\t1 <comment> \n \n \t1 try { \n \n \t2 hookRunner . runAfterExecutionHook ( queryStr , hookContext , executionError ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t8 accepted . remove ( source ) ; } } } \n \n \t4 } ; } } \n \n \t2 if ( ! availableSlot ) { \n \n \t3 <comment> \n \n <ect>
\t1 try { \n \n \t1 new LocalMapJoinProcFactory . LocalMapJoinProcessor ( ) . hasGroupBy ( mapJoinOp , \n \n \t2 context ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 List < SyncQueueItemVO > l = _queueMgr . dequeueFromAny ( getMsid ( ) , MAX_ONETIME_SCHEDULE_SIZE ) ; \n \n \t5 if ( l != null && l . size ( ) > 0 ) { \n \n \t6 for ( SyncQueueItemVO item : l ) { \n \n <ect>
\t7 <string_literal> , \n \n \t7 allowedDatetimeUpdateHour ) ; \n \n \t4 } else { \n \n \t5 allowedDatetimeUpdateHour = - 1 ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
public boolean isRegisterFor ( Class < ? > cls ) { \n \n \t1 return cls . isAssignableFrom ( MPrinter . class ) ; } \n \n @ Override \n \n public boolean preUpdate ( BeanPersistRequest < ? > request ) { \n \n <ect>
\t6 <comment> \n \n \t6 <comment> \n \n \t6 <comment> \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 if not definition_id in self . alerts_run_time : \n \n \t2 self . alerts_run_time [ definition_id ] = curr_time \n \n \t2 interval_seconds = definition [ 'interval' ] * <number_literal> \n \n \t2 if curr_time > self . alerts_run_time [ definition_id ] + ( interval_seconds * stale_interval_multiplier ) : \n \n <ect>
\t6 storeDef . getType ( ) + \n \n \t6 <string_literal> + \n \n \t6 ReadOnlyStorageConfiguration . TYPE_NAME ) ; \n \n \t4 continue ; } \n \n <ect>
\t6 while ( ! ( isStopping ( ) || isStopped ( ) ) && ( session == null || session . getSessionState ( ) . equals ( SessionState . CLOSED ) ) \n \n \t8 && attempt < configuration . getMaxReconnect ( ) ) { \n \n \t7 try { \n \n \t8 attempt ++ ; \n \n <ect>
\t2 LOG . info ( <string_literal> + result ) ; \n \n \t2 assertTrue ( <string_literal> + result , result . contains ( <string_literal> ) ) ; \n \n \t2 HashMap < String , String > propsAfter = new HashMap < String , String > ( ) ; \n \n \t2 IntrospectionSupport . getProperties ( runtimeConfigurationView , propsAfter , null ) ; \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 NSNotificationCenter . defaultCenter ( ) . postNotification ( \n \n \t6 ERMDDeleteButton . BUTTON_PERFORMED_DELETE_ACTION , obj , userInfo ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public Sampler next ( ) { \n \n \t2 if ( StringUtils . isEmpty ( getLockName ( ) ) ) { \n \n <ect>
\t4 Trace . addReceiver ( receiver ) ; \n \n \t4 logger . info ( <string_literal> , receiver ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t3 if ( isNotBlank ( mBID ) ) { \n \n \t4 LOGGER . debug ( <string_literal> { } \\ <string_literal> { } \\ <string_literal> , mBID , tagInfo ) ; \n \n \t4 TableMusicBrainzReleases . writeMBID ( mBID , tagInfo ) ; \n \n \t4 return mBID ; } \n \n <ect>
\t6 . startAt ( DateBuilder . futureDate ( <number_literal> + i , IntervalUnit . SECOND ) ) . withSchedule ( SimpleScheduleBuilder \n \n \t8 . repeatMinutelyForever ( eventRuntime . getConfig ( ) . getReloadMinutes ( ) ) ) \n \n \t6 . build ( ) ; \n \n \t4 this . scheduler . scheduleJob ( jobTrigger ) ; \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( leftCount != rightCount && CompactionManager . isCompactionManager . get ( ) ) \n \n \t3 { \n \n <ect>
\t4 if ( accessControlMaxAge != null ) { \n \n \t5 response . setAccessControlMaxAge ( accessControlMaxAge ) ; } \n \n \t3 } else { \n \n \t4 <comment> \n \n <ect>
\t3 catch ( SecurityException e ) { \n \n \t4 fallbackToTmp = true ; } \n \n \t3 finally { \n \n \t4 if ( fallbackToTmp ) \n \n <ect>
\t4 } else { \n \n \t5 <comment> \n \n \t5 encoders . add ( ChannelHandlerFactories . newObjectEncoder ( protocol ) ) ; \n \n \t5 decoders . add ( ChannelHandlerFactories . newObjectDecoder ( protocol ) ) ; \n \n <ect>
\t2 List < UserSessionModel > sessions1 = getSessions ( session1 ) ; \n \n \t2 List < UserSessionModel > sessions2 = getSessions ( session2 ) ; \n \n \t2 Assert . assertEquals ( <number_literal> , sessions1 . size ( ) ) ; \n \n \t2 Assert . assertEquals ( <number_literal> , sessions2 . size ( ) ) ; \n \n <ect>
\t3 s_logger . error ( msg , e ) ; \n \n \t3 return new GetVncPortAnswer ( cmd , msg ) ; } } \n \n \t1 protected Answer execute ( SetupCommand cmd ) { \n \n <ect>
\t2 if ( ! hasAPoolFs ( ) ) { \n \n \t3 return nullIsTrueCallWrapper ( <string_literal> , type , target , \n \n \t5 clustername , fsid , nfsbaseid , managerid , fsid ) ; \n \n \t2 } else if ( hasPoolFs ( fsid ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 public boolean add ( Setting setting ) { \n \n \t2 SimpleUri id = setting . getId ( ) ; \n \n \t2 if ( id == null ) { \n \n <ect>
\t2 return serviceToValidate . matches ( this . service ) ; } \n \n \t1 @ Override \n \n \t1 public ProxyGrantingTicket grantProxyGrantingTicket ( final String id , final Authentication authentication , final ExpirationPolicy expirationPolicy ) throws AbstractTicketException { \n \n \t2 if ( this . grantedTicketAlready ) { \n \n <ect>
\t4 remainingSpace -= spaceUsed ; } \n \n \t3 else if ( effectiveIndexInterval > maxIndexInterval ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t4 logger . info ( <string_literal> , addr , getLinkInfo ( dbes , addr ) ) ; \n \n \t4 dev . setHasModemDBEntry ( true ) ; } \n \n \t2 } else { \n \n \t3 if ( m_driver . isModemDBComplete ( ) && ! addr . isX10 ( ) ) { \n \n <ect>
\t6 for ( int i = 0 ; i < aks . length ; i ++ ) { \n \n \t7 forceDestinationWakeupOnCompletion ( context , transaction , aks [ i ] . getDestination ( ) , aks [ i ] ) ; } \n \n \t6 transaction . setState ( Transaction . PREPARED_STATE ) ; \n \n \t6 registerMBean ( transaction ) ; \n \n <ect>
public void populateResource ( Resource resource , InputStream inputStream ) throws SystemException { \n \n \t1 try { \n \n \t1 Map < String , Object > responseMap = GSON . fromJson ( IOUtils . toString ( inputStream , <string_literal> ) , MAP_TYPE ) ; \n \n \t1 if ( responseMap == null ) { \n \n <ect>
\t2 setHtml ( EntityUtils . toString ( entity ( ) ) ) ; \n \n \t2 } else { \n \n \t2 setHtml ( EntityUtils . toString ( entity ( ) , receiveEncoding ( ) ) ) ; } } } \n \n <ect>
\t7 task . setVmCreateImageTaskState ( CreateImageState . complete ) ; \n \n \t5 } else \n \n \t6 continue ; \n \n \t4 } catch ( final Exception ex ) { \n \n <ect>
\t4 LOG . debug ( <string_literal> ) ; } \n \n \t3 try ( final PreparedStatement updateStatement = conn . prepareStatement ( <string_literal> ) ) { \n \n \t4 updateStatement . executeUpdate ( ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t4 return null ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 LOG . warn ( <string_literal> + namespace + <string_literal> + kubernetes . getMasterUrl ( ) ) ; \n \n \t3 return null ; } \n \n <ect>
\t1 try { \n \n \t1 currentBinding . toOM ( eucaMsg , this . getNamespace ( ) ) ; \n \n \t1 } catch ( final RuntimeException e ) { \n \n \t1 LOG . error ( <string_literal> + operationName + <string_literal> + params ) ; \n \n <ect>
\t1 { \n \n \t2 switch ( type ) \n \n \t2 { \n \n \t2 case TOP_OF_MINUTE : \n \n <ect>
\t3 @ Override \n \n \t3 public void onTransaction ( Peer peer , Transaction tx ) { \n \n \t4 Result result = DefaultRiskAnalysis . FACTORY . create ( null , tx , NO_DEPS ) . analyze ( ) ; \n \n \t4 incrementCounter ( TOTAL_KEY ) ; \n \n <ect>
\t1 if ( null != w ) { \n \n \t2 try { \n \n \t2 w . close ( ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t6 privateNtwk = _ntwkSvc . createPrivateNetwork ( networkName , networkName , physicalNetworkIdFinal , broadcastUri , ipAddress , null , gateway , netmask , \n \n \t8 gatewayOwnerId , vpcId , isSourceNat , networkOfferingId ) ; \n \n \t5 } else { <comment> \n \n \t6 <comment> \n \n <ect>
\t1 { \n \n \t2 LOGGER . info ( <string_literal> ) ; \n \n \t2 checkedSleep ( timeout , unit ) ; \n \n \t2 store . put ( key , value ) ; \n \n <ect>
\t3 valBytes ) ; \n \n \t2 try { \n \n \t3 fileWriter . write ( null , kv ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 if ( ( new File ( userDataFilePath ) . exists ( ) ) ) { \n \n \t3 Script hardLink = new Script ( ! _inSystemVM , <string_literal> , _timeout , s_logger ) ; \n \n \t3 hardLink . add ( userDataFilePath ) ; \n \n \t3 hardLink . add ( tempDirName + openStackConfigDriveName + <string_literal> ) ; \n \n <ect>
\t2 executorService . shutdown ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 executorService . awaitTermination ( THREADPOOL_TERMINATION_TIMEOUT , TimeUnit . SECONDS ) ; \n \n \t2 pause ( ADDITIONAL_SLEEP_AFTER * <number_literal> ) ; \n \n <ect>
\t3 log . debug ( format ( <string_literal> , idx , convert ( idx ) ) ) ; \n \n \t2 idx = convert ( idx ) ; \n \n \t2 BPTreePage page = get ( idx , READ ) ; \n \n \t2 if ( logging ( ) ) \n \n <ect>
\t1 @ Override \n \n \t1 public void bindingChanged ( BindingProvider provider , String itemName ) { \n \n \t2 if ( context . getConfig ( ) . isValid ( ) ) { \n \n \t3 if ( provider instanceof AstroBindingProvider ) { \n \n <ect>
\t1 if ( is == null ) { \n \n \t2 <comment> \n \n \t2 if ( filesToRead . empty ( ) ) return false ; \n \n \t2 Path p = filesToRead . pop ( ) ; \n \n <ect>
\t3 return _default ; } \n \n \t2 try { \n \n \t3 return Integer . parseInt ( value ) ; \n \n \t2 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t3 bshInterpreter . set ( <string_literal> , jmctx . getPreviousResult ( ) ) ; <comment> \n \n \t3 bshInterpreter . set ( <string_literal> , JMeterUtils . getJMeterProperties ( ) ) ; \n \n \t3 bshInterpreter . set ( <string_literal> , vars ) ; <comment> \n \n \t2 } catch ( JMeterException e ) { \n \n <ect>
\t2 waitForBridgeFormation ( 1 ) ; \n \n \t2 HashSet < NetworkBridge > bridgesStart = new HashSet < NetworkBridge > ( ) ; \n \n \t2 for ( NetworkConnector networkConnector : networkConnectors ) { \n \n \t3 bridgesStart . addAll ( networkConnector . activeBridges ( ) ) ; } \n \n <ect>
\t2 if ( SystemProperties . getBoolean ( USE_NATIVE_CLOCK_SYSTEM_PROPERTY , true ) && Native . isGettimeofdayAvailable ( ) ) { \n \n \t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 return new NativeClock ( ) ; \n \n \t2 } else { \n \n <ect>
\t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( InvocationTargetException e ) { \n \n <ect>
\t2 Function . ReadFunction readFunction = Function . ReadFunction . getFunction ( topNConfig . getTopNFunction ( ) ) ; \n \n \t2 Function function = new Function ( readFunction , null ) ; \n \n \t2 conditionBuilder . topNFunction ( function ) ; \n \n \t1 } else { \n \n <ect>
\t1 private void handleError ( String msg ) { \n \n \t2 _collector . reportError ( new Exception ( <string_literal> + msg ) ) ; } \n \n \t1 @ Override \n \n \t1 public void activate ( ) { \n \n <ect>
\t1 private final Cipher encryptCipher ; \n \n \t1 private final Cipher decryptCipher ; \n \n \t1 private volatile boolean stop ; \n \n \t1 public UDPBroadcaster ( String config ) { \n \n <ect>
\t3 int adjustedLimit = query . hasLimit ( ) ? query . getLimit ( ) : Integer . MAX_VALUE - 1 ; \n \n \t3 if ( adjustedLimit < Integer . MAX_VALUE - 1 - offset ) adjustedLimit += offset ; \n \n \t3 else adjustedLimit = Integer . MAX_VALUE - 1 ; \n \n \t3 TopDocs docs = searcher . search ( q , adjustedLimit ) ; \n \n <ect>
\t4 <comment> \n \n \t4 final long t1 = System . currentTimeMillis ( ) ; \n \n \t4 ns2 . runBackgroundOperations ( ) ; <comment> \n \n \t4 final long t2 = System . currentTimeMillis ( ) ; \n \n <ect>
\t1 ConfigFilterType srcType = ConfigFilterType . OTHER ; \n \n \t1 try { \n \n \t1 srcType = ConfigFilterType . valueOf ( type . toUpperCase ( Locale . ENGLISH ) ) ; \n \n \t1 } catch ( IllegalArgumentException ex ) { \n \n <ect>
\t3 DataHelper . storeProps ( config , conf ) ; \n \n \t3 if ( _log . shouldInfo ( ) ) \n \n \t4 _log . info ( <string_literal> + conf ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t2 al . add ( any ) ; \n \n \t2 new Exclude ( al ) ; } \n \n \t1 @ Test ( expected = IllegalArgumentException . class ) \n \n \t1 public void testExcludeArrayListOfElementFails3 ( ) { \n \n <ect>
\t6 else if ( Options . v ( ) . verbose ( ) ) \n \n \t7 logger . debug ( <string_literal> + String . format ( <string_literal> , \n \n \t9 className , container . getDexName ( ) , container . getFilePath ( ) . getCanonicalPath ( ) ) ) ; } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 c = new Connection ( host , port , key ) ; \n \n \t5 connected = true ; \n \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \n \t3 try { \n \n \t4 socket . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 throw new CloudRuntimeException ( <string_literal> + host . getName ( ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 s_logger . warn ( <string_literal> + host + <string_literal> + dataStore , e ) ; } } \n \n \t2 if ( poolHosts . isEmpty ( ) ) { \n \n <ect>
\t2 if ( url . equals ( <string_literal> ) && certFileName == null ) { \n \n \t3 s_logger . error ( <string_literal> ) ; \n \n \t3 System . exit ( 1 ) ; } \n \n \t2 if ( secretKey == null ) { \n \n <ect>
\t2 command . add ( <string_literal> ) ; \n \n \t2 command . add ( <string_literal> ) ; \n \n \t2 result = command . execute ( ) ; \n \n \t2 if ( result != null ) { \n \n <ect>
\t5 logger . trace ( <string_literal> ) ; \n \n \t4 imConversation . sendMessage ( new SimpleMessage ( sysMsg . toString ( ) ) ) ; } \n \n \t3 catch ( Exception ex ) \n \n \t3 { \n \n <ect>
\t3 return false ; } \n \n \t2 final String clientId = context . getRequestParameter ( OAuth20Constants . CLIENT_ID ) ; \n \n \t2 final OAuthRegisteredService registeredService = getRegisteredServiceByClientId ( clientId ) ; \n \n \t2 if ( ! validator . checkServiceValid ( registeredService ) ) { \n \n <ect>
\t3 VersionNumber vn = new VersionNumber ( versionedName ) ; \n \n \t3 Assert . assertTrue ( t . equals ( vn . getAsTime ( ) ) ) ; \n \n \t3 <comment> \n \n \t3 Thread . sleep ( 1 ) ; } \n \n <ect>
\t5 boolean assignToVpcNtwk = network . getVpcId ( ) != null && ipVO . getVpcId ( ) != null && ipVO . getVpcId ( ) . longValue ( ) == network . getVpcId ( ) ; \n \n \t5 if ( assignToVpcNtwk ) { \n \n \t6 <comment> \n \n \t6 _networkModel . checkIpForService ( ipVO , Service . Lb , networkId ) ; \n \n <ect>
\t2 final Conditions conditions = this . samlObjectBuilder . newConditions ( issuedAt , service . getId ( ) , this . issueLength ) ; \n \n \t2 assertion . setConditions ( conditions ) ; \n \n \t2 LOGGER . debug ( <string_literal> , this . issuer , service . getId ( ) ) ; \n \n \t2 final Subject subject = this . samlObjectBuilder . newSubject ( principal . getId ( ) ) ; \n \n <ect>
\t7 break ; } } \n \n \t5 LOG . info ( <string_literal> + original . getQueueName ( ) + <string_literal> + index + <string_literal> + blockSize + <string_literal> ) ; \n \n \t5 connection . close ( ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 private File getWorkingDirForUser ( final String username ) throws IOException { \n \n \t2 final File userDir = getOrCreateSvnUserDirectory ( username ) ; \n \n <ect>
\t2 if ( ! deployment . getRealm ( ) . equals ( account . getKeycloakSecurityContext ( ) . getRealm ( ) ) ) { \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( account . checkActive ( ) ) { \n \n <ect>
<comment> \n \n void beanCacheRemove ( Object id ) { \n \n \t1 if ( beanCache != null ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , cause ) ; } \n \n \t2 if ( notifier != null ) { \n \n \t3 notifier . onFailure ( context , cause ) ; } \n \n \t2 if ( cause instanceof InterruptedException || cause instanceof InterruptedIOException ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t2 if ( grid . getTileSize ( ) == null ) { \n \n \t3 logger . error ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 if ( grid . getGridDimensions ( ) == null ) { \n \n <ect>
<comment> \n \n \t1 public void setKeyObtentionIterations ( final String iter ) { \n \n \t2 if ( StringUtils . isNotBlank ( iter ) && NumberUtils . isCreatable ( iter ) ) { \n \n <ect>
\t2 String columnNoStr = parameter . substring ( pos1 + <number_literal> ) ; \n \n \t2 int columnNo = Integer . parseInt ( columnNoStr ) ; \n \n \t2 if ( PentahoSystem . debug ) { \n \n \t2 TemplateUtil . logger . debug ( <string_literal> + inputName ) ; <comment> \n \n <ect>
\t1 verifyImport ( <string_literal> + seqFileVal , checkCols ) ; } \n \n @ Test \n \n public void testClob1 ( ) { \n \n \t1 if ( ! supportsClob ( ) ) { \n \n <ect>
\t3 if ( this . jwksFile != null ) { \n \n \t4 LOGGER . debug ( <string_literal> , this . jwksFile ) ; \n \n \t4 final JsonWebKeySet jsonWebKeySet = buildJsonWebKeySet ( this . jwksFile ) ; \n \n \t4 if ( jsonWebKeySet == null || jsonWebKeySet . getJsonWebKeys ( ) . isEmpty ( ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected void doCatch ( Throwable e ) throws Throwable { \n \n \t2 <comment> \n \n \t2 state = BillingWorkflowState . WORKFLOW_FAILED ; \n \n <ect>
\t3 if ( transport != null ) { \n \n \t4 try { \n \n \t5 transport . close ( ) ; \n \n \t4 } catch ( MessagingException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 String cidrSubnet = NetUtils . getCidrSubNet ( cidrAddress , cidrSize ) ; \n \n \t2 String serverSubnet = NetUtils . getSubNet ( serverPrivateIP , serverPrivateNetmask ) ; \n \n \t2 if ( ! cidrSubnet . equals ( serverSubnet ) ) { \n \n <ect>
\t1 protected Log logger = LogFactory . getLog ( RejectAndDontRequeueRecoverer . class ) ; \n \n \t1 @ Override \n \n \t1 public void recover ( Message message , Throwable cause ) { \n \n <ect>
\t4 final String snapshotFile = snapshotDestPath + <string_literal> + snapshotName ; \n \n \t4 try { \n \n \t5 s_logger . debug ( <string_literal> + rbdSnapshot ) ; \n \n \t5 final File snapDir = new File ( snapshotDestPath ) ; \n \n <ect>
<comment> \n \n \t3 status = Curator . CURATE_SUCCESS ; \n \n \t3 String handle = item . getHandle ( ) ; \n \n <ect>
\t2 totalQueries += dbpojoHiveSavedQuery . size ( ) ; \n \n \t2 logger . info ( <string_literal> + username ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 for ( i = 0 ; i < dbpojoHiveSavedQuery . size ( ) ; i ++ ) { \n \n <ect>
\t3 log . warn ( <string_literal> , indexPath ) ; \n \n \t3 return false ; } \n \n \t2 IndexInfoProvider infoProvider = infoProviders . get ( type ) ; \n \n \t2 if ( infoProvider == null ) { \n \n <ect>
\t2 } catch ( SmbException exc ) { \n \n \t3 throw new RuntimeIOException ( format ( <string_literal> , smbFile . getUncPath ( ) , exc . toString ( ) ) , exc ) ; } } \n \n \t1 @ Override \n \n \t1 public InputStream getInputStream ( ) throws RuntimeIOException { \n \n <ect>
\t7 QName typeName = part . getTypeName ( ) ; \n \n \t7 SchemaType type = typeName == null ? null : wsdlContext . getSchemaTypeLoader ( ) . findType ( typeName ) ; \n \n \t7 messageParts . add ( new MessageXmlPart ( children [ 0 ] , type , part , bindingOperation , isRequest ) ) ; } \n \n \t5 } else if ( children . length != 1 ) { \n \n <ect>
\t1 if ( ! m . matches ( ) ) { \n \n \t1 unmatchedRowsCount ++ ; \n \n \t2 if ( ! alreadyLoggedNoMatch ) { \n \n \t2 <comment> \n \n <ect>
\t2 this . log = log ; } \n \n \t1 @ Override \n \n \t1 public void corruptedLogFile ( long version , Throwable t ) \n \n \t1 { \n \n <ect>
\t2 if ( remoteSolrServerConfiguration . getSolrZkHost ( ) != null && remoteSolrServerConfiguration . getSolrZkHost ( ) . length ( ) > 0 ) { \n \n \t3 try { \n \n \t4 solrServer = initializeWithCloudSolrServer ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 PaginatedResult < ObjectEntity > result ; \n \n \t1 try { \n \n \t1 result = ObjectMetadataManagers . getInstance ( ) . listPaginated ( bucket , maxKeys , request . getPrefix ( ) , request . getDelimiter ( ) , request . getMarker ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 stream = new FileOutputStream ( destFile ) ; \n \n \t4 stream . write ( fileData ) ; \n \n \t4 LOGGER . info ( <string_literal> + needCode ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 protected void pruneUntilMinimal ( OWLClassExpression unsatClass ) throws OWLException { \n \n \t2 LOGGER . info ( <string_literal> , Integer . valueOf ( debuggingAxioms . size ( ) ) ) ; \n \n \t2 resetSatisfiabilityTestCounter ( ) ; \n \n <ect>
\t5 throw new StoreOperationFailureException ( String . format ( <string_literal> , \n \n <number_literal> def . getName ( ) ) ) ; } } \n \n \t2 } catch ( VoldemortException e ) { \n \n \t3 response . setError ( ProtoUtils . encodeError ( errorCodeMapper , e ) ) ; \n \n <ect>
\t1 s . setRange ( MetadataSchema . ReplicationSection . getRange ( ) ) ; \n \n \t1 for ( Entry < Key , Value > entry : s ) { \n \n \t2 log . info ( <string_literal> , entry . getKey ( ) . toStringNoTruncate ( ) , \n \n \t3 ProtobufUtil . toString ( Status . parseFrom ( entry . getValue ( ) . get ( ) ) ) ) ; } \n \n <ect>
\t3 result = new FileInputStream ( execResult . getCommand ( ) . getOutFile ( ) ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n \t3 if ( execResult . getStdout ( ) == null && execResult . getCommand ( ) . isUseStderrOnEmptyStdout ( ) ) { \n \n <ect>
\t3 for ( File child : files ) { \n \n \t4 recursivelyDeleteDirectory ( child ) ; } } \n \n \t2 boolean success = file . delete ( ) ; \n \n \t2 if ( ! success ) { \n \n <ect>
\t5 <comment> \n \n \t5 off += fragments [ i ] . getValid ( ) ; } \n \n \t4 if ( off != state . getCompleteSize ( ) ) { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 try { \n \n \t2 HiveQueryId parsedJob = parseAtsHiveJob ( ( JSONObject ) job ) ; \n \n \t2 parsedJobs . add ( parsedJob ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 OpAttr [ ] inputs = new OpAttr [ inputsList . size ( ) ] ; \n \n \t1 for ( int i = 0 ; i < inputs . length ; i ++ ) { \n \n \t1 inputs [ i ] = dispatch ( inputsList . get ( i ) ) ; } \n \n <ect>
\t3 pstmt . executeBatch ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t3 if ( ! wakeup . isAwake ( ) ) { \n \n \t4 logger . debug ( <string_literal> , wakeup . getNode ( ) . getNodeId ( ) ) ; \n \n \t4 return ; } \n \n \t3 <comment> \n \n <ect>
\t2 syncWork . toRestartInUse . add ( sessionToDestroy ) ; } } \n \n \t1 e . toDestroy . clear ( ) ; \n \n \t1 <comment> \n \n \t1 for ( WmTezSession sessionToReturn : e . toReturn ) { \n \n <ect>
\t1 protected AuthenticationHandlerExecutionResult doAuthentication ( final Credential credential ) throws GeneralSecurityException { \n \n \t2 final YubiKeyCredential yubiKeyCredential = ( YubiKeyCredential ) credential ; \n \n \t2 final String otp = yubiKeyCredential . getToken ( ) ; \n \n \t2 if ( ! YubicoClient . isValidOTPFormat ( otp ) ) { \n \n <ect>
public void close ( ) throws IOException { \n \n \t1 LlapIoImpl . LOG . trace ( <string_literal> , \n \n \t2 isClosed , isInterrupted , pendingError . get ( ) , queue . size ( ) ) ; } \n \n <ect>
\t2 for ( CacheEventListener listener : listeners ) { \n \n \t3 try { \n \n \t4 listener . onFlush ( event ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 . EXEC_TIMEOUT_NAME + <string_literal> ; \n \n \t1 LOG . warn ( <string_literal> + cmd + msg + <string_literal> + res ) ; \n \n \t1 res . stderr += <string_literal> + msg ; } \n \n \t1 if ( res . exitcode != 0 ) { \n \n <ect>
\t2 try { \n \n \t3 topologyConf . remove ( ConfigExtension . TOPOLOGY_UPGRADE_FLAG ) ; \n \n \t3 submitTopology ( name , topologyCodeLocation , JStormUtils . to_json ( topologyConf ) , topology ) ; \n \n \t2 } catch ( AlreadyAliveException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 public void sendCommand ( HttpClient client , Connection conn ) { \n \n \t2 if ( TestCaseEngine . _printUrl == true ) \n \n \t2 { \n \n <ect>
\t2 if ( position < 0 || position > maxColumn ) { \n \n \t3 logger . error ( <string_literal> , maxColumn ) ; \n \n \t3 return ; } \n \n \t2 if ( line < 0 || line > maxLine ) { \n \n <ect>
\t3 UserVmVO vm = _vmDao . findById ( vmId ) ; \n \n \t3 vmNames . add ( vm . getInstanceName ( ) ) ; } \n \n \t2 Answer answer = _agentMgr . easySend ( hostId , new GetVmStatsCommand ( vmNames , _hostDao . findById ( hostId ) . getGuid ( ) , hostName ) ) ; \n \n \t2 if ( answer == null || ! answer . getResult ( ) ) { \n \n <ect>
\t2 { \n \n \t3 reconnect ( publicAddress , InetAddress . getByName ( localAddressValue . value ) ) ; } \n \n \t2 catch ( UnknownHostException e ) \n \n \t2 { \n \n <ect>
\t4 if ( approval . getStatus ( ) == ApprovalStatus . APPROVED ) { \n \n \t5 validUserApprovedScopes . add ( approval . getScope ( ) ) ; \n \n \t5 approvedScopes . add ( approval . getScope ( ) ) ; } } } \n \n <ect>
\t1 public BindingReport ( ) { \n \n \t2 this ( <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void call ( Injector injector ) { \n \n <ect>
\t2 if ( null != entry . getKey ( ) ) { \n \n \t2 nullByte | = 1 < < ( b % <number_literal> ) ; \n \n \t2 } else if ( warnedOnceNullMapKey != null ) { \n \n \t2 if ( ! warnedOnceNullMapKey . value ) { \n \n <ect>
\t2 LOG . info ( <string_literal> + sanSnapshotId + <string_literal> ) ; \n \n \t2 storageResource = connectionManager . connectTarget ( iqn , lun ) ; \n \n \t2 storageResource . setId ( snapshotId ) ; \n \n \t2 } catch ( Exception connEx ) { \n \n <ect>
\t2 try { \n \n \t3 request . writeTo ( out ) ; \n \n \t3 server . send ( dest , out . buffer ( ) , 0 , out . position ( ) ) ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
<comment> \n \n \t1 protected String getRegisteredServiceJwtProperty ( final RegisteredService service , final RegisteredServiceProperty . RegisteredServiceProperties propName ) { \n \n \t2 if ( service == null || ! service . getAccessStrategy ( ) . isServiceAccessAllowed ( ) ) { \n \n <ect>
\t4 return new FenceAnswer ( cmd , false , <string_literal> ) ; \n \n \t3 } else { \n \n \t4 return new FenceAnswer ( cmd ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t3 s_logger . info ( <string_literal> + responseCode ) ; \n \n \t3 if ( responseCode == <number_literal> ) { \n \n \t4 InputStream is = method . getResponseBodyAsStream ( ) ; \n \n \t4 Map < String , String > success = getSingleValueFromXML ( is , new String [ ] { <string_literal> } ) ; \n \n <ect>
static void speedTestHashLogger ( final int len ) { \n \n \t1 final HLogger logger = hashLoggerContext . getLogger ( loggerName ) ; \n \n \t1 long start = System . nanoTime ( ) ; \n \n \t1 for ( int i = 0 ; i < len ; i ++ ) { \n \n <ect>
\t2 File exportFile = File . createTempFile ( <string_literal> , <string_literal> ) ; \n \n \t2 Path exportPath = Paths . get ( URI . create ( <string_literal> + exportFile . getAbsolutePath ( ) ) ) ; \n \n \t2 client ( <string_literal> ) . index ( new IndexRequest ( ) . index ( <string_literal> ) . type ( <string_literal> ) . id ( <string_literal> ) . source ( <string_literal> , <string_literal> ) . refresh ( true ) ) . actionGet ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t4 dbProp = new Properties ( ) ; } \n \n \t3 try { \n \n \t4 dbProp . load ( new FileInputStream ( propertiesFile ) ) ; \n \n \t3 } catch ( FileNotFoundException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public Boolean call ( ) { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 for ( String databaseName : Iterables . filter ( Databases . getBootstrapper ( ) . listDatabases ( ) , DatabaseFilters . OLDVERSION ) ) { \n \n <ect>
\t5 return new UsernamePasswordAuthenticationToken ( username , password , authorities ) ; } \n \n \t4 LOGGER . warn ( <string_literal> , \n \n \t6 username , authorizer . getElements ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 long time = watch . stop ( ) ; \n \n \t3 Logger log = LoggerFactory . getLogger ( testContext . getTestClass ( ) ) ; \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 log . info ( <string_literal> + testContext . getTestMethod ( ) . getName ( ) + <string_literal> + testContext . getTestClass ( ) . getName ( ) + <string_literal> ) ; \n \n <ect>
\t6 else if ( currentToken . equals ( endToken ) ) { \n \n \t7 return true ; } \n \n \t5 } catch ( Exception e ) { \n \n \t6 error . compareAndSet ( null , e ) ; \n \n <ect>
\t1 final boolean valid = Boolean . parseBoolean ( builder . evaluate ( packIt , <string_literal> ) . toString ( ) ) ; \n \n \t1 if ( ! valid ) { \n \n \t1 final String json = builder . addJSON ( ) . evaluate ( \n \n \t2 String . format ( <string_literal> , getLinterName ( ) ) , <string_literal> ) . toString ( ) ; \n \n <ect>
\t2 if ( ! initialized ) { \n \n \t3 ApplicationContext applicationContext = ( ApplicationContext ) ActionContext . getContext ( ) . getApplication ( ) . get ( \n \n \t5 WebApplicationContext . ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE ) ; \n \n \t3 if ( applicationContext == null ) { \n \n <ect>
public Double runningAverage ( ) { \n \n \t1 return ( Double ) storedValueForKey ( _Voting . RUNNING_AVERAGE_KEY ) ; } \n \n public void setRunningAverage ( Double value ) { \n \n <ect>
\t3 try { \n \n \t4 fi = new FileInputStream ( cfg ) ; \n \n \t4 props . load ( fi ) ; \n \n \t3 } catch ( FileNotFoundException fnfe ) { \n \n <ect>
\t3 return ( ( LabeledLink ) this ) . copy ( newId ) ; \n \n \t2 else if ( this instanceof CompactLink ) \n \n \t3 return ( ( CompactLink ) this ) . copy ( newId ) ; \n \n \t2 else { \n \n <ect>
\t6 getTimer ( taskDefinition ) . scheduleAtFixedRate ( schedulerTask , \n \n \t7 SchedulerConstants . SCHEDULER_DEFAULT_DELAY , repeatInterval ) ; \n \n \t5 } else { \n \n \t6 <comment> \n \n <ect>
\t3 success = false ; } \n \n \t2 <comment> \n \n \t2 final List < FirewallRuleVO > firewallIngressRulesToApply = _firewallDao . listByNetworkPurposeTrafficType ( networkId , Purpose . Firewall , FirewallRule . TrafficType . Ingress ) ; \n \n \t2 if ( ! _firewallMgr . applyFirewallRules ( firewallIngressRulesToApply , false , caller ) ) { \n \n <ect>
\t2 String blockedNode = blockNodeWithIndex ( <string_literal> , <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) \n \n \t3 . setWaitForCompletion ( false ) . setIncludeGlobalState ( false ) . setIndices ( <string_literal> ) . get ( ) ; \n \n <ect>
\t2 public Boolean call ( ) { \n \n \t3 try { \n \n \t3 new ClusterAllocator ( allocInfo , config ) . run ( ) ; \n \n \t3 } catch ( final Exception ex ) { \n \n <ect>
\t2 } catch ( I2PSessionException e ) { \n \n \t3 _log . error ( <string_literal> , e ) ; \n \n \t3 return writeString ( SESSION_ERROR , e . getMessage ( ) ) ; \n \n \t2 } catch ( SAMException e ) { \n \n <ect>
\t3 sProp = sProperty ; \n \n \t3 sProp . addCallback ( new Runnable ( ) { \n \n \t4 @ Override \n \n \t4 public void run ( ) { \n \n <ect>
\t5 if ( upnString != null ) { \n \n \t6 return upnString ; } } } \n \n \t2 } catch ( final CertificateParsingException e ) { \n \n \t3 LOGGER . error ( <string_literal> , e ) ; \n \n <ect>
\t3 throw new RuntimeException ( e ) ; } } \n \n \t1 public static void modifyDocElementAttribute ( Document doc , String tagName , String attributeName , String regex , String replacement ) { \n \n \t2 NodeList nodes = doc . getElementsByTagName ( tagName ) ; \n \n \t2 if ( nodes . getLength ( ) != 1 ) { \n \n <ect>
\t4 log . debug ( <string_literal> , source ) ; \n \n \t4 source . init ( ) ; \n \n \t4 sourceList . add ( source ) ; \n \n \t3 } else { \n \n <ect>
\t6 s_logger . debug ( <string_literal> + _gson . toJson ( deviceConfigSpecArray [ i ] ) ) ; \n \n \t5 i ++ ; \n \n \t4 } else { \n \n <ect>
\t3 return resumeFlow ( ) ; } \n \n \t2 if ( result . getValue ( ) . isPresent ( ) ) { \n \n \t3 return CollectionUtils . wrapSet ( validateEventIdForMatchingTransitionInContext ( id , context , \n \n \t4 buildEventAttributeMap ( authentication . getPrincipal ( ) , service , result . getValue ( ) . get ( ) ) ) ) ; } \n \n <ect>
\t2 if ( result . isEmpty ( ) ) { \n \n \t3 return Response . status ( Status . NOT_FOUND ) . build ( ) ; } \n \n \t2 return Response . ok ( result . get ( 0 ) ) . build ( ) ; } \n \n \t1 private void createProtectedResource ( Album album ) { \n \n <ect>
\t4 player . join ( ) ; \n \n \t3 } catch ( SynthesisException e ) { \n \n \t4 logger . error ( <string_literal> , e . getLocalizedMessage ( ) , e ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t1 * \n \n \t1 * } catch ( Exception e ) { s_logger . warn ( <string_literal> , e ) ; } \n \n \t1 * finally { try { if ( rs != null ) { rs . close ( ) ; } if ( pstmt != null ) { \n \n \t1 * pstmt . close ( ) ; } txn . commit ( ) ; } catch ( SQLException sqle ) { \n \n <ect>
\t1 public ItemsVO doCreateItemsTableIfNot ( ItemsVO vo ) { \n \n \t2 String sql = StringUtilsExt . replaceArrayMerge ( SQL_CREATE_ITEMS_TABLE_IF_NOT , \n \n \t4 new String [ ] { <string_literal> , <string_literal> , <string_literal> , <string_literal> } , \n \n \t4 new String [ ] { vo . getItemsManageTable ( ) , vo . getColname ( ) , vo . getColtype ( ) , vo . getItemsManageTable ( ) } ) ; \n \n <ect>
\t2 } catch ( ResourceUnavailableException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . RESOURCE_UNAVAILABLE_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ConcurrentOperationException ex ) { \n \n <ect>
\t1 assertThat ( id ) . isEqualTo ( 1L ) ; \n \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 Object val = s . nextId ( null ) ; \n \n \t1 log . warn ( <string_literal> + val ) ; } \n \n <ect>
\t3 } else if ( isPosixJNAAffinityUsable ( ) ) { \n \n \t4 LOGGER . trace ( <string_literal> ) ; \n \n \t4 AFFINITY_IMPL = PosixJNAAffinity . INSTANCE ; \n \n \t3 } else { \n \n <ect>
\t3 } catch ( CmsException e ) { \n \n \t4 LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } \n \n \t2 <comment> \n \n \t2 String result = ancestors . get ( 0 ) ; \n \n <ect>
\t2 String s = <string_literal> + extLockId + <string_literal> + \n \n \t2 <string_literal> + LOCK_WAITING + <string_literal> ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 if ( PropertyUtils . isWriteable ( target , name ) && properties . containsKey ( key ) ) { \n \n \t4 try { \n \n \t5 String value = context . expand ( String . valueOf ( properties . get ( key ) ) ) ; \n \n \t5 BeanUtils . setProperty ( target , name , value ) ; \n \n <ect>
\t1 if ( ! vm . isUsePrivateAddressing ( ) && \n \n \t2 ( VmState . PENDING . equals ( vm . getState ( ) ) || VmState . RUNNING . equals ( vm . getState ( ) ) ) ) { \n \n \t2 assignSystemAddress ( vm ) ; } \n \n \t1 } catch ( final NotEnoughResourcesException e ) { \n \n <ect>
\t2 spanPage = bf . file . readUnsignedInt ( ) ; \n \n \t2 bottom = bsl . spanHash . get ( Integer . valueOf ( spanPage ) ) ; \n \n \t2 if ( bottom == null ) { \n \n \t3 <comment> \n \n <ect>
\t2 _geoIP = new GeoIP ( _context ) ; \n \n \t2 _manager = new TransportManager ( _context ) ; \n \n \t2 startGeoIP ( ) ; } \n \n \t1 public synchronized void startup ( ) { \n \n <ect>
\t4 while ( ( entry = in . getNextEntry ( ) ) != null ) { \n \n \t5 String oriName = entry . getName ( ) ; \n \n \t5 String filename = directory . getAbsolutePath ( ) + File . separator + oriName ; \n \n \t5 if ( entry . isDirectory ( ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 @ Override \n \n \t1 public void teardownTest ( BackendListenerContext context ) throws Exception { \n \n <ect>
\t2 if ( addVif ) { \n \n \t3 args += <string_literal> ; } \n \n \t2 final String command = String . format ( <string_literal> , <string_literal> , VRScripts . IPASSOC , args ) ; \n \n <ect>
\t8 <string_literal> + me . getRecall ( ) + \n \n \t8 <string_literal> + elapsedTimeSec + \n \n \t8 <string_literal> + correctModel . getAccuracy ( ) + \n \n \t8 <string_literal> + correctModel . getMrr ( ) ) ; \n \n <ect>
\t6 savedConn = null ; <comment> \n \n \t6 conn . disconnect ( ) ; } \n \n \t5 setUseKeepAlive ( false ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t4 if ( ! allAttrReceived ) \n \n \t5 U . sleep ( <number_literal> ) ; } \n \n \t4 for ( Map . Entry < String , Integer > entry : receivedParams . entrySet ( ) ) \n \n <ect>
private static final Logger LOG = LoggerFactory . getLogger ( RetryPolicy . class ) ; \n \n private RetryPolicy ( ) { } \n \n @ Override \n \n public void handle ( Event event , Throwable cause ) throws EventDeliveryException { \n \n <ect>
\t5 public boolean process ( final Exchange exchange , final AsyncCallback callback ) { \n \n \t6 LOGGER . info ( <string_literal> ) ; \n \n \t6 return super . process ( exchange , new AsyncCallback ( ) { \n \n \t7 public void done ( final boolean doneSync ) { \n \n <ect>
\t2 FunctionRegistry . getFunctionNames ( <string_literal> ) ) ; \n \n \t1 for ( Function function : getAllFunctions ( ) ) { \n \n \t1 String functionName = function . getFunctionName ( ) ; \n \n \t1 try { \n \n <ect>
public synchronized void stop ( ) { \n \n \t1 LOGGER . info ( <string_literal> , getName ( ) ) ; \n \n \t1 twitterStream . shutdown ( ) ; \n \n \t1 super . stop ( ) ; \n \n <ect>
\t3 String name = ( String ) entry . getKey ( ) ; \n \n \t3 if ( ! IGNORE_SYS_PROPS . contains ( name ) ) { \n \n \t4 if ( name . startsWith ( <string_literal> ) && ! name . startsWith ( IGNORE_TEST_SYS_PROPS ) ) { \n \n \t5 if ( configuration . get ( name ) == null ) { \n \n <ect>
\t6 if ( i < usages . size ( ) ) { \n \n \t7 usage = <string_literal> + usages . get ( i ) ; } } \n \n \t5 s_logger . info ( <string_literal> + desc + usage ) ; } } \n \n \t2 } else { \n \n <ect>
\t2 String outputFileName = resourceName . substring ( resourceName . lastIndexOf ( <string_literal> ) + 1 ) ; \n \n \t2 try { \n \n \t3 outputFileName = configuration . getTempFolder ( ) + <string_literal> + outputFileName ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 confDirPath = confDir . getCanonicalPath ( ) ; \n \n \t1 File logDir = new File ( baseDir , <string_literal> ) ; \n \n \t1 logDir . mkdirs ( ) ; \n \n \t1 logDirPath = logDir . getCanonicalPath ( ) ; \n \n <ect>
\t1 try { \n \n \t1 return getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; \n \n \t1 } catch ( final RhinoException e ) { \n \n \t1 final String message = RhinoUtils . createExceptionMessage ( e ) ; \n \n <ect>
\t5 if ( ! ( returnType == void . class ) ) { \n \n \t6 request . setAttribute ( extractor . nameFor ( returnType ) , result ) ; } \n \n \t5 if ( ! response . isCommitted ( ) ) { \n \n \t6 String path = resolver . pathFor ( DefaultResourceMethod . instanceFor ( type , method ) ) ; \n \n <ect>
\t4 log . debug ( <string_literal> + template . getDefaultDestinationName ( ) ) ; } \n \n \t3 Connection conn = template . getConnectionFactory ( ) . createConnection ( ) ; \n \n \t3 JmsUtils . closeConnection ( conn ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n \t2 if ( itemName == null ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t2 metadataProvider . setId ( metadataProvider . getClass ( ) . getCanonicalName ( ) ) ; \n \n \t2 buildMetadataFilters ( service , metadataProvider , metadataFilterList ) ; \n \n \t2 LOGGER . debug ( <string_literal> , service . getMetadataLocation ( ) ) ; \n \n \t2 metadataProvider . initialize ( ) ; \n \n <ect>
\t3 return netInfo != null && netInfo . isConnected } \n \n \t1 override fun loadTasksFromFile ( path : String ) : RemoteContents { \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 return received . size ( ) == SPLIT_COUNT ? GridComputeJobResultPolicy . REDUCE : GridComputeJobResultPolicy . WAIT ; } \n \n \t2 <comment> \n \n \t2 @ Override public Integer reduce ( List < GridComputeJobResult > results ) throws GridException { \n \n <ect>
\t3 if ( optionalOfferings != null && ! optionalOfferings . isEmpty ( ) ) { \n \n \t4 if ( networks != null && ! networks . isEmpty ( ) ) { \n \n \t5 for ( CloudStackNetwork network : networks ) { \n \n \t6 for ( CloudStackNetworkOffering optionalOffering : optionalOfferings ) { \n \n <ect>
\t1 import params \n \n \t1 env . set_params ( params ) \n \n \t1 hive_interactive ( name = 'hiveserver2' ) \n \n \t1 def pre_upgrade_restart ( self , env , upgrade_type = None ) : \n \n <ect>
\t4 <comment> \n \n \t4 if ( ctx . type ( ) == ExecuteType . BATCH ) \n \n \t5 log . debug ( <string_literal> , newline + ctx . sql ( ) ) ; \n \n \t4 else \n \n <ect>
\t2 this . log = logProvider . getLog ( getClass ( ) ) ; \n \n \t2 bindingListener = me - > \n \n \t2 { \n \n \t3 serverClusterId = me ; \n \n <ect>
\t4 if ( fs . getType ( ) == FileSystem . TYPE_LOCAL_DISK ) { \n \n \t5 disks . add ( fs . getDevName ( ) ) ; } } \n \n \t3 logger . debug ( <string_literal> , Arrays . toString ( disks . toArray ( ) ) ) ; \n \n \t2 } catch ( SigarException e ) { \n \n <ect>
\t3 public void operationComplete ( ChannelFuture future ) throws Exception { \n \n \t4 long durationNanos = System . nanoTime ( ) - creationNanos ; \n \n \t4 long durationMillis = TimeUnit . MILLISECONDS . convert ( durationNanos , TimeUnit . NANOSECONDS ) ; \n \n \t4 if ( future . isSuccess ( ) ) { \n \n <ect>
<number_literal> voldemortConfig . getNioAcceptorBacklog ( ) , \n \n <number_literal> voldemortConfig . getNioSelectorMaxHeartBeatTimeMs ( ) ) ; \n \n \t4 onlineServices . add ( nioSocketService ) ; \n \n \t3 } else { \n \n <ect>
\t4 return ; \n \n \t3 } else { \n \n \t4 state . setIsSuccessful ( true ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 this . handler = handler ; \n \n \t2 try { \n \n \t3 graphDb = ( DatabaseService ) StructrApp . getInstance ( ) . command ( GraphDatabaseCommand . class ) . execute ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t4 producer . send ( message ) ; \n \n \t4 messagesSent . incrementAndGet ( ) ; \n \n \t4 if ( messagesSent . get ( ) % <number_literal> == 0 ) { \n \n \t5 LOG . info ( <string_literal> + messagesSent . get ( ) ) ; \n \n <ect>
<comment> \n \n \t1 private void flushNewPartitions ( ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t2 } catch ( Throwable e ) { \n \n \t3 log . warn ( <string_literal> , e ) ; } } \n \n \t1 protected void onIO ( NginxClojureAsynSocket s , long sc , boolean isRead ) { \n \n <ect>
\t2 final OverlapDetector < Interval > ribosomalSequenceOverlapDetector = new OverlapDetector < Interval > ( 0 , 0 ) ; \n \n \t2 if ( ribosomalIntervalsFile != null ) { \n \n \t3 final IntervalList ribosomalIntervals = IntervalList . fromFile ( ribosomalIntervalsFile ) ; \n \n \t3 if ( ribosomalIntervals . size ( ) == 0 ) { \n \n <ect>
\t1 <comment> \n \n \t1 outPrinter . join ( ) ; \n \n \t1 errPrinter . join ( ) ; \n \n \t1 if ( exitVal != 0 ) { \n \n <ect>
\t9 new Versioned < byte [ ] > ( ByteUtils . getBytes ( entry . getValue ( ) , \n \n <number_literal> <string_literal> ) ) , \n \n \t9 null ) ; \n \n \t5 } catch ( ObsoleteVersionException e ) { \n \n <ect>
\t3 mdata = new MonitorData ( page , action , url , cthread . getName ( ) ) ; \n \n \t3 this . activeTimerDataList . put ( cthread , mdata ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 this . logger . warn ( <string_literal> , config . getController ( ) , e ) ; } } \n \n \t2 if ( node != null ) { \n \n \t3 executeCommand ( config , node , command ) ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 calcTabletStats ( conn , opts . getTableName ( ) , opts . auths , scanOpts . scanBatchSize , ke , \n \n \t4 columns ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 { \n \n \t3 ok = messageFactory . createResponse ( Response . OK , byeRequest ) ; } \n \n \t2 catch ( ParseException ex ) \n \n \t2 { \n \n <ect>
\t4 . setFetchMode ( <string_literal> , FetchMode . JOIN ) \n \n \t4 . list ( ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , salespersons . size ( ) ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , ( ( Salesperson ) salespersons . get ( 0 ) ) . getOrders ( ) . size ( ) ) ; \n \n <ect>
\t4 @ Override public void apply ( GridFuture < Long > t ) { \n \n \t5 exchWorker . addFuture ( forcePreloadExchange ( exchFut . discoveryEvent ( ) , exchFut . exchangeId ( ) ) ) ; } \n \n \t3 } ) ; } \n \n <ect>
\t4 LOG . info ( <string_literal> , fileStore ) ; \n \n \t4 if ( fileStore . getParentFile ( ) . mkdirs ( ) ) { \n \n \t5 LOG . info ( <string_literal> , fileStore ) ; \n \n \t4 } else { \n \n <ect>
\t2 } catch ( IOException ex ) { \n \n \t3 ex . printStackTrace ( ) ; \n \n \t3 Assert . fail ( <string_literal> + name + <string_literal> + ex . getMessage ( ) ) ; } } \n \n \t1 public int handleNameEnumerator ( ContentName prefix , ArrayList < ContentName > returnedNames ) { \n \n <ect>
\t4 <comment> \n \n <ect>
\t6 String message = ( String ) info . objectForKey ( <string_literal> ) ; \n \n \t6 String keyPaths = ( String ) info . objectForKey ( <string_literal> ) ; \n \n \t6 property = keyPaths == null ? property : keyPaths ; \n \n <ect>
\t1 public void initialize ( Map < String , Param > params ) throws TikaConfigException { \n \n \t2 AnnotationUtils . assignFieldParams ( recogniser , params ) ; \n \n \t2 recogniser . initialize ( params ) ; \n \n \t2 LOG . info ( <string_literal> , recogniser . getClass ( ) . getName ( ) ) ; \n \n <ect>
\t7 defaultStatelessKieSession = kieSessionModel ; \n \n \t7 defaultStatelessKieSessionFromMain = isMainModule ; \n \n \t6 } else { \n \n \t7 defaultStatelessKieSession = null ; \n \n <ect>
\t2 getAllowedAttributes ( ) . entrySet ( ) . stream ( ) . filter ( entry - > WSFederationClaims . contains ( entry . getKey ( ) . toUpperCase ( ) ) ) . forEach ( entry - > { \n \n \t3 final String claimName = entry . getKey ( ) ; \n \n \t3 final String attributeName = entry . getValue ( ) ; \n \n \t3 final WSFederationClaims claim = WSFederationClaims . valueOf ( claimName . toUpperCase ( ) ) ; \n \n <ect>
\t4 if ( cis != null ) { \n \n \t5 try { \n \n \t6 cis . close ( ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t5 . acceptLanguage ( <string_literal> ) . get ( ) ; \n \n \t3 Assert . assertEquals ( <number_literal> , response . getStatus ( ) ) ; \n \n \t3 String vary = response . getHeaderString ( HttpHeaderNames . VARY ) ; \n \n \t3 Assert . assertNotNull ( vary ) ; \n \n <ect>
\t3 return no ( ) ; } \n \n \t2 final String principal = c . getPrincipal ( ) . getId ( ) ; \n \n \t2 final LocalDate onOrAfter = LocalDate . now ( ) . minus ( trustedProperties . getExpiration ( ) , \n \n \t4 DateTimeUtils . toChronoUnit ( trustedProperties . getTimeUnit ( ) ) ) ; \n \n <ect>
\t3 if ( lock ( coordAction . getJobId ( ) ) ) { \n \n \t4 call ( store ) ; } \n \n \t3 else { \n \n \t4 queueCallable ( new CoordActionCheckCommand ( actionId , actionCheckDelay ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t8 new org . apache . http . HttpVersion ( \n \n \t10 Integer . parseInt ( parts [ 0 ] ) , Integer . parseInt ( parts [ 1 ] ) ) ) ; } } \n \n \t3 ) ; } \n \n \t1 private static void load ( String file , GenericHttpParams params ) { \n \n <ect>
\t2 catch ( ClosedSelectorException cse ) { \n \n \t3 if ( this . isActive ( ) ) { \n \n \t4 logger . error ( <string_literal> , cse ) ; } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 if ( bindingConfig != null ) { \n \n \t3 BticinoBindingConfig config = parseBindingConfig ( item , bindingConfig ) ; \n \n \t3 addBindingConfig ( item , config ) ; \n \n \t2 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 response = base . request ( ) . post ( Entity . entity ( book2 , Constants . MEDIA_TYPE_TEST_XML ) ) ; \n \n \t2 log . info ( <string_literal> + response . getStatus ( ) ) ; \n \n \t2 assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n \t2 int id2 = response . readEntity ( int . class ) ; \n \n <ect>
\t4 accountID . isJingleNodesAutoDiscoveryEnabled ( ) , \n \n \t4 searchNodesWithPrefix ) ; \n \n \t3 { \n \n <ect>
\t1 protected < T > void doAddOption ( Map < String , T > options , String name , T value ) { \n \n \t2 log . trace ( <string_literal> , name , value ) ; \n \n \t2 T val = options . put ( name , value ) ; \n \n \t2 if ( val != null ) { \n \n <ect>
\t3 try { \n \n \t4 port2Num = Integer . parseInt ( args [ <number_literal> ] ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n \t4 l . log ( <string_literal> ) ; \n \n <ect>
\t5 } else if ( end == - 1 || end > length - 1 ) { \n \n \t6 end = length - 1 ; } \n \n \t5 <comment> \n \n \t5 if ( start > end ) { \n \n <ect>
\t8 String reason = null ; \n \n \t8 if ( response == <number_literal> ) { \n \n \t9 success = true ; \n \n \t9 if ( internet ) { \n \n <ect>
\t2 Set < T > found = new LinkedHashSet < T > ( ) ; \n \n \t2 String [ ] versionDirs = getComponentVersionDirs ( windowsKitDir ) ; \n \n \t2 for ( String versionDir : versionDirs ) { \n \n \t3 VersionNumber version = VersionNumber . withPatchNumber ( ) . parse ( versionDir ) ; \n \n <ect>
\t4 if ( args [ i ] instanceof Wrapper ) { \n \n \t5 Class type = pt [ i ] ; \n \n \t5 MethodType mt = MethodType . methodType ( type , Wrapper . class ) ; \n \n \t5 handle = MethodHandles . filterArguments ( handle , i , UNWRAP_METHOD . asType ( mt ) ) ; \n \n <ect>
\t3 list = getListFromBytes ( cache . get ( inKey ) ) ; \n \n \t3 list . remove ( inValue ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t1 LOG . info ( <string_literal> + getPluginDescription ( ) ) ; } } \n \n @ Override \n \n public void registerSlimTables ( SlimTableFactory slimTableFactory ) throws PluginException { \n \n \t1 if ( register ( plugin , <string_literal> , SlimTableFactory . class , slimTableFactory ) ) { \n \n <ect>
\t5 . execute ( ) . actionGet ( ) ; \n \n \t3 assertHitCount ( searchResponse , docsTest1 + docsTest2 ) ; \n \n \t3 assertAllSuccessful ( searchResponse ) ; } \n \n \t2 IndicesStatsResponse indicesStats = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . execute ( ) . actionGet ( ) ; \n \n <ect>
\t5 } else { \n \n \t6 sasl . done ( Sasl . SaslOutcome . PN_SASL_AUTH ) ; } \n \n \t5 LOG . debug ( <string_literal> , mechanism . getMechanismName ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t3 List < ? extends IpAddress > ipsToRelease = _ipAddressDao . listByAccount ( accountId ) ; \n \n \t3 for ( IpAddress ip : ipsToRelease ) { \n \n \t4 s_logger . debug ( <string_literal> + ip + <string_literal> + accountId + <string_literal> ) ; \n \n \t4 if ( ! _networkMgr . releasePublicIpAddress ( ip . getId ( ) , callerUserId , caller ) ) { \n \n <ect>
\t3 requestsAvg . report ( 1 . 0 ) ; \n \n \t3 if ( Arrays . equals ( results , data ) ) { \n \n \t4 fetchSuccesses ++ ; \n \n \t4 int percentSuccess = <number_literal> * fetchSuccesses / insertAttempts ; \n \n <ect>
\t3 int iterationToRestore = randomIntBetween ( 0 , iterationCount - 1 ) ; \n \n \t3 logger . info ( <string_literal> , iterationToRestore ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( indexName ) ) ; \n \n <ect>
\t4 s_logger . warn ( <string_literal> + item . getContentId ( ) , e ) ; \n \n \t4 try { \n \n \t5 _queueMgr . returnItem ( item . getId ( ) ) ; \n \n \t4 } catch ( Throwable thr ) { \n \n <ect>
\t3 _toTry . remove ( _key ) ; \n \n \t3 empty = _toTry . isEmpty ( ) ; } \n \n \t2 if ( empty ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 public boolean hasNext ( ) { \n \n \t2 if ( jobCount < nJobs ) { \n \n \t3 boolean hasNext = jobIter . hasNext ( ) ; \n \n <comment> \n \n <ect>
\t1 builder . transferGB ( templateOptions . getTransferGB ( ) ) ; \n \n \t1 ServerSpec spec = builder . build ( ) ; \n \n \t1 <comment> \n \n \t1 String password = templateOptions . hasRootPassword ( ) ? templateOptions . getRootPassword ( ) : getRandomPassword ( ) ; \n \n <ect>
\t4 try { \n \n \t5 resource . configure ( <string_literal> , params ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n \t5 _alertMgr . sendAlert ( AlertManager . AlertType . ALERT_TYPE_HOST , dcId , podId , <string_literal> + url . getHost ( ) , <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t2 if ( holder . isEnterOracleImplicitCache ( ) ) { \n \n \t3 try { \n \n \t4 OracleUtils . exitImplicitCacheToClose ( holder . statement ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 Thread . sleep ( <number_literal> * <number_literal> ) ; <comment> \n \n \t1 <comment> \n \n \t1 } catch ( InterruptedException e ) { \n \n \t1 <comment> \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t4 listener . testEnded ( host ) ; \n \n \t3 } catch ( RemoteException e ) { \n \n <ect>
\t3 } else { \n \n \t4 logger . warn ( String . format ( <string_literal> , \n \n \t6 event . getNodeId ( ) , item . getName ( ) , bit ) ) ; } \n \n \t2 } else { \n \n <ect>
\t4 dao = ( Dao < ? , ? > ) constructor . newInstance ( arguments ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 throw SqlExceptionUtil . create ( <string_literal> + daoClass , e ) ; } } \n \n \t2 addDaoToTableMap ( tableKey , dao ) ; \n \n <ect>
\t2 int maxVersion = in . readInt ( ) ; \n \n \t2 from = CompactEndpointSerializationHelper . deserialize ( in ) ; \n \n \t2 <comment> \n \n \t2 MessagingService . instance ( ) . setVersion ( from , maxVersion ) ; \n \n <ect>
\t2 Integer xacceleration = acceleration != null ? acceleration : this . acceleration ; \n \n \t2 Integer xpwm = pwm != null ? pwm : this . pwmFrequency ; \n \n \t2 short xspeed = 0 ; \n \n \t2 if ( speed == null ) { \n \n <ect>
<number_literal> queue_scheduler = queue_scheduler_factory ( ) ) , \n \n \t8 topic_manager = TopicManager ( ) , \n \n \t8 authenticator = authenticator , \n \n \t8 protocol = STOMP11 ) \n \n <ect>
\t1 @ PostConstruct \n \n \t1 public void initTest ( ) { \n \n \t2 Assert . assertTrue ( true ) ; } \n \n \t1 public void MethodWithClassDbAnnotated ( ) { \n \n <ect>
\t2 <string_literal> , 1 , cf_defs ) ; \n \n \t1 cluster . addKeyspace ( ks_def ) ; \n \n \t1 log . info ( <string_literal> + keyspace ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 if ( ( _coordinatorState . hasCache ( curr ) || _coordinator . isReady ( ) ) && ! _activeTx . containsKey ( curr ) ) { \n \n \t6 TransactionAttempt attempt = new TransactionAttempt ( curr , _rand . nextLong ( ) ) ; \n \n \t6 Object state = _coordinatorState . getState ( curr , _initializer ) ; \n \n \t6 _activeTx . put ( curr , new TransactionStatus ( attempt ) ) ; \n \n <ect>
\t2 if ( NODE == null ) { \n \n \t3 startNode ( seed ) ; } } \n \n \t1 @ Override \n \n \t1 public void tearDown ( ) throws Exception { \n \n <ect>
\t2 <comment> \n \n \t2 String bucketIdStr = \n \n \t4 Utilities . getBucketFileNameFromPathSubString ( bucketName ) ; \n \n \t2 int bucketId = Utilities . getBucketIdFromFile ( bucketIdStr ) ; \n \n <ect>
\t5 logger . debug ( remoteFilePath + <string_literal> ) ; } } } \n \n \t2 else if ( FileExistsMode . REPLACE_IF_MODIFIED . equals ( fileExistsMode ) ) { \n \n <ect>
\t7 + e . getMessage ( ) + <string_literal> ) ; } \n \n \t4 catch ( Exception t2 ) { \n \n \t5 <comment> \n \n \t5 <comment> \n \n <ect>
\t5 <string_literal> + d2wContext . valueForKeyPath ( <string_literal> ) + <string_literal> + \n \n \t5 <string_literal> + d2wContext ( ) . valueForKey ( <string_literal> ) + <string_literal> + \n \n \t5 <string_literal> + d2wContext ( ) . valueForKey ( <string_literal> ) + <string_literal> , ex ) ; \n \n \t2 } else { \n \n <ect>
\t5 return new ContextEndpoint ( uri , this , endpoint ) ; \n \n \t5 <comment> \n \n \t2 throw new ResolveEndpointFailedException ( <string_literal> + uri + <string_literal> + getLocalCamelContext ( ) . getName ( ) ) ; } \n \n \t1 protected void logUsingEndpoint ( String uri , Endpoint endpoint ) { \n \n <ect>
\t5 Entity . entity ( <string_literal> , MediaType . TEXT_PLAIN_TYPE ) ) ; \n \n \t3 Assert . assertEquals ( HttpResponseCodes . SC_BAD_REQUEST , response . getStatus ( ) ) ; \n \n \t3 String entity = response . readEntity ( String . class ) ; \n \n \t3 ResteasyViolationException e = new ResteasyViolationException ( String . class . cast ( entity ) ) ; \n \n <ect>
\t5 + userResource . toRepresentation ( ) . getUsername ( ) + <string_literal> <string_literal> \\ <string_literal> <string_literal> \\ <string_literal> ) ; \n \n \t3 userResource . roles ( ) . clientLevel ( clientId ) . add ( roleRepresentations ) ; \n \n \t2 } else { \n \n <ect>
\t4 _log . warn ( <string_literal> , path , e ) ; } } \n \n \t3 <comment> \n \n \t3 if ( propertiesInStore == null || ! propertiesInStore . equals ( discoveryProperties ) ) \n \n \t3 { \n \n <ect>
\t3 @ Override \n \n \t3 protected boolean onUnknownException ( Exception e , long nextDelayMs ) { \n \n \t4 if ( isShutdown ) \n \n \t5 return false ; \n \n <ect>
\t1 Predicate < Iterable < HostAndPort > > findOrBreak = or ( updateRefOnSocketOpen ( result ) , throwISEIfNoLongerRunning ( node ) ) ; \n \n \t1 logger . debug ( <string_literal> , sockets , timeout , timeUnits ) ; \n \n \t1 boolean passed = retryPredicate ( findOrBreak , timeout , period , timeUnits ) . apply ( sockets ) ; \n \n \t1 if ( passed ) { \n \n <ect>
\t4 <comment> \n \n \t4 processBasicReport ( serialMessage , offset , endpoint ) ; \n \n \t4 break ; \n \n \t3 case BASIC_GET : \n \n <ect>
\t5 + <string_literal> ) ; } } \n \n \t1 private void doWarnForRelativePath ( File file ) { \n \n \t2 if ( file . isAbsolute ( ) ) return ; \n \n \t2 if ( file . getPath ( ) . substring ( 0 , <number_literal> ) . equals ( <string_literal> + File . separator ) ) return ; \n \n <ect>
\t4 UpdateOp combined = UpdateOp . combine ( id , ops ) ; \n \n \t4 LOG . debug ( <string_literal> , ops . size ( ) ) ; \n \n \t4 before = queue . getStore ( ) . findAndUpdate ( NODES , combined ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 brokerService . start ( ) ; } \n \n \t1 @ Override \n \n \t1 protected void after ( ) { \n \n \t2 try { \n \n <ect>
\t3 stmt . executeUpdate ( sql ) ; \n \n \t3 removedir ( node . getChildText ( <string_literal> ) . toString ( ) , view . getProperties ( ) . get ( <string_literal> ) ) ; \n \n \t3 logger . info ( node . getChildText ( <string_literal> ) . toString ( ) + <string_literal> ) ; } \n \n \t3 else { \n \n <ect>
\t3 <comment> \n \n \t3 if ( <string_literal> . equals ( address ) ) { \n \n \t4 processCurrentLocation ( exchange ) ; \n \n \t3 } else { \n \n <ect>
\t3 dropHBaseTable ( context ) ; \n \n \t3 dropHdfsPath ( context ) ; \n \n \t3 dropHiveTable ( context ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void testClientCleanup ( ) throws Throwable { \n \n \t2 OSMXBean osMbean = new OSMXBean ( ) ; \n \n \t2 if ( osMbean . getUnix ( ) == false ) { \n \n <ect>
\t3 LOG . error ( <string_literal> ) ; \n \n \t3 throw new IllegalArgumentException ( \n \n \t5 <string_literal> ) ; } \n \n \t2 if ( ObjectHelper . isEmpty ( namespaceName ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n @ Test \n \n public void duContextTest ( ) throws Exception { \n \n <ect>
\t2 for name , value in yaml . load ( file ) . iteritems ( ) : \n \n \t2 if name != None : \n \n \t3 configurations [ name ] = str ( value ) \n \n \t1 except : \n \n <ect>
\t3 people = ( ArrayList < Map < String , Object > > ) serviceActionController . execute ( new ServiceActionContext ( null , \n \n \t5 null ) , getAllPersonAdditionalPropertiesAction ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
{ \n \n \t1 if ( interest != interesting ) \n \n \t1 { \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 FavoriteItemService favoriteItemService = AppContextUtil . getSpringBean ( FavoriteItemService . class ) ; \n \n \t3 return favoriteItemService . isUserFavorite ( UserUIContext . getUsername ( ) , getType ( ) , \n \n \t5 PropertyUtils . getProperty ( beanItem , <string_literal> ) . toString ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 project . logger . warn ( deprecationMessage ) \n \n \t2 } else { \n \n \t3 throw GradleException ( deprecationMessage ) } \n \n \t2 if ( project . plugins . findPlugin ( ANDROID_APT_PLUGIN_ID ) != null ) { \n \n <ect>
\t3 nic = _nicsDao . findByNetworkIdInstanceIdAndBroadcastUri ( network . getId ( ) , vm . getId ( ) , broadcastUri . toString ( ) ) ; \n \n \t2 } else { \n \n \t3 nic = _networkModel . getNicInNetwork ( vm . getId ( ) , network . getId ( ) ) ; } \n \n \t2 if ( nic == null ) { \n \n <ect>
\t2 return tgt ; } \n \n \t1 private boolean shouldIssueTicketGrantingTicket ( final Authentication authentication , final String ticketGrantingTicket ) { \n \n \t2 boolean issueTicketGrantingTicket = true ; \n \n \t2 if ( StringUtils . isNotBlank ( ticketGrantingTicket ) ) { \n \n <ect>
\t7 log . debug ( <string_literal> ) ; \n \n \t7 log . debug ( <string_literal> , operation ) ; \n \n \t7 log . debug ( <string_literal> , key ) ; \n \n \t7 log . debug ( <string_literal> , data ) ; \n \n <ect>
\t5 if ( stt == null || stt . isExpired ( ) ) { \n \n \t6 LOGGER . warn ( <string_literal> , sts ) ; \n \n \t6 return null ; } \n \n \t5 if ( stt . getSecurityToken ( ) . isExpired ( ) ) { \n \n <ect>
\t10 final Map < String , String > vmmetadata = new HashMap < String , String > ( ) ; \n \n \t10 vmmetadata . put ( vm . getInstanceName ( ) , platform ) ; \n \n \t10 syncVMMetaData ( vmmetadata ) ; } } } \n \n \t7 if ( answer == null || ! answer . getResult ( ) ) { \n \n <ect>
\t3 return true ; } \n \n \t2 return false ; } \n \n \t1 public NSArray attributeListAtDepth ( ) { \n \n \t2 Number ky = Integer . valueOf ( depth ) ; \n \n <ect>
\t1 @ Bean \n \n \t1 public AuthenticationEventExecutionPlanConfigurer pac4jAuthenticationEventExecutionPlanConfigurer ( ) { \n \n \t2 return plan - > { \n \n \t3 if ( ! builtClients ( ) . findAllClients ( ) . isEmpty ( ) ) { \n \n <ect>
\t3 cipherProviderType ; \n \n \t2 logger . error ( errMessage ) ; \n \n \t2 throw new FlumeException ( errMessage ) ; } \n \n \t1 } catch ( ClassNotFoundException ex ) { \n \n <ect>
\t2 final DiscoveryNodes . Delta nodesDelta = clusterChangedEvent . nodesDelta ( ) ; \n \n \t3 String summary = nodesDelta . shortSummary ( ) ; \n \n \t3 if ( summary . length ( ) > 0 ) { \n \n <ect>
@ Test \n \n public void testPersistActions ( ) throws AmbariException { \n \n \t1 populateActionDB ( db , hostName , requestId , stageId , false ) ; \n \n \t1 for ( Stage stage : db . getAllStages ( requestId ) ) { \n \n <ect>
\t3 } else if ( StringUtils . isEmpty ( configInDB . getValue ( ) ) ) { \n \n \t4 s_logger . info ( <string_literal> ) ; \n \n \t4 _configDao . update ( Config . SSVMPSK . key ( ) , Config . SSVMPSK . getCategory ( ) , getPrivateKey ( ) ) ; } \n \n \t2 } catch ( NoSuchAlgorithmException ex ) { \n \n <ect>
\t3 Gson gson = gb . create ( ) ; \n \n \t3 byte [ ] details = proxy . getSessionDetails ( ) ; \n \n \t3 status = gson . fromJson ( details != null ? new String ( details , Charset . forName ( <string_literal> ) ) : null , ConsoleProxyStatus . class ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t5 if ( ! result . isSuccessful ( ) ) { \n \n \t6 <comment> <ect>
\t2 } catch ( OutOfMemoryError e ) { \n \n \t3 s_logger . error ( <string_literal> ) ; \n \n \t3 System . exit ( 1 ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t1 private static void tryUnlock ( CmsObject cms , CmsResource resource ) { \n \n \t2 try { \n \n \t3 cms . unlockResource ( resource ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t1 if ( con != null && cleanup ) { \n \n \t2 try { \n \n \t2 con . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 InputStream in = ! chunked ? new BufferedInputStream ( request . getResponseBodyAsStream ( ) ) \n \n \t9 : new ChunkedInputStream ( request . getResponseBodyAsStream ( ) ) ; \n \n \t3 RandomAccessFile out = new RandomAccessFile ( file , <string_literal> ) ; \n \n \t3 out . seek ( localFileSize ) ; \n \n <ect>
\t2 runnable = new RESTRunnable ( m_restCache , m_queuedUrls , m_ttlUrlCache , m_gson , \n \n \t3 streamProvider , url ) ; \n \n \t2 break ; \n \n \t1 default : \n \n <ect>
\t5 if ( equalCon == null ) continue ; \n \n \t5 Collection < Object > labels = equalCon . getValue ( ) ; \n \n \t5 assert labels . size ( ) >= 1 ; \n \n \t5 if ( labels . size ( ) > 1 ) { \n \n <ect>
\t2 try { \n \n \t3 Thread . sleep ( checkInterval ) ; \n \n \t3 return false ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 rows [ i ] = i + <string_literal> + <number_literal> . <number_literal> ; } \n \n \t1 HcatTestUtils . createTestDataFile ( INPUT_FILE_NAME , rows ) ; \n \n <ect>
\t3 } else { <comment> \n \n \t3 imagingServiceName = configuration . getHostName ( ) + <string_literal> + imaging ; } \n \n \t3 try { \n \n \t3 ServiceConfigurations . lookupByName ( Imaging . class , imagingServiceName ) ; \n \n <ect>
\t2 out . tab ( 1 ) . println ( <string_literal> ) ; } \n \n \t1 protected void printConvenienceMethodProcedure ( JavaWriter out , RoutineDefinition procedure , boolean instance ) { \n \n \t2 <comment> \n \n \t2 if ( procedure . getInParameters ( ) . size ( ) > <number_literal> ) { \n \n <ect>
\t1 runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n \t1 runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n \t1 runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n \t1 List < String > rs = runStatementOnDriver ( <string_literal> + Table . NONACIDORCTBL + <string_literal> ) ; \n \n <ect>
\t3 if ( bitmap != null ) { \n \n \t4 bitfield = new BitField ( bitmap , bitmap . length * <number_literal> ) ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 { \n \n \t4 notifyCommitted ( outcome . getCommitIndex ( ) ) ; } } \n \n \t2 catch ( Throwable e ) \n \n \t2 { \n \n <ect>
\t1 exec ( <string_literal> , true ) ; \n \n \t1 exec ( <string_literal> , true , <string_literal> ) ; } \n \n @ Test \n \n public void commentTest ( ) throws IOException { \n \n <ect>
\t2 for ( int i = 0 ; i < message . capacity ( ) ; i ++ ) { \n \n \t3 message . writeByte ( ( byte ) i ) ; } } \n \n \t1 @ Override \n \n \t1 public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { \n \n <ect>
\t1 public static boolean deletePlugin ( RouterContext ctx , String appName ) throws Exception { \n \n \t2 Log log = ctx . logManager ( ) . getLog ( PluginStarter . class ) ; \n \n \t2 File pluginDir = new File ( ctx . getConfigDir ( ) , PLUGIN_DIR + ' / ' + appName ) ; \n \n \t2 if ( ( ! pluginDir . exists ( ) ) || ( ! pluginDir . isDirectory ( ) ) ) { \n \n <ect>
\t4 modificationQueue . registerNodeCallback ( node , callbackId ) ; \n \n \t3 } else { \n \n \t4 logger . error ( <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t3 return ErrorResponse . exists ( <string_literal> ) ; \n \n \t2 } catch ( ForbiddenException fe ) { \n \n \t3 throw fe ; \n \n \t2 } catch ( Exception me ) { <comment> \n \n <ect>
\t2 } else { \n \n \t3 jettyWebXmlLoc = this . jettyWebXmlLocation ; } \n \n \t2 URL jettyWebXml = bundleContext . getBundle ( ) . getResource ( jettyWebXmlLoc ) ; \n \n \t2 if ( jettyWebXml != null ) { \n \n <ect>
\t2 ef = new Exclude ( array ) ; \n \n \t2 assertTrue ( ef . match ( b1 ) ) ; \n \n \t2 assertFalse ( ef . match ( b3 ) ) ; \n \n \t2 assertTrue ( ef . match ( b06 ) ) ; \n \n <ect>
\t3 Answer rebootAnswer = cmds . getAnswer ( RebootAnswer . class ) ; \n \n \t3 if ( rebootAnswer != null && rebootAnswer . getResult ( ) ) { \n \n \t4 rebootedVm = vm ; \n \n \t4 return rebootedVm ; } \n \n <ect>
\t3 logger . error ( <string_literal> , job , e ) ; \n \n \t3 return null ; } } \n \n \t1 public static JobInstance parseToJobInstance ( CubingJob job , Map < String , Output > outputs ) { \n \n \t2 if ( job == null ) { \n \n <ect>
\t1 { \n \n \t2 try { \n \n \t3 listener . onRequestSent ( ) ; } \n \n \t2 catch ( Throwable t ) { \n \n <ect>
\t3 try { \n \n \t4 scheduler . scheduleJob ( job , trigger ) ; \n \n \t4 triggersCreated = true ; \n \n \t3 } catch ( SchedulerException se ) { \n \n <ect>
\t2 <comment> \n \n \t2 while ( newGroupsEnum . hasMoreElements ( ) ) \n \n \t2 { \n \n \t3 String groupName = newGroupsEnum . nextElement ( ) ; \n \n <ect>
\t4 ArrayList < Msg > lrs = db . getValue ( ) . getLinkRecords ( ) ; \n \n \t4 for ( Msg m : lrs ) { \n \n \t5 int recordFlags = m . getByte ( <string_literal> ) & 0xff ; \n \n \t5 String ms = ( ( recordFlags & ( 0x1 < < <number_literal> ) ) != 0 ) ? <string_literal> : <string_literal> ; \n \n <ect>
\t3 } catch ( BinaryStoreException e ) { \n \n \t4 I18n msg = JcrI18n . problemsGettingBinaryKeysFromBinaryStore ; \n \n \t4 problems . addError ( msg , repositoryName ( ) , backupLocation ( ) , e . getMessage ( ) ) ; } } \n \n \t2 private void removeExistingDocuments ( ) { \n \n <ect>
\t2 try { \n \n \t3 final ControlClusterStatus clusterStatus = niciraNvpApi . getControlClusterStatus ( ) ; \n \n \t3 final String status = clusterStatus . getClusterStatus ( ) ; \n \n \t3 if ( clusterIsUnstable ( status ) ) { \n \n <ect>
\t6 String msg = ioex . getMessage ( ) ; \n \n \t6 boolean sockReset = msg != null && msg . contains ( <string_literal> ) ; \n \n \t6 if ( sockReset ) { \n \n \t7 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t4 <comment> \n \n \t4 try { \n \n \t5 this . registrar . setScheduler ( resolveSchedulerBean ( beanFactory , ScheduledExecutorService . class , false ) ) ; } \n \n \t4 catch ( NoUniqueBeanDefinitionException ex2 ) { \n \n <ect>
\t2 return new org . apache . thrift . async . AsyncMethodCallback < Void > ( ) { \n \n \t2 public void onComplete ( Void o ) { } \n \n \t2 public void onError ( java . lang . Exception e ) { \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t4 Logger . error ( this , format ( <string_literal> , listener ) , t ) ; } } \n \n \t2 return false ; } \n \n \t1 public boolean tripPendingKey ( Key key , KeyBlock block , ClientContext context ) { \n \n \t2 if ( ( key instanceof NodeSSK ) != isSSKScheduler ) { \n \n <ect>
\t4 sched . deleteJobs ( new ArrayList < JobKey > ( jobKeys ) ) ; \n \n \t4 logger . debug ( <string_literal> , jobKeys . size ( ) , \n \n \t6 jobKeys ) ; } \n \n \t2 } catch ( SchedulerException e ) { \n \n <ect>
\t2 try { \n \n \t3 VmwareManager mgr = getServiceContext ( ) . getStockObject ( VmwareManager . CONTEXT_STOCK_NAME ) ; \n \n \t3 Pair < Boolean , String > result = SshHelper . sshExecute ( controlIp , DEFAULT_DOMR_SSHPORT , <string_literal> , mgr . getSystemVMKeyFile ( ) , null , <string_literal> + args ) ; \n \n \t3 if ( ! result . first ( ) ) { \n \n <ect>
\t4 String fixedMessageSelector = replyToSelectorName + <string_literal> + replyToSelectorValue + <string_literal> ; \n \n \t4 answer = new SharedQueueMessageListenerContainer ( endpoint , fixedMessageSelector ) ; \n \n \t4 <comment> \n \n \t4 answer . setCacheLevel ( DefaultMessageListenerContainer . CACHE_CONSUMER ) ; \n \n <ect>
\t4 _log . debug ( <string_literal> ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 } catch ( InterruptedException e ) { \n \n \t7 throw new IOException ( <string_literal> , e ) ; } } } \n \n \t4 log . info ( <string_literal> + duration + <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t1 logger . info ( <string_literal> , ex ) ; } \n \n \t1 executor . shutdownNow ( ) ; \n \n \t1 super . stop ( ) ; \n \n \t1 sourceCounter . stop ( ) ; \n \n <ect>
\t4 ReachableMethods rm = Scene . v ( ) . getReachableMethods ( ) ; \n \n \t4 reachable = rm . contains ( tn . method ) ; \n \n \t4 if ( mhp != null ) \n \n \t5 mhpself = mhp . mayHappenInParallel ( tn . method , tn . method ) ; } \n \n <ect>
\t3 @ Override \n \n \t3 public boolean isSatisified ( ) throws Exception { \n \n \t4 for ( ConsumerState tally : consumerStates ) { \n \n \t5 final int expected = numMessages * ( tally . destination . isComposite ( ) ? tally . destination . getCompositeDestinations ( ) . length : 1 ) ; \n \n <ect>
\t3 hostId = host . getId ( ) ; } \n \n \t2 DataStore secondaryStore = _dataStoreMgr . getImageStore ( network . getDataCenterId ( ) ) ; \n \n \t2 <comment> \n \n \t2 if ( update && profile . getVirtualMachine ( ) . getState ( ) . equals ( VirtualMachine . State . Running ) ) { \n \n <ect>
\t3 result . success = o ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
protected BaseMaskUDF ( AbstractTransformer transformer , String displayName ) { \n \n \t1 this . transformer = transformer ; \n \n \t1 this . displayName = displayName ; } \n \n public ObjectInspector initialize ( ObjectInspector [ ] arguments ) throws UDFArgumentException { \n \n <ect>
\t4 int page \t3 = 1 ; \n \n \t4 result = app . nodeQuery ( type ) . sort ( sortKey ) . order ( sortDesc ) . page ( page ) . pageSize ( pageSize ) . getResult ( ) ; \n \n \t4 logger . info ( <string_literal> , new Object [ ] { result . getRawResultCount ( ) , number } ) ; \n \n \t4 assertTrue ( result . getRawResultCount ( ) == number ) ; \n \n <ect>
\t2 serviceProviders = new CreateUserData ( new File ( _testDir + USER_DIRECTORY ) , SERVICE_PROVIDERS , SERVICE_PROVIDERS . length , \n \n \t4 UserConfiguration . keystorePassword ( ) . toCharArray ( ) , true ) ; } \n \n \t1 @ Test \n \n \t1 public void testGetLocalServiceKeys ( ) throws Exception { \n \n <ect>
\t2 String threadName = camelContext . getExecutorServiceManager ( ) . resolveThreadName ( <string_literal> + url ) ; \n \n \t2 Thread thread = getCamelContext ( ) . getExecutorServiceManager ( ) . newThread ( threadName , new Runnable ( ) { \n \n \t3 public void run ( ) { \n \n \t4 try { \n \n <ect>
\t1 public boolean exists ( ) { \n \n \t2 return isFile ( ) || isDirectory ( ) ; } \n \n \t1 @ Override \n \n \t1 public boolean canRead ( ) { \n \n <ect>
\t1 } else { \n \n \t2 LOG . error ( <string_literal> + DUMP_DATA_ON_ERROR_KEY + <string_literal> ) ; } \n \n \t1 InputSplit is = context . getInputSplit ( ) ; \n \n \t1 if ( is instanceof FileSplit ) { \n \n <ect>
\t5 <comment> \n \n \t5 meta = OreDictionary . WILDCARD_VALUE ; } \n \n \t4 stack = new ItemStack ( stack . getItem ( ) , stack . getCount ( ) , meta ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t4 logger . warn ( <string_literal> , postMethod . getStatusLine ( ) ) ; \n \n \t4 return false ; } \n \n \t3 return true ; \n \n \t2 } catch ( HttpException e ) { \n \n <ect>
\t1 Set < T > dictSet = expandDictionary ( meta ) ; \n \n \t1 if ( dictSet != null && dictSet . size ( ) == 1 && dictSet . contains ( value ) ) { \n \n \t2 return BLOCK_CANNOT_MATCH ; } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 LOG . info ( <string_literal> ) \n \n \t1 try { \n \n \t1 dbExecute ( <string_literal> <ect>
\t3 if ( e . getCause ( ) instanceof RuntimeException ) \n \n \t3 { \n \n \t4 if ( e . getCause ( ) . getCause ( ) instanceof IOException ) \n \n \t4 { \n \n <ect>
\t3 } else { \n \n \t4 return false ; } \n \n \t2 } catch ( DOMException e ) { \n \n \t3 resp . sendError ( WebdavStatus . SC_INTERNAL_SERVER_ERROR ) ; \n \n <ect>
\t1 { \n \n \t2 String prefer6 = System . getProperty ( <string_literal> ) ; \n \n \t2 String prefer4 = System . getProperty ( <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> + prefer6 ) ; \n \n <ect>
\t3 s_logger . debug ( <string_literal> ) ; \n \n \t2 } catch ( SQLException e ) { \n \n \t3 throw new CloudRuntimeException ( <string_literal> , e ) ; } } \n \n \t1 private void encryptSite2SitePSK ( Connection conn ) { \n \n <ect>
\t4 LOGGER . debug ( e . getMessage ( ) , e ) ; } \n \n \t2 } ) ; } \n \n \t1 private File getMetadataBackupFile ( final AbstractResource metadataResource , \n \n \t9 final RegisteredService service ) throws IOException { \n \n <ect>
\t4 return server ; } \n \n \t3 catch ( KafkaException e ) { \n \n \t4 if ( e . getCause ( ) instanceof BindException ) { \n \n \t5 <comment> \n \n <ect>
\t5 break ; } \n \n \t4 healing . stateNext = HealState . UPDATEROUTES ; \n \n \t3 case UPDATEROUTES : \n \n \t4 <comment> \n \n <ect>
\t1 Thread . currentThread ( ) . setName ( <string_literal> ) ; \n \n \t1 logger . log ( XLevel . TRACE , <string_literal> ) ; \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n <ect>
\t3 Set < String > ids = new HashSet < > ( ) ; \n \n \t3 try { \n \n \t4 for ( final java . lang . String line : new XReadLines ( file ) . readLines ( ) ) { \n \n \t5 ids . add ( line . trim ( ) ) ; } \n \n <ect>
\t1 public ConcreteDecorator ( @ Delegate final ConcreteResourceIntf resource ) { \n \n \t2 this . resource = resource ; } \n \n \t1 @ Override \n \n \t1 public Response execute ( ) { \n \n <ect>
\t1 for ( ConfLogger logger : confLoggers . getLoggers ( ) ) { \n \n \t2 String loggerName = logger . getLogger ( ) ; \n \n \t2 Level logLevel = Level . getLevel ( logger . getLevel ( ) ) ; \n \n \t2 if ( logLevel == null ) { \n \n <ect>
\t2 <string_literal> + \n \n \t2 <string_literal> + \n \n \t2 <string_literal> + \n \n \t2 <string_literal> + \n \n <ect>
\t1 public void setup ( ) { \n \n \t2 try { \n \n \t3 constructor = reflectFactory . createConstructor ( LocationComponent . class ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t2 EndpointStatisticCommand command = new EndpointStatisticCommand ( <string_literal> , false , null ) ; \n \n \t2 command . execute ( controller , ps , null ) ; \n \n \t2 String out = os . toString ( ) ; \n \n \t2 assertNotNull ( out ) ; \n \n <ect>
\t4 numDeletedSizeAvailable , \n \n \t4 org . apache . jackrabbit . oak . commons . IOUtils . humanReadableByteCount ( deletedSize ) , deletedSize ) ; } \n \n \t2 <comment> \n \n \t2 GarbageCollectionType . get ( blobStore ) . removeAllMarkedReferences ( blobStore ) ; \n \n <ect>
\t4 try { \n \n \t5 lock . lock ( ) ; \n \n \t5 doPurge ( afterPurgeAction ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 for ( final String test : qFileTestNames ) { \n \n \t1 if ( excluded . contains ( test ) ) { \n \n \t2 logger . info ( <string_literal> + driver + <string_literal> + test ) ; \n \n \t1 } else if ( isolated . contains ( test ) ) { \n \n <ect>
\t3 } <comment> \n \n \t2 } catch ( ConcurrentModificationException e ) { \n \n \t3 log . debug ( <string_literal> , e ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 new Timeout ( <string_literal> , <number_literal> ) . sleep ( ) ; <comment> \n \n \t2 JTableOperator jto = new JTableOperator ( wo , 0 ) ; \n \n \t2 int row = jto . findCellRow ( <string_literal> , <number_literal> , 0 ) ; \n \n \t2 jto . clickOnCell ( row , 1 ) ; \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testCmdlineParam ( ) throws Exception { \n \n <ect>
\t3 _leaseSet = getContext ( ) . netDb ( ) . lookupLeaseSetLocally ( _to . calculateHash ( ) ) ; \n \n \t3 if ( _leaseSet == null ) { \n \n \t4 <comment> \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 reply . setIsDeleteMarker ( Boolean . TRUE ) ; } \n \n \t1 setCorsInfo ( request , reply , objectEntity . getBucket ( ) ) ; \n \n \t1 return reply ; \n \n \t1 } catch ( AccessDeniedException e ) { \n \n <ect>
\t3 _mobileTel = ( String ) xPath . evaluate ( <string_literal> , xmlNode , \n \n \t5 XPathConstants . STRING ) ; \n \n \t3 _fax = ( String ) xPath . evaluate ( <string_literal> , xmlNode , XPathConstants . STRING ) ; \n \n \t2 } catch ( XPathExpressionException e ) { \n \n <ect>
\t3 if ( originatorInformationProvider != null ) { \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t4 OriginatorInformation originatorInformation = originatorInformationProvider . getOriginatorInformation ( exchange ) ; \n \n \t4 if ( originatorInformation != null ) { \n \n <ect>
\t1 BufferedReader reader = null ; \n \n \t1 try { \n \n \t2 <comment> \n \n \t2 if ( ! hostProvider . isCollectorHostLive ( clusterName , GANGLIA ) ) { \n \n <ect>
\t1 for ( ShortTaskStatus task : underlyingTasks ) { \n \n \t2 String component = task . getRole ( ) ; \n \n \t2 Long logicalStartTaskId = hostRequest . getLogicalTasksForTopologyTask ( this ) . get ( component ) ; \n \n \t2 if ( logicalStartTaskId == null ) { \n \n <ect>
\t2 this . cursors = cursors ; } \n \n \t1 @ Override \n \n \t1 public Void execute ( final InternalConnection connection ) { \n \n <ect>
\t10 finished . set ( true ) ; \n \n \t10 tx . success ( ) ; \n \n \t9 } catch ( Throwable t ) { \n \n \t10 t . printStackTrace ( ) ; \n \n <ect>
\t3 runArgvTestPrograms ( python3 ) ; } } \n \n \t1 private void runTestPrograms ( String pythonBinary ) throws Exception { \n \n \t2 String utils = findUtilsFile ( ) ; \n \n \t2 for ( String file : findTestFiles ( ) ) { \n \n <ect>
\t3 } catch ( IllegalAccessException e ) { \n \n \t4 s_logger . error ( e . getMessage ( ) , e ) ; \n \n \t4 return null ; } \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t1 baseEventFetchStmt . setString ( 1 , channel ) ; \n \n \t1 ResultSet rsetBaseEvent = baseEventFetchStmt . executeQuery ( ) ; \n \n \t1 if ( ! rsetBaseEvent . next ( ) ) { \n \n \t2 <comment> \n \n <ect>
\t4 argument1Type = ArgumentType . ATTRIBUTE ; \n \n \t3 else if ( isInstanceOfTheClass ( node . asResource ( ) , variable ) ) \n \n \t4 argument1Type = ArgumentType . VARIABLE ; \n \n \t2 } else { \n \n <ect>
\t2 <comment> \n \n \t2 epState . addApplicationState ( ApplicationState . STATUS , StorageService . instance . valueFactory . left ( tokens , computeExpireTime ( ) ) ) ; \n \n \t2 handleMajorStateChange ( endpoint , epState ) ; \n \n \t2 Uninterruptibles . sleepUninterruptibly ( intervalInMillis * <number_literal> , TimeUnit . MILLISECONDS ) ; \n \n <ect>
\t4 MethodsMetadataReaderFactory factory = new MethodsMetadataReaderFactory ( type . getClassLoader ( ) ) ; \n \n \t4 MethodsMetadataReader metadataReader = factory . getMetadataReader ( ClassUtils . getQualifiedName ( type ) ) ; \n \n \t4 return Optional . of ( metadataReader . getMethodsMetadata ( ) ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlParsingError ( Throwable t ) { \n \n <ect>
\t2 } catch ( SQLException e ) { \n \n \t3 String msg = <string_literal> + e . getMessage ( ) ; \n \n \t3 s_logger . error ( msg ) ; \n \n \t3 throw new CloudRuntimeException ( msg , e ) ; } \n \n <ect>
\t1 ApplicationContext ctx = this . getContext ( servletConfig ) ; \n \n \t1 String beanName = null ; \n \n \t1 if ( ( targetBean != null ) && ctx . containsBean ( targetBean ) ) { \n \n <ect>
\t5 currentUser . getShortUserName ( ) , yarnClientUsername ) ; \n \n \t3 <comment> \n \n \t3 final Map < String , String > dynamicProperties = \n \n \t4 FlinkYarnSessionCli . getDynamicProperties ( ENV . get ( YarnConfigKeys . ENV_DYNAMIC_PROPERTIES ) ) ; \n \n <ect>
\t1 protected void removeFailureCounter ( Channel channel ) { \n \n \t2 failureCounters . remove ( channel ) ; } \n \n \t1 @ Override \n \n \t1 public void channelConnected ( ChannelHandlerContext ctx , ChannelStateEvent e ) { \n \n <ect>
\t2 if ( fatals == null ) { \n \n \t3 fatals = new ArrayDeque < > ( ) ; \n \n \t3 exchange . setProperty ( Exchange . FATAL_FALLBACK_ERROR_HANDLER , fatals ) ; } \n \n \t2 if ( fatals . contains ( id ) ) { \n \n <ect>
\t1 final ChannelFutureListener listener = new ChannelFutureListener ( ) { \n \n \t2 @ Override \n \n \t2 public void operationComplete ( ChannelFuture cf ) { \n \n \t3 if ( ! cf . isSuccess ( ) && ! promise . isDone ( ) ) { \n \n <ect>
\t3 } else { \n \n \t4 boolean exclude = TunnelPeerSelector . shouldExclude ( _context , info ) ; \n \n \t4 if ( exclude ) { \n \n \t5 <comment> \n \n <ect>
\t2 createProducerAndSendMessages ( NUM_TO_SEND ) ; \n \n \t2 QueueViewMBean proxy = getProxyToQueueViewMBean ( ) ; \n \n \t2 createConsumer ( ) ; \n \n \t2 long start = System . currentTimeMillis ( ) ; \n \n <ect>
\t2 if ( broker1 != null && broker1 . isStarted ( ) ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 broker1 . stop ( ) ; } \n \n \t2 else { \n \n <ect>
\t4 try { \n \n \t5 return ! authorizeService \n \n \t6 . authorizeActionBoolean ( getAnonContext ( ) , item , org . dspace . core . Constants . READ ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
<comment> \n \n \t1 private void receiveGetPeers ( MsgID msgID , NodeInfo nInfo , \n \n \t8 InfoHash ih , boolean noSeeds ) throws InvalidBEncodingException { \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 LOG . info ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 server . stop ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 for ( Entry < String , String > entry : jarMd5Map . entrySet ( ) ) { \n \n \t1 Path localJarPath = new Path ( entry . getKey ( ) ) ; \n \n \t1 String jarFilename = localJarPath . getName ( ) ; \n \n \t1 String localMd5sum = entry . getValue ( ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public boolean remove ( SimpleUri id ) { \n \n \t2 Setting setting = get ( id ) ; \n \n \t2 if ( setting == null ) { \n \n <ect>
\t3 throw e ; } \n \n \t3 break ; \n \n \t2 default : \n \n \t3 throw e ; } } \n \n <ect>
\t9 : answer . getDetails ( ) ) ; } \n \n \t5 } catch ( Exception e ) { \n \n \t6 s_logger . warn ( <string_literal> + guestConfig . getId ( ) + <string_literal> + e . getMessage ( ) ) ; } \n \n <ect>
\t2 session . close ( ) ; \n \n \t2 connection . close ( ) ; } \n \n \t1 protected MessageConsumer createConsumer ( String selector ) throws JMSException { \n \n \t2 if ( durable ) { \n \n <ect>
\t1 LOG . error ( <string_literal> + f ) ; } \n \n \t1 return result ; } \n \n public static boolean rename ( FileSystem fs , Path sourcePath , \n \n \t7 Path destPath , Configuration conf ) throws IOException { \n \n <ect>
\t3 U . error ( log , <string_literal> + cmdRes , e ) ; \n \n \t3 json = JSONSerializer . toJSON ( new GridRestResponse ( STATUS_FAILED , e . getMessage ( ) ) , cfg ) ; } \n \n \t2 try { \n \n <ect>
\t2 else if ( osName . contains ( <string_literal> ) ) \n \n \t3 return MAC ; \n \n \t2 else if ( osName . contains ( <string_literal> ) ) \n \n \t3 return WINDOWS ; \n \n <ect>
\t3 extra = uri . extra . clone ( ) ; \n \n \t2 } else \n \n \t3 extra = null ; \n \n \t2 this . suggestedEdition = uri . suggestedEdition ; \n \n <ect>
\t3 for ( int i = 0 ; i < generations . length ; i ++ ) \n \n \t3 { \n \n \t4 if ( ! getLevel ( i ) . isEmpty ( ) ) \n \n \t4 { \n \n <ect>
\t3 String errorMessage ; \n \n \t3 try { \n \n \t4 errorMessage = responseToErrorMessage ( response ) ; \n \n \t3 } catch ( final IOException e ) { \n \n <ect>
\t6 log . error ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \n \t6 e . printStackTrace ( ) ; \n \n \t6 rulesSinceFirstFail ++ ; \n \n \t5 } else if ( block . connects ) { \n \n <ect>
\t4 return <string_literal> ; } \n \n \t3 if ( mapping . endsWith ( <string_literal> ) ) { \n \n \t4 String path = mapping . substring ( 0 , mapping . length ( ) - <number_literal> ) ; \n \n \t4 if ( ! path . isEmpty ( ) ) { \n \n <ect>
\t3 if ( valueContent != null ) \n \n \t4 value = Double . parseDouble ( valueContent ) ; \n \n \t3 f . setDouble ( object , value ) ; \n \n \t2 } else { \n \n <ect>
\t1 try { \n \n \t2 metastore = MetaStoreExportUtil . connectToRepository ( null ) . getMetaStore ( ) ; \n \n \t1 } catch ( KettleException e ) { \n \n \t2 <comment> \n \n <ect>
\t4 s_logger . error ( msg ) ; \n \n \t4 return new GetStorageStatsAnswer ( cmd , msg ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t1 protected abstract T compare ( T value1 , T value2 ) ; \n \n \t1 @ Override \n \n \t1 public State init ( Object batchId , TridentCollector collector ) { \n \n \t2 this . batchId = batchId ; \n \n <ect>
\t2 logger . debug ( <string_literal> + username + <string_literal> + e . toString ( ) ) ; } \n \n \t1 throw new UnauthorisedException ( authFailedForUser ( authentication . getPrincipal ( ) . toString ( ) ) , e ) ; } \n \n \t1 <comment> \n \n <ect>
\t2 KeyspaceMetadata ksm = Schema . instance . getKeyspaceMetadata ( droppedType . keyspace ) ; \n \n \t2 announce ( SchemaKeyspace . dropTypeFromSchemaMutation ( ksm , droppedType , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } \n \n \t1 public static void announceFunctionDrop ( UDFunction udf , boolean announceLocally ) \n \n \t1 { \n \n <ect>
\t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( <number_literal> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; \n \n \t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( 0 ) . currentNodeId ( ) , nullValue ( ) ) ; \n \n \t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( 1 ) . currentNodeId ( ) , nullValue ( ) ) ; \n \n \t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( <number_literal> ) . currentNodeId ( ) , nullValue ( ) ) ; } \n \n <ect>
\t4 break ; } \n \n \t3 OutputInterpreter . AllLinesParser interpreter = new OutputInterpreter . AllLinesParser ( ) ; \n \n \t3 if ( ! doScript ( _getStatusCommand , interpreter ) ) { \n \n \t4 success = true ; \n \n <ect>
\t3 HeaderParam headerParam2 = new HeaderParam ( <string_literal> , signatureString ) ; \n \n \t3 params . addHeader ( headerParam2 ) ; \n \n \t3 authenticateRequest ( request , params ) ; } \n \n \t2 catch ( Exception e ) \n \n <ect>
\t4 synchronizeSlave ( host ) ; \n \n \t3 } else { \n \n \t4 logger . info ( <string_literal> , new Object [ ] { host , df . format ( localSyncTimestamp ) } ) ; } } } \n \n \t1 private void synchronizeSlave ( final SyncHostInfo info ) { \n \n <ect>
\t6 logger . warn ( <string_literal> , entry ) ; } \n \n \t4 } else { \n \n \t5 logger . warn ( <string_literal> , entry ) ; } \n \n \t3 } else { \n \n <ect>
public void removeFrom$ { relationship . capitalizedName } ( $relationship . actualDestination . classNameWithDefault object ) { \n \n \t1 excludeObjectFromPropertyWithKey ( object , $ { entity . prefixClassNameWithoutPackage } . $ { relationship . uppercaseUnderscoreName } _KEY ) ; } \n \n public void addTo$ { relationship . capitalizedName } Relationship ( $relationship . actualDestination . classNameWithDefault object ) { \n \n <ect>
\t4 str = queryMap . get ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 modifiers = Integer . parseInt ( str ) ; \n \n \t4 } catch ( NumberFormatException e ) { \n \n <ect>
\t4 String since = MIN_QUERY_VERSION ; \n \n \t4 if ( VersionComparator . comp ( v , since ) < 0 ) { \n \n \t5 failed ( peer , false ) ; \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 } else \n \n \t6 addPeer ( pn , true , false ) ; \n \n \t5 gotSome = true ; \n \n \t4 } catch ( FSParseException e2 ) { \n \n <ect>
\t2 <comment> \n \n \t2 return null ; } \n \n \t1 @ Override \n \n \t1 public EndPoint select ( DataObject srcData , DataObject destData , StorageAction action ) { \n \n <ect>
\t4 connection . open ( <string_literal> , brokerService . getTransportConnectors ( ) . get ( 0 ) . getConnectUri ( ) . getPort ( ) ) ; \n \n \t4 connection . connect ( <string_literal> , <string_literal> ) ; \n \n \t4 connection . disconnect ( ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 boolean removed = _synQueue . remove ( _synPacket ) ; \n \n \t3 if ( removed ) { \n \n \t4 if ( _synPacket . isFlagSet ( Packet . FLAG_SYNCHRONIZE ) ) { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
<comment> \n \n \t1 public EntityData . Component serialize ( Component base , Component delta , FieldSerializeCheck < Component > check ) { \n \n \t2 ComponentMetadata < ? > componentMetadata = componentLibrary . getMetadata ( base . getClass ( ) ) ; \n \n \t2 if ( componentMetadata == null ) { \n \n <ect>
\t1 LinkedHashMap < String , String > currObject = nextObject ; \n \n \t1 try { \n \n \t1 nextObject = readNextObject ( this . reader ) ; \n \n \t1 } catch ( EndOfDocumentException e ) { \n \n <ect>
\t2 throws TException { \n \n \t1 try { \n \n \t2 checkPermission ( credentials , lock , <string_literal> ) ; \n \n \t1 } catch ( ThriftSecurityException e ) { \n \n <ect>
\t1 public Producer createProducer ( ) throws Exception { \n \n \t2 IgniteAtomicSequence atomicSeq = ignite ( ) . atomicSequence ( name , initialValue , false ) ; \n \n \t2 if ( atomicSeq == null ) { \n \n \t3 atomicSeq = ignite ( ) . atomicSequence ( name , initialValue , true ) ; \n \n <ect>
\t5 if ( ! downloaded ) continue ; \n \n \t5 throw new PluginNotFoundException ( <string_literal> ) ; } \n \n \t4 Attributes mainAttributes = manifest . getMainAttributes ( ) ; \n \n \t4 if ( mainAttributes == null ) { \n \n <ect>
\t2 synchronized ( results ) { \n \n \t3 final Future < RFXComTransmitterMessage > old = results . get ( seqNumber ) ; \n \n \t3 assert old == null : <string_literal> ; \n \n \t3 if ( old != null ) { \n \n <ect>
\t2 <comment> \n \n \t2 Account caller = CallContext . current ( ) . getCallingAccount ( ) ; \n \n \t2 if ( ! _accountMgr . isRootAdmin ( caller . getId ( ) ) ) { \n \n <ect>
<comment> \n \n \t1 public static boolean isAuthorizedResponseTypeForService ( final J2EContext context , final OAuthRegisteredService registeredService ) { \n \n \t2 final String responseType = context . getRequestParameter ( OAuth20Constants . RESPONSE_TYPE ) ; \n \n \t2 if ( registeredService . getSupportedResponseTypes ( ) != null && ! registeredService . getSupportedResponseTypes ( ) . isEmpty ( ) ) { \n \n <ect>
\t5 Thread . sleep ( sleep ) ; \n \n \t4 } catch ( InterruptedException ie ) { \n \n \t5 LOG . debug ( <string_literal> + ie ) ; } } \n \n \t3 consumer . close ( ) ; \n \n <ect>
<comment> \n \n protected List < TermInfoClusterInOut > getClusterLabels ( Integer integer , \n \n <number_literal> Collection < WeightedPropertyVectorWritable > wpvws ) throws IOException { \n \n \t1 if ( wpvws . size ( ) < minNumIds ) { \n \n <ect>
\t8 + Arrays . toString ( matches . toArray ( ) ) ; \n \n \t3 logger . error ( errorMessage ) ; \n \n \t3 throw new VoldemortApplicationException ( errorMessage ) ; \n \n \t2 } else { \n \n <ect>
\t1 DirLock dirlock = DirLock . tryLock ( hdfs , lockDirPath ) ; \n \n \t1 if ( dirlock == null ) { \n \n \t1 dirlock = DirLock . takeOwnershipIfStale ( hdfs , lockDirPath , lockTimeoutSec ) ; \n \n \t1 if ( dirlock == null ) { \n \n <ect>
\t2 Addresses . getInstance ( ) . stop ( address ) } \n \n \t1 } catch ( final Exception e ) { \n \n \t2 logger . error ( <string_literal> , e ) } \n \n \t1 } catch ( NoSuchElementException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 LockInfo out = new LockInfo ( ) ; \n \n \t3 java . nio . channels . FileLock informationRegionLock = lockInformationRegion ( LockMode . Shared , backoff ) ; \n \n \t3 if ( informationRegionLock == null ) { \n \n <ect>
\t3 return ; } \n \n \t2 final List < X509CRL > expiredCrls = new ArrayList < > ( ) ; \n \n \t2 final List < X509CRLEntry > revokedCrls ; \n \n \t2 crls . stream ( ) . filter ( CertUtils : : isExpired ) . forEach ( crl - > { \n \n <ect>
\t3 if ( fileContainers . size ( ) == 1 && defaultFile . length ( ) > 0 ) { \n \n \t4 log . warn ( <string_literal> + defaultFile ) ; \n \n \t4 file = defaultFile ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t5 } else { \n \n \t6 printer = client . getPrinter ( printerUrl ) ; } \n \n \t5 if ( printer != null ) { \n \n \t6 value = new DecimalType ( client . getJobs ( printer , whichJobs , <string_literal> , false ) . size ( ) ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlIDPRequestProcessingError ( Throwable t ) { \n \n <ect>
\t5 logger . warn ( <string_literal> ) ; \n \n \t5 return ; } \n \n \t4 if ( isTopNCompatibleSum ( measureDesc . getFunction ( ) , origFunc ) == false ) { \n \n \t5 continue ; } \n \n <ect>
\t5 if ( fullCheckpoint ) { \n \n \t6 if ( mark != null && ( newMark == null || newMark . compareTo ( mark ) < 0 ) ) { \n \n \t7 newMark = mark ; } } } \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t4 sendMessage ( coordinator , new PrepareConsistentResponse ( sessionID , getBroadcastAddressAndPort ( ) , true ) ) ; \n \n \t4 executor . shutdown ( ) ; } \n \n \t3 public void onFailure ( Throwable t ) \n \n \t3 { \n \n <ect>
\t2 } finally { \n \n \t3 IOUtils . closeQuietly ( writer ) ; } \n \n \t2 manager . storeConfiguration ( ) ; \n \n \t2 File configFile = configurer . getConfigFile ( ) . file ( ) ; \n \n <ect>
\t2 for ( SockIO socket : toClose ) { \n \n \t3 try { \n \n \t4 socket . trueClose ( false ) ; } \n \n \t3 catch ( Exception ex ) { \n \n <ect>
\t3 JSONObject jsonObj = XML . toJSONObject ( fileContents ) ; \n \n \t3 Object json = JSONUtil . createJson ( jsonObj . toString ( ) ) ; \n \n \t3 jsonImport = new JsonImport ( json , this . getFactory ( ) , this . getWorksheet ( ) , workspace , maxNumLines ) ; \n \n \t2 } catch ( JSONException ex ) { \n \n <ect>
\t5 throw new ConcurrentSnapshotExecutionException ( repositoryName , snapshotName , <string_literal> ) ; } \n \n \t4 return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , snapshots ) . build ( ) ; } \n \n \t3 @ Override \n \n \t3 public void onFailure ( String source , Exception e ) { \n \n <ect>
\t3 long [ ] stats = getNetworkStats ( conn , cmd . getPrivateIP ( ) ) ; \n \n \t3 NetworkUsageAnswer answer = new NetworkUsageAnswer ( cmd , <string_literal> , stats [ 0 ] , stats [ 1 ] ) ; \n \n \t3 return answer ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <string_literal> ) . setSnapshots ( <string_literal> ) . execute ( ) . actionGet ( ) . getSnapshots ( ) . get ( 0 ) . state ( ) , equalTo ( SnapshotState . PARTIAL ) ) ; } \n \n \t2 assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( <string_literal> , <string_literal> ) . execute ( ) . actionGet ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 assertThrows ( client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <string_literal> , <string_literal> ) . setRestoreGlobalState ( false ) . setWaitForCompletion ( true ) . execute ( ) , SnapshotRestoreException . class ) ; \n \n <ect>
\t2 taskManagerMetricGroup . close ( ) ; \n \n \t2 if ( throwable != null ) { \n \n \t3 return FutureUtils . completedExceptionally ( new FlinkException ( <string_literal> , throwable ) ) ; \n \n \t2 } else { \n \n <ect>
\t4 try { \n \n \t5 long value = Long . parseLong ( property ) ; \n \n \t5 this . setPhyTimeoutMillis ( value ) ; \n \n \t4 } catch ( NumberFormatException e ) { \n \n <ect>
\t1 if ( ! bws . containsKey ( table ) ) \n \n \t2 try { \n \n \t2 addTable ( table ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t5 msg = <string_literal> ; \n \n \t5 <comment> \n \n \t5 useMasterPasswordCheckBox . setSelected ( true ) ; \n \n \t5 changeMasterPasswordButton . setEnabled ( true ) ; } \n \n <ect>
\t6 def runtimeConfig = configSlurper . parse ( runtimeResource . getURL ( ) ) \n \n \t6 propertySource . merge ( runtimeConfig , false ) } \n \n \t5 return new NavigableMapPropertySource ( name , propertySource ) \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t3 { \n \n \t4 compiled . add ( Pattern . compile ( pattern ) ) ; } \n \n \t3 catch ( PatternSyntaxException e ) \n \n \t3 { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t2 if ( samples . isEmpty ( ) && ! noSamplesSpecified ) \n \n \t3 throw new UserException ( <string_literal> ) ; \n \n \t2 if ( ! noSamplesSpecified ) \n \n \t3 for ( String sample : samples ) \n \n <ect>
\t3 } else { \n \n \t4 responseStatus = responseStatus . substring ( responseStatus . indexOf ( ' ' ) + 1 , responseStatus . indexOf ( ' ' , responseStatus . indexOf ( ' ' ) + 1 ) ) ; \n \n \t4 int status = Integer . parseInt ( responseStatus ) ; \n \n \t4 if ( status != <number_literal> ) { \n \n <ect>
\t3 e . printStackTrace ( ) ; } \n \n \t2 return resp ; } \n \n \t1 protected VirtualRouter stopNetScalerVm ( final long vmId , final boolean forced , final Account caller , final long callerUserId ) throws ResourceUnavailableException , ConcurrentOperationException { \n \n \t2 final DomainRouterVO netscalerVm = _routerDao . findById ( vmId ) ; \n \n <ect>
\t2 } catch ( IllegalBlockSizeException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( BadPaddingException e ) { \n \n <ect>
\t3 else if ( CompletableFuture . class . equals ( returnType ) ) { <comment> \n \n \t4 return CompletableFuture . supplyAsync ( invoker , this . asyncExecutor ) ; } \n \n \t3 else if ( Future . class . isAssignableFrom ( returnType ) ) { \n \n <ect>
\t3 return null ; \n \n \t2 try { \n \n \t3 return controlInterfaceCache . get ( instance . getInstanceId ( ) ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
private val log = logProvider . getLog ( getClass ) \n \n private val cacheMonitor = kernelMonitors . newMonitor ( classOf [ StringCacheMonitor ] ) \n \n kernelMonitors . addMonitorListener ( new StringCacheMonitor { \n \n \t1 override def cacheDiscard ( ignored : String , query : String , secondsSinceReplan : Int ) { \n \n <ect>
\t5 return callback . authenticated ( federatedIdentity ) ; } \n \n \t3 } catch ( WebApplicationException e ) { \n \n \t4 return e . getResponse ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 _downloadMonitor . downloadVolumeToStorage ( data , caller ) ; } } \n \n \t1 protected Void createTemplateAsyncCallback ( AsyncCallbackDispatcher < ? extends BaseImageStoreDriverImpl , DownloadAnswer > callback , \n \n \t2 CreateContext < CreateCmdResult > context ) { \n \n <ect>
\t4 nodesSampler . sample ( ) ; \n \n \t4 if ( ! closed ) { \n \n \t5 nodesSamplerFuture = threadPool . schedule ( nodesSamplerInterval , ThreadPool . Names . GENERIC , this ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
# no way to execute shell command with bash pipes under sudo , it is fully dev responsibility \n \n if not is_under_root ( ) and not isinstance ( command , str ) : \n \n \t1 command = <string_literal> . format ( AMBARI_SUDO_BINARY , string_cmd_from_args_list ( command ) ) # core . shell . as_sudo \n \n elif not is_under_root ( ) and isinstance ( command , str ) : \n \n <ect>
\t2 total = Long . parseLong ( response . split ( <string_literal> ) [ 1 ] . trim ( ) ) ; \n \n \t2 log . info ( <string_literal> , total ) ; \n \n \t2 if ( total > MIN && total < MAX ) { \n \n \t2 break ; } \n \n <ect>
\t3 log . info ( <string_literal> ) ; \n \n \t2 else \n \n \t3 System . out . println ( <string_literal> ) ; \n \n \t2 log . warning ( <string_literal> ) ; \n \n <ect>
\t3 return sig ; } \n \n \t2 private boolean validateSignature ( final byte [ ] signature , final byte message [ ] ) throws NTLMEngineException \n \n \t2 { \n \n \t3 final byte [ ] computedSignature = computeSignature ( message ) ; \n \n <ect>
\t5 StreamingRepairTask task = new StreamingRepairTask ( desc , request ) ; \n \n \t5 task . run ( ) ; \n \n \t5 break ; \n \n \t4 case ANTICOMPACTION_REQUEST : \n \n <ect>
\t2 int index = 0 ; \n \n \t2 for ( Map . Entry < String , String > header : headers . entrySet ( ) ) { \n \n \t3 logger . debug ( <string_literal> , header . getKey ( ) , header . getValue ( ) ) ; \n \n \t3 requestHeaders [ index ++ ] = new BasicHeader ( header . getKey ( ) , header . getValue ( ) ) ; } \n \n <ect>
\t5 LOG . warn ( <string_literal> , restartStrategyName ) ; \n \n \t4 } catch ( NoSuchMethodException nsme ) { \n \n \t5 LOG . warn ( <string_literal> , restartStrategyName , CREATE_METHOD ) ; \n \n \t4 } catch ( InvocationTargetException ite ) { \n \n <ect>
\t2 getProps ( ) . setProperty ( n , getOverlay ( ) . getProperty ( deprecatedKey ) ) ; \n \n \t2 getOverlay ( ) . setProperty ( n , getOverlay ( ) . getProperty ( deprecatedKey ) ) ; } } \n \n \t1 return names . toArray ( new String [ names . size ( ) ] ) ; } \n \n private void handleDeprecation ( ) { \n \n <ect>
\t3 case SENSOR_MULTI_LEVEL_SUPPORTED_GET : \n \n \t4 logger . warn ( <string_literal> , command ) ; \n \n \t4 return ; \n \n \t3 case SENSOR_MULTI_LEVEL_SUPPORTED_REPORT : \n \n <ect>
\t1 if ( ! tarballFile . isFile ( ) || ! tarballFile . canRead ( ) ) { \n \n \t1 throw new Exception ( <string_literal> \n \n \t2 + tarballPath + <string_literal> \n \n \t2 + <string_literal> + PROP_PATH_TO_DIST_TARBALL ) ; } \n \n <ect>
\t1 <comment> \n \n \t1 private void persistCache ( ) { \n \n <ect>
\t3 OutputStream out = s . getOutputStream ( ) ; \n \n \t3 out . write ( DataHelper . getASCII ( <string_literal> ) ) ; \n \n \t3 BufferedReader reader = new BufferedReader ( new InputStreamReader ( s . getInputStream ( ) ) ) ; \n \n \t3 String line = reader . readLine ( ) ; \n \n <ect>
\t2 assertThat ( appender . lastEvent . getLevel ( ) , equalTo ( Level . ERROR ) ) ; \n \n \t2 assertThat ( appender . lastEvent . getThrown ( ) , equalTo ( ex ) ) ; \n \n \t2 assertThat ( appender . lastParameterizedMessage ( ) . getFormattedMessage ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 ex = randomException ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
\t3 resp . setHeader ( <string_literal> , se . getDescription ( ) ) ; \n \n \t3 HttpUtils . writeHttpResponse ( resp , serializedResponseText , se . getErrorCode ( ) . getHttpCode ( ) , responseType , ApiServer . JSONcontentType . value ( ) ) ; \n \n \t3 auditTrailSb . append ( <string_literal> + se . getErrorCode ( ) + <string_literal> + se . getDescription ( ) ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t1 if ( latestFile != null ) { \n \n \t1 try { \n \n \t2 onChange ( latestFile ) ; \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t5 } catch ( InterruptedException e ) { \n \n \t6 e . printStackTrace ( ) ; \n \n \t6 exceptions . add ( e ) ; } } \n \n \t3 } catch ( JMSException e ) { \n \n <ect>
\t2 BasicDBObject result ; \n \n \t2 try { \n \n \t3 result = getReplicaConfig ( ) ; \n \n \t2 } catch ( MongoException e ) { \n \n <ect>
\t2 try { \n \n \t3 if ( allowPartial ) { \n \n \t4 <comment> \n \n \t4 if ( randomBoolean ( ) ) { \n \n <ect>
\t4 } else { \n \n \t5 parent = ( PlexusContainer ) ctx . getAttribute ( PlexusLifecycleListener . KEY ) ; } \n \n \t4 if ( parent . hasChildContainer ( CHILD_CONTAINER_NAME ) ) { \n \n <ect>
\t2 log . trace ( <string_literal> ) ; \n \n \t2 List < Activity > osActivities = new ArrayList < Activity > ( ) ; \n \n \t2 try \n \n \t2 { \n \n <ect>
\t5 ServletOps . responseSendError ( response , ex . getResponseCode ( ) ) ; \n \n \t4 else \n \n \t5 ServletOps . responseSendError ( response , ex . getResponseCode ( ) , ex . getMessage ( ) ) ; \n \n \t3 } catch ( RuntimeIOException ex ) { \n \n <ect>
\t1 $LOG . info ( <string_literal> + r . getRegionNameAsString ( ) + <string_literal> + count . to_s + \n \n \t2 <string_literal> + regions . length . to_s + <string_literal> + servername ) \n \n \t1 next \n \n \t1 end \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 try { \n \n \t5 long contentLength = Long . parseLong ( contentLengthStr ) ; \n \n \t5 publishRequestContentLength ( listener , contentLength ) ; \n \n \t4 } catch ( NumberFormatException e ) { \n \n <ect>
\t1 private void updateServiceRegistryWithMatchingService ( final List < RegisteredService > services , final RegisteredService cachedService , \n \n <number_literal> final RegisteredService matchingService , final ServiceRegistry serviceRegistry ) { \n \n \t2 LOGGER . debug ( <string_literal> , matchingService , distributedCacheManager . getName ( ) ) ; \n \n \t2 if ( matchingService . equals ( cachedService ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 in = new FileInputStream ( module . getFile ( ) ) ; \n \n \t4 out = new FileOutputStream ( tmpModuleJar ) ; \n \n \t4 OpenmrsUtil . copyFile ( in , out ) ; } \n \n \t3 catch ( IOException io ) { \n \n <ect>
\t4 if ( request . getHdr ( ) != null ) { \n \n \t5 request . getHdr ( ) . setType ( OpCode . error ) ; \n \n \t5 request . setTxn ( new ErrorTxn ( ke . code ( ) . intValue ( ) ) ) ; } \n \n \t4 request . setException ( ke ) ; \n \n <ect>
\t1 public final void shutdown ( ) { \n \n \t2 try { \n \n \t3 if ( connectorServer != null && connectorServer . isActive ( ) ) { \n \n \t4 connectorServer . stop ( ) ; \n \n <ect>
\t2 if ( cachedSolrServer != null ) { \n \n \t3 try { \n \n \t4 cachedSolrServer . shutdown ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
@ Override \n \n public CommandReport execute ( \n \n \t1 ConcurrentMap < String , Object > requestSharedDataContext ) \n \n \t1 throws AmbariException , InterruptedException { \n \n <ect>
\t4 pollTimeStart = 0 ; \n \n \t4 logger . debug ( <string_literal> ) ; } \n \n \t2 } else { \n \n \t3 closeConnection ( ) ; \n \n <ect>
\t5 logger . error ( <string_literal> , ex ) ; } } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t3 <comment> \n \n \t3 t . run ( ) ; \n \n \t2 } catch ( IOException ex ) { \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) { \n \n <ect>
\t2 return chat ; } \n \n \t1 private static class XMPPConnectionListener extends AbstractConnectionListener { \n \n \t2 @ Override \n \n \t2 public void connectionClosed ( ) { \n \n <ect>
\t2 public Random create ( ) { \n \n \t3 return new BouncyCastleRandom ( ) ; } } \n \n \t1 private final RandomGenerator random = new VMPCRandomGenerator ( ) ; \n \n \t1 public BouncyCastleRandom ( ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void execute ( ) { \n \n <ect>
\t5 logger . warn ( <string_literal> , getUuid ( ) ) ; } \n \n \t3 } else { \n \n \t4 logger . warn ( <string_literal> , getUuid ( ) ) ; } \n \n \t2 } else { \n \n <ect>
\t4 _volumeDao . update ( volumeId , volume ) ; } \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( NaException nae ) { \n \n \t3 <comment> \n \n <ect>
\t1 protected void doStart ( ) throws Exception { \n \n \t2 if ( producerCache == null ) { \n \n \t3 if ( cacheSize < 0 ) { \n \n \t4 producerCache = new EmptyProducerCache ( this , camelContext ) ; \n \n <ect>
\t5 if ( outmsg != null ) \n \n \t5 { \n \n \t6 if ( ! inmsg . equals ( outmsg ) ) { \n \n \t7 if ( _log . shouldLog ( Log . WARN ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( ! preconditions . areSatisfied ( ) ) { \n \n <ect>
\t2 Logger . info ( <string_literal> . format ( old_conf , current_dir ) ) \n \n \t2 Link ( old_conf , action = <string_literal> ) \n \n \t2 Link ( old_conf , to = current_dir ) \n \n \t2 else : \n \n <ect>
\t4 return false ; } \n \n \t3 <comment> \n \n \t3 return waitForTableToBecomeActive ( tableName ) ; \n \n \t2 } catch ( AmazonClientException e ) { \n \n <ect>
\t1 options . description ( description ) ; \n \n \t1 options . deploy ( false ) ; \n \n \t1 options . powerOn ( false ) ; \n \n \t1 URI VDC = URI . create ( template . getLocation ( ) . getId ( ) ) ; \n \n <ect>
\t4 if ( inactiveName != null ) { \n \n \t5 inactiveDurableTopicSubscribers . remove ( inactiveName ) ; \n \n \t5 managementContext . unregisterMBean ( inactiveName ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 if ( qualifiers == null ) { \n \n \t6 qualifiers = new NSMutableArray ( ) ; \n \n \t6 qualifiers . addObjectsFromArray ( q . qualifiers ( ) ) ; } \n \n \t5 if ( cache == q1 ) \n \n <ect>
private boolean closeCompleting = false ; \n \n synchronized void completeClose ( boolean saveState , boolean completeClose ) throws IOException { \n \n \t1 if ( ! isClosing ( ) || isCloseComplete ( ) || closeCompleting ) { \n \n \t1 throw new IllegalStateException ( <string_literal> + closeState ) ; } \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 for item in pids : \n \n \t2 if pid_exists ( item [ <string_literal> ] ) and ( item [ <string_literal> ] not in exclude_list ) : \n \n \t2 pfile . write ( <string_literal> % item [ <string_literal> ] ) \n \n \t2 pid_saved = item [ <string_literal> ] \n \n <ect>
public Response fetchJobStatus ( @ PathParam ( <string_literal> ) String jobId ) throws ItemNotFound , HiveClientException , NoOperationStatusSetException { \n \n \t1 JobController jobController = getResourceManager ( ) . readController ( jobId ) ; \n \n \t1 Job job = jobController . getJob ( ) ; \n \n \t1 String jobStatus = job . getStatus ( ) ; \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + utilities . getScope ( EJBBookReader . class ) ) ; \n \n \t2 log . info ( <string_literal> + utilities . getScope ( EJBBookReaderImpl . class ) ) ; \n \n \t2 log . info ( <string_literal> + utilities . getScope ( EJBBookWriterImpl . class ) ) ; \n \n <ect>
\t2 Context ctx = Contexts . lookup ( request . getCorrelationId ( ) ) ; \n \n \t2 accnt = ctx . getAccount ( ) . getAccountNumber ( ) ; \n \n \t2 src = ctx . getRemoteAddress ( ) . getHostAddress ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 channelState . unackedMessageDeliveryTags . add ( deliveryTag ) ; } \n \n \t3 } finally { \n \n \t4 channelState . lock . unlock ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 PrintStream out = new PrintStream ( buffer ) ; \n \n \t3 CmsShell shell = new CmsShell ( cms , <string_literal> , null , out , out ) ; \n \n \t3 shell . execute ( importScript ) ; \n \n \t3 String outputString = buffer . toString ( ) ; \n \n <ect>
\t2 this . recipient = recipient ; } \n \n \t1 public Message < String > receive ( ) { \n \n \t2 try { \n \n \t3 if ( counter > <number_literal> ) { \n \n <ect>
\t1 if ( opState . isTerminal ( ) ) { \n \n \t1 <comment> \n \n \t1 LOG . debug ( opHandle + <string_literal> + opState ) ; \n \n \t1 } else { \n \n <ect>
\t5 throw new UnrecognizableServiceForServiceTicketValidationException ( serviceTicket . getService ( ) ) ; } } \n \n \t3 final Service selectedService = resolveServiceFromAuthenticationRequest ( serviceTicket . getService ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , selectedService ) ; \n \n \t3 final RegisteredService registeredService = this . servicesManager . findServiceBy ( selectedService ) ; \n \n <ect>
\t5 null ) . method ( <string_literal> ) . getConnection ( ) ; \n \n \t3 HttpResponse response = Utils . doVoidOperation ( urlConnection ) ; \n \n \t3 if ( ! response . isSuccessCode ( ) ) { \n \n \t4 if ( response . isAuthDenied ( ) ) { \n \n <ect>
\t3 boolean granted = false ; \n \n \t3 for ( SecurityChecker checker : _securityCheckers ) { \n \n \t4 if ( checker . checkAccess ( caller , entity , accessType ) ) { \n \n <ect>
\t2 boolean result = true ; \n \n \t2 try { \n \n \t3 <comment> \n \n \t3 if ( ! _networkModel . isVmPartOfNetwork ( router . getId ( ) , network . getId ( ) ) ) { \n \n <ect>
\t4 dsMo . deleteFile ( cmd . getVolume ( ) . getPath ( ) + <string_literal> , morDc , true ) ; } \n \n \t3 return new Answer ( cmd , true , <string_literal> ) ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t8 registerFamily ( familyName , fullName , null ) ; \n \n \t8 break ; } } } } } \n \n \t3 else if ( path . toLowerCase ( ) . endsWith ( <string_literal> ) ) { \n \n \t4 if ( alias != null ) \n \n <ect>
\t1 @ Override \n \n \t1 public void monitorTarget ( ResourceID resourceID , HeartbeatTarget < O > heartbeatTarget ) { \n \n \t2 if ( ! stopped ) { \n \n \t3 if ( heartbeatTargets . containsKey ( resourceID ) ) { \n \n <ect>
\t5 String err = <string_literal> + event + <string_literal> + currentStatus + <string_literal> + hostId ; \n \n \t5 s_logger . debug ( err ) ; \n \n \t5 throw new CloudRuntimeException ( err ) ; } \n \n <ect>
\t5 status += <string_literal> + holder . failReason + <string_literal> ; \n \n \t4 } else if ( ! holder . hasBakedQuads ( ) ) { \n \n \t5 status += <string_literal> ; } \n \n \t4 BCLog . logger . info ( <string_literal> + holder . modelLocation + status ) ; } \n \n <ect>
\t3 pathList . add ( coreResourcePath ) ; } \n \n \t2 if ( configPaths != null ) { \n \n \t3 pathList . addAll ( Arrays . asList ( configPaths ) ) ; } \n \n \t2 if ( testMode ) { \n \n <ect>
\t3 return instanceId ; } } \n \n \t1 private class LoggingListener implements CloudListener { \n \n \t2 @ Override \n \n \t2 public void transmissionStarted ( ) { \n \n <ect>
\t3 context . setIdp ( this ) ; \n \n \t3 context . setIdpConfig ( getConfig ( ) ) ; \n \n \t3 return context ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 if ( ! isClosed ( ) && disposeClusterCommandExecutorOnClose ) { \n \n \t3 try { \n \n \t4 clusterCommandExecutor . destroy ( ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 manifestDir = null ; } \n \n \t1 Utilities . FILE_OP_LOGGER . debug ( <string_literal> , specPath ) ; \n \n \t1 JavaUtils . IdPathFilter filter = new JavaUtils . IdPathFilter ( writeId , stmtId , true , false ) ; \n \n \t1 if ( isMmCtas && ! fs . exists ( specPath ) ) { \n \n <ect>
\t3 if ( field . getJavadoc ( ) . isPresent ( ) ) { \n \n \t4 final ConfigurationMetadataProperty prop = createConfigurationProperty ( field , property ) ; \n \n \t4 processNestedClassOrInterfaceTypeIfNeeded ( field , prop ) ; \n \n \t3 } else { \n \n <ect>
\t4 TextMessage message = session . createTextMessage ( name . getMethodName ( ) + <string_literal> + id ) ; \n \n \t4 message . setIntProperty ( <string_literal> , id ) ; \n \n \t4 producer . send ( message ) ; \n \n \t4 if ( id % <number_literal> == 0 ) { \n \n <ect>
\t2 if ( result . isPaused ( ) ) { \n \n \t3 input . put ( REFERER_FLOW_EXECUTION_ATTRIBUTE , result . getPausedKey ( ) ) ; } \n \n \t2 String url = flowUrlHandler . createFlowDefinitionUrl ( flowId , input , request ) ; \n \n <ect>
\t3 Message msgc = session . createTextMessage ( <string_literal> ) ; \n \n \t3 msgc . setStringProperty ( <string_literal> , <string_literal> ) ; \n \n \t3 producer . send ( msgc ) ; } \n \n \t2 doneSignal . await ( ) ; \n \n <ect>
\t1 public void onPrepareFatalError ( Exception exception , Map < String , Object > parameters ) \n \n \t1 { \n \n \t2 super . onPrepareFatalError ( exception , parameters ) ; \n \n \t2 <comment> \n \n <ect>
\t4 if ( mcast_addr != null ) { \n \n \t5 mcast_sock . leaveGroup ( mcast_addr . getIpAddress ( ) ) ; } \n \n \t4 getSocketFactory ( ) . close ( mcast_sock ) ; <comment> \n \n \t4 mcast_sock = null ; \n \n <ect>
\t3 Preconditions . checkArgument ( output != null , <string_literal> + id ) ; \n \n \t3 output . getInfo ( ) . putAll ( info ) ; \n \n \t3 executableDao . updateJobOutput ( output ) ; \n \n \t2 } catch ( PersistentException e ) { \n \n <ect>
\t2 break ; } \n \n \t1 default : throw new AssertionError ( <string_literal> + kr ) ; } } \n \n \t1 <comment> \n \n \t1 if ( e . hasClusterStateChanged ) { \n \n <ect>
\t5 return <number_literal> ; \n \n \t4 } else { \n \n \t5 s_logger . info ( <string_literal> + responseCode ) ; \n \n \t5 String volumeId = values . get ( <string_literal> ) ; \n \n <ect>
\t3 if ( StringUtils . isNotBlank ( source ) ) { \n \n \t4 try { \n \n \t5 return ( T ) Enum . valueOf ( enumType , source ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
# init data , once loggers are setup to see exceptions / errors of initialization . \n \n initializer_module . init ( ) \n \n if home_dir != <string_literal> : \n \n \t1 # When running multiple Ambari Agents on this host for simulation , each one will use a unique home directory . \n \n <ect>
\t2 RemoveRandomWithObject < T > firstRGA = rga ; \n \n \t2 if ( rga == null ) { \n \n \t3 Logger . error ( this , <string_literal> + this ) ; \n \n \t3 if ( grabArrays [ 1 - x ] == null ) { \n \n <ect>
\t4 try { \n \n \t5 <comment> \n \n \t5 extension = this . extensionRepository . resolve ( extensionId ) ; \n \n \t4 } catch ( ResolveException e ) { \n \n <ect>
public void deleteFileQueryLogs ( String homedir ) { \n \n \t1 try { \n \n \t1 File file = new File ( homedir + <string_literal> ) ; \n \n \t1 if ( file . delete ( ) ) { \n \n <ect>
\t1 public static final Logger log = Logger . getLogger ( KeyValueCodingProtectedAccessor . class ) ; \n \n \t1 public KeyValueCodingProtectedAccessor ( ) { super ( ) ; } \n \n \t1 @ Override \n \n \t1 public Object fieldValue ( Object object , Field field ) throws IllegalArgumentException , IllegalAccessException { \n \n <ect>
\t2 sfaiSetup ( ) ; } \n \n \t1 @ Override \n \n \t1 public boolean test ( ) { \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t5 directByteBufferFreeMethod . setAccessible ( true ) ; \n \n \t5 directByteBufferFreeMethod . invoke ( directByteBuffer ) ; \n \n \t5 success = true ; \n \n \t4 } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void check ( ) { \n \n \t2 GlobalLock lock = GlobalLock . getInternLock ( <string_literal> ) ; \n \n \t2 try { \n \n <ect>
abstract protected void doDispose ( ) ; \n \n @ Override \n \n public final void initialise ( ) throws InitialisationException { \n \n \t1 if ( id == null ) { \n \n <ect>
\t2 this ( node , message , null ) ; } \n \n \t1 public JCExpression makeErroneous ( AbstractTransformer gen ) { \n \n \t2 return gen . makeErroneous ( node , getMessage ( ) ) ; } \n \n \t1 public void logError ( AbstractTransformer gen ) { \n \n <ect>
\t1 public boolean destroyNetwork ( long networkId , ReservationContext context ) { \n \n \t2 Account callerAccount = _accountMgr . getAccount ( context . getCaller ( ) . getAccountId ( ) ) ; \n \n \t2 NetworkVO network = _networksDao . findById ( networkId ) ; \n \n \t2 if ( network == null ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t2 producer . setPriority ( <number_literal> ) ; \n \n \t2 for ( int i = 0 ; i < numToSend ; i ++ ) { \n \n \t3 Message msg = session . createTextMessage ( <string_literal> + i ) ; \n \n \t3 producer . send ( msg ) ; } \n \n <ect>
\t6 vmMo . detachDisk ( volumeDatastorePath , false ) ; } \n \n \t4 } finally { \n \n \t5 s_logger . info ( <string_literal> ) ; \n \n \t5 if ( vmMo != null ) { \n \n <ect>
\t3 result . setSuccessIsSet ( true ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
This function will obtain the Kerberos ticket if security is enabled . \n \n : return : \n \n <string_literal> <string_literal> <ect>
\t3 <comment> \n \n \t3 installDatabase ( false , databaseName , false , \n \n \t4 OGlobalConfiguration . DISTRIBUTED_BACKUP_TRY_INCREMENTAL_FIRST . getValueAsBoolean ( ) ) ; } } \n \n \t1 } else if ( key . startsWith ( CONFIG_REGISTEREDNODES ) ) { \n \n <ect>
\t6 + <string_literal> + roles [ i ] + <string_literal> ) ; } \n \n \t4 return ( true ) ; } } \n \n \t2 <comment> \n \n <ect>
\t3 bshInterpreter . set ( <string_literal> , samp ) ; <comment> \n \n \t3 processFileOrScript ( bshInterpreter ) ; \n \n \t2 } catch ( JMeterException e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + physicalMemSize ) ; \n \n \t3 long workerMemSize = ConfigExtension . getMemSizePerWorker ( conf ) ; \n \n \t3 memPortNum = ( int ) ( physicalMemSize / ( workerMemSize * memWeight ) ) ; \n \n \t3 if ( memPortNum < 1 ) { \n \n <ect>
\t2 <comment> \n \n \t2 log . info ( <string_literal> + token ) ; \n \n \t2 log . info ( <string_literal> + jobConf . getCredentials ( ) . getAllTokens ( ) ) ; \n \n \t2 AuthenticationToken unwrappedToken = ConfiguratorBase . unwrapAuthenticationToken ( jobConf , token ) ; \n \n <ect>
\t2 } catch ( final BadServerResponse e ) { \n \n \t3 s_logger . debug ( <string_literal> , e ) ; \n \n \t3 errorMsg = e . toString ( ) ; \n \n \t2 } catch ( final XenAPIException e ) { \n \n <ect>
\t3 { \n \n \t3 finalKey = ArgumentUtils . dataMapToCompoundKey ( ( DataMap ) compoundKey , resource . getKeys ( ) ) ; } \n \n \t3 catch ( IllegalArgumentException e ) \n \n \t3 { \n \n <ect>
\t3 mos . write ( BatchConstants . CFG_OUTPUT_STATISTICS , new LongWritable ( i ) , new BytesWritable ( valueBuf . array ( ) , valueBuf . limit ( ) ) , statisticsFileName ) ; } } \n \n \t1 private void logMapperAndCuboidStatistics ( List < Long > allCuboids ) throws IOException { \n \n \t2 logger . info ( <string_literal> + taskId + <string_literal> + allCuboids . size ( ) ) ; \n \n \t2 logger . info ( <string_literal> + samplingPercentage ) ; \n \n <ect>
\t4 try { \n \n \t5 ret . add ( new LocalFsBlobStoreFile ( sub . getParentFile ( ) , sub . getName ( ) ) ) ; \n \n \t4 } catch ( IllegalArgumentException e ) { \n \n \t5 <comment> \n \n <ect>
\t2 } else { \n \n \t3 try { \n \n \t4 startAuthentication ( ) ; \n \n \t3 } catch ( DbxException e ) { \n \n <ect>
\t2 this . destinationInterceptors = null ; \n \n \t2 this . destinationFactory = null ; \n \n \t2 if ( startDate != null ) { \n \n \t3 LOG . info ( <string_literal> , new Object [ ] { getBrokerVersion ( ) , getBrokerName ( ) , brokerId , getUptime ( ) } ) ; } \n \n <ect>
\t1 public void testFutureEchoCallTwoTimes ( ) throws Exception { \n \n \t2 Echo service = ProxyHelper . createProxy ( context . getEndpoint ( <string_literal> ) , Echo . class ) ; \n \n \t2 Future < String > future = service . asText ( <number_literal> ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t4 fileType = FileTypeDetector . detectFileType ( inputStream ) ; \n \n \t4 metadata = getMetadata ( inputStream , fileType ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 metadata = new Metadata ( ) ; \n \n <ect>
\t2 SampleResult res = context . getPreviousResult ( ) ; \n \n \t2 HTTPSamplerBase sampler ; \n \n \t2 HTTPSampleResult result ; \n \n \t2 if ( ! ( sam instanceof HTTPSamplerBase ) || ! ( res instanceof HTTPSampleResult ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 ZWaveCommandClass zwaveCommandClass = this . getNode ( ) . getCommandClass ( commandClass ) ; \n \n \t4 if ( zwaveCommandClass == null ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 InputTableConfig tableConfig = getInputTableConfig ( attempt , split . getTableName ( ) ) ; \n \n <ect>
\t9 throw new RuntimeException ( e ) ; } } \n \n \t7 @ Override \n \n \t7 public void handleException ( TransportException exp ) { \n \n \t8 try { \n \n <ect>
\t4 response . setResponses ( resList ) ; \n \n \t4 response . setResponseName ( getCommandName ( ) ) ; \n \n \t4 this . setResponseObject ( response ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 peer . readBytes ( in ) ; \n \n \t3 _receivedUnconfirmedIdentity = peer ; \n \n \t2 } catch ( DataFormatException dfe ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 } else { \n \n \t4 final LocalDateTime stLocal = DateTimeUtils . localDateTimeOf ( this . startingDateTime ) ; \n \n \t4 if ( stLocal != null ) { \n \n \t5 if ( LocalDateTime . now ( ) . isBefore ( stLocal ) ) { \n \n <ect>
\t6 String . valueOf ( System . currentTimeMillis ( ) ) , \n \n \t6 String . valueOf ( timeOut ) , \n \n \t6 String . valueOf ( routingType ) ) ; \n \n \t3 responseCode = conn . getResponseCode ( ) ; \n \n <ect>
<comment> \n \n \t1 private void logException ( Exception e , String target , String user ) \n \n \t1 { \n \n <ect>
\t2 if ( isShutdown . get ( ) ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 break ; \n \n \t2 } else { \n \n <ect>
\t3 assertTrue ( ! frames . isEmpty ( ) ) ; \n \n \t3 publish = new PUBLISH ( ) . decode ( frames . get ( 0 ) ) ; \n \n \t3 frames . clear ( ) ; } \n \n \t2 long duration = System . currentTimeMillis ( ) - startTime ; \n \n <ect>
\t3 <comment> \n \n \t3 configureLog4J ( properties , pigContext ) ; \n \n \t3 log . info ( getVersionString ( ) . replace ( <string_literal> , <string_literal> ) ) ; \n \n \t3 if ( logFileName != null ) { \n \n <ect>
<comment> \n \n \t1 private void registerMacrosForWiki ( String wikiName , XWikiContext xcontext ) \n \n \t1 { \n \n \t2 try { \n \n <ect>
\t3 catch ( InterruptedException e ) { \n \n \t4 <comment> \n \n \t3 flusher . run ( ) ; } \n \n \t2 if ( this . fileStates . size ( ) > 0 ) { \n \n <ect>
\t1 public void start ( ) { \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 ivOneWireUpdateTask . start ( ) ; \n \n <ect>
\t4 logger . warn ( <string_literal> ) ; \n \n \t4 logger . warn ( <string_literal> ) ; \n \n \t4 logger . warn ( <string_literal> ) ; \n \n \t4 logger . warn ( <string_literal> ) ; \n \n <ect>
\t2 if ( null == children || children . length == 0 ) { \n \n \t3 try { \n \n \t3 delete ( directory ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 assertEquals ( <string_literal> , invalidValue , mappedValue ) ; \n \n \t1 assertTrue ( <string_literal> , jsonObj . isEmpty ( ) ) ; } \n \n @ Test \n \n public void testMapperDate_invalidDateStringValue ( ) { \n \n <ect>
\t1 K key = null ; \n \n \t1 if ( keys == null || keys . isEmpty ( ) ) { \n \n \t2 if ( ! map . isEmpty ( ) ) { \n \n \t3 key = Iterables . get ( map . keySet ( ) , 0 ) ; \n \n <ect>
\t1 public void updated ( Dictionary < String , ? > config ) { \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 if ( config != null ) { \n \n \t3 String instancename = ( String ) config . get ( <string_literal> ) ; \n \n <ect>
\t4 instance , <string_literal> , keepers , <string_literal> , \n \n \t4 new String ( ( ( PasswordToken ) getAdminToken ( ) ) . getPassword ( ) , UTF_8 ) , \n \n \t4 <string_literal> , prefix ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 final HttpMessage msg = new HttpMessage ( url , IOUtils . toString ( entity . getContent ( ) , StandardCharsets . UTF_8 ) ) ; \n \n \t5 msg . setContentType ( entity . getContentType ( ) . getValue ( ) ) ; \n \n \t5 msg . setResponseCode ( responseCode ) ; \n \n \t5 return msg ; } } \n \n <ect>
\t1 @ Override \n \n \t1 public void aggregate ( State state , TridentTuple tuple , TridentCollector collector ) { \n \n \t2 T value1 = valueFromTuple ( state . previousTuple ) ; \n \n \t2 T value2 = valueFromTuple ( tuple ) ; \n \n <ect>
\t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t5 _log . debug ( <string_literal> + key . toBase64 ( ) + <string_literal> + \n \n \t7 ( dbFile . lastModified ( ) - dataPublishDate ) + <string_literal> ) ; } \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t4 _fortuna . addRandomBytes ( data , offset , len ) ; } \n \n \t2 } catch ( RuntimeException e ) { \n \n \t3 <comment> \n \n \t3 Log log = _context . logManager ( ) . getLog ( FortunaRandomSource . class ) ; \n \n <ect>
\t6 principalOptional = RestxSession . getValue ( \n \n \t8 sessionDefinition , RestxPrincipal . class , RestxPrincipal . SESSION_DEF_KEY , principalName ) ; \n \n \t6 logger . info ( <string_literal> , su . get ( ) ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t2 executor = Executors . newScheduledThreadPool ( 1 ) ; \n \n \t2 executor . scheduleAtFixedRate ( checkalivetask , 0 , <number_literal> , TimeUnit . SECONDS ) ; } \n \n \t1 @ Override \n \n \t1 public void deactivate ( ) { \n \n <ect>
\t6 retValue = retValue . substring ( index ) ; \n \n \t5 } else { \n \n \t6 retValue = retValue . substring ( 0 , index ) ; } \n \n \t4 } else if ( <string_literal> . equals ( tokens [ i ] ) ) { \n \n <ect>
\t1 private boolean rolledBack ; \n \n \t1 @ Override \n \n \t1 public void start ( ) { \n \n <ect>
\t4 field . set ( cmdObj , Short . valueOf ( paramObj . toString ( ) ) ) ; \n \n \t4 break ; \n \n \t3 case STRING : \n \n \t4 if ( ( paramObj != null ) && paramObj . toString ( ) . length ( ) > annotation . length ( ) ) { \n \n <ect>
\t1 closeQuietly ( httpUrlConnection ) ; } } \n \n protected void fillHeaderAndDebugInfo ( HttpURLConnection httpUrlConnection ) { \n \n \t1 currentHeaders = Collections . unmodifiableMap ( httpUrlConnection . getHeaderFields ( ) ) ; \n \n \t1 String usedApiVersion = StringUtils . trimToEmpty ( httpUrlConnection . getHeaderField ( <string_literal> ) ) ; \n \n <ect>
public class ManagementServer \n \n { \n \n \t1 public static Server createManagementServer ( int mgtPort ) \n \n \t1 { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 log . error ( <string_literal> , contract , tx != null ? tx : <string_literal> ) ; \n \n \t3 throw new RuntimeException ( e ) ; <comment> \n \n \t2 stateMachine . transition ( State . CLOSING ) ; \n \n <ect>
\t5 <string_literal> ) ; } \n \n \t2 <comment> \n \n \t2 if ( ! newServiceOffering . isDynamic ( ) && vmInstance . getServiceOfferingId ( ) == newServiceOffering . getId ( ) ) { \n \n <ect>
\t3 File oldFile = new File ( getFileName ( oldest ) ) ; \n \n \t3 if ( ! oldFile . canWrite ( ) ) { \n \n \t4 LOG . info ( <string_literal> + oldFile . getAbsolutePath ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t4 s_logger . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t4 throw new CloudRuntimeException ( <string_literal> + e . getMessage ( ) , e ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 @ Path ( <string_literal> ) \n \n \t1 @ Consumes ( { <string_literal> } ) \n \n \t1 public String addFavoriteMovie ( SecureProcessingFavoriteMovieXmlType movie ) { \n \n \t2 int len = Math . min ( movie . getTitle ( ) . length ( ) , <number_literal> ) ; \n \n <ect>
\t3 } finally { \n \n \t4 <comment> \n \n \t4 stopServer ( serverList ) ; } \n \n \t2 } catch ( AssertionError ae ) { \n \n <ect>
\t2 try { \n \n \t2 entry . put ( <string_literal> , \n \n \t4 AbstractCluster . formatVectorAsJson ( point . getVector ( ) , dictionary ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 public boolean configure ( final String name , final Map < String , Object > params ) throws ConfigurationException { \n \n \t2 s_logger . info ( <string_literal> + mgmtServiceConf . getPingTimeout ( ) ) ; \n \n \t2 final int threads = DirectAgentLoadSize . value ( ) ; \n \n \t2 _nodeId = ManagementServerNode . getManagementServerId ( ) ; \n \n <ect>
\t5 } catch ( SQLException e ) { \n \n \t6 throw new CloudRuntimeException ( <string_literal> , e ) ; } \n \n \t4 } catch ( SQLException e ) { \n \n \t5 throw new CloudRuntimeException ( <string_literal> , e ) ; } \n \n <ect>
\t2 for ( int i = 1 ; i < = <number_literal> ; i ++ ) { \n \n \t3 Calendar nextTimeout = calendarTimeout . getNextTimeout ( previousTimeout ) ; \n \n \t3 Assert . assertNotNull ( timeZoneDisplayName , nextTimeout ) ; \n \n \t3 Assert . assertNotNull ( timeZoneDisplayName , nextTimeout . after ( previousTimeout ) ) ; \n \n <ect>
\t1 protected Object getPort ( Map < ? , ? > options ) { \n \n \t2 Object port = options . get ( <string_literal> ) ; \n \n \t2 if ( port == null ) { \n \n \t3 port = DEFAULT_PORT ; \n \n <ect>
\t1 client . createTable ( HCatCreateTableDesc . create ( tableToCreate ) . build ( ) ) ; \n \n \t1 HCatTable t1 = client . getTable ( dbName , tableName ) ; \n \n \t1 assertNotNull ( t1 ) ; \n \n \t1 <comment> \n \n <ect>
\t6 return o1 . getSecond ( ) > o2 . getSecond ( ) ? - 1 : 1 ; } \n \n \t4 } ) ; \n \n \t2 private void addToJobPool ( AbstractExecutable executable , int priority ) { \n \n \t3 String jobDesc = executable . toString ( ) ; \n \n <ect>
\t2 if ( commandClass == null ) { \n \n \t3 logger . error ( String . format ( <string_literal> , this . getNode ( ) . getNodeId ( ) , \n \n \t5 commandClassCode ) ) ; \n \n \t3 return ; } \n \n <ect>
\t2 this . LOG = LOG ; } \n \n \t1 public void log ( Fault fault ) { \n \n \t2 <comment> \n \n \t2 Logger tmpLogger = Logger . getLogger ( FaultLogger . class ) ; \n \n <ect>
\t3 Collection < X509CertificateHolder > certs = certStore . getMatches ( null ) ; \n \n \t3 if ( certs != null && certs . size ( ) > 0 ) { \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t4 for ( X509CertificateHolder cert : certs ) { \n \n <ect>
\t4 final Long revision = parseRevisionOrDie ( version ) ; \n \n \t4 <comment> \n \n \t4 final SVNNodeKind nodeType = repo . checkPath ( path , revision ) ; \n \n \t4 if ( SVNNodeKind . NONE . equals ( nodeType ) ) { \n \n <ect>
\t2 break ; \n \n \t2 case XMLStreamConstants . END_ELEMENT : \n \n \t2 EndElement endElement = event . asEndElement ( ) ; \n \n \t2 String name = endElement . getName ( ) . getLocalPart ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public void setUp ( ) throws Exception { \n \n \t2 fc = new CCNFlowServer ( _capacity , true , _handle ) ; } \n \n \t1 @ Test \n \n \t1 public void testMultipleGets ( ) throws Throwable { \t1 \n \n <ect>
\t2 deployEnv ( ) ; \n \n \t2 String fastModeStr = System . getProperty ( <string_literal> ) ; \n \n \t2 if ( fastModeStr != null && fastModeStr . equalsIgnoreCase ( <string_literal> ) ) { \n \n \t3 fastBuildMode = true ; \n \n <ect>
\t3 trayIcon . setPopupMenu ( popup ) ; \n \n \t3 try { \n \n \t4 tray . add ( trayIcon ) ; \n \n \t3 } catch ( AWTException e ) { \n \n <ect>
\t1 public static boolean deleteDirectory ( File dir ) throws IOException { \n \n \t2 if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { \n \n \t3 throw new IOException ( <string_literal> + dir . getAbsolutePath ( ) + <string_literal> ) ; } \n \n <ect>
\t6 } while ( charBuffer == null && currentLength > 0 ) ; \n \n \t6 result = charBuffer != null ? charBuffer . toString ( ) : <string_literal> ; } } \n \n \t4 else { \n \n \t5 result = inputString ; } } } \n \n <ect>
\t4 return ; \n \n \t3 } catch ( InsufficientMoneyException e ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t4 throw new ExecutionException ( <string_literal> + publicIp ) ; \n \n \t3 } else { \n \n \t4 return true ; } \n \n \t2 default : \n \n <ect>
\t2 if ( resourceProxy != null ) { \n \n \t3 try { \n \n \t4 WebClient . client ( resourceProxy ) . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 s1 = new QuorumPeer ( peers , s1dir , s1dir , portClient1 , <number_literal> , 1 , tickTime , initLimit , syncLimit ) ; \n \n \t3 Assert . assertEquals ( portClient1 , s1 . getClientPort ( ) ) ; \n \n \t3 break ; \n \n \t2 case <number_literal> : \n \n <ect>
\t4 ContactJabberImpl sourceContact \n \n \t5 = ssContactList . findContactById ( userID ) ; \n \n \t4 if ( sourceContact == null ) \n \n \t4 { \n \n <ect>
\t5 + overProvFactor . toString ( ) ) ; \n \n \t3 s_logger . debug ( <string_literal> + overProvFactor + <string_literal> + pool . getCapacityBytes ( ) ) ; \n \n \t2 } else { \n \n \t3 totalOverProvCapacity = pool . getCapacityBytes ( ) ; \n \n <ect>
\t5 it . remove ( ) ; } \n \n \t3 } catch ( java . nio . channels . ClosedSelectorException cse ) { \n \n \t4 <comment> \n \n \t3 } catch ( java . nio . channels . CancelledKeyException nx ) { \n \n <ect>
\t3 waitTime . add ( Long . valueOf ( val ) ) ; \n \n \t2 } else if ( NAME_IGNORE_LIST . indexOf ( <string_literal> + key + <string_literal> ) != - 1 ) { \n \n \t3 <comment> \n \n \t2 } else { \n \n <ect>
<comment> \n \n @ Subscribe \n \n public void onTaskUpdateEvent ( TaskUpdateEvent event ) throws ClusterNotFoundException { \n \n <ect>
\t4 <comment> \n \n \t4 wait ( MINUTES . toMillis ( <number_literal> ) ) ; \n \n \t4 long time = System . currentTimeMillis ( ) - start ; \n \n \t4 if ( time > MINUTES . toMillis ( <number_literal> ) ) \n \n <ect>
<comment> \n \n @ BeforeMethod \n \n public void setupInstance ( ) throws Exception { \n \n <ect>
\t2 try { \n \n \t3 if ( scheduler . isStarted ( ) && clientRegistryRefresher != null ) { \n \n \t4 scheduler . terminate ( makeClientRegistryRefresherJobId ( ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 trRow7 . appendChild ( cell71 , cell72 ) \n \n \t3 tooltipManager . appendRow ( trRow7 ) \n \n \t3 return tooltipManager . create ( ) . write ( ) \n \n \t2 } catch ( e : Exception ) { \n \n <ect>
\t3 checkInvokers ( invokers , invocation ) ; \n \n \t3 Invoker < T > invoker = select ( loadbalance , invocation , invokers , null ) ; \n \n \t3 return invoker . invoke ( invocation ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 } ) ; } \n \n \t2 @ Override \n \n \t2 public void onSuccess ( None none ) \n \n \t2 { \n \n <ect>
\t3 } catch ( NoSuchAlgorithmException e ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t2 logger . info ( ( Supplier < ? > ) ( ) - > new ParameterizedMessage ( <string_literal> , <string_literal> ) , new Exception ( ) ) ; } \n \n \t1 public void checkFailOrderOfExceptionArgument1 ( ) { \n \n \t2 logger . info ( <string_literal> , <string_literal> , new Exception ( ) ) ; } \n \n \t1 public void checkOrderOfExceptionArgument2 ( ) { \n \n <ect>
\t5 @ Override \n \n \t5 public Integer apply ( InetAddress input ) { \n \n \t6 return occurrencesByHost . count ( input ) ; } \n \n \t4 } ) ; \n \n <ect>
\t2 for ( ShardStats shardStats : indexStats . getShards ( ) ) { \n \n \t3 assertNull ( shardStats . getCommitStats ( ) . getUserData ( ) . get ( Engine . SYNC_COMMIT_ID ) ) ; } \n \n \t2 ShardsSyncedFlushResult result ; \n \n \t2 if ( randomBoolean ( ) ) { \n \n <ect>
<comment> \n \n \t3 } catch ( final IOException e ) { \n \n <ect>
\t8 logger . error ( <string_literal> ) ; \n \n \t7 } else { \n \n \t8 logger . debug ( <string_literal> + msg . msgCount + <string_literal> ) ; } } \n \n \t5 } else { \n \n <ect>
\t3 logger . error ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 this . shutdownDeadline = System . currentTimeMillis ( ) + howLong ; \n \n \t2 try { \n \n <ect>
\t1 if ( novaApi . getFloatingIPExtensionForZone ( zoneAndId . getZone ( ) ) . isPresent ( ) ) { \n \n \t2 try { \n \n \t3 removeFloatingIpFromNodeAndDeallocate . apply ( zoneAndId ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t1 expect ( provider . loadLdapAuthenticationProvider ( <string_literal> ) ) . andThrow ( exception ) ; \n \n \t1 <comment> \n \n \t1 Logger log = createNiceMock ( Logger . class ) ; \n \n \t1 provider . LOG = log ; \n \n <ect>
\t1 if ( red >= relativePixel . minRed && red < = relativePixel . maxRed \n \n \t2 && green >= relativePixel . minGreen && green < = relativePixel . maxGreen \n \n \t2 && blue >= relativePixel . minBlue && blue < = relativePixel . maxBlue ) { \n \n \t2 <comment> \n \n <ect>
\t3 Script . execute ( url , <string_literal> , <string_literal> , filename ) ; \n \n \t3 DeleteDbFiles . execute ( dbDir , dbName , true ) ; \n \n \t3 RunScript . execute ( url , <string_literal> , <string_literal> , filename , null , false ) ; \n \n \t2 } catch ( SQLException se ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , max ) ; } \n \n \t2 Short min = Tools . getShortOpt ( ConfigOptsDimmable . MIN . toString ( ) , opts ) ; \n \n \t2 logger . debug ( <string_literal> , min ) ; \n \n \t2 if ( min == null ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void jbossWSUnableToCreateSecurityToken ( ) { \n \n <ect>
\t3 LOGGER . trace ( <string_literal> , time , zoneId ) ; \n \n \t3 final ZoneId zone = ZoneId . of ( zoneId ) ; \n \n \t3 return DateTimeUtils . zonedDateTimeOf ( time , zone ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t1 public MongoProfileService mongoAuthenticatorProfileService ( ) { \n \n \t2 final MongoAuthenticationProperties mongo = casProperties . getAuthn ( ) . getMongo ( ) ; \n \n \t2 final MongoClientURI uri = new MongoClientURI ( mongo . getMongoHostUri ( ) ) ; \n \n \t2 final MongoClient client = new MongoClient ( uri ) ; \n \n <ect>
\t2 stackId = getStackInformationFromUrl ( propertyMap ) ; \n \n \t1 } else { \n \n \t2 LOG . error ( <string_literal> , propertyMaps . size ( ) ) ; } } \n \n \t1 if ( null == stackId ) { \n \n <ect>
\t2 return true ; } \n \n \t1 @ Override \n \n \t1 public boolean verifyServicesCombination ( Set < Service > services ) { \n \n \t2 if ( ! services . contains ( Service . Connectivity ) ) { \n \n <ect>
\t3 { \n \n \t4 var ret_val = sc . InitiateShutdown ( true , <string_literal> ) ; \n \n \t4 if ( ret_val != ReturnCode . Completed ) \n \n \t4 { \n \n <ect>
\t4 logger . error ( <string_literal> , e ) ; \n \n \t3 } catch ( JsonMappingException e ) { \n \n \t4 logger . error ( <string_literal> , e ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 llap_selected_queue_am_percent_key = key \n \n \t2 self . logger . info ( <string_literal> . format ( llap_daemon_selected_queue_name , llap_selected_queue_am_percent_key ) ) \n \n \t2 break ; \n \n \t1 if llap_selected_queue_am_percent_key is None : \n \n <ect>
\t1 <comment> \n \n \t1 @ Override public void spiStart ( @ Nullable String gridName ) throws GridSpiException { \n \n \t2 startStopwatch ( ) ; \n \n <ect>
\t2 if ( currentPage == null || ! token . equals ( currentPageToken ) ) { \n \n \t3 final PageNode < IsWidget > toPage = navGraph . getPage ( token . getPageName ( ) ) ; \n \n \t3 navigate ( new Request < > ( toPage , token ) , false ) ; } \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t2 registry = createSystemUtils ( ) ; \n \n \t2 if ( ! isHeadless ( ) ) { \n \n \t3 frame = new LooksFrame ( autoUpdater , configuration ) ; \n \n \t2 } else { \n \n <ect>
\t3 logger . debug ( <string_literal> + messageResolver ) ; } \n \n \t2 Message message = messageResolver . resolveMessage ( messageSource , currentLocale ) ; \n \n \t2 List < Message > messages = sourceMessages . get ( message . getSource ( ) ) ; \n \n <ect>
\t3 <comment> \n \n \t3 if ( timeSet != null ) { \n \n \t4 cal . setTimeInMillis ( timeSet ) ; \n \n \t4 if ( ( timeRead - timeSet ) < = <number_literal> ) { \n \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \n \t3 try { \n \n \t4 this . socket . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t6 level = 1 ; } \n \n \t5 logger . info ( <string_literal> , nm ( ) , dev . getAddress ( ) , level ) ; \n \n \t5 m_feature . publish ( new PercentType ( level ) , StateChangeType . CHANGED ) ; } \n \n \t3 } catch ( FieldException e ) { \n \n <ect>
\t3 log . trace ( <string_literal> + local_addr + <string_literal> + ( dest == null ? <string_literal> : dest ) + <string_literal> + req ) ; \n \n \t2 try { \n \n \t3 down_prot . down ( msg ) ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
\t3 } catch ( InterruptedException ie ) { } \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t4 _log . debug ( <string_literal> ) ; \n \n \t3 if ( toSend != _totalSent ) \n \n <ect>
\t5 it . remove ( ) ; } } \n \n \t3 host . setTags ( conn , hr . tags ) ; \n \n \t3 return new MaintainAnswer ( command ) ; \n \n \t2 } catch ( final XenAPIException e ) { \n \n <ect>
\t3 Configuration localConf ; \n \n \t3 try { \n \n \t4 localConf = new XConfiguration ( new StringReader ( strConfig ) ) ; } \n \n \t3 catch ( IOException e1 ) { \n \n <ect>
\t2 return ; } \n \n \t2 <comment> <ect>
\t3 httpListenPort = Integer . parseInt ( s ) ; \n \n \t3 s_logger . info ( <string_literal> + s ) ; } \n \n \t2 s = conf . getProperty ( <string_literal> ) ; \n \n \t2 if ( s != null && s . equalsIgnoreCase ( <string_literal> ) ) { \n \n <ect>
\t5 <comment> \n \n \t5 try { \n \n \t6 r . job . run ( ) ; \n \n \t5 } catch ( Throwable t ) { \n \n <ect>
\t3 final Exchange copy = prepareExchange ( exchange ) ; \n \n \t3 if ( executorService != null ) { \n \n \t4 executorService . submit ( new Callable < Exchange > ( ) { \n \n \t5 public Exchange call ( ) throws Exception { \n \n <ect>
\t4 numFileBlocks = Math . max ( numFileBlocks , id + 1 ) ; \n \n \t4 return dst ; \n \n \t3 } catch ( IllegalArgumentException ex ) { \n \n \t4 <comment> \n \n <ect>
\t5 String ok = handshake ( out , version , false , eventHandler , mode , user , password , <string_literal> ) ; \n \n \t5 if ( ok == null ) \n \n \t6 throw new IOException ( <string_literal> + ( <number_literal> + i ) + <string_literal> ) ; \n \n \t5 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t7 . execute ( new CoordActionsActiveCountJPAExecutor ( coordJob . getId ( ) ) ) ; \n \n \t5 LOG . debug ( <string_literal> + coordJob . getId ( ) + <string_literal> + numWaitingActions + <string_literal> \n \n \t7 + coordJob . getMatThrottling ( ) ) ; \n \n \t5 if ( numWaitingActions >= coordJob . getMatThrottling ( ) ) { \n \n <ect>
\t6 LOG . warn ( <string_literal> , configuration . getClass ( ) . getName ( ) ) ; } \n \n \t4 } else { \n \n \t5 LOG . warn ( <string_literal> , SAXON_CONFIGURATION_CLASS_NAME , factory . getClass ( ) . getName ( ) ) ; } \n \n \t3 } else { \n \n <ect>
\t3 currRow = e . nextElement ( ) ; \n \n \t3 processedCount ++ ; \n \n \t4 if ( debugRow != null ) { \n \n <ect>
\t2 if ( parser . getArgumentById ( NONPROXY_HOSTS ) != null ) { \n \n \t3 String n = parser . getArgumentById ( NONPROXY_HOSTS ) . getArgument ( ) ; \n \n \t3 System . setProperty ( <string_literal> , n ) ; <comment> \n \n \t3 System . setProperty ( <string_literal> , n ) ; <comment> \n \n <ect>
\t5 StringUtils . isBlank ( k . getAlgorithm ( ) ) \n \n \t7 && StringUtils . isBlank ( k . getKeyId ( ) ) \n \n \t7 && StringUtils . isBlank ( k . getKeyType ( ) ) ) . count ( ) ; \n \n \t3 if ( badKeysCount == jsonWebKeySet . getJsonWebKeys ( ) . size ( ) ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void shouldLogWarning ( ) \n \n \t1 { \n \n \t2 Log log = logProvider . getLog ( getClass ( ) ) ; \n \n <ect>
<comment> \n \n public final WroModel setGroups ( final Collection < Group > groups ) { \n \n \t1 notNull ( groups , <string_literal> ) ; \n \n <ect>
\t3 BitstreamFormat bf = null ; \n \n \t3 try { \n \n \t4 bf = this . bitstream . getFormat ( swordService . getContext ( ) ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t1 if ( nodeId != null ) { \n \n \t2 logger . info ( <string_literal> , getNodeIdentifier ( ) ) ; \n \n \t1 } else { \n \n \t2 nodeId = getHardwareId ( ) ; \n \n <ect>
<comment> \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
\t3 return principal . getId ( ) ; } \n \n \t2 if ( this . persistentIdGenerator == null ) { \n \n \t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t2 final String id = this . persistentIdGenerator . generate ( principal , new PairwiseService ( sectorIdentifier ) ) ; \n \n <ect>
\t1 if ( resizeThreshold < = newRefsCount ) { \n \n \t1 newRefsCount = \n \n \t2 ( Long . bitCount ( newRefsCount ) == 1 ) ? estimateNewRowCount : nextHighestPowerOfTwo ( newRefsCount ) ; \n \n \t1 expandAndRehashImpl ( newRefsCount ) ; \n \n <ect>
\t4 } else { \n \n \t5 throw new IllegalArgumentException ( <string_literal> \n \n <number_literal> + path . toString ( ) ) ; } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 final SAML2HTTPRedirectDeflateSignatureSecurityHandler handler = new SAML2HTTPRedirectDeflateSignatureSecurityHandler ( ) ; \n \n \t2 final SAMLPeerEntityContext peer = context . getSubcontext ( SAMLPeerEntityContext . class , true ) ; \n \n \t2 peer . setEntityId ( SamlIdPUtils . getIssuerFromSamlRequest ( profileRequest ) ) ; \n \n \t2 LOGGER . debug ( <string_literal> , peer . getEntityId ( ) , handler . getClass ( ) . getSimpleName ( ) ) ; \n \n <ect>
\t2 @ Override \n \n \t2 public void process ( Exchange exchange ) throws Exception { \n \n \t3 Message in = exchange . getIn ( ) ; \n \n \t3 Comment comment = ( Comment ) in . getBody ( ) ; \n \n <ect>
\t3 . filter ( hour - > hour < = hoursFromNow && hour >= hoursBeforeNow ) \n \n \t3 . count ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , timestamp , windowInHours , count ) ; \n \n \t2 if ( count == events . size ( ) ) { \n \n <ect>
\t4 out . write ( buffer ) ; \n \n \t4 buffer . clear ( ) ; } \n \n \t3 in . close ( ) ; \n \n \t3 out . close ( ) ; \n \n <ect>
\t5 candidateUser . setUserProperty ( OpenmrsConstants . USER_PROPERTY_LOGIN_ATTEMPTS , String . valueOf ( attempts ) ) ; } \n \n \t4 saveUserProperties ( candidateUser ) ; } } \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 @ Override \n \n \t3 protected void onRegistrationSuccess ( JMTMRegistrationSuccess success ) { \n \n \t4 <comment> \n \n \t4 if ( Objects . equals ( getTargetLeaderId ( ) , currentJobMasterId ) ) { \n \n <ect>
\t2 LOG . error ( <string_literal> + getFileProgress ( reader ) , e ) ; \n \n \t2 <comment> \n \n \t2 return ; \n \n \t1 } catch ( ParseException e ) { \n \n <ect>
\t4 . addAsNew ( metaData . index ( <string_literal> ) ) \n \n \t4 . build ( ) ; \n \n \t2 ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . CLUSTER_NAME_SETTING \n \n \t3 . getDefault ( Settings . EMPTY ) ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; \n \n <ect>
\t5 propertyName . equals ( <string_literal> ) || propertyName . equals ( <string_literal> ) || \n \n \t5 propertyName . equals ( <string_literal> ) || propertyName . equals ( <string_literal> ) || \n \n \t5 propertyName . equals ( <string_literal> ) || propertyName . equals ( <string_literal> ) || \n \n \t5 propertyName . equals ( <string_literal> ) ) { \n \n <ect>
\t5 } catch ( Exception e ) \n \n \t5 { \n \n \t6 errorMsg = e . getMessage ( ) ; \n \n \t6 userInfo . setObjectForKey ( e , EXCEPTION_KEY ) ; \n \n <ect>
\t1 public static TemporaryFolder tempFolder = new TemporaryFolder ( ) ; \n \n \t1 @ BeforeClass \n \n \t1 public static void prepare ( ) throws Exception { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n <ect>
\t5 pipeline . addLast ( NETWORK_FAILURE_HANDLER_NAME , failureHandler ) ; } \n \n \t4 return pipeline ; } \n \n \t2 } ) ; \n \n \t2 channel = serverBootstrap . bind ( new InetSocketAddress ( localPort ) ) ; \n \n <ect>
\t2 AbstractXmlApplicationContext db = new ClassPathXmlApplicationContext ( <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 AbstractXmlApplicationContext app = new ClassPathXmlApplicationContext ( <string_literal> ) ; \n \n \t2 <comment> \n \n <ect>
\t6 <comment> \n \n \t6 <comment> \n \n \t6 <comment> \n \n \t6 <comment> \n \n <ect>
\t3 Schema schema = st . getSchema ( ) ; \n \n \t3 SchemaTupleFactory stf = new SchemaTupleFactory ( stClass , st . getQuickGenerator ( ) ) ; \n \n \t3 for ( GenContext context : GenContext . values ( ) ) { \n \n \t4 if ( context != GenContext . FORCE_LOAD && ! context . shouldGenerate ( stClass ) ) { \n \n <ect>
\t3 } else if ( replyType == REPLY_NODES ) { \n \n \t4 List < NodeInfo > reply = ( List < NodeInfo > ) waiter . getReplyObject ( ) ; \n \n \t4 <comment> \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 try { \n \n \t3 ADT_A05 adt = ( ADT_A05 ) message ; \n \n \t3 response = processADT_A28 ( adt ) ; } \n \n \t2 catch ( ClassCastException e ) { \n \n <ect>
\t5 JMeterUtils . reportErrorToUser ( msg ) ; \n \n \t4 } catch ( Exception err ) { \n \n \t5 log . error ( <string_literal> , c , err ) ; } } \n \n \t2 } catch ( NullPointerException er ) { \n \n <ect>
\t2 for ( TransactionSynchronization txSync : txSyncArray ) { \n \n \t3 txSync . afterCompletion ( status ) ; } } \n \n \t1 public void addTransactionSynchronization ( TransactionSynchronization txSync ) { \n \n \t2 this . synchronizations . add ( txSync ) ; \n \n <ect>
\t5 String answer = data . get ( <string_literal> ) ; \n \n \t5 if ( Strings . isNotBlank ( answer ) ) { \n \n \t6 return answer ; } } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 private short _syncMode = DBSyncGeneric . SYNC_MODE_UPDATE ; \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n \t3 try { \n \n <ect>
\t2 closeIndices . removeAll ( deleteIndices ) ; \n \n \t2 if ( closeIndices . size ( ) > 0 ) { \n \n \t3 for ( String index : closeIndices ) { \n \n \t4 if ( randomBoolean ( ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 String newPath = context . getPath ( ) ; \n \n \t4 if ( newPath != null && ! isEquals ( path , newPath ) ) { \n \n <ect>
\t3 } catch ( ArrayIndexOutOfBoundsException ex ) { \n \n \t4 logger . error ( <string_literal> , ex ) ; \n \n \t4 logger . error ( <string_literal> + formatter . format ( buffer . length ) + <string_literal> ) ; \n \n \t4 logger . error ( <string_literal> + mb ) ; \n \n <ect>
\t3 synchronized ( semaphore ) { \n \n \t4 messageIds . add ( id ) ; \n \n \t4 semaphore . notifyAll ( ) ; } \n \n \t3 if ( verbose ) { \n \n <ect>
\t4 if ( foundInDelayed ) { \n \n \t5 delayedLoadPlugins . add ( plugin ) ; } \n \n \t4 else { \n \n \t5 failedPlugins . put ( plugin . getName ( ) , plugin ) ; \n \n <ect>
public void update ( String jobName , JobData data ) \n \n \t1 throws IOException { \n \n \t1 try { \n \n \t1 if ( ! jobExists ( jobName ) ) { \n \n <ect>
\t4 Hash to = instructions . getDestination ( ) ; \n \n \t4 <comment> \n \n \t4 if ( type != DataMessage . MESSAGE_TYPE ) { \n \n \t5 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t6 _log . info ( <string_literal> + pp ) ; \n \n \t4 } else { \n \n \t5 pp . release ( ) ; \n \n \t5 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 try { \n \n \t2 balancer = constructNewBalancerForTable ( clazzName , tableId ) ; \n \n \t2 log . info ( <string_literal> , clazzName , tableId ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 } else { \n \n \t3 sb . append ( <string_literal> ) ; } \n \n \t2 databaseType . appendEscapedEntityName ( sb , tableName ) ; \n \n \t2 String statement = sb . toString ( ) ; \n \n <ect>
\t5 _decryptBlockBuf [ i ] ^ = array [ start + i ] ; } } \n \n \t3 boolean ok = recvUnencryptedI2NP ( ) ; \n \n \t3 if ( ! ok ) { \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t3 if ( semanticType . getDomain ( ) == null ) { \n \n \t4 logger . error ( <string_literal> ) ; \n \n \t4 continue ; } \n \n \t3 if ( semanticType . getType ( ) == null ) { \n \n <ect>
\t3 throw new NoCorrelationKeyException ( this , exchange ) ; } \n \n \t2 return value ; } \n \n \t1 protected void onError ( TransactionStatus status , Exception e ) throws RuntimeCamelException { \n \n \t2 status . setRollbackOnly ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t5 } else if ( command . equals ( OnOffType . OFF ) || command . equals ( UpDownType . DOWN ) ) { \n \n \t6 myqOnlineData . executeMyQCommand ( garageopener . getDeviceId ( ) , <string_literal> , 0 ) ; \n \n \t6 beginRapidPoll ( true ) ; \n \n \t5 } else { \n \n <ect>
\t2 reader . getRelayResponseReader ( ) . readCharlieIP ( ip , 0 ) ; \n \n \t2 int port = reader . getRelayResponseReader ( ) . readCharliePort ( ) ; \n \n \t2 if ( ( ! isValid ( ip , port ) ) || ( ! isValid ( bob . getIP ( ) , bob . getPort ( ) ) ) ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
<comment> \n \n \t1 private void showUsageStatistics ( ) { \n \n \t2 if ( sessionFactory . getStatistics ( ) . isStatisticsEnabled ( ) ) { \n \n <ect>
\t6 instance ) ; \n \n \t4 return null ; } \n \n \t3 <comment> \n \n \t3 if ( ! nameHostMapper . containsKey ( instance ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( dvd && rendererMencoderOptions . contains ( <string_literal> ) ) { \n \n <ect>
\t5 log . error ( <string_literal> , tce . getCause ( ) ) ; \n \n \t5 if ( tce . getCause ( ) != null && tce . getCause ( ) instanceof org . xml . sax . SAXParseException ) { \n \n \t6 org . xml . sax . SAXParseException e = ( org . xml . sax . SAXParseException ) tce . getCause ( ) ; \n \n \t6 log . error ( <string_literal> , e . getLineNumber ( ) , e . getColumnNumber ( ) ) ; } \n \n <ect>
<comment> \n \n \t1 public void setExtensionNames ( Map < String , String > map ) { \n \n \t3 for ( Map . Entry < String , String > entry : extensionNames . entrySet ( ) ) { \n \n <ect>
\t2 if ( ! this . getAudience ( ) . equalsIgnoreCase ( expectedAudience ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , this . getAudience ( ) ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! this . issuer . equalsIgnoreCase ( expectedIssuer ) ) { \n \n <ect>
\t3 LOG . info ( <string_literal> + qp . getName ( ) ) ; \n \n \t3 qp . shutdown ( ) ; \n \n \t3 Election e = qp . getElectionAlg ( ) ; \n \n \t3 if ( e != null ) { \n \n <ect>
\t5 vm = _userVMDao . acquireInLockTable ( work . getInstanceId ( ) ) ; \n \n \t5 if ( vm == null ) { \n \n \t6 vm = _userVMDao . findById ( work . getInstanceId ( ) ) ; \n \n \t6 if ( vm == null ) { \n \n <ect>
\t2 executorService . shutdownNow ( ) ; \n \n \t2 while ( ! executorService . awaitTermination ( <number_literal> , TimeUnit . MILLISECONDS ) ) { \n \n \t2 LOGGER . debug ( <string_literal> ) ; } } \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t4 && firstError != 0 && remaining > 0 ) \n \n \t3 { \n \n \t4 log . debug ( <string_literal> + si . toString ( ) ) ; \n \n \t4 <comment> \n \n <ect>
\t1 try { \n \n \t1 ret = Entities . uniqueResult ( Images . exampleKernelWithImageId ( kernelId ) ) ; \n \n \t1 tx . commit ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 message . getUniqueMessageId ( ) , batchId , exception ) ; } } \n \n \t1 @ Override \n \n \t1 public void onPrepareFatalError ( Exception exception , Map < String , Object > parameters ) \n \n \t1 { \n \n <ect>
\t2 setPassword ( password ) ; \n \n \t2 setHostname ( uri . getHost ( ) ) ; \n \n \t2 String path = uri . getPath ( ) ; \n \n \t2 if ( path != null && ! path . isEmpty ( ) ) { \n \n <ect>
\t3 final UserProfile profile = this . profileCreator . create ( credentials , getWebContext ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , profile ) ; \n \n \t3 return createResult ( new ClientCredential ( credentials , authenticator . getClass ( ) . getSimpleName ( ) ) , profile ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t2 if ( storeType != null && ! storeType . equals ( XWikiHibernateBaseStore . HINT ) ) { \n \n \t3 try { \n \n \t4 return this . componentManager . getInstance ( AttachmentVersioningStore . class , storeType ) ; \n \n \t3 } catch ( ComponentLookupException e ) { \n \n <ect>
\t3 updateAuthenticationToRememberBypass ( authentication , provider , principal ) ; \n \n \t3 return false ; } \n \n \t2 final boolean bypassByCredType = locateMatchingCredentialType ( authentication , bypassProperties . getCredentialClassType ( ) ) ; \n \n \t2 if ( bypassByCredType ) { \n \n <ect>
\t3 s_logger . info ( <string_literal> + traffType ) ; \n \n \t3 int gcIntervalMinutes = NumbersUtil . parseInt ( configs . get ( Config . ElasticLoadBalancerVmGcInterval . key ( ) ) , <number_literal> ) ; \n \n \t3 if ( gcIntervalMinutes < <number_literal> ) \n \n \t4 gcIntervalMinutes = <number_literal> ; \n \n <ect>
\t2 Log . debug ( <string_literal> , document , term ) ; \n \n \t2 try { \n \n \t3 indexWriter . updateDocument ( term , document ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 private boolean connClosedByClient ( Request request ) { \n \n \t2 return request . cnxn == null ; } \n \n \t1 public void shutdown ( ) { \n \n \t2 <comment> \n \n <ect>
\t7 throw e ; \n \n \t6 } else { \n \n \t7 s_logger . warn ( <string_literal> + e . getScope ( ) . getName ( ) , e ) ; } } \n \n \t4 } catch ( final ExecutionException e ) { \n \n <ect>
\t1 final Volume volume = createPreferredVolumeFromDisk ( ) ; \n \n \t1 try { \n \n \t2 checkVolume ( volume ) ; \n \n \t2 VirtualMachine virtualMachine = getPreferredVirtualMachine ( ) ; \n \n <ect>
\t2 writer . append ( <string_literal> ) . append ( String . valueOf ( cdbw . interClusterDensity ( ) ) ) . append ( <string_literal> ) ; \n \n \t2 writer . append ( <string_literal> ) . append ( String . valueOf ( cdbw . intraClusterDensity ( ) ) ) . append ( <string_literal> ) ; \n \n \t2 writer . append ( <string_literal> ) . append ( String . valueOf ( cdbw . separation ( ) ) ) . append ( <string_literal> ) ; \n \n \t2 writer . flush ( ) ; } \n \n <ect>
\t4 logger . error ( <string_literal> ) ; \n \n \t4 return null ; } \n \n \t3 return m_ports . values ( ) . iterator ( ) . next ( ) ; } \n \n \t2 if ( ! m_ports . containsKey ( port ) ) { \n \n <ect>
\t6 + allManagedAgents . size ( ) ) ; } \n \n \t3 return ; } \n \n \t2 if ( avLoad == 0L ) { \n \n <ect>
\t4 logger . error ( <string_literal> , evt ) ; \n \n \t4 if ( evt . getSourceException ( ) . getCause ( ) != null ) { \n \n \t5 Throwable c = evt . getSourceException ( ) . getCause ( ) ; \n \n \t5 while ( c != null ) { \n \n <ect>
\t9 escape ( row . getString ( USERNAME ) ) , \n \n \t9 escape ( droppedResource . getName ( ) ) ) ) ; } \n \n \t3 catch ( RequestExecutionException e ) \n \n \t3 { \n \n <ect>
\t2 catch ( GridException e ) { \n \n \t3 if ( ctx . discovery ( ) . alive ( nodeId ) ) \n \n \t4 U . error ( log , <string_literal> + nodeId + <string_literal> + res + ' ] ' , e ) ; \n \n <ect>
\t3 Futures . addCallback ( future , new FutureCallback < TestOutcome > ( ) { \n \n \t4 @ Override \n \n \t4 public void onSuccess ( TestOutcome result ) { \n \n \t5 remainingReportCount . decrementAndGet ( ) ; \n \n <ect>
\t3 if ( socket != null ) \n \n \t4 try { \n \n \t5 socket . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t1 public Collection < String > getEligibleAccountsForSurrogateToProxy ( final String username ) { \n \n \t2 final Collection < String > eligible = new LinkedHashSet < > ( ) ; \n \n \t2 try { \n \n \t3 final SearchFilter filter = LdapUtils . newLdaptiveSearchFilter ( ldapProperties . getSearchFilter ( ) , CollectionUtils . wrap ( username ) ) ; \n \n <ect>
\t4 try { \n \n \t5 log . info ( <string_literal> + msg + <string_literal> + nodeId + \n \n \t6 <string_literal> + I_TOPIC_1 + ' ] ' ) ; \n \n \t5 if ( ! nodeId . equals ( grid1 . localNode ( ) . id ( ) ) ) { \n \n <ect>
\t2 lock . lock ( ) ; \n \n \t2 try { \n \n \t3 ExecutionResult rc = _vrDeployer . prepareCommand ( cmd ) ; \n \n \t3 if ( ! rc . isSuccess ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 List < InstanceGroupVO > groups = _vmGroupDao . listByAccountId ( accountId ) ; \n \n \t3 for ( InstanceGroupVO group : groups ) { \n \n \t4 if ( ! _vmMgr . deleteVmGroup ( group . getId ( ) ) ) { \n \n <ect>
\t4 long length = Math . max ( blob . length ( ) , MAX_RETAIN_SIZE ) ; \n \n \t4 try ( InputStream is = blob . getBinaryStream ( 0 , length ) ) { \n \n \t5 jmvars . put ( name , IOUtils . toString ( is , ENCODING ) ) ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 String patchRequest = patchArray . toString ( ) ; \n \n \t2 logger . info ( <string_literal> + patchRequest ) ; \n \n \t2 Webhook webhookRequest = new Webhook ( ) ; \n \n \t2 Webhook webhookGetResponse = webhookRequest . update ( TestConstants . SANDBOX_CONTEXT , webhookId , patchRequest ) ; \n \n <ect>
\t1 String homefile = filename . substring ( <number_literal> ) ; \n \n \t1 String dir = System . getProperty ( <string_literal> ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n <ect>
\t1 try { \n \n \t1 <comment> \n \n \t1 userRecord . parse ( val ) ; \n \n \t1 } catch ( RecordParser . ParseError pe ) { \n \n <ect>
\t4 } else if ( command instanceof PercentType ) { \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t5 sendPercent ( bulb , rgbwSteps , bridgeId , ( PercentType ) command , BindingType . brightness ) ; } \n \n \t3 } else if ( deviceConfig . getCommandType ( ) . equals ( BindingType . nightMode ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 KeyLocator newKeyLocator = new KeyLocator ( keyObject . getVersionedName ( ) , keyObject . getContentPublisher ( ) ) ; \n \n \t3 setKeyLocator ( keyDigest , newKeyLocator ) ; \n \n \t3 if ( Log . isLoggable ( Log . FAC_KEYS , Level . INFO ) ) \n \n <ect>
\t5 + id + <string_literal> + FacadeAPI . NBT_CUSTOM_ITEM_STACK ) ; \n \n \t4 return ; } \n \n \t3 Block block = Block . REGISTRY . getObject ( new ResourceLocation ( regName ) ) ; \n \n \t3 if ( block == Blocks . AIR ) { \n \n <ect>
\t7 logger . warn ( <string_literal> + project . getId ( ) , e ) ; } \n \n \t6 else \n \n \t6 { \n \n \t7 <comment> \n \n <ect>
\t2 s_logger . info ( <string_literal> + _account . get ( ) ) ; \n \n \t2 HttpClient client = new HttpClient ( ) ; \n \n \t2 HttpMethod method = new GetMethod ( url ) ; \n \n \t2 int responseCode = client . executeMethod ( method ) ; \n \n <ect>
\t4 lifecycleListeners . addAll ( container . lookupList ( AbstractMavenLifecycleParticipant . class ) ) ; } \n \n \t3 catch ( ComponentLookupException e ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t3 return false ; } \n \n \t2 try { \n \n \t3 notifier . notify ( event ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t1 { \n \n \t2 this . handlerDesc = handlerdesc ; } \n \n \t1 public String getName ( ) \n \n \t1 { \n \n <ect>
\t1 longToString = new FastByIDMap < > ( <number_literal> ) ; \n \n \t1 this . dataFile = Preconditions . checkNotNull ( dataFile ) ; \n \n \t1 if ( ! dataFile . exists ( ) || dataFile . isDirectory ( ) ) { \n \n \t1 throw new FileNotFoundException ( dataFile . toString ( ) ) ; } \n \n <ect>
\t3 return BESTEFFORT ; \n \n \t2 } else if ( NAME_ABORT . equalsIgnoreCase ( behaviorString ) ) { \n \n \t3 return ABORT ; \n \n \t2 } else { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + network . getId ( ) ) ; \n \n \t3 return true ; } \n \n \t2 if ( network . getVpcId ( ) == null ) { \n \n \t3 return super . associatePublicIP ( network , ipAddresses , router ) ; } \n \n <ect>
\t6 } catch ( Exception e ) { \n \n \t7 s_logger . error ( <string_literal> + account . getId ( ) , e ) ; } } \n \n \t5 <comment> \n \n \t5 List < ? extends Domain > inactiveDomains = _domainMgr . findInactiveDomains ( ) ; \n \n <ect>
\t5 Account caller = CallContext . current ( ) . getCallingAccount ( ) ; \n \n \t5 long callerUserId = CallContext . current ( ) . getCallingUserId ( ) ; \n \n \t5 outsideIp = _ipAddrMgr . allocateIp ( owner , false , caller , callerUserId , zone , true ) ; \n \n \t4 } catch ( ResourceAllocationException e ) { \n \n <ect>
\t4 { \n \n \t5 workersDependentOn . add ( mapToWorker . get ( mapDependedOn ) ) ; } \n \n \t4 else \n \n \t4 { \n \n <ect>
\t4 exec . execute ( execCommand ) ; \n \n \t4 LOG . info ( <string_literal> ) ; \n \n \t3 } catch ( Exception eex ) { \n \n \t4 LOG . error ( eex ) ; \n \n <ect>
\t2 try { \n \n \t2 result = ( PerfLogger ) ReflectionUtils . newInstance ( conf . getClassByName ( \n \n \t3 conf . getVar ( HiveConf . ConfVars . HIVE_PERF_LOGGER ) ) , conf ) ; \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t3 String json = response . readEntity ( String . class ) ; \n \n \t3 JsonArray jsonArray = new JsonParser ( ) . parse ( json ) . getAsJsonObject ( ) . get ( <string_literal> ) . getAsJsonArray ( ) ; \n \n \t3 return jsonArray . size ( ) != 0 ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 logger . debug ( srcFile . getAbsolutePath ( ) + <string_literal> ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t2 logger . debug ( <string_literal> + srcFile . getAbsolutePath ( ) + <string_literal> + destFile . getAbsolutePath ( ) ) ; } \n \n \t1 } else { \n \n <ect>
\t3 long doneTime ; \n \n \t3 long checkTime = System . currentTimeMillis ( ) ; \n \n \t3 object = VersioningProfile . getFirstBlockOfLatestVersion ( three , null , null , <number_literal> , getHandle . defaultVerifier ( ) , getHandle ) ; \n \n \t3 doneTime = System . currentTimeMillis ( ) ; \n \n <ect>
\t3 if ( _dead ) return ; \n \n \t3 _dead = true ; \n \n \t3 super . success ( ) ; } \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 long expectedBloomFilterSize = Math . max ( cfs . metadata ( ) . params . minIndexInterval , \n \n <number_literal> SSTableReader . getApproximateKeyCount ( txn . originals ( ) ) ) ; \n \n \t3 logger . trace ( <string_literal> , expectedBloomFilterSize ) ; \n \n <ect>
\t2 } else { \n \n \t3 this . ldapServiceMapper = ldapServiceMapper ; } \n \n \t2 this . loadFilter = ldapProperties . getLoadFilter ( ) ; \n \n \t2 this . searchFilter = ldapProperties . getSearchFilter ( ) ; \n \n <ect>
\t3 s_logger . error ( <string_literal> + volume . getId ( ) + <string_literal> , cre ) ; \n \n \t3 throw cre ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 } else { \n \n \t3 _firewallDao . remove ( lb . getId ( ) ) ; } \n \n \t2 _elbMgr . handleDeleteLoadBalancerRule ( lb , callerUserId , caller ) ; \n \n \t2 if ( success ) { \n \n <ect>
\t8 s_logger . info ( description ) ; } } } \n \n \t4 } finally { \n \n \t5 syncLock . unlock ( ) ; } \n \n \t3 } else { \n \n <ect>
\t2 if delay > retryDuration : \n \n \t2 delay = retryDuration \n \n \t2 retryDuration -= delay # allow one last attempt \n \n \t2 commandresult [ 'stderr' ] += <string_literal> \n \n <ect>
\t3 terminateTransactionsForValidUser ( username ) ; \n \n \t3 terminateConnectionsForValidUser ( username ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t1 if ( ! prop . isOneToOne ( ) ) { \n \n \t1 throw new IllegalStateException ( <string_literal> + prop . getFullBeanName ( ) + <string_literal> ) ; } \n \n \t1 prop . setPrimaryKeyJoin ( true ) ; \n \n \t1 if ( ! primaryKeyJoin . name ( ) . isEmpty ( ) ) { \n \n <ect>
\t3 if ( sp == null ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> + volumeUuid ) ; } \n \n \t3 try { \n \n \t4 if ( sp . isActive ( ) == 0 ) { \n \n <ect>
\t4 String className = ERXProperties . stringForKey ( <string_literal> ) ; \n \n \t4 if ( className != null ) { \n \n \t5 _factory = ( Factory ) Class . forName ( className ) . newInstance ( ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 if ( nbt . hasKey ( <string_literal> ) ) { \n \n \t3 owner = NBTUtil . readGameProfileFromNBT ( nbt . getCompoundTag ( <string_literal> ) ) ; \n \n \t3 if ( owner == null || ! owner . isComplete ( ) ) { \n \n \t4 String msg = <string_literal> + owner + <string_literal> + getClass ( ) + <string_literal> ; \n \n <ect>
\t1 protected void internalReceiveUpdate ( String itemName , State newState ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t1 try { \n \n \t1 ServerSocket serverSocket = new ServerSocket ( port ) ; \n \n \t1 while ( true ) { \n \n \t1 Socket socket = serverSocket . accept ( ) ; \n \n <ect>
\t2 for ( HdmiCecMessage message : copiedBuffer ) { \n \n \t3 if ( message . getOpcode ( ) == Constants . MESSAGE_ACTIVE_SOURCE \n \n \t5 && message . getSource ( ) == address ) { \n \n \t4 mDevice . onMessage ( message ) ; \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( event instanceof CamelContextStartedEvent ) { \n \n <ect>
\t3 XMLEncodableTester . handleException ( ex ) ; \n \n \t3 System . out . println ( <string_literal> ) ; } } \n \n \t1 @ Test \n \n \t1 public void testDecodeInputStream ( ) { \n \n <ect>
\t2 this . jobScheduler = requireNonNull ( jobScheduler ) ; \n \n \t2 this . listener = requireNonNull ( listener ) ; } \n \n \t1 public void start ( ) \n \n \t1 { \n \n <ect>
\t5 if ( keyField != null ) { \n \n \t6 long hashCode = keyField . hashCode ( ) ; \n \n \t6 partition = Math . abs ( ( int ) ( hashCode ^ ( hashCode > > > <number_literal> ) ) ) % partitionInfos . size ( ) ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 PigStats . start ( pigContext . getExecutionEngine ( ) . instantiatePigStats ( ) ) ; \n \n \t2 <comment> \n \n \t2 String auditId = PigATSClient . getPigAuditId ( pigContext ) ; \n \n \t2 String callerId = ( String ) pigContext . getProperties ( ) . get ( PigConfiguration . PIG_LOG_TRACE_ID ) ; \n \n <ect>
<comment> \n \n \t1 private Errors initFormErrors ( RequestContext context , Object formObject ) throws Exception { \n \n <ect>
\t3 EucalyptusActivityTasks . getInstance ( ) . deleteRolePolicy ( roleName , policy . getPolicyName ( ) ) ; } \n \n \t2 EucalyptusActivityTasks . getInstance ( ) . putRolePolicy ( roleName , SERVO_ROLE_POLICY_NAME , SERVO_ROLE_POLICY_DOCUMENT ) ; \n \n \t2 LOG . info ( String . format ( <string_literal> , accountNumber , lbName ) ) ; } \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t1 while ( true ) \n \n \t1 { \n \n \t1 try \n \n \t1 { \n \n <ect>
<comment> \n \n \t1 public synchronized void addSlf4jReporter ( Duration reportInterval , String loggerName ) { \n \n \t2 if ( null != slf4jReporter ) { \n \n <ect>
\t1 path = self . resource . path \n \n \t1 if sudo . path_isdir ( path ) : \n \n \t1 raise Fail ( <string_literal> % ( self . resource , path ) ) \n \n \t1 if sudo . path_exists ( path ) : \n \n <ect>
\t3 responseObserver . onNext ( response ) ; \n \n \t3 responseObserver . onCompleted ( ) ; } \n \n \t2 @ Override \n \n \t2 public void pingSyncAsync ( PingRequest request , StreamObserver < PongResponse > responseObserver ) { \n \n <ect>
\t1 if os . path . isdir ( storm_local_directory ) : \n \n \t1 Logger . info ( <string_literal> . format ( storm_local_directory ) ) \n \n \t1 Directory ( storm_local_directory , action = <string_literal> , create_parents = True ) \n \n \t1 # Recreate storm local directory \n \n <ect>
<comment> \n \n \t1 protected void startScheduler ( final Scheduler scheduler , final int startupDelay ) throws SchedulerException { \n \n \t2 if ( startupDelay < = 0 ) { \n \n <ect>
\t2 fileWriter . flush ( ) ; \n \n \t2 fileWriter . close ( ) ; \n \n \t2 csvPrinter . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 MDC . put ( <string_literal> , <string_literal> ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 MDC . put ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t3 @ Override public void run ( ) { \n \n \t4 try { \n \n \t5 LOG . info ( <string_literal> ) ; \n \n \t5 start . await ( ) ; \n \n <ect>
\t3 return ; \n \n \t2 } catch ( CmsException ex ) { \n \n \t3 resp . setStatus ( CmsWebdavStatus . SC_INTERNAL_SERVER_ERROR ) ; \n \n \t3 if ( LOG . isErrorEnabled ( ) ) { \n \n <ect>
\t1 assertFalse ( <string_literal> , moreExpected ) ; \n \n \t1 boolean moreActual = actualIter . hasNext ( ) ; \n \n \t1 if ( moreActual ) { \n \n \t1 while ( actualIter . hasNext ( ) ) { \n \n <ect>
\t3 try { \n \n \t4 return this . componentManagerProvider . get ( ) . < TranslationBundle > getInstance ( TranslationBundle . class , \n \n \t5 bundleType + ' : ' + bundleId ) ; \n \n \t3 } catch ( ComponentLookupException e ) { \n \n <ect>
\t3 } else if ( replyType == REPLY_NETWORK_FAIL ) { \n \n \t4 break ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 TimeUnit . MILLISECONDS ) ; \n \n \t1 LOG . info ( <string_literal> + aggregator . getName ( ) + <string_literal> + \n \n \t2 + aggregator . getSleepIntervalMillis ( ) + <string_literal> ) ; \n \n \t1 } else { \n \n <ect>
\t1 if ( query . isPresent ( ) ) return Optional . of ( getQueryPerfix ( ) + query . get ( ) ) ; \n \n \t1 else return Optional . absent ( ) ; } \n \n static Optional < String > createTableRenameQuery ( String oldDatabaseName , String oldTableName , String newDatabaseName , String newTableName ) { \n \n \t1 if ( Strings . isNullOrEmpty ( oldTableName ) || Strings . isNullOrEmpty ( newTableName ) ) { \n \n <ect>
\t1 int ambariServerClassUrlsSize = 0 ; \n \n \t1 while ( ambariServerClassUrls . hasMoreElements ( ) ) { \n \n \t2 ambariServerClassUrlsSize ++ ; \n \n \t2 URL url = ambariServerClassUrls . nextElement ( ) ; \n \n <ect>
\t3 { \n \n \t4 existingList = getListFromBytes ( cache . get ( inKey ) ) ; } } \n \n \t2 catch ( IOException e1 ) \n \n \t2 { \n \n <ect>
\t7 break ; \n \n \t6 case <number_literal> : \n \n \t7 <comment> \n \n \t7 if ( p_protocol_read . getProperty ( <string_literal> ) . equals ( <string_literal> ) ) { \n \n <ect>
\t2 closeWriter ( ) ; \n \n \t2 } catch ( EventDeliveryException ex ) { \n \n \t2 LOG . warn ( <string_literal> \n \n \t3 + <string_literal> + ex . getLocalizedMessage ( ) ) ; \n \n <ect>
\t1 public void checkForcedUnlock ( ) { \n \n \t2 if ( Boolean . getBoolean ( <string_literal> ) ) { \n \n \t3 DBLockProvider lock = getDBLock ( ) ; \n \n \t3 if ( lock . supportsForcedUnlock ( ) ) { \n \n <ect>
\t1 ClientOnDefaultTable opts = new ClientOnDefaultTable ( <string_literal> ) ; \n \n \t1 ScannerOpts scanOpts = new ScannerOpts ( ) ; \n \n \t1 BatchWriterOpts bwOpts = new BatchWriterOpts ( ) ; \n \n \t1 opts . parseArgs ( TestRandomDeletes . class . getName ( ) , args , scanOpts , bwOpts ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
<comment> \n \n \t1 protected void run ( String [ ] args ) throws Exception { \n \n <ect>
\t1 try { \n \n \t1 inflightPuts = new InflightEventWrapper ( inflightPutsFile ) ; \n \n \t1 inflightTakes = new InflightEventWrapper ( inflightTakesFile ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t6 continue ; } \n \n \t6 s_logger . debug ( <string_literal> + vm + <string_literal> ) ; } \n \n \t5 if ( oldState == State . Stopping ) { \n \n <ect>
\t2 <comment> \n \n \t2 val ^ = ( messageExpiration & TIME_MASK ) ; \n \n \t2 boolean dup = _filter . add ( val ) ; \n \n \t2 if ( dup && _log . shouldLog ( Log . WARN ) ) { \n \n <ect>
\t2 super . close ( ) ; } \n \n \t1 <comment> \n \n \t2 public void disconnected ( I2PSession session ) { \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t8 . newSchema ( ) \n \n \t8 . query ( queryTypeBuilder . name ( <string_literal> ) . build ( ) ) \n \n \t8 . build ( new LinkedHashSet < > ( graphQLTypes . values ( ) ) ) ; } } \n \n \t4 } catch ( FrameworkException fex ) { \n \n <ect>
\t1 try { \n \n \t1 dataSource = PooledDatasourceHelper . setupPooledDataSource ( databaseConnection ) ; \n \n \t1 nativeConnection = captureConnection ( dataSource . getConnection ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 LOG . trace ( format ( <string_literal> , node , statistics ) ) ; \n \n \t4 } else { \n \n <ect>
\t2 try { \n \n \t3 final String engineName = getScriptEngineName ( scriptFile ) ; \n \n \t3 final ScriptEngine engine = new ScriptEngineManager ( ) . getEngineByName ( engineName ) ; \n \n \t3 if ( engine == null || StringUtils . isBlank ( engineName ) ) { \n \n <ect>
\t3 try { \n \n \t4 URI newURI = URIUtils . createURI ( oldURI . getScheme ( ) , oldURI . getHost ( ) , - 1 , \n \n \t6 URLEncoder . encode ( oldURI . getPath ( ) , <string_literal> ) , URLEncodedUtils . format ( parameters , <string_literal> ) , null ) ; \n \n \t4 logger . warn ( <string_literal> + oldURI . getPath ( ) ) ; \n \n <ect>
\t8 <comment> \n \n \t8 if ( data . startsWith ( eiscpCmd . substring ( 0 , <number_literal> ) ) ) { \n \n \t9 match = true ; } \n \n \t7 } catch ( Exception e ) { \n \n <ect>
\t2 return WSFederationClaims . ALL_CLAIMS . stream ( ) . map ( c - > UriBuilder . fromUri ( c . getUri ( ) ) . build ( ) ) . collect ( Collectors . toList ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public ProcessedClaimCollection retrieveClaimValues ( final ClaimCollection claims , final ClaimsParameters parameters ) { \n \n \t2 if ( parameters . getRealm ( ) == null || ! parameters . getRealm ( ) . equalsIgnoreCase ( this . handlerRealm ) ) { \n \n <ect>
<comment> \n \n \t1 public byte [ ] get ( String url , boolean rewrite , int retries , int initialSize , int maxSize ) { \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t6 if ( isAlive ( ) ) \n \n \t7 _log . error ( <string_literal> , ioe ) ; \n \n \t5 } catch ( Throwable t ) { \n \n \t6 if ( isAlive ( ) ) \n \n <ect>
\t4 out . write ( <string_literal> ) ; \n \n \t4 out . write ( name ) ; \n \n \t4 out . newLine ( ) ; \n \n \t4 if ( bases . length == 0 ) { \n \n <ect>
\t3 if ( bootstrap . group ( ) != null ) { \n \n \t4 bootstrap . group ( ) . shutdownGracefully ( ) ; } \n \n \t3 bootstrap = null ; } \n \n \t2 long end = System . currentTimeMillis ( ) ; \n \n <ect>
\t2 for ( Long pointer : pendingTakes ) { \n \n \t2 LOG . debug ( <string_literal> + FlumeEventPointer . fromLong ( pointer ) ) ; } \n \n \t1 } else { \n \n \t2 LOG . error ( msg + <string_literal> ) ; } } \n \n <ect>
\t2 } catch ( InstantiationException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 throw new RuntimeException ( <string_literal> + clz . getName ( ) + <string_literal> ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n <ect>
\t3 if ( value != null ) { \n \n \t4 try { \n \n \t5 mode = AutomaticWatchMode . valueOf ( value . toUpperCase ( ) ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t8 vbd . destroy ( conn ) ; } } \n \n \t6 vdi . destroy ( conn ) ; } \n \n \t5 s_logger . debug ( <string_literal> + vmName ) ; } } \n \n \t2 } catch ( Types . XenAPIException ex ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void testGetAllIdentifiers ( ) { \n \n \t2 try { \n \n \t3 long start = System . currentTimeMillis ( ) ; \n \n <ect>
\t1 private static Cassandra . Iface createConnection ( ) throws TTransportException \n \n \t1 { \n \n \t2 if ( System . getProperty ( <string_literal> ) == null || System . getProperty ( <string_literal> ) == null ) \n \n \t2 { \n \n <ect>
\t3 } else if ( e instanceof NodeValidationException ) { \n \n \t4 logger . error ( <string_literal> , e . getMessage ( ) ) ; \n \n \t3 } else { \n \n \t4 <comment> \n \n <ect>
\t6 we . resetValue ( ) ; } \n \n \t4 } else { \n \n \t5 propertyEditor . setAsText ( <string_literal> ) ; } \n \n \t4 } catch ( IllegalArgumentException ex ) { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t2 buildSMTPAppender ( subject , ASYNCHRONOUS ) ; \n \n \t2 smtpAppender . setLayout ( buildPatternLayout ( DEFAULT_PATTERN ) ) ; \n \n \t2 smtpAppender . start ( ) ; \n \n \t2 logger . addAppender ( smtpAppender ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void handleException ( String threadName , Throwable e ) { \n \n <ect>
\t2 if ( ! StringUtils . isBlank ( uri ) ) { \n \n \t3 try { \n \n \t4 this . uri = new URI ( uri ) ; \n \n \t3 } catch ( URISyntaxException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 logger . trace ( <string_literal> , uid , subId ) ; \n \n \t2 Map < String , TinkerforgeBindingProvider > providerMap = getBindingProviders ( uid , subId ) ; \n \n \t2 if ( providerMap . size ( ) == 0 ) { \n \n <ect>
\t4 zibase . hostUnregistering ( listenerHost , listenerPort ) ; \n \n \t3 } catch ( SocketException ex ) { \n \n \t4 logger . error ( <string_literal> + ex ) ; \n \n \t3 } catch ( UnknownHostException ex ) { \n \n <ect>
\t2 templateHostRef = _storageMgr . findVmTemplateHost ( templateId , pool ) ; \n \n \t2 if ( templateHostRef == null || templateHostRef . getDownloadState ( ) != Status . DOWNLOADED ) { \n \n \t3 String result = downloadTemplateFromSwiftToSecondaryStorage ( dcId , templateId ) ; \n \n \t3 if ( result != null ) { \n \n <ect>
\t3 List < ? extends NetworkACLItem > rules ) \n \n \t5 throws ResourceUnavailableException { \n \n \t2 s_logger . debug ( <string_literal> ) ; \n \n \t2 if ( rules == null || rules . isEmpty ( ) ) { \n \n <ect>
\t5 final HttpMessage msg = new HttpMessage ( url , IOUtils . toString ( entity . getContent ( ) , StandardCharsets . UTF_8 ) ) ; \n \n \t5 msg . setContentType ( entity . getContentType ( ) . getValue ( ) ) ; \n \n \t5 msg . setResponseCode ( responseCode ) ; \n \n \t5 return msg ; } } \n \n <ect>
\t1 protected String cleanupMethodName ( final String rawMethodName ) { \n \n \t2 if ( allowedMethodNames . matcher ( rawMethodName ) . matches ( ) ) { \n \n \t3 return rawMethodName ; \n \n \t2 } else { \n \n <ect>
\t3 { \n \n \t4 if ( loader . getFailedHosts ( ) . size ( ) > maxFailures ) \n \n \t5 throw new IOException ( <string_literal> + loader . getFailedHosts ( ) ) ; \n \n \t4 else \n \n <ect>
\t4 . filter ( entry - > entry . getRecordDate ( ) . isEqual ( onOrBefore ) || entry . getRecordDate ( ) . isBefore ( onOrBefore ) ) \n \n \t4 . sorted ( ) \n \n \t4 . distinct ( ) \n \n \t4 . collect ( Collectors . toSet ( ) ) ; \n \n <ect>
\t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 return new ArrayList < > ( 0 ) ; } \n \n \t2 final List < LogoutRequest > logoutRequests = performLogoutForTicket ( ticket ) ; \n \n \t2 this . logoutExecutionPlan . getLogoutHandlers ( ) . forEach ( h - > { \n \n <ect>
\t3 try { \n \n \t4 Log4jPropertyHelper . updateLog4jConfiguration ( JstormMaster . class , \n \n \t6 log4jPath ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 } catch ( IOException e ) { \n \n \t6 log . error ( <string_literal> + dbZone . getName ( ) , e ) ; } } \n \n \t4 return zones ; } \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t1 } catch ( HiveException e ) { \n \n \t1 LOG . warn ( <string_literal> , e ) ; \n \n \t1 return 1 ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 try { \n \n \t3 if ( c != null ) \n \n \t4 c . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t7 <comment> \n \n \t7 byte [ ] test = new byte [ 1 ] ; \n \n \t7 return test ; \n \n \t6 default : \n \n <ect>
\t1 public Long getNumCounter ( ) { \n \n \t1 try { \n \n \t2 return ( Long ) metrics . get ( numCounter ) ; \n \n \t1 } catch ( JMException e ) { \n \n <ect>
\t2 Class type \n \n \t2 try { \n \n \t3 Script script = shell . parse ( source , SCRIPT_FILENAME ) \n \n \t3 type = script . getClass ( ) \n \n <ect>
\t4 return ; } \n \n \t3 removeSR ( conn , sr ) ; \n \n \t3 return ; \n \n \t2 } catch ( XenAPIException | XmlRpcException e ) { \n \n <ect>
\t3 messagesBundle = new Properties ( ) ; } \n \n \t2 try { \n \n \t3 attributes . put ( <string_literal> , theme . getProperties ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 SignalHandler . register ( LOG ) ; \n \n \t2 JvmShutdownSafeguard . installAsShutdownHook ( LOG ) ; \n \n \t2 long maxOpenFileHandles = EnvironmentInformation . getOpenFileHandlesLimit ( ) ; \n \n \t2 if ( maxOpenFileHandles != - 1L ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 this . waitForParserFinished ( ) ; \n \n \t4 if ( this . parserError != null ) { \n \n <ect>
\t4 File file = new File ( dir ) ; \n \n \t4 <comment> \n \n \t4 file . mkdirs ( ) ; \n \n \t4 file = new File ( dir , name ) ; \n \n <ect>
\t9 <comment> \n \n \t9 <comment> \n \n \t9 if ( reason == null ) { \n \n \t10 if ( internet ) { \n \n <ect>
\t5 trafficClassBits | = trafficClasses . get ( trafficClassEnum ) ; \n \n \t4 } else { \n \n \t5 throw new FieldConvertError ( <string_literal> + trafficClassEnum ) ; } } \n \n \t3 trafficClassSetting = trafficClassBits ; \n \n <ect>
\t3 sendResponse ( resp , <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 HostVO host = _ms . getHostBy ( vm . getHostId ( ) ) ; \n \n \t2 if ( host == null ) { \n \n <ect>
\t3 <comment> \n \n \t2 } catch ( Exception e ) { \n \n \t2 LOG . warn ( <string_literal> + query , e ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 protected static int [ ] parseOSXVersion ( ) { \n \n \t2 if ( ! Platform . isMac ( ) ) { \n \n \t3 return null ; } \n \n \t2 if ( ! <string_literal> . equals ( System . getProperty ( <string_literal> ) ) ) { \n \n <ect>
\t2 successDocIds . add ( new DocId ( item . getIndex ( ) , item . getType ( ) , item . getId ( ) ) ) ; } } \n \n \t1 indexingListener . onSuccess ( successDocIds ) ; } \n \n \t1 @ Override \n \n \t1 public void afterBulk ( long executionId , BulkRequest req , Throwable e ) { \n \n <ect>
\t3 config = configFactory . create ( deviceType , deviceAddress , mode , allConfig ) ; \n \n \t3 open ( ) ; } } \n \n \t1 public void open ( ) { \n \n \t2 if ( config == null || ( cul != null && config . equals ( cul . getConfig ( ) ) ) ) { \n \n <ect>
\t4 PersistenceAdapter adaptor = ( PersistenceAdapter ) getClass ( ) . getClassLoader ( ) . loadClass ( clazz ) . newInstance ( ) ; \n \n \t4 jobSchedulerStore = adaptor . createJobSchedulerStore ( ) ; \n \n \t4 jobSchedulerStore . setDirectory ( getSchedulerDirectoryFile ( ) ) ; \n \n \t4 configureService ( jobSchedulerStore ) ; \n \n <ect>
\t1 this . systemSessionFactory = systemSessionFactory ; } \n \n public synchronized void gc ( ) { \n \n \t1 Repository jcrRepository = PentahoSystem . get ( Repository . class , <string_literal> , null ) ; \n \n \t1 if ( jcrRepository == null ) { \n \n <ect>
\t1 <comment> \n \n \t1 override fun leaseCompileSession ( aliveFlagPath : String ? ) : CompileService . CallResult < Int > = ifAlive ( minAliveness = Aliveness . Alive ) { \n \n \t2 CompileService . CallResult . Good ( \n \n \t4 state . sessions . leaseSession ( ClientOrSessionProxy < Any > ( aliveFlagPath ) ) . apply { \n \n <ect>
\t2 this . mode = mode ; \n \n \t2 newURI = null ; \n \n \t2 expectedSize = - 1 ; \n \n \t2 if ( mode == FetchExceptionMode . INTERNAL_ERROR ) \n \n <ect>
\t1 try { \n \n \t2 pw = new PrintWriter ( crashLogFile ) ; \n \n \t2 ex . printStackTrace ( pw ) ; \n \n \t2 pw . flush ( ) ; \n \n <ect>
\t2 log . info ( <string_literal> , afterSetupTime ) ; \n \n \t2 checkpointMBean . createCheckpoint ( <number_literal> ) ; \n \n \t2 Set < String > afterCheckpointBlobs = createBlobs ( <number_literal> , <number_literal> ) ; \n \n \t2 state . blobsPresent . addAll ( afterCheckpointBlobs ) ; \n \n <ect>
\t5 File f = File . createTempFile ( <string_literal> , null ) ; \n \n \t5 copyFile ( fs . getAvailableRefs ( ) , f ) ; \n \n \t5 ( ( BlobTrackingStore ) blobStore ) . getTracker ( ) . add ( f ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t4 final Ticket t = ( Ticket ) document . content ( ) ; \n \n \t4 LOGGER . debug ( <string_literal> , t ) ; \n \n \t4 final Ticket decoded = decodeTicket ( t ) ; \n \n \t4 if ( decoded == null || decoded . isExpired ( ) ) { \n \n <ect>
\t1 for ( File jar : jars ) { \n \n \t2 try { \n \n \t2 URL url = jar . toURI ( ) . toURL ( ) ; \n \n \t2 urls . add ( url ) ; \n \n <ect>
\t1 LOGGER . warn ( <string_literal> + name + <string_literal> + value + <string_literal> ) ; \n \n \t1 return ; } \n \n \t1 Class propClass = getPropertyType ( instance . getClass ( ) , name ) ; \n \n \t1 if ( propClass == null ) { \n \n <ect>
\t3 public void onAcceptError ( Exception error ) { \n \n \t4 LOG . error ( <string_literal> , error ) ; } \n \n \t2 } ) ; \n \n \t2 getServer ( ) . start ( ) ; \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
<comment> \n \n \t1 LOG . info ( LogUtil . header ( <string_literal> ) ) ; \n \n \t1 Bootstrap . doDiscovery ( ) ; \n \n <ect>
\t4 blockDevices . add ( device ) ; } } \n \n \t1 } catch ( ClientComputeException e ) { \n \n \t2 throw e ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t2 LOG . error ( <string_literal> , exception ) ; \n \n \t2 try { \n \n \t3 shutDown ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t3 catch ( Exception e ) { \n \n \t4 Exception exceptionToLog = e ; \n \n \t4 if ( ! ( e instanceof MessagingException ) ) { \n \n \t5 exceptionToLog = new MessageHandlingException ( requestMessage , e ) ; } \n \n <ect>
\t2 logger . debug ( <string_literal> , playerId , commandType . getCommand ( ) , newState ) ; \n \n \t2 for ( String itemName : getItemNames ( playerId , commandType ) ) { \n \n \t3 eventPublisher . postUpdate ( itemName , new PercentType ( newState ) ) ; } } \n \n \t1 private void numberChangeEvent ( String playerId , CommandType commandType , int newState ) { \n \n <ect>
\t4 if ( network . getNetworkCidr ( ) == null ) { \n \n \t5 network . setNetworkCidr ( network . getCidr ( ) ) ; } \n \n \t4 <comment> \n \n \t4 if ( network . getNetworkCidr ( ) . equals ( guestVmCidr ) ) { \n \n <ect>
\t2 Domain dm = null ; \n \n \t2 try { \n \n \t3 dm = conn . domainLookupByName ( vmName ) ; \n \n \t3 if ( attach ) { \n \n <ect>
\t3 Integer hopNum = order . get ( i ) ; \n \n \t3 int hop = hopNum . intValue ( ) ; \n \n \t3 if ( ( isBlank ( cfg , hop ) ) || ( ! cfg . isInbound ( ) && hop == 1 ) ) { \n \n \t4 <comment> \n \n <ect>
<comment> \n \n \t5 final Duration delta = Duration . between ( messageTimeEnd , messageTimeStart ) ; \n \n \t5 if ( delta . toNanos ( ) / <number_literal> > readLagTime . toNanos ( ) ) { \n \n <ect>
@ Slf4j \n \n public class CasCoreTicketCatalogConfiguration extends BaseTicketCatalogConfigurer { \n \n \t1 @ Override \n \n \t1 public final void configureTicketCatalog ( final TicketCatalog plan ) { \n \n <ect>
\t1 @ Override \n \n \t1 public Object lookup ( String lookupName ) throws NameNotFoundException { \n \n \t2 String name = this . root + lookupName ; \n \n <ect>
\t7 if ( delayAfterEndOfBlock > 0 ) { \n \n \t8 uncheckedFlush ( outstream ) ; \n \n \t8 uncheckedSleep ( delayAfterEndOfBlock ) ; } } \n \n \t6 if ( excludeEndOfData ( messageCounter ) ) { \n \n <ect>
\t1 } catch ( InterruptedException ie ) { \n \n \t1 LOGGER . warn ( <string_literal> ) ; \n \n \t1 incrementFailedCount ( ) ; \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t4 srcFs , conf , oldPart . getInputFormatClass ( ) , files ) ; } } \n \n \t2 if ( ! flag ) { \n \n \t3 throw new HiveException ( ErrorMsg . WRONG_FILE_FORMAT ) ; } \n \n \t2 } else { \n \n <ect>
\t3 Object [ ] noArgs = null ; \n \n \t3 Object result = method . invoke ( o , noArgs ) ; \n \n \t3 return ImmutablePair . of ( asName ( method ) , toString ( result ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 for ( ResetContextHandle handle : resetHandles ) { \n \n \t5 try { \n \n \t6 handle . reset ( ) ; \n \n \t5 } catch ( Throwable e ) { \n \n <ect>
\t6 i -- ; \n \n \t6 msg = pending . get ( i ) ; \n \n \t6 allocated -= curWanted ; \n \n \t6 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 try { \n \n \t4 AudioSystem . write ( request . getAudio ( ) , request . getAudioFileFormat ( ) . getType ( ) , output ) ; \n \n \t4 output . flush ( ) ; \n \n \t4 output . close ( ) ; \n \n <ect>
\t7 _privateNic = nic ; \n \n \t7 s_logger . info ( <string_literal> + nicName ) ; \n \n \t7 break ; } } \n \n \t2 <comment> \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 if ( logMINOR ) \n \n \t4 Logger . minor ( this , <string_literal> + e , e ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t3 try { \n \n \t4 URL url = new URL ( <string_literal> + System . getProperty ( <string_literal> ) + <string_literal> + location ) ; \n \n \t4 return new UrlResource ( url ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t6 throw error ; } } } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t4 try { \n \n \t5 <comment> \n \n \t5 if ( host . state == Host . State . UP ) \n \n \t6 return ; \n \n <ect>
\t4 waitFailed ( project , nodes , logger , <string_literal> ) } \n \n \t3 boolean anyNodeFailed = false \n \n \t3 for ( NodeInfo node : nodes ) { \n \n \t4 if ( node . failedMarker . exists ( ) ) { \n \n <ect>
\t4 secCodes = new HashSet ( ) ; \n \n \t4 tables . put ( ( ( KeyExtent ) ke . getKey ( ) ) . getTableId ( ) . toString ( ) , secCodes ) ; } } \n \n \t3 LOG . error ( <string_literal> , tables ) ; } \n \n \t2 if ( var7 . getConstraintViolationSummaries ( ) . size ( ) > 0 ) { \n \n <ect>
\t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 if ( rs . next ( ) ) { \n \n \t4 ipCount = rs . getInt ( 1 ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 XWikiDocument cachedoc ; \n \n \t2 try { \n \n \t3 cachedoc = getCache ( ) . get ( key ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 final String controlIp = getRouterSshControlIp ( cmd ) ; \n \n \t2 final Map < String , List < String [ ] > > data = new HashMap < String , List < String [ ] > > ( ) ; \n \n \t2 data . put ( cmd . getVmIpAddress ( ) , cmd . getVmData ( ) ) ; \n \n \t2 String json = new Gson ( ) . toJson ( data ) ; \n \n <ect>
\t2 doDTDPasses ( ext ) ; \n \n \t2 doDTDPasses ( ext ) ; \n \n \t2 doExternalEntityExpansionPasses ( ext ) ; } \n \n \t1 void doEntityExpansionFails ( String ext ) throws Exception { \n \n <ect>
\t1 public void logEvent ( Version fromVersion , Version toVersion , UpgradeState state ) { \n \n \t1 Sql sql = null ; \n \n \t1 try { \n \n \t2 sql = Databases . Events . getConnection ( ) ; \n \n <ect>
\t3 return new Home ( tmpHome ) ; } \n \n \t2 String userHomeFromEnv = System . getenv ( <string_literal> ) ; \n \n \t2 String userHomeFromProperty = System . getProperty ( <string_literal> ) ; \n \n \t2 if ( ! StringUtils . equals ( userHomeFromEnv , userHomeFromProperty ) ) { \n \n <ect>
\t3 throw new NotFoundException ( <string_literal> ) ; } \n \n \t2 if ( ! model . getProviderType ( ) . equals ( UserStorageProvider . class . getName ( ) ) ) { \n \n \t3 throw new NotFoundException ( <string_literal> ) ; } \n \n \t2 UserStorageProviderModel providerModel = new UserStorageProviderModel ( model ) ; \n \n <ect>
\t2 } else if ( ! StringUtils . isBlank ( component ) ) { \n \n \t3 LOG . info ( <string_literal> , component ) ; \n \n \t3 List < Integer > tasks = topologyContext . getComponentTasks ( component ) ; \n \n \t3 if ( tasks == null ) { \n \n <ect>
\t3 pstmt . executeBatch ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t3 URLStreamHandlerFactory oldValue = ( URLStreamHandlerFactory ) field . get ( null ) ; \n \n \t3 if ( oldValue != null ) { \n \n \t4 field . set ( null , null ) ; } \n \n \t2 } catch ( NoSuchFieldException e ) { \n \n <ect>
\t8 LOG . info ( <string_literal> + ( ( ActiveMQMessageConsumer ) localConsumer ) . getConsumerId ( ) ) ; \n \n \t8 localConsumer . close ( ) ; \n \n \t7 } catch ( NoSuchElementException nse ) { \n \n \t7 } catch ( Exception ignored ) { \n \n <ect>
\t4 listener = indexService . getIndexEventListener ( ) ; } \n \n \t3 listener . beforeIndexRemoved ( indexService , reason ) ; \n \n \t3 logger . debug ( <string_literal> , index , reason , extraInfo ) ; \n \n \t3 indexService . close ( extraInfo , reason == IndexRemovalReason . DELETED ) ; \n \n <ect>
\t3 msg . acknowledge ( ) ; } \n \n \t2 <comment> \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 msg = ( TextMessage ) consumer . receive ( <number_literal> ) ; \n \n <ect>
public void deletePigScriptLocalFile ( String homedir , String filename2 ) { \n \n \t1 try { \n \n \t1 File file = new File ( homedir + filename2 ) ; \n \n \t1 if ( file . delete ( ) ) { \n \n <ect>
\t2 } catch ( InstantiationException e ) { \n \n \t3 log . warn ( <string_literal> + className + <string_literal> + \n \n \t5 <string_literal> , e ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n <ect>
\t4 return false ; } \n \n \t3 Instance host = registeredHostsById . get ( instanceId ) ; \n \n \t3 if ( host == null ) { \n \n <ect>
\t3 List < String > arguments = options . _arguments ( ) ; \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 rewrite ( arguments ) ; \n \n <ect>
\t2 { \n \n \t3 return new Integer ( value ) ; } \n \n \t2 catch ( RuntimeException e ) \n \n \t2 { \n \n <ect>
\t5 locMap . addAltEntry ( name , altName ) ; \n \n \t5 log . debug ( <string_literal> + name + <string_literal> + altName ) ; \n \n \t4 } catch ( JenaException ex ) \n \n \t4 { \n \n <ect>
\t1 final String taskList = Iterables . get ( channelName , <number_literal> ) ; \n \n \t1 if ( this . type . equals ( type ) ) try { \n \n \t2 return hasTasks ( accountNumber , domain , taskList ) ; \n \n \t1 } catch ( final Exception e ) { \n \n <ect>
\t3 json . writeEndObject ( ) ; \n \n \t3 objectIndenter . setCompact ( false ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t2 try { \n \n \t3 Ec2Client . getInstance ( ) . deleteSnapshot ( this . getOwnerUserId ( ) , snapshotId ) ; \n \n \t3 LOG . info ( String . format ( <string_literal> , snapshotId ) ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t3 fail ( <string_literal> ) ; \n \n \t2 } catch ( IllegalArgumentException ex ) { \n \n \t3 assertEquals ( <string_literal> , ex . getMessage ( ) ) ; \n \n \t3 assertEquals ( <string_literal> , ex . getCause ( ) . getMessage ( ) ) ; } \n \n <ect>
\t1 <comment> \n \n \t1 public synchronized void initialize ( ) { \n \n <ect>
\t2 <comment> \n \n \t2 do { \n \n \t3 if ( executor . isShutdown ( ) ) \n \n \t3 { \n \n <ect>
\t2 emptyFile . seekZero ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void basicSeeking ( ) throws IOException , NoSuchAlgorithmException { \n \n <ect>
\t2 adminUsers = new HashSet < String > ( ) ; \n \n \t2 securityEnabled = services . getConf ( ) . getBoolean ( CONF_SECURITY_ENABLED , false ) ; \n \n \t2 instrumentation = Services . get ( ) . get ( InstrumentationService . class ) . get ( ) ; \n \n \t2 if ( securityEnabled ) { \n \n <ect>
\t2 LOG . info ( <string_literal> + md5Str + <string_literal> + keyObjectStr ) ; \n \n \t2 suffix = <string_literal> + md5Str + suffix ; } \n \n \t1 parentDir = FileUtils . createLocalDirsTempFile ( spillFileDirs , <string_literal> , <string_literal> , true ) ; \n \n \t1 tmpFile = File . createTempFile ( <string_literal> , suffix , parentDir ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public void notLeader ( ) { \n \n \t1 try { \n \n \t2 if ( hasLeadership ( ) ) { \n \n <ect>
\t3 pkg . save ( output . getFileOnDisk ( ) . getAbsolutePath ( ) ) ; \n \n \t3 pkg . close ( ) ; \n \n \t3 doc . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 NSArray entities = ( NSArray ) EOModelGroup . defaultGroup ( ) . models ( ) . valueForKeyPath ( <string_literal> ) ; \n \n \t5 EOQualifier q = new EOKeyValueQualifier ( <string_literal> , EOQualifier . QualifierOperatorEqual , className ) ; \n \n \t5 NSArray candidates = EOQualifier . filteredArrayWithQualifier ( entities , q ) ; \n \n \t5 if ( candidates . count ( ) > 1 ) { \n \n <ect>
\t4 VmwareManager mgr = getServiceContext ( ) . getStockObject ( VmwareManager . CONTEXT_STOCK_NAME ) ; \n \n \t4 String controlIp = getRouterSshControlIp ( cmd ) ; \n \n \t4 Pair < Boolean , String > result = SshHelper . sshExecute ( controlIp , DEFAULT_DOMR_SSHPORT , <string_literal> , mgr . getSystemVMKeyFile ( ) , null , <string_literal> + args ) ; \n \n <ect>
\t4 } else { \n \n \t5 status = cursor . getSearchKeyRange ( dk , dvs , lockMode ) ; } \n \n \t4 if ( status == opSuccess ) { \n \n <ect>
\t2 return NodeL10n . getBase ( ) . getString ( <string_literal> + newPhysicalLevel . name ( ) ) ; } \n \n \t1 public FRIEND_TRUST getDefaultFriendTrust ( ) { \n \n \t2 synchronized ( this ) { \n \n \t3 if ( friendsThreatLevel == null ) { \n \n <ect>
\t4 . put ( <string_literal> , <string_literal> ) ; \n \n \t2 assertAcked ( prepareCreate ( <string_literal> ) \n \n \t4 . setSettings ( settings ) \n \n \t4 . addMapping ( <string_literal> , <string_literal> , <string_literal> ) ) ; \n \n <ect>
\t3 try { \n \n \t4 main . initializeAndRun ( args ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 <comment> \n \n <ect>
\t4 client . isResponse200 ( ) ) ; \n \n \t2 client . reset ( ) ; } \n \n \t1 @ Test \n \n \t1 public void testAbortedPOSTOKNoSwallow ( ) { \n \n <ect>
\t2 conn . connect ( ) ; \n \n \t2 logger . info ( <string_literal> + conn . getResponseCode ( ) ) ; \n \n \t2 byte [ ] b = new byte [ <number_literal> ] ; \n \n \t2 conn . getInputStream ( ) . read ( b ) ; \n \n <ect>
\t4 return responseCode ; } } \n \n \t2 <comment> \n \n \t2 { \n \n \t3 url = server + <string_literal> + s_newVolume . get ( ) + <string_literal> + s_linuxVmId . get ( ) ; \n \n <ect>
\t3 e . printStackTrace ( ) ; } \n \n \t2 mgr = appContext . getBean ( UsageManager . class ) ; \n \n \t2 if ( mgr != null ) { \n \n <ect>
\t1 } catch ( InterruptedException e ) { \n \n \t1 Thread . currentThread ( ) . interrupt ( ) ; } \n \n \t1 do { \n \n \t1 boolean error = false ; \n \n <ect>
\t2 CustomDownSampler downSampler = getDownSamplerByType ( type , conf ) ; \n \n \t2 if ( downSampler != null ) { \n \n \t3 downSamplers . add ( downSampler ) ; } } } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 try { \n \n \t1 Path newFile = renameCompletedFile ( reader . getFilePath ( ) ) ; \n \n \t1 LOG . info ( <string_literal> , newFile , spoutId ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlSPSettingCanonicalizationMethod ( String canonicalizationMethod ) { \n \n <ect>
\t1 public final Property < Integer > getThreadCount ( ) { \n \n \t2 return threadCount ; } \n \n \t1 @ Deprecated \n \n \t1 public void threadCount ( Integer tc ) { \n \n <ect>
\t6 config . properties ( ) . put ( FrameworkConfig . NEED_RUNTIME_INJECTION , true ) ; \n \n \t6 requestScopedIntrospectors . addFirst ( ii ) ; } } \n \n \t4 if ( ! i . getClass ( ) . isAnnotationPresent ( RequestScoped . class ) ) { \n \n \t5 if ( ! i . getClass ( ) . isAnnotationPresent ( ApplicationScoped . class ) ) { \n \n <ect>
\t2 ensureGreen ( <string_literal> ) ; \n \n \t2 internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( replicaNode ) ) ; \n \n \t2 ensureYellow ( <string_literal> ) ; \n \n \t2 assertEquals ( <number_literal> , client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . metaData ( ) . index ( <string_literal> ) . inSyncAllocationIds ( 0 ) . size ( ) ) ; \n \n <ect>
\t7 stopGrid ( gridName ) ; \n \n \t7 U . sleep ( ThreadLocalRandom . current ( ) . nextLong ( restartDelay ( ) . get1 ( ) , restartDelay ( ) . get2 ( ) ) ) ; \n \n \t7 if ( stop . get ( ) ) \n \n \t8 return null ; \n \n <ect>
\t2 val readLines = ArrayList < String > ( ) \n \n \t2 val download = dbxClient . files ( ) . download ( path ) \n \n \t2 val openFileStream = download . inputStream \n \n \t2 val fileInfo = download . result \n \n <ect>
\t5 customBatch = JStormUtils . mk_list ( ) ; \n \n \t5 ret . put ( out , customBatch ) ; } \n \n \t4 customBatch . add ( msg ) ; } \n \n \t2 } else { \n \n <ect>
\t2 switch ( state ) { \n \n \t2 case UNINITIALIZED : \n \n \t2 case INITIALIZED : \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 return ; } \n \n \t3 Zone axfrZone = new Zone ( this . secondaryZone . getZoneName ( ) , records . toArray ( new Record [ records . size ( ) ] ) ) ; \n \n \t3 log . debug ( <string_literal> + this . secondaryZone . getZoneName ( ) + <string_literal> + this . secondaryZone . getRemoteServerAddress ( ) ) ; \n \n \t3 if ( ! axfrZone . getSOA ( ) . getName ( ) . equals ( this . secondaryZone . getZoneName ( ) ) ) { \n \n <ect>
\t4 this . setResponseObject ( response ) ; \n \n \t3 } else { \n \n \t4 throw new ServerApiException ( BaseCmd . INTERNAL_ERROR , <string_literal> ) ; } \n \n \t2 } catch ( ResourceUnavailableException ex1 ) { \n \n <ect>
\t5 logger . debug ( <string_literal> ) ; \n \n \t4 } catch ( IOException e ) { \n \n \t5 logger . warn ( <string_literal> , e ) ; } \n \n \t3 } else { \n \n <ect>
public LongPressOnElement ( String mappedUri ) { \n \n \t1 super ( mappedUri ) ; } \n \n @ Override \n \n public Response safeHandle ( HttpRequest request ) throws JSONException { \n \n <ect>
\t3 BCLog . logger . error ( <string_literal> + name ) ; \n \n \t3 return false ; } \n \n \t2 TabletProgram program = factory . create ( this ) ; \n \n \t2 if ( program == null ) { \n \n <ect>
\t5 return pa . getJournal ( ) . getFileMap ( ) . size ( ) == 1 ; } \n \n \t3 } , TimeUnit . MINUTES . toMillis ( <number_literal> ) ) \n \n \t2 ) ; \n \n \t2 int endPercentage = broker . getAdminView ( ) . getMemoryPercentUsage ( ) ; \n \n <ect>
\t3 { \n \n \t4 loadIndex ( ) ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t2 LOG . error ( <string_literal> , t ) \n \n \t2 try { \n \n \t2 jobManagerSystem . shutdown ( ) \n \n \t2 } catch { \n \n <ect>
\t1 if ( sourceUri . startsWith ( <string_literal> ) ) { \n \n \t2 URLStreamProvider streamProvider = new URLStreamProvider ( \n \n \t3 LOOKUP_CONNECTION_TIMEOUT , LOOKUP_READ_TIMEOUT , \n \n \t3 null , null , null ) ; \n \n <ect>
\t2 case NodeCreated : \n \n \t2 case NodeDataChanged : \n \n \t2 <comment> \n \n \t2 TableState tState = updateTableStateCache ( tableId ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 <comment> \n \n \t3 offsetTableOffset = readLong ( theBytes , theBytes . length - <number_literal> ) ; \n \n \t3 <comment> \n \n \t3 if ( numObjects < 1 ) { \n \n <ect>
\t2 sb . append ( <string_literal> ) . append ( topologyId ) . append ( <string_literal> ) ; \n \n \t2 sb . append ( <string_literal> ) . append ( port ) . append ( <string_literal> ) ; \n \n \t2 sb . append ( <string_literal> ) . append ( workerId ) . append ( <string_literal> ) ; \n \n \t2 sb . append ( <string_literal> ) . append ( jarPath ) . append ( <string_literal> ) ; \n \n <ect>
\t7 else { \n \n \t8 synchronized ( mux ) { \n \n \t9 set = oldestNode . compareAndSet ( oldest , newOldest ) ; } \n \n <ect>
\t2 File [ ] files = modulesFolder . listFiles ( ) ; \n \n \t2 if ( modulesFolder . isDirectory ( ) && files != null ) { \n \n \t3 loadModules ( Arrays . asList ( files ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 if ( openNow ) { \n \n \t3 while ( sockMgr == null ) { \n \n \t4 verifySocketManager ( ) ; \n \n \t4 if ( sockMgr == null ) { \n \n <ect>
\t3 if ( OSUtils . isWindows ( ) ) \n \n \t4 System . gc ( ) ; <comment> \n \n \t3 <comment> \n \n \t2 } catch ( FileNotFoundException e ) { \n \n <ect>
\t4 <string_literal> + request . uri ( ) + <string_literal> + request . method ( ) + <string_literal> + validMethodSet ) ; \n \n \t3 bytesRestResponse . addHeader ( <string_literal> , Strings . collectionToDelimitedString ( validMethodSet , <string_literal> ) ) ; \n \n \t3 channel . sendResponse ( bytesRestResponse ) ; \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
<comment> \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 long firstCheckPoint = getRoundedAggregateTimeMillis ( getSleepIntervalMillis ( ) ) ; \n \n <ect>
\t5 <comment> \n \n \t5 SSTableReader sstable = lookupSSTable ( cfs , desc ) ; \n \n \t5 if ( sstable == null ) \n \n \t5 { \n \n <ect>
\t3 c . close ( ) ; } \n \n \t2 <comment> \n \n \t2 broker . stop ( ) ; \n \n \t2 broker . waitUntilStopped ( ) ; \n \n <ect>
\t3 Iterator < DSCAlarmEventListener > iterator = _listeners . iterator ( ) ; \n \n \t3 while ( iterator . hasNext ( ) ) { \n \n \t4 ( ( DSCAlarmEventListener ) iterator . next ( ) ) . dscAlarmEventRecieved ( event ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 if ( contentType != null && contentType . startsWith ( VCloudMediaType . ERROR_XML ) ) { \n \n \t2 try { \n \n \t3 return factory . create ( errorHandlerProvider . get ( ) ) . setContext ( request ) . apply ( response ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t4 } else if ( action == Action . SUSPEND_ALL_ROUTES ) { \n \n \t5 log . info ( <string_literal> , tail ) ; \n \n \t5 camelContext . suspend ( ) ; } \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t2 if ( credential == null ) { \n \n \t3 LOGGER . error ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 if ( soapContext == null ) { \n \n <ect>
\t2 int count = 0 ; \n \n \t2 while ( enumeration . hasMoreElements ( ) ) { \n \n \t3 Message msg = ( Message ) enumeration . nextElement ( ) ; \n \n \t3 assertNotNull ( msg ) ; \n \n <ect>
\t1 public boolean isHealthy ( ) { \n \n \t2 long timeElapsed = System . currentTimeMillis ( ) - lastHeartBeatTimeMs ; \n \n \t2 boolean healthy = timeElapsed < maxHeartBeatTimeMs ; \n \n \t2 if ( ! healthy ) { \n \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \n \t3 Long processId = getProcessId ( ) ; \n \n \t3 if ( processId == null ) \n \n \t3 { \n \n <ect>
\t5 vnetEnd = Integer . parseInt ( tokens [ 1 ] ) ; } \n \n \t3 } catch ( NumberFormatException e ) { \n \n \t4 throw new InvalidParameterValueException ( <string_literal> ) ; } \n \n \t3 if ( ( vnetStart > vnetEnd ) || ( vnetStart < 0 ) || ( vnetEnd > <number_literal> ) ) { \n \n <ect>
\t4 try { \n \n \t5 LOG . error ( <string_literal> + failCount + <string_literal> ) ; \n \n \t5 StatsManager . stop ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 StickinessPolicy result = _lbService . createLBStickinessPolicy ( this ) ; \n \n \t3 this . setEntityId ( result . getId ( ) ) ; \n \n \t2 } catch ( NetworkRuleConflictException e ) { \n \n <ect>
\t4 int val = Integer . parseInt ( str ) ; \n \n \t4 port = val ; \n \n \t4 _log . info ( <string_literal> + port ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t2 List < String > toBeRemoved = new ArrayList < > ( ) ; \n \n \t2 for ( String engineId : input ) { \n \n \t3 if ( engineId . startsWith ( <string_literal> ) && ! registry . isAvis ( ) && Platform . isWindows ( ) ) { \n \n \t4 if ( ! avsHackLogged ) { \n \n <ect>
\t5 prop = <string_literal> ; } \n \n \t4 pageContext . getOut ( ) . print ( prop ) ; \n \n \t3 } catch ( Exception ex ) { \n \n \t4 if ( LOG . isErrorEnabled ( ) ) { \n \n <ect>
\t3 style . setColor ( TextFormatting . RED ) ; \n \n \t2 } else { \n \n \t3 style . setColor ( TextFormatting . GREEN ) ; } \n \n \t2 BCLog . logger . info ( <string_literal> + result . status ) ; \n \n <ect>
\t4 final StandardMBean adapter = new StandardMBean ( mbean , mbeanInterface ) ; \n \n \t4 mbs . registerMBean ( adapter , \n \n \t6 name ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 eeMethod . setRequestEntity ( new StringRequestEntity ( content , contentType , null ) ) ; \n \n \t4 logger . trace ( <string_literal> , content , contentType ) ; } \n \n \t4 try { \n \n <ect>
\t3 . putHeader ( this . id , new FlushHeader ( FlushHeader . FLUSH_NOT_COMPLETED , fh . viewID ) ) \n \n \t3 . setBuffer ( marshal ( flushParticipants , null ) ) ; \n \n \t3 down_prot . down ( response ) ; \n \n <ect>
\t2 { \n \n \t3 if ( ! movingToConsensus ) \n \n \t3 { \n \n \t4 membershipManager . removeAdditionalReplicationMember ( catchingUpMember ) ; \n \n <ect>
\t1 String yarnAtsGuid = statement . getYarnATSGuid ( ) ; \n \n \t1 LOG . info ( <string_literal> , yarnAtsGuid , jobId ) ; \n \n \t1 <comment> \n \n \t1 if ( yarnAtsGuid == null ) { \n \n <ect>
<comment> \n \n \t1 private void doCreateProject ( HttpServletRequest request , HttpServletResponse response , Properties parameters ) \n \n \t3 throws ServletException , IOException { \n \n <ect>
\t6 MessageAck poisonAck = new MessageAck ( messageDispatch , MessageAck . POSION_ACK_TYPE , 1 ) ; \n \n \t6 poisonAck . setPoisonCause ( error ) ; \n \n \t6 localBroker . oneway ( poisonAck ) ; \n \n \t5 } catch ( IOException ioe ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void clear ( short columnFrom , short columnTo , short rowFrom , short rowTo ) { \n \n \t2 if ( columnFrom < 0 || columnFrom > maxColumn ) { \n \n <ect>
\t3 Registry camelRegistry = getCamelContext ( ) . getRegistry ( ) ; \n \n \t3 metricRegistry = getOrCreateMetricRegistry ( camelRegistry , METRIC_REGISTRY_NAME ) ; } \n \n \t2 String metricsName = getMetricsName ( remaining ) ; \n \n \t2 MetricsType metricsType = getMetricsType ( remaining ) ; \n \n <ect>
\t3 if ( ( ( RefSeqFeature ) rec . getUnderlyingObject ( ) ) . overlapsExonP ( target ) ) { \n \n \t4 logger . debug ( <string_literal> + rec . getUnderlyingObject ( ) . toString ( ) ) ; \n \n \t4 geneNames . add ( ( ( RefSeqFeature ) rec . getUnderlyingObject ( ) ) . getGeneName ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 try { \n \n \t3 i = new LZ4Compressor ( ) ; \n \n \t2 } catch ( NoClassDefFoundError e ) { \n \n \t3 i = null ; \n \n <ect>
\t2 DLNAMediaSubtitle sub = new DLNAMediaSubtitle ( ) ; \n \n \t2 try { \n \n \t3 sub . setExternalFile ( subFile , null ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n <ect>
\t3 s_logger . info ( <string_literal> + dcId + <string_literal> + podId + <string_literal> + clusterId + <string_literal> + uri . getHost ( ) ) ; } \n \n \t2 <comment> \n \n \t2 if ( podId == null ) { \n \n <ect>
\t4 <comment> \n \n \t4 api . sendCommand ( this . getClient ( ) , null ) ; \n \n \t4 <comment> \n \n \t4 if ( ( verify == true ) && ! ( api . getResponseType ( ) == ResponseType . ERROR || api . getResponseType ( ) == ResponseType . EMPTY ) ) { \n \n <ect>
\t2 int logPeriod = optionsHelper . hasOption ( OPTION_LOG_PERIOD ) ? Integer . valueOf ( optionsHelper . getOptionValue ( OPTION_LOG_PERIOD ) ) : DEFAULT_LOG_PERIOD ; \n \n \t2 if ( logPeriod < 1 ) { \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t3 return ; } \n \n <ect>
\t6 result = <string_literal> ; } \n \n \t6 ; \n \n \t6 break ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 BuildingSlotMapIterator . MAX_PER_ITEM = builderMaxPerItemFactor ; } \n \n \t2 if ( Utils . CAULDRON_DETECTED ) { \n \n \t3 BCLog . logger . warn ( <string_literal> ) ; \n \n \t3 BCLog . logger . warn ( <string_literal> ) ; \n \n <ect>
public void setPlotSummary ( webobjectsexamples . businesslogic . movies . common . PlotSummary value ) { \n \n \t1 takeStoredValueForKey ( value , _Movie . PLOT_SUMMARY_KEY ) ; } \n \n public void setPlotSummaryRelationship ( webobjectsexamples . businesslogic . movies . common . PlotSummary value ) { \n \n <ect>
\t3 _session . destroySession ( ) ; \n \n \t3 return ; \n \n \t2 } else if ( lastActivity < = _lastActive && ! _shutdownEnabled ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t7 log . debug ( <string_literal> + dateAccArr . get ( 0 ) \n \n <number_literal> . getValue ( ) + <string_literal> + yesterday + <string_literal> + infoObject \n \n \t8 . handle ) ; } } } \n \n \t3 } else { \n \n <ect>
\t2 this ( uri , 1 ) ; } \n \n \t1 @ Override \n \n \t1 public void onInit ( Route route ) { \n \n \t2 ensureElectionIsCreated ( ) ; \n \n <ect>
<comment> \n \n \t1 public static boolean checkResponseTypes ( final String type , final OAuth20ResponseTypes . . . expectedTypes ) { \n \n <ect>
\t1 resultSet = statement . executeQuery ( query ) ; \n \n \t1 if ( ( resultSet != null ) && ( resultSet . next ( ) ) ) { \n \n \t2 count = resultSet . getInt ( 1 ) ; } \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t2 return subNetRules . accept ( _basicVisitor , router ) ; } \n \n \t1 @ Override \n \n \t1 public boolean applyDhcpEntry ( final Network network , final NicProfile nic , final VirtualMachineProfile profile , final DeployDestination dest , \n \n \t3 final DomainRouterVO router ) throws ResourceUnavailableException { \n \n <ect>
\t7 <comment> \n \n \t7 logger . debug ( <string_literal> + player . getName ( ) + <string_literal> + game . getId ( ) ) ; \n \n \t7 player . leave ( ) ; } } \n \n \t4 } else if ( ! player . hasLeft ( ) ) { \n \n <ect>
\t2 if ( this . kerberosKdcSystemProperty != null ) { \n \n \t3 LOGGER . debug ( <string_literal> , SYS_PROP_KERB5_KDC , this . kerberosKdcSystemProperty ) ; \n \n \t3 System . setProperty ( SYS_PROP_KERB5_KDC , this . kerberosKdcSystemProperty ) ; } \n \n \t2 if ( this . kerberosRealmSystemProperty != null ) { \n \n <ect>
\t2 } catch ( MalformedURLException e ) { \n \n \t3 Logger . error ( this , <string_literal> ) ; \n \n \t3 return ; \n \n \t2 } catch ( IllegalBase64Exception e ) { \n \n <ect>
\t2 while ( it . hasNext ( ) ) { \n \n \t3 Tag t = it . next ( ) ; \n \n \t3 <comment> \n \n \t3 if ( t instanceof SourceLnPosTag ) { \n \n <ect>
\t2 this . tuple = tuple ; \n \n \t2 this . tupleInfo = tupleInfo ; } \n \n \t1 public void run ( ) { \n \n \t2 if ( JStormDebugger . isDebug ( id ) ) { \n \n <ect>
\t1 } else if ( componentFactoryClass . isAnnotationPresent ( SessionScoped . class ) ) { \n \n \t3 logger . debug ( <string_literal> , targetType . getName ( ) ) ; \n \n \t2 sessionScoped . put ( targetType , componentFactoryClass ) ; \n \n \t1 } else { <comment> \n \n <ect>
\t3 try { \n \n \t4 portNum = Integer . parseInt ( args [ 1 ] ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n \t4 l . log ( <string_literal> ) ; \n \n <ect>
\t1 if ( request . getInlineData ( ) ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 if ( reply . getSize ( ) * <number_literal> > ObjectStorageProperties . MAX_INLINE_DATA_SIZE ) { \n \n <ect>
\t3 mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n \t3 JVMStabilityInspector . inspectThrowable ( e ) ; \n \n <ect>
\t2 TimeUnit . SECONDS . sleep ( <number_literal> ) ; \n \n \t2 sub = consumerSession . createDurableSubscriber ( topic , subName ) ; \n \n \t2 message = sub . receive ( <number_literal> ) ; \n \n \t2 assertNotNull ( <string_literal> , message ) ; \n \n <ect>
\t6 repository . login ( credentials ) , context ) ) ; \n \n \t4 jobs . add ( thread ) ; \n \n \t4 thread . start ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 { \n \n \t4 fieldAssembler = fieldAssembler . name ( predicateShortHand ) . type ( ) . unionOf ( ) . array ( ) . items ( targetSchema ) . and ( ) . type ( targetSchema ) . and ( ) . nullType ( ) . endUnion ( ) . noDefault ( ) ; } } } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t5 log . debug ( <string_literal> + mod ) ; } \n \n \t4 try { \n \n \t5 refreshWAC ( servletContext , false , mod ) ; \n \n <ect>
\t4 { \n \n \t5 <comment> \n \n \t5 if ( leftCount != rightCount && CompactionManager . isCompactionManager . get ( ) ) \n \n \t5 { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 long total = 0 ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t3 document = DomUtil . readXml ( stream ) ; \n \n \t3 <comment> \n \n \t3 Node descriptorsN = document . getDocumentElement ( ) ; \n \n \t3 if ( descriptorsN == null ) { \n \n <ect>
\t2 Double confidence = semanticType . getConfidenceScore ( ) ; \n \n \t2 Origin origin = semanticType . getOrigin ( ) ; \n \n \t2 Integer countOfSemanticType = semanticTypesCount . get ( domainUri + propertyUri ) ; \n \n \t2 if ( countOfSemanticType == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( fileTransferTransport == null ) \n \n \t2 { \n \n <ect>
\t2 try { \n \n \t3 sendWithRetries ( nodeId , new GridContinuousMessage ( MSG_START_ACK , routineId , err ) , null ) ; } \n \n \t2 catch ( GridTopologyException ignored ) { \n \n <ect>
\t2 try { \n \n \t3 release ( msg , decrement ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t2 Object valDeSer = props . get ( ConsumerConfig . VALUE_DESERIALIZER_CLASS_CONFIG ) ; \n \n \t2 if ( keyDeSer != null && ! keyDeSer . equals ( deSerName ) ) { \n \n \t3 LOG . warn ( <string_literal> , ConsumerConfig . KEY_DESERIALIZER_CLASS_CONFIG ) ; } \n \n \t2 if ( valDeSer != null && ! valDeSer . equals ( deSerName ) ) { \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 log . error ( <string_literal> , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 disconnect ( ) ; } \n \n \t5 return ; } \n \n \t3 } catch ( Exception ex ) \n \n \t3 { \n \n <ect>
\t1 IOException { \n \n \t1 DataInputStream in = new DataInputStream ( new ByteBufferBackedInputStream ( payload ) ) ; \n \n \t1 try { \n \n \t1 String columnName = in . readUTF ( ) ; \n \n <ect>
\t4 final SVNDirEntry logEntry = handler . getParent ( ) ; \n \n \t4 final List < TestVersionResult . Test > tests = Lists . newArrayListWithExpectedSize ( handler . getChildren ( ) . size ( ) ) ; \n \n \t4 for ( final SVNDirEntry testDefFile : handler . getChildren ( ) ) { \n \n \t5 if ( testDefFile . getKind ( ) != SVNNodeKind . DIR ) { \n \n <ect>
\t3 response . setStatus ( HttpSC . OK_200 ) ; \n \n \t3 ServletOutputStream out = response . getOutputStream ( ) ; \n \n \t3 out . println ( DateTimeUtils . nowAsXSDDateTimeString ( ) ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t4 logger . debug ( <string_literal> + sessionId ) ; \n \n \t4 logger . debug ( <string_literal> + session . getHost ( ) ) ; \n \n \t4 return true ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 public void deviceRemoved ( Device dev ) { \n \n \t4 String udn = dev . getUDN ( ) ; \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 messagesSent . incrementAndGet ( ) ; \n \n \t6 producerHasSentTenMessages . countDown ( ) ; \n \n \t6 Thread . sleep ( <number_literal> ) ; \n \n \t6 if ( idx != 0 && idx%100 == 0 ) { \n \n <ect>
\t3 return ; } \n \n \t2 try { \n \n \t3 manageObject ( managedObject ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 ClassFinder finder = buildClassFinder ( classPackageTest , urls ) ; \n \n \t4 Test < ClassFinder . ClassInfo > test = getActionClassTest ( ) ; \n \n \t4 classes . addAll ( finder . findClasses ( test ) ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t9 message . setHeader ( JCacheConstants . OLD_VALUE , event . getOldValue ( ) ) ; } \n \n \t8 try { \n \n \t9 getProcessor ( ) . process ( exchange ) ; \n \n \t8 } catch ( Exception e ) { \n \n <ect>
\t2 if ( needRestart ) { \n \n \t3 try { \n \n \t4 _itMgr . start ( vm , null , user , caller ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 Map < String , String > values = getSingleValueFromXML ( el , \n \n \t6 new String [ ] { <string_literal> , <string_literal> } ) ; \n \n \t4 if ( ( values . get ( <string_literal> ) == null ) || ( values \n \n \t6 . get ( <string_literal> ) == null ) ) { \n \n <ect>
\t2 smtpAppender . addTo ( <string_literal> ) ; \n \n \t2 smtpAppender . start ( ) ; \n \n \t2 logger . addAppender ( smtpAppender ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n <ect>
\t2 if ( properties . getProperty ( <string_literal> ) != null ) { \n \n \t3 try { \n \n \t4 ttl = Integer . parseInt ( properties . getProperty ( <string_literal> ) ) ; \n \n \t3 } catch ( Exception x ) { \n \n <ect>
\t1 File dbDir = new File ( System . getProperty ( <string_literal> ) , <string_literal> ) ; \n \n \t1 if ( ! dbDir . mkdir ( ) ) { \n \n \t1 throw new RuntimeException ( <string_literal> + dbDir . getAbsolutePath ( ) ) ; } \n \n \t1 dbDir . deleteOnExit ( ) ; \n \n <ect>
\t7 if ( _ipAddressDao . update ( addr . getId ( ) , addr ) ) { \n \n \t8 finalAddr = addr ; \n \n \t8 break ; } } } } \n \n \t4 if ( finalAddr == null ) { \n \n <ect>
\t3 Dn dn = ldifEntry . getDn ( ) ; \n \n \t3 if ( ldifEntry . isEntry ( ) ) { \n \n \t4 org . apache . directory . api . ldap . model . entry . Entry items = ldifEntry . getEntry ( ) ; \n \n \t4 rootDSE . add ( new DefaultEntry ( directoryService . getSchemaManager ( ) , items ) ) ; \n \n <ect>
\t2 <comment> \n \n \t2 replyManager . processReply ( holder ) ; } \n \n \t1 public void onTimeout ( String correlationId ) { \n \n \t2 <comment> \n \n <ect>
\t2 getMoreLogs ( ) ; \n \n \t1 } catch ( SQLException e ) { \n \n \t2 LOG . error ( <string_literal> , logFile , e ) ; \n \n \t1 } catch ( HdfsApiException e ) { \n \n <ect>
\t6 listener . eventReceived ( CuratorFrameworkImpl . this , event ) ; } \n \n \t5 catch ( Exception e ) \n \n \t5 { \n \n \t6 ThreadUtils . checkInterrupted ( e ) ; \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 stopAsync ( ) ; \n \n \t2 while ( ! stopped . await ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n <ect>
\t5 || AuthPolicy . SPNEGO . equalsIgnoreCase ( authScope . getScheme ( ) ) ) { \n \n \t4 logger . debug ( <string_literal> , \n \n \t6 new Object [ ] { authScope . getHost ( ) , authScope . getPort ( ) , authScope . getRealm ( ) } ) ; \n \n \t4 if ( requestUsername == null && AuthPolicy . BASIC . equalsIgnoreCase ( authScope . getScheme ( ) ) ) { \n \n <ect>
\t2 if ( debugOutput != null ) { \n \n \t3 try { \n \n \t4 debugOutput . close ( ) ; \n \n \t3 } catch ( IOException ex ) { \n \n <ect>
\t2 try { \n \n \t3 FileUtils . writeStringToFile ( config . getHome ( ) . getSubFile ( <string_literal> ) , content , <string_literal> ) ; \n \n \t3 config . loadAnnouncement ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 if ( isWindows ( ) ) { \n \n \t3 f = new File ( <string_literal> ) ; \n \n \t2 } else { \n \n \t3 f = new File ( <string_literal> ) ; } \n \n <ect>
\t5 <comment> \n \n \t5 if ( getContext ( ) . random ( ) . nextInt ( <number_literal> ) > 0 ) { \n \n \t6 sigTypeChanged = false ; \n \n \t6 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t5 Revision lastRev = doc . getLastRev ( ) . get ( clusterId ) ; \n \n \t5 Revision lastMod = determineLastModification ( doc , clusterId ) ; \n \n \t5 knownLastRev = Utils . max ( lastRev , lastMod ) ; \n \n \t4 } else { \n \n <ect>
\t3 method = mci . retrieveConstructor ( newArgs ) ; \n \n \t3 if ( method instanceof MetaConstructor ) { \n \n \t4 MetaConstructor mcon = ( MetaConstructor ) method ; \n \n \t4 if ( mcon . isBeanConstructor ( ) ) { \n \n <ect>
\t4 lastSlowData . add ( slowDataEle ) ; \n \n \t4 lastErrorData . add ( errDataEle ) ; \n \n \t4 otherData . add ( otherDataEle ) ; \n \n \t3 } else { \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t4 <comment> \n \n \t4 return new Answer ( cmd , true , <string_literal> ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t4 { \n \n \t5 index . close ( ) ; } \n \n \t4 catch ( Exception e ) \n \n \t4 { \n \n <ect>
\t3 checkpoint ( stateful , read , end ) ; \n \n \t3 return null ; } \n \n \t2 <comment> \n \n \t2 else { \n \n <ect>
\t2 } catch ( final Exception e ) { \n \n \t3 LOGGER . error ( e . getMessage ( ) , e ) ; } \n \n \t2 return null ; } \n \n \t1 private TreeSet < OneTimeTokenAccount > readAccountsFromJsonRepository ( ) throws IOException { \n \n <ect>
\t5 if ( TimeValue . isPositive ( keepAlive ) ) { \n \n \t6 s = <string_literal> + keepAlive ; \n \n \t5 } else { \n \n \t6 s = <string_literal> ; } \n \n <ect>
\t1 RawStore ms = getMS ( ) ; \n \n \t1 try { \n \n \t2 adminRole = ms . getRole ( ADMIN ) ; \n \n \t1 } catch ( NoSuchObjectException e ) { \n \n <ect>
\t1 public void bindingChanged ( BindingProvider provider , String itemName ) { \n \n \t2 super . bindingChanged ( provider , itemName ) ; \n \n \t2 conditionalDeActivate ( ) ; } \n \n \t1 private void conditionalDeActivate ( ) { \n \n <ect>
\t4 this . getController ( ) . notifyEventListeners ( zEvent ) ; \n \n \t4 dynamicDone = true ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t1 <comment> \n \n \t1 for ( WmTezSession sessionToDestroy : e . toDestroy ) { \n \n \t1 if ( e . toReturn . remove ( sessionToDestroy ) ) { \n \n \t2 LOG . warn ( <string_literal> ) ; } \n \n <ect>
\t3 AsyncCallFuture < TemplateApiResult > future = _tmpltSvr . prepareTemplateOnPrimary ( srcTemplate , pool ) ; \n \n \t3 try { \n \n \t4 TemplateApiResult result = future . get ( ) ; \n \n \t4 if ( result . isFailed ( ) ) { \n \n <ect>
\t1 else { \n \n \t2 addObjectToBothSidesOfRelationshipWithKey ( object , _Forum . POSTS_KEY ) ; } } \n \n public void removeFromPostsRelationship ( se . caboo . beast . model . Post object ) { \n \n <ect>
\t2 TunnelId inTunnelId = inTunnel . getReceiveTunnelId ( 0 ) ; \n \n \t2 RouterInfo inGateway = getContext ( ) . netDb ( ) . lookupRouterInfoLocally ( inTunnel . getPeer ( 0 ) ) ; \n \n \t2 if ( inGateway == null ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 assertEquals ( false , log . hasEvents ( ) ) ; } \n \n \t1 @ Test \n \n \t1 public void shouldNotAcceptMessageWithNonNullAndNullParameters ( ) { \n \n \t2 logger . error ( errorMessageWithTwoParameters , <string_literal> , null ) ; \n \n <ect>
\t1 private static final Logger log = LoggerFactory . getLogger ( SourceTypeStreamFile . class ) ; \n \n \t1 private final StreamFile streamFile ; \n \n \t1 public SourceTypeStreamFile ( TaskDataSource source , StreamFile streamFile ) { \n \n \t2 super ( source ) ; \n \n <ect>
\t4 return null ; } \n \n \t3 if ( sources [ 0 ] instanceof AbstractNode ) { \n \n \t4 ( ( AbstractNode ) sources [ 0 ] ) . unlockSystemPropertiesOnce ( ) ; \n \n \t3 } else { \n \n <ect>
\t4 s_logger . error ( <string_literal> + maid . getDelegate ( ) ) ; \n \n \t3 } catch ( final InstantiationException e ) { \n \n \t4 s_logger . error ( <string_literal> + maid . getDelegate ( ) ) ; \n \n \t3 } catch ( final IllegalAccessException e ) { \n \n <ect>
\t5 ( ( Bundle ) pluginTable . getModel ( ) \n \n \t7 . getValueAt ( selectedRows [ i ] , 0 ) ) . update ( ) ; } \n \n \t4 catch ( BundleException ex ) \n \n \t4 { \n \n <ect>
\t2 while ( ( result = parser . getParseResult ( ) ) != null ) { \n \n \t3 try { \n \n \t3 store . persist ( event , result ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 logger . info ( <string_literal> \n \n \t6 + factory . getColumnName ( hNode . getId ( ) ) \n \n \t6 + <string_literal> + node . getValue ( ) . asString ( ) \n \n \t6 + <string_literal> ) ; \n \n <ect>
\t5 . createQuery ( \n \n \t7 <string_literal> + <string_literal> \n \n \t9 + <string_literal> ) \n \n \t5 . setParameter ( <string_literal> , tabToUndelete . getTemplate ( ) . getId ( ) ) . executeUpdate ( ) ; \n \n <ect>
\t2 logger . debug ( <string_literal> + this . rawMsg ) ; \n \n \t2 logger . debug ( <string_literal> + Integer . toString ( 0xff & this . len ) ) ; \n \n \t2 logger . debug ( <string_literal> + Integer . toHexString ( 0xff & this . msgCount ) ) ; \n \n \t2 logger . debug ( <string_literal> + Integer . toHexString ( 0xff & this . msgFlag ) ) ; \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 <comment> \n \n \t3 try { \n \n \t4 if ( ! verifyAttributeExtraction ( url , attributeList ) ) { \n \n <ect>
\t2 return f ; } \n \n \t1 @ Override \n \n \t1 protected void prepareInvokeOnStateChange ( final AtmosphereResource r , final AtmosphereResourceEvent e ) { \n \n \t2 if ( writeTimeoutInSecond != - 1 ) { \n \n <ect>
\t4 logger . info ( <string_literal> + sid ) ; } \n \n \t3 return sid ; } \n \n \t2 Matcher challengematch = CHALLENGE_PATTERN . matcher ( loginXml ) ; \n \n \t2 if ( ! challengematch . find ( ) ) { \n \n <ect>
\t2 WOComponent wocomponent = wocontext . component ( ) ; \n \n \t2 Context context = createContext ( wocomponent ) ; \n \n \t2 int count = _count ( context , wocomponent ) ; \n \n \t2 boolean checkHashCodes = checkHashCodes ( wocomponent ) ; \n \n <ect>
\t3 Message message = session . createMessage ( ) ; \n \n \t3 message . setStringProperty ( <string_literal> , <string_literal> ) ; \n \n \t3 producer . send ( topic , message ) ; \n \n \t3 sent ++ ; } \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t3 resolverClass . objectInstance ? . let { \n \n \t4 return it } \n \n \t3 val constructorWithoutParameters = resolverClass . constructors . find { it . parameters . all { it . isOptional } } \n \n \t3 if ( constructorWithoutParameters == null ) { \n \n <ect>
\t5 <comment> \n \n \t5 task . call ( ) ; \n \n \t4 } catch ( Throwable cause ) { \n \n \t5 if ( ! tryFailureInternal ( cause ) ) { \n \n <ect>
\t4 loadFunction ( currentlySelectedWindow ) ; \n \n \t3 } else { \n \n \t4 LOG . debug ( <string_literal> + currentlySelectedWindowMarker + <string_literal> + newMarker + <string_literal> ) ; } \n \n \t3 return ; } \n \n <ect>
\t2 return Collections . emptyList ( ) ; } \n \n \t1 @ Override \n \n \t1 public void init ( Resource resource , String name , String instruction ) { \n \n \t2 this . resource = resource ; \n \n <ect>
\t1 private void transferAlignmentInfoToFragment ( final SAMRecord unaligned , final SAMRecord aligned , final boolean isContaminant , final boolean needsSafeReverseComplement ) { \n \n \t2 setValuesFromAlignment ( unaligned , aligned , needsSafeReverseComplement ) ; \n \n \t2 updateCigarForTrimmedOrClippedBases ( unaligned , aligned ) ; \n \n \t2 if ( SAMUtils . cigarMapsNoBasesToRef ( unaligned . getCigar ( ) ) ) { \n \n <ect>
\t3 client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) \n \n \t3 . setTransientSettings ( Settings . builder ( ) . put ( <string_literal> , numShardsOnNode1 ) ) . execute ( ) . actionGet ( ) ; \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t5 s_logger . info ( <string_literal> ) ; \n \n \t5 invalidateServiceContext ( context ) ; } \n \n \t3 } else { \n \n \t4 <comment> \n \n <ect>
\t2 try ( final Tx tx = app . tx ( ) ) { \n \n \t3 resultList = query . getAsList ( ) ; \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t2 try { \n \n \t3 Method jmDNSCreateMethod = jmDNSClass . getMethod ( <string_literal> , null ) ; \n \n \t3 return jmDNSCreateMethod . invoke ( null , null ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n <ect>
\t2 liveEndpoints . add ( addr ) ; \n \n \t2 unreachableEndpoints . remove ( addr ) ; \n \n \t2 expireTimeEndpointMap . remove ( addr ) ; \n \n \t2 logger . debug ( <string_literal> + addr ) ; \n \n <ect>
\t3 logger . warn ( <string_literal> , requestedPath ) ; \n \n \t3 tx . success ( ) ; \n \n \t3 return new FileOrFolder ( requestedPath , user ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 } catch ( PeerParseException e ) { \n \n \t4 Logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; \n \n \t4 return null ; \n \n \t3 } catch ( ReferenceSignatureVerificationException e ) { \n \n <ect>
\t6 . to ( <string_literal> ) \n \n \t6 . process ( new Processor ( ) { \n \n \t7 @ Override \n \n \t7 public void process ( Exchange exchange ) throws Exception { \n \n <ect>
\t2 final String repoName = <string_literal> ; \n \n \t2 createTestRepository ( repoName ) ; \n \n \t2 createIndex ( <string_literal> , <string_literal> , <string_literal> ) ; \n \n \t2 ensureGreen ( ) ; \n \n <ect>
\t10 s_logger . info ( <string_literal> + volume . getUuid ( ) + <string_literal> ) ; \n \n \t10 AsyncCallFuture < VolumeApiResult > future = volService . expungeVolumeAsync ( volOnSecondary ) ; \n \n \t10 VolumeApiResult result = future . get ( ) ; \n \n \t10 if ( ! result . isSuccess ( ) ) { \n \n <ect>
\t3 try { \n \n \t4 saveToFile ( project , tempFile ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 e . printStackTrace ( ) ; \n \n <ect>
\t2 if ( fs . isReady ( ) ) \n \n \t2 break ; \n \n \t2 log . warn ( <string_literal> ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t1 try { \n \n \t2 verifyRequest ( jobId , ctx , request , response , \n \n \t3 new URL ( <string_literal> , <string_literal> , this . port , reqUri ) ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 { \n \n \t3 if ( conf . commitlog_sync_period_in_ms != 0 ) \n \n \t3 { \n \n \t4 throw new ConfigurationException ( <string_literal> , false ) ; } \n \n <ect>
\t1 public static String getAvcProfile ( String value ) { \n \n \t2 String profile = substringBefore ( lowerCase ( value ) , <string_literal> ) ; \n \n \t2 if ( isNotBlank ( profile ) ) { \n \n \t3 return profile ; } \n \n <ect>
\t4 if ( ifc . isUp ( ) && ! ifc . isVirtual ( ) ) { \n \n \t5 for ( final InetAddress addr : IteratorUtil . enumerationAsIterable ( ifc . getInetAddresses ( ) ) ) { \n \n \t6 addrList . add ( addr ) ; } } } \n \n \t2 } catch ( final SocketException e ) { \n \n <ect>
public Integer unitID ( ) { \n \n \t1 return ( Integer ) storedValueForKey ( _Unit . UNIT_ID_KEY ) ; } \n \n public void setUnitID ( Integer value ) { \n \n <ect>
\t2 this . tempDir = new File ( dir , <string_literal> ) ; \n \n \t2 try { \n \n \t3 this . tempDir . mkdirs ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 if ( error instanceof DestinationDoesNotExistException && ( ( DestinationDoesNotExistException ) error ) . isTemporary ( ) ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( messageDispatch != null ) { \n \n <ect>
\t2 connections . remove ( event . getSource ( ) ) ; \n \n \t2 try { \n \n \t3 ( ( ManagedConnection ) event . getSource ( ) ) . cleanup ( ) ; \n \n \t2 } catch ( ResourceException e ) { \n \n <ect>
\t4 citrixResourceBase . setCanBridgeFirewall ( canBridgeFirewall ) ; \n \n \t4 if ( ! canBridgeFirewall ) { \n \n \t5 final String msg = <string_literal> ; \n \n \t5 s_logger . warn ( msg ) ; \n \n <ect>
\t6 log . debug ( <string_literal> { } \\ <string_literal> , StringEscapeUtil . escapeJava ( key ) ) ; } \n \n \t4 } else { \n \n \t5 params . setStrings ( key , values ) ; \n \n <ect>
\t2 if ( null == line ) { \n \n \t3 break ; <comment> \n \n \t2 LoggingAsyncSink . this . contextLog . info ( line ) ; } \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t4 containerId = rs . getInt ( 1 ) ; \n \n \t4 resultCount ++ ; } \n \n \t3 rs . close ( ) ; \n \n \t3 if ( resultCount == 0 ) { \n \n <ect>
<comment> \n \n \t1 public String readStringRaw ( ) throws IOException { \n \n \t2 int len = readLength ( ) ; \n \n \t2 if ( len == 0 ) { \n \n <ect>
\t6 piece = p ; \n \n \t6 break ; } } } \n \n \t3 if ( piece == null ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 <comment> \n \n \t3 String fullSnapPath = parent + snapshotPath ; \n \n \t3 File snapDir = new File ( fullSnapPath ) ; \n \n \t3 if ( snapDir . exists ( ) && snapDir . isDirectory ( ) ) { \n \n <ect>
\t2 } catch ( ParserConfigurationException e ) { \n \n \t3 s_logger . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t3 return null ; \n \n \t2 } catch ( DOMException e ) { \n \n <ect>
\t6 if ( object . getVirtual ( ) == 1 ) { \n \n \t7 rCode = comm . sendDataToService ( object . getParent ( ) , encData ) ; \n \n \t6 } else { \n \n \t7 rCode = comm . sendDataToService ( service , encData ) ; } \n \n <ect>
\t2 public void messageReceived ( IoSession session , Object message ) throws Exception { \n \n \t3 logger . debug ( <string_literal> , message ) ; } \n \n \t2 @ Override \n \n \t2 public void exceptionCaught ( IoSession session , Throwable cause ) throws Exception { \n \n <ect>
\t3 if ( sn == null ) continue ; \n \n \t3 logger . debug ( <string_literal> + number + <string_literal> ) ; \n \n \t3 logger . debug ( sn . getScoreDetailsString ( ) ) ; \n \n \t3 number ++ ; \n \n <ect>
\t1 count ++ ; \n \n \t1 if ( byteChar != 0 && byteChar % 1000000L == 0 ) { \n \n \t2 logger . info ( <string_literal> + ( byteChar / 1000000L ) + \n \n \t3 <string_literal> ) ; } } \n \n <ect>
\t2 if ( client . getDeliveryMode ( ) . equalsIgnoreCase ( JmsProducerProperties . DELIVERY_MODE_PERSISTENT ) ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 jmsProducer . setDeliveryMode ( DeliveryMode . PERSISTENT ) ; \n \n \t2 } else if ( client . getDeliveryMode ( ) . equalsIgnoreCase ( JmsProducerProperties . DELIVERY_MODE_NON_PERSISTENT ) ) { \n \n <ect>
\t2 try { \n \n \t3 res = OpenCms . initCmsObject ( cms ) ; \n \n \t3 res . getRequestContext ( ) . setCurrentProject ( cms . readProject ( CmsProject . ONLINE_PROJECT_ID ) ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t3 if ( state == HighLowValue . HIGH ) { \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t4 tinkerforgeDevice . ledOn ( ) ; \n \n \t3 } else { \n \n <ect>
\t1 String task3 = query \n \n \t2 . taskDefinitionKey ( <string_literal> ) \n \n \t2 . singleResult ( ) \n \n \t2 . getId ( ) ; \n \n <ect>
\t4 return calculatedSpeed ( ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n \t4 return <string_literal> ; \n \n \t3 } catch ( ExecutionException e ) { \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n <ect>
\t3 onException ( context , e ) ; \n \n \t3 endContext ( context ) ; \n \n \t3 throw configuration . translate ( queryString , constants , e ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 acceptor . bind ( addr ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t2 sessions1 = getSessions ( session1 ) ; \n \n \t2 sessions2 = getSessions ( session2 ) ; \n \n \t2 Assert . assertTrue ( sessions1 . isEmpty ( ) ) ; \n \n \t2 Assert . assertTrue ( sessions2 . isEmpty ( ) ) ; \n \n <ect>
\t3 if ( task != null ) { \n \n \t4 try { \n \n \t5 task . destroy ( conn ) ; \n \n \t4 } catch ( Exception e1 ) { \n \n <ect>
\t4 if ( tmp_view != null ) \n \n \t5 view_rsps . add ( sender , tmp_view ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void warning ( SAXParseException exception ) throws SAXException { \n \n \t2 if ( errorHandler != null ) { \n \n <ect>
\t1 protected void registerMultifactorFlowDefinitionIntoLoginFlowRegistry ( final FlowDefinitionRegistry sourceRegistry ) { \n \n \t2 final String [ ] flowIds = sourceRegistry . getFlowDefinitionIds ( ) ; \n \n \t2 for ( final String flowId : flowIds ) { \n \n \t3 final FlowDefinition definition = sourceRegistry . getFlowDefinition ( flowId ) ; \n \n <ect>
\t2 @ Override \n \n \t2 public void validate ( Message message , DataType type ) throws ValidationException { \n \n \t3 message . getExchange ( ) . setProperty ( VALIDATOR_INVOKED , OtherXOrderResponseValidator . class ) ; \n \n \t3 assertEquals ( <string_literal> , message . getBody ( ) ) ; \n \n <ect>
\t1 private void notifyListeners ( String json ) throws IOException { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( json == null || json . isEmpty ( ) ) { \n \n <ect>
\t1 public Serializable execute ( final TaskHandlerActionContext < ActionContext > inActionContext ) \n \n \t1 { \n \n \t2 if ( cache != null ) \n \n \t2 { \n \n <ect>
\t1 TokenRewriteStream tokenRewriteStream = ctx . getViewTokenRewriteStream ( rewriteStreamName ) ; \n \n \t1 String fullyQualifiedQuery = rewriteQueryWithQualifiedNames ( astNode , tokenRewriteStream ) ; \n \n \t1 return fullyQualifiedQuery ; \n \n \t1 } catch ( Exception err ) { \n \n <ect>
\t4 stmt . setString ( <number_literal> , name ) ; \n \n \t4 stmt . executeUpdate ( ) ; \n \n \t4 return true ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 cd_access = 'a' , \n \n \t1 create_parents = True , \n \n \t1 recursive_ownership = True ) \n \n tez_tarball_with_native_lib = os . path . join ( tez_native_tarball_staging_dir , <string_literal> ) \n \n <ect>
\t3 return GridComputeJobResultPolicy . FAILOVER ; } \n \n \t2 <comment> \n \n \t2 @ Override public Integer reduce ( List < GridComputeJobResult > results ) { \n \n <ect>
\t4 return file . isFile ( ) && file . getName ( ) . startsWith ( <string_literal> ) ; \n \n \t3 } } ) ; \n \n \t2 for ( final File doc : docs ) { \n \n \t3 final Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) ) ; \n \n <ect>
<comment> \n \n @ BeforeClass \n \n public static void setup ( ) throws TTransportException , IOException , InterruptedException , ConfigurationException { \n \n <ect>
\t4 try { \n \n \t5 if ( local . fileExists ( name ) ) { \n \n \t6 local . deleteFile ( name ) ; } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t1 long end ; \n \n \t1 while ( i < <number_literal> ) { \n \n \t1 i ++ ; } \n \n \t1 end = System . nanoTime ( ) ; \n \n <ect>
\t1 static { \n \n \t2 try { \n \n \t3 krb5Oid = new Oid ( <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 throw new RuntimeException ( <string_literal> ) ; } \n \n \t1 if ( type . isDynamic ( ) ) { \n \n \t1 cluster . start ( ) ; \n \n \t1 } else { \n \n <ect>
\t4 . done ( ) , \n \n \t3 Result . class ) ; \n \n \t2 assertNotNull ( <string_literal> , createResult ) ; \n \n \t2 assertTrue ( createResult . isSuccess ( ) ) ; \n \n <ect>
\t3 return Optional . empty ( ) ; } \n \n \t2 return Optional . of ( key ) ; } \n \n \t1 private static RsaJsonWebKey getJsonSigningWebKeyFromJwks ( final JsonWebKeySet jwks ) { \n \n \t2 if ( jwks . getJsonWebKeys ( ) . isEmpty ( ) ) { \n \n <ect>
\t3 if ( url != null ) { \n \n \t4 try { \n \n \t5 this . properties = new Configurations ( ) . properties ( url ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n <ect>
\t4 messageListener . setInterrupted ( true ) ; \n \n \t4 try { \n \n \t5 messageListener . join ( ) ; \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t1 { \n \n \t2 @ Override \n \n \t2 public void runInternal ( ) \n \n \t2 { \n \n <ect>
\t3 Session session2 = con2 . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; \n \n \t3 session2 . unsubscribe ( <string_literal> ) ; \n \n \t3 session2 . close ( ) ; \n \n \t3 con2 . close ( ) ; \n \n <ect>
\t6 lastTxid = txid - 1 ; \n \n \t5 } else { \n \n \t6 lastTxid = txid ; } \n \n \t4 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 } catch ( IOException ioe ) { \n \n \t4 Throwable cause = ioe . getCause ( ) ; \n \n \t4 if ( cause instanceof UnrecoverableKeyException ) { \n \n \t5 <comment> \n \n <ect>
\t1 counterGroup . incrementAndGet ( <string_literal> ) ; \n \n \t1 } catch ( Exception ex ) { \n \n \t1 transaction . rollback ( ) ; \n \n \t1 counterGroup . incrementAndGet ( <string_literal> ) ; \n \n <ect>
\t7 s_logger . error ( <string_literal> + api . getName ( ) + \n \n \t8 <string_literal> + api . getUrl ( ) ) ; \n \n \t7 return false ; \n \n \t6 } else if ( api . getTestCaseInfo ( ) != null ) { \n \n <ect>
\t3 return ( Boolean ) meta . getClass ( ) . getMethod ( <string_literal> ) . invoke ( meta ) ; } \n \n \t2 catch ( NoSuchMethodException e ) { \n \n \t3 log . trace ( <string_literal> ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t3 case QUEUE_FLUSH_INTERVAL : { \n \n \t4 if ( namespace . since ( Namespace . INFINISPAN_SERVER_9_0 ) ) { \n \n \t5 throw ParseUtils . unexpectedAttribute ( reader , index ) ; \n \n \t4 } else { \n \n <ect>
\t3 e . printStackTrace ( ) ; \n \n \t3 logger . error ( <string_literal> , e . getMessage ( ) ) ; } } \n \n \t1 private boolean validateCubeInstance ( CubeInstance cubeInstance ) { \n \n \t2 if ( cubeInstance == null ) { \n \n <ect>
\t1 public void changePassword ( String pw , String pw2 ) throws DAOException { \n \n \t2 User u = Context . getAuthenticatedUser ( ) ; \n \n \t2 LoginCredential credentials = getLoginCredential ( u ) ; \n \n \t2 if ( ! credentials . checkPassword ( pw ) ) { \n \n <ect>
<comment> \n \n \t1 private WeightedMultigraph < Node , DefaultLink > step5 ( WeightedMultigraph < Node , DefaultLink > g4 ) { \n \n <ect>
\t2 } catch ( FileNotFoundException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t3 return new UpdateContainer ( new ErrorUpdate ( <string_literal> + e . getMessage ( ) ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 if ( event . getState ( ) == KeeperState . Expired ) { \n \n \t1 log . warn ( <string_literal> , event . getPath ( ) ) ; \n \n \t1 server . stop ( ) ; \n \n \t1 } else if ( event . getType ( ) == EventType . NodeDeleted ) { \n \n <ect>
\t6 if ( stats . getMeasurementsCount ( ) < minMeasure ) \n \n \t7 continue ; \n \n \t6 if ( stats . lastUpdatedSince ( ) > retryPeriod ) { \n \n \t7 if ( excludedAtLastTick . contains ( host ) ) \n \n <ect>
\t5 ( ( <number_literal> > firstVersionMaxSegment ) ? firstVersionMaxSegment : 3L ) , outputHandle . getDefaultPublisher ( ) , inputHandle ) ; \n \n \t2 CCNVersionedInputStream vlatest = new CCNVersionedInputStream ( defaultStreamName , \n \n \t4 ( ( <number_literal> > latestVersionMaxSegment ) ? latestVersionMaxSegment : 3L ) , outputHandle . getDefaultPublisher ( ) , inputHandle ) ; \n \n \t2 testArgumentRunner ( vfirst , vlatest ) ; \n \n <ect>
\t2 blob = new ByteArrayOutputStream ( n ) ; } \n \n \t2 blob . write ( buf , 0 , n ) ; \n \n \t2 blobLength += n ; \n \n \t2 if ( blobLength >= maxBlobLength ) { \n \n <ect>
\t2 r . nextBytes ( bytes ) ; \n \n \t2 m . put ( column_fam , new Text ( <string_literal> + column ) , new Value ( bytes ) ) ; } \n \n \t1 mutations_so_far ++ ; \n \n \t1 if ( mutations_so_far % <number_literal> == 0 ) { \n \n <ect>
\t1 <comment> \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 delegateInMemory = newDelegateInMemory ; \n \n \t1 } catch ( TasteException te ) { \n \n <ect>
\t3 scheduledWorkRequest . start ( ) ; \n \n \t3 try { \n \n \t4 scheduledWorkRequest . join ( ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t2 assert exec != null ; \n \n \t2 assert ggHome != null ; \n \n \t2 assert ggName != null ; \n \n \t2 assert springCtx != null ; \n \n <ect>
\t4 long timeDiff = - System . currentTimeMillis ( ) ; \n \n \t4 Runtime runtime = Runtime . getRuntime ( ) ; \n \n \t4 long memDiff = - ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) ; \n \n \t4 if ( texturePack == null ) { \n \n <ect>
\t2 if ( colon != - 1 ) { \n \n \t3 String blobId = reference . substring ( 0 , colon ) ; \n \n \t3 if ( reference . equals ( getReference ( blobId ) ) ) { \n \n \t4 return blobId ; } \n \n <ect>
\t3 <comment> \n \n \t3 serviceActionController . execute ( currentContext , postActivityAction ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t6 } else { \n \n \t7 logger . debug ( <string_literal> , r . uuid ( ) ) ; } \n \n \t6 AtmosphereResourceImpl . class . cast ( dup ) . dirtyClose ( ) ; \n \n \t5 } else { \n \n <ect>
\t2 try { \n \n \t3 zipInputStream = new ZipInputStream ( new FileInputStream ( zipFileName ) ) ; \n \n \t3 ZipEntry zipEntry = null ; \n \n \t3 while ( ( zipEntry = zipInputStream . getNextEntry ( ) ) != null ) { \n \n <ect>
\t1 public void closeConnection ( ) { \n \n \t2 this . writeTarget . get ( ) . closeConnection ( ) ; } \n \n \t1 @ Override \n \n \t1 protected void timeoutOccurred ( ) { \n \n <ect>
\t6 <comment> \n \n \t6 if ( className . startsWith ( <string_literal> ) ) { \n \n \t7 logger . warn ( <string_literal> + clazz . getName ( ) , t ) ; } } } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 _zk . exists ( path , this , this , false ) ; \n \n \t2 if ( init ) \n \n \t2 { \n \n \t3 _eventBus . publishInitialize ( property , null ) ; \n \n <ect>
\t2 } else if ( this . storage == Storage . SESSION ) { \n \n \t3 localeHandler = new SessionLocaleHandler ( invocation ) ; \n \n \t2 } else { \n \n \t3 localeHandler = new RequestOnlyLocaleHandler ( invocation ) ; } \n \n <ect>
\t1 public void testGetFeatureValid ( ) { \n \n \t2 String path = <string_literal> ; \n \n \t2 String newline = System . getProperty ( <string_literal> ) ; \n \n \t2 Document doc = getAsDOM ( path ) ; \n \n <ect>
\t1 public static void refreshAuthenticatedUser ( ) { \n \n \t2 if ( Daemon . isDaemonThread ( ) ) { \n \n \t3 return ; } \n \n <ect>
\t5 Item item = res . addItem ( group ) ; \n \n \t5 item . getItemProperty ( caption ) . setValue ( group . getSimpleName ( ) ) ; \n \n \t5 item . getItemProperty ( idOu ) . setValue ( group . getOuFqn ( ) ) ; } } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t1 } else { \n \n \t1 registry = new LlapRegistryService ( false ) ; \n \n \t1 registry . init ( conf ) ; \n \n \t1 registry . start ( ) ; } \n \n <ect>
<comment> \n \n \t1 protected void updateItemValues ( TinkerforgeBindingProvider provider , String itemName , boolean only_poll_enabled ) { \n \n \t2 if ( tinkerforgeEcosystem == null ) { \n \n <ect>
\t4 latch2 . await ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t4 locked . set ( true ) ; } \n \n \t3 catch ( InterruptedException e1 ) { \n \n \t4 Thread . currentThread ( ) . interrupt ( ) ; \n \n <ect>
\t5 . to ( routeboxUri ) \t5 \n \n \t5 . to ( <string_literal> ) ; } \n \n \t2 } ) ; \n \n \t2 context . start ( ) ; \n \n <ect>
\t3 log . error ( <string_literal> + sig ) ; \n \n \t3 return false ; } \n \n \t2 SigType type = SigType . parseSigType ( ss [ 0 ] ) ; \n \n \t2 if ( type == null ) { \n \n <ect>
\t3 return new Formula ( setId , setExpr ) ; } } \n \n \t1 static class TransformToFormulasVisitor extends MdxVisitorImpl { \n \n \t2 private final Query query ; \n \n \t2 public TransformToFormulasVisitor ( Query query ) { \n \n <ect>
\t2 String onefile = realFile ( one , conf ) ; \n \n \t2 if ( onefile != null ) { \n \n \t3 realFiles . add ( realFile ( one , conf ) ) ; \n \n \t2 } else { \n \n <ect>
\t3 String aliasPath = alias . getAliasPath ( ) ; \n \n \t3 if ( CmsAlias . ALIAS_PATTERN . matcher ( aliasPath ) . matches ( ) ) { \n \n \t4 vfsDriver . insertAlias ( dbc , project , alias ) ; \n \n \t3 } else { \n \n <ect>
\t3 ( ( DataTypeAware ) ex . getIn ( ) ) . setBody ( orderXml , new DataType ( <string_literal> ) ) ; \n \n \t2 } ) ; \n \n \t2 Thread . sleep ( <number_literal> ) ; \n \n \t2 LOG . info ( <string_literal> , answerXml . getOut ( ) . getBody ( String . class ) ) ; \n \n <ect>
\t2 resetMock ( count ) ; \n \n \t2 StopWatch watch = new StopWatch ( ) ; \n \n \t2 execute ( count ) ; \n \n \t2 assertMockEndpointsSatisfied ( ) ; \n \n <ect>
\t3 s_logger . trace ( <string_literal> + _gson . toJson ( answer ) ) ; } \n \n \t2 return answer ; } \n \n \t1 protected Answer execute ( CheckHealthCommand cmd ) { \n \n <ect>
\t2 public void connectionOpen ( final NHttpConnection conn ) { \n \n \t3 logger . info ( <string_literal> + conn . getContext ( ) . getAttribute ( ExecutionContext . HTTP_TARGET_HOST ) <comment> \n \n \t3 ) ; } \n \n \t2 public void connectionTimeout ( final NHttpConnection conn ) { \n \n <ect>
\t7 failedUnregistered . remove ( url ) ; \n \n \t6 } catch ( Throwable t ) { <comment> \n \n \t7 logger . warn ( <string_literal> + failed + <string_literal> + t . getMessage ( ) , t ) ; } } \n \n \t4 } catch ( Throwable t ) { <comment> \n \n <ect>
\t4 } ) ; } } \n \n \t2 if ( ! connectors . isEmpty ( ) ) { \n \n \t3 server . setConnectors ( connectors . toArray ( new Connector [ 0 ] ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 Item item = Item . getByNameOrId ( args [ 0 ] . trim ( ) ) ; \n \n \t2 if ( item != null ) { \n \n \t3 stack = new ItemStack ( item ) ; \n \n \t2 } else { \n \n <ect>
\t5 <comment> \n \n \t5 <comment> \n \n \t5 sentMsgs . remove ( msgId ) ; } \n \n \t4 catch ( GridException e ) { \n \n <ect>
\t3 param = cmd . equals ( OnOffType . ON ) ? <string_literal> : <string_literal> ; \n \n \t2 } else if ( command instanceof DecimalType ) { \n \n \t3 param = ( ( DecimalType ) command ) . toString ( ) ; \n \n \t2 } else { \n \n <ect>
\t2 if ( dbConnection != null ) { \n \n \t3 try { \n \n \t4 this . dbConnection . rollback ( ) ; \n \n \t3 } catch ( SQLException se ) { \n \n <ect>
\t1 protected void doDeleteConfigMap ( Exchange exchange , String operation ) throws Exception { \n \n \t2 String configMapName = exchange . getIn ( ) . getHeader ( KubernetesConstants . KUBERNETES_CONFIGMAP_NAME , String . class ) ; \n \n \t2 String namespaceName = exchange . getIn ( ) . getHeader ( KubernetesConstants . KUBERNETES_NAMESPACE_NAME , String . class ) ; \n \n \t2 if ( ObjectHelper . isEmpty ( configMapName ) ) { \n \n <ect>
\t2 { \n \n \t3 s_logger . info ( <string_literal> + this . command ) ; } \n \n \t2 if ( this . getCommandType ( ) == CommandType . SCRIPT ) { \n \n \t3 try { \n \n <ect>
\t4 public Void call ( ) { \n \n \t5 try { \n \n \t6 LOGGER . info ( <string_literal> ) ; \n \n \t6 final Properties call = getGit ( ) . gc ( ) . call ( ) ; \n \n <ect>
\t4 sb . append ( <string_literal> ) ; } \n \n \t3 String body = sb . toString ( ) ; \n \n \t3 ResteasyClient client = new ResteasyClientBuilder ( ) . httpEngine ( executor ) . build ( ) ; \n \n \t3 Response response = client . target ( generateURL ( <string_literal> ) ) . request ( ) . header ( <string_literal> , <string_literal> ) . post ( Entity . text ( body ) ) ; \n \n <ect>
\t2 if ( sMaxVideoBitrate != null ) { \n \n \t3 try { \n \n \t4 iMaxVideoBitrate = Integer . parseInt ( sMaxVideoBitrate ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t1 public static void initialize ( Configuration jConf ) throws IOException { \n \n \t2 initialize ( jConf , Utils . isLocal ( jConf ) ) ; } \n \n \t1 public static void initialize ( Configuration jConf , boolean isLocal ) throws IOException { \n \n \t2 if ( stb != null ) { \n \n <ect>
\t2 try { \n \n \t3 if ( ! ipmiPing ( ) ) { \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n \t4 if ( ! ipmiPing ( ) ) { \n \n <ect>
\t2 } catch ( ManagementServerException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . INTERNAL_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( VirtualMachineMigrationException ex ) { \n \n <ect>
\t2 for ( KerberosTicket ticket : tickets ) { \n \n \t3 KerberosPrincipal server = ticket . getServer ( ) ; \n \n \t3 if ( server . getName ( ) . equals ( <string_literal> + server . getRealm ( ) + <string_literal> + server . getRealm ( ) ) ) { \n \n \t4 LOG . debug ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \n <ect>
\t1 if ( valueClass . equals ( ClusterWritable . class ) ) { \n \n \t2 ClusterWritable clusterWritable = ( ClusterWritable ) value ; \n \n \t2 value = clusterWritable . getValue ( ) ; \n \n \t2 valueClass = value . getClass ( ) ; } \n \n <ect>
\t3 final Date requestSent , \n \n \t3 final Date responseReceived , \n \n \t3 final FutureCallback < HttpCacheEntry > callback ) { \n \n <ect>
\t4 acs . setLocation ( authnRequest . getAssertionConsumerServiceURL ( ) ) ; \n \n \t4 acs . setResponseLocation ( authnRequest . getAssertionConsumerServiceURL ( ) ) ; \n \n \t4 acs . setIndex ( 0 ) ; \n \n \t4 acs . setIsDefault ( Boolean . TRUE ) ; } \n \n <ect>
\t3 try { \n \n \t3 stopIfNeeded ( configuration ) ; \n \n \t3 } catch ( Exception ex ) { \n \n \t3 <comment> \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public long getAcquireRetryDelay ( ) { \n \n <ect>
\t2 SchemaTupleFactory [ ] keySchemaTupleFactories = new SchemaTupleFactory [ inputSchemas . length ] ; \n \n \t2 for ( int i = 0 ; i < inputSchemas . length ; i ++ ) { \n \n \t3 Schema schema = inputSchemas [ i ] ; \n \n \t3 if ( schema != null ) { \n \n <ect>
\t1 cmdReport = createCommandReport ( result . getExitCode ( ) , result . isSuccessful ( ) ? \n \n \t2 HostRoleStatus . COMPLETED : HostRoleStatus . FAILED , <string_literal> , result . getStdout ( ) , result . getStderr ( ) ) ; \n \n \t1 LOGGER . debug ( <string_literal> , cmdReport ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t5 s_logger . info ( <string_literal> ) ; \n \n \t5 client = new HttpClient ( ) ; \n \n \t5 method = new GetMethod ( url ) ; \n \n \t5 responseCode = client . executeMethod ( method ) ; \n \n <ect>
\t7 LOGGER . info ( cryptoGroup . concat ( <string_literal> + EncodingUtils . generateJsonWebKey ( crypto . getSigning ( ) . getKeySize ( ) ) ) ) ; \n \n \t6 } else if ( obj instanceof EncryptionRandomizedSigningJwtCryptographyProperties ) { \n \n \t7 final EncryptionRandomizedSigningJwtCryptographyProperties crypto = ( EncryptionRandomizedSigningJwtCryptographyProperties ) obj ; \n \n \t7 final String encKey = new Base64RandomStringGenerator ( crypto . getEncryption ( ) . getKeySize ( ) ) . getNewString ( ) ; \n \n <ect>
\t2 buf . put ( ( byte ) config . getEndByte1 ( ) ) ; \n \n \t2 buf . put ( ( byte ) config . getEndByte2 ( ) ) ; \n \n \t2 <comment> \n \n \t2 buf . flip ( ) ; \n \n <ect>
\t4 Integer pid = ProcessUtil . getProcessID ( process ) ; \n \n \t4 if ( pid != null ) { \n \n \t5 LOGGER . debug ( <string_literal> + pid + <string_literal> + this ) ; \n \n \t4 } else { \n \n <ect>
\t2 DatagramPacket pkt = packet . getPacket ( ) ; \n \n \t2 byte data [ ] = pkt . getData ( ) ; \n \n \t2 int off = HEADER_SIZE ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 public void testSendWithClientWriteTimeout ( ) throws Exception { \n \n \t2 final ActiveMQQueue dest = new ActiveMQQueue ( <string_literal> ) ; \n \n \t2 messageTextPrefix = initMessagePrefix ( <number_literal> * <number_literal> ) ; \n \n \t2 URI tcpBrokerUri = URISupport . removeQuery ( broker . getTransportConnectors ( ) . get ( 0 ) . getConnectUri ( ) ) ; \n \n <ect>
\t1 Host host = m_hosts . get ( hostId ) ; \n \n \t1 if ( null == host ) { \n \n \t2 return ; } \n \n \t1 String hostName = host . getHostName ( ) ; \n \n <ect>
\t1 } catch ( Throwable t ) { \n \n \t2 LOG . error ( <string_literal> , t ) ; } \n \n \t2 LOG . debug ( <string_literal> + metricsList . size ( ) ) ; \n \n <ect>
\t1 response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; } \n \n \t1 LOG . info ( <string_literal> + file . getAbsolutePath ( ) + <string_literal> ) ; } \n \n private void handleError ( File [ ] files ) { \n \n \t1 if ( ArrayUtils . isEmpty ( files ) ) { \n \n <ect>
\t4 obj . put ( <string_literal> , outGeomWKT ) ; \n \n \t4 obj . put ( <string_literal> , <number_literal> ) ; \n \n \t4 arr . put ( obj ) ; } \n \n \t2 } catch ( JSONException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void activate ( ) { \n \n \t2 super . activate ( ) ; \n \n \t2 setProperlyConfigured ( true ) ; \n \n <ect>
\t2 Preconditions . checkArgument ( this . restoredBucketStates == null , <string_literal> ) ; \n \n \t2 try { \n \n \t3 initFileSystem ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 rootDiskTO = vol ; \n \n \t5 deviceConfigSpecArray [ i ] . setDevice ( device ) ; \n \n \t5 deviceConfigSpecArray [ i ] . setOperation ( VirtualDeviceConfigSpecOperation . ADD ) ; \n \n <ect>
\t4 LOG . info ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 jmsConn . stop ( ) ; \n \n \t4 } catch ( javax . jms . JMSException jms_exc ) { \n \n <ect>
\t3 throw new CircuitBreakerOpenException ( message , <string_literal> + target ) ; } \n \n \t2 try { \n \n \t3 Object result = callback . execute ( ) ; \n \n <ect>
\t1 self . keytab_name = <string_literal> \n \n def get_component_name ( self ) : \n \n \t1 return <string_literal> \n \n def pre_upgrade_restart ( self , env , upgrade_type = None ) : \n \n <ect>
\t2 testArgumentRunner ( vfirst , vlatest ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testCCNVersionedInputStreamContentObjectCCNLibrary ( ) throws Exception { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t2 resource . start ( tid , XAResource . TMNOFLAGS ) ; \n \n \t2 ( ( TransactionContext ) resource ) . addSynchronization ( new Synchronization ( ) { \n \n \t3 @ Override \n \n \t3 public void beforeEnd ( ) throws Exception { \n \n <ect>
\t4 final Properties props = new Properties ( ) ; \n \n \t4 try ( final FileInputStream finputstream = new FileInputStream ( propsFile ) ; ) { \n \n \t5 props . load ( finputstream ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 Map < String , Logger > availableLoggers = getCamelContext ( ) . getRegistry ( ) . findByTypeWithName ( Logger . class ) ; \n \n \t3 if ( availableLoggers . size ( ) == 1 ) { \n \n \t4 providedLogger = availableLoggers . values ( ) . iterator ( ) . next ( ) ; \n \n <ect>
\t4 <comment> \n \n \t4 if ( ( ipAddressValues != null ) && ! ipAddressValues . isEmpty ( ) ) { \n \n \t5 s_windowsIpId . set ( ipAddressValues . get ( 0 ) ) ; \n \n \t5 s_windowsIP . set ( ipAddressValues . get ( 1 ) ) ; \n \n <ect>
\t2 if ( ! filePath . exists ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , filePath . getCanonicalPath ( ) ) ; \n \n \t3 final boolean created = filePath . createNewFile ( ) ; \n \n \t3 if ( created ) { \n \n <ect>
\t3 writer . write ( xstream . toXML ( log ) + <string_literal> ) ; \n \n \t2 } catch ( final FileNotFoundException exc ) { \n \n \t3 throw new RuntimeException ( <string_literal> ) ; \n \n \t2 } catch ( final Throwable t ) { \n \n <ect>
\t3 cfg . setLocalAddress ( InetAddress . getByName ( dynamoDbProperties . getLocalAddress ( ) ) ) ; } \n \n \t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 final AmazonDynamoDBClient client = new AmazonDynamoDBClient ( provider , cfg ) ; \n \n \t2 if ( StringUtils . isNotBlank ( dynamoDbProperties . getEndpoint ( ) ) ) { \n \n <ect>
\t7 <string_literal> , \n \n \t7 new String [ ] { e . getMessage ( ) } ) ) ; } } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n <ect>
\t6 <comment> \n \n \t6 try { \n \n \t7 emHolder . getEntityManager ( ) . joinTransaction ( ) ; } \n \n \t6 catch ( TransactionRequiredException ex ) { \n \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \n \t3 assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <string_literal> ) . setWaitForNoRelocatingShards ( true ) ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 allowNodes ( <string_literal> , 1 ) ; \n \n <ect>
\t1 else \n \n \t1 { \n \n \t2 config . addResourceClassNames ( classFileNames . keySet ( ) ) ; \n \n \t2 sourceFileNames = classFileNames . values ( ) ; } } \n \n <ect>
\t2 keys . add ( <string_literal> ) ; \n \n \t2 uniqueKeys . put ( <string_literal> , keys ) ; \n \n \t2 uniqueKeys . put ( <string_literal> , keys ) ; \n \n \t2 <comment> \n \n <ect>
\t4 . uniqueResult ( ) ; \n \n \t2 logger . info ( <string_literal> + propertyName ) ; \n \n \t2 Entities . delete ( property ) ; \n \n \t2 } catch ( NoSuchElementException e ) { \n \n <ect>
\t5 fileLocation = <string_literal> + urlPrefix + fileName ; } \n \n \t4 InputStream in = null ; \n \n \t4 if ( ! GrailsStringUtils . isBlank ( url ) ) { \n \n \t5 in = servletContext . getResourceAsStream ( url ) ; \n \n <ect>
\t2 } catch ( final CloudRuntimeException e ) { \n \n \t3 s_logger . error ( <string_literal> + vmSpec . getName ( ) + <string_literal> + e . toString ( ) , e ) ; \n \n \t3 return new MigrateWithStorageReceiveAnswer ( command , e ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t1 try { \n \n \t1 delete . apply ( instanceId ) ; \n \n \t1 } catch ( Exception ex ) { \n \n \t1 if ( PersistenceExceptions . classify ( ex ) == PersistenceExceptions . ErrorCategory . CONSTRAINT ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , DEFAULT_PAGE_SIZE < < DEFAULT_MAX_ORDER ) ; \n \n \t3 logger . debug ( <string_literal> , DEFAULT_TINY_CACHE_SIZE ) ; \n \n \t3 logger . debug ( <string_literal> , DEFAULT_SMALL_CACHE_SIZE ) ; \n \n \t3 logger . debug ( <string_literal> , DEFAULT_NORMAL_CACHE_SIZE ) ; \n \n <ect>
<comment> \n \n \t1 private String expandLHS ( final String lhs , \n \n \t7 int lineOffset ) { \n \n \t2 substitutions = new ArrayList < Map < String , String > > ( ) ; \n \n <ect>
\t9 s_logger . info ( <string_literal> + username + <string_literal> + ( ( System . currentTimeMillis ( ) - now ) / 1000L ) + <string_literal> ) ; \n \n \t8 } else { \n \n \t9 s_logger . info ( <string_literal> + username + <string_literal> + ( ( System . currentTimeMillis ( ) - now ) / 1000L ) + <string_literal> + reason ) ; } \n \n \t7 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( StorageUnavailableException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . RESOURCE_UNAVAILABLE_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ExecutionException ex ) { \n \n <ect>
\t2 for ( final VariantContext vc : reader . getSecond ( ) ) { \n \n \t3 if ( vc == null ) continue ; \n \n \t3 while ( pos < vc . getStart ( ) ) { \n \n \t4 final GenomeLoc loc = genomeLocParser . createGenomeLoc ( contig , pos ) ; \n \n <ect>
\t4 for ( int i = 0 ; i < numberOfThreads ; i ++ ) { \n \n \t5 m_threadStarter . startThread ( null ) ; } } \n \n \t3 threadSynchronisation . startThreads ( ) ; \n \n \t3 m_times . setExecutionStartTime ( ) ; \n \n <ect>
\t4 final SearchResult next = search . next ( ) ; \n \n \t4 String loginUser = next . getNameInNamespace ( ) ; \n \n \t4 if ( search . hasMore ( ) ) \n \n \t4 { \n \n <ect>
\t1 @ Test \n \n \t1 public final void testGetMaxFileDescriptorCount ( ) { \n \n \t2 if ( osMbean != null && osMbean . getUnix ( ) == true ) { \n \n \t3 mfdc = osMbean . getMaxFileDescriptorCount ( ) ; \n \n <ect>
\t2 externalHostConfigPresent = true ; \n \n \t2 setInstanceId = true ; } \n \n \t2 String metricsCollectorExternalPort = configs . get ( <string_literal> ) ; \n \n \t2 if ( StringUtils . isNotEmpty ( metricsCollectorExternalPort ) ) { \n \n <ect>
\t3 try { \n \n \t4 MBeanRegistry . getInstance ( ) . register ( jmxConnectionBean , zkServer . jmxServerBean ) ; \n \n \t4 connectionBeans . put ( serverCnxn , jmxConnectionBean ) ; \n \n \t3 } catch ( JMException e ) { \n \n <ect>
\t2 for ( ; pos < = condition . getMetricNames ( ) . size ( ) ; pos ++ ) { \n \n \t2 stmt . setString ( pos , condition . getMetricNames ( ) . get ( pos - 1 ) ) ; } } \n \n \t1 if ( condition . getAppId ( ) != null ) { \n \n <ect>
\t3 if ( uuid2Host . isEmpty ( ) ) { \n \n \t4 log . warn ( <string_literal> , job ) ; } \n \n \t3 IJob ijob = getJob ( job ) ; \n \n \t3 if ( ijob == null ) { \n \n <ect>
\t3 for ( final ResourceAccess access : app . nodeQuery ( ResourceAccess . class ) . getAsList ( ) ) { \n \n \t4 app . delete ( access ) ; } \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
def matrix_snapshot ( ) : \n \n \t1 <string_literal> <string_literal> <string_literal> \n \n <ect>
\t3 buildUpdateMap ( ) ; \n \n \t3 itemHasChanged = true ; \n \n \t2 } else { \n \n \t3 setPanelMessage ( <string_literal> ) ; \n \n <ect>
\t4 if ( ! StringUtils . isBlank ( type . getUserType ( ) ) ) { \n \n \t5 log . warn ( <string_literal> + type ) ; \n \n \t5 type . setUserType ( null ) ; } \n \n \t4 if ( ! StringUtils . isBlank ( type . getBinding ( ) ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t4 pstmt . setLong ( 1 , mapId ) ; \n \n \t4 pstmt . executeUpdate ( ) ; \n \n <ect>
<comment> \n \n \t2 try { \n \n \t3 jndiContext = new InitialContext ( ) ; \n \n \t2 } catch ( NamingException e ) { \n \n <ect>
\t4 } catch ( Exception e ) { \n \n \t5 throw new IllegalArgumentException ( <string_literal> + customFactory , \n \n \t7 e ) ; } } \n \n \t2 } catch ( KylinConfigCannotInitException e ) { \n \n <ect>
\t3 Class < ? extends Item > itemType = provider . getItemType ( item ) ; \n \n \t3 String service = checkParameterReplacement ( provider , item ) ; \n \n \t3 logger . debug ( <string_literal> , service , type , itemType . getName ( ) ) ; \n \n \t3 if ( device . blacklistMap . contains ( service ) ) { \n \n <ect>
\t4 public void handleTemplateException ( TemplateException te , Environment env , Writer out ) throws TemplateException { \n \n \t5 te . printStackTrace ( ) ; } \n \n \t3 } ) ; \n \n \t2 } catch ( TemplateException templateException ) { \n \n <ect>
\t1 Transactions . find ( new ObjectInfo ( bucketName , objectKey ) ) ; \n \n \t1 } catch ( NoSuchElementException e ) { \n \n \t1 throw new NoSuchEntityException ( objectKey ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 { \n \n \t2 <comment> \n \n \t2 if ( ! ( exception instanceof EOGeneralAdaptorException ) ) \n \n \t2 { \n \n <ect>
\t1 public Network design ( NetworkOffering offering , DeploymentPlan plan , Network userSpecified , Account owner ) { \n \n \t2 <comment> \n \n \t2 PhysicalNetworkVO physnet = _physicalNetworkDao . findById ( plan . getPhysicalNetworkId ( ) ) ; \n \n \t2 if ( physnet == null || physnet . getIsolationMethods ( ) == null || ! physnet . getIsolationMethods ( ) . contains ( <string_literal> ) ) { \n \n <ect>
\t3 rdfGen . generateRDF ( true ) ; \n \n \t3 logger . debug ( <string_literal> , sourceName ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void treeNodesInserted ( TreeModelEvent tme ) { \n \n \t2 String name = ( ( JMeterTreeNode ) tme . getTreePath ( ) . getLastPathComponent ( ) ) . getName ( ) ; \n \n <ect>
\t1 final FileSystem srcFs , destFs ; \n \n \t1 try { \n \n \t1 destFs = destf . getFileSystem ( conf ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 private boolean checkSelfNamed ( String iname ) { \n \n \t2 try { \n \n \t3 if ( ! checkSelfNamed ( Class . forName ( iname , true , loader ) ) ) { \n \n <ect>
\t5 if ( greaterOrEqual ( t , upperBound ) ) { \n \n \t6 return false ; } } } \n \n \t3 return true ; } \n \n \t2 catch ( RepositoryException e ) { \n \n <ect>
\t3 remoteChange . addRemoteCacheChange ( change ) ; } \n \n \t2 else if ( messageType == ERXRemoteSynchronizer . DELETE ) { \n \n \t3 EOGlobalID gid = readGID ( dis ) ; \n \n \t3 ERXDatabase . SnapshotDeleted change = new ERXDatabase . SnapshotDeleted ( gid , NSDictionary . EmptyDictionary ) ; \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( this . type == ResultSet . TYPE_SCROLL_INSENSITIVE && needsCommit ) { \n \n <ect>
\t2 } else { \n \n \t3 log . info ( <string_literal> ) ; } \n \n \t2 log . info ( <string_literal> + DEFAULT_ENCODING ) ; \n \n \t2 log . info ( <string_literal> + USE_NANO_TIME ) ; \n \n <ect>
\t2 Webhook webhookRequest = new Webhook ( ) ; \n \n \t2 String uuid = UUID . randomUUID ( ) . toString ( ) ; \n \n \t2 webhookRequest . setUrl ( WebhooksInputData . WEBHOOK_URL + uuid ) ; \n \n \t2 webhookRequest . setEventTypes ( EventTypeListTestCase . createAuthEventTypeList ( ) ) ; \n \n <ect>
\t1 public Optional < InputStream > getInputStream ( ) { \n \n \t2 try { \n \n \t3 return optional ( new XZInputStream ( new BufferedInputStream ( new FileInputStream ( file ) ) ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 this . setResponseObject ( response ) ; \n \n \t3 } else { \n \n \t4 throw new ServerApiException ( BaseCmd . INTERNAL_ERROR , <string_literal> ) ; } \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
<comment> \n \n \t1 private void runTests ( boolean multi , String tcParams , String clusterFilter , String destinationFilter ) throws Exception , InterruptedException { \n \n \t2 assertClientsConnectedToThreeBrokers ( ) ; \n \n <ect>
\t3 logger . error ( <string_literal> ) ; \n \n \t3 stopRPCServer ( ) ; } \n \n \t2 if ( isNativeTransportRunning ( ) ) \n \n \t2 { \n \n <ect>
\t2 if ( TodoList . selectedTasks . isNotEmpty ( ) ) return Mode . SELECTION \n \n \t2 return Mode . MAIN } \n \n \t1 private fun isDrawerOpen ( drawer : Int ) : Boolean { \n \n \t2 if ( drawer_layout == null ) { \n \n <ect>
\t3 WikiPropertyGroupProvider provider = propertyGroupProviders . get ( propertyGroupName ) ; \n \n \t3 try { \n \n \t4 descriptor . addPropertyGroup ( provider . get ( wikiId ) ) ; \n \n \t3 } catch ( WikiPropertyGroupException e ) { \n \n <ect>
\t3 if ( m_startfolder . getValue ( ) . length ( ) < = ( ( String ) m_site . getValue ( ) ) . length ( ) ) { \n \n \t4 return false ; } \n \n \t3 return cmsLocal . existsResource ( m_startfolder . getValue ( ) . substring ( ( ( String ) m_site . getValue ( ) ) . length ( ) ) ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t3 ServerInfo serverInfo = getServerInfo ( sockJsUrlInfo , getHttpRequestHeaders ( headers ) ) ; \n \n \t3 createRequest ( sockJsUrlInfo , headers , serverInfo ) . connect ( handler , connectFuture ) ; } \n \n \t2 catch ( Throwable exception ) { \n \n \t3 if ( logger . isErrorEnabled ( ) ) { \n \n <ect>
\t5 return false ; } } \n \n \t2 } finally { \n \n \t3 try { \n \n \t4 _networkMgr . release ( profile , cleanUpEvenIfUnableToStop ) ; \n \n <ect>
\t3 return ( File ) method . invoke ( content ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n \t3 LOG . error ( <string_literal> , content . getClass ( ) . getSimpleName ( ) , e ) ; \n \n \t2 } catch ( InvocationTargetException e ) { \n \n <ect>
\t1 System . setOut ( outPrintStream ) ; \n \n \t1 <comment> \n \n \t1 schemaTool . doUpgrade ( <string_literal> ) ; \n \n \t1 LOG . info ( <string_literal> + stdout . toString ( ) ) ; \n \n <ect>
\t5 fireProducerEvent ( new ProducerStoppedEvent ( this , destination , ( ProducerId ) removeInfo . getObjectId ( ) , count ) ) ; } \n \n \t3 } else { \n \n \t4 LOG . warn ( <string_literal> + command ) ; } \n \n \t2 } else { \n \n <ect>
\t3 Map < String , UpdateOp > updates = newHashMap ( ) ; \n \n \t3 for ( Map . Entry < String , UpdateOp > entry : batch ) { \n \n \t4 updates . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } \n \n \t3 listener . sweepUpdate ( updates ) ; } \n \n <ect>
\t2 command . add ( <string_literal> , templateFileFullPath ) ; \n \n \t2 command . setWorkDir ( templateFile . getParent ( ) ) ; \n \n \t2 String result = command . execute ( ) ; \n \n \t2 if ( result != null ) { \n \n <ect>
\t2 <comment> \n \n \t2 @ Override public void sendMessage ( GridNode node , GridTcpCommunicationMessageAdapter msg ) throws GridSpiException { \n \n \t3 if ( isTxFinish ( msg ) ) { \n \n <ect>
\t1 private void handleAsRedirect ( String uri , HttpServletRequest request , HttpServletResponse response ) throws IOException { \n \n \t2 if ( uri . startsWith ( <string_literal> ) ) { \n \n \t3 uri = request . getContextPath ( ) + uri ; } \n \n <ect>
\t2 if ( symLink . exists ( ) ) { \n \n \t3 try { \n \n \t4 if ( symLink . getCanonicalFile ( ) . equals ( file . getCanonicalFile ( ) ) ) { \n \n \t5 <comment> \n \n <ect>
\t3 remoteEof ( key ) ; \n \n \t3 return ; } } \n \n \t1 private void remoteEof ( SelectionKey key ) { \n \n \t2 <comment> \n \n <ect>
\t3 ensureRouteMethod = contextClazz . getDeclaredMethod ( <string_literal> , String . class ) ; \n \n \t2 } catch ( SecurityException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t4 description . getTestClass ( ) . getSimpleName ( ) , description . getMethodName ( ) , TestUtils . USE_NIO \n \n \t3 ) ; } \n \n \t2 @ Override \n \n \t2 protected void finished ( Description description ) { \n \n <ect>
\t5 logger . debug ( <string_literal> , bindUri ) ; \n \n \t4 } catch ( InstantiationException | IllegalAccessException e ) { \n \n \t5 logger . error ( <string_literal> { } \\ <string_literal> , e ) ; } \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 protected static List < String > getSupportedNameIdFormats ( final SamlRegisteredService service , \n \n <number_literal> final SamlRegisteredServiceServiceProviderMetadataFacade adaptor ) { \n \n \t2 final List < String > supportedNameFormats = adaptor . getSupportedNameIdFormats ( ) ; \n \n <ect>
\t2 LOG . warn ( <string_literal> ) ; \n \n \t2 } else if ( ex instanceof CancellationException ) { \n \n \t2 LOG . warn ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t3 try { \n \n \t4 response . sendRedirect ( oauthServer . getEndUserAuthorizationRequestUri ( request ) ) ; \n \n \t4 return null ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 firstReceipt = duration ; \n \n \t4 firstReceiptLatch . countDown ( ) ; \n \n \t4 LOG . info ( <string_literal> + firstReceipt + <string_literal> ) ; \n \n \t3 } else if ( count . get ( ) % batchSize == 0 ) { \n \n <ect>
\t3 document = builder . parse ( is ) ; \n \n \t2 } catch ( SAXException e ) { \n \n \t3 logger . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 _commandSetupHelper . createVpcAssociatePublicIPCommands ( domainRouterVO , publicIps , cmds , vlanMacAddress ) ; } } } \n \n \t1 @ Override \n \n \t1 public boolean startSite2SiteVpn ( final Site2SiteVpnConnection conn , final VirtualRouter router ) throws ResourceUnavailableException { \n \n \t2 if ( router . getState ( ) != State . Running ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 try ( Reader reader = new InputStreamReader ( streamIn , StandardCharsets . UTF_8 ) ) { \n \n \t4 properties . load ( reader ) ; \n \n \t4 reader . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 descriptions . addAll ( ( ( NoMoreItems ) receive ) . getColumns ( ) ) ; } \n \n \t1 endReached = true ; } \n \n \t1 if ( receive instanceof FetchFailed ) { \n \n \t1 FetchFailed error = ( FetchFailed ) receive ; \n \n <ect>
\t1 @ Override \n \n \t1 public void processResult ( int rc , String path , Object ctx , Stat stat ) \n \n \t1 { \n \n \t1 KeeperException . Code code = KeeperException . Code . get ( rc ) ; \n \n <ect>
\t3 <comment> \n \n \t3 pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 rs = pstmt . executeQuery ( ) ; \n \n \t3 if ( ! rs . next ( ) ) { \n \n <ect>
\t5 orderedProviders . addAll ( result . get ( updated . value ( ) ) ) ; } \n \n \t4 orderedProviders . add ( provider ) ; \n \n \t4 producer = provider ; } } \n \n \t2 if ( producer == null ) { \n \n <ect>
\t2 assertEquals ( <number_literal> , entitySetWithTop . getEntities ( ) . size ( ) ) ; \n \n \t2 LOG . info ( <string_literal> , entitySet . getEntities ( ) ) ; \n \n \t2 clientEntity = ( ClientEntity ) responseParts . get ( <number_literal> ) . getBody ( ) ; \n \n \t2 assertNotNull ( clientEntity ) ; \n \n <ect>
\t5 Thread . sleep ( 25000L ) ; <comment> \n \n \t4 logger . trace ( <string_literal> ) ; \n \n \t4 client . disconnect ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 . setRouting ( routing ) \n \n \t4 . setIndices ( index ) \n \n \t4 . setSize ( <number_literal> ) \n \n \t4 . execute ( ) . actionGet ( ) ; \n \n <ect>
\t4 <comment> \n \n \t4 log . error ( <string_literal> ) ; \n \n \t4 _machineIpList = new NSArray < > ( new String [ ] { LOCAL_IP_ADDRESS } ) ; } \n \n <ect>
\t1 vectorOp = OperatorFactory . getVectorOperator ( \n \n \t2 opClass , op . getCompilationOpContext ( ) , op . getConf ( ) , \n \n \t2 vContext , vectorDesc ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
: return : Returns the path to the absolute backup directory . \n \n <string_literal> <string_literal> <ect>
\t4 LifecycleMojo mojo = mojos . get ( i ) ; \n \n \t4 GoalSpec gs = parseGoalSpec ( mojo . getGoal ( ) ) ; \n \n \t4 if ( gs == null ) \n \n \t4 { \n \n <ect>
<comment> \n \n \t5 if ( v . getId ( ) == i ) { \n \n <ect>
\t3 } else { \n \n \t4 s_logger . info ( <string_literal> + responseCode + <string_literal> + values . get ( <string_literal> ) ) ; \n \n \t4 s_snapshot . set ( values . get ( <string_literal> ) ) ; } \n \n \t2 } else { \n \n <ect>
\t2 compileLibraries ( avrBasePath , buildPath , includePaths , systemFolder ) ; \n \n \t2 sketch . setCompilingProgress ( <number_literal> ) ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t5 writeSetting ( readMarker . getIdentifier ( ) , getMarkerColumn ( partitionId , bucketId ) , times . getTime ( messageTimeStart ) ) ; \n \n \t5 log . debug ( <string_literal> , \n \n \t7 readMarker . getIdentifier ( ) , partitionId , bucketId , messageTimeStart ) ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t1 * templateZonePairList . add ( new Pair < Long , Long > ( publicIsos . get ( i ) . getId ( ) , \n \n \t1 * null ) ) ; continue ; } else if ( keyword == null && name == null ) { \n \n \t1 * templateZonePairList . add ( new Pair < Long , Long > ( publicIsos . get ( i ) . getId ( ) , \n \n \t1 * null ) ) ; } } } } } catch ( Exception e ) { \n \n <ect>
\t2 ResteasyProviderFactory factory = ResteasyProviderFactory . getInstance ( ) ; \n \n \t2 delegate = factory . getMessageBodyReader ( CDIInjectionBook . class , null , null , Constants . MEDIA_TYPE_TEST_XML_TYPE ) ; \n \n \t2 log . info ( <string_literal> ) ; } \n \n \t1 public CDIInjectionBookReader ( ) { \n \n <ect>
\t4 log . debug ( <string_literal> + url + <string_literal> + cacheDir ) ; \n \n \t4 long curTime = System . currentTimeMillis ( ) ; \n \n \t4 fs . setTimes ( cacheFile , - 1 , curTime ) ; \n \n \t4 return cacheFile ; } \n \n <ect>
\t1 processPoolChangesOnMasterThread ( poolName , hasRequeues , syncWork ) ; } \n \n \t1 <comment> \n \n \t1 for ( KillQueryContext killCtx : syncWork . toKillQuery . values ( ) ) { \n \n \t1 if ( killQueryInProgress . put ( killCtx . session , killCtx ) != null ) { \n \n <ect>
\t2 Location location = null ; \n \n \t2 try { \n \n \t3 location = journal . getNextLocation ( nextLocation , limit ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 worksheet . getSemanticTypes ( ) , rdfPrefix , rdfNamespace , \n \n \t5 false ) ; \n \n \t2 } catch ( KarmaException e ) \n \n \t2 { \n \n <ect>
\t5 . post ( Entity . entity ( bigJAXBElement , <string_literal> ) ) ; \n \n \t3 Assert . assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n \t3 String entity = response . readEntity ( String . class ) ; \n \n \t3 int len = Math . min ( entity . length ( ) , <number_literal> ) ; \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 builder . append ( InetAddress . getLocalHost ( ) . getCanonicalHostName ( ) ) ; \n \n \t2 } catch ( UnknownHostException ex ) { \n \n <ect>
\t3 checkIteratorConflicts_result result = new checkIteratorConflicts_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t4 if ( store != null && store . isActive ( ) ) { \n \n \t5 try { \n \n \t6 store . rollbackTrx ( ) ; } \n \n \t5 catch ( RuntimeException rex ) { \n \n <ect>
\t2 try ( Jar jar = new Jar ( <string_literal> , in ) ) { \n \n \t3 for ( Entry < String , Resource > e : jar . getResources ( ) \n \n \t4 . entrySet ( ) ) { \n \n \t4 String path = e . getKey ( ) ; \n \n <ect>
\t2 loginModule . get ( FLAG ) . set ( <string_literal> ) ; \n \n \t2 loginModule . get ( OPERATION_HEADERS ) . get ( ALLOW_RESOURCE_SERVICE_RESTART ) . set ( true ) ; \n \n \t2 steps . add ( loginModule ) ; \n \n \t2 applyUpdates ( managementClient . getControllerClient ( ) , Arrays . asList ( compositeOp ) ) ; \n \n <ect>
\t6 LOGGER . info ( <string_literal> , result . getCanonicalPath ( ) ) ; } } \n \n \t3 } else { \n \n \t4 LOGGER . warn ( <string_literal> , filePath . getCanonicalPath ( ) ) ; } \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t3 <comment> \n \n \t3 LOG . debug ( <string_literal> , factory ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t5 Map < String , String > mappings = getMapping ( client , index , \n \n \t7 types != null ? new HashSet < > ( types ) : null ) ; \n \n \t5 logger . info ( <string_literal> , mappings . keySet ( ) ) ; \n \n \t5 for ( String type : mappings . keySet ( ) ) { \n \n <ect>
\t1 protected File \t5 _workspaceDir ; \n \n \t1 final static Logger logger = LoggerFactory . getLogger ( <string_literal> ) ; \n \n \t1 static public synchronized void initialize ( File dir ) { \n \n \t2 if ( singleton != null ) { \n \n <ect>
\t2 { \n \n \t3 stream . close ( ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t2 } catch ( final InterruptedException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return new FenceAnswer ( command , false , e . getMessage ( ) ) ; \n \n \t2 } catch ( final ExecutionException e ) { \n \n <ect>
\t2 if ( netComp != null && netComp . getNetworkId ( ) != NULL_NET_ID ) { \n \n \t3 if ( mode . isServer ( ) ) { \n \n \t4 if ( metadata . isReplicated ( ) ) { \n \n \t5 for ( NetClient client : netClientList ) { \n \n <ect>
\t2 Savepoint sp = null ; \n \n \t2 try { \n \n \t3 sp = conn . setSavepoint ( key ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t3 while ( ! this . taskCanceled && splitIterator . hasNext ( ) ) \n \n \t3 { \n \n \t4 <comment> \n \n \t4 final InputSplit split = splitIterator . next ( ) ; \n \n <ect>
<comment> \n \n \t1 private void registerMacro ( DocumentReference wikiMacroDocumentReference , String wikiMacroDocumentAuthor , \n \n \t2 XWikiContext xcontext ) \n \n \t1 { \n \n <ect>
\t1 error . join ( ) ; \n \n \t1 if ( output . getValues ( ) != null && output . getValues ( ) . containsKey ( <string_literal> ) ) { \n \n \t2 return output . getValues ( ) . get ( <string_literal> ) ; } \n \n \t1 } catch ( Exception t ) { \n \n <ect>
\t2 this . sharedServices = sharedServices ; \n \n \t2 this . jvmVersionDetector = jvmVersionDetector ; } \n \n \t1 public void configure ( ProviderConnectionParameters parameters ) { \n \n \t2 LogLevel providerLogLevel = parameters . getVerboseLogging ( ) ? LogLevel . DEBUG : LogLevel . INFO ; \n \n <ect>
\t4 storageNic2 = guestNic ; \n \n \t4 _storageNetworkName2 = _guestNetworkName ; } \n \n \t3 _host . storageNetwork2 = storageNic2 . getNetworkRecord ( conn ) . uuid ; \n \n \t3 _host . storagePif2 = storageNic2 . getPifRecord ( conn ) . uuid ; \n \n <ect>
\t5 { \n \n \t6 sstable = open ( entry . getKey ( ) , entry . getValue ( ) , metadata , partitioner ) ; } \n \n \t5 catch ( IOException ex ) \n \n \t5 { \n \n <ect>
\t5 log . debug ( <string_literal> , _transCount , EOSharedEditingContext . defaultSharedEditingContext ( ) . registeredObjects ( ) . count ( ) ) ; \n \n \t4 } else { \n \n \t5 log . debug ( <string_literal> ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 driver . switchTo ( ) . window ( <string_literal> ) ; \n \n \t1 <comment> \n \n \t1 wait . until ( ExpectedConditions . visibilityOfElementLocated ( By . id ( <string_literal> ) ) ) ; } \n \n private void waitForServerStart ( final AndroidDevice device ) { \n \n <ect>
\t5 return new AboutWindowPluginComponent ( getContainer ( ) , this ) ; } \n \n \t3 } , \n \n \t3 helpMenuFilter ) ; \n \n <ect>
\t6 sendCurrentState ( ) ; \n \n \t5 } catch ( CommunicationException e ) { \n \n \t6 cancel ( ) ; \n \n \t6 LOGGER . error ( <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
<comment> \n \n @ Override \n \n public boolean stop ( ) throws Exception { \n \n <ect>
\t1 public String encode ( String input ) { \n \n \t2 try { \n \n \t3 return URLEncoder . encode ( input , encoding ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t1 try { \n \n \t1 return buildClient ( BillingAWSCredentialsProvider . BillingUserSupplier . INSTANCE , \n \n \t3 BillingProperties . SQS_CLIENT_CONFIG ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t3 if ( editor == null ) { \n \n \t4 throw new CacheConfigurationException ( <string_literal> + parameterType ) ; } \n \n \t3 editor . setAsText ( ( String ) attribs . get ( propName ) ) ; \n \n \t3 Object parameter = editor . getValue ( ) ; \n \n <ect>
\t2 long start = _context . clock ( ) . now ( ) ; \n \n \t2 InfoHash iHash = new InfoHash ( ih ) ; \n \n \t2 List < NodeInfo > nodes = _knownNodes . findClosest ( iHash , max ) ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
<comment> \n \n \t1 private boolean installView ( View new_view , Digest digest ) { \n \n \t2 if ( ! new_view . containsMember ( gms . local_addr ) ) { \n \n <ect>
\t3 if ( matchingNuageVspDevice == null ) { \n \n \t4 auditDomainsOnVsp ( ( HostVO ) host , true ) ; } \n \n \t3 return nuageVspDevice ; \n \n \t2 } catch ( ConfigurationException e ) { \n \n <ect>
\t5 logger . warn ( <string_literal> ) ; } } \n \n \t3 NotifyMyAndroid . defaultUrl = ( String ) config . get ( PARAM_KEY_DEFAULT_URL ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t3 int numLines = 0 ; \n \n \t3 while ( ( line = reader . readLine ( ) ) != null ) { \n \n \t4 final String [ ] toks = line . trim ( ) . split ( <string_literal> ) ; \n \n \t4 if ( toks . length < <number_literal> ) { \n \n <ect>
\t1 protected void printFormattedPayload ( ) { \n \n \t2 logger . debug ( <string_literal> + this . firmwareMajor + <string_literal> + this . firmwareMinor ) ; \n \n \t2 logger . debug ( <string_literal> + this . type ) ; \n \n \t2 logger . debug ( <string_literal> + this . testResult ) ; \n \n <ect>
\t3 errorString = <string_literal> ; \n \n \t3 status = TemplateDownloader . Status . UNRECOVERABLE_ERROR ; \n \n \t3 s_logger . warn ( <string_literal> + ex . toString ( ) ) ; \n \n \t2 } catch ( Throwable th ) { \n \n <ect>
\t3 return eventList ; } \n \n \t2 for ( String calendarId : query . getCalendarIds ( ) ) { \n \n \t3 final CalendarRuntime eventRuntime = EventStorage . getInstance ( ) . getEventCache ( ) . get ( calendarId ) ; \n \n \t3 if ( eventRuntime == null ) { \n \n <ect>
\t5 String pluginKey = ArtifactUtils . key ( plugin . getGroupId ( ) , plugin . getArtifactId ( ) , \n \n <number_literal> plugin . getVersion ( ) ) ; \n \n \t5 if ( projectsMap . containsKey ( pluginKey ) ) \n \n \t5 { \n \n <ect>
\t4 if ( peer != null ) \n \n \t5 sendDestroy ( peer ) ; \n \n \t4 dropPeer ( peerHash , false , <string_literal> ) ; \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 if ( ln . size ( ) > 0 ) { \n \n \t2 return ( String ) ln . getRdn ( ln . size ( ) - 1 ) . getValue ( ) ; } \n \n \t1 } catch ( InvalidNameException e ) { \n \n \t1 LOG . error ( e , e ) ; \n \n <ect>
\t1 this . communicator = new LlapProtocolClientProxy ( 1 , conf , llapToken ) ; \n \n \t1 this . communicator . init ( conf ) ; } \n \n private void terminateRequest ( ) { \n \n \t1 if ( closed || requestInfo == null ) { \n \n <ect>
\t2 public void run ( ) { \n \n \t2 try { \n \n \t3 deleteParts ( bucketName , objectKey , uploadId , true ) ; \n \n \t2 } catch ( final Throwable f ) { \n \n <ect>
\t3 if ( t instanceof InterruptedException ) \n \n \t4 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t3 else if ( t instanceof ThreadDeath ) \n \n \t4 throw ( ThreadDeath ) t ; \n \n <ect>
\t4 log . warn ( <string_literal> , getName ( ) ) ; \n \n \t4 return false ; } \n \n \t3 ScheduledBackupType typeToUse = ScheduledBackupType . getBackupTypes ( ) . get ( type ) ; \n \n \t3 if ( typeToUse == null ) { \n \n <ect>
\t4 @ GridInstanceResource \n \n \t4 private Grid g ; \n \n \t4 <comment> \n \n \t4 @ Override public Object execute ( ) { \n \n <ect>
\t3 log . debug ( <string_literal> + npse ) ; \n \n \t3 ERXValidationException v = ERXValidationFactory . defaultFactory ( ) . createException ( object ( ) , key ( ) , dateString , <string_literal> ) ; \n \n \t3 parent ( ) . validationFailedWithException ( v , date , key ( ) ) ; \n \n \t2 } catch ( NSValidation . ValidationException v ) { \n \n <ect>
\t2 net . juniper . contrail . api . types . Project project ; \n \n \t2 try { \n \n \t3 project = _manager . getVncProject ( owner . getDomainId ( ) , owner . getAccountId ( ) ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t2 return rs . getFloat ( 1 ) ; \n \n \t1 } else { \n \n \t2 return null ; } \n \n \t1 } catch ( SQLException sqle ) { \n \n <ect>
\t4 if ( files == null && attempts ++ > maxFindAttempts ) { \n \n \t5 log . error ( <string_literal> + attempts + <string_literal> ) ; \n \n \t5 throw new RuntimeException ( <string_literal> + attempts + <string_literal> ) ; \n \n \t4 } else if ( files == null ) { \n \n <ect>
\t2 JVMStabilityInspector . inspectThrowable ( indexBuildFailure ) ; \n \n \t2 if ( indexBuildFailure != null ) \n \n \t3 logger . warn ( <string_literal> , getIndexNames ( indexes ) , indexBuildFailure ) ; \n \n \t2 else \n \n <ect>
\t1 int excluded = this . excluded ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 flushInternal ( ) ; \n \n \t1 if ( excluded == 0 ) { \n \n <ect>
\t1 try { \n \n \t2 if ( connection != null ) \n \n \t2 connection . close ( ) ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t1 try { \n \n \t1 actualUri = method . getURI ( ) . toString ( ) ; <comment> \n \n \t1 LOG . debug ( type + <string_literal> + method . getURI ( ) . getEscapedURI ( ) ) ; \n \n \t1 int httpStatus = client . executeMethod ( method ) ; \n \n <ect>
\t3 f = new File ( graphDir ) ; \n \n \t3 if ( ! f . exists ( ) ) { \n \n \t4 f . mkdir ( ) ; } \n \n \t3 logger . info ( <string_literal> ) ; \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testSLSB ( ) throws Exception { \n \n <ect>
\t3 fail ( <string_literal> ) ; \n \n \t2 } catch ( RepositoryException ex ) { \n \n \t3 assertThat ( ex . toString ( ) , containsString ( <string_literal> + location + <string_literal> ) ) ; } } \n \n \t1 public void testRepositoryAckTimeout ( ) throws Exception { \n \n <ect>
\t5 peer . setPeerState ( ServerState . LOOKING ) ; \n \n \t5 LOG . info ( <string_literal> ) ; \n \n \t5 v = peer . getElectionAlg ( ) . lookForLeader ( ) ; \n \n \t5 if ( v == null ) { \n \n <ect>
\t5 break ; } \n \n \t4 try { \n \n \t5 Thread . sleep ( <number_literal> ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t4 gadgetDefs . put ( gadgetDefUrl , targetGadgetDef ) ; \n \n \t4 List < GadgetMetaDataDTO > gadgetMetaData = gadgetMetaFetcher . getGadgetsMetaData ( gadgetDefs ) ; \n \n \t4 for ( GadgetMetaDataDTO currentGMeta : gadgetMetaData ) \n \n \t4 { \n \n <ect>
\t3 org . junit . Assert . assertEquals ( 1 + DEFAULT_CLIENTS_COUNT , clientSessionsCount ) ; \n \n \t2 } finally { \n \n \t3 long end = System . currentTimeMillis ( ) - start ; \n \n \t3 log . infof ( <string_literal> , loginTask == null ? <string_literal> : loginTask . getHistogram ( ) ) ; \n \n <ect>
\t2 if ( result == null || result . isEmpty ( ) ) { \n \n \t3 log . warn ( <string_literal> , jobId , checkPath ) ; \n \n \t3 return 0 ; \n \n \t2 } else if ( result . size ( ) > 1 ) { \n \n <ect>
\t3 + <string_literal> + queryFilterString ) ; \n \n \t1 if ( maxParts >= 0 ) { \n \n \t2 <comment> \n \n \t2 query . setRange ( 0 , maxParts ) ; } \n \n <ect>
\t2 long expectedResultCount = ( pageSize == 0 || page == 0 ) \n \n \t5 ? 0 \n \n \t5 : Math . min ( number , pageSize ) ; \n \n \t2 int startIndex = ( Math . max ( page , 1 ) - 1 ) * pageSize ; \n \n <ect>
<comment> \n \n \t1 private void doInitializeParserUI ( HttpServletRequest request , HttpServletResponse response , Properties parameters ) \n \n \t3 throws ServletException , IOException { \n \n <ect>
\t6 Map . Entry < ? , ? > me = ( Map . Entry < ? , ? > ) it . next ( ) ; \n \n \t6 String key = ( String ) me . getKey ( ) ; \n \n \t6 String value = ( String ) me . getValue ( ) ; \n \n \t6 if ( value == null ) { \n \n <ect>
\t3 String [ ] lines = rdf . split ( <string_literal> ) ; \n \n \t3 int count = lines . length ; \n \n \t3 assertEquals ( <number_literal> , count ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 LOG . debug ( <string_literal> + hits . getNumberOfHits ( ) ) ; \n \n \t6 for ( int i = 0 ; i < hits . getNumberOfHits ( ) ; i ++ ) { \n \n \t7 LOG . debug ( <string_literal> + i + <string_literal> + hits . getHit ( ) . get ( i ) . getHitLocation ( ) ) ; \n \n \t7 LOG . debug ( <string_literal> + i + <string_literal> + hits . getHit ( ) . get ( i ) . getScore ( ) ) ; \n \n <ect>
<number_literal> final Class < T > clazz ) { \n \n \t2 try { \n \n \t3 final ScriptEngine engine = new ScriptEngineManager ( ) . getEngineByName ( <string_literal> ) ; \n \n \t3 if ( engine == null ) { \n \n <ect>
\t2 LOG . info ( <string_literal> , sub . getPendingQueueSize ( ) ) ; \n \n \t2 assertNotNull ( consumer . receive ( <number_literal> ) ) ; \n \n \t2 assertNotNull ( consumer . receive ( <number_literal> ) ) ; \n \n \t2 consumer . close ( ) ; \n \n <ect>
\t1 try { \n \n \t1 setViewUrl ( viewInstanceEntity ) ; \n \n \t1 } catch ( Exception urlCreateException ) { \n \n \t1 LOG . error ( <string_literal> , viewInstanceEntity . getViewName ( ) ) ; \n \n <ect>
\t3 m_hostname = InetAddress . getLocalHost ( ) . getHostName ( ) + <string_literal> + InetAddress . getLocalHost ( ) . getHostAddress ( ) ; \n \n \t2 } catch ( NumberFormatException ex ) { \n \n \t3 throw new ConfigurationException ( <string_literal> + execTime + <string_literal> + aggregationRange + <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 s_logger . debug ( log ( seq , <string_literal> ) ) ; } \n \n \t4 processAnswers ( seq , resp ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 LOG . trace ( <string_literal> + value . getValue ( ) ) ; } \n \n \t3 final Long currentTimeStamp = value . getTimestamp ( ) . getTime ( ) ; \n \n \t3 final Double currentValue = value . getValue ( ) ; \n \n \t3 if ( currentValue == null ) { \n \n <ect>
\t1 if ( maxLifetime != 0 && maxLifetime < SECONDS . toMillis ( <number_literal> ) ) { \n \n \t2 LOGGER . warn ( <string_literal> , poolName , MAX_LIFETIME ) ; \n \n \t2 maxLifetime = MAX_LIFETIME ; } \n \n \t1 if ( idleTimeout + SECONDS . toMillis ( 1 ) > maxLifetime && maxLifetime > 0 ) { \n \n <ect>
\t3 connect ( ) ; \n \n \t3 return ; <comment> \n \n \t3 } catch ( IOException e ) { \n \n \t3 <comment> \n \n <ect>
\t2 } catch ( ExecException e ) { \n \n \t3 log . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( FrontendException e ) { \n \n <ect>
\t4 case 'N' : \n \n \t5 parity = SerialPort . PARITY_NONE ; \n \n \t5 break ; \n \n \t4 default : \n \n <ect>
\t2 testRealmRegistrationPage . waitForConfirmPasswordInputPresent ( ) ; \n \n \t2 testRealmRegistrationPage . waitForUsernameInputPresent ( ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 <comment> \n \n <ect>
<comment> \n \n \t1 private static boolean canInvokeWithArgs ( List < Object > args , Class [ ] parameterTypes ) { \n \n \t2 if ( parameterTypes . length != args . size ( ) ) { \n \n <ect>
\t6 LOG . info ( <string_literal> ) ; \n \n \t6 exchange . getIn ( ) . setBody ( <string_literal> ) ; \n \n \t5 } else { \n \n \t6 assertEquals ( <string_literal> , input ) ; \n \n <ect>
\t1 threadOne . proceedAndWaitTillDone ( ) ; \n \n \t1 assertNull ( threadOne . exception ) ; \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t2 boolean disabledWithJMX = ! enabled && shouldBeEnabled ( ) ; \n \n \t2 if ( currentBoundaries != null ) \n \n \t2 { \n \n \t3 if ( ! newCompactionParams . equals ( schemaCompactionParams ) ) \n \n <ect>
\t5 tInfo . size = vSize ; \n \n \t5 loc . updateVirtualSize ( vSize ) ; \n \n \t5 loc . save ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 @ PostConstruct \n \n \t1 public void buildFactory ( ) { \n \n \t1 instance = Validation . byDefaultProvider ( ) . configure ( ) \n \n \t2 . constraintValidatorFactory ( constraintValidatorFactory ) . buildValidatorFactory ( ) ; \n \n <ect>
\t2 options . solr_keytab , options . solr_principal , options . json_file , options . compression , \n \n \t2 options . hdfs_keytab , options . hdfs_principal , options . hdfs_user , options . hdfs_path , options . key_file_path , \n \n \t2 options . bucket , options . key_prefix , options . local_path ) \n \n \t1 else : \n \n <ect>
<comment> \n \n \t1 private void throwUnauthorized ( User user , Method method , String attr ) { \n \n <ect>
public class Application extends ERXApplication { \n \n \t1 public static void main ( String [ ] argv ) { \n \n \t2 ERXApplication . main ( argv , Application . class ) ; } \n \n \t1 public Application ( ) { \n \n <ect>
\t2 try { \n \n \t3 final HttpHeaders acceptHeaders = new HttpHeaders ( ) ; \n \n \t3 acceptHeaders . setAccept ( CollectionUtils . wrap ( MediaType . APPLICATION_JSON ) ) ; \n \n \t3 final HttpEntity < Principal > entity = new HttpEntity < > ( authentication . getPrincipal ( ) , acceptHeaders ) ; \n \n <ect>
\t7 LOGGER . warn ( String . format ( \n \n \t8 <string_literal> , \n \n \t8 entry . getKey ( ) , entry . getValue ( ) , e . getMessage ( ) ) ) ; } } \n \n \t4 } catch ( XWikiVelocityException ex ) { \n \n <ect>
\t4 s_logger . warn ( <string_literal> + e . toString ( ) , e ) ; } } \n \n \t2 return stats ; } \n \n \t1 protected Answer execute ( final SetMonitorServiceCommand cmd ) { \n \n <ect>
\t1 for ( Future < Boolean > future : futures ) { \n \n \t2 try { \n \n \t2 result & = future . get ( ) ; \n \n \t2 } catch ( InterruptedException | ExecutionException e ) { \n \n <ect>
\t1 private static void loadAndInit ( String className ) \n \n \t1 { \n \n \t2 try { \n \n \t3 Class < ? > classObj = Class . forName ( className ) ; \n \n <ect>
\t4 } , <string_literal> + j ) ; \n \n \t4 if ( logMINOR ) \n \n \t5 Logger . minor ( this , <string_literal> + j + <string_literal> ) ; \n \n \t3 } catch ( RejectedExecutionException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 @ Override \n \n \t1 protected SpatialMatch objectToStruct ( PropFuncArg argObject ) { \n \n \t2 if ( argObject . isNode ( ) ) { \n \n <ect>
\t7 if ( cnt < JOB_COUNT ) { \n \n \t8 try { \n \n \t9 mapper . send ( new SessionChainTestJob ( cnt ) ) ; } \n \n \t8 catch ( GridException e ) { \n \n <ect>
\t3 this . udpThreadPoolShutdownTimeout = udpThreadPoolShutdownTimeout ; } \n \n \t2 this . remotePassword = configFile . getString ( <string_literal> ) ; \n \n \t2 log . debug ( <string_literal> + remotePassword ) ; \n \n \t2 this . remotePort = configFile . getInteger ( <string_literal> ) ; \n \n <ect>
\t2 { \n \n \t3 undo . undo ( ) ; } \n \n \t2 catch ( CannotUndoException e ) \n \n \t2 { \n \n <ect>
\t5 MessageConsumer con2 = session . createConsumer ( queue ) ; \n \n \t5 while ( true ) { \n \n \t6 Message message = con2 . receive ( <number_literal> ) ; \n \n \t6 if ( message == null ) { break ; } \n \n <ect>
\t5 boolean autocommit = con . getConnection ( ) . getAutoCommit ( ) ; \n \n \t5 if ( ! autocommit ) con . getConnection ( ) . commit ( ) ; } } \n \n \t3 return true ; \n \n \t2 } catch ( SQLException x ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 LOG . error ( <string_literal> + topology_id + <string_literal> + task_id , e ) ; } } \n \n \t1 @ Override \n \n \t1 public void report ( String error , String errorLevel , int errorCode , int duration ) { \n \n <ect>
\t6 if ( client . getIsEnabled ( ) ) { \n \n \t7 XMPPContext . connect ( client ) ; } } \n \n \t5 tx . success ( ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t3 if ( this . running || ! this . autoStartup ) { \n \n \t4 return ; } \n \n \t3 if ( this . connectionFactory instanceof CachingConnectionFactory && \n \n \t5 ( ( CachingConnectionFactory ) this . connectionFactory ) . getCacheMode ( ) == CacheMode . CONNECTION ) { \n \n <ect>
\t2 actionResolverName = <string_literal> , \n \n \t2 resourceResolverName = <string_literal> ) \n \n \t1 @ Override \n \n \t1 public MultifactorAuthenticationTrustRecord set ( final MultifactorAuthenticationTrustRecord record ) { \n \n <ect>
\t2 if ( parentFile . delete ( ) && parentFile . mkdir ( ) ) { \n \n \t2 parentFile . deleteOnExit ( ) ; \n \n \t2 break ; } \n \n <ect>
\t3 if ( scheduler == null && opened . get ( ) ) { \n \n \t4 startCheckpoint ( ) ; } \n \n \t3 return location ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t3 if ( updated == 0 ) { \n \n \t4 <comment> \n \n \t4 LOG . warn ( <string_literal> ) ; \n \n \t3 } else if ( updated > 1 ) { \n \n <ect>
\t3 throw new EucalyptusCloudException ( <string_literal> + this . snapshotId ) ; } \n \n \t2 } catch ( EucalyptusCloudException e ) { \n \n \t3 throw e ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 clientDestCount = 1 ; <comment> \n \n \t4 clientDestIndex = clientIndex % numDests ; } \n \n \t3 <comment> \n \n \t2 } else { \n \n <ect>
\t3 SOAPBody body = envelope . getBody ( ) ; \n \n \t3 body . setPrefix ( namespace ) ; \n \n \t3 body . addChildElement ( bodyData ) ; <comment> \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 writer . write ( document ) ; \n \n \t3 String result = out . toString ( ) ; \n \n \t3 <comment> \n \n <ect>
\t3 taskId = entry . getValue ( ) ; } \n \n \t2 long trueSize = fetchTaskTrueSize ( jobId , taskId ) ; \n \n \t2 long reportedSize = getReportedSize ( spawn . getTask ( jobId , taskId ) ) ; \n \n \t2 double ratio = getRatio ( trueSize , reportedSize ) ; \n \n <ect>
\t4 return ; } \n \n \t3 final Pair < String , String > email = formatNotifications ( context , state ) ; \n \n \t3 doSendMail ( config , users , email ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 if ( result != null ) { \n \n \t4 LOGGER . debug ( <string_literal> , key , result ) ; \n \n \t4 attributesToRelease . put ( key , result ) ; \n \n \t3 } else { \n \n <ect>
\t3 LOG . debug ( <string_literal> ) ; \n \n \t3 try { \n \n \t4 socketTransportStarted . await ( ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 final ScriptEngine scriptEngine = scriptEngineContainer \n \n \t5 . getScriptEngine ( m_initialisationMessage . getScript ( ) ) ; \n \n <ect>
\t2 try { \n \n \t3 cubeManager . promoteNewlyOptimizeSegments ( cube , segment ) ; \n \n \t3 return new ExecuteResult ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 public < T extends VMInstanceVO > T allocate ( T vm , VMTemplateVO template , ServiceOfferingVO serviceOffering , Pair < ? extends DiskOfferingVO , Long > rootDiskOffering , \n \n \t3 List < Pair < DiskOfferingVO , Long > > dataDiskOfferings , List < Pair < NetworkVO , NicProfile > > networks , Map < VirtualMachineProfile . Param , Object > params , DeploymentPlan plan , \n \n \t3 HypervisorType hyperType , Account owner ) throws InsufficientCapacityException { \n \n <ect>
<comment> \n \n \t1 private static boolean isGrantTypeSupported ( final String type , final OAuth20GrantTypes . . . expectedTypes ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 final List < NiciraNvpDeviceVO > devices = niciraNvpDao . listByPhysicalNetwork ( physnet . getId ( ) ) ; \n \n \t2 if ( devices . isEmpty ( ) ) { \n \n <ect>
\t1 val clazz = compile ( \n \n \t1 getRuntimeContext . getUserCodeClassLoader , \n \n \t1 genAggregations . name , \n \n \t1 genAggregations . code ) \n \n <ect>
\t2 BreakerSettings newFielddataSettings = new BreakerSettings ( CircuitBreaker . FIELDDATA , newFielddataLimitBytes , newFielddataOverhead , \n \n \t4 HierarchyCircuitBreakerService . this . fielddataSettings . getType ( ) ) ; \n \n \t2 registerBreaker ( newFielddataSettings ) ; \n \n \t2 HierarchyCircuitBreakerService . this . fielddataSettings = newFielddataSettings ; \n \n <ect>
\t2 if ( ( t . isClosing ( ) || t . isClosed ( ) ) && e instanceof IllegalStateException ) { \n \n \t2 log . debug ( <string_literal> , extent , \n \n \t3 e . getMessage ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t7 logger . trace ( <string_literal> , LoggerConstants . COMMAND ) ; \n \n \t7 if ( mDevice instanceof MTextActor ) { \n \n \t8 ( ( MTextActor ) mDevice ) . write ( command . toString ( ) ) ; } \n \n \t6 } else if ( command instanceof DecimalType ) { \n \n <ect>
\t8 s_logger . warn ( <string_literal> + vm + <string_literal> + ( answer != null ? answer . getDetails ( ) : <string_literal> ) ) ; \n \n \t8 _haMgr . scheduleStop ( vm , destHostId , WorkType . ForceStop ) ; \n \n \t8 throw new ExecutionException ( <string_literal> + vm . getUuid ( ) + <string_literal> ) ; } \n \n \t7 throw new ExecutionException ( <string_literal> + vm . getUuid ( ) + <string_literal> ) ; } } \n \n <ect>
\t3 if ( task != null ) { \n \n \t4 try { \n \n \t5 task . destroy ( conn ) ; \n \n \t4 } catch ( final Exception e1 ) { \n \n <ect>
\t6 c . onFailure ( context ) ; \n \n \t5 else \n \n \t6 c . onFoundEdition ( ed , origUSK . copy ( ed ) , context , lastWasMetadata , lastCompressionCodec , data , false , false ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
@ Override \n \n public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) \n \n \t1 throws IOException , ServletException { \n \n \t1 if ( ! authPropsConfig . isAuthJwtEnabled ( ) ) { <comment> \n \n <ect>
\t4 log . warn ( <string_literal> , be ) ; \n \n \t4 int [ ] updateCounts = be . getUpdateCounts ( ) ; \n \n \t4 for ( int updateCount : updateCounts ) { \n \n \t5 if ( updateCount > - 1 ) { \n \n <ect>
\t3 try { \n \n \t4 fd . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 if ( lock ( jobId ) ) { \n \n \t4 coordInfo = call ( store ) ; } \n \n \t3 else { \n \n \t4 queueCallable ( new CoordResumeCommand ( jobId ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t1 buckets = searchCriteria . list ( ) ; \n \n \t1 trans . commit ( ) ; \n \n \t1 return buckets ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 break ; } } \n \n \t3 <comment> \n \n \t3 if ( cardInColumn == null ) { \n \n \t4 <comment> \n \n <ect>
\t1 if ( nettyServer != null ) { \n \n \t1 try { \n \n \t2 nettyServer . close ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 task . setRebalanceSource ( null ) ; \n \n \t4 task . setRebalanceTarget ( null ) ; } \n \n \t3 if ( task . getState ( ) . isQueuedState ( ) ) { \n \n \t4 removeFromQueue ( task ) ; \n \n <ect>
\t2 boolean result ; \n \n \t2 byte [ ] digest = obj . getFirstDigest ( ) ; \n \n \t2 ContentName name = obj . getVersionedName ( ) ; \n \n \t2 if ( Log . isLoggable ( Level . INFO ) ) { \n \n <ect>
\t3 final RadiusPacket response = client . authenticate ( request , RadiusClient . getAuthProtocol ( this . protocol . getName ( ) ) , this . retries ) ; \n \n \t3 LOGGER . debug ( <string_literal> , client . getRemoteInetAddress ( ) . getCanonicalHostName ( ) , response . getClass ( ) . getName ( ) ) ; \n \n \t3 if ( response instanceof AccessAccept ) { \n \n \t4 final List < RadiusAttribute > attributes = response . getAttributes ( ) . getAttributeList ( ) ; \n \n <ect>
\t2 } else { \n \n \t2 populateLdapConfigurationToBeUpgraded ( propertiesToBeSaved , oldPropertyName , key . key ( ) , ldapPropertyValue ) ; } } \n \n \t1 } ) ; \n \n \t1 if ( propertiesToBeSaved . isEmpty ( ) ) { \n \n <ect>
\t3 this . commitInternal ( ) ; \n \n \t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 <comment> \n \n \t3 if ( this . holdability == ResultSet . CLOSE_CURSORS_AT_COMMIT ) { \n \n <ect>
\t4 t . schedule ( ) ; } \n \n \t3 super . run ( ) ; } \n \n \t2 catch ( RuntimeException t ) { \n \n \t3 if ( ERXApplication . _wasMainInvoked ) { \n \n <ect>
\t2 assertTrue ( msg instanceof TextMessage ) ; \n \n \t2 LOG . info ( <string_literal> , queueView . getQueueSize ( ) ) ; \n \n \t2 assertEquals ( msgCount , queueView . getQueueSize ( ) ) ; \n \n \t2 session . commit ( ) ; \n \n <ect>
\t4 try { \n \n \t5 writeResponse ( this . serverSocket . accept ( ) ) ; \n \n \t5 Thread . sleep ( <number_literal> ) ; \n \n \t4 } catch ( final SocketException e ) { \n \n <ect>
\t3 IDatabaseConnection kylinConn = new DatabaseConnection ( cubeConnection ) ; \n \n \t3 ITable kylinTable = executeQuery ( kylinConn , queryName , sql , needSort ) ; \n \n \t3 printResult ( kylinTable ) ; } } \n \n \t1 protected void compare ( String queryFolder , String [ ] exclusiveQuerys , boolean needSort ) throws Exception { \n \n <ect>
\t3 serverAddress = createNonBlockingServer ( address , processor , protocolFactory , serverName , \n \n \t4 threadName , numThreads , numSTThreads , timeBetweenThreadChecks , maxMessageSize ) ; } \n \n \t2 break ; \n \n \t1 } catch ( TTransportException e ) { \n \n <ect>
\t1 session = null ; } \n \n \t1 if ( cluster != null ) { \n \n \t1 cluster . close ( ) ; \n \n \t1 cluster = null ; } \n \n <ect>
\t3 boolean success = false ; \n \n \t3 try { \n \n \t4 success = _fs . mkdirs ( _fullPath , perms ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 if ( ! doColumnMasking && ! doRowFiltering ) { \n \n \t1 <comment> \n \n \t1 return null ; \n \n \t1 } else { \n \n <ect>
\t2 if hive_tez_default_queue : \n \n \t3 putHiveInteractiveSiteProperty ( <string_literal> , hive_tez_default_queue ) \n \n \t3 self . logger . debug ( <string_literal> . format ( hive_tez_default_queue ) ) \n \n \t1 else : \n \n <ect>
\t1 { \n \n \t2 String path = getSettingsString ( urlKey ) ; \n \n \t2 if ( path == null || path . length ( ) == 0 ) \n \n \t2 { \n \n <ect>
\t3 try ( PreparedStatement volStoreUpdate = conn . prepareStatement ( <string_literal> ) ; ) { \n \n \t4 rowCount = volStoreUpdate . executeUpdate ( ) ; \n \n \t4 s_logger . debug ( <string_literal> + rowCount + <string_literal> ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t5 log . warn ( <string_literal> , value ) ; } } } \n \n \t2 <comment> \n \n \t2 for ( String id : configMap . keySet ( ) ) { \n \n \t3 if ( StringUtils . isEmpty ( configMap . get ( id ) . getUrl ( ) ) ) { \n \n <ect>
\t3 case ConsoleProxy : \n \n \t2 case SecondaryStorageVm : \n \n \t3 return false ; \n \n \t3 default : \n \n <ect>
\t1 private boolean doCancelMaintenance ( long hostId ) { \n \n \t2 HostVO host ; \n \n \t2 host = _hostDao . findById ( hostId ) ; \n \n \t2 if ( host == null || host . getRemoved ( ) != null ) { \n \n <ect>
\t8 switch ( readByte ) { \n \n \t8 case - 1 : \n \n \t9 if ( echoSocket . isConnected ( ) && ! echoSocket . isClosed ( ) ) { \n \n \t10 log . info ( <string_literal> , reader . available ( ) ) ; \n \n <ect>
\t4 new Values ( tupleId , trade ) ) ; \n \n \t2 collector . emit ( SequenceTopologyDef . CUSTOMER_STREAM_ID , \n \n \t4 new Values ( tupleId , customer ) ) ; \n \n \t1 } else if ( obj != null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 logger . debug ( <string_literal> + measuredTemperature ) ; \n \n \t2 logger . debug ( <string_literal> + displayMeasuredTemp ) ; \n \n \t2 logger . debug ( <string_literal> + ctrlMode ) ; \n \n \t2 logger . debug ( <string_literal> + dstActive ) ; \n \n <ect>
\t2 if ( lun == null ) \n \n \t3 throw new InvalidParameterValueException ( <string_literal> ) ; \n \n \t2 NetappVolumeVO vol = _volumeDao . acquireInLockTable ( lun . getVolumeId ( ) ) ; \n \n \t2 if ( vol == null ) { \n \n <ect>
\t4 log . warn ( <string_literal> + list ) ; \n \n \t4 return null ; } \n \n \t3 LiteralLabel lit = x . getLiteral ( ) ; \n \n \t3 if ( ! XSDDatatype . XSDinteger . isValidLiteral ( lit ) ) { \n \n <ect>
\t3 long realPk = l < < CODE_LENGTH ; \n \n \t3 <comment> \n \n \t3 realPk = realPk | ( ( ERXModelGroup ) EOModelGroup . defaultGroup ( ) ) . entityCode ( ename ) ; \n \n <ect>
\t4 { \n \n \t5 JVMStabilityInspector . inspectThrowable ( e ) ; \n \n \t5 <comment> \n \n \t5 <comment> \n \n <ect>
@ Test \n \n public void testFindHostsByStage ( ) { \n \n \t1 ormTestHelper . createStageCommands ( ) ; \n \n \t1 StageEntity stageEntity = stageDAO . findByActionId ( <string_literal> ) ; \n \n <ect>
\t5 ++ retryCount ; \n \n \t4 } else { \n \n \t5 break ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 for ( LVMVolumeInfo foundVolumeInfo : volumeInfos ) { \n \n \t2 String loDevName = foundVolumeInfo . getLoDevName ( ) ; \n \n \t2 if ( loDevName != null ) { \n \n \t2 String loFileName = foundVolumeInfo . getVolumeId ( ) ; \n \n <ect>
\t6 . appendIndex ( ) , ctx . entryLog ( ) . readEntryTerm ( ctx . entryLog ( ) . appendIndex ( ) ) ) ; \n \n \t2 currentMembers . stream ( ) . filter ( member - > ! member . equals ( ctx . myself ( ) ) ) . forEach ( member - > \n \n \t4 outcome . addOutgoingMessage ( new RaftMessages . Directed ( member , preVoteForMe ) ) \n \n \t2 ) ; \n \n <ect>
\t3 fileName = convertURLToFileName ( fileName ) ; \n \n \t3 File hostDir = new File ( PMS . getConfiguration ( ) . getTempFolder ( ) , hostName ) ; \n \n \t3 if ( ! hostDir . isDirectory ( ) ) { \n \n \t4 if ( ! hostDir . mkdir ( ) ) { \n \n <ect>
\t5 ZooTrace . logQuorumPacket ( LOG , traceMask , 'o' , p ) ; } \n \n \t4 oa . writeRecord ( p , <string_literal> ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 if ( ! sock . isClosed ( ) ) { \n \n <ect>
\t5 <comment> \n \n \t5 try { \n \n \t6 in . close ( ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t2 if ( highAvailabilityServices != null ) { \n \n \t3 try { \n \n \t4 highAvailabilityServices . close ( ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t6 userStats . setNetBytesSent ( userStats . getNetBytesSent ( ) + currentBytesSent ) ; \n \n \t6 _userStatsDao . update ( userStats . getId ( ) , userStats ) ; \n \n \t6 s_logger . debug ( <string_literal> + router + <string_literal> ) ; \n \n \t5 } else { \n \n <ect>
\t3 if ( entity != null ) { \n \n \t4 resultList = parseGetResponse ( entity ) ; \n \n \t3 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 while ( providerIterator . hasNext ( ) ) { \n \n \t3 providerList . add ( providerIterator . next ( ) ) ; } \n \n \t2 Collections . sort ( providerList , new Weighted . WeightedComparator ( ) ) ; \n \n <ect>
\t5 entry = in . getNextEntry ( ) ; \n \n \t5 overallCount ++ ; } \n \n \t4 logger . info ( <string_literal> , overallCount ) ; \n \n \t4 tx . success ( ) ; } } \n \n <ect>
\t2 resources < < new PublicIPResource ( \n \n \t3 value : networkInterface . association . publicIp \n \n \t2 ) } \n \n \t1 } catch ( NoSuchElementException e ) { \n \n <ect>
<comment> \n \n \t1 public void sendMessage ( byte [ ] data ) { \n \n \t2 if ( socket == null ) { \n \n <ect>
\t4 sid = observerCounter . getAndDecrement ( ) ; \n \n \t4 LOG . info ( <string_literal> + sid ) ; } \n \n \t2 } catch ( IOException e ) { \n \n \t3 closeSocket ( sock ) ; \n \n <ect>
\t4 } catch ( Throwable e ) { } } } \n \n \t2 return false ; } \n \n \t1 private void receive ( String msg , InetSocketAddress remoteAddress ) { \n \n <ect>
\t2 try { \n \n \t3 OvmStoragePool . prepareOCFS2Nodes ( _conn , cmd . getClusterName ( ) , params . toString ( ) ) ; \n \n \t3 return new Answer ( cmd , true , <string_literal> ) ; \n \n \t2 } catch ( XmlRpcException e ) { \n \n <ect>
\t3 if ( this . _dbId != CONNECTED_DB ) { \n \n \t4 _conn . close ( ) ; } \n \n \t3 _conn = null ; \n \n \t2 } catch ( final SQLException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 cache . put ( path , ( hit ? Boolean . TRUE : Boolean . FALSE ) ) ; } \n \n \t2 if ( hit == false ) \n \n \t2 { \n \n <ect>
\t4 MacOSXDockIcon . addDockIconListener ( ) ; \n \n \t3 <comment> \n \n \t3 SystrayService systrayService = new SystrayServiceJdicImpl ( ) ; \n \n <ect>
\t2 this . path = path ; \n \n \t2 this . count = count ; } \n \n \t1 public void run ( ) throws InterruptedException , KeeperException { \n \n \t2 try { \n \n <ect>
\t1 @ Override \n \n \t1 public OneTimeTokenAccount get ( final String username ) { \n \n \t2 try { \n \n \t3 if ( ! this . location . getFile ( ) . exists ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 Integer currentVM = _autoScaleVmGroupVmMapDao . countByGroup ( asGroup . getId ( ) ) ; \n \n \t2 Integer maxVm = asGroup . getMaxMembers ( ) ; \n \n \t2 if ( currentVM + numVm > maxVm ) { \n \n <ect>
\t5 recvCount . notify ( ) ; } \n \n \t4 try { \n \n \t5 commitTxIfNecessary ( ) ; \n \n \t4 } catch ( JMSException ex ) { \n \n <ect>
<comment> \n \n \t1 @ PreDestroy \n \n \t1 @ SneakyThrows \n \n \t1 public void destroy ( ) { \n \n <ect>
<comment> \n \n \t1 protected void createGoogleAppsPublicKey ( ) throws Exception { \n \n \t2 if ( ! isValidConfiguration ( ) ) { \n \n <ect>
\t1 String parentRelativePath = getParentRelativePath ( realAbsoluteFile ) ; \n \n \t1 synchronized ( this ) { \n \n \t1 progress . markAsIndexed ( inputFile ) ; \n \n \t1 indexFileAndParentDir ( inputFile , parentRelativePath ) ; } \n \n <ect>
\t4 pluginFile . delete ( ) ; \n \n \t4 if ( ! downloaded ) continue ; \n \n \t4 throw new PluginNotFoundException ( <string_literal> , ie1 ) ; \n \n \t3 } catch ( IllegalAccessException iae1 ) { \n \n <ect>
\t3 serialPort . notifyOnDataAvailable ( true ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 return new SerialCommunicationChannel ( serialPort ) ; \n \n \t2 } catch ( NoSuchPortException e ) { \n \n <ect>
\t7 visibilityFlags . put ( DOMNode . visibleToPublicUsers , parentNode . getProperty ( DOMNode . visibleToPublicUsers ) ) ; \n \n \t7 try { \n \n \t8 newNode . setProperties ( newNode . getSecurityContext ( ) , visibilityFlags ) ; \n \n \t7 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 Thread . currentThread ( ) . interrupt ( ) ; } \n \n \t1 LogLog . warn ( <string_literal> , e ) ; \n \n \t1 level = Level . toLevel ( p ) ; \n \n \t1 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t4 tinkerforgeDevice . switchSocketB ( getAddress ( ) , getUnit ( ) , BrickletRemoteSwitch . SWITCH_TO_OFF ) ; \n \n \t3 } else if ( newDimmValue == getMaxValue ( ) . shortValue ( ) ) { \n \n \t4 <comment> \n \n \t4 dimmState = new PercentValue ( new BigDecimal ( <number_literal> ) ) ; \n \n <ect>
\t2 for ( EnumDefinition e : database . getEnums ( schema ) ) { \n \n \t3 try { \n \n \t4 generateEnum ( e ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t5 GC100IRDevice gcDevice = new GC100IRDevice ( gc100ControlPoint , configURL , m , i , deviceType ) ; \n \n \t5 try { \n \n \t6 gcProps . put ( <string_literal> , gcDevice . getInetAddress ( ) . toString ( ) ) ; \n \n \t5 } catch ( UnknownHostException e ) { \n \n <ect>
\t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . CLIENT_ID ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , grantType ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . SECRET ) ) { \n \n <ect>
\t2 { \n \n \t2 try { \n \n \t3 Files . createDirectories ( dir ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 this . session = session ; } \n \n \t1 @ Override \n \n \t1 public void onComplete ( Exchange exchange ) { \n \n \t2 try { \n \n <ect>
\t3 LOG . info ( <string_literal> , window , start , end ) ; \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 for ( Map . Entry < String , Integer > entry : counts . entrySet ( ) ) { \n \n \t4 LOG . info ( <string_literal> , entry . getKey ( ) , entry . getValue ( ) ) ; } \n \n <ect>
\t5 log . warn ( <string_literal> , getDetails ( pd ) ) ; } } \n \n \t3 if ( noSaveDefault ( pd ) ) { \n \n <ect>
\t1 @ POST \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 @ Consumes ( { <string_literal> , <string_literal> } ) \n \n \t1 public String addFavoriteMovie ( FavoriteMovieXmlRootElement movie ) { \n \n <ect>
\t5 if ( jars != null ) { \n \n \t6 for ( File file : jars ) { \n \n \t7 annotationProcessor . scan ( file ) ; } } } } \n \n \t3 if ( ! annotationFound && allowAllClassesScan ) { \n \n <ect>
\t3 tarballPath = file . getCanonicalPath ( ) ; \n \n \t3 LOGGER . info ( <string_literal> + tarballPath ) ; \n \n \t3 break ; \n \n \t3 } else { \n \n <ect>
\t5 ldapDao . setResultAttributeMapping ( ldap . getAttributes ( ) ) ; \n \n \t5 final String [ ] attributes = ldap . getAttributes ( ) . keySet ( ) . toArray ( new String [ ldap . getAttributes ( ) . keySet ( ) . size ( ) ] ) ; \n \n \t5 constraints . setReturningAttributes ( attributes ) ; \n \n \t4 } else { \n \n <ect>
\t1 thread . interrupt ( ) ; } } \n \n public static ProcessEngine getProcessEngine ( String configurationResource ) { \n \n \t1 ProcessEngine processEngine = processEngines . get ( configurationResource ) ; \n \n \t1 if ( processEngine == null ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , collectionName , metadata ) ; \n \n \t3 this . mongoTemplate . insert ( holder , collectionName ) ; \n \n \t3 LOGGER . debug ( <string_literal> , ticket . getId ( ) ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testIsNotLastSegment ( ) { \n \n <ect>
\t3 mSeekBar ! ! . progress = mCurrentValue - mMinValue \n \n \t3 val unitsRight = view . findViewById ( R . id . seekBarPrefUnitsRight ) as TextView \n \n \t3 unitsRight . text = mUnitsRight \n \n \t2 } catch ( e : Exception ) { \n \n <ect>
\t4 result = result && routesRules . accept ( _advancedVisitor , router ) ; \n \n \t3 } else if ( router . getState ( ) == State . Stopped || router . getState ( ) == State . Stopping ) { \n \n \t4 s_logger . debug ( <string_literal> + router . getInstanceName ( ) + <string_literal> + router . getState ( ) + <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t2 String existSeparator = <string_literal> , nonExistSeparator = <string_literal> ; \n \n \t2 for ( int i = 0 ; i < uriList . length ; i ++ ) { \n \n \t3 if ( allExists ) { \n \n \t4 allExists = pathExists ( uriList [ i ] , conf ) ; \n \n <ect>
\t1 private XMLObject getSecurityTokenFromRequestedToken ( final RequestedSecurityToken reqToken , final Collection < WsFederationConfiguration > config ) { \n \n \t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 XMLObject securityToken = getAssertionFromSecurityToken ( reqToken ) ; \n \n \t2 if ( securityToken instanceof EncryptedData ) { \n \n <ect>
\t4 sLogger . debug ( <string_literal> ) ; \n \n \t3 } else { \n \n \t4 sLogger . debug ( <string_literal> ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t3 byte [ ] data = ( byte [ ] ) buffer ; \n \n \t3 sendWriteBuffer ( commandId , replayAddress , data , true ) ; \n \n \t2 } else { \n \n <ect>
\t3 createResultSimple ( javaContext , requiresAuthenticationResult ) } } } \n \n \t2 futureResult . onFailure { case x = > log . error ( <string_literal> , x ) } \n \n \t2 futureResult \n \n \t1 case None = > \n \n <ect>
\t1 return 1 \n \n matches = re . findall ( r <string_literal> , out ) \n \n stack_version = matches [ 0 ] if matches and len ( matches ) > 0 else None \n \n if not stack_version : \n \n <ect>
\t3 br . close ( ) ; \n \n \t3 ir . close ( ) ; \n \n \t3 fir . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 return ; } \n \n \t2 Peer oldPeer = peer ; \n \n \t2 peer = peer . dropHostName ( ) ; \n \n \t2 if ( peer == null ) { \n \n <ect>
\t2 StopWatch watch = new StopWatch ( ) ; \n \n \t2 super . afterPropertiesSet ( ) ; \n \n \t2 Boolean shutdownEager = CamelContextHelper . parseBoolean ( getContext ( ) , getShutdownEager ( ) ) ; \n \n \t2 if ( shutdownEager != null ) { \n \n <ect>
\t3 try { \n \n \t4 i2pSocket . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t5 s_logger . debug ( <string_literal> + vpc_id ) ; } } \n \n \t2 } catch ( SQLException e ) { \n \n \t3 throw new CloudRuntimeException ( <string_literal> , e ) ; } } \n \n \t1 private void upgradeResourceCount ( Connection conn ) { \n \n <ect>
\t3 + conf . getInt ( <string_literal> , 0 ) ) ; } \n \n \t1 Utilities . FILE_OP_LOGGER . trace ( <string_literal> , statsFile ) ; \n \n \t1 Output output = new Output ( statsFile . getFileSystem ( conf ) . create ( statsFile , true ) ) ; \n \n \t1 LOG . debug ( <string_literal> + statsFile ) ; \n \n <ect>
\t3 String [ ] templateNames = null ; \n \n \t3 client = new HttpClient ( ) ; \n \n \t3 method = new GetMethod ( url ) ; \n \n \t3 responseCode = client . executeMethod ( method ) ; \n \n <ect>
<comment> \n \n \t1 public void complete ( ) throws SQLException { \n \n \t2 <comment> \n \n \t2 if ( ! isValid ( ) ) { \n \n <ect>
\t2 except Exception as e : \n \n \t3 self . fail ( e ) \n \n \t2 finally : \n \n \t3 self . assertIsNotNone ( ntwk2 , <string_literal> ) \n \n <ect>
\t1 public boolean start ( ) { \n \n \t2 try { \n \n \t3 check ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 Ability ability = source . copy ( ) ; \n \n \t2 List < Ability > options = getPlayableOptions ( ability , game ) ; \n \n \t2 if ( options . isEmpty ( ) ) { \n \n <ect>
\t3 s_logger . error ( <string_literal> + startupCmd . getProxyVmId ( ) , e ) ; \n \n \t2 } catch ( OperationTimedoutException e ) { \n \n \t3 s_logger . error ( <string_literal> + startupCmd . getProxyVmId ( ) , e ) ; \n \n \t2 } catch ( OutOfMemoryError e ) { \n \n <ect>
\t5 log . warn ( <string_literal> , file ) ; \n \n \t5 return defaultProps ; } \n \n \t4 is = resource . openStream ( ) ; \n \n \t4 if ( is == null ) { \n \n <ect>
\t3 return delegate . execute ( spec ) ; \n \n \t2 } catch ( CompilationFailedException e ) { \n \n \t3 if ( spec . getCompileOptions ( ) . isFailOnError ( ) && spec . getScalaCompileOptions ( ) . isFailOnError ( ) ) { \n \n \t4 throw e ; } \n \n <ect>
\t5 indexMetaDataList . add ( indexMetaData ) ; \n \n \t4 } else { \n \n \t5 throw new IllegalStateException ( <string_literal> + indexFolderName + <string_literal> + indexPathId + <string_literal> ) ; } \n \n \t3 } else { \n \n <ect>
\t1 } catch ( TimeoutException e ) { \n \n \t1 LOG . warn ( <string_literal> + txnBatch . getCurrentTxnId ( ) + \n \n \t3 <string_literal> + endPoint , e ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 @ Override \n \n \t2 public void onRemoval ( RemovalNotification < CCMBridge . Builder , CachedCCMAccess > notification ) { \n \n \t3 CachedCCMAccess cached = notification . getValue ( ) ; \n \n \t3 if ( cached != null && cached . ccm != null ) { \n \n <ect>
\t2 transceiver . writeBuffers ( responder . respond ( transceiver . readBuffers ( ) ) ) ; \n \n \t1 } catch ( ClosedChannelException e ) { \n \n \t2 return ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t8 . put ( <string_literal> , true ) \n \n \t8 . put ( <string_literal> , JSON_MAPPER . writeValueAsBytes ( segment ) ) \n \n \t8 . build ( ) \n \n \t4 ) ; \n \n <ect>
\t2 } else { \n \n \t3 throw new RuntimeException ( <string_literal> \n \n \t5 + System . getProperty ( <string_literal> ) ) ; } } \n \n \t1 private void executeKill ( Process p , String logKillSequence ) throws Exception { \n \n <ect>
\t2 long period = startTime ; \n \n \t2 for ( ByteSequence job : list ) { \n \n \t3 js . schedule ( <string_literal> + ( count ++ ) , job , <string_literal> , startTime , period , - 1 ) ; } \n \n \t2 List < Job > test = js . getAllJobs ( ) ; \n \n <ect>
\t3 for ( InetAddressAndPort ep : liveEndpoints ) \n \n \t4 MessagingService . instance ( ) . sendOneWay ( message , ep ) ; \n \n \t3 Uninterruptibles . sleepUninterruptibly ( Integer . getInteger ( <string_literal> , <number_literal> ) , TimeUnit . MILLISECONDS ) ; } \n \n \t2 else \n \n <ect>
\t4 return new Answer ( cmd , false , <string_literal> ) ; } \n \n \t3 for ( ManagedObjectReference hostMOR : hosts ) { \n \n \t4 HostMO hostMo = new HostMO ( context , hostMOR ) ; \n \n \t4 hostMo . deletePortGroup ( cmd . getNicUuid ( ) . toString ( ) ) ; \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 int [ ] refCount = tokenRefMap . get ( tokenIdentifier ) ; \n \n \t1 if ( refCount == null ) { \n \n <ect>
\t4 log . warn ( <string_literal> + Constants . LIVE + <string_literal> ) ; } \n \n \t3 if ( ! Constants . LIVE . equalsIgnoreCase ( mode ) ) { \n \n \t4 log . debug ( <string_literal> + headers . toString ( ) ) ; \n \n <ect>
\t3 status = response . getStatus ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 logger . debug ( <string_literal> , e ) ; } \n \n \t2 if ( status != <number_literal> ) { \n \n <ect>
\t2 try ( PrintWriter printWriter = response . getWriter ( ) ) { \n \n \t3 response . setStatus ( status ) ; \n \n \t3 printWriter . print ( text ) ; \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
\t3 } catch ( final InvalidTicketException e ) { \n \n \t4 LOGGER . error ( <string_literal> , serviceCredential , e ) ; \n \n \t4 return generateErrorView ( e . getCode ( ) , new Object [ ] { serviceTicketId } , request , service ) ; \n \n \t3 } catch ( final AbstractTicketException e ) { \n \n <ect>
\t3 try { \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n \t3 } catch ( InterruptedException e ) { } } \n \n \t2 if ( count % <number_literal> == 0 ) { \n \n <ect>
\t4 logger . debug ( <string_literal> + service_id ) ; \n \n \t4 if ( name != null && name . isLiteral ( ) ) service_name = name . asLiteral ( ) . getString ( ) ; \n \n \t4 logger . debug ( <string_literal> + service_name ) ; \n \n \t4 if ( address != null && address . isLiteral ( ) ) service_address = address . asLiteral ( ) . getString ( ) ; \n \n <ect>
\t2 hostDownInCloudstack = wait_until ( <number_literal> , <number_literal> , self . checkHostStateInCloudstack , <string_literal> , ha_host . id ) \n \n \t2 # the test could have failed here but we will try our best to get host back in consistent state \n \n \t2 no_of_vms = self . noOfVMsOnHost ( ha_host . id ) \n \n \t2 no_of_vms = no_of_vms + self . noOfVMsOnHost ( other_host . id ) \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void printFormattedPayload ( ) { \n \n <ect>
\t4 _resourceCountDao . setResourceCount ( accountId , ResourceOwnerType . Account , type , ( newCount == null ) ? 0 : newCount . longValue ( ) ) ; \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( ! Long . valueOf ( oldCount ) . equals ( newCount ) && ( type != Resource . ResourceType . primary_storage && type != Resource . ResourceType . secondary_storage ) ) { \n \n <ect>
\t4 Destination replyTo = jmsMessage . getJMSReplyTo ( ) ; \n \n \t4 if ( replyTo != null ) { \n \n \t5 headers . put ( JmsHeaders . REPLY_TO , replyTo ) ; } } \n \n \t3 catch ( Exception ex ) { \n \n <ect>
\t8 <comment> \n \n \t7 isclosed = dfs . isFileClosed ( partPath ) ; } } \n \n \t5 Boolean truncated = ( Boolean ) refTruncate . invoke ( fs , partPath , bucketState . currentFileValidLength ) ; \n \n \t5 if ( ! truncated ) { \n \n <ect>
\t4 Object fieldValue = null ; \n \n \t4 try { \n \n \t5 fieldValue = f . get ( obj ) ; \n \n \t4 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t2 cb . append ( String . format ( <string_literal> , code ) ) ; } } \n \n \t1 final String scriptAsString = String . format ( <string_literal> %s \\ <string_literal> , \n \n \t2 cb . toString ( ) . replace ( <string_literal> , <string_literal> <string_literal> # <string_literal> \\ \\ # <string_literal> , # \n \n \t2 sb . toString ( ) ) ; \n \n <ect>
\t3 + <string_literal> ) ; } \n \n \t1 if ( null != tableName ) { \n \n \t1 LOG . info ( <string_literal> + tableName ) ; \n \n \t1 } else { \n \n <ect>
\t4 } catch ( final AgentUnavailableException e ) { \n \n \t5 s_logger . warn ( <string_literal> , e ) ; \n \n \t5 throw new ConnectionException ( true , <string_literal> , e ) ; \n \n \t4 } catch ( final OperationTimedoutException e ) { \n \n <ect>
\t6 PropertyKey propertyKey = StructrApp . getConfiguration ( ) . getPropertyKeyForDatabaseName ( node . getClass ( ) , key ) ; \n \n \t6 if ( propertyKey != null ) { \n \n \t7 Node dbNode = node . getNode ( ) ; \n \n \t7 if ( dbNode . hasProperty ( newKey ) ) { \n \n <ect>
\t2 final boolean ipCheck = ipPatternCanBeChecked ( remoteIp ) ; \n \n \t2 if ( ipCheck && ! ipPatternMatches ( remoteIp ) ) { \n \n \t3 return false ; } \n \n \t2 final String hostName = getRemoteHostName ( remoteIp ) ; \n \n <ect>
\t2 ErlideEventBus . register ( new NoRuntimeHandler ( ) ) ; \n \n \t2 ErlideEventBus . register ( new UIMessageReporter ( ) ) ; \n \n \t2 if ( SystemConfiguration . getInstance ( ) . isDeveloper ( ) ) { \n \n \t3 BackendManagerPopup . init ( ) ; } \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t1 <comment> \n \n \t1 TestingUtil . killCacheManagers ( manager ( 1 ) ) ; \n \n \t1 cacheManagers . remove ( 1 ) ; \n \n <ect>
\t1 String metricKey = StringUtils . substringBefore ( line , <string_literal> ) ; \n \n \t1 String value = line . substring ( metricKey . length ( ) + 1 ) ; \n \n \t1 saveMeasure ( context , inputFile , metricKey , KeyValueFormat . parseIntInt ( value ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 s_logger . warn ( <string_literal> + vm ) ; \n \n \t5 try { \n \n \t6 stateTransitTo ( vm , Event . OperationFailed , vm . getHostId ( ) ) ; \n \n \t5 } catch ( NoTransitionException e ) { \n \n <ect>
\t1 ** / \n \n \t1 <comment> \n \n \t1 runStatementOnDriver ( <string_literal> + Table . NONACIDPART + <string_literal> , confForTez ) ; \n \n \t1 rs = runStatementOnDriver ( <string_literal> + Table . NONACIDPART + <string_literal> , confForTez ) ; \n \n <ect>
\t5 hostsToRebalance = lbPlanner . getHostsToRebalance ( node . getMsid ( ) , avLoad ) ; \n \n \t5 if ( hostsToRebalance != null && ! hostsToRebalance . isEmpty ( ) ) { \n \n \t6 break ; \n \n \t5 } else { \n \n <ect>
\t6 ssl_truststore_password = params . ssl_truststore_password , ssl_keystore_password = params . ssl_keystore_password , \n \n \t6 stack_version_override = stack_version , skip_if_rangeradmin_down = not params . retryAble ) \n \n \t1 if params . stack_supports_core_site_for_ranger_plugin and params . enable_ranger_knox and params . security_enabled : \n \n \t1 if params . has_namenode : \n \n <ect>
\t2 getDateSeqOutput ( <string_literal> ) ) ; } \n \n @ Test \n \n public void testTime1 ( ) { \n \n \t1 if ( ! supportsTime ( ) ) { \n \n <ect>
\t4 NSTimestampFormatter formatter = new NSTimestampFormatter ( <string_literal> ) ; \n \n \t4 File renamedFile = new File ( pathForSiteConfig ( ) + <string_literal> + formatter . format ( new NSTimestamp ( ) ) ) ; \n \n \t4 sc . renameTo ( renamedFile ) ; } \n \n \t2 } catch ( NSForwardException ne ) { \n \n <ect>
\t4 users . addKerberosAuthentication ( userEntity , principal ) ; \n \n \t4 users . removeAuthentication ( userEntity , entity . getUserAuthenticationId ( ) ) ; \n \n \t3 } catch ( AmbariException e ) { \n \n \t4 <comment> \n \n <ect>
\t5 if ( key != null ) { \n \n \t6 configVo . setValue ( key . valueIn ( id ) == null ? null : key . valueIn ( id ) . toString ( ) ) ; \n \n \t6 configVOList . add ( configVo ) ; \n \n \t5 } else { \n \n <ect>
\t5 + response ) ; \n \n \t3 throw new CloudRuntimeException ( <string_literal> + url \n \n \t5 + <string_literal> + response ) ; } \n \n \t2 final InputStream is = method . getResponseBodyAsStream ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 ListResponse < ListElastistorPoolResponse > response = new ListResponse < ListElastistorPoolResponse > ( ) ; \n \n \t3 response . setResponses ( poolResponses ) ; \n \n \t3 return response ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t3 gb . setVersion ( 1 . <number_literal> ) ; \n \n \t3 Gson gson = gb . create ( ) ; \n \n \t3 status = gson . fromJson ( answer . getDetails ( ) , ConsoleProxyStatus . class ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 for ( int i = this . preProcessingIndex ; i >= 0 ; i -- ) { \n \n \t3 try { \n \n \t4 this . interceptors . get ( i ) . afterCompletion ( request , deferredResult ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t3 try { \n \n \t4 if ( null != sslmgr ) { \n \n \t5 sslmgr . setContext ( conn ) ; <comment> \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 protected boolean isTicketAuthenticityVerified ( final String ticketId ) { \n \n \t2 if ( this . cipherExecutor != null ) { \n \n <ect>
\t1 INSTANCE ; \n \n \t1 private static final Logger LOG = Logger . getLogger ( StorageInfo . ConvertExpirationTime . class ) ; \n \n \t1 @ Override \n \n \t1 public boolean apply ( @ Nullable Class arg0 ) { \n \n <ect>
\t2 final IndexRoutingTable indexShardRoutingTable = clusterState . routingTable ( ) . index ( index ) ; \n \n \t2 Set < Integer > shardIdsToFail = new HashSet < > ( ) ; \n \n \t2 for ( int i = 1 + randomInt ( numberOfShards - 1 ) ; i > 0 ; i -- ) { \n \n \t3 shardIdsToFail . add ( randomInt ( numberOfShards - 1 ) ) ; } \n \n <ect>
\t3 log . info ( <string_literal> + numPagesEncoded . get ( ) + \n \n \t5 <string_literal> + numPagesDecoded . get ( ) + \n \n \t5 <string_literal> + numPagesSplit . get ( ) ) ; \n \n \t3 if ( trackEncodingByteUsage ) { \n \n <ect>
\t6 if ( access . read ( ) == ' \\ n' ) { \n \n \t7 long start = lastEnd ; \n \n \t7 long size = pos - start ; \n \n \t7 if ( size > <number_literal> ) { \n \n <ect>
\t5 String ip = slavePoolr . master . getAddress ( slaveConn ) ; \n \n \t5 if ( ! masterIp . trim ( ) . equals ( ip . trim ( ) ) ) { \n \n \t6 PoolEmergencyResetMaster ( slaveIp , masterIp , username , password ) ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 PreparedStatement pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 while ( rs . next ( ) ) { \n \n \t4 Long id = rs . getLong ( 1 ) ; \n \n <ect>
\t4 } else { \n \n \t5 logger . info ( <string_literal> ) ; } \n \n \t4 for ( Map . Entry < Integer , Store < ByteArray , byte [ ] , byte [ ] > > entry : realStores . entrySet ( ) ) { \n \n \t5 InMemoryPutAssertionStorageEngine < ByteArray , byte [ ] , byte [ ] > engine = ( InMemoryPutAssertionStorageEngine < ByteArray , byte [ ] , byte [ ] > ) entry . getValue ( ) ; \n \n <ect>
\t3 setServerIsFound ( true ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t2 } else { \n \n \t3 setServerIsFound ( false ) ; \n \n <ect>
\t3 mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n \t3 JVMStabilityInspector . inspectThrowable ( e ) ; \n \n <ect>
\t4 LOG . debug ( <string_literal> + \n \n \t5 ci . getFullPartitionName ( ) + <string_literal> ) ; \n \n \t4 continue ; } \n \n \t3 if ( txnHandler . checkFailedCompactions ( ci ) ) { \n \n <ect>
\t4 int frequency = getSamplingRate ( ) ; \n \n \t4 length = ( float ) size / channels / ( bits / <number_literal> ) / frequency ; \n \n \t3 } ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t7 throw e ; } \n \n \t5 } catch ( SaslException e ) { \n \n \t6 LOG . error ( <string_literal> , e ) ; } } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 s_logger . info ( <string_literal> ) ; } } \n \n \t2 s_logger . info ( <string_literal> ) ; \n \n \t2 return false ; \n \n \t2 <comment> <ect>
\t2 out . close ( ) ; \n \n \t2 assertStoreHasExactly ( store , <string_literal> , <string_literal> ) ; \n \n \t2 readAssertEquals ( store , <string_literal> , <number_literal> ) ; \n \n \t2 readAssertEquals ( store , <string_literal> , <number_literal> ) ; \n \n <ect>
\t2 try { \n \n \t3 removeDecoder ( ctx ) ; \n \n \t3 return true ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 terminate ( pc ) ; } \n \n \t4 <comment> \n \n \t4 else if ( pc . getStartTime ( ) + <number_literal> < System . currentTimeMillis ( ) && pc . getThread ( ) . getPriority ( ) != Thread . MIN_PRIORITY ) { \n \n \t5 Log log = config . getRequestTimeoutLogger ( ) ; \n \n <ect>
\t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . node ( <string_literal> ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . node ( <string_literal> ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . node ( <string_literal> ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n <ect>
\t1 return context . getExportPluginClasses ( ) . stream ( ) \n \n \t2 . filter ( clazz - > { \n \n \t2 boolean isFromCurrentArtifact = clazz . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) . equals ( artifactUrl . get ( ) ) ; \n \n \t2 if ( isFromCurrentArtifact && exporterArtifact != rootArtifact ) { \n \n <ect>
\t3 rights . setType ( ContentType . TEXT ) ; \n \n \t3 entry . setRights ( rights ) ; \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
<comment> \n \n \t1 public boolean swapTask ( JobTask task , String replicaHostID , boolean kickOnComplete , int priority ) { \n \n \t2 if ( task == null ) { \n \n <ect>
\t5 } catch ( Throwable t ) { \n \n \t6 _log . error ( <string_literal> , t ) ; \n \n \t6 return ; } } \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t4 <comment> \n \n \t4 if ( state == PowerState . PowerOn ) { \n \n \t5 vmStates . put ( vmName , new HostVmStateReportEntry ( state , conn . getHostName ( ) ) ) ; } \n \n \t3 } catch ( final LibvirtException e ) { \n \n <ect>
\t3 message . setText ( i + <string_literal> + priority ) ; \n \n \t3 message . setIntProperty ( <string_literal> , i ) ; \n \n \t3 message . setJMSPriority ( priority ) ; \n \n \t3 if ( i > 0 && i % <number_literal> == 0 ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , defaultAttrs ) ; \n \n \t3 final Map < String , Object > defaultAttributesToRelease = new TreeMap < > ( String . CASE_INSENSITIVE_ORDER ) ; \n \n \t3 defaultAttrs . stream ( ) . forEach ( key - > { \n \n \t4 if ( attributes . containsKey ( key ) ) { \n \n <ect>
\t8 + <string_literal> \n \n \t8 + this . target + <string_literal> + this . methodName ) ; } } } } \n \n \t2 else { \n \n <ect>
\t2 return null ; } \n \n \t1 public boolean removeSnapshot ( String snapshotName , boolean removeChildren ) throws Exception { \n \n \t2 ManagedObjectReference morSnapshot = getSnapshotMor ( snapshotName ) ; \n \n \t2 if ( morSnapshot == null ) { \n \n <ect>
\t4 return value . getString ( ) ; \n \n \t3 } catch ( ValueFormatException vfe ) { \n \n \t4 return null ; } } \n \n \t2 public void dispose ( ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + rowCount + <string_literal> ) ; \n \n \t2 } catch ( SQLException e ) { \n \n \t3 s_logger . error ( <string_literal> + e . getMessage ( ) , e ) ; \n \n \t3 throw new CloudRuntimeException ( <string_literal> + e . getMessage ( ) , e ) ; } \n \n <ect>
\t4 boolean changed = snark . getStorage ( ) . recheck ( ) ; \n \n \t4 if ( changed ) \n \n \t5 updateStatus ( snark ) ; \n \n \t4 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t2 Collection < String > names = U . newHashSet ( spis . length ) ; \n \n \t2 for ( T spi : spis ) { \n \n \t3 <comment> \n \n <ect>
\t2 } ) ; \n \n \t2 try { \n \n \t3 remoteTxsFuture . get ( failTime - System . nanoTime ( ) , TimeUnit . NANOSECONDS ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t1 return tail ; } \n \n \t1 public void addOrMerge ( long offset , long end , boolean doMerge , boolean doLogNew ) { \n \n \t1 if ( doMerge && tail != null && tail . merge ( offset , end ) ) return ; \n \n \t1 if ( doLogNew ) { \n \n <ect>
\t4 Transaction txn = Transaction . open ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 if ( version != null ) { \n \n \t6 for ( DbUpgrade upgrade : versionUpgrades ) { \n \n <ect>
\t2 client ( ) . prepareIndex ( <string_literal> , <string_literal> ) \n \n \t4 . setSource ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) \n \n \t4 . get ( ) ; \n \n \t2 refresh ( ) ; \n \n <ect>
\t2 assertEquals ( 0 , compressed . position ( ) ) ; \n \n \t2 assertEquals ( compressedSize , compressed . limit ( ) ) ; \n \n \t2 assertEquals ( compressedSize , compressed . remaining ( ) ) ; \n \n \t2 int uncompressedLen = Snappy . uncompressedLength ( compressed ) ; \n \n <ect>
\t2 LOG . debug ( <string_literal> ) ; \n \n \t2 for ( Operator < ? > co : component ) { \n \n \t3 LOG . debug ( <string_literal> + co . getName ( ) + <string_literal> + co . getIdentifier ( ) ) ; } } \n \n \t2 if ( component . size ( ) != 1 ) { \n \n <ect>
\t1 LOG . info ( <string_literal> , componentName ) ; } \n \n @ Override \n \n public void onFailure ( Throwable t ) { \n \n \t1 if ( t instanceof CancellationException ) { \n \n <ect>
\t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t4 _log . debug ( <string_literal> + primary + <string_literal> + infoHash ) ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t1 tagKeys . addAll ( response . getDescribeTagsResult ( ) . getTagDescriptions ( ) . getMember ( ) . stream ( ) \n \n \t2 . flatMap ( tagDesc - > tagDesc . getTags ( ) . getMember ( ) . stream ( ) ) \n \n \t2 . map ( Tag : : getKey ) . collect ( Collectors . toSet ( ) ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 log . trace ( <string_literal> , local_addr , printDigest ( stability_digest ) ) ; \n \n \t3 num_stability_msgs_sent ++ ; \n \n \t3 down_prot . down ( msg ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 if ( ! state . attributes . isEmpty ( ) ) { \n \n \t3 try { \n \n \t4 cookieState = encoders [ 0 ] . encode ( state . attributes , storeContext ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t6 assert rsrc1 == rsrc5 ; \n \n \t6 assert rsrc2 == rsrc6 ; \n \n \t6 assert rsrc3 == rsrc7 ; \n \n \t6 assert rsrc4 == rsrc8 ; \n \n <ect>
\t2 initialize ( exchange ) ; \n \n \t2 String text = evaluateAsString ( exchange ) ; \n \n \t2 return new StringSource ( text ) ; } \n \n \t1 public Object evaluateAsBytesSource ( Exchange exchange ) throws Exception { \n \n <ect>
\t3 broker . waitUntilStopped ( ) ; } \n \n \t2 doStartBroker ( false ) ; } \n \n \t1 private void doStartBroker ( boolean delete ) throws Exception { \n \n \t2 doCreateBroker ( delete ) ; \n \n <ect>
\t2 if ( hivercFile . isFile ( ) ) { \n \n \t2 LOG . info ( <string_literal> + hivercFile ) ; \n \n \t2 int rc = processor . processFile ( hivercFile . getAbsolutePath ( ) ) ; \n \n \t2 if ( rc != 0 ) { \n \n <ect>
\t4 String moduleName = String . format ( <string_literal> , receivingModule . getId ( ) , receivingModule . getVersion ( ) ) ; \n \n \t4 Path finalPath = PathManager . getInstance ( ) . getHomeModPath ( ) . normalize ( ) . resolve ( moduleName ) ; \n \n \t4 if ( finalPath . normalize ( ) . startsWith ( PathManager . getInstance ( ) . getHomeModPath ( ) ) ) { \n \n \t5 if ( Files . exists ( finalPath ) ) { \n \n <ect>
\t3 svcName . set ( null ) ; \n \n \t3 try { \n \n \t4 run0 ( ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t2 if ( logListeners != null && ! logListeners . isEmpty ( ) ) { \n \n \t3 for ( Map . Entry < String , LogListener > entry : logListeners . entrySet ( ) ) { \n \n \t4 LogListener logListener = entry . getValue ( ) ; \n \n \t4 if ( ! camelContext . getLogListeners ( ) . contains ( logListener ) ) { \n \n <ect>
\t2 repository . setName ( name ) ; \n \n \t2 return repository ; } \n \n \t1 @ Override \n \n \t1 public List < RepositoryTag > getTags ( IRepositoryIdProvider repository ) throws IOException { \n \n <ect>
\t2 dbConn . rollback ( ) ; } \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 dbConn . commit ( ) ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t1 if ( isCacheUsable ( typeName , injectable ) ) { \n \n \t2 log . debug ( <string_literal> + typeName ) ; \n \n \t2 factorySource = generatedSourceByFactoryTypeName . get ( typeName ) ; \n \n \t1 } else { \n \n <ect>
\t3 try { \n \n \t4 val result = callback . call ( args . arg1 ( ) , args . arg ( <number_literal> ) , args . arg ( <number_literal> ) ) \n \n \t4 return result . tojstring ( ) \n \n \t3 } catch ( e : LuaError ) { \n \n <ect>
\t4 log . error ( <string_literal> , local_addr ) ; \n \n \t3 else { \n \n \t4 long time = System . nanoTime ( ) - hdr . start_time ; \n \n \t4 if ( time < = 0 ) \n \n <ect>
\t2 if ( pluginInfos . isEmpty ( ) ) { \n \n \t3 logger . info ( <string_literal> + type + <string_literal> ) ; \n \n \t2 } else { \n \n \t3 for ( final String name : pluginInfos . stream ( ) . map ( PluginInfo : : getName ) . sorted ( ) . collect ( Collectors . toList ( ) ) ) { \n \n <ect>
\t3 try { \n \n \t4 return createAlpnOpenListener ( ) ; \n \n \t3 } catch ( Throwable e ) { \n \n \t4 UndertowLogger . ROOT_LOGGER . alpnNotFound ( getName ( ) ) ; \n \n <ect>
\t1 protected AuthenticationBuilder authenticateInternal ( final AuthenticationTransaction transaction ) throws AuthenticationException { \n \n \t2 final Collection < Credential > credentials = transaction . getCredentials ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , credentials ) ; \n \n \t2 if ( credentials . isEmpty ( ) ) { \n \n <ect>
\t3 int currentSize = Gossiper . instance . getEndpointStates ( ) . size ( ) ; \n \n \t3 totalPolls ++ ; \n \n \t3 if ( currentSize == epSize ) \n \n \t3 { \n \n <ect>
\t6 return e ; } } \n \n \t3 } ) ; \n \n \t3 if ( maybeUnaligned instanceof Boolean ) { \n \n \t4 unaligned = ( Boolean ) maybeUnaligned ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 } else { \n \n \t4 return new Answer ( cmd , false , <string_literal> ) ; } \n \n \t3 return new Answer ( cmd , true , <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 if ( unwrappedToken != token ) { \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 connector = instance . getConnector ( accumuloParams . getAccumuloUserName ( ) , unwrappedToken ) ; \n \n \t2 } else { \n \n <ect>
\t1 if ( ! slotZnode . start ( znodeCreationTimeout , TimeUnit . SECONDS ) ) { \n \n \t2 throw new Exception ( \n \n \t3 <string_literal> + znodeCreationTimeout + <string_literal> ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 } catch ( SQLNonTransientConnectionException e ) { \n \n \t5 <comment> \n \n \t4 } catch ( SQLException e ) { \n \n \t5 context . setThrowable ( e ) ; \n \n <ect>
\t7 <string_literal> , \n \n \t7 from , to , networkId ) ) ; } \n \n \t2 if ( ! r . getResult ( ) ) { \n \n \t3 tunnel . setState ( OvsTunnel . State . Failed . name ( ) ) ; \n \n <ect>
\t1 this . keyStore . setKeyEntry ( alias , privateKey , keyPassword . toCharArray ( ) , new Certificate [ ] { cert } ) ; \n \n \t1 this . store ( ) ; } \n \n @ Override \n \n public void store ( ) throws IOException , GeneralSecurityException { \n \n <ect>
\t4 logger . warn ( <string_literal> , offset , reader . getPath ( ) ) ; } \n \n \t3 return - 1 ; } \n \n \t2 else if ( end < offset || end > reader . length ( ) ) \n \n \t2 { \n \n <ect>
\t1 public void deleteJob ( String jobId ) { \n \n \t2 try { \n \n \t3 executableDao . deleteJob ( jobId ) ; \n \n \t2 } catch ( PersistentException e ) { \n \n <ect>
\t3 final long [ ] stats = xcpServerResource . getNetworkStats ( conn , command . getPrivateIP ( ) ) ; \n \n \t3 final NetworkUsageAnswer answer = new NetworkUsageAnswer ( command , <string_literal> , stats [ 0 ] , stats [ 1 ] ) ; \n \n \t3 return answer ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t5 throw new AgentUnavailableException ( <string_literal> , _id ) ; } \n \n \t4 ch = s_clusteredAgentMgr . connectToPeer ( peerName , ch ) ; \n \n \t4 if ( ch == null ) { \n \n <ect>
\t2 if ( this . notificationMapper == null ) { \n \n \t3 this . notificationMapper = new DefaultNotificationMapper ( this . objectName , this . defaultNotificationType ) ; } \n \n \t2 exporter . registerManagedResource ( this . delegate , this . objectName ) ; \n \n <ect>
\t2 startModeSwitching ( ( ) - > \n \n \t2 { \n \n \t3 if ( cancellationHandle . cancellationRequested ( ) ) \n \n \t3 { \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t4 if ( e instanceof SocketTimeoutException ) { \n \n \t5 logger . warn ( <string_literal> ) ; \n \n \t4 } else if ( e instanceof IOException ) { \n \n <ect>
\t1 <comment> \n \n \t1 private void init ( ) { <comment> \n \n <ect>
\t1 workflow . aggregateDaily ( ) ; \n \n \t1 } catch ( final WorkflowExecutionAlreadyStartedException ex ) { \n \n \t1 ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( LoggingLevel . ERROR == runLoggingLevel ) { \n \n \t4 LOG . error ( <string_literal> , this . getEndpoint ( ) ) ; \n \n \t3 } else if ( LoggingLevel . WARN == runLoggingLevel ) { \n \n <ect>
\t5 if not isMyVmDirLink ( vmDir ) : \n \n \t6 logger . debug ( OvmHost . getAllVms , <string_literal> %vmDir ) \n \n \t6 continue \n \n \t5 if vms . has_key ( dir ) : \n \n <ect>
\t5 _processor . delegate ( ) . attachmentAvailable ( _processor , attachment ) ; } \n \n \t3 } catch ( Throwable t ) { \n \n \t4 if ( _processor . delegate ( ) != null ) { \n \n \t5 _processor . delegate ( ) . attachmentNotAvailable ( _processor , attachment , ERXExceptionUtilities . toParagraph ( t ) ) ; } \n \n <ect>
\t1 public CachingTicketRegistry ( final CipherExecutor cipherExecutor , final LogoutManager logoutManager ) { \n \n \t2 super ( cipherExecutor ) ; \n \n \t2 this . storage = Caffeine . newBuilder ( ) . initialCapacity ( INITIAL_CACHE_SIZE ) . maximumSize ( MAX_CACHE_SIZE ) \n \n \t3 . expireAfter ( new CachedTicketExpirationPolicy ( ) ) . removalListener ( new CachedTicketRemovalListener ( ) ) . build ( s - > { \n \n <ect>
\t6 . orElse ( null ) ; \n \n \t4 if ( StringUtils . isNotBlank ( sts ) ) { \n \n \t5 final SecurityTokenTicket stt = ticketRegistry . getTicket ( sts , SecurityTokenTicket . class ) ; \n \n \t5 if ( stt == null || stt . isExpired ( ) ) { \n \n <ect>
\t5 input . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n \t5 logger . error ( <string_literal> , e ) ; } } \n \n \t2 } else { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public String getName ( ) { \n \n <ect>
\t3 <comment> \n \n \t3 return false ; \n \n \t2 } catch ( Throwable t ) { \n \n \t3 <comment> \n \n <ect>
\t3 if ( lock == null ) { \n \n \t4 s_logger . debug ( <string_literal> ) ; \n \n \t4 return ; } \n \n \t3 if ( ! lock . lock ( <number_literal> ) ) { \n \n <ect>
\t1 return reply ; \n \n \t1 } catch ( NoSuchElementException e ) { \n \n \t1 throw new EucalyptusCloudException ( <string_literal> + request . getVolumeId ( ) + <string_literal> , e ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected void renameTempTargetFile ( ) { \n \n \t2 if ( tempTargetFile != null && tempTargetFile != targetFile ) { \n \n <ect>
\t3 job . submit ( ) ; \n \n \t2 } else { \n \n \t3 job . waitForCompletion ( true ) ; \n \n \t3 retVal = job . isSuccessful ( ) ? 0 : 1 ; \n \n <ect>
\t3 return ; } \n \n \t2 if ( configuration . getLoggingUseSyslog ( ) ) { \n \n \t3 <comment> \n \n \t3 if ( configuration . getLoggingSyslogHost ( ) . isEmpty ( ) ) { \n \n <ect>
<comment> \n \n private static ReentrantLock getLockFor ( String key ) { \n \n \t1 LOG . info ( <string_literal> , key ) ; \n \n \t1 if ( null == locks . get ( key ) ) { \n \n <ect>
\t4 wrapper . setSecure ( isSSLEnabled ( ) ) ; \n \n \t4 connections . put ( Long . valueOf ( socket ) , wrapper ) ; \n \n \t4 getExecutor ( ) . execute ( new SocketWithOptionsProcessor ( wrapper ) ) ; } \n \n \t2 } catch ( RejectedExecutionException x ) { \n \n <ect>
\t4 _log . debug ( <string_literal> + this + <string_literal> + timeoutMs + <string_literal> + _state ) ; \n \n \t3 if ( timeoutMs < = 0 ) { \n \n \t4 <comment> \n \n \t4 if ( timeoutMs < 0 && _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 partition . startDisrupting ( ) ; \n \n \t2 ensureStableCluster ( <number_literal> , master ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client ( replicaNode ) . prepareIndex ( <string_literal> , <string_literal> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <string_literal> , <string_literal> ) . endObject ( ) ) . get ( ) ; \n \n <ect>
<comment> \n \n \t1 public void removeFromCache ( String viewName , Locale locale ) { \n \n \t2 if ( ! isCache ( ) ) { \n \n <ect>
\t3 org . dspace . content . Item item = findItem ( context , itemId , org . dspace . core . Constants . WRITE ) ; \n \n \t3 org . dspace . content . Bitstream bitstream = bitstreamService . findByIdOrLegacyId ( context , bitstreamId ) ; \n \n \t3 if ( bitstream == null ) { \n \n \t4 context . abort ( ) ; \n \n <ect>
\t2 error . join ( ) ; \n \n \t2 } catch ( Exception t ) { \n \n \t2 LOG . error ( t ) ; } \n \n \t2 if ( ( outFileUncompressed != null ) && ( ! outFileUncompressed . renameTo ( file ) ) ) { \n \n <ect>
\t1 List < Partition > parts = client . listPartitions ( dbName , tableName , ( short ) - 1 ) ; \n \n \t1 LOG . info ( <string_literal> + parts . toString ( ) + <string_literal> ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 client . dropDatabase ( dbName , true , false , true ) ; \n \n <ect>
\t1 if ( ugi != null ) { \n \n \t2 if ( curUser != null && curUser . getUserName ( ) . equals ( ugi . getUserName ( ) ) ) { \n \n \t2 LOG . debug ( <string_literal> , ugi ) ; \n \n \t2 } else { \n \n <ect>
\t1 @ Override \n \n \t1 public void run ( ) { \n \n \t2 try { \n \n \t2 int threadId = waitForAllThreadsToStart ( this , threadCount ) ; \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public int getStatementCacheSize ( ) { \n \n <ect>
\t3 function . failOutputs . foreach ( _ . createNewFile ( ) ) \n \n \t3 writeStackTrace ( e ) \n \n \t3 } catch { \n \n \t3 case _ : Throwable = > <comment> } \n \n <ect>
\t3 final int position = requestBody . indexOf ( <string_literal> <string_literal> ' , position ) ; \n \n \t3 return requestBody . substring ( position , nextPosition ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t3 String errMsg = null ; \n \n \t3 try { \n \n \t4 deleteVDI ( conn , snapshotVdi ) ; \n \n \t3 } catch ( final BadServerResponse e ) { \n \n <ect>
\t5 ZoneSceneEnum . MINIMUM , false ) ; \n \n \t3 if ( transmitted ) { \n \n \t4 addEcho ( device . getDSID ( ) . getValue ( ) , ( short ) ZoneSceneEnum . MINIMUM . getSceneNumber ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t5 case <number_literal> : \n \n \t6 this . gain = <number_literal> ; \n \n \t6 break ; \n \n \t5 default : \n \n <ect>
\t2 0x8915 , # SIOCGIFADDR \n \n \t2 struct . pack ( '256s' , ifname [ : <number_literal> ] ) \n \n \t2 ) [ <number_literal> : <number_literal> ] ) \n \n \t1 except Exception , err : \n \n <ect>
\t4 if ( skipFailback ) { \n \n \t5 t = t . getCause ( ) ; } \n \n \t4 throw new IllegalStateException ( <string_literal> + url + <string_literal> + getUrl ( ) . getAddress ( ) + <string_literal> + t . getMessage ( ) , t ) ; \n \n \t3 } else { \n \n <ect>
\t3 } else { \n \n \t4 for ( String text : descriptionText ) { \n \n \t5 s_logger . info ( <string_literal> + text ) ; } } \n \n \t2 } else { \n \n <ect>
\t2 startUpCallback . onSuccess ( None . none ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public void onSuccess ( None result ) \n \n \t1 { \n \n <ect>
\t1 private ComponentGroup ( Map < ComponentId , TransactionalComponent > group ) { \n \n \t2 this . group . putAll ( group ) ; } \n \n \t1 public void add ( TransactionalComponent component ) { \n \n \t2 Objects . requireNonNull ( component ) ; \n \n <ect>
\t2 setupTestNodes ( Settings . EMPTY ) ; \n \n \t2 connectNodes ( testNodes ) ; \n \n \t2 CountDownLatch responseLatch = new CountDownLatch ( 1 ) ; \n \n \t2 boolean waitForActionToStart = randomBoolean ( ) ; \n \n <ect>
\t4 public void onComplete ( Exchange exchange ) { \n \n \t5 try { \n \n \t6 dataStore . delete ( exchange . getProperty ( KratiConstants . KEY ) ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t1 Logger . info ( <string_literal> . format ( expected_data ) ) \n \n \t1 sql_cmd = <string_literal> . format ( table [ 'name' ] ) \n \n \t1 _ , stdout , _ = exec_psql_cmd ( sql_cmd , self . active_master_host , self . active_master_port , tuples_only = False ) \n \n \t1 if expected_data != stdout . strip ( ) : \n \n <ect>
\t2 URI uri ; \n \n \t2 try { \n \n \t3 uri = new URI ( _downloadUrl ) ; \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
\t3 public boolean isSatisified ( ) throws Exception { \n \n \t4 try { \n \n \t5 Subscription sub = \n \n \t7 brokerService . getRegionBroker ( ) . getDestinationMap ( ) . get ( ActiveMQDestination . transform ( dest ) ) . getConsumers ( ) . get ( 0 ) ; \n \n <ect>
\t4 uploadMetricData ( upload ) ; \n \n \t4 LOG . debug ( <string_literal> , \n \n \t6 workerMetricInfo . get_metrics_size ( ) , System . currentTimeMillis ( ) - start ) ; \n \n \t3 } else { \n \n <ect>
\t1 protected void onAfterProcess ( Exchange exchange , Processor processor , ProcessorDefinition < ? > definition , long timeTaken , Breakpoint breakpoint ) { \n \n \t2 try { \n \n \t3 breakpoint . afterProcess ( exchange , processor , definition , timeTaken ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t3 Optional < UISkin > skin = Assets . getSkin ( moduleName + <string_literal> + skinUri ) ; \n \n \t3 if ( skin . isPresent ( ) ) { \n \n \t4 assetData . getRootWidget ( ) . setSkin ( skin . get ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 File destination = new File ( dir , filename ) ; \n \n \t2 try { \n \n \t3 write ( list , new FileOutputStream ( destination ) ) ; } \n \n \t2 catch ( Exception ioe ) { \n \n <ect>
\t2 <comment> <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t2 Exception e = expectThrows ( Exception . class , ( ) - > { \n \n \t4 QueryStringQueryBuilder qb = queryStringQuery ( <string_literal> ) ; \n \n \t4 if ( randomBoolean ( ) ) { \n \n \t5 qb . useAllFields ( true ) ; } \n \n <ect>
\t3 if ( defaultVoice == null ) { \n \n \t4 <comment> \n \n \t4 defaultVoice = Voice . getVoice ( marytts . getAvailableVoices ( ) . iterator ( ) . next ( ) ) ; } \n \n \t2 } catch ( MaryConfigurationException e ) { \n \n <ect>
\t2 } catch ( ResourceUnavailableException e ) { \n \n \t3 s_logger . warn ( <string_literal> + proxy . getHostName ( ) + <string_literal> , e ) ; \n \n \t3 return false ; \n \n \t2 } catch ( CloudRuntimeException e ) { \n \n <ect>
\t2 return match . orElse ( UNKNOWN ) ; } \n \n \t1 @ Override \n \n \t1 protected Event doExecute ( final RequestContext requestContext ) { \n \n \t2 final Event currentEvent = requestContext . getCurrentEvent ( ) ; \n \n <ect>
\t2 return transformation ( v , element , beforeVisitor , afterVisitor ) ; } \n \n \t1 protected Element transformation ( ApplyElementTransformVisitor transformApply , Element element , \n \n \t9 ElementVisitor beforeVisitor , ElementVisitor afterVisitor ) { \n \n \t2 if ( element == null ) { \n \n <ect>
\t8 throw new SevenZipException ( ) ; } \n \n \t7 return data . length ; } \n \n \t5 } ) ; \n \n \t4 } catch ( FileNotFoundException | SevenZipException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( isRunning ( old ) ) { \n \n \t3 <comment> \n \n \t3 if ( UserConfigurationCompare . configEqual ( secret , old ) ) { \n \n <ect>
\t2 try { \n \n \t3 this . document = Jsoup . parse ( text , url ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 this . document = null ; \n \n <ect>
\t7 logger . warn ( <string_literal> , path , ex . getMessage ( ) ) ; } \n \n \t5 } else { \n \n \t6 logger . warn ( <string_literal> , path ) ; } \n \n \t4 } else { \n \n <ect>
\t2 s_usageDao = _usageDao ; \n \n \t2 s_usageIPAddressDao = _usageIPAddressDao ; } \n \n \t1 public static boolean parse ( AccountVO account , Date startDate , Date endDate ) { \n \n <ect>
\t5 checkEntry ( grid ( i ) , backupKey , <number_literal> , false ) ; } } \n \n \t2 Map < Integer , Integer > nearKeys = new HashMap < > ( ) ; \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) \n \n \t3 nearKeys . put ( key ( grid0 , NOT_PRIMARY_AND_BACKUP ) , <number_literal> ) ; \n \n <ect>
\t4 LOGGER . debug ( e . getMessage ( ) , e ) ; } \n \n \t2 } ) ; } \n \n \t1 private File getMetadataBackupFile ( final AbstractResource metadataResource , \n \n \t9 final RegisteredService service ) throws IOException { \n \n <ect>
@ Override \n \n public void start ( ) { \n \n \t1 withContextClassLoader ( null , ( ) - > { \n \n <ect>
\t3 self . fail ( e ) \n \n \t2 finally : \n \n \t3 self . assert_ ( vm1 is not None , <string_literal> ) \n \n \t3 self . assert_ ( vm1 . state == 'Running' , <string_literal> ) \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 log . error ( <string_literal> , syncName ) ; \n \n \t3 throw new IllegalArgumentException ( <string_literal> + syncName ) ; } \n \n \t2 ExternalIdentityProvider idp = idpManager . getProvider ( idpName ) ; \n \n \t2 if ( idp == null ) { \n \n <ect>
\t1 _doRunnableTasks ( afterTasks , blockBuilder ) ; \n \n \t1 log . debug ( <string_literal> + ( System . currentTimeMillis ( ) - start ) + <string_literal> ) ; } \n \n private void doBeforeRunnables ( final BlockBuilder < ? > builder ) { \n \n \t1 long start ; \n \n <ect>
and place it in this directory before rerunning this script . ) \n \n -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - <string_literal> <string_literal> <ect>
<comment> \n \n \t1 public static LocationMapper createLocationMapper ( String configPath ) { \n \n \t2 if ( configPath == null || configPath . length ( ) == 0 ) { \n \n <ect>
\t3 mBlockLayoutRequests = false ; \n \n \t3 <comment> \n \n \t3 doDragFloatView ( movePos , moveItem , false ) ; \n \n \t3 mPrevTime = mCurrTime ; \n \n <ect>
<comment> \n \n @ Override \n \n public Set < ? extends NodeMetadata > suspendNodesMatching ( Predicate < ? super NodeMetadata > filter ) { \n \n <ect>
\t1 public void updateJob ( ) throws CommandException { \n \n \t2 InstrumentUtils . incrJobCounter ( getName ( ) , 1 , getInstrumentation ( ) ) ; \n \n \t2 coordJob . setSuspendedTime ( null ) ; \n \n \t2 coordJob . setLastModifiedTime ( new Date ( ) ) ; \n \n <ect>
\t3 int code = HttpServletResponse . SC_BAD_REQUEST ; \n \n \t3 response . setStatus ( code ) ; \n \n \t3 response . getWriter ( ) . append ( RestMethodResult . jsonError ( code , <string_literal> + jpex . getMessage ( ) ) ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 log . error ( <string_literal> , e ) ; } } } \n \n \t3 namedPluginClasses . put ( iname , <string_literal> ) ; \n \n \t3 if ( found == 0 ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> + usageRecords . second ( ) . intValue ( ) + <string_literal> + account . getAccountId ( ) + <string_literal> + account . getDomainId ( ) ) ; } \n \n \t3 List < QuotaUsageVO > quotaListForAccount = aggregatePendingQuotaRecordsForAccount ( account , usageRecords ) ; \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 log . error ( <string_literal> , e ) ; \n \n \t3 throw new MllpJUnitResourceException ( <string_literal> , e ) ; } \n \n \t2 if ( disconnectAfterSend ) { \n \n <ect>
\t3 try { \n \n \t4 PurgeTxnLog . purge ( logsDir , snapsDir , snapRetainCount ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 LOG . error ( <string_literal> , e ) ; } \n \n <ect>
\t2 _fetchEndTime = ( totalTimeout > 0 ? System . currentTimeMillis ( ) + totalTimeout : - 1 ) ; \n \n \t2 _fetchInactivityTimeout = ( int ) Math . min ( inactivityTimeout , Integer . MAX_VALUE ) ; \n \n \t2 _keepFetching = true ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 MessageProducer producer = session . createProducer ( queue ) ; \n \n \t2 int messageSize = <number_literal> * <number_literal> ; \n \n \t2 String messageText = createLargeString ( messageSize ) ; \n \n \t2 Message m = session . createTextMessage ( messageText ) ; \n \n <ect>
\t1 } else if ( result instanceof Range ) { \n \n \t1 LOG . info ( <string_literal> + result ) ; \n \n \t1 return Collections . singletonList ( ( Range ) result ) ; \n \n \t1 } else if ( result instanceof List ) { \n \n <ect>
\t1 <comment> \n \n \t1 private class BlockedConnectionHandler implements BlockedListener { \n \n \t2 @ Override \n \n \t2 public void handleBlocked ( String reason ) throws IOException { \n \n <ect>
\t3 if ( element == null ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> + Service . UserData . getName ( ) + <string_literal> ) ; } \n \n \t3 boolean result = element . saveUserData ( network , nicProfile , vmProfile ) ; \n \n \t3 if ( ! result ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void shutdown ( IRecordProcessorCheckpointer checkpointer , ShutdownReason reason ) { \n \n <ect>
\t7 LOG . info ( <string_literal> + txid ) ; \n \n \t7 broker . forgetTransaction ( null , txid ) ; } \n \n \t6 persistCompletion ( txid ) ; \n \n \t5 } catch ( Exception ex ) { \n \n <ect>
\t2 for ( int i = - 1 ; i < max ; ++ i ) { \n \n \t3 try { \n \n \t4 if ( ! brokerService . isStarted ( ) ) { \n \n \t5 if ( LOGGER . isLoggable ( Level . INFO ) ) { \n \n <ect>
\t2 this . listenerFactory = listenerFactory ; \n \n \t2 this . cachedClasspathTransformer = cachedClasspathTransformer ; } \n \n \t1 public ClassPath create ( ) { \n \n \t2 Collection < File > classpath = build ( ) ; \n \n <ect>
\t1 public boolean disable ( ) throws Exception { \n \n \t2 try { \n \n \t3 WorkflowClientManager . stop ( ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t3 if ( startx < 0 ) \n \n \t4 startx = 0 ; \n \n \t3 g . drawString ( text , startx , h / <number_literal> ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 GamesRoomManager . instance . removeTable ( tableId ) ; } } } \n \n \t1 public void debugServerState ( ) { \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 Collection < User > users = UserManager . instance . getUsers ( ) ; \n \n <ect>
\t4 } else { \n \n \t5 resultsF . put ( i , seconds ) ; } \n \n \t4 brokerService . stop ( ) ; \n \n \t4 brokerService . waitUntilStopped ( ) ; } } \n \n <ect>
\t3 long rowCountBeforeAggr = finalScanner instanceof GTAggregateScanner \n \n \t5 ? ( ( GTAggregateScanner ) finalScanner ) . getInputRowCount ( ) \n \n \t5 : finalRowCount ; \n \n \t3 appendProfileInfo ( sb , <string_literal> , serviceStartTime ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public void onEvent ( BoxEvent event ) { \n \n \t2 try { \n \n \t3 <comment> \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 ContentObject theObject = getHandle . get ( theName . name ( ) , <number_literal> ) ; \n \n \t4 if ( null == theObject ) { \n \n <ect>
\t4 indexStream . print ( <string_literal> ) ; \n \n \t4 indexStream . print ( type . struct . name ) ; \n \n \t4 indexStream . println ( <string_literal> ) ; \n \n \t4 Path typePath = apiRootPath . resolve ( type . struct . name + <string_literal> ) ; \n \n <ect>
\t2 try { \n \n \t3 messageDigest = MessageDigest . getInstance ( <string_literal> ) ; \n \n \t2 } catch ( NoSuchAlgorithmException exc ) { \n \n \t3 globalErrorDictionary . takeValueForKey ( ( <string_literal> ) , ( <string_literal> ) ) ; \n \n <ect>
\t5 SCPClient scp = new SCPClient ( conn ) ; \n \n \t5 scp . put ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) ; \n \n \t5 s_logger . info ( <string_literal> ) ; \n \n \t4 } catch ( Exception ex ) { \n \n <ect>
<comment> \n \n @ Override \n \n public void setPreference ( long userID , long itemID , float value ) throws TasteException { \n \n \t1 Preconditions . checkArgument ( ! Float . isNaN ( value ) , <string_literal> ) ; \n \n <ect>
\t3 ExprNodeDesc . ExprNodeDescEqualityWrapper . transform ( desc . getPartitionCols ( ) ) ; \n \n \t2 if ( keyCols != null && keyCols . equals ( partCols ) ) { \n \n \t2 desc . setReducerTraits ( EnumSet . of ( UNIFORM ) ) ; } } \n \n \t1 } else { \n \n <ect>
\t6 logger . debug ( \n \n \t8 <string_literal> + item + <string_literal> ) ; } \n \n \t5 config = new FritzahaQueryscriptMeter ( configParts [ 0 ] , configParts [ 1 ] , MeterType . ENERGY , timedef ) ; \n \n \t4 } else { \n \n <ect>
\t2 PlayerPumpInfo info = pumpProgress . computeIfAbsent ( profile , PlayerPumpInfo : : new ) ; \n \n \t2 info . lastPumpTick = world . getTotalWorldTime ( ) ; \n \n \t2 info . sourcesPumped ++ ; \n \n \t2 String name = profile . getName ( ) ; \n \n <ect>
\t2 Geometry JTSGeometry ; \n \n \t2 try { \n \n \t3 JTSGeometry = reader . read ( inGeomWKT ) ; \n \n \t2 } catch ( ParseException e1 ) { \n \n <ect>
\t3 q = new LinkedList < > ( ) ; \n \n \t3 snd = new GridThread ( ctx . config ( ) . getGridName ( ) , <string_literal> , worker ) ; \n \n \t3 snd . start ( ) ; } \n \n <ect>
\t2 try { \n \n \t3 Connection conn = factory . createConnection ( ) ; \n \n \t3 conn . close ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( i > 0 && i % <number_literal> == 0 ) { \n \n \t4 LOG . info ( <string_literal> + i + <string_literal> ) ; } \n \n \t3 template . sendBodyAndHeader ( URI , ExchangePattern . InOnly , <string_literal> + i , JmsConstants . JMS_DESTINATION_NAME , <string_literal> + i ) ; } \n \n <ect>
\t2 PublicIPAddress returnVal = findAvailableAndAssociatedWithNetwork ( input . getId ( ) , client . getAddressClient ( ) ) ; \n \n \t2 logger . debug ( <string_literal> , returnVal . getId ( ) ) ; \n \n \t2 return returnVal ; \n \n \t1 } catch ( NoSuchElementException e ) { \n \n <ect>
\t2 val LOG = LoggerFactory . getLogger ( SaveContentCommand : : class . java ) } \n \n \t1 @ AllowConcurrentEvents \n \n \t1 @ Subscribe \n \n \t1 fun saveContent ( event : SaveContentEvent ) { \n \n <ect>
\t2 if ( response . getEntity ( ) != null ) { \n \n \t3 <comment> \n \n \t3 MediaType mediaType = response . getEntity ( ) . getMediaType ( ) ; \n \n \t3 if ( mediaType != null ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
public InitiateMultipartUploadResponseType initiateMultipartUpload ( InitiateMultipartUploadType request ) throws S3Exception { \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n \t1 switch ( failObjectPut ) { \n \n \t1 case INTERNAL_ERROR : \n \n <ect>
\t5 } finally { \n \n \t6 prep . close ( ) ; } \n \n \t4 } catch ( SQLException e ) { \n \n \t5 <comment> \n \n <ect>
\t1 logger . error ( <string_literal> ) ; \n \n \t1 throw new BadCredentialsException ( <string_literal> ) ; } \n \n \t1 String encPassword = CommonUtil . encryptPassword ( username , password ) ; \n \n \t1 if ( ! encPassword . equals ( user . getPassword ( ) ) ) { \n \n <ect>
\t2 if ( numRecordsIn == null ) { \n \n \t3 try { \n \n \t4 numRecordsIn = ( ( OperatorMetricGroup ) streamOperator . getMetricGroup ( ) ) . getIOMetricGroup ( ) . getNumRecordsInCounter ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 queryEntry . queryState = QueryState . ERROR ; } } \n \n \t2 opProcessorConsumer . close ( ) ; \n \n \t2 QueryEntry runE = queryTracker . running . remove ( query . uuid ( ) ) ; \n \n \t2 if ( runE == null ) { \n \n <ect>
\t2 try { \n \n \t3 long index = Long . parseLong ( sindex ) ; \n \n \t3 result = xwiki . getDeletedDocument ( index , context ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 if ( res . success ( ) ) \n \n \t5 return res . byteSource ( ) ; \n \n \t4 <comment> \n \n <ect>
\t3 if ( routeStatus == ServiceStatus . Started ) { \n \n \t4 if ( ServiceHelper . isSuspended ( route . getConsumer ( ) ) ) { \n \n \t5 resumeOrStartConsumer ( route . getConsumer ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t2 if ( result != null && result . size ( ) > 0 ) { \n \n \t3 ipAddr = result . get ( 0 ) . getIpAddress ( ) ; \n \n \t3 privateIpAddr = result . get ( 0 ) . getPrivateIpAddress ( ) ; } } \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t6 try { \n \n \t7 _multicastSocket . receive ( receivePacket ) ; \n \n \t7 handlePacket ( receivePacket ) ; } \n \n \t6 catch ( Throwable t ) { \n \n <ect>
\t2 } else if ( blobMigrationCase == BlobMigrationCase . COPY_REFERENCES ) { \n \n \t3 result = new LoopbackBlobStoreFactory ( ) ; \n \n \t2 } else { \n \n \t3 result = new DummyBlobStoreFactory ( ) ; <comment> \n \n <ect>
\t3 LOG . error ( <string_literal> ) ; \n \n \t3 throw new IllegalArgumentException ( \n \n \t5 <string_literal> ) ; } \n \n \t2 if ( ObjectHelper . isEmpty ( namespaceName ) ) { \n \n <ect>
\t3 if ( Volume . Type . ROOT . equals ( volType ) ) { \n \n \t4 <comment> \n \n \t4 if ( ! ( Storage . StoragePoolType . NetworkFilesystem . equals ( poolType ) || \n \n \t6 Storage . StoragePoolType . Filesystem . equals ( poolType ) ) ) { \n \n <ect>
\t2 synchronized ( jobs ) { \n \n \t3 if ( ! isRestartScheduled ( ) ) { \n \n \t4 Jenkins . getInstance ( ) . checkPermission ( Jenkins . ADMINISTER ) ; \n \n \t4 addJob ( new RestartJenkinsJob ( getCoreSource ( ) ) ) ; \n \n <ect>
\t1 final List < Resource > filteredResources = new ArrayList < Resource > ( ) ; \n \n \t1 for ( final Resource resource : getResources ( ) ) { \n \n \t1 if ( type == resource . getType ( ) ) { \n \n \t2 if ( filteredResources . contains ( resource ) ) { \n \n <ect>
\t1 logger . debug ( <string_literal> + tx ) ; } \n \n \t1 tx . suspend ( ) ; \n \n \t1 logger . debug ( <string_literal> + tx ) ; \n \n <ect>
\t3 max = Math . max ( max , duration ) ; \n \n \t3 if ( duration == max ) { \n \n \t4 LOG . info ( <string_literal> + max + <string_literal> + i + <string_literal> + message . getText ( ) ) ; } \n \n \t3 sum += duration ; } \n \n <ect>
\t1 for ( HttpRequestFilter filter : request . getFilters ( ) ) { \n \n \t2 request = filter . filter ( request ) ; } \n \n \t1 checkRequestHasContentLengthOrChunkedEncoding ( request , \n \n \t3 <string_literal> + request ) ; \n \n <ect>
\t2 @ Override public Serializable execute ( ) { \n \n \t3 int arg = this . < Integer > argument ( 0 ) ; \n \n \t3 try { \n \n <ect>
\t2 while ( availableTime > 0 ) { \n \n \t3 try { \n \n \t4 ack = receivedCommands . poll ( availableTime , TimeUnit . MILLISECONDS ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t2 public boolean match ( long ssl , String hostname ) { \n \n \t3 ReferenceCountedOpenSslEngine engine = engineMap . get ( ssl ) ; \n \n \t3 if ( engine != null ) { \n \n \t4 return engine . checkSniHostnameMatch ( hostname ) ; } \n \n <ect>
\t3 if ( visitedClasses . containsObject ( selectedClass ) ) \n \n \t4 visitedClasses . removeObject ( selectedClass ) ; \n \n \t3 visitedClasses . insertObjectAtIndex ( selectedClass , 0 ) ; \n \n \t3 this . selectedClass = selectedClass ; } \n \n <ect>
\t1 public void testShuffleZ1Z3 ( ) throws Exception { \n \n \t2 testZonedRebalance ( <string_literal> , z1z3Current , z1z3Shuffle , z1z3StoresXml , z1z3Stores ) ; } \n \n \t1 @ Test ( timeout = <number_literal> ) \n \n \t1 public void testShuffleZ1Z3AndShuffleAgain ( ) throws Exception { \n \n <ect>
\t4 return null ; } \n \n \t3 <comment> \n \n \t3 if ( auth . processLogout ( wrappedRequest , response , new URLPatternMatcher ( ) ) ) { \n \n <ect>
\t4 String msg = \n \n \t6 <string_literal> + \n \n \t6 <string_literal> ; \n \n \t4 msg += ex . toString ( ) ; \n \n <ect>
\t1 private void tryToLoadPropertiesFromStream ( Properties props , String propName , InputStream is ) { \n \n \t2 try { \n \n \t3 props . load ( is ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 else { \n \n \t2 addObjectToBothSidesOfRelationshipWithKey ( object , $ { entity . prefixClassNameWithoutPackage } . $ { relationship . uppercaseUnderscoreName } _KEY ) ; } } \n \n public void removeFrom$ { relationship . capitalizedName } Relationship ( $relationship . actualDestination . classNameWithDefault object ) { \n \n <ect>
\t2 continue ; \n \n \t2 try { \n \n \t2 ts . add ( UUID . fromString ( iid ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 try { \n \n \t6 Properties mappings = \n \n \t8 PropertiesLoaderUtils . loadAllProperties ( this . schemaMappingsLocation , this . classLoader ) ; \n \n <ect>
\t2 for ( PluggableAPIAuthenticator authManager : authenticators ) { \n \n \t3 if ( authManager != null && authManager instanceof SAML2AuthManager ) { \n \n \t4 _samlAuthManager = ( SAML2AuthManager ) authManager ; } } \n \n \t2 if ( _samlAuthManager == null ) { \n \n <ect>
\t7 s_logger . debug ( <string_literal> + id ) ; \n \n \t7 _resourceMgr . createHostAndAgent ( id , resource , details , false , null , false ) ; \n \n \t7 s_logger . debug ( <string_literal> + id ) ; \n \n \t6 } else { \n \n <ect>
\t4 s_logger . warn ( <string_literal> + key + <string_literal> ) ; } \n \n \t3 if ( _locks . size ( ) == 0 ) { \n \n \t4 closeConnection ( ) ; } \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t5 if ( startSync0 != null ) { \n \n \t6 startSync0 . remove ( nodeId ) ; \n \n \t6 if ( startSync0 . isEmpty ( ) ) { \n \n <ect>
\t5 LOGGER . error ( <string_literal> + mail . toString ( ) ) ; \n \n \t5 if ( emailCount == 1 ) { \n \n \t6 throw mex ; } \n \n \t4 } catch ( XWikiException e ) { \n \n <ect>
\t2 Desktop . getDesktop . browse ( new URI ( MANUAL_DOWNLOAD_URL ) ) \n \n \t1 } catch { \n \n \t2 case e : Exception = > Main . showErrorDialog ( <string_literal> + MANUAL_DOWNLOAD_URL , \n \n \t2 e ) } \n \n <ect>
\t2 LOGGER . info ( <string_literal> ) ; \n \n \t2 configureSecureTransport ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> , ( Object [ ] ) this . igniteConfiguration . getCacheConfiguration ( ) ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 ExecutorService toShutdown = service ; \n \n \t1 service = null ; \n \n \t1 toShutdown . shutdownNow ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 public boolean end ( Writer writer , String body ) { \n \n \t2 for ( Iterator paramEntries = _parameters . iterator ( ) ; paramEntries . hasNext ( ) ; ) { \n \n \t3 Object iteratorEntryObj = paramEntries . next ( ) ; \n \n \t3 if ( ! MakeIterator . isIterable ( iteratorEntryObj ) ) { \n \n <ect>
\t4 if ( ! configChanges . storageChanged && configChanges . predefinedWorkspacesChanged ) refreshWorkspaces ( ) ; \n \n \t4 if ( configChanges . nameChanged ) repositoryNameChanged ( ) ; \n \n \t4 if ( configChanges . connectorsChanged ) { \n \n \t5 newState . connectors . restart ( config . get ( ) . getFederation ( ) ) ; } } \n \n <ect>
\t2 final String extension = FilenameUtils . getExtension ( alias ) ; \n \n \t2 boolean hasExtension = ! StringUtils . isEmpty ( extension ) ; \n \n \t2 if ( hasExtension ) { \n \n \t3 final String processorName = FilenameUtils . getBaseName ( alias ) ; \n \n <ect>
\t3 final String attributeName ) { \n \n \t2 final Authentication newAuthn = DefaultAuthenticationBuilder . newInstance ( authn ) \n \n \t4 . addAttribute ( attributeName , Boolean . TRUE ) \n \n \t4 . build ( ) ; \n \n <ect>
\t1 env . put ( <string_literal> , <string_literal> ) ; \n \n \t1 DirContext dnsContext = new InitialDirContext ( env ) ; \n \n \t1 log . info ( <string_literal> + domain ) ; \n \n \t1 Attributes attrs1 = dnsContext . getAttributes ( domain , new String [ ] { <string_literal> } ) ; \n \n <ect>
\t2 } catch ( NoSuchAlgorithmException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( NoSuchPaddingException e ) { \n \n <ect>
\t3 batchDelete ( bytekey ) ; } \n \n \t2 try { \n \n \t3 iterator . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 protected void checkProperty ( final URL webAppURL , final String propertyName , final int expectedCode , \n \n \t3 final String expectedBody ) throws Exception { \n \n \t2 final URI sysPropUri = new URI ( webAppURL . toExternalForm ( ) + PrintSystemPropertyServlet . SERVLET_PATH . substring ( 1 ) + <string_literal> \n \n \t4 + Utils . encodeQueryParam ( PrintSystemPropertyServlet . PARAM_PROPERTY_NAME , propertyName ) ) ; \n \n <ect>
\t6 if ( backupResult != null && hasOwnerVm ) { \n \n \t7 s_logger . info ( <string_literal> ) ; \n \n \t7 boolean chainConsolidated = false ; \n \n \t7 for ( String vmdkDsFilePath : backupResult . third ( ) ) { \n \n <ect>
\t2 try { \n \n \t2 StaticDatabasePropertyEntry . update ( <string_literal> , \n \n \t3 <string_literal> , <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 fileSystem . close ( ) ; \n \n \t2 return null ; } \n \n \t1 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public AccessTokenRequestDataHolder extract ( final HttpServletRequest request , final HttpServletResponse response ) { \n \n \t2 final String clientId = request . getParameter ( OAuth20Constants . CLIENT_ID ) ; \n \n \t2 final Set < String > scopes = OAuth20Utils . parseRequestScopes ( request ) ; \n \n <ect>
\t2 final UsernamePasswordCredential originalUserPass = ( UsernamePasswordCredential ) credential ; \n \n \t2 final UsernamePasswordCredential userPass = new UsernamePasswordCredential ( originalUserPass . getUsername ( ) , originalUserPass . getPassword ( ) ) ; \n \n \t2 if ( StringUtils . isBlank ( userPass . getUsername ( ) ) ) { \n \n \t3 throw new AccountNotFoundException ( <string_literal> ) ; } \n \n <ect>
\t2 FileStoreActionQueue . start ( ) \n \n \t2 localBroadCastManager . registerReceiver ( m_broadcastReceiver , intentFilter ) \n \n \t2 Logger . info ( TAG , <string_literal> ) \n \n \t2 Logger . info ( TAG , <string_literal> + TodoList ) \n \n <ect>
\t1 this . count = 0 ; \n \n \t1 this . nextRollCheck = MIN_RECORDS_BEFORE_ROLL_CHECK ; \n \n \t1 if ( rollIntervalMillis > 0 ) { \n \n \t1 this . nextRollTime = System . currentTimeMillis ( ) + rollIntervalMillis ; } \n \n <ect>
\t3 super ( p ) ; } \n \n \t2 @ Override \n \n \t2 public void handleMessage ( int group , byte cmd1 , Msg msg , DeviceFeature f , String fromPort ) { \n \n \t3 InsteonAddress a = f . getDevice ( ) . getAddress ( ) ; \n \n <ect>
\t2 } else { \n \n \t3 <comment> \n \n \t3 if ( ! disableCounter ) records = 0 ; \n \n \t3 else { \n \n <ect>
\t4 sgs . add ( _securityGroupDao . findById ( sgId ) ) ; } \n \n \t3 final Set < SecurityGroupVO > uniqueGroups = new TreeSet < SecurityGroupVO > ( new SecurityGroupVOComparator ( ) ) ; \n \n \t3 uniqueGroups . addAll ( sgs ) ; \n \n \t3 if ( userVm == null ) { \n \n <ect>
public static void halt ( final String msg , int status ) { \n \n \t1 halt ( status , new Runnable ( ) { \n \n \t1 @ Override \n \n \t1 public void run ( ) { \n \n <ect>
\t3 ObjectName objectName = new ObjectName ( MBEAN_NAME ) ; \n \n \t3 if ( ! mbeanServer . isRegistered ( objectName ) ) { \n \n \t4 mbeanServer . registerMBean ( instance , objectName ) ; } \n \n \t2 } catch ( JMException ex ) { \n \n <ect>
\t10 if ( users == null ) { \n \n <number_literal> s_logger . info ( <string_literal> ) ; \n \n <number_literal> url = server + <string_literal> + username + <string_literal> + username + <string_literal> ; \n \n \t10 } else { \n \n <ect>
\t4 assertCount ( index , <string_literal> + shard . getNode ( ) . getNodeName ( ) , <number_literal> ) ; } } } \n \n \t1 public void testSeqNoCheckpoints ( ) throws Exception { \n \n \t2 Nodes nodes = buildNodeAndVersions ( ) ; \n \n \t2 assumeFalse ( <string_literal> , nodes . getNewNodes ( ) . isEmpty ( ) ) ; \n \n <ect>
\t4 if ( l != null && l . size ( ) > 0 && l . get ( 0 ) . second ( ) . intValue ( ) > 0 ) { \n \n \t5 return true ; \n \n \t4 } else { \n \n <ect>
\t4 sequenceSet = test . get ( tx , String . valueOf ( j ) ) ; \n \n \t4 for ( int ix = 0 ; ix < NUM_ITERATIONS - 1 ; ix ++ ) { \n \n \t5 sequenceSet . remove ( startSequenceId ++ ) ; \n \n \t5 test . put ( tx , String . valueOf ( j ) , sequenceSet ) ; } } } \n \n <ect>
\t2 if ( scaleString != null ) { \n \n \t3 scale = Integer . parseInt ( scaleString ) ; } \n \n \t2 logger . debug ( <string_literal> , node . getNodeId ( ) , command . toString ( ) ) ; \n \n \t2 if ( converter == null ) { \n \n <ect>
\t6 log . error ( local_addr + <string_literal> + msg . getSrc ( ) ) ; \n \n \t5 return null ; } \n \n \t4 Address sender = msg . getSrc ( ) ; \n \n \t4 if ( view != null && ! view . containsMember ( sender ) ) { \n \n <ect>
public void onModelPeriodChanged ( final long period ) { \n \n \t1 try { \n \n \t1 managerInitializer . get ( ) . onModelPeriodChanged ( period ) ; \n \n \t1 } catch ( final WroRuntimeException e ) { \n \n <ect>
public SecurityGroup createSecurityGroup ( String name , Location location ) { \n \n \t1 String region = location . getId ( ) ; \n \n \t1 if ( region == null ) { \n \n \t2 return null ; } \n \n <ect>
\t5 fileOutputStream . close ( ) ; \n \n \t5 log . warn ( <string_literal> + filename ) ; \n \n \t4 } catch ( java . io . IOException exception ) { \n \n \t5 log . warn ( <string_literal> + exception ) ; } } \n \n <ect>
\t4 System . out . println ( <string_literal> + bnlVocalizations . getLength ( ) + <string_literal> + vocalWavDir + <string_literal> ) ; } \n \n \t2 } catch ( IOException e ) { \n \n \t3 e . printStackTrace ( ) ; } } \n \n \t1 public boolean compute ( ) throws IOException , UnsupportedAudioFileException { \n \n <ect>
\t3 final TicketDefinition metadata = this . ticketCatalog . find ( ticket ) ; \n \n \t3 if ( metadata == null ) { \n \n \t4 LOGGER . error ( <string_literal> , ticket . getId ( ) ) ; \n \n \t4 return ; } \n \n <ect>
\t6 try { \n \n \t7 doUnregister ( url ) ; \n \n \t7 failedUnregistered . remove ( url ) ; \n \n \t6 } catch ( Throwable t ) { <comment> \n \n <ect>
\t4 for ( int i = 0 ; i < results . length ; i ++ ) { \n \n \t5 results [ i ] = <string_literal> ; } \n \n \t4 return new SetFirewallRulesAnswer ( cmd , false , results ) ; } \n \n \t2 } catch ( final Throwable e ) { \n \n <ect>
\t3 this . writer = writer ; \n \n \t3 this . barcode = barcode ; } \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n <ect>
\t1 except Fail as ex : \n \n \t1 if is_last_try : # last try \n \n \t2 raise \n \n \t1 else : \n \n <ect>
<comment> \n \n \t4 if ( jarEntry != null ) { \n \n \t5 return ( URL ) getUrlMethod ( jarEntry ) . invoke ( jarEntry ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 txn . commit ( ) ; } \n \n \t3 throw new ServerException ( <string_literal> , naf ) ; } \n \n \t2 catch ( NaException nae ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t1 } catch ( SQLException ex ) { \n \n \t1 try { \n \n \t2 connection . rollback ( ) ; \n \n \t1 } catch ( SQLException ex2 ) { \n \n <ect>
\t1 protected void doStart ( ) throws Exception { \n \n \t2 super . doStart ( ) ; \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 executor = getEndpoint ( ) . createExecutor ( ) ; \n \n <ect>
\t5 logger . info ( <string_literal> , controllerName ) ; } \n \n \t4 if ( matcher . group ( <number_literal> ) . equals ( <string_literal> ) ) { \n \n \t5 String ip = config . get ( key ) . toString ( ) ; \n \n \t5 deviceConfig . setIP ( ip ) ; \n \n <ect>
\t4 <comment> \n \n \t4 logger . debug ( <string_literal> , ttx ) ; } \n \n \t3 catch ( TException tx ) \n \n \t3 { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , type ) ; \n \n \t3 return new GroovyPasswordEncoder ( properties . getType ( ) ) ; } \n \n \t2 if ( type . contains ( <string_literal> ) ) { \n \n \t3 try { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 boolean enableSSL = config . getBoolean ( WebOptions . SSL_ENABLED ) && SSLUtils . getSSLEnabled ( config ) ; \n \n \t2 if ( enableSSL ) { \n \n <ect>
\t3 _isMemoryLow = memoryLow ; } \n \n \t2 boolean memoryStarved = checkMemory ( _memoryStarvedThreshold , true ) ; \n \n \t2 if ( memoryStarved != _isMemoryStarved ) { \n \n \t3 if ( ! memoryStarved ) { \n \n <ect>
\t2 processEvent . fire ( <string_literal> ) ; \n \n \t2 int id = counter . getAndIncrement ( ) ; \n \n \t2 book . setId ( id ) ; \n \n \t2 collection . put ( id , book ) ; \n \n <ect>
\t1 for i in range ( iterations ) : \n \n \t1 Logger . info ( 'Try %d out of %d' % ( i + 1 , iterations ) ) \n \n \t1 code , out = shell . call ( formatZK_cmd , logoutput = False , user = params . hdfs_user ) \n \n \t1 if code == 0 : \n \n <ect>
\t1 protected void logCasValidationAssertion ( final Assertion assertion ) { \n \n \t2 LOGGER . debug ( <string_literal> , assertion . isValid ( ) ) ; \n \n \t2 LOGGER . debug ( <string_literal> , assertion . getPrincipal ( ) . getName ( ) ) ; \n \n \t2 LOGGER . debug ( <string_literal> , assertion . getAuthenticationDate ( ) ) ; \n \n <ect>
\t4 ReflectionHelper . setField ( config . getClass ( ) . getDeclaredField ( <string_literal> ) , config , false ) ; \n \n \t4 LOG . info ( <string_literal> , config . getUpdateCheck ( ) ) ; \n \n \t3 } catch ( Throwable e ) { \n \n \t4 <comment> \n \n <ect>
\t4 return false ; } \n \n \t3 Set < Policy > associatedPolicies = policy . getAssociatedPolicies ( ) ; \n \n \t3 <comment> \n \n \t3 if ( associatedPolicies == null || associatedPolicies . isEmpty ( ) ) { \n \n <ect>
\t1 try { \n \n \t1 KeyspaceDefinition ks_def = HFactory . createKeyspaceDefinition ( keyspace , \n \n \t2 <string_literal> , 1 , cf_defs ) ; \n \n \t1 cluster . addKeyspace ( ks_def ) ; \n \n <ect>
\t3 LOG . debug ( <string_literal> + fmtMsgInfo ( in_msg ) ) ; \n \n \t3 if ( in_msg . propertyExists ( <string_literal> ) ) { \n \n \t4 seq = in_msg . getIntProperty ( <string_literal> ) ; \n \n \t4 if ( ( haveFirstSeq ) && ( seq != ( lastSeq + 1 ) ) ) { \n \n <ect>
\t4 case POWER_STATE : \n \n \t5 logger . error ( <string_literal> , commmandType ) ; \n \n \t5 break ; \n \n \t4 case SHARP : \n \n <ect>
\t4 currency = currencyValue . toString ( ) ; } \n \n \t3 try { \n \n \t4 format . setCurrency ( Currency . getInstance ( currency ) ) ; \n \n \t3 } catch ( IllegalArgumentException iae ) { \n \n <ect>
\t5 ctx . config ( ) . getClockSyncSamples ( ) ) ; \n \n \t4 pendingSnapshot = snapshot ; \n \n \t4 while ( ! snapshot . ready ( ) ) { \n \n <ect>
\t4 _log . warn ( <string_literal> + _session ) ; \n \n \t3 nextDelay = _reduceTime ; \n \n \t2 } else if ( _reduceEnabled && now - lastActivity >= _reduceTime ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 public void testQueryContactStatus ( ) \n \n \t2 throws Exception \n \n \t1 { \n \n \t2 <comment> \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( isMyDirectAck ( msg ) ) { \n \n <ect>
\t4 converter = this . getStateConverter ( item , barrierOperatorState . getLabel ( ) ) ; } } \n \n \t2 logger . debug ( <string_literal> , event . getNodeId ( ) , item . getName ( ) , \n \n \t4 event . getValue ( ) ) ; \n \n \t2 if ( converter == null ) { \n \n <ect>
\t5 super ( text , false ) ; \n \n \t5 this . containedStacks = containedStacks ; } \n \n \t4 @ Override \n \n \t4 public void onClicked ( ) { \n \n <ect>
\t3 final byte [ ] token = EncodingUtils . decodeBase64 ( authorizationHeader . substring ( this . messageBeginPrefix . length ( ) ) ) ; \n \n \t3 if ( token == null ) { \n \n \t4 LOGGER . warn ( <string_literal> ) ; \n \n \t4 return null ; } \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void testStarted ( ) \n \n \t1 { \n \n <ect>
\t3 int code = HttpServletResponse . SC_BAD_REQUEST ; \n \n \t3 response . setStatus ( code ) ; \n \n \t3 response . getWriter ( ) . append ( RestMethodResult . jsonError ( code , <string_literal> + jpex . getMessage ( ) ) ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t3 this . graph = graph ; } \n \n \t2 @ Override \n \n \t2 public void abort ( ) { \n \n \t3 throw new UnsupportedOperationException ( <string_literal> ) ; \n \n <ect>
\t4 transportListener . onException ( e ) ; \n \n \t3 } catch ( RuntimeException e2 ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t2 clusterState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( 1 ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . RELOCATING ) . size ( ) , equalTo ( 1 ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . RELOCATING ) . get ( 0 ) . relocatingNodeId ( ) , equalTo ( <string_literal> ) ) ; \n \n <ect>
\t1 <comment> \n \n \t1 public void testLogInitialize ( ) { \n \n \t2 log = new GridJclLogger ( LogFactory . getLog ( GridJclLoggerTest . class . getName ( ) ) ) ; \n \n <ect>
\t2 final long numChunks = chunks . count ( ) ; \n \n \t2 final Object chunkSource = chunks . findOne ( ) . get ( <string_literal> ) ; \n \n \t2 final Object chunkDest = shards . findOne ( new BasicDBObject ( <string_literal> , new BasicDBObject ( <string_literal> , chunkSource ) ) ) ; \n \n \t2 LOG . info ( <string_literal> + chunkSource ) ; \n \n <ect>
\t3 try { \n \n \t4 final Constructor < ? > cstr = clazz . getDeclaredConstructor ( paramClasses ) ; \n \n \t4 return ( Tokenizer ) cstr . newInstance ( paramValues ) ; \n \n \t3 } catch ( IllegalArgumentException | IllegalAccessException | InstantiationException | InvocationTargetException | SecurityException e ) { \n \n <ect>
\t3 if ( defaultHandlerResolver . supports ( handlers , transaction ) ) { \n \n \t4 resolvedHandlers . addAll ( defaultHandlerResolver . resolve ( handlers , transaction ) ) ; } } \n \n \t2 if ( resolvedHandlers . isEmpty ( ) ) { \n \n \t3 throw new GeneralSecurityException ( <string_literal> ) ; } \n \n <ect>
\t1 { \n \n \t2 if ( ! startTimeIsSet ) \n \n \t3 Log . warn ( this , <string_literal> ) ; \n \n \t2 if ( ! finishTimeIsSet ) \n \n <ect>
\t3 . getSnapshots ( ) \n \n \t3 . get ( 0 ) \n \n \t3 . state ( ) ; \n \n \t2 assertThat ( state , equalTo ( SnapshotState . SUCCESS ) ) ; \n \n <ect>
\t3 log . debug ( <string_literal> ) ; } \n \n \t2 if ( channelFuture . cause ( ) != null ) { \n \n \t3 throw new RuntimeException ( channelFuture . cause ( ) ) ; } } \n \n \t1 private void onConnectTimeOut ( ) { \n \n <ect>
\t1 protected Endpoint createEndpoint ( String uri , String remaining , Map < String , Object > parameters ) throws Exception { \n \n \t2 CxfEndpoint result ; \n \n \t2 Object value = parameters . remove ( <string_literal> ) ; \n \n \t2 if ( value != null ) { \n \n <ect>
\t3 file = getFile ( PropertiesUtil . getProjectProperties ( ) . get ( <string_literal> ) . split ( <string_literal> ) ) ; } \n \n \t2 if ( file == null ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t4 screenshotFile = new File ( new File ( System . getProperty ( <string_literal> ) ) , testName + <string_literal> ) ; } \n \n \t3 FileUtils . copyFile ( sourceFile , screenshotFile ) ; \n \n \t3 LOGGER . info ( <string_literal> , testName , screenshotFile . getAbsolutePath ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 new Job ( i , PListTest . TaskType . CREATE , iterations ) . run ( ) ; } \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 for ( int i = 0 ; i < numLists ; i ++ ) { \n \n \t3 new Job ( i , PListTest . TaskType . ADD , iterations ) . run ( ) ; } \n \n <ect>
\t1 <comment> \n \n \t1 ps . execute ( ) ; \n \n \t1 } catch ( SQLException sqle ) { \n \n \t1 interruptParent = true ; \n \n <ect>
\t2 didParseClosingWebObjectTag ( ) ; } \n \n \t1 private void didParseText ( ) { \n \n \t2 if ( _contentText != null ) { \n \n <ect>
\t5 setSize ( ref . getSize ( ) ) ; } \n \n \t3 } else { \n \n \t4 <comment> \n \n \t4 queue = createQueue ( ) ; \n \n <ect>
\t2 exchange . getOut ( ) . setHeader ( OptaPlannerConstants . BEST_SOLUTION , event . getNewBestSolution ( ) ) ; \n \n \t2 try { \n \n \t3 getProcessor ( ) . process ( exchange ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 Response response = client . target ( generateURL ( <string_literal> , URL_PREFIX + ext ) ) . request ( ) \n \n \t5 . post ( Entity . entity ( bigJAXBElement , <string_literal> ) ) ; \n \n \t3 Assert . assertEquals ( HttpResponseCodes . SC_BAD_REQUEST , response . getStatus ( ) ) ; \n \n \t3 String entity = response . readEntity ( String . class ) ; \n \n <ect>
\t1 @ Before \n \n \t1 public void cleanDatabase ( ) { \n \n \t2 try ( final Tx tx = app . tx ( ) ) { \n \n \t3 final List < ? extends NodeInterface > nodes = app . nodeQuery ( ) . getAsList ( ) ; \n \n <ect>
\t5 logger . debug ( <string_literal> ) ; \n \n \t4 } else { \n \n \t5 logger . debug ( <string_literal> ) ; } \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t3 v = valueDataConversion . fromStorage ( v ) ; } \n \n \t3 sendEvent ( ( byte [ ] ) k , ( byte [ ] ) v , version , event ) ; } } \n \n \t1 boolean isSendEvent ( CacheEntryEvent < ? , ? > event ) { \n \n \t2 if ( isChannelDisconnected ( ) ) { \n \n <ect>
\t2 } catch ( NamingException e ) { \n \n \t3 LOGGER . debug ( e , <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 try { \n \n <ect>
public void testNamedFifo ( ) throws Exception { \n \n \t1 if ( Shell . WINDOWS ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t1 for ( String url : urls ) { \n \n \t2 url = url . trim ( ) ; \n \n \t2 if ( isActiveUrl ( url ) ) \n \n \t2 return url ; } } \n \n <ect>
<comment> \n \n \t1 Action action ( AtmosphereRequest req , AtmosphereResponse res ) throws IOException , ServletException { \n \n \t2 if ( ! Utils . properProtocol ( req ) ) { \n \n <ect>
\t6 InputStream input = method . getResponseBodyAsStream ( ) ; \n \n \t6 Element el = queryAsyncJobResult ( server , input ) ; \n \n \t6 Map < String , String > values = getSingleValueFromXML ( el , new String [ ] { <string_literal> , <string_literal> } ) ; \n \n \t6 if ( ( values . get ( <string_literal> ) == null ) || ( values . get ( <string_literal> ) == null ) ) { \n \n <ect>
\t2 vpc_off_4 = VpcOffering . create ( \n \n \t9 self . apiclient , \n \n \t9 self . services [ <string_literal> ] \n \n \t9 ) \n \n <ect>
\t1 log . warn ( <string_literal> + val ) ; } \n \n \t1 log . warn ( <string_literal> ) ; \n \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 Object val = s . nextId ( null ) ; \n \n <ect>
\t4 LOG . debug ( <string_literal> , sweepRev ) ; } \n \n \t3 store . findAndUpdate ( NODES , rootUpdate ) ; \n \n \t3 stats . calls ++ ; \n \n \t3 map . remove ( ROOT_PATH , rootRev ) ; \n \n <ect>
\t2 if ( ! zoneDir . exists ( ) || ! zoneDir . isDirectory ( ) ) { \n \n \t3 log . error ( <string_literal> + name + <string_literal> ) ; \n \n \t3 return null ; \n \n \t2 } else if ( ! zoneDir . canRead ( ) ) { \n \n <ect>
\t4 adminCms . getRequestContext ( ) . setCurrentProject ( cms . getRequestContext ( ) . getCurrentProject ( ) ) ; \n \n \t4 adminCms . getRequestContext ( ) . setRequestTime ( cms . getRequestContext ( ) . getRequestTime ( ) ) ; \n \n \t4 cmsForReadingProperties = adminCms ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 HashMap objectMap = state . getObjectMap ( ) ; \n \n \t1 oi = ( ObjectInstance ) objectMap . get ( key ) ; } \n \n \t1 { \n \n <ect>
\t2 Class < ? > params [ ] = new Class [ 1 ] ; \n \n \t2 params [ 0 ] = String . class ; \n \n \t2 Method executeM = findMethod ( c , <string_literal> , params ) ; \n \n \t2 if ( executeM == null ) { \n \n <ect>
\t4 continue ; } \n \n \t3 Answer answer = _agentMgr . easySend ( ssvm . getId ( ) , thiscpc ) ; \n \n \t3 if ( answer != null && answer . getResult ( ) ) { \n \n <ect>
\t3 String secretKey = user . getSecretKey ( ) ; \n \n \t3 String input = cloudIdentifier ; \n \n \t3 signature = signRequest ( input , secretKey ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 testNoOverrideBrowser ( clientId ) ; } \n \n \t1 private void testNoOverrideBrowser ( String clientId ) { \n \n \t2 oauth . clientId ( clientId ) ; \n \n \t2 String loginFormUrl = oauth . getLoginFormUrl ( ) ; \n \n <ect>
\t2 synchronized ( lock ) { \n \n \t3 if ( stopped ) { \n \n \t4 return terminationFuture ; } \n \n \t3 stopped = true ; } \n \n <ect>
\t5 logger . info ( modelFile . getName ( ) + <string_literal> ) ; } \n \n \t4 pw . close ( ) ; } \n \n \t3 assertEquals ( tag , true ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 ReflectionUtils . makeAccessible ( field ) ; \n \n \t6 final Expression exp = ( Expression ) ReflectionUtils . getField ( field , ( ( ViewState ) state ) . getViewFactory ( ) ) ; \n \n \t6 stateMap . put ( <string_literal> , StringUtils . defaultIfBlank ( exp . getExpressionString ( ) , exp . getValue ( null ) . toString ( ) ) ) ; \n \n \t5 } else { \n \n <ect>
\t5 if ( value instanceof String ) { \n \n \t6 String textValue = ( String ) value ; \n \n \t6 answer . add ( textValue ) ; } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 switch ( colInfo . getType ( ) ) { \n \n \t4 case Types . VARCHAR : \n \n \t5 if ( value != null && value . length ( ) > colInfo . getPrecision ( ) ) { \n \n \t6 value = value . substring ( 0 , colInfo . getPrecision ( ) ) ; \n \n <ect>
\t4 log . error ( <string_literal> , testBeanClass , e ) ; \n \n \t4 throw new Error ( e . toString ( ) , e ) ; <comment> \n \n \t3 if ( defaultBundle == null ) { \n \n \t4 if ( className . startsWith ( <string_literal> ) ) { \n \n <ect>
\t4 Entities . delete ( part ) ; } \n \n \t3 } else { \n \n \t3 LOG . debug ( <string_literal> + arg0 . getBucketName ( ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 shutdown ( ) ; \n \n \t3 server . stop ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 HttpResponse httpResponse = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , status ) ; \n \n \t1 channel . write ( httpResponse ) . addListener ( new ChannelFutureListener ( ) { \n \n \t2 public void operationComplete ( ChannelFuture future ) { \n \n \t2 <comment> \n \n <ect>
\t4 dao . setMethod ( HttpMethod . resolve ( rest . getMethod ( ) ) . name ( ) ) ; \n \n \t4 if ( StringUtils . isNotBlank ( rest . getBasicAuthPassword ( ) ) && StringUtils . isNotBlank ( rest . getBasicAuthUsername ( ) ) ) { \n \n \t5 dao . setBasicAuthPassword ( rest . getBasicAuthPassword ( ) ) ; \n \n \t5 dao . setBasicAuthUsername ( rest . getBasicAuthUsername ( ) ) ; \n \n <ect>
\t2 + sqlE . toString ( ) , sqlE ) ; } \n \n \t1 try { \n \n \t2 new ResultSetPrinter ( ) . printResultSet ( pw , results ) ; \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t2 WorkflowActionBean action = ( WorkflowActionBean ) aContext . getAction ( ) ; \n \n \t2 incrActionErrorCounter ( action . getType ( ) , <string_literal> , 1 ) ; \n \n \t2 int actionRetryCount = action . getRetries ( ) ; \n \n \t2 if ( actionRetryCount >= executor . getMaxRetries ( ) ) { \n \n <ect>
\t2 flosser . stopMonitoringNamespace ( name ) ; } \n \n \t1 @ AfterClass \n \n \t1 public static void tearDownAfterClass ( ) throws Exception { \n \n \t2 try { \n \n <ect>
\t3 protected void runInContext ( ) { \n \n \t4 try { \n \n \t5 doKeepAlive ( ) ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t1 sb . append ( <string_literal> ) . append ( tableName ) . append ( <string_literal> ) ; } \n \n \t1 sb . append ( <string_literal> + tableName + <string_literal> ) ; \n \n \t1 String tableHints = getConf ( ) . get ( SQLServerManager . TABLE_HINTS_PROP ) ; \n \n \t1 if ( tableHints != null ) { \n \n <ect>
\t2 if ( src instanceof String ) { \n \n \t3 try { \n \n \t4 return Integer . valueOf ( src . toString ( ) ) ; \n \n \t3 } catch ( NumberFormatException nfex ) { \n \n <ect>
\t6 ! name . startsWith ( ROUTERINFO_PREFIX ) || \n \n \t6 ! name . endsWith ( ROUTERINFO_SUFFIX ) || \n \n \t6 ! f . isFile ( ) ) { \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 LOGGER . warn ( <string_literal> <string_literal> <ect>
\t1 @ Override \n \n \t1 public RandomAccessBucket createShadow ( ) { \n \n \t2 TempFileBucket ret = new TempFileBucket ( filenameID , generator , false ) ; \n \n \t2 ret . setReadOnly ( ) ; \n \n <ect>
\t1 throw new NoSuchRecordException ( <string_literal> + resourceId ) ; \n \n \t1 } catch ( EucalyptusCloudException e ) { \n \n \t1 throw e ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 servers = getServers ( admin ) \n \n \t1 begin \n \n \t1 servername = getServerName ( servers , hostname , port ) \n \n \t1 rescue ArgumentError = > e \n \n <ect>
\t3 configFiltersInstances . add ( configFilter ) ; \n \n \t3 configFilterPatternCache . put ( configFilter . getName ( ) , \n \n \t4 createConfigFilterPattern ( configFilter ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( InstantiationException ie ) { \n \n \t3 log . error ( <string_literal> + toolActionType + <string_literal> ) ; \n \n \t3 log . error ( <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 return False , 1 \n \n \t1 def disconnectHostfromNetwork ( self , hostIp , timeout ) : \n \n \t2 srcFile = os . path . dirname ( os . path . realpath ( __file__ ) ) + <string_literal> \n \n \t2 if not ( os . path . isfile ( srcFile ) ) : \n \n <ect>
\t2 } ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 ActionFuture < CreateSnapshotResponse > future = client ( masterNode1 ) . admin ( ) . cluster ( ) \n \n \t3 . prepareCreateSnapshot ( <string_literal> , <string_literal> ) . setWaitForCompletion ( false ) . setIndices ( idxName ) . execute ( ) ; \n \n <ect>
\t2 ERXApplication . _startRequest ( ) ; \n \n \t2 try { \n \n \t3 return _call ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 + <string_literal> \n \n \t4 + <string_literal> + <string_literal> \n \n \t4 + <string_literal> + <string_literal> ; \n \n \t2 Document doc = postAsDOM ( <string_literal> , xml ) ; \n \n <ect>
\t3 return null ; } \n \n \t2 final Map < String , MultifactorAuthenticationProvider > providerMap = \n \n \t4 MultifactorAuthenticationUtils . getAvailableMultifactorAuthenticationProviders ( this . applicationContext ) ; \n \n \t2 if ( providerMap == null || providerMap . isEmpty ( ) ) { \n \n <ect>
\t3 ActiveMQDestination destination1 = getConsumer1Destination ( ) ; \n \n \t3 ActiveMQDestination destination2 = getConsumer2Destination ( ) ; \n \n \t3 MessageConsumer c1 = session . createConsumer ( destination1 , null ) ; \n \n \t3 MessageConsumer c2 = session . createConsumer ( destination2 , null ) ; \n \n <ect>
\t2 if ( ssoUser == null || ! ssoUser . getActive ( ) ) { \n \n \t3 LOG . debug ( String . format ( <string_literal> , user , group ) ) ; \n \n \t3 final CloudianGroup ssoGroup = getClient ( ) . listGroup ( group ) ; \n \n \t3 if ( ssoGroup == null ) { \n \n <ect>
\t1 public synchronized void sendMessage ( ApnsNotification m ) throws NetworkIOException { \n \n \t2 sendMessage ( m , false ) ; \n \n \t2 drainBuffer ( ) ; } \n \n \t1 private synchronized void sendMessage ( ApnsNotification m , boolean fromBuffer ) throws NetworkIOException { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void leftCluster ( ) \n \n \t1 { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 final AuthenticationResult authenticationResult = this . authenticationSystemSupport . handleAndFinalizeSingleAuthenticationTransaction ( service , credential ) ; \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 WebUtils . putTicketGrantingTicketInScopes ( context , this . centralAuthenticationService . createTicketGrantingTicket ( authenticationResult ) ) ; \n \n <ect>
\t1 public List < AtmosphereRequest > onTextStream ( WebSocket webSocket , Reader data ) { \n \n \t2 LOG . debug ( <string_literal> , data ) ; \n \n \t2 String connectionKey = store . getConnectionKey ( webSocket ) ; \n \n \t2 consumer . sendMessage ( connectionKey , data ) ; \n \n <ect>
\t2 broker . getSystemUsage ( ) . setSendFailIfNoSpaceAfterTimeout ( <number_literal> ) ; \n \n \t2 Runnable r = new Runnable ( ) { \n \n \t3 public void run ( ) { \n \n \t4 try { \n \n <ect>
\t6 eventPublisher . postUpdate ( item , state ) ; } } } \n \n \t3 if ( client != null ) { \n \n \t4 client . disconnect ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 assertBusy ( ( ) - > { \n \n \t3 <comment> \n \n \t3 List < TaskInfo > tasks = client ( ) . admin ( ) . cluster ( ) . prepareListTasks ( ) . setActions ( TestPersistentTasksExecutor . NAME + <string_literal> ) . get ( ) \n \n \t5 . getTasks ( ) ; \n \n <ect>
\t2 try { \n \n \t3 return 0xff & buffer [ ( int ) ( readCount % maxMemorySize ) ] ; \n \n \t2 } catch ( ArrayIndexOutOfBoundsException ex ) { \n \n \t3 logger . error ( <string_literal> , ex ) ; \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , list , ticketClass ) ; \n \n \t2 return list ; } \n \n \t1 @ Override \n \n \t1 public void register ( final TicketDefinition ticketDefinition ) { \n \n <ect>
\t5 eventPublisher . postCommand ( itemName , command ) ; } \n \n \t3 } ; \n \n \t3 mqttService . registerMessageConsumer ( brokerName , commandSubscriber ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 modified = true ; } } \n \n \t2 m . put ( materializationName , materialization ) ; } \n \n \t1 Map < String , Materialization > result = m . build ( ) ; \n \n <ect>
\t7 <string_literal> + depCls + <string_literal> + d . sampleClassName ( ) + \n \n \t7 <string_literal> + d . sampleClassName ( ) + <string_literal> + meta + ' ] ' ) ; \n \n \t5 return d ; } \n \n <ect>
\t5 pstmt . setString ( 1 , resourceType ) ; \n \n \t5 pstmt . setLong ( <number_literal> , accountId ) ; \n \n \t5 rs = pstmt . executeQuery ( ) ; \n \n \t5 if ( ! rs . next ( ) ) { \n \n <ect>
\t4 appender . append ( newLogEvent ) ; \n \n \t3 } else { \n \n \t4 LOGGER . warn ( <string_literal> , refName ) ; } \n \n \t2 } else { \n \n <ect>
\t6 log . info ( <string_literal> + rsrc1 ) ; \n \n \t6 log . info ( <string_literal> + rsrc2 ) ; \n \n \t6 log . info ( <string_literal> + rsrc3 ) ; \n \n \t6 log . info ( <string_literal> + rsrc4 ) ; \n \n <ect>
\t3 entryCount = strategy . getEntryCount ( ) ; \n \n \t3 return result ; } } \n \n \t1 private SortStrategy createSortStrategy ( File dir ) { \n \n \t2 if ( useTraverseWithSort ) { \n \n <ect>
\t2 BulkActivityDeleteResponse response = deleteMapper . execute ( activityIds ) ; \n \n \t2 <comment> \n \n \t2 { \n \n <ect>
\t2 sizeToUse = powerOfTwo ( sizeToUse ) ; \n \n \t2 synchronized ( this ) { \n \n \t3 DisruptorReference ref = getDisruptors ( ) . get ( key ) ; \n \n \t3 if ( ref == null ) { \n \n <ect>
\t3 return packageConfig ; } \n \n \t2 PackageConfig . Builder newPackage = buildPackageContext ( packageElement ) ; \n \n \t2 if ( newPackage . isNeedsRefresh ( ) ) { \n \n \t3 return newPackage . build ( ) ; } \n \n <ect>
\t3 for ( AsyncMessageCallback cbi : cb ) { \n \n \t4 try { \n \n \t5 cbi . fatalError ( ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t4 replacement . setProperty ( mbp . getName ( ) , mbp . getInitialValue ( ) ) ; } } \n \n \t2 replacement . initialize ( ) ; \n \n \t2 if ( adapter == null ) { \n \n <ect>
\t4 if ( ! proxyingService . getProxyPolicy ( ) . isAllowedToProxy ( ) ) { \n \n \t5 LOGGER . warn ( <string_literal> , proxyingService . getId ( ) , service . getId ( ) ) ; \n \n \t5 throw new UnauthorizedProxyingException ( UnauthorizedProxyingException . MESSAGE + registeredService . getId ( ) ) ; } \n \n \t3 } else { \n \n <ect>
\t3 logger . error ( <string_literal> , ae ) ; \n \n \t3 throw ae ; } } \n \n \t1 @ Test ( timeout = <number_literal> ) \n \n \t1 public void testRORWRebalanceWithReplication ( ) throws Exception { \n \n <ect>
\t5 locked = true ; \n \n \t5 Long agentId = null ; \n \n \t5 VmRulesetLogVO log = _rulesetLogDao . findByVmId ( userVmId ) ; \n \n \t5 if ( log == null ) { \n \n <ect>
\t2 LOG . warn ( <string_literal> + e , e ) ; \n \n \t2 fail ( e . toString ( ) ) ; } \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 outputClient . complete ( ) ; \n \n <ect>
\t4 tree . addVertex ( cn ) ; } } \n \n \t2 Node source , target ; \n \n \t2 for ( LabeledLink l : model . getGraph ( ) . edgeSet ( ) ) { \n \n \t3 if ( ! ( l . getSource ( ) instanceof InternalNode ) ) { \n \n <ect>
\t2 Thread . sleep ( sleepMillis ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t2 <comment> \n \n \t2 isRunning = false ; \n \n <ect>
\t2 endpoint . expectedMessageCount ( ( int ) dataSet . getSize ( ) ) ; \n \n \t2 endpoint . expectedHeaderReceived ( <string_literal> , <number_literal> ) ; \n \n \t2 <comment> \n \n \t2 MockEndpoint . assertIsSatisfied ( context , <number_literal> , TimeUnit . SECONDS ) ; \n \n <ect>
\t6 uri . startsWith ( <string_literal> ) ? getElementAt ( Integer . parseInt ( uri . substring ( <number_literal> ) ) ) : \n \n \t6 <comment> \n \n \t6 get ( uri ) ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t5 s_logger . info ( <string_literal> + ( shutdownWaitMs / <number_literal> ) + <string_literal> + vmName ) ; \n \n \t5 return powerOffNoCheck ( ) ; } \n \n \t4 return true ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 return null ; \n \n \t3 } else { \n \n \t4 return jobStoreGit . fetchJobConfigFromHistory ( jobId , commit ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 ctrl . getCommandFactoryMap ( ) . get ( MultipleValueEditColumnCommand . class . getSimpleName ( ) ) ; \n \n \t3 MultipleValueEditColumnCommand mvecc = ( MultipleValueEditColumnCommand ) mfc . createCommand ( multiCellEditInput , model , workspace ) ; \n \n \t3 mvecc . doIt ( workspace ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 context = createContext ( ) ; \n \n \t3 if ( ! configurationService . getBooleanProperty ( <string_literal> , true ) ) { \n \n \t4 context . turnOffAuthorisationSystem ( ) ; } \n \n \t3 if ( ! ( ( limit != null ) && ( limit >= 0 ) && ( offset != null ) && ( offset >= 0 ) ) ) { \n \n <ect>
\t2 } catch ( ClassNotFoundException e ) { \n \n \t3 LOG . error ( <string_literal> + ClassName , e ) ; \n \n \t3 bloomFilter = null ; \n \n \t2 } catch ( InstantiationException e ) { \n \n <ect>
<comment> \n \n \t1 default Set < AuthenticationHandler > resolve ( Set < AuthenticationHandler > candidateHandlers , AuthenticationTransaction transaction ) { \n \n \t2 final String handlers = candidateHandlers . stream ( ) . map ( AuthenticationHandler : : getName ) . collect ( Collectors . joining ( <string_literal> ) ) ; \n \n <ect>
\t4 for ( ColumnFamilyStore cfs : selfWithIndexes ) \n \n \t4 { \n \n \t5 if ( ! cfs . getDataTracker ( ) . getCompacting ( ) . isEmpty ( ) ) \n \n \t5 { \n \n <ect>
\t1 public void tearDown ( ) throws Exception { \n \n \t2 super . tearDown ( ) ; \n \n \t2 DefaultCamelContext dcc = ( DefaultCamelContext ) context ; \n \n \t2 while ( ! dcc . isStopped ( ) ) { \n \n <ect>
\t6 try { \n \n \t7 blobContainer . deleteBlob ( blobName ) ; \n \n \t6 } catch ( IOException e ) { \n \n \t7 <comment> \n \n <ect>
\t1 Clusters clusters = injector . getInstance ( Clusters . class ) ; \n \n \t1 StringBuilder clusterDump = new StringBuilder ( ) ; \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t3 throw new CloudRuntimeException ( <string_literal> , e ) ; } } \n \n \t1 private void fixRouterKeys ( Connection conn ) { \n \n \t2 <comment> \n \n \t2 List < String > keys = new ArrayList < String > ( ) ; \n \n <ect>
\t2 assertEquals ( <string_literal> , <number_literal> , index ) ; \n \n \t2 assertNotEquals ( <string_literal> , \n \n \t5 filenames [ 0 ] , \n \n \t5 filenames [ 1 ] ) ; \n \n <ect>
\t5 if ( request == null ) \n \n \t6 loaded . addPartiallyLoadedRequest ( reqID , null , RequestLoadStatus . FAILED ) ; \n \n \t4 } catch ( StorageFormatException e ) { \n \n \t5 if ( request == null ) { \n \n <ect>
\t3 sslc . init ( kmf . getKeyManagers ( ) , null , _context . random ( ) ) ; \n \n \t3 _factory = sslc . getServerSocketFactory ( ) ; \n \n \t3 return true ; \n \n \t2 } catch ( GeneralSecurityException gse ) { \n \n <ect>
\t2 expected . setExclusive ( true ) ; \n \n \t2 expected . setExclusive ( true ) ; \n \n \t2 expected . setPrefetchSize ( <number_literal> ) ; \n \n \t2 try { \n \n <ect>
\t2 CompletableFuture < Acknowledge > request = pendingSlotRequest . getRequestFuture ( ) ; \n \n \t2 if ( null != request ) { \n \n \t3 request . completeExceptionally ( new SlotAllocationException ( cause ) ) ; \n \n \t2 } else { \n \n <ect>
\t5 String indexFileSizeInBytes = ( String ) checksumMetadata . get ( CheckSumMetadata . INDEX_FILE_SIZE_IN_BYTES ) ; \n \n \t5 if ( indexFileSizeInBytes != null ) { \n \n \t6 indexSizeInBytes += Long . parseLong ( indexFileSizeInBytes ) ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 LoadBalancerSecurityGroup group ; \n \n \t1 try { \n \n \t2 group = LoadBalancerSecurityGroupEntityTransform . INSTANCE . apply ( groupView ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t5 persistenceUnitName \n \n \t3 ) ; \n \n \t3 final boolean matches = persistenceUnitName == null || persistenceUnit . getName ( ) . equals ( persistenceUnitName ) ; \n \n \t3 if ( ! matches ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 internalCluster ( ) . startNode ( Settings . builder ( ) . put ( Node . NODE_DATA_SETTING . getKey ( ) , false ) . build ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client ( ) . admin ( ) . indices ( ) . prepareCreate ( <string_literal> ) . setWaitForActiveShards ( ActiveShardCount . NONE ) . execute ( ) . actionGet ( ) ; \n \n <ect>
\t6 String p = ( String ) f . get ( null ) ; \n \n \t6 if ( p != null ) { \n \n \t7 known . add ( p ) ; } \n \n \t5 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t3 throw new ChecksumFailedException ( message , cause ) ; } \n \n \t2 else if ( ! ArtifactRepositoryPolicy . CHECKSUM_POLICY_IGNORE . equals ( checksumPolicy ) ) \n \n \t2 { \n \n \t3 <comment> \n \n <ect>
\t3 for ( UUID id : itemsToReindex ) { \n \n \t4 Item item = itemService . find ( ctx , id ) ; \n \n \t4 authorityService . indexItem ( ctx , item ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 File databaseFileObj = new File ( sqoopDataDirObj , <string_literal> ) ; \n \n \t1 return databaseFileObj . toString ( ) ; } \n \n private void init ( ) { \n \n \t1 if ( null != server ) { \n \n <ect>
\t6 callContext . getCallingAccountId ( ) , callContext . getCallingUserId ( ) ) ; \n \n \t5 reallyRun ( ) ; \n \n \t5 AsyncJobExecutionContext . unregister ( ) ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t3 } else { \n \n \t4 InputStream is = getConfigInputStream ( servletContext ) ; \n \n \t4 final SamlDeployment deployment ; \n \n \t4 if ( is == null ) { \n \n <ect>
\t3 log . debug ( <string_literal> + inputCharset ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n \t3 try { \n \n \t4 getRequest ( ) . setCharacterEncoding ( CHARSET_DEFAULT ) ; \n \n <ect>
\t2 <comment> \n \n \t2 @ SuppressWarnings ( <string_literal> ) \n \n \t2 @ Override protected void body ( ) throws InterruptedException { \n \n <ect>
\t4 log . info ( <string_literal> , getEolByte ( ) ) ; } \n \n \t4 log . debug ( <string_literal> , this , getClassname ( ) , Integer . toHexString ( tcpClient . hashCode ( ) ) ) ; <comment> \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 remoteLogger . callAppenders ( event ) ; } } } \n \n \t1 } catch ( java . io . EOFException e ) { \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 } catch ( java . net . SocketException e ) { \n \n <ect>
\t3 try { \n \n \t4 List fieldInfos = QueryAnalyzer . toSearchFieldInfos ( searchResultWithBLOBs . getQuerytext ( ) , type ) ; \n \n \t4 savedQueries . add ( new SearchQueryInfo ( searchResultWithBLOBs . getQueryname ( ) , fieldInfos ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testBeforeAfterDate ( ) { \n \n <ect>
\t4 KVMStoragePool pool = getStoragePool ( store . getPoolType ( ) , store . getUuid ( ) ) ; \n \n \t4 StorageAdaptor adaptor = getStorageAdaptor ( pool . getType ( ) ) ; \n \n \t4 result = adaptor . connectPhysicalDisk ( vol . getPath ( ) , pool , disk . getDetails ( ) ) ; \n \n \t4 if ( ! result ) { \n \n <ect>
\t1 protected void error ( Throwable e , String msg ) { \n \n \t2 errors_ += <string_literal> ; \n \n \t2 if ( null != e ) { \n \n \t3 errors_ += e . toString ( ) + <string_literal> ; \n \n <ect>
\t4 enumerateOneSegment ( dir_chunk ) ; \n \n \t4 i = PMGLheader . getBlockNext ( ) ; \n \n \t4 dir_chunk = null ; } \n \n \t2 } catch ( ChmParsingException e ) { \n \n <ect>
\t2 if ( dbConnection != null ) { \n \n \t3 try { \n \n \t4 dbConnection . close ( ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t5 executeQueueItem ( item , false ) ; \n \n \t4 } else { \n \n \t5 break ; } \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t6 osgiFilter ) ; } \n \n \t2 catch ( InvalidSyntaxException ex ) \n \n \t2 { \n \n \t3 serRefs = null ; \n \n <ect>
\t4 cmds . addCommand ( <string_literal> , plugNicCmd ) ; \n \n \t4 _agentMgr . send ( dest . getHost ( ) . getId ( ) , cmds ) ; \n \n \t4 final PlugNicAnswer plugNicAnswer = cmds . getAnswer ( PlugNicAnswer . class ) ; \n \n \t4 if ( plugNicAnswer == null || ! plugNicAnswer . getResult ( ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 public String sayHi ( ) { \n \n <ect>
\t3 try { \n \n \t4 reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , <string_literal> ) ) ; \n \n \t4 return ( ZWaveNode ) stream . fromXML ( reader ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 ConcurrentOperationException , ResourceUnavailableException { \n \n \t2 if ( router . getRole ( ) != Role . VIRTUAL_ROUTER || ! router . getIsRedundantRouter ( ) ) { \n \n \t3 return this . start ( router , user , caller , params , null ) ; } \n \n \t2 if ( router . getState ( ) == State . Running ) { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , result , this . script ) ; \n \n \t4 return result . toString ( ) ; } \n \n \t2 } catch ( final Exception e ) { \n \n \t3 LOGGER . error ( e . getMessage ( ) , e ) ; } \n \n <ect>
\t2 configure ( ) ; \n \n \t2 super . start ( ) ; } \n \n \t1 protected void checkIntegrity ( ) { \n \n \t2 for ( SystemIntegrityChecker checker : getBeans ( SystemIntegrityChecker . class ) ) { \n \n <ect>
\t2 ndv = oldEst . estimateNumDistinctValues ( ) ; \n \n \t2 aggregateData . setNdvEstimator ( oldEst ) ; \n \n \t1 } else { \n \n \t2 ndv = Math . max ( aggregateData . getNumDVs ( ) , newData . getNumDVs ( ) ) ; } \n \n <ect>
\t3 _lastWrite = _file . lastModified ( ) ; \n \n \t3 _size = rv ; \n \n \t3 return rv ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t1 protected void sendCount ( final int count , final int code ) { \n \n \t2 for ( int i = 0 ; i < count ; ++ i ) { \n \n \t3 send ( code ) ; } } \n \n \t1 protected void assertNumberReceived ( final int count ) throws InterruptedException { \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName + <string_literal> + replDumpId , driver ) ; \n \n \t1 incrementalDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 incrementalDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t4 { \n \n \t5 buffer = computeNextInternal ( ) ; } \n \n \t4 catch ( EOFException e ) \n \n \t4 { \n \n <ect>
\t4 cache . get ( state . getId ( ) ) . addAll ( actions ) ; \n \n \t3 } else { \n \n \t4 cache . put ( state . getId ( ) , Queues . newConcurrentLinkedQueue ( actions ) ) ; } \n \n \t3 statesWithCandidates . add ( state . getId ( ) ) ; \n \n <ect>
\t2 url = file . getAbsoluteFile ( ) . toURL ( ) ; \n \n \t2 } else { \n \n \t2 logger . debug ( <string_literal> + file . getAbsolutePath ( ) ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 log . debug ( <string_literal> + authorizable . getID ( ) + <string_literal> ) ; \n \n \t4 return ; } } \n \n \t2 Principal principal = authorizable . getPrincipal ( ) ; \n \n \t2 if ( administrativePrincipals . contains ( principal . getName ( ) ) ) { \n \n <ect>
<comment> \n \n \t1 public static void putWarnCookieIfRequestParameterPresent ( final CookieGenerator warnCookieGenerator , final RequestContext context ) { \n \n \t2 if ( warnCookieGenerator != null ) { \n \n <ect>
\t2 final HashMap < String , Pair < String , State > > changes = new HashMap < String , Pair < String , State > > ( ) ; \n \n \t2 synchronized ( _cluster . intern ( ) ) { \n \n \t3 HashMap < String , Pair < String , State > > newStates = getAllVms ( conn ) ; \n \n \t3 if ( newStates == null ) { \n \n <ect>
\t5 field . setUseRootPaths ( true ) ; \n \n \t5 field . setCmsObject ( m_cms ) ; \n \n \t5 m_ouResources . addRow ( field ) ; } } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t1 if ( arg0 . length != 1 ) { \n \n \t1 LOG . error ( <string_literal> ) ; \n \n \t1 throw new HiveException ( <string_literal> ) ; } \n \n \t1 if ( arg0 [ 0 ] . get ( ) == null ) { \n \n <ect>
\t1 incrementInvalidations ( ) ; \n \n \t1 final InvalidateCommand invalidateCommand = commandsFactory . buildInvalidateCommand ( EnumUtil . EMPTY_BIT_SET , keys ) ; \n \n \t1 invalidateCommand . setTopologyId ( rpcManager . getTopologyId ( ) ) ; \n \n <ect>
\t2 { \n \n \t3 stream . injectPacket ( pkt , false , this ) ; } \n \n \t2 catch ( TransmissionFailedException e ) \n \n \t2 { \n \n <ect>
\t1 public void addPersistentRequests ( List < ClientRequest > v , boolean onlyForever ) { \n \n \t2 synchronized ( this ) { \n \n \t3 for ( ClientRequest req : runningPersistentRequests ) { \n \n \t4 if ( req == null ) { \n \n <ect>
\t3 if ( c == null || c . isClosed ( ) ) \n \n \t4 return ; \n \n \t3 refreshSchema ( c , targetType , targetKeyspace , targetName , signature , cluster ) ; \n \n \t2 } catch ( ConnectionException e ) { \n \n <ect>
\t1 long targetDate = DateUtils . addDays ( new Date ( analysisDate ) , - days ) . getTime ( ) ; \n \n \t1 SnapshotDto snapshot = findNearestSnapshotToTargetDate ( snapshots , targetDate ) ; \n \n \t1 if ( snapshot == null ) { \n \n \t1 return null ; } \n \n <ect>
\t2 m_hosts . put ( hostEntity . getHostId ( ) , host ) ; } \n \n \t1 } catch ( Exception e ) { \n \n \t2 LOG . warn ( <string_literal> + \n \n \t2 <string_literal> , hostMappingEntity . getHostname ( ) , configGroupName ) ; \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t1 public void swapSeats ( final String sessionId , final UUID roomId , final UUID tableId , final int seatNum1 , final int seatNum2 ) throws MageException { \n \n \t2 execute ( <string_literal> , sessionId , ( ) - > { \n \n \t3 Optional < Session > session = SessionManager . instance . getSession ( sessionId ) ; \n \n \t3 if ( ! session . isPresent ( ) ) { \n \n <ect>
\t2 try { \n \n \t2 if ( input != null ) { \n \n \t3 input . close ( ) ; } \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t2 } catch ( HttpException e ) { \n \n \t3 logger . warn ( <string_literal> , e ) ; \n \n \t3 return false ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 break ; } \n \n \t5 Message message = consumer . receive ( max ) ; \n \n \t5 if ( message == null ) { \n \n \t6 continue ; } \n \n <ect>
\t4 if ( info . equals ( <string_literal> ) ) \n \n \t5 return true ; \n \n \t4 Log . warning ( Log . FAC_REPO , <string_literal> + info ) ; } \n \n \t2 } catch ( ContentDecodingException e ) { \n \n <ect>
\t1 JobHandleImpl < ? > handle = jobs . get ( msg . jobId ) ; \n \n \t1 if ( handle != null ) { \n \n \t2 handle . getMetrics ( ) . addMetrics ( msg . sparkJobId , msg . stageId , msg . taskId , msg . metrics ) ; \n \n \t1 } else { \n \n <ect>
\t3 LOGGER . info ( <string_literal> + cert . getSubjectDN ( ) ) ; \n \n \t3 try { \n \n \t4 addUrl ( CertificateUtil . getCRLURL ( cert ) ) ; \n \n \t3 } catch ( CertificateParsingException e ) { \n \n <ect>
\t2 assertEquals ( <string_literal> , \n \n \t3 ChatRoomMemberRole . GUEST , roleEventUser3 . getPreviousRole ( ) ) ; \n \n \t2 assertEquals ( <string_literal> , \n \n \t3 ChatRoomMemberRole . MEMBER , roleEventUser3 . getNewRole ( ) ) ; \n \n <ect>
\t6 StompReceiptEvent event = new StompReceiptEvent ( StompInboundChannelAdapter . this , \n \n \t8 destination , subscription . getReceiptId ( ) , StompCommand . SUBSCRIBE , true ) ; \n \n \t6 applicationEventPublisher . publishEvent ( event ) ; } \n \n \t5 else { \n \n <ect>
\t2 if ( catch2except == null ) \n \n \t3 return exception ; \n \n \t2 return catch2except . get ( catchBody ) ; } \n \n \t1 public void dump ( ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 private SSLContext sslContext = null ; \n \n \t1 public ConsoleProxySecureServerFactoryImpl ( ) { } \n \n \t1 @ Override \n \n \t1 public void init ( byte [ ] ksBits , String ksPassword ) { \n \n <ect>
\t2 @ Override \n \n \t2 public TaskManager get ( ) { \n \n \t2 return clientTaskManager ; } \n \n \t1 } ) ; } \n \n <ect>
\t2 && ! params . getKeyEncryptionStrategyClass ( ) . equals ( <string_literal> ) ) { \n \n \t2 allIsWell = validateNotEmpty ( params . getOpaqueKeyEncryptionKeyID ( ) , allIsWell , errorBuf , \n \n \t3 <string_literal> ) ; } \n \n \t1 if ( ! allIsWell ) { \n \n <ect>
\t8 removed += curSize ; } } } } \n \n \t4 remaining = _inboundTagSets . size ( ) ; } } \n \n \t2 _context . statManager ( ) . addRateData ( <string_literal> , remaining , 0 ) ; \n \n \t2 if ( removed > 0 && _log . shouldInfo ( ) ) \n \n <ect>
\t3 assertUserManager ( ) ; \n \n \t3 return userManager . getAllRoleNames ( ) ; } \n \n \t2 catch ( AuthorizationViolationException e ) \n \n \t2 { \n \n <ect>
\t4 <string_literal> + restInvocation . getHttpMethod ( ) ) ; } } \n \n \t1 Mac mac = getMac ( ) ; \n \n \t1 mac . update ( input . getBytes ( <string_literal> ) ) ; \n \n \t1 String printBase64Binary = bytesToHex ( mac . doFinal ( ) ) ; \n \n <ect>
<comment> \n \n \t1 public void setJcifsPassword ( final String jcifsPassword ) { \n \n \t2 if ( StringUtils . isNotBlank ( jcifsPassword ) ) { \n \n \t3 Config . setProperty ( JCIFS_PROP_CLIENT_PASSWORD , jcifsPassword ) ; \n \n <ect>
\t5 int valueSize = headerBuffer . getInt ( ByteUtils . SIZE_OF_SHORT + ByteUtils . SIZE_OF_INT ) ; \n \n \t5 do { \n \n \t6 if ( keySize == - 1 && valueSize == - 1 ) { \n \n \t7 if ( valueLocation > ( fileSize - headerSize ) ) { \n \n <ect>
\t2 downloadTime = new Date ( ) . getTime ( ) - start . getTime ( ) ; \n \n \t2 if ( status == Status . DOWNLOAD_FINISHED ) { \n \n \t3 LOGGER . info ( <string_literal> + downloadUrl + <string_literal> + s3TO . getBucketName ( ) + <string_literal> + totalBytes + <string_literal> + ( downloadTime / <number_literal> ) + <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t4 if ( ! isRunning ( ) ) { \n \n \t5 LOGGER . info ( <string_literal> ) ; \n \n \t5 LOGGER . warning ( <string_literal> ) ; \n \n \t5 return true ; } \n \n <ect>
\t2 if ( pool != null ) { \n \n \t3 _pool = pool ; \n \n \t2 } else { \n \n \t3 Log log = _context . logManager ( ) . getLog ( getClass ( ) ) ; \n \n <ect>
\t2 } catch ( NoSuchMetaStoreException nsme ) { \n \n \t3 <comment> \n \n \t2 } catch ( IOException ioe ) { \n \n \t3 if ( ! closed ) \n \n <ect>
\t2 int count = 0 ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 String cleanedLine = this . cleanURL ( line ) ; \n \n <ect>
\t5 fetchResponse = consumer . fetch ( fetchRequest ) ; } \n \n \t4 catch ( Throwable cce ) { \n \n \t5 <comment> \n \n \t5 if ( cce instanceof ClosedChannelException ) { \n \n <ect>
\t9 newFiles . remove ( changedFile ) } \n \n \t8 pluginManager . informOfFileChange ( changedFile ) } } \n \n \t6 newFiles . clear ( ) \n \n \t5 } catch ( CompilationFailedException cfe ) { \n \n <ect>
\t2 String [ ] command = null ; \n \n \t2 try { \n \n \t3 command = ( String [ ] ) params . get ( <string_literal> ) ; \n \n \t3 if ( command == null ) { \n \n <ect>
\t3 LOG . warn ( <string_literal> ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n \t3 LOG . warn ( <string_literal> , ex ) ; } } } \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t4 break ; \n \n \t3 case END_GAME_INFO : \n \n \t4 GameEndView message = ( GameEndView ) callback . getData ( ) ; \n \n \t4 this . gameResult = message . hasWon ( ) ? <string_literal> : <string_literal> ; \n \n <ect>
\t5 + attribute , \n \n \t5 attributeMap . get ( attribute ) ) ; } \n \n \t3 server . sendToGangliaNodes ( ) ; } } \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t3 if ( majorChange ) { \n \n \t3 throw new Exception ( <string_literal> ) ; } \n \n \t3 break ; \n \n \t2 default : \n \n <ect>
\t2 try { \n \n \t3 OutputStream os = buildContext . newFileOutputStream ( outFile ) ; \n \n \t3 properties . store ( os , <string_literal> ) ; \n \n \t3 os . close ( ) ; \n \n <ect>
\t5 CoolantManager . INSTANCE . addCoolant ( coolant , tag . getInteger ( <string_literal> ) ) ; \n \n \t4 } else { \n \n \t5 failed = true ; } } } \n \n \t2 if ( failed ) { \n \n <ect>
\t2 <comment> \n \n \t2 ID precisionTemp = dateOfBirth . getDegreeOfPrecision ( ) ; \n \n \t2 if ( precisionTemp != null && precisionTemp . getValue ( ) != null ) { \n \n \t3 String precision = precisionTemp . getValue ( ) . toUpperCase ( ) ; \n \n <ect>
\t5 . setSync ( false ) \n \n \t5 . setDisableWAL ( true ) ; \n \n \t3 final RocksDB rocksDB = RocksDB . open ( options , rocksDir . getAbsolutePath ( ) ) ) { \n \n \t3 <comment> \n \n <ect>
\t3 } catch ( IOException ioe ) { } \n \n \t3 if ( _log . shouldLog ( Log . ERROR ) ) \n \n \t4 _log . error ( <string_literal> + remoteHost + ' : ' + remotePort , ex ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t2 basic . skipping ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void versionedSkipping ( ) throws IOException , NoSuchAlgorithmException { \n \n <ect>
\t4 . setRepeatLastToken ( false ) \n \n \t4 . setRowLimit ( <number_literal> ) \n \n \t4 . executeWithCallback ( callback ) ; \n \n \t3 Set < Long > set = callback . get ( ) ; \n \n <ect>
\t2 sc . setParameters ( <string_literal> , false ) ; \n \n \t2 sc . setParameters ( <string_literal> , netIds . toArray ( ) ) ; \n \n \t2 List < IPAddressVO > publicIps = _ipAddressDao . search ( sc , null ) ; \n \n \t2 if ( publicIps == null ) { \n \n <ect>
\t3 s_logger . error ( <string_literal> + network . getName ( ) ) ; \n \n \t3 return false ; } \n \n \t2 List < CiscoAsa1000vDeviceVO > asaList = _ciscoAsa1000vDao . listByPhysicalNetwork ( network . getPhysicalNetworkId ( ) ) ; \n \n \t2 if ( asaList . isEmpty ( ) ) { \n \n <ect>
\t4 final OtpErlangBinary bin = BeamUtil . getBeamBinary ( module , path ) ; \n \n \t4 if ( bin != null ) { \n \n \t5 ok = BeamLoader . loadBeam ( b . getOtpRpc ( ) , module , bin ) ; } \n \n \t4 if ( ! ok ) { \n \n <ect>
\t8 responsePdu . setJsonPackage ( result ) ; \n \n \t8 addOutgoingClusterPdu ( responsePdu ) ; } } } \n \n \t4 } ) ; \n \n \t3 } catch ( final Throwable e ) { \n \n <ect>
\t2 if ( ErrorMessageBuilder . this . hasMessage ( this . ex ) ) { \n \n \t2 try { \n \n \t3 return String . format ( this . fstring , this . fArgs ) + <string_literal> + ErrorMessageBuilder . this . getMessage ( this . ex ) ; \n \n \t2 } catch ( IllegalFormatException ex1 ) { \n \n <ect>
\t7 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t6 } catch ( Exception e ) { \n \n \t7 logger . error ( <string_literal> , e ) ; } \n \n \t5 } else { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
public void setCompany ( er . uber . model . Company value ) { \n \n \t1 takeStoredValueForKey ( value , _Employee . COMPANY_KEY ) ; } \n \n public void setCompanyRelationship ( er . uber . model . Company value ) { \n \n <ect>
\t2 try ( PrintWriter printWriter = response . getWriter ( ) ) { \n \n \t3 response . setStatus ( status ) ; \n \n \t3 printWriter . print ( text ) ; \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 numEigensWritten ++ ; \n \n \t2 if ( numEigensWritten == maxEigensToKeep ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void updated ( Dictionary < String , ? > config ) throws ConfigurationException { \n \n <ect>
\t2 return sourceRoots ; } \n \n \t1 public boolean canInferSourceRoots ( ) { \n \n \t2 for ( Object source : sources ) { \n \n \t3 if ( ! canInferSourceRoot ( source ) ) { \n \n <ect>
\t3 assert rsrc2 != null ; \n \n \t3 assert rsrc3 != null ; \n \n \t3 assert rsrc4 != null ; \n \n \t3 assert log != null ; \n \n <ect>
\t5 LOG . trace ( <string_literal> , batchSize ) ; } } \n \n \t3 <comment> \n \n \t3 if ( ! isValid ( exchange ) ) { \n \n \t4 if ( isIgnoreInvalidExchanges ( ) ) { \n \n <ect>
\t4 batch . put ( ( K ) serializer . deserialize ( rawKey ) , value ) ; \n \n \t4 itr . next ( ) ; } \n \n \t3 return batch ; \n \n \t2 } catch ( RocksDBException e ) { \n \n <ect>
\t5 long tStamp = System . currentTimeMillis ( ) ; \n \n \t5 while ( i ++ < sendCount ) { \n \n \t6 producer . send ( session . createTextMessage ( <string_literal> ) ) ; \n \n \t6 if ( i%100 == 0 ) { \n \n <ect>
\t3 EOAdaptor adaptor = EOAdaptor . adaptorWithModel ( model ) ; \n \n \t3 try { \n \n \t4 adaptorPrototypes = adaptor . prototypeAttributes ( ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t4 throw new GridException ( <string_literal> , e ) ; } \n \n \t3 Integer res = taskSes . getAttribute ( TEST_ATTR_KEY ) ; \n \n \t3 assert res != null && res . equals ( SETS_ATTR_COUNT ) : \n \n \t4 <string_literal> + res + <string_literal> + SETS_ATTR_COUNT + ' ] ' ; \n \n <ect>
\t3 CommitLog . instance . shutdownBlocking ( ) ; \n \n \t3 <comment> \n \n \t3 ScheduledExecutors . nonPeriodicTasks . shutdown ( ) ; \n \n \t3 if ( ! ScheduledExecutors . nonPeriodicTasks . awaitTermination ( 1 , TimeUnit . MINUTES ) ) \n \n <ect>
\t2 log . info ( <string_literal> + className + <string_literal> ) ; \n \n \t2 return qualifiers ; } \n \n \t1 @ Override \n \n \t1 public Class < ? extends Annotation > getScope ( ) { \n \n <ect>
\t2 LOG . trace ( <string_literal> + mbean ) ; } \n \n \t1 } catch ( ScriptExecutionFailedException ex ) { \n \n \t2 LOG . error ( <string_literal> + ex . getMessage ( ) , ex ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t3 cache . remove ( key ) ; } \n \n \t2 } ) ; } \n \n \t1 exec . stop ( ) ; \n \n \t1 long duration = System . currentTimeMillis ( ) - startTime ; \n \n <ect>
\t4 audioDestination . write ( bytes , 0 , nrRead ) ; } \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 from . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + inputSampleCount . longValue ( ) \n \n \t5 + <string_literal> + chunkedSampleCount . longValue ( ) \n \n \t5 + <string_literal> ) ; \n \n \t3 if ( inputSampleCount . get ( ) != chunkedSampleCount . get ( ) ) { \n \n <ect>
\t5 String encodedTimeZone = URLEncoder . encode ( <string_literal> , <string_literal> ) ; \n \n \t5 url = \n \n \t6 server + <string_literal> + s_rootVolume . get ( ) + <string_literal> + \n \n \t7 encodedTimeZone ; \n \n <ect>
\t3 assertIsSatisfied ( timeoutForEmptyEndpoints ) ; \n \n \t3 <comment> \n \n \t3 failed = true ; \n \n \t2 } catch ( AssertionError e ) { \n \n <ect>
\t2 for ( Message msg : batch ) { \n \n \t3 try { \n \n \t4 receiver . receive ( msg . src ( ) , msg . getRawBuffer ( ) , msg . getOffset ( ) , msg . getLength ( ) ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t5 if ( ! loc . load ( ) ) { \n \n \t6 s_logger . warn ( <string_literal> + container ) ; \n \n \t6 continue ; } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t3 QueryStats qs = this . getQueryStats ( sql ) ; \n \n \t3 if ( qs != null ) { \n \n \t4 qs . add ( delta , start ) ; \n \n <ect>
\t2 configureSwitchItemBinding ( <number_literal> , SLAVE_NAME , 0 ) ; \n \n \t2 Thread executeOnBackground = new Thread ( new Runnable ( ) { \n \n \t3 @ Override \n \n \t3 public void run ( ) { \n \n <ect>
\t1 <comment> \n \n \t1 private void migrateS3ToImageStore ( Connection conn ) { \n \n \t2 Long storeId = null ; \n \n \t2 Map < Long , Long > s3_store_id_map = new HashMap < Long , Long > ( ) ; \n \n <ect>
\t2 if ( StringUtils . equalsIgnoreCase ( fkName , rs . getString ( <string_literal> ) ) ) { \n \n \t3 return true ; } } \n \n \t1 } finally { \n \n \t2 rs . close ( ) ; } } \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n <ect>
\t1 if ( serverSocket != null ) { \n \n \t1 try { \n \n \t2 serverSocket . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 return Optional . absent ( ) ; } \n \n \t1 if ( submitResult instanceof ExecutionFailed ) { \n \n \t1 ExecutionFailed error = ( ExecutionFailed ) submitResult ; \n \n <ect>
\t3 VelocityManager velocityManager = Utils . getComponent ( VelocityManager . class ) ; \n \n \t3 VelocityContext velocityContext = velocityManager . getVelocityContext ( ) ; \n \n \t3 return evaluateVelocity ( content , name , velocityContext ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 lastActivityOn = - 1 ; \n \n \t2 startedOn = Clock . getInstance ( ) . now ( ) ; \n \n \t2 _log = I2PAppContext . getGlobalContext ( ) . logManager ( ) . getLog ( getClass ( ) ) ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t5 } else { \n \n \t6 throw new BatchProcessingException ( <string_literal> + response . getStatus ( ) ) ; } \n \n \t4 } catch ( Exception e ) { \n \n \t5 <comment> \n \n <ect>
\t1 final_content_lines = <string_literal> \n \n \t1 if sudo . path_isfile ( filename ) : \n \n \t1 file_content = sudo . read_file ( filename , encoding = self . resource . encoding ) \n \n \t1 new_content_lines += file_content . split ( ' \\ n' ) \n \n <ect>
\t6 } else { \n \n \t7 s_logger . error ( <string_literal> + api . getTestCaseInfo ( ) + <string_literal> + api . getUrl ( ) ) ; } \n \n \t5 } else { \n \n \t6 if ( api . isEmpty ( ) != false ) \n \n <ect>
\t2 final QueueViewMBean queueViewMBean = getProxyToQueue ( dlqQueue . getQueueName ( ) ) ; \n \n \t2 assertTrue ( <string_literal> , Wait . waitFor ( new Wait . Condition ( ) { \n \n \t3 @ Override \n \n \t3 public boolean isSatisified ( ) throws Exception { \n \n <ect>
\t5 if ( connectorStarted . await ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n \t6 LOG . debug ( <string_literal> ) ; \n \n \t6 server . stop ( ) ; } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t1 try { \n \n \t1 getLifecycleManager ( ) . applyPhase ( object , getLifecycleManager ( ) . getCurrentPhase ( ) , Disposable . PHASE_NAME ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 default : \n \n \t6 final String errorText = <string_literal> ; \n \n \t6 error ( errorText , Protos . Error . ErrorCode . SYNTAX_ERROR , CloseReason . REMOTE_SENT_INVALID_MESSAGE ) ; } \n \n \t3 } catch ( VerificationException e ) { \n \n <ect>
\t2 final TestOlingo2ResponseHandler < ODataFeed > responseHandler = new TestOlingo2ResponseHandler < ODataFeed > ( ) ; \n \n \t2 olingoApp . read ( edm , MANUFACTURERS , null , null , responseHandler ) ; \n \n \t2 final ODataFeed dataFeed = responseHandler . await ( ) ; \n \n \t2 assertNotNull ( <string_literal> , dataFeed ) ; \n \n <ect>
\t2 protected ExecuteResult doWork ( ExecutableContext context ) throws ExecuteException { \n \n \t3 try { \n \n \t4 rmdirOnHDFS ( getDataPath ( ) ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t6 <string_literal> ) ; \n \n \t4 } else { \n \n \t5 _alertMgr . clearAlert ( AlertManager . AlertType . ALERT_TYPE_USAGE_SERVER , 0 , 0 ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
@ Override \n \n public void upsertTable ( org . apache . sqoop . manager . ExportJobContext context ) \n \n \t1 throws IOException , ExportException { \n \n \t1 context . setConnManager ( this ) ; \n \n <ect>
\t3 email . addArgument ( error ) ; \n \n \t3 email . addArgument ( ConfigurationManager . getProperty ( <string_literal> ) + <string_literal> ) ; \n \n \t3 email . send ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 Repository r = cfd . getRepository ( rmiURI ) ; \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 return r ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 ResteasyWebTarget target = client . target ( PortProviderUtil . generateURL ( <string_literal> , DEPLOYMENT_FALSE ) ) ; \n \n \t3 Invocation invocation = target . request ( ) . buildGet ( ) ; \n \n \t3 response = invocation . invoke ( ) ; \n \n <ect>
\t1 <comment> \n \n \t1 setDetectedAttributes ( ambariLdapConfiguration , detectedUserAttributes ) ; \n \n \t1 LOG . info ( <string_literal> , ambariLdapConfiguration ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 Class < ? > clazz = Class . forName ( resourceName ) ; \n \n \t3 Constructor constructor = clazz . getConstructor ( ) ; \n \n \t3 resource = ( ServerResource ) constructor . newInstance ( ) ; \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t4 try { \n \n \t5 cleanupOutputsAfterUnpackFailure ( ) ; \n \n \t5 taskArtifactState . afterOutputsRemovedBeforeTask ( ) ; \n \n \t4 } catch ( Exception eCleanup ) { \n \n <ect>
\t4 activeSessions . add ( ss ) ; } \n \n \t2 } finally { \n \n \t3 sessionLock . unlock ( ) ; } \n \n <ect>
\t4 latchMap . putIfAbsent ( commandToSend . getMessageId ( ) , latch ) ; \n \n \t4 retryCountMap . putIfAbsent ( commandToSend . getMessageId ( ) , ONE ) ; \n \n \t4 netsendUDP ( commandToSend ) ; \n \n \t4 boolean unlatched = latch . await ( timeoutForOkMessagesMs , TimeUnit . MILLISECONDS ) ; \n \n <ect>
\t3 storeServer . registerOutputHandler ( dataStoreRequest . clientId ( ) , commChannel ) ; \n \n \t3 mainRequestHandler ( dataStoreRequest ) ; } \n \n \t2 catch ( Exception ex ) { \n \n \t3 logger . error ( ex , <string_literal> ) ; \n \n <ect>
\t4 } catch ( ConcurrentOperationException e ) { \n \n \t5 s_logger . warn ( <string_literal> + element . getName ( ) , e ) ; \n \n \t5 success = false ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 command . add ( <string_literal> ) ; \n \n \t2 command . add ( <string_literal> ) ; \n \n \t2 result = command . execute ( ) ; \n \n \t2 if ( result != null ) { \n \n <ect>
\t3 { \n \n \t4 logger . info ( <string_literal> ) ; } } \n \n \t2 else \n \n \t2 { \n \n <ect>
\t2 <comment> \n \n \t2 Message tmpMsg = decryptMessage ( null , msg . copy ( ) ) ; <comment> \n \n \t2 if ( tmpMsg != null ) \n \n \t3 return up_prot . up ( tmpMsg ) ; \n \n <ect>
\t3 String xml = StringHelper . stringFromStream ( is ) ; \n \n \t3 Object object = serializer . serializeFrom ( xml ) ; \n \n \t3 if ( object != null ) { \n \n \t4 String output = serializer . serializeTo ( object , <string_literal> , <string_literal> , 0 ) ; \n \n <ect>
\t1 oldVal = deltaRemaining . get ( ) ; \n \n \t1 } while ( ! deltaRemaining . compareAndSet ( oldVal , oldVal + delta ) ) ; \n \n \t1 int toStart = oldVal + delta ; \n \n \t1 if ( toStart < = 0 ) return createDummyFuture ( ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( registeredService instanceof SamlRegisteredService ) { \n \n \t4 final URL location = buildLogoutUrl ( registeredService , singleLogoutService ) ; \n \n \t4 if ( location != null ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 if ( getSession ( ) != null ) { \n \n \t3 getSession ( ) . close ( ) ; \n \n \t3 setSession ( null ) ; } \n \n <ect>
<number_literal> usageIterator ++ ; } \n \n \t10 if ( ( users == null ) && ( accountName == null ) ) { \n \n <number_literal> s_logger . info ( <string_literal> ) ; \n \n <number_literal> int cleanupResponseCode = executeCleanup ( server , developerServer , username ) ; \n \n <ect>
\t4 <comment> \n \n \t4 newElement . value = new Integer32 ( Integer . parseInt ( outMatcher . group ( <number_literal> ) . toString ( ) ) ) ; \n \n \t4 Command command = TypeParser . parseCommand ( item . getAcceptedCommandTypes ( ) , commandAsString ) ; \n \n \t4 if ( command == null ) { \n \n <ect>
\t3 if ( ignoredRootPackages ( ) . contains ( pkg ) ) { \n \n \t4 continue } \n \n \t3 if ( pkg == <string_literal> ) { \n \n \t4 <comment> \n \n <ect>
\t2 for ( VoldemortService service : basicServices ) { \n \n \t3 try { \n \n \t4 service . start ( ) ; \n \n \t3 } catch ( DisabledStoreException e ) { \n \n <ect>
\t3 List < Datapoint > dpList = null ; \n \n \t3 synchronized ( mScheduleMap ) { \n \n \t4 dpList = mScheduleMap . get ( autoRefreshTimeInSecs ) ; \n \n \t4 if ( dpList == null ) { \n \n <ect>
\t2 System . exit ( 1 ) ; } \n \n \t1 destDir . mkdirs ( ) ; \n \n \t1 if ( ! destDir . exists ( ) || ! destDir . canWrite ( ) ) \n \n \t1 { \n \n <ect>
\t2 ) || ( \n \n \t2 options . getTargetDir ( ) != null \n \n \t2 && options . getTargetDir ( ) . startsWith ( defaultHiveWarehouse ) \n \n \t1 ) ) ) { \n \n <ect>
\t3 try { \n \n \t4 Logger . normal ( this , <string_literal> + this ) ; \n \n \t4 writeBuffer ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 manager . close ( connection ) ; } } \n \n \t1 private void extractResults ( ResultSet resultSet , List < List < String > > results ) throws SQLException { \n \n \t2 List < String > oneRow = new LinkedList < String > ( ) ; \n \n \t2 while ( resultSet . next ( ) ) { \n \n <ect>
\t1 List < String > collectionToAdd = new ArrayList < > ( ) ; \n \n \t1 try { \n \n \t1 collectionToAdd = new ListCollectionHandler ( ) . handle ( solrClient , null ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 Object otherValue = method . invoke ( otherAttribute ) ; \n \n \t4 if ( otherValue != null ) { \n \n \t5 returnValue & = otherValue . equals ( thisValue ) ; } } \n \n \t3 catch ( NoSuchMethodException e ) { \n \n <ect>
\t2 wmsStore . setEnabled ( true ) ; \n \n \t2 catalog . validate ( wmsStore , false ) . throwIfInvalid ( ) ; \n \n \t2 catalog . add ( wmsStore ) ; \n \n \t2 String storeName = wmsStore . getName ( ) ; \n \n <ect>
\t2 String result = <string_literal> ; \n \n \t2 try { \n \n \t3 result = myevent . readevent ( sb . toString ( ) ) ; \n \n \t2 } catch ( JAXBException e ) { \n \n <ect>
\t1 logger . debug ( <string_literal> , hdfs_file_exists_command ) \n \n \t1 hdfs_file_exists = ( 0 == call ( hdfs_file_exists_command . split ( ) ) ) \n \n except Exception as e : \n \n \t1 print \n \n <ect>
<comment> \n \n private void enqueueAgentCommands ( Cluster cluster , String clusterName , Collection < String > hosts ) { \n \n \t1 if ( null == clusterName ) { \n \n <ect>
\t2 List < XMLSettingNode > zoneProviderElements = configFile . getSettings ( <string_literal> ) ; \n \n \t2 for ( XMLSettingNode settingNode : zoneProviderElements ) { \n \n \t3 String name = settingNode . getString ( <string_literal> ) ; \n \n \t3 if ( StringUtils . isEmpty ( name ) ) { \n \n <ect>
<comment> \n \n \t1 default boolean supports ( final AuthenticationResponse response ) { \n \n \t2 if ( response != null ) { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , result , scriptFile ) ; \n \n \t4 return result . toString ( ) ; } \n \n \t2 } catch ( final IOException e ) { \n \n \t3 LOGGER . error ( e . getMessage ( ) , e ) ; } \n \n <ect>
\t2 try { \n \n \t3 if ( retry > 0 ) { \n \n \t4 s_logger . info ( <string_literal> + retry + <string_literal> ) ; \n \n \t4 Thread . sleep ( <number_literal> ) ; } \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bundleContext ) throws Exception { \n \n <ect>
\t2 . fromTable ( table ) \n \n \t2 . addValue ( <string_literal> ) \n \n \t2 . build ( ) ; \n \n \t1 client . add_partition ( part ) ; \n \n <ect>
\t3 for ( JMeterProperty jMeterProperty : this ) { \n \n \t4 newCol . add ( jMeterProperty . clone ( ) ) ; } \n \n \t3 return newCol ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 getTransactionCoordinatorOwner ( ) . startTransactionBoundary ( ) ; } \n \n \t1 @ Override \n \n \t1 public void explicitJoin ( ) { \n \n \t2 if ( synchronizationRegistered ) { \n \n <ect>
\t2 thread1Start . countDown ( ) ; \n \n \t2 thread2Start . countDown ( ) ; \n \n \t2 future1 . get ( ) ; \n \n \t2 future2 . get ( ) ; \n \n <ect>
\t4 log . debug ( <string_literal> , remoteServer ( ) ) ; } \n \n \t3 getOperations ( ) . forceDisconnect ( ) ; \n \n \t2 } catch ( GenericFileOperationFailedException e ) { \n \n \t3 <comment> \n \n <ect>
\t3 PacketBufferBC testingBuffer = PacketBufferBC . asPacketBufferBc ( Unpooled . buffer ( ) ) ; \n \n \t3 varyingProperties . forEach ( ( key , vars ) - > { \n \n \t4 if ( DEBUG ) { \n \n \t5 BCLog . logger . info ( <string_literal> + key + <string_literal> ) ; \n \n <ect>
\t5 alignment , worksheet . getSemanticTypes ( ) , rdfSourcePrefix , rdfSourceNamespace , \n \n \t5 Boolean . valueOf ( addInverseProperties ) ) ; } \n \n \t2 catch ( KarmaException e ) \n \n \t2 { \n \n <ect>
\t1 removeGroups ( dbSession , userDto , groupsToRemove , groupsByName ) ; } \n \n private void addGroups ( DbSession dbSession , UserDto userDto , Collection < String > groupsToAdd , Map < String , GroupDto > groupsByName ) { \n \n \t1 groupsToAdd . stream ( ) . map ( groupsByName : : get ) . filter ( Objects : : nonNull ) . forEach ( \n \n \t1 groupDto - > { \n \n <ect>
\t2 assertThat ( appender . lastEvent . getLevel ( ) , equalTo ( Level . WARN ) ) ; \n \n \t2 assertThat ( appender . lastEvent . getThrown ( ) , equalTo ( ex ) ) ; \n \n \t2 assertThat ( appender . lastParameterizedMessage ( ) . getFormattedMessage ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 assertThat ( appender . lastParameterizedMessage ( ) . getParameters ( ) , arrayContaining ( <string_literal> ) ) ; \n \n <ect>
\t4 ConfigConstants . DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE ) ; \n \n \t2 final String amCommand = \n \n \t3 BootstrapTools . getStartCommand ( commandTemplate , startCommandValues ) ; \n \n \t2 amContainer . setCommands ( Collections . singletonList ( amCommand ) ) ; \n \n <ect>
\t3 try { \n \n \t4 l . changed ( ) ; } \n \n \t3 catch ( Throwable t ) { \n \n \t4 if ( log . isErrorEnabled ( ) ) \n \n <ect>
\t3 LOG . warn ( <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 @ Override \n \n \t2 public String getPassword ( ) { \n \n <ect>
\t6 relationProperty . addSingleElement ( securityContext , localNode , relatedNode ) ; \n \n \t5 } catch ( FrameworkException fex ) { \n \n \t6 logger . warn ( <string_literal> , fex ) ; } \n \n \t4 } else { \n \n <ect>
\t2 try { \n \n \t3 reader . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 relatedNodes . add ( n ) ; } \n \n \t4 } else { \n \n \t5 relatedNodes . add ( ( T ) source ) ; } } \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t9 s_logger . info ( <string_literal> + threadNum + <string_literal> ) ; \n \n \t9 dao . release ( 1L ) ; \n \n \t9 s_logger . info ( <string_literal> + threadNum + <string_literal> ) ; \n \n \t8 } else { \n \n <ect>
\t1 return main != null ; } \n \n void cleanCachesIfFlagSet ( String root ) throws IOException { \n \n \t1 String customLocation = root + <string_literal> ; \n \n \t1 <comment> \n \n <ect>
\t1 NoSuchElementException nsee = Exceptions . findCause ( e , NoSuchElementException . class ) ; \n \n \t1 if ( nsee != null ) { \n \n \t2 LOG . warn ( nsee . getMessage ( ) ) ; \n \n \t1 } else { \n \n <ect>
\t2 writer . close ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testNetworkManagerBackwards ( ) throws Exception { \n \n <ect>
\t1 public static DLNAResource autoMatch ( String uri , String name ) { \n \n \t2 try { \n \n \t3 uri = URLDecoder . decode ( uri , <string_literal> ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t3 int code = HttpServletResponse . SC_BAD_REQUEST ; \n \n \t3 response . setStatus ( code ) ; \n \n \t3 response . getWriter ( ) . append ( RestMethodResult . jsonError ( code , <string_literal> + jpex . getMessage ( ) ) ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t1 protected void printAliases ( ) throws IOException { \n \n \t2 if ( mExplain == null ) { <comment> \n \n \t3 mPigServer . printAliases ( ) ; \n \n \t2 } else { \n \n <ect>
\t4 FileUtils . forceMkdir ( metaDir ) ; \n \n \t4 String [ ] cubeMetaArgs = { <string_literal> , <string_literal> , <string_literal> , cubeName , <string_literal> , \n \n \t6 new File ( metaDir , cubeName ) . getAbsolutePath ( ) , <string_literal> , <string_literal> , <string_literal> , <string_literal> , \n \n \t6 <string_literal> , <string_literal> } ; \n \n <ect>
\t6 long diff = TimeUnit . MILLISECONDS . convert ( current_time - timestamp , TimeUnit . NANOSECONDS ) ; \n \n \t6 if ( diff >= timeout ) \n \n \t7 suspect ( target ) ; } } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t3 log . error ( <string_literal> + kBaseModel . getName ( ) + <string_literal> + kbuilder . getErrors ( ) . toString ( ) ) ; } \n \n \t2 if ( kbuilder . hasResults ( ResultSeverity . WARNING ) ) { \n \n \t3 for ( KnowledgeBuilderResult warn : kbuilder . getResults ( ResultSeverity . WARNING ) ) { \n \n \t4 messages . addMessage ( warn ) . setKieBaseName ( kBaseModel . getName ( ) ) ; } \n \n <ect>
\t7 + fileName ; \n \n \t6 String downloadDir = getExportDownloadDirectory ( eperson ) ; \n \n \t6 File dnDir = new File ( downloadDir ) ; \n \n \t6 if ( ! dnDir . exists ( ) && ! dnDir . mkdirs ( ) ) { \n \n <ect>
\t4 ActionProxyFactory obj = container . getInstance ( ActionProxyFactory . class , factoryName ) ; \n \n \t4 if ( obj != null ) { \n \n \t5 actionProxyFactories . put ( factoryPrefix , obj ) ; \n \n \t4 } else { \n \n <ect>
\t2 return new LinkedHashMap ( ) ; } \n \n \t1 Map map1 = ( Map ) map . get ( Preferences . get ( <string_literal> ) ) ; \n \n \t1 if ( map1 == null ) { \n \n \t2 String [ ] entries = ( String [ ] ) map . keySet ( ) . toArray ( new String [ 0 ] ) ; \n \n <ect>
\t3 return account . getId ( ) ; } \n \n \t2 return Account . ACCOUNT_ID_SYSTEM ; <comment> \n \n \t1 @ Override \n \n \t1 public void execute ( ) { \n \n <ect>
\t7 resolution . optionals . add ( r ) ; \n \n \t6 else \n \n \t7 resolution . missing . add ( r ) ; \n \n \t5 } else { \n \n <ect>
\t4 log . debug ( <string_literal> + conceptId + <string_literal> + forLocale ) ; } \n \n \t3 return null ; \n \n \t2 } else if ( forLocale == null ) { \n \n <ect>
\t1 if ( localConf . getBoolean ( Property . INSTANCE_RPC_SASL_ENABLED ) ) { \n \n \t1 String keytabPath = getKeytab ( localConf , target ) ; \n \n \t1 keytab = new File ( keytabPath ) ; \n \n \t1 if ( ! keytab . exists ( ) || ! keytab . isFile ( ) ) { \n \n <ect>
\t6 add ( fut ) ; <comment> \n \n \t6 <comment> \n \n \t6 assert ! n . id ( ) . equals ( ctx . localNodeId ( ) ) ; \n \n <ect>
\t5 Thread . sleep ( pollInterval * <number_literal> ) ; } } \n \n \t3 if ( stopped . get ( ) ) { \n \n \t4 LOG . info ( <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 server . start ( ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 server . join ( ) ; \n \n <ect>
\t4 delete ( node + <string_literal> + child ) ; } \n \n \t3 delete ( node ) ; } \n \n \t2 public void delete ( String node ) throws Exception { \n \n \t3 delay ( <number_literal> ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t2 transport = TTimeoutTransport . create ( address , timeout ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n <comment> \n \n \t1 @ Test \n \n \t1 public void testRepositoryControlObject ( ) throws Exception { \n \n <ect>
\t3 LOG . error ( <string_literal> ) ; \n \n \t3 throw new IllegalArgumentException ( \n \n \t5 <string_literal> ) ; } \n \n \t2 if ( ObjectHelper . isEmpty ( pvcSpec ) ) { \n \n <ect>
\t5 if ( ! cfgDir . exists ( ) ) { \n \n \t6 cfgDir . mkdirs ( ) ; } \n \n \t5 cfgFile . createNewFile ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 totalCheckFilesDeleted ++ ; } } \n \n \t1 LOG . info ( <string_literal> + totalCheckFilesDeleted + <string_literal> + \n \n \t2 checkPointFolderFile . getAbsolutePath ( ) ) ; \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t5 log . info ( <string_literal> + toString ( ) ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n \t4 throw new RuntimeException ( ex ) ; } \n \n <ect>
\t5 <string_literal> + \n \n \t7 MessageHelper . collectionInfoString ( collectionPersister , id , getFactory ( ) ) , \n \n \t5 staticLoadQuery . getSqlStatement ( ) \n \n \t3 ) ; } \n \n <ect>
\t1 try : \n \n \t1 if config . has_option ( PACKAGE_SECTION , PACKAGE_KEY ) : \n \n \t2 propertyMap [ PACKAGE_SECTION ] = config . get ( PACKAGE_SECTION , PACKAGE_KEY ) . split ( ' , ' ) \n \n \t1 except : \n \n <ect>
\t5 return file . isFile ( ) && file . getName ( ) . toLowerCase ( ) . endsWith ( <string_literal> ) ; } } \n \n \t2 ) ; \n \n \t2 int nJars = ( jarFiles == null ) ? 0 : jarFiles . length ; \n \n \t2 if ( nJars == 0 ) { \n \n <ect>
\t2 resetMock ( count ) ; \n \n \t2 StopWatch watch = new StopWatch ( ) ; \n \n \t2 execute ( count ) ; \n \n \t2 assertMockEndpointsSatisfied ( ) ; \n \n <ect>
\t3 return result instanceof TransactionManager ? Optional . of ( ( TransactionManager ) result ) : Optional . empty ( ) ; \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n \t3 return Optional . empty ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 catch ( BeanDefinitionParsingException e ) { \n \n \t3 if ( validContext ) { \n \n \t4 <comment> \n \n \t4 throw e ; } \n \n <ect>
\t1 public void marshal ( Exchange exchange , Object graph , OutputStream stream ) throws Exception { \n \n \t2 ObjectHelper . notNull ( graph , <string_literal> ) ; \n \n \t2 List < Map < String , Object > > data = ( List < Map < String , Object > > ) graph ; \n \n \t2 if ( data . isEmpty ( ) ) { \n \n <ect>
<comment> \n \n \t1 protected void mark ( GarbageCollectorFileState fs ) throws IOException , DataStoreException { \n \n <ect>
\t2 int maxIdle = realm . getSsoSessionIdleTimeout ( ) + SessionTimeoutHelper . IDLE_TIMEOUT_WINDOW_SECONDS ; \n \n \t2 return userSession . getLastSessionRefresh ( ) + maxIdle > currentTime && max > currentTime ; } \n \n \t1 public static boolean isOfflineSessionValid ( RealmModel realm , UserSessionModel userSession ) { \n \n \t2 if ( userSession == null ) { \n \n <ect>
\t2 String path = getIdentityCookiePath ( realm , uriInfo ) ; \n \n \t2 expireCookie ( realm , KEYCLOAK_IDENTITY_COOKIE , path , true , connection ) ; \n \n \t2 expireCookie ( realm , KEYCLOAK_SESSION_COOKIE , path , false , connection ) ; } \n \n \t1 public static void expireRememberMeCookie ( RealmModel realm , UriInfo uriInfo , ClientConnection connection ) { \n \n <ect>
\t4 } catch ( IOException e ) { \n \n \t5 throw UncheckedException . throwAsUncheckedException ( e ) ; } \n \n \t4 if ( ! properties . stringPropertyNames ( ) . containsAll ( METADATA_KEYS ) ) { \n \n \t5 throw new IllegalStateException ( <string_literal> ) ; } \n \n <ect>
\t2 return answer ; } \n \n \t1 protected void installCamelFeature ( String mainFeature ) throws Exception { \n \n \t2 if ( ! mainFeature . startsWith ( <string_literal> ) ) { \n \n \t3 mainFeature = <string_literal> + mainFeature ; } \n \n <ect>
\t3 for ( Entry < String , List < Integer > > entry : componentToTasks . entrySet ( ) ) { \n \n \t4 String name = entry . getKey ( ) ; \n \n \t4 List < Integer > taskIds = entry . getValue ( ) ; \n \n \t4 if ( taskIds == null || taskIds . size ( ) == 0 ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 return new WireSmokeSimpleSubresource ( ) ; } \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public WireSmokeSimpleResource getNotLocating ( ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 catch ( JPAExecutorException je ) { \n \n \t4 throw new CommandException ( je ) ; } } \n \n \t2 catch ( JPAExecutorException je ) { \n \n \t3 throw new CommandException ( je ) ; } \n \n <ect>
\t3 if ( headers . containsKey ( this . remotePrincipalHeader ) ) { \n \n \t4 final String header = headers . get ( this . remotePrincipalHeader ) . get ( 0 ) ; \n \n \t4 LOGGER . debug ( <string_literal> , header , this . remotePrincipalHeader ) ; \n \n \t4 return remoteUser ; } } \n \n <ect>
\t3 LOG . error ( <string_literal> , exception ) ; \n \n \t3 <comment> \n \n \t3 notification . Callback . onFailure ( notification . CallbackIds ) ; } } } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 catch ( SocketException e ) { \n \n \t3 <comment> \n \n \t3 LOG . debug ( <string_literal> , e ) ; } \n \n \t2 catch ( Throwable t ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void close ( ) throws IOException { \n \n \t2 List < Runnable > runnables = service . shutdownNow ( ) ; \n \n \t2 if ( ! runnables . isEmpty ( ) ) \n \n <ect>
\t2 CloseableHttpClient client = HttpClientBuilder . create ( ) . setDefaultRequestConfig ( requestconfig ) . build ( ) ; \n \n \t2 try { \n \n \t3 HttpResponse response = client . execute ( get ) ; \n \n \t3 for ( Header header : response . getAllHeaders ( ) ) { \n \n <ect>
\t3 waitForTask ( client . getVAppClient ( ) . undeployVApp ( vApp . getHref ( ) ) ) ; \n \n \t3 vApp = client . getVAppClient ( ) . getVApp ( vApp . getHref ( ) ) ; \n \n \t3 logger . debug ( <string_literal> , vApp . getStatus ( ) , vApp . getName ( ) ) ; \n \n \t2 } catch ( IllegalStateException e ) { \n \n <ect>
\t2 if ( StringUtils . isEmpty ( modelName ) ) { \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 throw new BadRequestException ( msg . getEMPTY_MODEL_NAME ( ) ) ; } \n \n \t2 if ( ! ValidateUtil . isAlphanumericUnderscore ( modelName ) ) { \n \n <ect>
\t5 m_Socket = new DatagramSocket ( ) ; \n \n \t5 m_LocalPort = m_Socket . getLocalPort ( ) ; \n \n \t5 m_LocalAddress = m_Socket . getLocalAddress ( ) ; } } \n \n \t3 logger . debug ( <string_literal> , m_Socket . toString ( ) ) ; \n \n <ect>
\t2 WeightedMultigraph < Node , DefaultLink > tree = steinerTree . getDefaultSteinerTree ( ) ; \n \n \t2 if ( tree == null ) { \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 return ; } \n \n <ect>
\t5 <comment> \n \n \t5 <comment> \n \n \t5 if ( locNodeId . equals ( nodeId ) ) { \n \n <ect>
\t4 if ( candidate . getGeneration ( ) != generation ) \n \n \t5 continue ; \n \n \t4 if ( candidate . getIP ( ) == null || <string_literal> . equals ( candidate . getIP ( ) ) ) \n \n \t4 { \n \n <ect>
\t1 @ Override \n \n \t1 protected void open ( ) { \n \n \t2 super . open ( ) ; \n \n \t2 checkState ( gmetrics == null , <string_literal> ) ; \n \n <ect>
\t5 eventPublisher . postUpdate ( itemName , newValue ) ; \n \n \t4 } else if ( command instanceof PercentType ) { \n \n \t5 sendPercent ( bulb , rgbwSteps , bridgeId , ( PercentType ) command , BindingType . colorTemperature ) ; } \n \n \t3 } else if ( deviceConfig . getCommandType ( ) . equals ( BindingType . discoMode ) ) { \n \n <ect>
\t4 string argumentExample = <string_literal> + \n \n \t5 <string_literal> + \n \n \t5 <string_literal> + \n \n \t5 <string_literal> ; \n \n <ect>
\t3 factory = WSDLFactory . newInstance ( ) ; \n \n \t3 wsdlReader = factory . newWSDLReader ( ) ; \n \n \t3 wsdlReader . setFeature ( <string_literal> , true ) ; \n \n \t3 wsdlReader . setFeature ( <string_literal> , true ) ; } \n \n <ect>
\t3 Message newMessage = sentMsg . get ( key ) ; \n \n \t3 if ( newMessage == null ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t4 Connection conn ; \n \n \t4 try { \n \n \t5 conn = txn . getConnection ( ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t2 long end = System . currentTimeMillis ( ) ; \n \n \t2 long diff = end - start ; \n \n \t2 I2PAppContext . getGlobalContext ( ) . statManager ( ) . addRateData ( <string_literal> , diff ) ; \n \n \t2 <comment> \n \n <ect>
\t5 try { \n \n \t6 <comment> \n \n \t6 RecordMetadata response = responseFtr . get ( ) ; \n \n \t6 if ( response . topic ( ) == null ) { \n \n <ect>
\t2 if ( StringUtils . isNotBlank ( hostString ) && StringUtils . isNotBlank ( portString ) ) { \n \n \t3 host = hostString ; \n \n \t3 port = Integer . parseInt ( portString ) ; \n \n \t3 serialPort = null ; \n \n <ect>
\t3 Node node = constant . getNode ( ) ; \n \n \t3 String lexicalForm = node . getLiteral ( ) . getLexicalForm ( ) ; \n \n \t3 node = Node . createLiteral ( lexicalForm ) ; \n \n \t3 ConstantEx constantEx = new ConstantEx ( NodeValue . makeNode ( node ) . asString ( ) , node ) ; \n \n <ect>
\t2 if ( hasNext ( ) ) \n \n \t2 { \n \n \t3 if ( buffer . length < offNextBlockHeader + <number_literal> ) \n \n \t3 { \n \n <ect>
\t2 String tgtId = this . ticketGrantingTicketUniqueTicketIdGenerator . getNewTicketId ( TicketGrantingTicket . PREFIX ) ; \n \n \t2 if ( this . cipherExecutor != null ) { \n \n \t3 LOGGER . debug ( <string_literal> , tgtId ) ; \n \n \t3 tgtId = this . cipherExecutor . encode ( tgtId ) ; \n \n <ect>
<number_literal> argumentProvider . getExtraArguments ( representativeTarget , context ) ) \n \n \t3 <comment> \n \n \t3 commonArguments . pluginClasspaths = concatenate ( commonArguments . pluginClasspaths , \n \n <number_literal> argumentProvider . getClasspath ( representativeTarget , context ) ) \n \n <ect>
\t2 assertThat ( nested0 . getDocCount ( ) , equalTo ( 3L ) ) ; \n \n \t2 terms = nested0 . getAggregations ( ) . get ( <string_literal> ) ; \n \n \t2 assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 for ( String bucketName : new String [ ] { <string_literal> , <string_literal> , <string_literal> } ) { \n \n <ect>
\t2 try { \n \n \t3 deRegisterListeners ( ) ; \n \n \t3 controllerThread . interrupt ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public void collectVmDiskStatistics ( final UserVm userVm ) { \n \n \t2 <comment> \n \n \t2 if ( ! userVm . getHypervisorType ( ) . equals ( HypervisorType . KVM ) ) \n \n \t3 return ; \n \n <ect>
\t4 <comment> \n \n \t4 try { \n \n \t5 listener . receiveEvent ( event ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 _testManager . runTest ( bob . getRemoteIPAddress ( ) , bob . getRemotePort ( ) , bob . getCurrentCipherKey ( ) , bob . getCurrentMACKey ( ) ) ; \n \n \t3 setLastTested ( isIPv6 ) ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 client . start ( ) ; } \n \n \t3 startedLatch . await ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 producer . sendMessage ( ) ; \n \n <ect>
\t3 if ( task != null ) { \n \n \t4 try { \n \n \t5 task . destroy ( conn ) ; \n \n \t4 } catch ( final Exception e1 ) { \n \n <ect>
\t3 assertEquals ( <string_literal> , in . getHeader ( <string_literal> ) , counter ) ; \n \n \t3 Map < ? , ? > body = in . getBody ( Map . class ) ; \n \n \t3 assertNotNull ( <string_literal> + ObjectHelper . className ( in . getBody ( ) ) , body ) ; \n \n \t3 assertEquals ( <string_literal> , expectedFirstName [ counter ] , body . get ( <string_literal> ) ) ; \n \n <ect>
\t7 newNode . setOwnerDocument ( page ) ; \n \n \t6 } else if ( page != null ) { \n \n \t7 newNode . setOwnerDocument ( page ) ; } \n \n \t5 } else { \n \n <ect>
\t5 count ++ ; \n \n \t5 if ( count == n ) { \n \n \t6 break ; } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 solr = solrServer ; \n \n \t4 } catch ( SolrServerException e ) { \n \n \t5 log . error ( <string_literal> , e ) ; } \n \n \t3 } else { \n \n <ect>
\t2 } else { \n \n \t3 unitConcatenator = v . getConcatenator ( ) ; } \n \n \t2 <comment> \n \n \t2 UnitDatabase database = v . getDatabase ( ) ; \n \n <ect>
\t6 answer = new StartupAnswer ( startup , attache . getId ( ) , mgmtServiceConf . getPingInterval ( ) ) ; \n \n \t5 } else if ( cmd instanceof ShutdownCommand ) { \n \n \t6 final ShutdownCommand shutdown = ( ShutdownCommand ) cmd ; \n \n \t6 final String reason = shutdown . getReason ( ) ; \n \n <ect>
\t3 doValidate ( context , formObject , binder . getBindingResult ( ) ) ; \n \n \t2 } else { \n \n \t4 if ( getValidator ( ) == null ) { \n \n <ect>
\t1 FileSystem fs = FileSystem . get ( modelTempDir . toUri ( ) , config ) ; \n \n \t1 int iterationNumber = 1 ; \n \n \t1 Path iterationPath = modelPath ( modelTempDir , iterationNumber ) ; \n \n \t1 while ( fs . exists ( iterationPath ) && iterationNumber < = maxIterations ) { \n \n <ect>
protected void execute ( Context context ) throws SQLException { \n \n \t1 String defaultOrgUuid = getDefaultOrgUuid ( context ) ; \n \n \t1 String defaultQualityGate = getDefaultQualityGate ( context ) ; \n \n \t1 if ( defaultQualityGate == null ) { \n \n <ect>
\t4 <comment> \n \n \t4 String line = dataReader . readLine ( ) ; \n \n \t4 dataReader . close ( ) ; \n \n \t4 if ( line == null ) { \n \n <ect>
\t2 executorThread = null ; } } \n \n \t1 if ( executorThread == null ) { \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 } else { \n \n <ect>
public class PropertyUtils { \n \n private static final Logger LOGGER = Logger . getLogger ( PropertyUtils . class ) ; \n \n public static void setProperty ( Object instance , String name , String value ) { \n \n \t1 if ( instance == null ) { \n \n <ect>
\t3 if ( interval > 0 ) { \n \n \t4 Runnable instrumentationLogger = new Runnable ( ) { \n \n \t5 public void run ( ) { \n \n \t6 try { \n \n <ect>
\t3 if ( getRetryDelayMs ( ) > 0 ) { \n \n \t5 try { \n \n \t6 Thread . sleep ( getRetryDelayMs ( ) ) ; \n \n \t5 } catch ( InterruptedException ie ) { \n \n <ect>
\t1 super . notifyListeners ( modifications ) ; \n \n \t1 <comment> \n \n \t1 for ( Object key : modifications . getNodeIdentifiers ( ) ) { \n \n \t1 if ( ! ( key instanceof NodeId ) ) { \n \n <ect>
\t2 if ( version > MessagingService . current_version ) \n \n \t2 { \n \n \t3 <comment> \n \n \t3 Gossiper . instance . addSavedEndpoint ( from ) ; \n \n <ect>
\t4 channel = bootstrap . bind ( address ) ; \n \n \t4 group . add ( channel ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 LOGGER . error ( <string_literal> + port + <string_literal> ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public void forwardPortStatus ( byte [ ] ip , int port , int externalPort , boolean success , String reason ) { \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) { \n \n \t3 if ( success ) \n \n <ect>
\t1 @ Override \n \n \t1 public void transition ( HostImpl host , HostEvent event ) { \n \n \t1 HostStatusUpdatesReceivedEvent e = ( HostStatusUpdatesReceivedEvent ) event ; \n \n \t1 <comment> \n \n <ect>
\t4 second . setReadName ( second . getReadName ( ) + <string_literal> ) ; \n \n \t4 writeFastqRecord ( second . getFirstOfPairFlag ( ) ? codec1 : codec2 , second ) ; \n \n \t4 wrote ++ ; \n \n \t4 if ( wrote % <number_literal> == 0 ) { \n \n <ect>
\t1 @ Test ( expected = IllegalArgumentException . class ) \n \n \t1 public void testMerkleTree0 ( ) throws Exception { \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; \n \n \t2 testTree ( 0 , sizes [ 0 ] , false ) ; \n \n <ect>
\t3 log . debug ( <string_literal> + tx + <string_literal> + commit + ' ] ' ) ; \n \n \t2 if ( ! tx . markFinalizing ( RECOVERY_FINISH ) ) { \n \n <ect>
\t5 TimeUnit . MILLISECONDS . sleep ( <number_literal> ) ; \n \n \t5 stompConnection . close ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 log . error ( <string_literal> , e ) ; } } \n \n <ect>
\t2 String durableSubscriberName = getDestinationName ( ) + <string_literal> ; \n \n \t2 BrokerView adminView = this . brokerService . getAdminView ( ) ; \n \n \t2 int durableSubscribersAtStart = adminView . getDurableTopicSubscribers ( ) . length ; \n \n \t2 int inactiveSubscribersAtStart = adminView . getInactiveDurableTopicSubscribers ( ) . length ; \n \n <ect>
\t3 node . addNode ( <string_literal> + count -- ) ; \n \n \t3 if ( count % saveInterval == 0 ) { \n \n \t4 node . getSession ( ) . save ( ) ; } \n \n \t3 if ( count % <number_literal> == 0 ) { \n \n <ect>
\t1 if ( writer != null ) { \n \n \t2 try { \n \n \t2 writer . close ( ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testCustomPartitioning ( ) { \n \n \t2 try { \n \n <ect>
\t3 <comment> \n \n \t3 Path tmpPath = FileSystems . getDefault ( ) . getPath ( path + <string_literal> ) ; \n \n \t3 if ( ! pathCache . contains ( tmpPath ) ) { \n \n \t3 try { \n \n <ect>
\t1 FileStatus [ ] listStatus ; \n \n \t1 try { \n \n \t2 listStatus = fsAsUser . listStatus ( path ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 new HashMap < InetSocketAddress , Vote > ( ) ; \n \n \t3 logicalclock . incrementAndGet ( ) ; \n \n \t3 proposedLeader = self . getId ( ) ; \n \n \t3 proposedZxid = self . getLastLoggedZxid ( ) ; \n \n <ect>
<comment> \n \n public void collectUsageInfo ( NodeUsageCollector profile ) { \n \n <ect>
\t4 throw new InvalidParameterValueException ( <string_literal> ) ; } \n \n \t3 if ( assignAccountToProject ( project , account . getId ( ) , ProjectAccount . Role . Regular ) != null ) { \n \n \t4 return true ; \n \n \t3 } else { \n \n <ect>
\t2 logger . debug ( <string_literal> , nodeId ) ; \n \n \t2 if ( incomingMessage . getMessagePayloadByte ( 0 ) != 0x00 ) { \n \n \t3 logger . debug ( <string_literal> , nodeId ) ; \n \n \t2 } else { \n \n <ect>
\t3 if ( isActive ( ) ) { \n \n \t4 try { \n \n \t5 listeners . firePaused ( requestContext ) ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t5 } else { \n \n \t6 value = values ; } } \n \n \t4 if ( value == null ) { \n \n \t5 inMessage . setBody ( paramName ) ; \n \n <ect>
\t2 for ( String ep : srvRef . endpoints ) \n \n \t3 endpoints . put ( ep , srvRef ) ; } \n \n \t1 public ServiceRef getServiceRef ( String service ) { \n \n \t2 if ( ! initialized ) \n \n <ect>
\t2 lDrvState . stateLock . unlock ( ) ; } \n \n \t1 if ( isInterrupted ) { \n \n \t2 LOG . info ( <string_literal> + queryId + <string_literal> + duration + <string_literal> ) ; \n \n \t1 } else { \n \n <ect>
\t3 } catch ( SocketTimeoutException se ) { \n \n \t4 <comment> \n \n \t3 } catch ( IOException e ) { \n \n \t4 if ( started . get ( ) ) { \n \n <ect>
\t6 <comment> \n \n \t6 workerVm . detachAllDisks ( ) ; \n \n \t6 workerVm . destroy ( ) ; } \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> , uri , dst ) ; \n \n \t3 if ( ! FileUtil . copy ( fs , path , dst , false , conf ) ) { \n \n \t3 throw new IOException ( <string_literal> + uri + <string_literal> + dst ) ; } \n \n \t3 DONE . add ( dst . getPath ( ) ) ; \n \n <ect>
\t5 return null ; } } } \n \n \t2 if ( idx < list . size ( ) ) { \n \n \t3 x = list . get ( idx ) ; \n \n \t3 if ( ! x . isLiteral ( ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 LOG . error ( <string_literal> + \n \n \t5 <string_literal> ) ; \n \n \t3 return - 1 ; } \n \n \t2 catch ( Throwable t ) { \n \n <ect>
\t2 final ShardId shardId = new ShardId ( index , <string_literal> , 0 ) ; \n \n \t2 <comment> \n \n \t2 setState ( clusterService , \n \n \t3 state ( index , true , ShardRoutingState . STARTED , randomFrom ( ShardRoutingState . INITIALIZING , ShardRoutingState . STARTED ) ) ) ; \n \n <ect>
\t2 ssl_version = Script . get_force_https_protocol_value ( ) \n \n \t1 ) \n \n \t1 conn . request ( <string_literal> , url , payload , headers ) \n \n \t1 response = conn . getresponse ( ) \n \n <ect>
\t3 renderers . setSelectedIndex ( 0 ) ; } \n \n \t2 renderers . addItemListener ( new ItemListener ( ) { \n \n \t3 public void itemStateChanged ( ItemEvent e ) { \n \n \t4 if ( e . getStateChange ( ) == ItemEvent . SELECTED ) { \n \n <ect>
\t1 protected void deleteHDFSMeta ( String metaUrl ) throws IOException { \n \n \t2 int cut = metaUrl . indexOf ( ' @ ' ) ; \n \n \t2 String path = metaUrl . substring ( 0 , cut ) ; \n \n \t2 HadoopUtil . getFileSystem ( path ) . delete ( new Path ( path ) , true ) ; \n \n <ect>
<comment> \n \n \t1 public void stopDC ( Cluster cluster , int dc ) { \n \n <ect>
\t1 protected boolean getBooleanParam ( final InvocationHandler invocationHandler , final Method method , final boolean defaultValue ) throws Throwable { \n \n \t2 Boolean value = ( Boolean ) invocationHandler . invoke ( configuration , method , null ) ; \n \n \t2 if ( value == null ) { \n \n \t3 value = defaultValue ; } \n \n <ect>
\t3 c2 . setNanos ( newNanos ) ; \n \n \t3 Assert . assertTrue ( timestampEquals ( e2 , c2 ) ) ; \n \n \t3 Assert . assertTrue ( c2 . equals ( e2 ) ) ; \n \n \t3 testTimestamp ( c2 , e2 ) ; } \n \n <ect>
\t1 public void onDisconnected ( ) { \n \n \t2 log . info ( <string_literal> + server + <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void onError ( int num , String msg ) { \n \n <ect>
\t2 if ( newServiceOffering == null ) { \n \n \t3 throw new InvalidParameterValueException ( <string_literal> ) ; } \n \n \t2 <comment> \n \n \t2 if ( ! ( vmInstance . getState ( ) . equals ( State . Stopped ) || vmInstance . getState ( ) . equals ( State . Running ) ) ) { \n \n <ect>
\t5 vmPath = host . _getVmPathFromPrimaryStorage ( name ) \n \n \t5 vmStatus = db_get_vm ( vmPath ) \n \n \t5 dct [ name ] = vmStatus [ 'status' ] \n \n \t4 except Exception , e : \n \n <ect>
\t3 synchronized ( this ) { \n \n \t4 if ( finished ) return null ; } \n \n \t3 if ( persistent ) { \n \n \t4 if ( sourceData == null ) { \n \n <ect>
\t6 <comment> \n \n \t6 ConcurrentOperationException ex = new ConcurrentOperationException ( <string_literal> ) ; \n \n \t6 throw ex ; } \n \n <ect>
\t6 nextByte = serialPort . getInputStream ( ) . read ( ) ; \n \n \t6 if ( nextByte == - 1 ) { \n \n \t7 continue ; } \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t5 LOG . info ( <string_literal> + destinationName + <string_literal> + message . toString ( ) ) ; \n \n \t5 session . rollback ( ) ; <comment> \n \n \t10 <comment> \n \n \t3 } catch ( JMSException ex ) { \n \n <ect>
\t5 LOG . trace ( Long . toHexString ( cnxn . sessionId ) \n \n \t7 + <string_literal> \n \n \t7 + ChannelBuffers . hexDump ( buf ) ) ; } \n \n \t4 if ( cnxn . throttled ) { \n \n <ect>
\t2 byte [ ] valueBytes = null ; \n \n \t2 try { \n \n \t3 valueBytes = serverDigestValue . getBytes ( getDigestCharset ( ) ) ; \n \n \t2 } catch ( UnsupportedEncodingException uee ) { \n \n <ect>
\t7 manager . close ( ) ; \n \n \t7 executor . shutdown ( ) ; } \n \n \t5 } ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t3 public boolean isSatisified ( ) throws Exception { \n \n \t4 int totalUnconsumed = 0 ; \n \n \t4 for ( TestConsumer testConsumer : testConsumers ) { \n \n \t5 long unconsumed = testConsumer . unconsumedSize ( ) ; \n \n <ect>
\t5 long tStamp = System . currentTimeMillis ( ) ; \n \n \t5 while ( i ++ < sendCount ) { \n \n \t6 producer . send ( session . createTextMessage ( <string_literal> ) ) ; \n \n \t6 if ( i%100 == 0 ) { \n \n <ect>
\t2 ShardRouting shard = ShardRouting . newUnassigned ( new ShardId ( <string_literal> , <string_literal> , 0 ) , true , StoreRecoverySource . EXISTING_STORE_INSTANCE , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , null ) ) ; \n \n \t2 shard = shard . initialize ( <string_literal> , null , - 1 ) ; \n \n \t2 shard = shard . moveToStarted ( ) ; \n \n \t2 AllocationId allocationId = shard . allocationId ( ) ; \n \n <ect>
\t3 <comment> \n \n \t3 Node n = pat . getNode ( ) ; \n \n \t3 if ( ! n . isURI ( ) ) \n \n \t3 { \n \n <ect>
\t1 @ Override \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 public boolean blvlck ( boolean fix , int width , SkipLevels < K , V > [ ] prevLevels ) { \n \n \t2 bf . log . warn ( <string_literal> + width ) ; \n \n <ect>
\t3 cfg . setProperty ( <string_literal> , dbUser ) ; \n \n \t3 cfg . setProperty ( <string_literal> , dbPassword ) ; \n \n \t3 factory = cfg . buildSessionFactory ( ) ; \n \n \t2 } else { \n \n <ect>
\t3 <comment> \n \n \t3 target = doGetProducer ( endpoint , true ) ; \n \n \t3 if ( target == null ) { \n \n \t4 if ( isStopped ( ) ) { \n \n <ect>
\t3 PathUtils . rmr ( StormConfig . worker_pids_root ( conf , workerId ) ) ; \n \n \t3 <comment> \n \n \t3 PathUtils . rmr ( StormConfig . worker_root ( conf , workerId ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 boolean sortDesc \t1 = true ; \n \n \t4 int pageSize \t2 = <number_literal> ; \n \n \t4 int page \t3 = 1 ; \n \n \t4 result = app . nodeQuery ( type ) . sort ( sortKey ) . order ( sortDesc ) . page ( page ) . pageSize ( pageSize ) . getResult ( ) ; \n \n <ect>
\t9 buf . append ( ' , ' ) ; \n \n \t8 buf . append ( testAddr ) ; \n \n \t7 } else { \n \n \t8 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <string_literal> ) . setSettings ( Settings . builder ( ) . put ( <string_literal> , <number_literal> ) ) . execute ( ) . actionGet ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . setWaitForActiveShards ( numShards . numPrimaries * <number_literal> ) . execute ( ) . actionGet ( ) ; \n \n <ect>
\t3 <comment> \n \n \t3 Coin value = Coin . ZERO ; \n \n \t3 for ( TransactionOutput output : req . tx . getOutputs ( ) ) { \n \n \t4 value = value . add ( output . getValue ( ) ) ; } \n \n <ect>
\t2 baos . close ( ) ; \n \n \t2 stream . setData ( baos . toByteArray ( ) ) ; \n \n \t2 <comment> \n \n \t2 if ( LOGGER . isLogging ( Level . INFO ) ) { \n \n <ect>
\t3 String s = entity . getFormDataPart ( <string_literal> , String . class , null ) ; \n \n \t3 Assert . assertEquals ( <string_literal> , <string_literal> , s ) ; \n \n \t3 <comment> \n \n \t3 for ( Map . Entry < String , List < InputPart > > formDataEntry : entity . getFormDataMap ( ) . entrySet ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 final String replicaNode = internalCluster ( ) . startNode ( ) ; \n \n \t2 final String primaryNode = internalCluster ( ) . startNode ( ) ; \n \n <ect>
\t2 try { \n \n \t3 Document doc = XmlHelper . parse ( xmlString ) ; \n \n \t3 Node node = XmlHelper . getRootNode ( doc ) ; \n \n \t3 if ( node == null ) { \n \n <ect>
\t1 LOG . debug ( <string_literal> \n \n \t2 + byteData , e ) ; \n \n \t1 } catch ( CharacterCodingException e ) { \n \n \t1 isNull = true ; \n \n <ect>
\t4 propHolder = new PropertiesHolder ( ) ; } } \n \n \t2 else { \n \n \t3 <comment> \n \n <ect>
\t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( 0 ) . currentNodeId ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 clusterState = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; \n \n <ect>
\t2 Hash to = msg . getTarget ( ) . getIdentity ( ) . getHash ( ) ; \n \n \t2 msg . timestamp ( <string_literal> ) ; \n \n \t2 if ( context . banlist ( ) . isBanlisted ( to ) ) { \n \n \t3 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 try { \n \n \t3 PublicKey tmpKey = generatePubKey ( msg . getBuffer ( ) ) ; \n \n \t3 sendSecretKey ( secret_key , tmpKey , msg . getSrc ( ) ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 indexStats = client ( ) . admin ( ) . indices ( ) . prepareStats ( <string_literal> ) . get ( ) . getIndex ( <string_literal> ) ; \n \n \t2 assertFlushResponseEqualsShardStats ( indexStats . getShards ( ) , syncedFlushResult . getShardsResultPerIndex ( ) . get ( <string_literal> ) ) ; \n \n \t2 refresh ( ) ; \n \n \t2 assertThat ( client ( ) . prepareSearch ( ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( ( long ) numDocs . get ( ) ) ) ; \n \n <ect>
\t6 hbaseAdmin . disableTable ( tableName ) ; } \n \n \t5 hbaseAdmin . deleteTable ( tableName ) ; \n \n \t5 logger . info ( <string_literal> + htableName ) ; \n \n \t4 } else { \n \n <ect>
\t1 } catch ( HostNotFoundException e1 ) { \n \n \t2 associatedWithCluster = false ; \n \n \t1 } catch ( AmbariException e1 ) { \n \n \t2 <comment> \n \n <ect>
\t4 mapper . send ( Collections . singletonMap ( new TestJob ( ) , ( GridNode ) null ) ) ; \n \n \t4 assert false ; } \n \n \t3 catch ( GridException e ) { \n \n <ect>
\t5 previousVersions . put ( node . getId ( ) , previousVersion ) ; } \n \n \t4 <comment> \n \n \t4 for ( String storeName : storeNames ) { \n \n \t5 for ( Node node : cluster . getNodes ( ) ) { \n \n <ect>
\t4 data . free ( ) ; } } \n \n \t2 @ Override \n \n \t2 protected void onFullTextMessage ( WebSocketChannel channel , BufferedTextMessage message ) { \n \n \t3 final String text = message . getData ( ) ; \n \n <ect>
static String ExpectedResults = \n \n \t1 <string_literal> Company1 \\ <string_literal> <number_literal> \\ <string_literal> <number_literal> \\ <string_literal> Female \\ <string_literal> M25 \\ <string_literal> ; \n \n static { \n \n \t1 LOG . info ( " Using DB2 CONNECT_STRING HOST_URL is : <string_literal> <ect>
\t6 deployment = new DeploymentBuilder ( ) . build ( is , loader ) ; \n \n \t5 } catch ( ParsingException e ) { \n \n \t6 throw new RuntimeException ( e ) ; } } \n \n \t4 deploymentContext = new SamlDeploymentContext ( deployment ) ; \n \n <ect>
\t2 LOG . warn ( <string_literal> ) ; \n \n \t2 state = ElbWorkflowState . WORKFLOW_CANCELLED ; \n \n \t2 return ; } \n \n \t2 state = ElbWorkflowState . WORKFLOW_FAILED ; \n \n <ect>
\t2 if ( maxContextSize != null ) { \n \n \t3 try { \n \n \t4 maxBrowserSize = Integer . parseInt ( maxContextSize ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t2 if ( null != aliasesObj && aliasesObj instanceof List ) { \n \n \t3 try { \n \n \t3 aliases . addAll ( ( List < String > ) aliasesObj ) ; \n \n \t3 } catch ( ClassCastException e ) { \n \n <ect>
\t8 break ; \n \n \t7 default : \n \n \t8 logger . warn ( <string_literal> , c ) ; } } \n \n \t4 } else { \n \n <ect>
\t4 sendCommand ( player . getMacAddress ( ) + <string_literal> ) ; } } \n \n \t2 private void handlePlayerUpdate ( String message ) { \n \n \t3 String [ ] messageParts = message . split ( <string_literal> ) ; \n \n \t3 if ( messageParts . length < <number_literal> ) { \n \n <ect>
\t3 if ( ( serverClientParts . length > <number_literal> ) || ( serverParts . length < <number_literal> ) \n \n \t5 || ( serverParts . length > <number_literal> ) ) { \n \n \t4 throw new ConfigException ( addressStr + wrongFormat ) ; } \n \n \t3 if ( serverClientParts . length == <number_literal> ) { \n \n <ect>
\t1 protected Map < String , Map < String , String > > deviceConfigCache = new HashMap < String , Map < String , String > > ( ) ; \n \n \t1 public SamsungAcBinding ( ) { } \n \n \t1 @ Override \n \n \t1 public void activate ( ) { \n \n <ect>
\t3 BufferedOakDirectory . setEnableWritingSingleBlobIndexFile ( PropertiesUtil . toBoolean ( \n \n \t5 config . get ( PROP_NAME_ENABLE_SINGLE_BLOB_PER_INDEX_FILE ) , \n \n \t5 PROP_ENABLE_SINGLE_BLOB_PER_INDEX_FILE_DEFAULT ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 cleanupOfflineMigrations ( ) ; \n \n \t3 cleanupNonexistentMigrations ( getConnector ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 boolean isValidSignature = verify ( signedFile , signingPublicKey ) ; \n \n \t3 if ( isValidSignature ) \n \n \t4 return true ; } \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 client . waitForActive ( true ) ; \n \n \t2 server . waitForActive ( true ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , server . group . size ( ) ) ; \n \n <ect>
\t3 } else { \n \n \t4 try { \n \n \t5 VirtualEthernetCardType . valueOf ( nicDeviceType ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 else \n \n \t3 { \n \n \t4 { \n \n <ect>
\t3 MeshQuerySource . queryCount . dec ( ) ; \n \n \t3 if ( queryOpProcessor != null ) { \n \n \t4 queryOpProcessor . close ( ) ; } \n \n \t3 if ( finalEng != null ) { \n \n <ect>
\t2 command . setExitCode ( Constants . EXIT_CODE_UNKNOWN ) ; \n \n \t2 return ; } \n \n \t2 <comment> \n \n \t2 if ( attempts ++ < = <number_literal> && cmd . getExitCode ( ) != 0 ) { \n \n <ect>
\t4 LOG . warn ( <string_literal> , destination ) ; } \n \n \t3 if ( view != null ) { \n \n \t4 registerDestination ( objectName , destName , view ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 throw new ConnectionException ( DisconnectReason . PROTOCOL_ERROR , \n \n \t9 <string_literal> + type + <string_literal> ) ; } \n \n \t1 protected void gotUnknown ( Message msg , SSHPacket buf ) \n \n \t3 throws ConnectionException , TransportException { \n \n <ect>
<number_literal> final Predicate < String > predicate ) { \n \n \t2 if ( providers == null || providers . isEmpty ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return null ; } \n \n <ect>
\t1 tran . commit ( ) ; \n \n \t1 } catch ( NoSuchElementException e ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t3 mbs . registerMBean ( getMonitor ( ) , mxbeanName ) ; \n \n \t2 } catch ( MalformedObjectNameException e ) { \n \n \t3 LOGGER . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( NotCompliantMBeanException e ) { \n \n <ect>
\t3 if ( clientSocket != null && ! clientSocket . isClosed ( ) ) { \n \n \t4 try { \n \n \t5 clientSocket . close ( ) ; \n \n \t4 } catch ( IOException ioEx ) { \n \n <ect>
\t3 <comment> \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 HueSettings settings = activeBridge . getSettings ( ) ; \n \n \t3 if ( settings == null ) { \n \n <ect>
\t3 try { \n \n \t4 serverSocket . close ( ) ; \n \n \t4 serverSocketChannel . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 } catch ( NotConnectedException ex ) { \n \n \t6 <comment> \n \n \t6 if ( logMINOR ) Logger . minor ( this , <string_literal> + msg + <string_literal> + source + <string_literal> + ex ) ; \n \n \t5 } catch ( SyncSendWaitedTooLongException ex ) { \n \n <ect>
\t2 if ( -- registrationCount < = 0 ) { \n \n \t3 try { \n \n \t4 dataStore . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 logger . debug ( <string_literal> , connectAttemptCount , connectionId ) ; \n \n \t2 InetAddressAndPort remote = connectionId . remote ( ) ; \n \n \t2 if ( ! authenticator . authenticate ( remote . address , remote . port ) ) \n \n \t2 { \n \n <ect>
\t1 methDefault . invoke ( connection , timeZoneObj ) ; \n \n \t1 TimeZone . setDefault ( timeZoneObj ) ; \n \n \t1 LOG . info ( <string_literal> + timeZoneObj . getID ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 assert rsrc4 == rsrc8 ; \n \n \t4 log . info ( <string_literal> + rsrc1 ) ; \n \n \t4 log . info ( <string_literal> + rsrc2 ) ; \n \n \t4 log . info ( <string_literal> + rsrc3 ) ; \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 return null ; } \n \n \t1 @ Override \n \n \t1 public void attach ( SysTransState systemState ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void testEnded ( String host ) { \n \n <ect>
\t2 Thread . sleep ( <number_literal> ) ; \n \n \t2 app . getBean ( <string_literal> , ProducerTemplate . class ) . sendBody ( <string_literal> , <string_literal> ) ; \n \n \t2 mock . assertIsSatisfied ( ) ; \n \n \t2 <comment> \n \n <ect>
\t2 if ( ! plainText && ( type instanceof CmsResourceTypeXmlContent ) ) { \n \n \t3 try { \n \n \t4 result = CmsWorkplaceEditorManager . checkAcaciaEditorAvailable ( A_CmsUI . getCmsObject ( ) , resource ) ; \n \n \t3 } catch ( CmsRuntimeException e ) { \n \n <ect>
\t3 pc . setPassword ( System . getProperty ( SYSPROP_SUPER_PASSWORD ) . toCharArray ( ) ) ; \n \n \t2 } else if ( credentials . containsKey ( userName ) ) { \n \n \t3 pc . setPassword ( credentials . get ( userName ) . toCharArray ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t1 var payload = { <string_literal> : x , <string_literal> : y } ; \n \n \t1 this . POST ( url , payload ) ; } \n \n Recorder . prototype . POST = function ( url , payload ) { \n \n \t1 var me = this ; \n \n <ect>
\t3 ValidationXMLFoo foo = new ValidationXMLFoo ( <string_literal> ) ; \n \n \t3 Response response = client . target ( generateURL ( <string_literal> ) ) . request ( ) . accept ( MediaType . APPLICATION_XML ) . post ( Entity . entity ( foo , <string_literal> ) ) ; \n \n \t3 Assert . assertEquals ( HttpResponseCodes . SC_INTERNAL_SERVER_ERROR , response . getStatus ( ) ) ; \n \n \t3 ViolationReport report = response . readEntity ( ViolationReport . class ) ; \n \n <ect>
\t5 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t6 _log . debug ( <string_literal> ) ; } \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 log . error ( <string_literal> + name , \n \n \t8 e ) ; } } } \n \n \t2 } catch ( RuntimeException ex ) { \n \n <ect>
\t4 completedByStrategy . incrementAndGet ( ) ; } } \n \n \t2 <comment> \n \n \t2 executorService . submit ( new Runnable ( ) { \n \n \t3 public void run ( ) { \n \n <ect>
\t2 setAlternateResponseData ( ) ; \n \n \t2 assertion . setXPathString ( <string_literal> ) ; \n \n \t2 assertion . setNegated ( true ) ; \n \n \t2 AssertionResult res = assertion . getResult ( jmctx . getPreviousResult ( ) ) ; \n \n <ect>
\t2 break ; } \n \n \t2 Thread . sleep ( <number_literal> ) ; } } \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t6 . append ( <string_literal> ) ; \n \n \t4 if ( iterator . hasNext ( ) ) \n \n \t5 sb . append ( <string_literal> ) ; } \n \n \t3 LOGGER . debug ( <string_literal> , sb . toString ( ) ) ; \n \n <ect>
\t1 conf_select_name = <string_literal> \n \n \t1 base_dir = os . path . dirname ( os . path . dirname ( os . path . realpath ( __file__ ) ) ) \n \n \t1 config_dir = self . get_config_dir_during_stack_upgrade ( env , base_dir , conf_select_name ) \n \n \t1 if config_dir : \n \n <ect>
\t2 logger . error ( <string_literal> , planId ( ) , peer . toString ( ) ) ; \n \n \t2 closeSession ( State . FAILED ) ; } \n \n \t1 public void onRestart ( InetAddressAndPort endpoint , EndpointState epState ) \n \n \t1 { \n \n <ect>
\t2 if ( opts == null ) { \n \n \t3 logger . debug ( <string_literal> , defaultStep ) ; } \n \n \t2 Short step = Tools . getShortOpt ( ConfigOptsDimmable . STEP . toString ( ) , opts , defaultStep ) ; \n \n \t2 if ( increaseDecrease == null ) { \n \n <ect>
\t5 NginxClojureSocketImpl s = ( NginxClojureSocketImpl ) POSTED_EVENTS_DATA . remove ( data ) ; \n \n \t5 s . closeByPostEvent ( ) ; \n \n \t5 return NGX_OK ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t5 <comment> \n \n \t4 } catch ( PeerTooOldException e ) { \n \n \t5 if ( crypto . isOpennet ) { \n \n \t6 <comment> \n \n <ect>
\t6 String line = br . readLine ( ) ; \n \n \t6 logger . trace ( <string_literal> , line ) ; \n \n \t6 processNextLine ( line ) ; } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 if ( domain . getParent ( ) != null && domain . getParent ( ) . longValue ( ) >= Domain . ROOT_DOMAIN ) { \n \n \t3 parent = domain . getParent ( ) . longValue ( ) ; } \n \n \t2 DomainVO parentDomain = findById ( parent ) ; \n \n \t2 if ( parentDomain == null ) { \n \n <ect>
\t7 JmxUtils . createObjectName ( JmxUtils . getPackageName ( this . getClass ( ) ) , \n \n <number_literal> JmxUtils . getClassName ( this . connectionStats . getClass ( ) ) ) ) ; \n \n \t2 <comment> \n \n \t2 this . channel = this . bootstrap . bind ( new InetSocketAddress ( getServicePort ( ) ) ) ; \n \n <ect>
\t6 printResults ( hits ) ; } \n \n \t5 private void printResults ( Hits hits ) { \n \n \t6 LOG . debug ( <string_literal> + hits . getNumberOfHits ( ) ) ; \n \n \t6 for ( int i = 0 ; i < hits . getNumberOfHits ( ) ; i ++ ) { \n \n <ect>
{ \n \n \t1 final RetryCallback callback = new RetryCallback ( ) { \n \n \t1 @ Override \n \n \t1 protected void retry ( ) { \n \n <ect>
\t2 getAllLevels ( this , lvls ) ; \n \n \t2 if ( bf . log . shouldLog ( Log . DEBUG ) ) \n \n \t3 bf . log . debug ( <string_literal> + lvls . size ( ) + <string_literal> ) ; \n \n \t2 if ( ! this . equals ( lvls . last ( ) ) ) { \n \n <ect>
\t2 clusterState = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 routingNodes = clusterState . getRoutingNodes ( ) ; \n \n \t2 clusterState = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 routingNodes = clusterState . getRoutingNodes ( ) ; \n \n <ect>
\t3 final int index = i ; \n \n \t3 Future < String > out = executor . submit ( new Callable < String > ( ) { \n \n \t4 public String call ( ) throws Exception { \n \n \t5 String reply = template . requestBody ( <string_literal> , index , String . class ) ; \n \n <ect>
\t2 logger . info ( <string_literal> , <string_literal> , <number_literal> , <string_literal> , <number_literal> , <number_literal> , <number_literal> , new String ( <string_literal> ) ) ; } \n \n \t1 public void checkFailNumberOfArguments3 ( ) { \n \n \t2 logger . info ( <string_literal> , <string_literal> , <number_literal> , <string_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> , new String ( <string_literal> ) ) ; } \n \n \t1 public void checkNumberOfArgumentsParameterizedMessage1 ( ) { \n \n <ect>
\t10 return address ; } \n \n \t8 } catch ( Throwable e ) { \n \n \t9 logger . warn ( <string_literal> + e . getMessage ( ) , e ) ; } } } \n \n \t5 } catch ( Throwable e ) { \n \n <ect>
<comment> \n \n \t2 if ( ! req . send ( ) ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 logger . info ( <string_literal> , m_refreshInterval / <number_literal> ) ; } \n \n \t2 long deadDeviceCount = <number_literal> ; \n \n \t2 if ( m_config . containsKey ( <string_literal> ) ) { \n \n \t3 deadDeviceCount = s_parseLong ( m_config . get ( <string_literal> ) , 2L , 100000L ) ; \n \n <ect>
\t5 try { \n \n \t6 MetaType m = MetaType . valueOf ( MetaType . class , metaType . trim ( ) ) ; \n \n \t6 insertFilters . add ( m ) ; \n \n \t5 } catch ( Exception ignored ) { \n \n <ect>
\t4 <comment> \n \n \t3 return first ; } \n \n \t2 Page < T > page = new Page < T > ( seq . getFirst ( ) ) ; \n \n \t2 page . makeFree ( 0 ) ; \n \n <ect>
\t3 if ( removeBouncyCastle ) { \n \n \t4 try { \n \n \t5 Security . removeProvider ( BouncyCastleProvider . PROVIDER_NAME ) ; \n \n \t4 } catch ( SecurityException ex ) { \n \n <ect>
\t2 { \n \n \t3 artifactIds . removeAll ( includedIds ) ; \n \n \t3 for ( String id : artifactIds ) \n \n \t3 { \n \n <ect>
\t5 } catch ( ResourceUnavailableException e ) { \n \n \t6 s_logger . warn ( <string_literal> + provider . getProviderName ( ) + <string_literal> + provider . getId ( ) , e ) ; \n \n \t4 return false ; \n \n \t3 } catch ( ConcurrentOperationException e ) { \n \n <ect>
\t1 try { \n \n \t2 <comment> \n \n \t2 first = pool . getAnyTransport ( servers , true ) . getSecond ( ) ; \n \n \t1 } catch ( TTransportException e ) { \n \n <ect>
\t6 -- counters [ <number_literal> ] ; \n \n \t6 update ( group ) ; \n \n \t6 Thread . sleep ( <number_literal> ) ; \n \n \t5 } else { \n \n <ect>
\t8 <comment> \n \n \t8 crc = crc2 ; } } \n \n \t6 <comment> \n \n \t6 if ( crc2 != crc ) { \n \n <ect>
\t4 . setType ( <string_literal> ) . setSettings ( Settings . builder ( ) \n \n \t8 . put ( <string_literal> , location ) \n \n \t4 ) . get ( ) ; \n \n \t2 assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; \n \n <ect>
\t8 result [ i ] . z = Integer . parseInt ( parts [ <number_literal> ] ) ; } } \n \n \t6 rawIndices . add ( result ) ; \n \n \t6 break ; } \n \n \t5 default : \n \n <ect>
\t3 data += <string_literal> ; \n \n \t3 client . getOutputStream ( ) . write ( data . getBytes ( ) ) ; \n \n \t3 client . getOutputStream ( ) . flush ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 public BTreeIndex ( PageFile pageFile , Page page ) { \n \n \t2 this ( pageFile , page . getPageId ( ) ) ; } \n \n \t1 synchronized public void load ( Transaction tx ) throws IOException { \n \n \t2 if ( loaded . compareAndSet ( false , true ) ) { \n \n <ect>
\t10 s . tryAcquire ( ( long ) timeout , TimeUnit . MILLISECONDS ) ; \n \n \t10 myChallenge = challengeMap \n \n <number_literal> . containsKey ( m . tag ) ; } \n \n \t8 } catch ( InterruptedException e ) { \n \n <ect>
\t5 . getOSGiVersion ( ) ; \n \n \t4 builder . setProperty ( Constants . BUNDLE_VERSION , version . toString ( ) ) ; \n \n \t4 if ( builder . getProperty ( Constants . SNAPSHOT ) == null ) { \n \n \t5 builder . setProperty ( Constants . SNAPSHOT , TSTAMP ) ; } } \n \n <ect>
\t2 for ( CreateUserData x : cua ) { \n \n \t4 x . closeAll ( ) ; } } \n \n \t1 @ Test \n \n \t1 public void performanceTest ( ) throws Exception { \n \n <ect>
\t4 } catch ( InterruptedException e ) { \n \n \t5 <comment> \n \n \t5 break ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 expandSayasElements ( doc ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 matchAndExpandPatterns ( doc ) ; \n \n <ect>
\t2 abcresult . expectedMessageCount ( 1 ) ; \n \n \t2 abcresult . whenAnyExchangeReceived ( new Processor ( ) { \n \n \t3 @ Override \n \n \t3 public void process ( Exchange exchange ) throws Exception { \n \n <ect>
\t4 boolean nameMatches = matchesSuffix ( classInfo . getName ( ) ) ; \n \n \t4 try { \n \n \t5 return inPackage && ( nameMatches || ( checkImplementsAction && com . opensymphony . xwork2 . Action . class . isAssignableFrom ( classInfo . get ( ) ) ) ) ; \n \n \t4 } catch ( ClassNotFoundException ex ) { \n \n <ect>
\t3 Iterator < KerberosTicket > iterator = kerberosTickets . iterator ( ) ; \n \n \t3 if ( iterator . hasNext ( ) ) { \n \n \t4 kerberosTicket = iterator . next ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 if ( msg != null ) { \n \n \t5 Message last = ( Message ) wireFormat . unmarshal ( new ByteSequence ( msg ) ) ; \n \n \t5 brokerSeq = last . getMessageId ( ) . getBrokerSequenceId ( ) ; \n \n \t4 } else { \n \n <ect>
\t1 @ SuppressWarnings ( { <string_literal> , <string_literal> } ) \n \n \t1 private static void applyRelationalConstraints ( ValidatorFactory factory , ActivationContext activationContext ) { \n \n \t2 final ConfigurationService cfgService = activationContext . getServiceRegistry ( ) . getService ( ConfigurationService . class ) ; \n \n \t2 if ( ! cfgService . getSetting ( BeanValidationIntegrator . APPLY_CONSTRAINTS , StandardConverters . BOOLEAN , true ) ) { \n \n <ect>
\t1 private void ensureVendorInitialized ( ) { \n \n \t2 if ( vendor != null ) return ; \n \n \t2 try { \n \n \t3 String productName = getDatabaseProductType ( ) ; \n \n <ect>
\t6 LOG . info ( <string_literal> + <string_literal> \n \n \t8 + createStatements [ i ] + <string_literal> + e . getMessage ( ) + <string_literal> + e . getSQLState ( ) \n \n \t8 + <string_literal> + e . getErrorCode ( ) ) ; } } \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t4 executorService . submit ( new Runnable ( ) { \n \n \t5 @ Override \n \n \t5 public void run ( ) { \n \n \t6 try { \n \n <ect>
<comment> \n \n \t1 PooledTunnelCreatorConfig removeFromBuilding ( long id ) { \n \n <ect>
\t3 long before = Clock . getInstance ( ) . now ( ) ; \n \n \t3 testDest ( host , port , conOptions , destName ) ; \n \n \t3 long after = Clock . getInstance ( ) . now ( ) ; \n \n \t3 long difference = after - before ; \n \n <ect>
\t3 log . error ( message ) ; \n \n \t3 String pre = WOApplication . application ( ) . name ( ) + <string_literal> + localHostName ; \n \n \t3 globalErrorDictionary . takeValueForKey ( pre + message , <string_literal> ) ; \n \n \t2 } catch ( NSForwardException ne ) { \n \n <ect>
\t5 break ; } } \n \n \t3 <comment> \n \n \t3 if ( is_alien_vm ) { \n \n \t4 map . put ( alien_vm_count -- , new AgentVmInfo ( entry . getKey ( ) , null , null , entry . getValue ( ) . second ( ) , entry . getValue ( ) . first ( ) ) ) ; \n \n <ect>
<comment> \n \n \t1 private void build ( File home , File rootPath ) { \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public long getCloseConnectionWatchTimeout ( ) { \n \n <ect>
\t5 String topic = sub . getProperty ( StructrApp . key ( MessageSubscriber . class , <string_literal> ) ) ; \n \n \t5 if ( topic != null ) { \n \n \t6 subscribeTopic ( thisClient , topic ) ; } \n \n \t4 } catch ( FrameworkException e ) { \n \n <ect>
\t5 outputStream . write ( buffer , 0 , n1 ) ; } \n \n \t4 logger . info ( <string_literal> ) ; } \n \n \t3 @ Override \n \n \t3 public void onAllDataRead ( ) throws IOException { \n \n <ect>
\t3 exceptionOccurred = true ; \n \n \t2 } finally { \n \n \t3 <comment> \n \n \t3 if ( exceptionOccurred ) { \n \n <ect>
\t3 } catch ( JMSException ex2 ) { \n \n \t4 <comment> \n \n \t5 log . debug ( <string_literal> , ex2 ) ; } \n \n <ect>
\t3 final AsyncEntityProducer entityProducer , \n \n \t3 final AsyncExecChain . Scope scope , \n \n \t3 final AsyncExecChain chain , \n \n \t3 final AsyncExecCallback asyncExecCallback ) { \n \n <ect>
\t1 ModifyPropertyValueResponseType reply = request . getReply ( ) ; \n \n \t1 if ( INTERNAL_OP . equals ( request . getName ( ) ) ) { \n \n \t1 if ( ! Contexts . lookup ( ) . hasAdministrativePrivileges ( ) ) { \n \n \t2 throw new EucalyptusCloudException ( <string_literal> ) ; } \n \n <ect>
\t2 return findConfigFile ( ) . path ( ) ; } \n \n \t1 private Resource findOrCreateConfFile ( ) throws IOException { \n \n \t2 Resource xmlFile = findConfigFile ( ) ; \n \n \t2 if ( Resources . exists ( xmlFile ) ) { \n \n <ect>
\t2 log . warn ( <string_literal> + stop . getJobKey ( ) + <string_literal> + stop . getRunCount ( ) ) ; \n \n \t2 minion . removeJobFromQueue ( stop . getJobKey ( ) , false ) ; \n \n \t2 List < JobTask > match = minion . getMatchingJobs ( stop ) ; \n \n \t2 if ( match . size ( ) == 0 && stop . getNodeID ( ) != null && stop . getNodeID ( ) >= 0 ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 return paths ; } \n \n \t1 @ Override \n \n \t1 public Iterable < FileStore > getFileStores ( ) { \n \n \t4 logger . info ( <string_literal> ) ; \n \n <ect>
\t3 if ( matched ) { \n \n \t4 try { \n \n \t5 version = Version . fromString ( p . getPersistentProperty ( PROJECT_PROPERTY_MODULEVERSION ) ) ; } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t7 currentPeriodicTrigger = timer . scheduleAtFixedRate ( \n \n \t9 new ScheduledTrigger ( ) , \n \n \t9 durationTillNextMillis , baseInterval , TimeUnit . MILLISECONDS ) ; \n \n \t7 return new CheckpointTriggerResult ( CheckpointDeclineReason . MINIMUM_TIME_BETWEEN_CHECKPOINTS ) ; } } \n \n <ect>
\t3 effectiveProviderType = TYPE_METRIC ; } \n \n \t2 if ( TYPE_METRIC . equals ( effectiveProviderType ) ) { \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 return createMetricsProvider ( executor ) ; } \n \n <ect>
\t2 { \n \n \t3 dsg = DatasetGraphFactory . create ( ) ; \n \n \t3 <comment> \n \n \t3 String filename = getValue ( argFile ) ; \n \n <ect>
\t2 if ( prop != null && prop . getProperty ( versionKey ) != null ) { \n \n \t3 String strValue = prop . getProperty ( versionKey ) ; \n \n \t3 value = tryParse ( strValue ) ; } \n \n <ect>
\t2 this . parser = ctx . parser ( ) ; } \n \n \t1 final String translate ( String sql ) { \n \n \t2 log . debug ( <string_literal> , sql ) ; \n \n \t2 String result = ctx . render ( parser . parseQuery ( sql ) ) ; \n \n <ect>
\t3 <comment> \n \n \t3 app . cypher ( <string_literal> , Collections . emptyMap ( ) ) ; \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t4 if ( ! uri . toLowerCase ( ) . endsWith ( <string_literal> ) ) { \n \n \t5 LOGGER . debug ( <string_literal> + file + <string_literal> + uri ) ; \n \n \t5 return handleRequestWithResourceInsideJar ( request ) ; } } \n \n \t2 } else { \n \n <ect>
\t4 String prvkeyPath = prvKeyFile . getAbsolutePath ( ) ; \n \n \t4 try ( BufferedWriter prvt_key_file = new BufferedWriter ( new FileWriter ( prvKeyFile ) ) ; ) { \n \n \t5 prvt_key_file . write ( prvKey ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t3 GetUploadParamsResponse response = _volumeService . uploadVolume ( this ) ; \n \n \t3 response . setResponseName ( getCommandName ( ) ) ; \n \n \t3 setResponseObject ( response ) ; \n \n \t2 } catch ( MalformedURLException | ResourceAllocationException e ) { \n \n <ect>
\t3 QName typeName = part . getTypeName ( ) ; \n \n \t3 if ( typeName != null ) { \n \n \t4 schemaType = wsdlContext . getSchemaTypeLoader ( ) . findType ( typeName ) ; \n \n \t4 if ( schemaType == null ) { \n \n <ect>
\t4 case RecognitionException : \n \n \t5 log . debug ( <string_literal> ) \n \n \t5 return new ParseStatus ( ParseCode . INCOMPLETE ) \n \n \t4 default : \n \n <ect>
\t5 assert ( annotation != null ) ; \n \n \t5 if ( match ( annotation . topic ( ) , subject ) ) { \n \n \t6 return method ; } } \n \n \t3 } else { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t3 try { \n \n \t4 defaultBundle = ( ResourceBundle ) Introspector . getBeanInfo ( testBeanClass ) . getBeanDescriptor ( ) . getValue ( \n \n \t6 GenericTestBeanCustomizer . RESOURCE_BUNDLE ) ; \n \n \t3 } catch ( IntrospectionException e ) { \n \n <ect>
\t2 if ( proxiedBy != null ) { \n \n \t3 LOGGER . debug ( <string_literal> , proxiedBy . getId ( ) ) ; \n \n \t3 final RegisteredService proxyingService = this . servicesManager . findServiceBy ( proxiedBy ) ; \n \n \t3 if ( proxyingService != null ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> ) ; \n \n \t3 _configDao . update ( <string_literal> , <string_literal> ) ; \n \n \t3 s_logger . debug ( <string_literal> ) ; \n \n \t3 _configDao . update ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t2 for ( String metric : metrics ) { \n \n \t3 metric = metric . trim ( ) ; \n \n \t3 if ( ! StringUtils . isBlank ( metric ) ) { \n \n \t4 debugMetricNames . add ( metric ) ; } } \n \n <ect>
\t1 <comment> \n \n \t1 if ( eventSerializerType == null || eventSerializerType . isEmpty ( ) ) { \n \n \t1 eventSerializerType = \n \n \t2 <string_literal> ; \n \n <ect>
\t1 public void testXPathSTaXPerformanceRoute ( ) throws Exception { \n \n \t2 NotifyBuilder notify = new NotifyBuilder ( context ) . whenDone ( size ) . create ( ) ; \n \n \t2 boolean matches = notify . matches ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t2 log . info ( <string_literal> + size + <string_literal> + TimeUtils . printDuration ( watch . stop ( ) ) ) ; \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void basicSeekZero ( ) throws IOException , NoSuchAlgorithmException { \n \n <ect>
\t2 if ( request . getOutput ( ) == null ) { \n \n \t3 if ( request . problemOccurred ( ) ) { \n \n \t4 logger . error ( <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t2 } else { \n \n \t3 final Status currentStatus = host . getStatus ( ) ; \n \n \t3 if ( currentStatus == Status . Down || currentStatus == Status . Alert || currentStatus == Status . Removed ) { \n \n <ect>
\t1 case LessThanOrEqualToThreshold : \n \n \t2 comparisonOperatorStr = <string_literal> ; \n \n \t2 break ; \n \n \t1 default : \n \n <ect>
\t7 break ; \n \n \t6 case Broken : \n \n \t7 throw new IllegalStateException ( <string_literal> ) ; \n \n \t6 case StopRequested : \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t4 break ; } \n \n \t3 default : \n \n \t4 assert false : <string_literal> + req ; } \n \n <ect>
<number_literal> asGetMoreCommandResponseDocument ( queryResult , responseBuffers ) , connection . getDescription ( ) , \n \n <number_literal> System . nanoTime ( ) - startTimeNanos , commandListener ) ; } \n \n \t3 } finally { \n \n \t4 responseBuffers . close ( ) ; } \n \n <ect>
\t5 if ( fileEntry == null ) { \n \n \t6 Logger . warn ( TAG , <string_literal> ) \n \n \t6 dialog . dismiss ( ) \n \n \t6 return @ OnClickListener } \n \n <ect>
\t2 resultVarsSet = true ; \n \n \t2 if ( getQueryPattern ( ) == null ) \n \n \t2 { \n \n \t3 if ( ! this . isDescribeType ( ) ) \n \n <ect>
\t3 sock . socket ( ) . shutdownOutput ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 <comment> \n \n <ect>
\t4 throw ( CommandException ) ex ; } \n \n \t3 else { \n \n \t4 throw new CommandException ( ex ) ; } } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
\t3 result . success = o ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t5 <comment> \n \n \t5 ColumnFamilyStore store = ColumnFamilyStore . getIfExists ( desc . keyspace , desc . columnFamily ) ; \n \n \t5 if ( store == null ) \n \n \t5 { \n \n <ect>
\t2 if ( profile == null ) return null ; \n \n \t2 Hash peer = profile . getPeer ( ) ; \n \n \t2 if ( peer . equals ( _us ) ) { \n \n \t3 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t3 allTasksSubmitted . set ( true ) ; \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t2 testData . prepare ( ) ; \n \n \t2 Session session = openSession ( ) ; \n \n \t2 session . enableFilter ( <string_literal> ) \n \n \t4 . setParameterList ( <string_literal> , new String [ ] { <string_literal> , <string_literal> } ) ; \n \n <ect>
\t4 if ( firstAddr . equals ( secondAddr ) ) { \n \n \t5 result = true ; } \n \n \t3 } catch ( IOException e ) { \n \n \t4 if ( firstAddr == null ) { \n \n <ect>
\t4 if ( multifactorAuthenticationProvider . isAvailable ( registeredService ) ) { \n \n \t5 final Event event = validateEventIdForMatchingTransitionInContext ( multifactorAuthenticationProvider . getId ( ) , context , \n \n \t7 buildEventAttributeMap ( authentication . getPrincipal ( ) , registeredService , multifactorAuthenticationProvider ) ) ; \n \n \t5 return CollectionUtils . wrapSet ( event ) ; } \n \n <ect>
\t4 String . class ) ; \n \n \t2 String namespaceName = exchange . getIn ( ) . getHeader ( \n \n \t4 KubernetesConstants . KUBERNETES_NAMESPACE_NAME , String . class ) ; \n \n \t2 if ( ObjectHelper . isEmpty ( rqName ) ) { \n \n <ect>
\t7 _log . warn ( ri . getIdentity ( ) . calculateHash ( ) + <string_literal> + _key + <string_literal> + _routerFile ) ; \n \n \t5 } else if ( ri . getPublished ( ) < = _knownDate ) { \n \n \t6 <comment> \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 String fileBase64 = Base64 . byteArrayToBase64 ( fileKeyObj . toString ( ) . getBytes ( ) ) ; \n \n \t1 if ( searchFileBase64 . equals ( fileBase64 ) ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t1 dbExecute ( destinationDatabase , <string_literal> $ { sourceSchema } \\ <string_literal> $ { destinationSchema } \\ <string_literal> ) \n \n \t1 if ( getDefaultSchemaName ( ) == sourceSchema ) { \n \n \t2 dbExecute ( destinationDatabase , <string_literal> ) } \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 if ( server != null ) { \n \n \t1 try { \n \n \t2 server . stop ( ) ; } \n \n \t1 catch ( Exception ex ) { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t8 <comment> \n \n \t8 long outputSize = getContext ( ) . getVertexStatistics ( predPredVertexName ) . getOutputStatistics ( pred . getOperatorKey ( ) . toString ( ) ) . getDataSize ( ) ; \n \n \t8 int desiredNumReducers = ( int ) Math . ceil ( ( double ) outputSize / bytesPerTask ) ; \n \n \t8 predPred . setEstimatedParallelism ( desiredNumReducers ) ; \n \n <ect>
\t3 <comment> \n \n \t3 log . error ( <string_literal> ) ; \n \n \t3 throw new RuntimeException ( e ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testFirstSegmentInterest ( ) { \n \n <ect>
\t3 for ( Class < ? extends AtmosphereInterceptor > a : DEFAULT_ATMOSPHERE_INTERCEPTORS ) { \n \n \t4 if ( ! excludedInterceptors . contains ( a . getName ( ) ) ) { \n \n \t5 interceptors . add ( newAInterceptor ( a ) ) ; \n \n \t4 } else { \n \n <ect>
\t2 return false ; } \n \n \t1 protected abstract ClusterBlockException checkBlock ( Request request , ClusterState state ) ; \n \n \t1 @ Override \n \n \t1 protected final void doExecute ( final Request request , ActionListener < Response > listener ) { \n \n <ect>
\t3 if ( crawlRules . isCrawlHiddenAnchors ( ) && eventToFire . getElement ( ) != null \n \n \t5 && <string_literal> . equals ( eventToFire . getElement ( ) . getTag ( ) ) ) { \n \n \t4 isFired = visitAnchorHrefIfPossible ( eventToFire ) ; \n \n \t3 } else { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; \n \n <ect>
\t3 { \n \n \t4 bytes = internalElement ( true , watcher ) ; } \n \n \t3 catch ( NoSuchElementException dummy ) \n \n \t3 { \n \n <ect>
\t4 Component component = CamelContextHelper . convertTo ( context , Component . class , bean ) ; \n \n \t4 if ( component != null ) { \n \n \t5 return component ; } } } \n \n \t2 if ( bean != null ) { \n \n <ect>
\t4 data . getStormClusterState ( ) . remove_blobstore_key ( key ) ; \n \n \t4 data . getStormClusterState ( ) . remove_key_version ( key ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 throw new TException ( e ) ; } } \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public void addSubDevice ( String subId , String subDeviceType ) { \n \n \t2 ModelFactory factory = ModelFactory . eINSTANCE ; \n \n \t2 RemoteSwitch subDevice = null ; \n \n \t2 if ( subDeviceType . equals ( <string_literal> ) ) { \n \n <ect>
\t3 Object format = objectFormatter . format ( value ) ; \n \n \t3 logger . debug ( <string_literal> , value , format ) ; \n \n \t3 return format ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 } else if ( receivedIntent . action == Constants . BROADCAST_UPDATE_UI ) { \n \n \t6 log . info ( TAG , <string_literal> ) \n \n \t6 refreshUI ( ) \n \n \t5 } else if ( receivedIntent . action == Constants . BROADCAST_HIGHLIGHT_SELECTION ) { \n \n <ect>
\t1 } finally { \n \n \t2 try { \n \n \t2 txn . rollback ( ) ; \n \n \t2 } catch ( Throwable t4 ) { \n \n <ect>
\t6 . setLatency ( System . currentTimeMillis ( ) - startTime ) ; \n \n \t4 monitor . incConnectionCreateFailed ( getHost ( ) , ce ) ; \n \n \t4 throw ce ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
@ Override \n \n public void closeOp ( boolean abort ) throws HiveException { \n \n \t1 try { \n \n \t1 if ( mapJoinTables == null ) { \n \n <ect>
\t3 Objects . notNull ( id , <string_literal> + entity + <string_literal> + sourceName ) ; \n \n \t3 Template old = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; \n \n \t3 if ( isRunning ( old ) ) { \n \n \t4 if ( UserConfigurationCompare . configEqual ( entity , old ) ) { \n \n <ect>
\t2 session1 = commit ( server1 , session1 , true ) ; \n \n \t2 assertInvalidations ( listener1realms . getInvalidationsAndClear ( ) , 1 , <number_literal> , realm . getId ( ) ) ; \n \n \t2 assertInvalidations ( listener2realms . getInvalidationsAndClear ( ) , 1 , <number_literal> , realm . getId ( ) ) ; \n \n \t2 <comment> \n \n <ect>
\t3 log . warn ( <string_literal> ) ; \n \n \t3 return prop ; } \n \n \t2 File file = new File ( path ) ; \n \n \t2 if ( ! file . exists ( ) || ! file . isFile ( ) || ! file . canRead ( ) ) { \n \n <ect>
\t2 if ( null == job . getRelatedCube ( ) || null == getCubeManager ( ) . getCube ( job . getRelatedCube ( ) ) \n \n \t4 || null == job . getRelatedSegment ( ) ) { \n \n \t3 getExecutableManager ( ) . discardJob ( job . getId ( ) ) ; \n \n \t3 return job ; } \n \n <ect>
\t1 @ Test @ Ignore \n \n \t1 public void missingFileErrors ( ) throws IOException { \n \n \t2 MeshyClient meshLink = new MeshyClient ( <string_literal> , <number_literal> ) ; \n \n \t2 Collection < FileReference > fileReferences = meshLink . listFiles ( new String [ ] { <string_literal> } ) ; \n \n <ect>
\t5 . doOnCancel ( ( ) - > logger . debug ( <string_literal> ) ) \n \n \t5 . map ( response - > { \n \n \t6 HttpStatus status = response . getStatusCode ( ) ; \n \n <ect>
\t3 log . debug ( <string_literal> + endpoint ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public void close ( ) throws IOException { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , principal . getName ( ) ) ; \n \n \t3 return principal . getName ( ) ; } \n \n \t2 final String remoteUser = request . getRemoteUser ( ) ; \n \n \t2 if ( StringUtils . isNotBlank ( remoteUser ) ) { \n \n <ect>
\t2 if ( tasks . size ( ) > 0 ) { \n \n \t3 AssetLoadingTask currAsset = tasks . firstElement ( ) ; \n \n \t3 if ( currAsset . assetDesc . fileName . equals ( fileName ) ) { \n \n \t4 currAsset . cancel = true ; \n \n <ect>
\t3 for ( MXBean mxBean : mxBeans ) { \n \n \t4 DataCollector collector = mxBean . gainDataCollector ( agentConfig . getHome ( ) . getDirectory ( ) ) ; \n \n \t4 scheduler . scheduleWithFixedDelay ( collector , 0L , getInterval ( ) , TimeUnit . SECONDS ) ; \n \n \t4 LOG . info ( <string_literal> , collector . getClass ( ) . getSimpleName ( ) ) ; } \n \n <ect>
\t1 try { \n \n \t2 Vector v = fetchVector ( new Path ( basisPath , BASIS_PREFIX + '_' + i ) , i ) ; \n \n \t2 basis . put ( i , v ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 _log . debug ( <string_literal> ) ; \n \n \t3 boolean wantMore = _fragments . waitForMoreAllowed ( ) ; \n \n \t3 if ( wantMore ) { \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 TypeAdapter < ServerInfo > adapter = GSON . getAdapter ( ServerInfo . class ) ; \n \n \t3 while ( jsonReader . hasNext ( ) ) { \n \n \t4 ServerInfo entry = adapter . read ( jsonReader ) ; \n \n \t4 servers . add ( entry ) ; \n \n <ect>
\t2 results = ( NSArray < er . neo4jadaptor . test . eo . SecondEntity > ) EOSortOrdering . sortedArrayUsingKeyOrderArray ( results , sortOrderings ) ; } } \n \n \t1 return results ; } \n \n public void addToSecondEntitiesRelationship ( er . neo4jadaptor . test . eo . SecondEntity object ) { \n \n <ect>
\t4 try { \n \n \t5 DataStore dataStore = storeMgr . getDataStore ( templateDataStore . getDataStoreId ( ) , DataStoreRole . Image ) ; \n \n \t5 EndPoint ep = _epSelector . select ( dataStore , templateDataStore . getExtractUrl ( ) ) ; \n \n \t5 if ( ep == null ) { \n \n <ect>
\t4 } else { \n \n \t5 assertEquals ( Throwable . class , constructor . getParameterTypes ( ) [ <number_literal> ] ) ; } } } \n \n \t2 assertEquals ( <number_literal> , ParameterizedMessage . class . getConstructors ( ) . length ) ; } \n \n \t1 public void checkNumberOfArguments1 ( ) { \n \n <ect>
\t1 if ( interesting && lastRequest == null ) { \n \n \t2 interesting = false ; \n \n \t2 out . sendInterest ( false ) ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t1 return jaxrsResponse . getGenericType ( ) ; } \n \n @ Override \n \n public void setEntity ( Object entity ) \n \n { \n \n <ect>
\t2 ThriftUtil . returnClient ( ( TServiceClient ) client ) ; } \n \n \t1 } catch ( ThriftSecurityException e ) { \n \n \t1 throw new AccumuloSecurityException ( e . user , e . code , e ) ; \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t4 throw new RuntimeException ( <string_literal> ) ; \n \n \t3 theCloud = cloud . get ( ) ; } \n \n \t2 <comment> \n \n \t2 if ( theCloud . isTriton ( ) ) { \n \n <ect>
\t2 catch ( NoSuchBeanDefinitionException e ) { \n \n \t3 <comment> \n \n \t3 int idBeans = context . getBeansOfType ( IdGenerator . class ) . size ( ) ; \n \n <ect>
\t2 SSLContext sslContext = null ; \n \n \t2 try { \n \n \t3 sslContext = SSLContext . getInstance ( <string_literal> , <string_literal> ) ; \n \n \t2 } catch ( NoSuchAlgorithmException e ) { \n \n <ect>
\t2 final Principal p = authentication . getPrincipal ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , p ) ; \n \n \t2 final boolean res = this . scimProvisioner . create ( p , c ) ; \n \n \t2 if ( res ) { \n \n <ect>
\t3 if ( maxFrequency != null ) { \n \n \t4 try { \n \n \t5 iMaxFrequency = Integer . parseInt ( maxFrequency ) ; \n \n \t4 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t6 s_logger . debug ( <string_literal> + actualTotalCpu + <string_literal> + totalCpu ) ; } \n \n \t5 long freeCpu = totalCpu - ( reservedCpu + usedCpu ) ; \n \n \t5 long freeMem = totalMem - ( reservedMem + usedMem ) ; \n \n <ect>
\t2 for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { \n \n \t3 try { \n \n \t4 listeners . get ( i ) . onStreamHalfClosed ( stream ) ; \n \n \t3 } catch ( Throwable cause ) { \n \n <ect>
\t6 <comment> \n \n \t6 log . debug ( <string_literal> + msg ) ; \n \n <ect>
\t3 final Authentication authentication = getAuthenticationSatisfiedByPolicy ( root . getAuthentication ( ) , \n \n \t4 new ServiceContext ( selectedService , registeredService ) ) ; \n \n \t3 final Principal principal = authentication . getPrincipal ( ) ; \n \n \t3 final RegisteredServiceAttributeReleasePolicy attributePolicy = registeredService . getAttributeReleasePolicy ( ) ; \n \n <ect>
\t1 void persistDom ( String name , @ Nullable String dom ) { \n \n \t2 try { \n \n \t3 Files . write ( Strings . nullToEmpty ( dom ) , new File ( doms , name + <string_literal> ) , Charsets . UTF_8 ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 for ( VHNode nestedVNode : nestedNodes ) { \n \n \t7 vNode . addNestedNode ( nestedVNode ) ; } } \n \n \t5 vNodes . add ( vNode ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 logger . info ( <string_literal> + query . toString ( ) ) ; \n \n \t3 String sData = TripleStoreUtil . invokeSparqlQuery ( query . toString ( ) , \n \n \t5 TripleStoreUtil . defaultModelsRepoUrl , <string_literal> , null ) ; \n \n \t3 if ( sData == null | sData . isEmpty ( ) ) { \n \n <ect>
\t2 return ( int ) StorageMetrics . totalHintsInProgress . getCount ( ) ; } \n \n \t1 public void verifyNoHintsInProgress ( ) \n \n \t1 { \n \n \t2 if ( getHintsInProgress ( ) > 0 ) \n \n <ect>
\t6 throw new InternalErrorException ( <string_literal> ) ; \n \n \t5 try { \n \n \t6 <comment> \n \n \t6 GraphLoadUtils . loadModel ( model , uri , MaxTriples ) ; \n \n <ect>
\t2 if ( StringUtils . isBlank ( this . spnegoAttributeName ) ) { \n \n \t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( this . connectionFactory == null ) { \n \n <ect>
\t4 <comment> \n \n \t4 if ( prepareTx . done ( ) ) { \n \n \t5 iter . remove ( ) ; \n \n <ect>
public List < StringKeyStringValueDto > doGetMetadata ( @ PathParam ( <string_literal> ) String pathId ) { \n \n \t1 try { \n \n \t1 return fileService . doGetMetadata ( pathId ) ; \n \n \t1 } catch ( FileNotFoundException e ) { \n \n <ect>
\t4 received += istream . read ( bytes ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 Log . info ( Log . FAC_TEST , <string_literal> + e . getMessage ( ) ) ; \n \n \t4 Assert . fail ( ) ; } } \n \n <ect>
\t2 ) ) ; \n \n \t2 ensureGreen ( ) ; \n \n \t2 <comment> \n \n \t2 int numDocsToKeep = randomIntBetween ( 0 , <number_literal> ) ; \n \n <ect>
\t2 <comment> \n \n \t2 throw new IOException ( <string_literal> + offsetMarker ) ; } \n \n \t1 <comment> \n \n \t1 long indexTableStart = WritableUtils . readVLong ( inBuf ) ; \n \n <ect>
\t2 } catch ( IOException ioe ) { \n \n \t3 if ( _file . exists ( ) ) \n \n \t4 _log . error ( <string_literal> + _file , ioe ) ; \n \n \t3 else if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 List < ServiceOfferingVO > serviceOfferingsForThisDomain = _offeringsDao . findServiceOfferingByDomainId ( domainId ) ; \n \n \t2 for ( ServiceOfferingVO serviceOffering : serviceOfferingsForThisDomain ) { \n \n \t3 _offeringsDao . remove ( serviceOffering . getId ( ) ) ; } } \n \n \t1 protected boolean cleanupDomain ( Long domainId , Long ownerId ) throws ConcurrentOperationException , ResourceUnavailableException { \n \n <ect>
\t3 final String identifier = provider . getId ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> , provider , service . getName ( ) ) ; \n \n \t3 final Event event = validateEventIdForMatchingTransitionInContext ( identifier , context , buildEventAttributeMap ( principal , service , provider ) ) ; \n \n \t3 return CollectionUtils . wrapSet ( event ) ; } \n \n <ect>
\t2 { \n \n \t3 caughtUp . get ( joinCatchupTimeout , MILLISECONDS ) ; } \n \n \t2 catch ( ExecutionException e ) \n \n \t2 { \n \n <ect>
\t3 if ( getDatabase ( ) . getIncludePackageRoutines ( ) ) { \n \n \t4 try { \n \n \t5 routines = getRoutines0 ( ) ; } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t6 s_logger . info ( <string_literal> + account . getState ( ) + <string_literal> + accountId + <string_literal> ) ; } } \n \n \t3 } else { \n \n \t4 s_logger . warn ( <string_literal> + accountId + <string_literal> ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t4 failedFetchLock = FailedFetchLock . getLock ( config , new Props ( ) ) ; \n \n \t4 removeRemoteObsoleteState ( failedFetchLock ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 else { \n \n \t3 this . replyHolder . put ( messageTag , pendingReply ) ; } \n \n \t2 saveAndSetProperties ( message , pendingReply , messageTag ) ; \n \n <ect>
\t6 + msg . getMessageSize ( ) + <string_literal> \n \n \t6 + msg . getMessageType ( ) + ' ' + msg . getMessageId ( ) + <string_literal> \n \n \t6 + msg . getTarget ( ) . getIdentity ( ) . calculateHash ( ) . toBase64 ( ) . substring ( 0 , <number_literal> ) + <string_literal> + msToSend + <string_literal> ) ; } \n \n \t2 <comment> \n \n <ect>
\t4 } catch ( IhcExecption e ) { \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t5 setReconnectRequest ( true ) ; } } \n \n \t2 } else { \n \n <ect>
\t4 sourceDataLine . flush ( ) ; \n \n \t4 sourceDataLine . close ( ) ; \n \n \t4 breaked = true ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 if ( rs != null ) { \n \n \t1 try { \n \n \t2 rs . close ( ) ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t4 final ClusteredAgentAttache forwardAttache = ( ClusteredAgentAttache ) createAttache ( hostId ) ; \n \n \t4 if ( forwardAttache == null ) { \n \n \t5 s_logger . warn ( <string_literal> + hostId + <string_literal> ) ; \n \n \t5 return false ; } \n \n <ect>
\t1 IOException wex = wt . getException ( ) ; \n \n \t1 if ( null != rex ) { \n \n \t1 LOG . error ( <string_literal> + StringUtils . stringifyException ( rex ) ) ; } \n \n \t1 if ( null != wex ) { \n \n <ect>
<number_literal> . setError ( ProtoUtils . encodeError ( errorCodeMapper , \n \n <number_literal> e ) ) \n \n <number_literal> . build ( ) ; \n \n \t2 ProtoUtils . writeMessage ( outputStream , response ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 logger . trace ( <string_literal> ) ; \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 logger . warn ( <string_literal> ) ; \n \n <ect>
\t6 continue ; } } \n \n \t4 gre_key = i ; \n \n \t4 break ; } \n \n \t2 } catch ( NeutronRestApiException e ) { \n \n <ect>
\t3 LOG . warn ( <string_literal> ) ; \n \n \t2 } else { \n \n \t3 MRJobStats js = mroJobMap . get ( mro ) ; \n \n \t3 if ( js == null ) { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t3 byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; \n \n \t3 org . apache . thrift . TSerializable msg ; \n \n \t3 getFollowing_result result = new getFollowing_result ( ) ; \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 assertJSON ( result , <string_literal> , <string_literal> ) ; \n \n \t3 String lock = result . getString ( <string_literal> ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 success ( broker , request , response , RELEASE_LOCK , <string_literal> , project , <string_literal> , user , <string_literal> , lock ) ; \n \n <ect>
\t5 sendWithRetries ( nodeId , msg ) ; } \n \n \t4 catch ( GridException e ) { \n \n \t5 if ( e . hasCause ( GridTopologyException . class ) ) { \n \n <ect>
\t2 if ( userContext == null ) { \n \n \t3 userContext = new UserContext ( ) ; \n \n \t3 httpSession . setAttribute ( WebConstants . OPENMRS_USER_CONTEXT_HTTPSESSION_ATTR , userContext ) ; \n \n <ect>
\t6 break ; } } \n \n \t4 m_open_web_net . onCommand ( l_pr ) ; } \n \n \t2 } catch ( \n \n \t2 Exception e ) { \n \n <ect>
\t3 AuthResult result = authorize ( s , requestId , method , authorization ) ; \n \n \t3 if ( result != AuthResult . AUTH_GOOD ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) { \n \n \t5 if ( authorization != null ) \n \n <ect>
\t2 return tidy . global . isCompacted . get ( ) ; } \n \n \t1 public void markSuspect ( ) \n \n \t1 { \n \n <ect>
\t3 logger . debug ( <string_literal> + userId + <string_literal> + tournament . getId ( ) ) ; \n \n \t3 return ; } \n \n \t2 TournamentPlayer tournamentPlayer = tournament . getPlayer ( playerId ) ; \n \n \t2 if ( tournamentPlayer == null ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void subAppend ( LoggingEvent event ) { \n \n \t2 if ( editingContext ( ) . hasChanges ( ) ) { \n \n <ect>
\t5 Host host = _resourceMgr . findHostByGuid ( info . getHostUuid ( ) ) ; \n \n \t5 if ( host != null ) { \n \n \t6 Answer answer = _agentMgr . send ( host . getId ( ) , cleanup ( info . name ) ) ; \n \n \t6 if ( ! answer . getResult ( ) ) { \n \n <ect>
\t3 throw new FailedLoginException ( <string_literal> + transformedCredential . getId ( ) ) ; } \n \n \t2 if ( ! value . containsKey ( couchbaseProperties . getPasswordAttribute ( ) ) ) { \n \n \t3 throw new FailedLoginException ( <string_literal> + transformedCredential . getId ( ) ) ; } \n \n \t2 if ( ! value . get ( couchbaseProperties . getPasswordAttribute ( ) ) . equals ( transformedCredential . getPassword ( ) ) ) { \n \n <ect>
\t4 SessionId sessionId = new SessionId ( connectionId , sessionIdGenerator . getNextSequenceId ( ) ) ; \n \n \t4 ConsumerId consumerId = new ConsumerId ( sessionId , consumerIdGenerator . getNextSequenceId ( ) ) ; \n \n \t4 info = new ConsumerInfo ( consumerId ) ; \n \n \t4 if ( brokerConsumerDests . putIfAbsent ( pair , info ) == null ) { \n \n <ect>
\t8 . put ( <string_literal> , repositoryLocation ) \n \n \t8 . put ( <string_literal> , randomAlphaOfLength ( <number_literal> ) ) \n \n \t8 . put ( <string_literal> , 0 . <number_literal> ) ) ) ; \n \n \t2 <comment> \n \n <ect>
\t4 file = new TFile ( filePath ) ; } \n \n \t3 if ( file . exists ( ) ) { \n \n \t4 pathCache . put ( card , filePath ) ; \n \n \t4 return filePath ; } } \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 @ Consumes ( { <string_literal> } ) \n \n \t1 public String addFavoriteMovie ( SecureProcessingFavoriteMovieXmlRootElement movie ) { \n \n \t2 int len = Math . min ( movie . getTitle ( ) . length ( ) , <number_literal> ) ; \n \n \t2 logger . info ( <string_literal> + movie . getTitle ( ) . substring ( 0 , len ) + <string_literal> ) ; \n \n <ect>
\t2 if ( id != null ) { \n \n \t3 <comment> \n \n \t3 tryId = findStringIfAltSyntax ( id ) ; \n \n \t2 } else if ( null == ( generatedId = escape ( name != null ? findString ( name ) : null ) ) ) { \n \n <ect>
\t7 default : \n \n \t8 assert false ; \n \n \t8 break ; } \n \n \t6 } catch ( final Throwable e ) { \n \n <ect>
\t1 if ( response . getPayload ( ) != null ) { \n \n \t2 try { \n \n \t3 return Strings2 . toStringAndClose ( response . getPayload ( ) . openStream ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 getKeyStorePassword ( ) . toCharArray ( ) : LOGSEARCH_KEYSTORE_DEFAULT_PASSWORD . toCharArray ( ) ; \n \n \t1 boolean keyStoreFileExists = new File ( keyStoreLocation ) . exists ( ) ; \n \n \t1 if ( ! keyStoreFileExists ) { \n \n \t2 FileUtil . createDirectory ( certFolder ) ; \n \n <ect>
\t2 if ( ! url . endsWith ( <string_literal> ) ) { \n \n \t3 url += <string_literal> ; } \n \n \t2 if ( ! url . startsWith ( <string_literal> ) ) { \n \n \t3 url = <string_literal> + url ; } \n \n <ect>
\t3 final Object userToken = context . getUserToken ( ) ; \n \n \t3 execRuntime . acquireConnection ( route , userToken , context ) ; } \n \n \t2 try { \n \n \t3 if ( ! execRuntime . isConnected ( ) ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t3 setLastUsed ( \n \n \t4 getWorkbenchProperty ( LAST_USED2 ) , getWorkbenchProperty ( \n \n \t5 LAST_USED2_URL ) ) ; \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
\t2 store . stop ( ) ; \n \n \t2 messageStore = createStore ( <number_literal> * ONE_MB ) ; \n \n \t2 verifyMessages ( messageStore , <number_literal> ) ; \n \n \t2 long sizeAfterChange = store . getJournal ( ) . getDiskSize ( ) ; \n \n <ect>
\t1 boolean result = checkExpressions ( agg . getParameters ( ) ) ; \n \n \t1 FunctionInfo fi = FunctionRegistry . getFunctionInfo ( agg . getGenericUDAFName ( ) ) ; \n \n \t1 result = result && ( fi != null ) && fi . isNative ( ) ; \n \n \t1 if ( ! result ) { \n \n <ect>
\t3 log . warn ( <string_literal> ) ; } } \n \n \t1 @ Override \n \n \t1 public void rstopTest ( boolean now ) throws RemoteException { \n \n \t2 if ( now ) { \n \n <ect>
\t3 while ( ( inputLine = in . readLine ( ) ) != null ) { \n \n \t4 s_logger . debug ( inputLine ) ; \n \n \t4 String [ ] tokens = inputLine . split ( <string_literal> ) ; \n \n \t4 if ( tokens . length != <number_literal> ) { \n \n <ect>
\t2 Answer [ ] answers = null ; \n \n \t2 try { \n \n \t3 answers = _agentMgr . send ( router . getHostId ( ) , cmds ) ; \n \n \t2 } catch ( final OperationTimedoutException e ) { \n \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \n \t3 start ( NODE_1 ) ; \n \n \t3 Thread . sleep ( FAILURE_FREE_TIME ) ; \n \n \t3 client . assertNoExceptions ( <string_literal> ) ; \n \n <ect>
\t3 if ( outQueue . size ( ) >= MAX_QUEUE_LENGTH ) { \n \n \t4 if ( neverDropAMessage ) { \n \n \t5 Logger . error ( this , <string_literal> + outQueue . size ( ) + <string_literal> + handler + <string_literal> ) ; \n \n \t4 } else { \n \n <ect>
\t3 UpdateMethod method = <string_literal> . equals ( uri . getScheme ( ) ) ? FILE : HTTP ; \n \n \t3 va = new VersionAvailable ( <string_literal> , <string_literal> , method , uris ) ; \n \n \t3 _available . putIfAbsent ( item , va ) ; } \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 self . logger . debug ( <string_literal> ) \n \n \t2 vpc_off = VpcOffering . create ( \n \n \t3 self . apiclient , \n \n \t3 self . services [ <string_literal> ] ) \n \n <ect>
\t5 requestSoapParts , \n \n \t5 responseSoapParts , \n \n \t5 context ) ; \n \n \t3 } catch ( XmlaException xex ) { \n \n <ect>
\t1 public void cancelDestroy ( VMInstanceVO vm , Long hostId ) { \n \n \t2 _haDao . delete ( vm . getId ( ) , WorkType . Destroy ) ; } \n \n \t1 protected Long destroyVM ( HaWorkVO work ) { \n \n \t2 final VMInstanceVO vm = _itMgr . findByIdAndType ( work . getType ( ) , work . getInstanceId ( ) ) ; \n \n <ect>
\t1 Class < ? > ifClass = null ; \n \n \t1 try { \n \n \t2 ifClass = Class . forName ( inputFileFormatClassName ) ; \n \n \t1 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t4 if ( rs . wasNull ( ) ) { \n \n \t5 cell . setCellValue ( NULL_VALUE ) ; \n \n \t4 } else { \n \n \t5 cell . setCellValue ( rs . getString ( colIndex ) ) ; } \n \n <ect>
\t5 } ; } } \n \n \t2 } else if ( tokenizer . hasParameter ( ) ) { \n \n \t3 String parameter = tokenizer . getParameter ( ) ; \n \n \t3 if ( parameter == null ) { \n \n <ect>
\t2 try ( Scanner scanner = new Scanner ( f , <string_literal> ) ; ) { \n \n \t3 String [ ] stats = scanner . useDelimiter ( <string_literal> ) . next ( ) . split ( <string_literal> ) ; \n \n \t3 uptime = new UptimeStats ( Double . parseDouble ( stats [ 0 ] ) , Double . parseDouble ( stats [ 1 ] ) ) ; \n \n \t2 } catch ( FileNotFoundException ex ) { \n \n <ect>
with Compiler [ GenericInputFormat [ Row ] ] \n \n with Logging { \n \n private var format : GenericInputFormat [ Row ] = _ \n \n override def open ( split : GenericInputSplit ) : Unit = { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 final Connector connector = new Connector ( http . getProtocol ( ) ) ; \n \n \t3 int port = http . getPort ( ) ; \n \n \t3 if ( port < = 0 ) { \n \n <ect>
\t6 assert globalCntrMultiNode . compareAndSet ( global , newCntr ) : invalid ( <string_literal> , \n \n \t7 pri , true , newCntr , global ) ; \n \n \t6 int prev = c . put ( CNTR_KEY , newCntr ) ; \n \n \t6 if ( DEBUG ) { \n \n <ect>
\t1 if ( i < EUCAKEY_CRED_SETUP . length ( ) ) \n \n \t2 return ; \n \n \t1 final String [ ] firstLine = userData . substring ( 0 , i ) . split ( <string_literal> ) ; \n \n \t1 if ( firstLine . length != <number_literal> ) { \n \n <ect>
\t3 String rfAddress = Utils . toHex ( token [ 0 ] & 0xFF , token [ 1 ] & 0xFF , token [ <number_literal> ] & 0xFF ) ; \n \n \t3 <comment> \n \n \t3 Device foundDevice = null ; \n \n \t3 for ( Device device : devices ) { \n \n <ect>
\t1 public Destination getReplyTo ( ) { \n \n \t2 try { \n \n \t3 destResolver . destinationReady ( ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
<comment> \n \n @ Subscribe \n \n public void processHostRemovedEvent ( HostsRemovedEvent hostsRemovedEvent ) { \n \n \t1 if ( hostsRemovedEvent . getHostNames ( ) . isEmpty ( ) ) { \n \n <ect>
\t4 byte [ ] pubkeyHash = script . getPubKeyHash ( ) ; \n \n \t4 return transactionBag . isPubKeyHashMine ( pubkeyHash ) ; } \n \n \t2 } catch ( ScriptException e ) { \n \n \t3 <comment> \n \n <ect>
\t5 _sspUuidDao . removeUuid ( tenantNetworkUuid ) ; \n \n \t5 processed = true ; \n \n \t5 break ; } } \n \n \t3 if ( ! processed ) { \n \n <ect>
\t1 LOGGER . log ( Level . SEVERE , <string_literal> ) ; } \n \n \t1 <comment> \n \n \t1 if ( deployment != null && PropertyHelper . getBooleanProperty ( processArchive . getProperties ( ) , ProcessArchiveXml . PROP_IS_DELETE_UPON_UNDEPLOY , false ) ) { \n \n \t1 try { \n \n <ect>
\t2 final Set < String > contexts = new HashSet < > ( ) ; \n \n \t2 for ( final byte [ ] kmer : SequenceUtil . generateAllKmers ( <number_literal> * contextSize + 1 ) ) { \n \n \t3 if ( kmer [ contextSize ] == 'C' ) { \n \n \t4 contexts . add ( StringUtil . bytesToString ( kmer ) ) ; } } \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public void setTagsSent ( Set < SessionTag > tags ) { \n \n \t2 if ( tags != null && ! tags . isEmpty ( ) ) \n \n <ect>
\t4 if ( listener != null ) { \n \n \t5 try { \n \n \t6 listener . run ( ) ; \n \n \t5 } catch ( Exception ignored ) { \n \n <ect>
\t4 private GridLogger log ; \n \n \t4 @ GridInstanceResource \n \n \t4 private Grid grid ; \n \n \t4 @ Override public Object execute ( ) throws GridException { \n \n <ect>
\t1 @ Test \n \n \t1 public void testMqttDuplicatesAfterBrokerRestartWithoutClientID ( ) throws Exception { \n \n \t2 brokerService . stop ( ) ; \n \n \t2 brokerService . waitUntilStopped ( ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public void close ( ) throws IOException { \n \n \t2 List < Runnable > runnables = service . shutdownNow ( ) ; \n \n \t2 if ( runnables . size ( ) > 0 ) \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 if ( ( current - lastActivityTimestamp ) > actorConfiguration . getTerminationTimeout ( MAX_TERMINATION_INACTIVITY_INTERVAL ) ) { \n \n \t1 cleanUpWithTermination ( ) ; } } \n \n private void cleanUp ( ) { \n \n \t1 if ( jobId . isPresent ( ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 public void shutdown ( ) { \n \n <ect>
\t4 } catch ( Exception e ) { \n \n \t5 <comment> \n \n \t5 if ( errorWaitTime == 1 ) { \n \n \t6 logger . warn ( <string_literal> , e ) ; } \n \n <ect>
\t6 connection . closeAsync ( ) ; } } \n \n \t4 @ Override \n \n \t4 protected boolean onConnectionException ( ConnectionException e , long nextDelayMs ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , h . getName ( ) , b . getUrl ( ) ) ; \n \n \t2 return h ; } \n \n \t1 private AuthenticationHandler queryDatabaseAuthenticationHandler ( final QueryJdbcAuthenticationProperties b ) { \n \n \t2 final Multimap < String , Object > attributes = CoreAuthenticationUtils . transformPrincipalAttributesListIntoMultiMap ( b . getPrincipalAttributeList ( ) ) ; \n \n <ect>
\t4 logger . info ( <string_literal> , retries - retriesRemaining + 1 , retries ) ; \n \n \t4 if ( connect ( ) ) { \n \n \t5 return true ; } \n \n \t4 retriesRemaining -- ; } } \n \n <ect>
\t3 ) . execute ( ) ; \n \n \t2 awaitForBlock ( plugins ) ; \n \n \t2 cancelSearch ( SearchAction . NAME ) ; \n \n \t2 disableBlocks ( plugins ) ; \n \n <ect>
\t3 _cidr = <string_literal> ; } \n \n \t2 _gateway = dbParams . get ( Config . ControlGateway . toString ( ) ) ; \n \n \t2 if ( _gateway == null ) { \n \n \t3 _gateway = NetUtils . getLinkLocalGateway ( ) ; } \n \n <ect>
\t3 loadDescriptors ( <string_literal> , \n \n \t5 beanClass , type ) ; \n \n \t3 managed = findManagedBean ( type ) ; \n \n \t3 if ( managed == null ) { \n \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \n \t4 processSceneActivationSet ( serialMessage , offset , endpoint ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t3 BadgerContext context = new BadgerContext ( Library . class ) ; \n \n \t3 StringWriter writer = new StringWriter ( ) ; \n \n \t3 context . createMarshaller ( ) . marshal ( library , writer ) ; \n \n \t3 String s = writer . toString ( ) ; \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t2 } <comment> \n \n \t1 @ Override \n \n \t1 public void run ( ) { \n \n <ect>
\t2 <string_literal> \n \n \t1 } , \n \n \t1 <string_literal> + \n \n <ect>
\t5 ctx . downstreamChannel . sendResponse ( <number_literal> ) ; \n \n \t5 return ; } \n \n \t4 AsynHttpContext ctx = s . getContext ( ) ; \n \n \t4 if ( ctx . wc != ctx . req . length ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 TripleStoreUtil utilObj = new TripleStoreUtil ( ) ; \n \n \t2 final List < String > graphs = utilObj . getContexts ( this . tripleStoreUrl ) ; \n \n \t2 if ( graphs == null ) { \n \n \t3 return new UpdateContainer ( new ErrorUpdate ( <string_literal> ) ) ; } \n \n <ect>
\t6 <comment> \n \n \t6 initializerDecided = ! isRolledBack . get ( ) ; } } } \n \n \t3 if ( ! initializingRepository ) { \n \n \t4 <comment> \n \n <ect>
\t5 File metaFile = new File ( baseDir , name + <string_literal> ) ; \n \n \t5 metaFile . delete ( ) ; \n \n \t5 return loadConfigFile ( masterKey ) ; } \n \n \t4 <comment> \n \n <ect>
\t3 Configuration . setConfiguration ( login_conf ) ; \n \n \t3 <comment> \n \n \t3 login = new Login ( AuthUtils . LOGIN_CONTEXT_CLIENT , client_callback_handler ) ; \n \n \t2 } catch ( LoginException ex ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t4 String namedReporter = reporterConfiguration . f0 ; \n \n \t4 Configuration reporterConfig = reporterConfiguration . f1 ; \n \n \t4 final String className = reporterConfig . getString ( ConfigConstants . METRICS_REPORTER_CLASS_SUFFIX , null ) ; \n \n \t4 if ( className == null ) { \n \n <ect>
\t1 ImmutableMap < String , Long > result = ImmutableMap . copyOf ( metaCallTimeMap ) ; \n \n \t1 metaCallTimeMap . clear ( ) ; \n \n \t1 return result ; } \n \n private boolean logDumpPhase ( String phase ) { \n \n <ect>
<number_literal> + <string_literal> \n \n <number_literal> + versioned . getValue ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t7 <comment> \n \n \t7 <comment> \n \n \t7 if ( store . getScope ( ) . getScopeType ( ) == ScopeType . REGION ) { \n \n \t8 if ( volumeHost . getDownloadState ( ) == VMTemplateStorageResourceAssoc . Status . DOWNLOADED && volumeHost . getInstallPath ( ) == null ) { \n \n <ect>
\t2 } catch ( NoSuchAlgorithmException e ) { \n \n \t3 Logger . error ( this , <string_literal> + e . getMessage ( ) , e ) ; \n \n \t3 e . printStackTrace ( ) ; \n \n \t2 } catch ( InvalidKeyException e ) { \n \n <ect>
\t2 log . info ( <string_literal> + className + <string_literal> ) ; \n \n \t2 return false ; } \n \n \t1 @ Override \n \n \t1 public Set < InjectionPoint > getInjectionPoints ( ) { \n \n <ect>
\t2 int pos = telegramValue . getPos ( ) != null ? telegramValue . getPos ( ) : - 1 ; \n \n \t2 Object value = null ; \n \n \t2 <comment> \n \n \t2 if ( pos > byteBuffer . position ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 EPersonServiceFactory . getInstance ( ) . getGroupService ( ) . initDefaultGroupNames ( context ) ; \n \n \t3 context . restoreAuthSystemState ( ) ; \n \n \t2 } catch ( AuthorizeException ex ) { \n \n <ect>
\t2 if ( ! keyfile . exists ( ) ) { \n \n \t3 try { \n \n \t4 keyfile . createNewFile ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 public Optional < MaterialData > getAssetData ( ResourceUrn urn ) throws IOException { \n \n \t2 if ( RESOURCE_NAME . equals ( urn . getResourceName ( ) ) && ! urn . getFragmentName ( ) . isEmpty ( ) ) { \n \n \t3 Optional < ? extends Shader > fontShader = assetManager . getAsset ( FONT_SHADER_URN , Shader . class ) ; \n \n \t3 if ( ! fontShader . isPresent ( ) ) { \n \n <ect>
\t5 <string_literal> inputName \\ <string_literal> ) ; \n \n \t4 LOG . error ( msg ) ; \n \n \t4 throw new IllegalArgumentException ( msg ) ; } \n \n \t3 HttpServletResponse oResponse = ( HttpServletResponse ) invocation . getInvocationContext ( ) . get ( HTTP_RESPONSE ) ; \n \n <ect>
\t2 if ( host != null && ( host . equals ( <string_literal> ) || host . equals ( <string_literal> ) ) && uri . getPort ( ) == <number_literal> ) { \n \n \t3 try { \n \n \t4 uri = new URI ( null , null , null , - 1 , uri . getPath ( ) , uri . getQuery ( ) , uri . getFragment ( ) ) ; \n \n \t3 } catch ( URISyntaxException e ) { \n \n <ect>
\t5 for ( PluginListener listener : listeners ) { \n \n \t6 listener . pluginUnloaded ( installedPlugin ) ; } \n \n \t4 } catch ( Exception e ) { \n \n \t5 uninstallMessage = <string_literal> ; \n \n <ect>
\t1 protected boolean poolIsCorrectType ( DiskProfile dskCh , StoragePool pool ) { \n \n \t2 boolean localStorageAllocationNeeded = localStorageAllocationNeeded ( dskCh ) ; \n \n \t3 s_logger . debug ( <string_literal> + localStorageAllocationNeeded ) ; \n \n <ect>
\t4 if ( s . equalsIgnoreCase ( SPSSODescriptor . DEFAULT_ELEMENT_NAME . getLocalPart ( ) ) ) { \n \n \t5 LOGGER . debug ( <string_literal> , SPSSODescriptor . DEFAULT_ELEMENT_NAME ) ; \n \n \t5 roles . add ( SPSSODescriptor . DEFAULT_ELEMENT_NAME ) ; } \n \n \t4 if ( s . equalsIgnoreCase ( IDPSSODescriptor . DEFAULT_ELEMENT_NAME . getLocalPart ( ) ) ) { \n \n <ect>
\t3 if ( ! updateMetadataOnly ) { \n \n \t3 fireObjectCreationEvent ( destinationBucket , destinationKey , destObject . getVersionId ( ) , requestUser . getUserId ( ) , requestUser . getName ( ) , \n \n \t4 requestUser . getAccountNumber ( ) , destObject . getSize ( ) , null ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 final PasswordModifyOperation operation = new PasswordModifyOperation ( modifyConnection ) ; \n \n \t3 final Response response = operation . execute ( new PasswordModifyRequest ( currentDn , \n \n \t5 StringUtils . isNotBlank ( oldPassword ) ? new Credential ( oldPassword ) : null , \n \n \t5 new Credential ( newPassword ) ) ) ; \n \n <ect>
\t8 eval . loadClassByName ( type . className , classLoader ) \n \n \t8 boxOrUnboxArgumentIfNeeded ( eval , value , type ) . asJdiValue ( vm , type ) } \n \n \t5 mainClass . invokeMethod ( thread , mainClass . methods ( ) . single ( ) , args , invokePolicy ) } \n \n \t3 } catch ( e : Throwable ) { \n \n <ect>
\t3 revokeNamespacePermission_result result = new revokeNamespacePermission_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 { \n \n \t3 long start = System . currentTimeMillis ( ) ; \n \n \t3 { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , \n \n \t6 properties . getEncodingAlgorithm ( ) , properties . getCharacterEncoding ( ) ) ; \n \n \t4 return new DefaultPasswordEncoder ( properties . getEncodingAlgorithm ( ) , properties . getCharacterEncoding ( ) ) ; \n \n \t3 case STANDARD : \n \n <ect>
\t3 len -= decoded ; } \n \n \t2 final AmqpSession session = ( AmqpSession ) getEndpoint ( ) . getSession ( ) . getContext ( ) ; \n \n \t2 final ConnectionId connectionId = session . getConnection ( ) . getConnectionId ( ) ; \n \n \t2 final Object action = ( ( AmqpValue ) message . getBody ( ) ) . getValue ( ) ; \n \n <ect>
\t2 <comment> \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 if ( action . hasBeenCalled ( ) ) { \n \n \t4 break ; } \n \n <ect>
\t2 throw new SignatureDoesNotMatchException ( creds . accessKeyId , creds . getLoginData ( ) , creds . signature ) ; } \n \n \t1 } else { \n \n \t2 throw new SignatureDoesNotMatchException ( creds . accessKeyId , creds . getLoginData ( ) , creds . signature ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 dataout . flush ( ) ; \n \n \t2 int cmd = datain . readInt ( ) ; \n \n \t2 int resp = datain . readInt ( ) ; \n \n \t2 if ( cmd != <number_literal> ) { \n \n <ect>
\t5 final String details = ma != null ? ma . getDetails ( ) : <string_literal> ; \n \n \t5 throw new CloudRuntimeException ( details ) ; } \n \n \t3 } catch ( final OperationTimedoutException e ) { \n \n \t4 if ( e . isActive ( ) ) { \n \n <ect>
\t1 } catch ( NotAvailableFromExchangeException e ) { \n \n \t2 assertThat ( notAvailableFromExchangeNotThrown ) . isFalse ( ) ; \n \n \t2 notAvailableFromExchangeThrown = true ; \n \n \t1 } catch ( NotYetImplementedForExchangeException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 Context . getHL7Service ( ) . processHL7Message ( parsedMessage ) ; \n \n \t3 <comment> \n \n <ect>
\t2 LOG . debug ( <string_literal> + s + <string_literal> ) ; \n \n \t2 int updCnt = stmt . executeUpdate ( s ) ; \n \n \t2 if ( updCnt != 1 ) { \n \n \t2 LOG . error ( <string_literal> + user + <string_literal> + cq_id + <string_literal> + updCnt ) ; \n \n <ect>
<comment> \n \n \t6 break ; } } } \n \n \t3 catch ( Throwable e ) \n \n \t3 { \n \n <ect>
\t3 super . setup ( context ) ; \n \n \t3 Configuration jConf = context . getConfiguration ( ) ; \n \n \t3 <comment> \n \n \t3 if ( firstTime ) { \n \n <ect>
\t5 <comment> \n \n \t5 if ( readByte == EBusTelegram . SYN ) { \n \n \t6 logger . debug ( <string_literal> ) ; \n \n \t5 } else { \n \n <ect>
<number_literal> final HttpServletResponse response ) { \n \n \t2 final Callable < Collection < Map < String , Object > > > asyncTask = ( ) - > { \n \n \t3 final String principal = Pac4jUtils . getPac4jAuthenticatedUsername ( ) ; \n \n \t3 if ( ! PrincipalResolver . UNKNOWN_USER . equals ( principal ) ) { \n \n <ect>
\t5 this . fileTimestamp = newFileTimestamp ; \n \n \t5 this . cachedMessageFormats . clear ( ) ; } \n \n \t4 catch ( IOException ex ) { \n \n <ect>
\t3 @ Override \n \n \t3 public int createNumberToBeRemoved ( ) { \n \n \t4 return initialNumberJobsToRemove ; } \n \n \t2 } ) ; \n \n <ect>
\t4 port ) ; \n \n \t2 String cmd = launcherCmd + <string_literal> + workerCmd ; \n \n \t2 cmd = cmd . replace ( <string_literal> , stormHome ) ; \n \n \t2 LOG . info ( <string_literal> + cmd ) ; \n \n <ect>
\t2 Long podId = plan . getPodId ( ) ; \n \n \t2 Long clusterId = plan . getClusterId ( ) ; \n \n \t2 List < Long > hostIdsByVmCount = _vmInstanceDao . listHostIdsByVmCount ( dcId , podId , clusterId , account . getAccountId ( ) ) ; \n \n <ect>
\t1 public static void setGenerator ( Context context , StageGenerator builder ) \n \n \t1 { \n \n \t2 if ( ARQ . stageGenerator == null ) \n \n \t3 <comment> \n \n <ect>
\t2 _callback = context ( ) . request ( ) . stringFormValueForKey ( <string_literal> ) ; \n \n \t2 if ( value != null && value . length ( ) == 0 ) \n \n \t3 value = null ; \n \n \t2 Object newValue = value ; \n \n <ect>
\t3 project . addModel ( modelName ) ; \n \n \t3 project . removeRealization ( RealizationType . CUBE , cubeName ) ; \n \n \t3 project . addRealizationEntry ( RealizationType . CUBE , cubeName ) ; \n \n \t3 dstStore . putResource ( projectResPath , project , projectSerializer ) ; \n \n <ect>
\t3 if ( volumesVOs . size ( ) > 1 ) { \n \n \t4 s_logger . warn ( <string_literal> + volId + <string_literal> + event . getAccountId ( ) + <string_literal> ) ; } \n \n \t3 for ( UsageVolumeVO volumesVO : volumesVOs ) { \n \n <ect>
\t4 LOGGER . warn ( <string_literal> , e ) ; } \n \n \t2 } catch ( StopStatsStoreException e ) { \n \n <ect>
\t1 File file = new File ( Configuration . class . getClassLoader ( ) . getResource ( CONFIG_FILE ) . getPath ( ) ) ; \n \n \t1 Long currentConfigLastModifiedDate = file . lastModified ( ) ; \n \n \t1 Properties properties = null ; \n \n \t1 if ( currentConfigLastModifiedDate . longValue ( ) != configLastModifiedDateForCustomJDBC . longValue ( ) ) { \n \n <ect>
\t4 if ( artifact != null ) { \n \n \t5 File jar = artifact . getFile ( ) ; \n \n \t5 urls . add ( jar . toURI ( ) . toURL ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t2 e = new IOException ( <string_literal> ) ; \n \n \t2 e . initCause ( new IllegalArgumentException ( ) ) ; \n \n \t2 helper . init ( <string_literal> , e , null ) ; \n \n \t2 reset ( log ) ; \n \n <ect>
<comment> \n \n \t1 protected void add ( @ Nullable Set < OWLAxiom > axioms ) { \n \n \t2 if ( axioms == null || axioms . isEmpty ( ) ) { \n \n <ect>
\t8 throw new ExecutionException ( <string_literal> + vm + <string_literal> ) ; } \n \n \t7 throw new ExecutionException ( <string_literal> + vm + <string_literal> ) ; } } \n \n \t5 s_logger . info ( <string_literal> + dest . getHost ( ) + <string_literal> + ( startAnswer == null ? <string_literal> : startAnswer . getDetails ( ) ) ) ; \n \n \t4 } catch ( OperationTimedoutException e ) { \n \n <ect>
\t1 self . insert_data ( table ) \n \n \t1 self . query_data ( table ) \n \n \t1 self . validate_data ( table ) \n \n \t1 except : \n \n <ect>
\t1 } catch ( FileNotFoundException e ) { \n \n \t1 LOG . info ( <string_literal> + StringUtils . stringifyException ( e ) ) ; \n \n \t1 return null ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 LOGGER . info ( <string_literal> + Joiner . on ( <string_literal> ) . join ( cmdArgs ) ) ; \n \n \t1 ProcessBuilder pb = new ProcessBuilder ( cmdArgs ) ; \n \n \t1 Map < String , String > env = pb . environment ( ) ; \n \n \t1 env . putAll ( environmentVariables ) ; \n \n <ect>
\t2 try { \n \n \t3 final FulltextIndexer indexer = StructrApp . getInstance ( securityContext ) . getFulltextIndexer ( ) ; \n \n \t3 indexer . addToFulltextIndex ( thisIndexable ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t4 . endArray ( ) \n \n \t4 . endObject ( ) ) ; \n \n \t3 assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutPipeline ( <string_literal> , pipelineSource , XContentType . JSON ) . get ( ) ) ; } \n \n \t2 if ( testScript ) { \n \n <ect>
\t2 if ( pollIterator == null ) { \n \n \t3 <comment> \n \n \t3 pollingTable = new ArrayList < Integer > ( ) ; \n \n \t3 if ( pollingTable == null ) { \n \n <ect>
\t3 logger . warn ( <string_literal> + fullCalleeURI , ex ) ; } \n \n \t2 if ( di != null ) \n \n \t2 { \n \n <ect>
\t3 _log . debug ( <string_literal> ) ; \n \n \t3 try { Thread . sleep ( <number_literal> * <number_literal> ) ; } catch ( InterruptedException ie ) { } \n \n \t3 s . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 public void handleResponse ( InFlightOpsResponse response ) { \n \n \t7 listener . onResponse ( response ) ; } \n \n \t6 @ Override \n \n \t6 public void handleException ( TransportException exp ) { \n \n <ect>
<comment> \n \n \t1 EigenStatus status = verify ( corpus , currentPseudoEigen ) ; \n \n \t1 if ( status . inProgress ( ) ) { \n \n <ect>
\t3 try { \n \n \t4 try ( Searcher searcher = acquireSearcher ( <string_literal> , SearcherScope . EXTERNAL ) ) { \n \n \t5 return searcher . getDirectoryReader ( ) . isCurrent ( ) == false ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 h = getArray ( len - off ) ; \n \n \t3 if ( h == null ) { \n \n \t4 return - 1 ; } \n \n \t3 System . arraycopy ( h , 0 , b , off , ( len - off ) ) ; \n \n <ect>
\t1 output . clear ( ) ; \n \n \t1 System . setOut ( out ) ; \n \n \t1 if ( config . exists ( ) ) { \n \n \t1 if ( ! config . delete ( ) ) { \n \n <ect>
\t2 @ NonNull \n \n \t2 final Set < AuthenticationHandler > handlerSet = getAuthenticationHandlersForThisTransaction ( transaction ) ; \n \n \t2 LOGGER . debug ( <string_literal> , handlerSet ) ; \n \n \t2 if ( handlerSet . isEmpty ( ) ) { \n \n <ect>
\t4 if ( wait_l != null ) { \n \n \t5 if ( wait_l . await ( <number_literal> , TimeUnit . MILLISECONDS ) ) \n \n \t6 LOG . info ( <string_literal> ) ; \n \n \t5 else \n \n <ect>
\t7 createTestSampleRenameMapFile ( Arrays . asList ( <string_literal> ) ) } ) ; \n \n \t2 return tests . toArray ( new Object [ ] [ ] { } ) ; } \n \n \t1 @ Test ( dataProvider = <string_literal> , expectedExceptions = UserException . class ) \n \n \t1 public void testLoadMalformedSampleRenameMapFile ( final String testName , final File mapFile ) { \n \n <ect>
\t3 } catch ( final IOException e ) { \n \n \t4 throw new TemplateOutputException ( <string_literal> , templateSpec . getTemplate ( ) , - 1 , - 1 , e ) ; } \n \n \t2 } catch ( final TemplateOutputException e ) { \n \n \t3 <comment> \n \n <ect>
\t2 if ( throwable instanceof ProcessCanceledException ) { \n \n \t3 Flog . warn ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 if ( throwable instanceof java . lang . OutOfMemoryError ) { \n \n <ect>
\t1 private void connect ( String host , int port ) { \n \n \t2 if ( StringUtils . isNotBlank ( host ) && port > 0 ) { \n \n \t3 try { \n \n \t4 client = new CupsClient ( host , port ) ; \n \n <ect>
\t7 in . close ( ) ; } \n \n \t6 zipFile . close ( ) ; \n \n \t6 out . close ( ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t4 <comment> \n \n \t4 UpgradeServiceSummary serviceSummary = upgradeServiceSummaries . get ( serviceName ) ; \n \n \t4 addServiceInfo ( services , ambariMetaInfo , serviceSummary . sourceStackId , serviceName ) ; \n \n \t3 } else { \n \n <ect>
\t4 StringBuffer destinations = new StringBuffer ( ) ; \n \n \t4 for ( ActiveMQDestination dest : result ) { \n \n \t5 destinations . append ( destinations . length ( ) > 0 ? <string_literal> : <string_literal> ) ; \n \n \t5 destinations . append ( dest . getPhysicalName ( ) ) ; } \n \n <ect>
\t2 frame = <string_literal> + <string_literal> + getQueueName ( ) + <string_literal> + \n \n \t4 <string_literal> + <string_literal> + Stomp . NULL ; \n \n \t2 stompConnection . sendFrame ( frame ) ; \n \n \t2 receipt = stompConnection . receive ( ) ; \n \n <ect>
\t3 final PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder ( ) . build ( config . getEncryptionPrivateKeyPassword ( ) . toCharArray ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 kp = converter . getKeyPair ( ckp . decryptKeyPair ( decProv ) ) ; \n \n \t2 } else { \n \n <ect>
\t3 while ( ! newVpx . get_instance_state ( ) . equalsIgnoreCase ( <string_literal> ) && System . currentTimeMillis ( ) - startTick < startWaitMilliSeconds ) { \n \n \t4 try { \n \n \t5 Thread . sleep ( <number_literal> ) ; \n \n \t4 } catch ( final InterruptedException e ) { \n \n <ect>
\t2 doiRow . setStatus ( TO_BE_REGISTERED ) ; \n \n \t2 try { \n \n \t3 doiService . update ( context , doiRow ) ; \n \n \t2 } catch ( SQLException sqle ) { \n \n <ect>
\t5 return writeString ( SESSION_ERROR , <string_literal> ) ; } \n \n \t4 dest = ( String ) props . remove ( <string_literal> ) ; \n \n \t4 if ( dest == null ) { \n \n \t5 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 index = ( index == 1 ) ? <number_literal> : 1 ; \n \n \t2 LOG . info ( <string_literal> , index ) ; \n \n \t2 final ZooKeeper zk1 = \n \n \t3 createClient ( qu . getPeer ( index ) . peer . getClientPort ( ) , watcher1 ) ; \n \n <ect>
\t1 String [ ] argv = getArgv ( isDirect , tableName , extraArgs ) ; \n \n \t1 try { \n \n \t1 runImport ( argv ) ; \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t1 val host = configuration . getString ( JobManagerOptions . ADDRESS ) \n \n \t1 val portRange = \n \n \t1 <comment> \n \n \t1 if ( ZooKeeperUtils . isZooKeeperRecoveryMode ( configuration ) ) { \n \n <ect>
\t4 case DATA_TYPE : \n \n \t5 fs . putSingle ( key , o . getDataTypeStr ( ) ) ; \n \n \t5 break ; \n \n \t4 default : \n \n <ect>
\t4 log . info ( <string_literal> , <string_literal> + container + <string_literal> + position ) ; \n \n \t3 else if ( container instanceof RoutineDefinition ) \n \n \t4 log . info ( <string_literal> , <string_literal> + container + <string_literal> + position ) ; \n \n \t3 else \n \n <ect>
\t4 return ; \n \n \t3 if ( isTransactionRisky ( tx , dependencies ) && ! acceptRiskyTransactions ) { \n \n \t4 <comment> \n \n \t4 riskDropped . put ( tx . getHash ( ) , tx ) ; \n \n <ect>
\t2 { \n \n \t2 _log . warn ( <string_literal> , scheme ) ; } } } \n \n \t1 else \n \n \t1 { \n \n <ect>
\t5 <comment> \n \n \t4 if ( groovySpringResourcesClass != null ) { \n \n \t5 reloadSpringResourcesConfig ( config , application , groovySpringResourcesClass ) ; } } \n \n \t3 catch ( Exception ex ) { \n \n <ect>
\t1 totalStored . release ( putList . size ( ) ) ; \n \n \t1 channelCounter . addToEventPutSuccessCount ( putList . size ( ) ) ; } \n \n \t1 @ Override \n \n \t1 protected void doRollback ( ) { \n \n <ect>
\t1 instance = HdfsZooInstance . getInstance ( ) ; \n \n \t1 config = new ServerConfigurationFactory ( instance ) ; \n \n \t1 context = new AccumuloServerContext ( instance , config ) ; \n \n \t1 log . info ( <string_literal> + Constants . VERSION ) ; \n \n <ect>
\t4 return null ; } } \n \n \t2 ) ; } \n \n \t1 } catch ( SwfMetadataException e ) { \n \n \t2 if ( ! handleException ( e ) ) { \n \n <ect>
\t2 LoggingEvent event = new LoggingEvent ( <string_literal> , logger , Level . DEBUG , <string_literal> , null , null ) ; \n \n \t2 Marker ignoreMarker = MarkerFactory . getMarker ( <string_literal> ) ; \n \n \t2 event . setMarker ( ignoreMarker ) ; \n \n \t2 assertTrue ( evaluator . evaluate ( event ) ) ; \n \n <ect>
\t3 if ( versionId == - 1 ) \n \n \t4 throw new VoldemortException ( <string_literal> ) ; \n \n \t3 File [ ] backUpDirs = ReadOnlyUtils . getVersionDirs ( storeDir , versionId , Long . MAX_VALUE ) ; \n \n \t3 if ( backUpDirs == null || backUpDirs . length < = 1 ) { \n \n <ect>
\t7 logger . warn ( databaseProductName + <string_literal> + \n \n \t9 <string_literal> + supportedDatabaseProductsForProcedures ) ; } \n \n \t6 if ( accessProcedureColumnMetaData ) { \n \n <ect>
\t3 } catch ( final IllegalArgumentException e ) { \n \n \t4 s_logger . error ( <string_literal> ) ; \n \n \t4 return null ; \n \n \t3 } catch ( final InstantiationException e ) { \n \n <ect>
\t4 assertEquals ( <string_literal> , shardStatus . getFailure ( ) ) ; \n \n \t3 } else { \n \n \t4 assertEquals ( <string_literal> , shardStatus . getFailure ( ) ) ; } } } \n \n \t1 public void testGetSnapshotsFromIndexBlobOnly ( ) throws Exception { \n \n <ect>
\t2 final IResourceStream resourceStream ) \n \n \t1 { \n \n \t2 { \n \n <ect>
\t5 s_logger . debug ( <string_literal> + accountName + <string_literal> + projectId ) ; \n \n \t4 } else { \n \n \t5 assignAccountToProject ( project , accountId , ProjectAccount . Role . Regular ) ; } \n \n \t3 } else { \n \n <ect>
\t4 source = e . getSource ( ) ; \n \n \t4 target = e . getTarget ( ) ; \n \n \t4 n1 = mapping . get ( source ) ; \n \n \t4 if ( n1 == null ) { \n \n <ect>
\t2 public void subscriptionCreated ( SubscriptionEvent evt ) \n \n \t2 { \n \n \t3 synchronized ( this ) \n \n \t3 { \n \n <ect>
\t3 manager . undefineConfiguration ( region . getCache ( ) . getName ( ) ) ; \n \n \t2 } ) ; \n \n \t2 regions . clear ( ) ; } \n \n \t1 protected void stopCacheManager ( ) { \n \n <ect>
\t4 metaData = readSnapshotMetaData ( snapshotId , snapshot . version ( ) , repositoryData . resolveIndices ( indices ) , true ) ; \n \n \t3 } else { \n \n \t4 metaData = readSnapshotMetaData ( snapshotId , null , repositoryData . resolveIndices ( indices ) , true ) ; } \n \n \t2 } catch ( IOException | SnapshotException ex ) { \n \n <ect>
\t5 if ( location != null ) { \n \n \t6 openPathsUsers . get ( name ) . setLastLocation ( location ) ; \n \n \t6 logger . debug ( <string_literal> , name , location . toString ( ) ) ; \n \n \t5 } else { \n \n <ect>
<comment> \n \n public synchronized void start ( ) { \n \n \t1 state = State . START ; \n \n \t1 dispatchEvent ( EventType . START ) ; \n \n <ect>
\t5 s_logger . warn ( <string_literal> ) ; \n \n \t5 return false ; } \n \n \t4 success = _autoScalePolicyConditionMapDao . removeByAutoScalePolicyId ( id ) ; \n \n \t4 if ( ! success ) { \n \n <ect>
\t1 LOG . error ( <string_literal> + cmd + <string_literal> + res , ex ) ; } \n \n \t1 if ( watchdog . killedProcess ( ) ) { \n \n \t1 String msg = <string_literal> + timeout + <string_literal> + AppConfig \n \n \t3 . EXEC_TIMEOUT_NAME + <string_literal> ; \n \n <ect>
\t1 <comment> \n \n \t1 public void suspend ( ) { \n \n <ect>
\t3 if ( slaStatus != null ) { \n \n \t4 SLADbOperations . writeStausEvent ( coordAction . getSlaXml ( ) , coordAction . getId ( ) , slaStatus , \n \n \t6 SlaAppType . COORDINATOR_ACTION , LOG ) ; } } \n \n \t2 catch ( XException ex ) { \n \n <ect>
\t2 this . running = running ; } \n \n \t1 void execute ( StandbyClient client ) throws Exception { \n \n \t2 RecordId remoteHead = getHead ( client ) ; \n \n \t2 if ( remoteHead == null ) { \n \n <ect>
\t3 JarEntry jarEntry ; \n \n \t3 while ( ( jarEntry = jarInputStream . getNextJarEntry ( ) ) != null ) { \n \n \t3 try { \n \n \t4 String entryPath = archivePath + File . separator + jarEntry . getName ( ) ; \n \n <ect>
\t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . CLIENT_ID ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , grantType ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . SECRET ) ) { \n \n <ect>
\t5 METHOD_FILTER . apply ( runner ) ; \n \n \t5 <comment> \n \n \t5 runners . add ( runner ) ; \n \n \t4 } catch ( NoTestsRemainException e ) { \n \n <ect>
\t2 if ( StringUtils . isBlank ( tokenParam ) || ! BooleanUtils . toBoolean ( tokenParam ) ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return super . build ( ticketGrantingTicket , request ) ; } \n \n \t2 final String jwt = this . tokenTicketBuilder . build ( ticketGrantingTicket ) ; \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 hostUpdateHelper . stopPersistenceService ( ) ; \n \n \t1 } catch ( Throwable e ) { \n \n \t1 if ( e instanceof AmbariException ) { \n \n <ect>
\t3 { \n \n \t4 sendReplicationNotification ( notifyEndpoint ) ; } \n \n \t3 public void onFailure ( Throwable t ) \n \n \t3 { \n \n <ect>
\t2 pStmt . setLong ( 1 , info . id ) ; \n \n \t2 LOG . debug ( <string_literal> + s + <string_literal> ) ; \n \n \t2 int updCount = pStmt . executeUpdate ( ) ; \n \n \t2 if ( updCount != 1 ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t1 public static int parseInt ( String s , int defaultValue ) { \n \n \t2 try { \n \n \t3 return Integer . parseInt ( s ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t5 try { \n \n \t6 _connPool . switchMaster ( _host . ip , _host . pool , conn , newMaster , _username , _password , _wait ) ; \n \n \t6 return new MaintainAnswer ( cmd , <string_literal> + newMasterRecord . address ) ; \n \n \t5 } catch ( XenAPIException e ) { \n \n <ect>
\t3 MessageListener handler = createMessageHandler ( session ) ; \n \n \t3 messageConsumer . setMessageListener ( handler ) ; \n \n \t3 answer = new MessageConsumerResources ( session , messageConsumer ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( ExternalIdentityException e ) { \n \n \t3 log . error ( <string_literal> , logId , idp . getName ( ) , e ) ; \n \n \t3 return false ; \n \n \t2 } catch ( LoginException e ) { \n \n <ect>
\t2 try { \n \n \t3 outStream = new FileOutputStream ( file , true ) ; \n \n \t3 storeProperties ( properties , outStream , comment ) ; } \n \n \t2 catch ( IOException ex ) { \n \n <ect>
\t3 String n ; \n \n \t3 while ( e . hasMoreElements ( ) ) { \n \n \t4 n = e . nextElement ( ) ; \n \n \t4 logger . trace ( <string_literal> , n , servletConfig . getInitParameter ( n ) ) ; } } \n \n <ect>
\t3 self . logger . debug ( <string_literal> % vpc2 . id ) \n \n \t3 # <number_literal> ) Connect two VPCs \n \n \t3 vpnconn1_response = Vpn . createVpnConnection ( \n \n \t4 self . apiclient , customer1_response . id , vpn2_response [ 'id' ] , c [ 'passive_1' ] ) \n \n <ect>
\t4 bc . getBroadcasterCache ( ) . addToCache ( getID ( ) , r != null ? r . uuid ( ) : BroadcasterCache . NULL , \n \n \t6 new BroadcastMessage ( String . valueOf ( token . future . hashCode ( ) ) , token . originalMessage ) ) ; \n \n \t4 logger . trace ( <string_literal> , token . originalMessage ) ; } \n \n \t2 } catch ( Throwable t2 ) { \n \n <ect>
\t6 } else { \n \n \t7 synchronized ( admin ) { \n \n \t8 admin . putReply ( messageKey , reply ) ; } } } } \n \n \t3 } catch ( JMSException e1 ) { \n \n <ect>
\t4 if ( contentName . equals ( failVerify . fullName ( ) ) ) \n \n \t5 return false ; \n \n \t3 } else \n \n \t4 Log . info ( Log . FAC_TEST , <string_literal> ) ; \n \n <ect>
\t5 logger . trace ( <string_literal> + incomingObject ) ; \n \n \t4 return ; } } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t2 mock . assertIsSatisfied ( ) ; \n \n \t2 <comment> \n \n \t2 log . warn ( <string_literal> ) ; \n \n \t2 IOHelper . close ( app ) ; \n \n <ect>
\t6 if ( oldState != State . Starting && oldState != State . Migrating ) { \n \n \t7 s_logger . debug ( <string_literal> + vm + <string_literal> + oldState ) ; \n \n \t7 _vms . remove ( vm ) ; \n \n \t6 } else { \n \n <ect>
\t1 try { \n \n \t2 c . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n \t2 if ( logger != null ) { \n \n <ect>
\t1 private static Map < String , String > loadFromFile ( @ Nonnull File file , @ Nonnull Log log ) \n \n \t1 { \n \n \t2 if ( ! file . exists ( ) ) \n \n \t2 { \n \n <ect>
\t4 if ( context . getCurrentUser ( ) != null ) { \n \n \t5 log . error ( <string_literal> + context . getCurrentUser ( ) . getEmail ( ) + <string_literal> \n \n \t8 + getActionString ( action ) + <string_literal> ) ; \n \n \t4 } else { \n \n <ect>
\t3 try { \n \n \t4 Pair < Boolean , String > result = SshHelper . sshExecute ( controlIp , DEFAULT_DOMR_SSHPORT , <string_literal> , mgr . getSystemVMKeyFile ( ) , null , \n \n \t6 <string_literal> + tmpFileName ) ; \n \n \t4 if ( ! result . first ( ) ) { \n \n <ect>
\t5 continue ; } \n \n \t4 try { \n \n \t5 component . configure ( component . getName ( ) , component . getConfigParams ( ) ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n <ect>
\t7 hostConfig . getDiscoveryName ( ) ) ; \n \n \t5 scheduleConnect ( qualifier , hostConfig ) ; } \n \n \t4 @ Override \n \n \t4 public void hubDiscovered ( HarmonyHubDiscoveryResult result ) { \n \n <ect>
\t2 servletContext . addServlet ( new ServletHolder ( new MyHttpServlet ( ) ) , <string_literal> ) ; \n \n \t2 try { \n \n \t3 server . start ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 state = new PeerTestState ( CHARLIE , sz == <number_literal> , nonce , now ) ; \n \n \t2 } else { \n \n \t3 if ( state . getReceiveBobTime ( ) > now - ( RESEND_TIMEOUT / <number_literal> ) ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 } else { \n \n \t7 answer = new Answer ( cmds [ i ] , false , <string_literal> ) ; } \n \n \t5 } catch ( Throwable t ) { \n \n \t6 <comment> \n \n <ect>
\t1 public static MessageType getSpec ( Integer specID , boolean dontLog ) { \n \n \t2 MessageType id = _specs . get ( specID ) ; \n \n \t2 if ( id == null ) { \n \n \t3 if ( ! dontLog ) \n \n <ect>
\t4 if ( client . getInputStream ( ) . available ( ) == 0 ) { \n \n \t5 break ; } } \n \n \t3 return strBuffer . toString ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 count ++ ; } \n \n \t2 <comment> \n \n \t2 if ( count == 0 ) { \n \n <ect>
\t3 for ( PrintRendererFactory factory : factories ) { \n \n \t4 syntaxes . add ( factory . getSyntax ( ) ) ; } \n \n \t2 } catch ( ComponentLookupException e ) { \n \n \t3 <comment> \n \n <ect>
\t7 logger . warn ( <string_literal> , resourceHandlerName , resourceHandlerName ) ; } \n \n \t5 } else { \n \n \t6 logger . warn ( <string_literal> , resourceHandlerName , resourceHandlerName ) ; } } } \n \n \t2 } else { \n \n <ect>
\t3 } catch ( Exception exp ) { \n \n \t4 <comment> \n \n \t4 LOG . error ( <string_literal> , exp ) ; } } \n \n \t2 if ( ! isSuccess ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 throw new AccountPasswordMustChangeException ( <string_literal> ) ; } } \n \n \t3 this . principalAttributeMap . forEach ( ( key , names ) - > { \n \n \t4 final Object attribute = dbFields . get ( key ) ; \n \n \t4 if ( attribute != null ) { \n \n <ect>
\t3 final Date date = structrFile . getProperty ( AbstractFile . lastModifiedDate ) ; \n \n \t3 tx . success ( ) ; \n \n \t3 return date . getTime ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 public void onFailure ( Throwable t ) \n \n \t3 { \n \n \t4 if ( ! previewKind . isPreview ( ) ) \n \n \t4 { \n \n <ect>
\t5 . toString ( ) ) . booleanValue ( ) ; } \n \n \t2 <comment> <ect>
\t5 return ; } \n \n \t4 long sourceSSRC = getSourceSSRC ( ) ; \n \n \t4 if ( sourceSSRC == - 1 ) \n \n \t4 { \n \n <ect>
\t2 if ( refresh ( ) ) { \n \n \t3 try { \n \n \t4 cacheLong = Long . parseLong ( cache ) ; \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t4 setResponseObject ( response ) ; \n \n \t3 } else { \n \n \t4 throw new ServerApiException ( ApiErrorCode . INTERNAL_ERROR , <string_literal> ) ; } \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t2 if ( ! tipped && ( ( rowTip > 0 && result . size ( ) > rowTip ) || ( memTip > 0 && estMem > memTip ) ) ) { \n \n \t3 try { \n \n \t4 File tmp = createTempFile ( ) ; \n \n <ect>
\t2 } catch ( Exception ex ) { \n \n \t3 log . warn ( <string_literal> , ex ) ; } \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 balancer . close ( ) ; \n \n <ect>
\t2 try { \n \n \t3 LOGGER . debug ( <string_literal> , ticketId ) ; \n \n \t3 final String encTicketId = encodeTicketId ( ticketId ) ; \n \n \t3 if ( encTicketId == null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onUserListUpdated ( JSONObject source , JSONObject userList , StreamListener [ ] listeners ) throws TwitterException , JSONException { \n \n \t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onUserListDestroyed ( JSONObject source , JSONObject userList , StreamListener [ ] listeners ) throws TwitterException { \n \n <ect>
\t3 return <string_literal> ; } \n \n \t2 try { \n \n \t3 return this . xwiki . getURLContent ( surl , username , password , this . context ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public void write ( OutputStream os , InputStream is ) throws IOException { \n \n \t2 this . tcpClient . write ( os , is ) ; } \n \n \t1 @ Deprecated \n \n \t1 public String read ( InputStream is ) throws ReadException { \n \n <ect>
\t2 idx ++ ; \n \n \t2 if ( idx < list . size ( ) ) { \n \n \t3 x = list . get ( idx ) ; \n \n \t3 if ( ! x . isLiteral ( ) ) { \n \n <ect>
\t3 } else { \n \n \t4 try ( Reader reader = clob . getCharacterStream ( ) ) { \n \n \t5 jmvars . put ( name , IOUtils . toString ( reader ) ) ; } } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 case DIMMER : \n \n \t7 node . setDimmer ( command , bindingConfig . getCmdValue ( ) ) ; \n \n \t7 break ; \n \n \t6 case INPUT : \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stsSecretKeyNotEncrypted ( ) { \n \n <ect>
\t1 LOG . warn ( <string_literal> \n \n \t2 + HiveConf . getTrimmedVar ( this . conf , ConfVars . LLAP_DAEMON_SERVICE_HOSTS ) \n \n \t2 + <string_literal> ) ; } \n \n \t1 if ( ! clusterState . hasClusterInfo ( ) ) { \n \n <ect>
\t3 MetaStoreListenerNotifier . notifyEvent ( listeners , EventType . CREATE_ISCHEMA , \n \n \t4 new CreateISchemaEvent ( success , this , schema ) , null , \n \n \t4 transactionalListenersResponses , ms ) ; } } \n \n \t1 } catch ( MetaException | AlreadyExistsException e ) { \n \n <ect>
\t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 return new ArrayList < > ( 0 ) ; } \n \n \t2 final List < LogoutRequest > logoutRequests = performLogoutForTicket ( ticket ) ; \n \n \t2 this . logoutExecutionPlan . getLogoutHandlers ( ) . forEach ( h - > { \n \n <ect>
\t1 public void purgeLocks ( String lockPathRoot ) { \n \n \t2 lockPathRoot = norm ( lockPathRoot ) ; \n \n \t2 try { \n \n \t3 curator . delete ( ) . guaranteed ( ) . deletingChildrenIfNeeded ( ) . forPath ( lockPathRoot ) ; \n \n <ect>
\t6 out = null ; } } \n \n \t4 if ( getVisualizer ( ) != null ) { \n \n \t5 this . isStats = getVisualizer ( ) . isStats ( ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 private static Logger log = Logger . getLogger ( Converter . class ) ; \n \n \t1 protected void processError ( Document xml ) { \n \n \t2 String errorMessage = XMLErrors . getErrorMessage ( xml ) ; \n \n <ect>
\t3 s3 = new QuorumPeer ( peers , s3dir , s3dir , portClient3 , <number_literal> , <number_literal> , tickTime , initLimit , syncLimit ) ; \n \n \t3 Assert . assertEquals ( portClient3 , s3 . getClientPort ( ) ) ; \n \n \t3 break ; \n \n \t2 case <number_literal> : \n \n <ect>
\t1 LOG . warn ( <string_literal> + part . getTableName ( ) ) ; \n \n \t1 List < FileStatus > fileStatus = wh . getFileStatusesForLocation ( part . getLocation ( ) ) ; \n \n \t1 <comment> \n \n \t1 populateQuickStats ( fileStatus , params ) ; \n \n <ect>
\t1 public Map < String , Object > getConsentableAttributesFrom ( final ConsentDecision decision ) { \n \n \t2 try { \n \n \t3 final String result = this . consentCipherExecutor . decode ( decision . getAttributes ( ) ) ; \n \n \t3 if ( StringUtils . isBlank ( result ) ) { \n \n <ect>
\t5 + <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 long firstElementZxid = pendingTxns . element ( ) . zxid ; \n \n \t2 if ( firstElementZxid != zxid ) { \n \n <ect>
\t3 if ( storageVOs . size ( ) > 1 ) { \n \n \t4 s_logger . warn ( <string_literal> + isoId + <string_literal> + event . getAccountId ( ) + <string_literal> ) ; } \n \n \t3 for ( UsageStorageVO storageVO : storageVOs ) { \n \n <ect>
\t1 final StringBuilder sb = new StringBuilder ( <number_literal> ) ; \n \n \t1 final List < URL > moduleUrls = ErraiAppPropertiesFiles . getModulesUrls ( ) ; \n \n \t1 final List < File > classpathElements = new ArrayList < > ( moduleUrls . size ( ) ) ; \n \n \t1 classpathElements . add ( new File ( outputPath ) ) ; \n \n <ect>
\t2 try { \n \n \t3 constructor = rawType . getConstructor ( String . class ) ; \n \n \t3 constructor . setAccessible ( true ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t5 s_logger . debug ( <string_literal> + oldEvents . size ( ) + <string_literal> ) ; \n \n \t5 for ( EventVO event : oldEvents ) { \n \n \t6 _eventDao . expunge ( event . getId ( ) ) ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t5 opponent . append ( mPlayer . getName ( ) ) ; } } \n \n \t3 ServerMessagesUtil . instance . incGamesStarted ( ) ; \n \n \t3 <comment> \n \n \t3 logger . info ( <string_literal> + ( match . getGame ( ) != null ? match . getGame ( ) . getId ( ) : <string_literal> ) + <string_literal> + match . getName ( ) + <string_literal> + creator + <string_literal> + opponent . toString ( ) ) ; \n \n <ect>
<comment> \n \n \t4 assertBusy ( ( ) - > assertFalse ( client ( ) . admin ( ) . indices ( ) . prepareExists ( <string_literal> ) . get ( ) . isExists ( ) ) ) ; \n \n \t3 } catch ( ExecutionException e ) { \n \n <ect>
\t4 stats = getVmStatsRawXML ( conn ) ; } \n \n \t2 } catch ( Exception e1 ) { \n \n \t3 s_logger . warn ( <string_literal> , e1 ) ; \n \n \t3 return null ; } \n \n <ect>
\t2 } else { \n \n \t2 LOG . debug ( <string_literal> + loDevName ) ; \n \n \t2 return <string_literal> ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 transportService . registerRequestHandler ( \n \n \t3 transportNodeAction , nodeRequest , nodeExecutor , new NodeTransportHandler ( ) ) ; } \n \n \t1 @ Override \n \n \t1 protected final void doExecute ( NodesRequest request , ActionListener < NodesResponse > listener ) { \n \n <ect>
\t7 buf . append ( con ) ; \n \n \t7 buf . append ( <string_literal> ) ; \n \n \t7 for ( Connection cur : _manager . listConnections ( ) ) { \n \n \t8 buf . append ( ' \\ n' ) . append ( cur ) ; } \n \n <ect>
\t7 <comment> \n \n \t7 if ( ! stopped . get ( ) ) { \n \n \t8 LOG . info ( <string_literal> + connection + <string_literal> + error . getMessage ( ) ) ; \n \n \t8 <comment> \n \n <ect>
\t8 getErrorHandler . handleExceptions ( messageEvent , e ) ; } } \n \n \t6 break ; \n \n \t5 case VoldemortOpCode . GET_ALL_OP_CODE : \n \n <ect>
<comment> \n \n \t1 throw new RuntimeException ( errorMsg ) ; } \n \n <ect>
\t3 catch ( IOException | GridException e ) { \n \n \t4 if ( e instanceof GridGgfsHadoopCommunicationException ) \n \n \t5 hadoop . close ( true ) ; \n \n <ect>
\t2 hl7InError . setError ( error ) ; \n \n \t2 if ( cause == null ) { \n \n \t3 hl7InError . setErrorDetails ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t2 } catch ( PermissionDeniedException e ) { \n \n \t3 logger . error ( <string_literal> + e . getMessage ( ) , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 private ZWaveCommandClass resolveConverter ( Item item , ZWaveNode node , int endpointId ) { \n \n \t2 if ( item == null ) { \n \n \t3 return null ; } \n \n \t2 if ( ! preferredCommandClasses . containsKey ( item . getClass ( ) ) ) { \n \n <ect>
\t3 } else { \n \n \t4 argsBuf . append ( <string_literal> ) . append ( userpwd . getUsernamePassword ( ) ) ; } \n \n \t3 try { \n \n <ect>
\t3 if ( channels . isEmpty ( ) ) \n \n \t4 internalSynchronizer . notifyAll ( ) ; } } \n \n \t1 @ Override \n \n \t1 public void forget ( ForwardedChannelOpener opener ) { \n \n <ect>
\t2 LOG . info ( <string_literal> , instanceBasePath ) ; \n \n \t2 try { \n \n \t3 FileUtils . deleteDirectory ( instanceBasePath ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t3 { \n \n \t4 continue ; } \n \n \t3 if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) \n \n \t3 { \n \n <ect>
\t1 throws InvalidColumnMappingException { \n \n \t1 int index = 0 ; \n \n \t1 while ( true ) { \n \n \t1 if ( index >= columnSpec . length ( ) ) { \n \n <ect>
\t1 if ( nonDefaultUser || ! hasInitialSessions || hasQueue ) { \n \n \t1 LOG . info ( <string_literal> , \n \n \t3 queueName , nonDefaultUser , defaultSessionPool , hasInitialSessions ) ; \n \n \t1 return getNewSessionState ( conf , queueName , doOpen ) ; } \n \n <ect>
\t1 @ Override \n \n \t1 public void processRemoteClose ( AmqpConnection connection ) throws IOException { \n \n \t2 doClosedInspection ( ) ; \n \n \t2 if ( isAwaitingClose ( ) ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public SerialMessage getValueMessage ( ) { \n \n <ect>
\t3 if ( checkpointThread != null && ! checkpointThread . isAlive ( ) ) { \n \n \t4 startCheckpoint ( ) ; } \n \n \t3 return location ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t2 return updatedProj ; } \n \n \t1 private ProjectInstance deserializeProjectDesc ( ProjectRequest projectRequest ) { \n \n \t2 ProjectInstance projectDesc = null ; \n \n \t2 try { \n \n <ect>
\t2 query . setParameter ( <string_literal> , inDomainGroupId ) ; \n \n \t2 List < Long > peopleIds = query . getResultList ( ) ; \n \n \t2 for ( Long id : peopleIds ) \n \n \t2 { \n \n <ect>
\t1 } finally { \n \n \t2 connection . close ( ) ; } \n \n \t1 } catch ( SQLException e ) { \n \n \t1 if ( LOG . isErrorEnabled ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 headers . put ( <string_literal> , null ) ; \n \n \t2 final org . apache . camel . component . linkedin . api . model . Posts result = requestBodyAndHeaders ( <string_literal> , null , headers ) ; \n \n \t2 assertNotNull ( <string_literal> , result ) ; \n \n <ect>
<number_literal> _transport . getExternalPort ( state . getSentIP ( ) . length == <number_literal> ) , \n \n <number_literal> _transport . getIntroKey ( ) ) ; \n \n \t2 if ( pkt == null ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected final void acknowledgeIDs ( long checkpointId , Set < UId > uniqueIds ) { \n \n <ect>
@ GET \n \n @ Produces ( MediaType . APPLICATION_JSON ) \n \n public Response getList ( ) { \n \n \t1 try { \n \n <ect>
\t3 sUseNAT = StringUtils . isNotBlank ( shouldUseNAT ) && shouldUseNAT . equalsIgnoreCase ( <string_literal> ) ; \n \n \t3 if ( sPC == null ) { \n \n \t4 sLogger . debug ( <string_literal> ) ; \n \n \t4 if ( ! connect ( ) ) { \n \n <ect>
\t4 sock . setEnabledProtocols ( protocols ) ; \n \n \t3 } catch ( IllegalArgumentException e ) { <comment> \n \n \t5 log . warn ( <string_literal> , PROTOCOL_LIST ) ; \n \n <ect>
\t2 continue ; } \n \n \t1 try { \n \n \t2 testCases . add ( ( IteratorTestCase ) clz . newInstance ( ) ) ; \n \n \t1 } catch ( IllegalAccessException | InstantiationException e ) { \n \n <ect>
\t2 else if ( wbo instanceof WhiteboardObjectLine ) \n \n \t2 { \n \n \t3 WhiteboardObjectLine line = ( WhiteboardObjectLine ) wbo ; \n \n <ect>
\t1 public void deactivate ( ) { \n \n \t2 try { \n \n \t3 selector . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t8 pairMode = false ; \n \n \t8 pairModeTimer = timers . get ( itemName ) ; \n \n \t8 if ( pairModeTimer != null ) { \n \n <ect>
\t5 throw new UnrecognizableServiceForServiceTicketValidationException ( serviceTicket . getService ( ) ) ; } } \n \n \t3 final Service selectedService = resolveServiceFromAuthenticationRequest ( serviceTicket . getService ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , selectedService ) ; \n \n \t3 final RegisteredService registeredService = this . servicesManager . findServiceBy ( selectedService ) ; \n \n <ect>
\t3 } else { \n \n \t4 LOG . debug ( <string_literal> , cl . getName ( ) ) ; } \n \n \t2 } catch ( NoSuchFieldException nsfe ) { \n \n \t3 if ( <string_literal> . equals ( cl . getSuperclass ( ) . getName ( ) ) ) { \n \n <ect>
\t3 if ( providedClassLoaderService != null ) { \n \n \t4 return getEntityManagerFactoryBuilder ( persistenceUnit , integration , providedClassLoaderService ) ; } \n \n \t3 else { \n \n \t4 return getEntityManagerFactoryBuilder ( persistenceUnit , integration , providedClassLoader ) ; } } \n \n <ect>
\t2 Validator validator = schema . newValidator ( ) ; \n \n \t2 try { \n \n \t3 validator . validate ( new StreamSource ( new StringReader ( xmlContent ) ) ) ; } \n \n \t2 catch ( SAXException ex ) { \n \n <ect>
\t1 public boolean exists ( String archiveName ) { \n \n \t2 try { \n \n \t3 return listArchives ( ) . contains ( archiveName ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 throw new CommandException ( ex ) ; } \n \n \t2 return null ; } \n \n \t1 @ Override \n \n \t1 protected Void execute ( CoordinatorStore store ) throws StoreException , CommandException { \n \n <ect>
\t3 } finally { \n \n \t4 lock . unlock ( ) ; } \n \n \t3 if ( ! result ) { \n \n \t4 JdbcUtils . close ( holder . conn ) ; \n \n <ect>
\t3 JMeterContextService . getContext ( ) . setRecording ( true ) ; \n \n \t3 <comment> \n \n \t3 byte [ ] ba = request . parse ( new BufferedInputStream ( clientSocket . getInputStream ( ) ) ) ; \n \n \t3 if ( ba . length == 0 ) { \n \n <ect>
\t2 AsyncCallFuture < VolumeApiResult > future = volService . migrateVolume ( vol , ( DataStore ) destPool ) ; \n \n \t2 try { \n \n \t3 VolumeApiResult result = future . get ( ) ; \n \n \t3 if ( result . isFailed ( ) ) { \n \n <ect>
\t3 logger . trace ( <string_literal> , addr ) ; \n \n \t2 localState . markDead ( ) ; \n \n \t2 liveEndpoints . remove ( addr ) ; \n \n \t2 unreachableEndpoints . put ( addr , System . nanoTime ( ) ) ; \n \n <ect>
\t1 public void testAssertionNoFile ( ) throws Exception { \n \n \t2 result . setResponseData ( readFile ( <string_literal> ) ) ; \n \n \t2 assertion . setXsdFileName ( <string_literal> ) ; \n \n \t2 AssertionResult res = assertion . getResult ( jmctx . getPreviousResult ( ) ) ; \n \n <ect>
\t4 Collection < User > users = Context . getUserService ( ) . getUsersByRole ( role ) ; \n \n \t4 Context . getAlertService ( ) . saveAlert ( new Alert ( text , users ) ) ; } \n \n \t3 catch ( Exception e ) { \n \n \t4 <comment> \n \n <ect>
\t2 break ; } \n \n \t1 } else { <comment> \n \n \t2 reply . setCancelled ( true ) ; } \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t4 for ( int updateCount : updateCounts ) { \n \n \t5 if ( updateCount > - 1 ) { \n \n \t6 log . warn ( <string_literal> + updateCount ) ; \n \n \t5 } else if ( updateCount == Statement . SUCCESS_NO_INFO ) { \n \n <ect>
\t1 sparkMemoryAndCores = sparkSession . getMemoryAndCores ( ) ; \n \n \t1 } catch ( HiveException e ) { \n \n \t1 throw new SemanticException ( <string_literal> + e ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t6 if ( wakeupCounter == null || selector == null ) throw x ; \n \n \t6 continue ; \n \n \t5 } catch ( CancelledKeyException x ) { \n \n \t6 <comment> \n \n <ect>
\t3 LOG . debug ( <string_literal> , input . getName ( ) , input . getId ( ) ) ; \n \n \t3 resolvedArtifactCache = Maps . newConcurrentMap ( ) ; \n \n \t3 cachePerRepo . put ( input . getId ( ) , resolvedArtifactCache ) ; \n \n \t2 } else { \n \n <ect>
\t2 ExecResult result = executor . execute ( execCommand ) ; \n \n \t2 ObjectHelper . notNull ( result , <string_literal> ) ; \n \n \t2 log . info ( <string_literal> , execCommand , result . getExitValue ( ) ) ; \n \n \t2 if ( result . getExitValue ( ) != 0 ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n \t2 if ( itemName != null && command != null ) { \n \n <ect>
\t3 deleteTicket ( ticketGrantingTicketId ) ; \n \n \t3 doPublishEvent ( new CasTicketGrantingTicketDestroyedEvent ( this , ticket ) ) ; \n \n \t3 return logoutRequests ; \n \n \t2 } catch ( final InvalidTicketException e ) { \n \n <ect>
\t3 if ( isClosed ( ) ) \n \n \t4 return ; \n \n \t3 boolean locked = host . notificationsLock . tryLock ( NOTIF_LOCK_TIMEOUT_SECONDS , TimeUnit . SECONDS ) ; \n \n \t3 if ( ! locked ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 } catch ( IllegalArgumentException iae ) { \n \n \t1 <comment> \n \n \t1 throw iae ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 consumersFinished . acquire ( ) ; \n \n \t2 long end2 = System . currentTimeMillis ( ) ; \n \n \t2 LOG . info ( <string_literal> + destination + <string_literal> + prodcuerCount + <string_literal> + consumerCount + <string_literal> + deliveryMode ) ; \n \n \t2 LOG . info ( <string_literal> + ( produceCount * <number_literal> . 0 / ( end1 - start ) ) ) ; \n \n <ect>
\t2 } catch ( PortInUseException portInUseException ) { \n \n \t3 logger . error ( <string_literal> , portInUseException ) ; \n \n \t3 connected = false ; \n \n \t2 } catch ( UnsupportedCommOperationException unsupportedCommOperationException ) { \n \n <ect>
\t1 try { \n \n \t1 setupDirs ( ) ; \n \n \t1 updateHdfsState ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 ( ( NotificationEmitter ) ManagementFactory . getMemoryMXBean ( ) ) . addNotificationListener ( this , null , null ) ; \n \n \t2 List < MemoryPoolMXBean > mpbeans = ManagementFactory . getMemoryPoolMXBeans ( ) ; \n \n \t2 long totalSize = 0 ; \n \n \t2 for ( MemoryPoolMXBean pool : mpbeans ) { \n \n <ect>
\t2 . withGeneralProgressListener ( origReq . getGeneralProgressListener ( ) ) \n \n \t2 . withRequestMetricCollector ( origReq . getRequestMetricCollector ( ) ) \n \n \t2 ; \n \n \t2 String uploadId = s3 . initiateMultipartUpload ( req ) . getUploadId ( ) ; \n \n <ect>
\t4 entity . getCertBody ( ) , \n \n \t4 entity . getCertChain ( ) ) ; \n \n \t3 entity . setExpiration ( certInfo . getExpiration ( ) ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t1 public Document downloadPhonebook ( int id ) { \n \n \t2 logger . info ( <string_literal> , id ) ; \n \n \t2 String phoneBookUrl = _tr064comm . getTr064Value ( new ItemConfiguration ( <string_literal> , String . valueOf ( id ) ) ) ; \n \n \t2 Document phoneBook = _tr064comm . getFboxXmlResponse ( phoneBookUrl ) ; \n \n <ect>
\t1 getRecoveryMarkers ( c ) ; \n \n \t1 <comment> \n \n \t1 sleepUninterruptibly ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t1 Map < KeyExtent , List < String > > markers = getRecoveryMarkers ( c ) ; \n \n <ect>
\t3 sb . append ( <string_literal> ) . append ( streamId ) ; \n \n \t3 sb . append ( <string_literal> ) . append ( componentName ) ; \n \n \t3 sb . append ( <string_literal> ) . append ( streamName ) ; \n \n \t3 sb . append ( <string_literal> ) . append ( id ) ; \n \n <ect>
\t1 public CodeSnippet process ( ResourceMethod resourceMethod ) { \n \n \t2 EndPointMethod endPointMethod = ( EndPointMethod ) resourceMethod ; \n \n \t2 String methodName = qualifiedMethodName ( resourceMethod ) ; \n \n \t2 EndPoint endPoint = endPointMethod . getEndPoint ( ) ; \n \n <ect>
\t2 return simulateCounterAttack ( game , node , alpha , beta ) ; } \n \n \t1 protected void simulateToEnd ( Game game ) { \n \n \t2 if ( Thread . interrupted ( ) ) { \n \n \t3 Thread . currentThread ( ) . interrupt ( ) ; \n \n <ect>
\t4 response . getOutputStream ( ) . write ( <string_literal> . getBytes ( <string_literal> ) ) ; \n \n \t4 return ; } \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t2 assertNotNull ( name ) ; \n \n \t2 ContentName tn = new ContentName ( ) ; \n \n \t2 ContentName bn = new ContentName ( ) ; \n \n \t2 XMLEncodableTester . encodeDecodeTest ( <string_literal> , name , tn , bn ) ; \n \n <ect>
\t2 log . debug ( 'Finished' ) } \n \n \t1 protected boolean work ( ) { \n \n \t2 def line = readLine ( ) \n \n \t2 if ( log . debugEnabled ) { \n \n <ect>
\t5 logger . error ( \n \n \t7 <string_literal> ) ; } \n \n \t4 completeJoin ( ctx , message . getJoinComplete ( ) ) ; \n \n \t3 } else { \n \n <ect>
public static void killServer ( AbstractProtocolServer < ? > server ) { \n \n \t1 try { \n \n \t2 if ( server != null ) server . stop ( ) ; \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return success ( ) ; } \n \n \t2 final Authentication authentication = WebUtils . getAuthentication ( requestContext ) ; \n \n \t2 if ( authentication == null ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 int totalRebalanced = 0 ; \n \n \t2 long start = System . currentTimeMillis ( ) ; \n \n \t2 for ( StorageEngine < ByteArray , byte [ ] , byte [ ] > engine : storeRepository . getAllStorageEngines ( ) ) { \n \n <ect>
\t4 authenticatedSessions . remove ( sessionId ) ; \n \n \t3 } else { \n \n \t4 logger . warn ( <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t3 mcp . setEventThreshold ( 0 , input ) ; \n \n \t3 mcp . setMonitorEnabled ( true ) ; \n \n \t3 logger . debug ( <string_literal> , itemName ) ; \n \n \t2 } catch ( IOException exception ) { \n \n <ect>
\t4 throw new IOException ( <string_literal> + f . getCanonicalPath ( ) ) ; } \n \n \t3 if ( this . serviceMap . containsKey ( service . getId ( ) ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , service . getId ( ) ) ; } \n \n \t3 this . serviceMap . put ( service . getId ( ) , service ) ; \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t3 download ( _resume , _callback ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 protected Message getFallback ( ) { \n \n \t2 return null ; } \n \n \t1 @ Override \n \n \t1 protected Message run ( ) throws Exception { \n \n <ect>
\t1 public static boolean hasNamespace ( InputStream file , String . . . namespaceURis ) { \n \n \t2 try { \n \n \t3 return hasNamespace ( getNamespaces ( file ) , namespaceURis ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
var n = e [ t ] , r = void 0 ; r = { type : n . multiLine ? <string_literal> : <string_literal> , value : this . scanner . source . slice ( n . slice [ 0 ] , n . slice [ 1 ] ) } , this . config . range && ( r . range = n . range ) , this . config . loc && ( r . loc = n . loc ) ; var i = { start : { line : n . loc . start . line , column : n . loc . start . column , offset : n . range [ 0 ] } , end : { line : n . loc . end . line , column : n . loc . end . column , offset : n . range [ 1 ] } } ; this . delegate ( r , i ) } } else this . scanner . scanComments ( ) } , e . prototype . getTokenRaw = function ( e ) { return this . scanner . source . slice ( e . start , e . end ) } , e . prototype . convertToken = function ( e ) { var t ; return t = { type : a . TokenName [ e . type ] , value : this . getTokenRaw ( e ) } , this . config . range && ( t . range = [ e . start , e . end ] ) , this . config . loc && ( t . loc = { start : { line : this . startMarker . lineNumber , column : this . startMarker . index - this . startMarker . lineStart } , end : { line : this . scanner . lineNumber , column : this . scanner . index - this . scanner . lineStart } } ) , e . regex && ( t . regex = e . regex ) , t } , e . prototype . nextToken = function ( ) { var e = this . lookahead ; this . lastMarker . index = this . scanner . index , this . lastMarker . lineNumber = this . scanner . lineNumber , this . lastMarker . lineStart = this . scanner . lineStart , this . collectComments ( ) , this . startMarker . index = this . scanner . index , this . startMarker . lineNumber = this . scanner . lineNumber , this . startMarker . lineStart = this . scanner . lineStart ; var t ; return t = this . scanner . lex ( ) , this . hasLineTerminator = ! ( ! e || ! t ) && e . lineNumber != = t . lineNumber , t && this . context . strict && t . type == = a . Token . Identifier && this . scanner . isStrictModeReservedWord ( t . value ) && ( t . type = a . Token . Keyword ) , this . lookahead = t , this . config . tokens && t . type != = a . Token . EOF && this . tokens . push ( this . convertToken ( t ) ) , e } , e . prototype . nextRegexToken = function ( ) { this . collectComments ( ) ; var e = this . scanner . scanRegExp ( ) ; return this . config . tokens && ( this . tokens . pop ( ) , this . tokens . push ( this . convertToken ( e ) ) ) , this . lookahead = e , this . nextToken ( ) , e } , e . prototype . createNode = function ( ) { return { index : this . startMarker . index , line : this . startMarker . lineNumber , column : this . startMarker . index - this . startMarker . lineStart } } , e . prototype . startNode = function ( e ) { return { index : e . start , line : e . lineNumber , column : e . start - e . lineStart } } , e . prototype . finalize = function ( e , t ) { if ( this . config . range && ( t . range = [ e . index , this . lastMarker . index ] ) , this . config . loc && ( t . loc = { start : { line : e . line , column : e . column } , end : { line : this . lastMarker . lineNumber , column : this . lastMarker . index - this . lastMarker . lineStart } } , this . config . source && ( t . loc . source = this . config . source ) ) , this . delegate ) { var n = { start : { line : e . line , column : e . column , offset : e . index } , end : { line : this . lastMarker . lineNumber , column : this . lastMarker . index - this . lastMarker . lineStart , offset : this . lastMarker . index } } ; this . delegate ( t , n ) } return t } , e . prototype . expect = function ( e ) { var t = this . nextToken ( ) ; t . type == = a . Token . Punctuator && t . value == = e || this . throwUnexpectedToken ( t ) } , e . prototype . expectCommaSeparator = function ( ) { if ( this . config . tolerant ) { var e = this . lookahead ; e . type == = a . Token . Punctuator && <string_literal> == = e . value ? this . nextToken ( ) : e . type == = a . Token . Punctuator && <string_literal> == = e . value ? ( this . nextToken ( ) , this . tolerateUnexpectedToken ( e ) ) : this . tolerateUnexpectedToken ( e , i . Messages . UnexpectedToken ) } else this . expect ( <string_literal> ) } , e . prototype . expectKeyword = function ( e ) { var t = this . nextToken ( ) ; t . type == = a . Token . Keyword && t . value == = e || this . throwUnexpectedToken ( t ) } , e . prototype . match = function ( e ) { return this . lookahead . type == = a . Token . Punctuator && this . lookahead . value == = e } , e . prototype . matchKeyword = function ( e ) { return this . lookahead . type == = a . Token . Keyword && this . lookahead . value == = e } , e . prototype . matchContextualKeyword = function ( e ) { return this . lookahead . type == = a . Token . Identifier && this . lookahead . value == = e } , e . prototype . matchAssign = function ( ) { if ( this . lookahead . type != = a . Token . Punctuator ) return ! 1 ; var e = this . lookahead . value ; return <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e || <string_literal> == = e } , e . prototype . isolateCoverGrammar = function ( e ) { var t = this . context . isBindingElement , n = this . context . isAssignmentTarget , r = this . context . firstCoverInitializedNameError ; this . context . isBindingElement = ! 0 , this . context . isAssignmentTarget = ! 0 , this . context . firstCoverInitializedNameError = null ; var i = e . call ( this ) ; return null != = this . context . firstCoverInitializedNameError && this . throwUnexpectedToken ( this . context . firstCoverInitializedNameError ) , this . context . isBindingElement = t , this . context . isAssignmentTarget = n , this . context . firstCoverInitializedNameError = r , i } , e . prototype . inheritCoverGrammar = function ( e ) { var t = this . context . isBindingElement , n = this . context . isAssignmentTarget , r = this . context . firstCoverInitializedNameError ; this . context . isBindingElement = ! 0 , this . context . isAssignmentTarget = ! 0 , this . context . firstCoverInitializedNameError = null ; var i = e . call ( this ) ; return this . context . isBindingElement = this . context . isBindingElement && t , this . context . isAssignmentTarget = this . context . isAssignmentTarget && n , this . context . firstCoverInitializedNameError = r || this . context . firstCoverInitializedNameError , i } , e . prototype . consumeSemicolon = function ( ) { this . match ( <string_literal> ) ? this . nextToken ( ) : this . hasLineTerminator || ( this . lookahead . type == = a . Token . EOF || this . match ( <string_literal> ) || this . throwUnexpectedToken ( this . lookahead ) , this . lastMarker . index = this . startMarker . index , this . lastMarker . lineNumber = this . startMarker . lineNumber , this . lastMarker . lineStart = this . startMarker . lineStart ) } , e . prototype . parsePrimaryExpression = function ( ) { var e , t , n , r , o = this . createNode ( ) ; switch ( this . lookahead . type ) { case a . Token . Identifier : <string_literal> == = this . sourceType && <string_literal> == = this . lookahead . value && this . tolerateUnexpectedToken ( this . lookahead ) , e = this . finalize ( o , new c . Identifier ( this . nextToken ( ) . value ) ) ; break ; case a . Token . NumericLiteral : case a . Token . StringLiteral : this . context . strict && this . lookahead . octal && this . tolerateUnexpectedToken ( this . lookahead , i . Messages . StrictOctalLiteral ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 , n = this . nextToken ( ) , r = this . getTokenRaw ( n ) , e = this . finalize ( o , new c . Literal ( n . value , r ) ) ; break ; case a . Token . BooleanLiteral : this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 , n = this . nextToken ( ) , n . value = <string_literal> == = n . value , r = this . getTokenRaw ( n ) , e = this . finalize ( o , new c . Literal ( n . value , r ) ) ; break ; case a . Token . NullLiteral : this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 , n = this . nextToken ( ) , n . value = null , r = this . getTokenRaw ( n ) , e = this . finalize ( o , new c . Literal ( n . value , r ) ) ; break ; case a . Token . Template : e = this . parseTemplateLiteral ( ) ; break ; case a . Token . Punctuator : switch ( t = this . lookahead . value ) { case <string_literal> : this . context . isBindingElement = ! 1 , e = this . inheritCoverGrammar ( this . parseGroupExpression ) ; break ; case <string_literal> : e = this . inheritCoverGrammar ( this . parseArrayInitializer ) ; break ; case <string_literal> : e = this . inheritCoverGrammar ( this . parseObjectInitializer ) ; break ; case <string_literal> : case <string_literal> : this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 , this . scanner . index = this . startMarker . index , n = this . nextRegexToken ( ) , r = this . getTokenRaw ( n ) , e = this . finalize ( o , new c . RegexLiteral ( n . value , r , n . regex ) ) ; break ; default : this . throwUnexpectedToken ( this . nextToken ( ) ) } break ; case a . Token . Keyword : ! this . context . strict && this . context . allowYield && this . matchKeyword ( <string_literal> ) ? e = this . parseIdentifierName ( ) : ! this . context . strict && this . matchKeyword ( <string_literal> ) ? e = this . finalize ( o , new c . Identifier ( this . nextToken ( ) . value ) ) : ( this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 , this . matchKeyword ( <string_literal> ) ? e = this . parseFunctionExpression ( ) : this . matchKeyword ( <string_literal> ) ? ( this . nextToken ( ) , e = this . finalize ( o , new c . ThisExpression ) ) : this . matchKeyword ( <string_literal> ) ? e = this . parseClassExpression ( ) : this . throwUnexpectedToken ( this . nextToken ( ) ) ) ; break ; default : this . throwUnexpectedToken ( this . nextToken ( ) ) } return e } , e . prototype . parseSpreadElement = function ( ) { var e = this . createNode ( ) ; this . expect ( <string_literal> ) ; var t = this . inheritCoverGrammar ( this . parseAssignmentExpression ) ; return this . finalize ( e , new c . SpreadElement ( t ) ) } , e . prototype . parseArrayInitializer = function ( ) { var e = this . createNode ( ) , t = [ ] ; for ( this . expect ( <string_literal> ) ; ! this . match ( <string_literal> ) ; ) if ( this . match ( <string_literal> ) ) this . nextToken ( ) , t . push ( null ) ; else if ( this . match ( <string_literal> ) ) { var n = this . parseSpreadElement ( ) ; this . match ( <string_literal> ) || ( this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 , this . expect ( <string_literal> ) ) , t . push ( n ) } else t . push ( this . inheritCoverGrammar ( this . parseAssignmentExpression ) ) , this . match ( <string_literal> ) || this . expect ( <string_literal> ) ; return this . expect ( <string_literal> ) , this . finalize ( e , new c . ArrayExpression ( t ) ) } , e . prototype . parsePropertyMethod = function ( e ) { this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 ; var t = this . context . strict , n = this . isolateCoverGrammar ( this . parseFunctionSourceElements ) ; return this . context . strict && e . firstRestricted && this . tolerateUnexpectedToken ( e . firstRestricted , e . message ) , this . context . strict && e . stricted && this . tolerateUnexpectedToken ( e . stricted , e . message ) , this . context . strict = t , n } , e . prototype . parsePropertyMethodFunction = function ( ) { var e = ! 1 , t = this . createNode ( ) , n = this . context . allowYield ; this . context . allowYield = ! 1 ; var r = this . parseFormalParameters ( ) , i = this . parsePropertyMethod ( r ) ; return this . context . allowYield = n , this . finalize ( t , new c . FunctionExpression ( null , r . params , i , e ) ) } , e . prototype . parseObjectPropertyKey = function ( ) { var e = this . createNode ( ) , t = this . nextToken ( ) , n = null ; switch ( t . type ) { case a . Token . StringLiteral : case a . Token . NumericLiteral : this . context . strict && t . octal && this . tolerateUnexpectedToken ( t , i . Messages . StrictOctalLiteral ) ; var r = this . getTokenRaw ( t ) ; n = this . finalize ( e , new c . Literal ( t . value , r ) ) ; break ; case a . Token . Identifier : case a . Token . BooleanLiteral : case a . Token . NullLiteral : case a . Token . Keyword : n = this . finalize ( e , new c . Identifier ( t . value ) ) ; break ; case a . Token . Punctuator : <string_literal> == = t . value ? ( n = this . isolateCoverGrammar ( this . parseAssignmentExpression ) , this . expect ( <string_literal> ) ) : this . throwUnexpectedToken ( t ) ; break ; default : this . throwUnexpectedToken ( t ) } return n } , e . prototype . isPropertyKey = function ( e , t ) { return e . type == = u . Syntax . Identifier && e . name == = t || e . type == = u . Syntax . Literal && e . value == = t } , e . prototype . parseObjectProperty = function ( e ) { var t , n , r , o = this . createNode ( ) , s = this . lookahead , u = ! 1 , l = ! 1 , p = ! 1 ; s . type == = a . Token . Identifier ? ( this . nextToken ( ) , n = this . finalize ( o , new c . Identifier ( s . value ) ) ) : this . match ( <string_literal> ) ? this . nextToken ( ) : ( u = this . match ( <string_literal> ) , n = this . parseObjectPropertyKey ( ) ) ; var f = this . qualifiedPropertyName ( this . lookahead ) ; if ( s . type == = a . Token . Identifier && <string_literal> == = s . value && f ) t = <string_literal> , u = this . match ( <string_literal> ) , n = this . parseObjectPropertyKey ( ) , this . context . allowYield = ! 1 , r = this . parseGetterMethod ( ) ; else if ( s . type == = a . Token . Identifier && <string_literal> == = s . value && f ) t = <string_literal> , u = this . match ( <string_literal> ) , n = this . parseObjectPropertyKey ( ) , r = this . parseSetterMethod ( ) ; else if ( s . type == = a . Token . Punctuator && <string_literal> == = s . value && f ) t = <string_literal> , u = this . match ( <string_literal> ) , n = this . parseObjectPropertyKey ( ) , r = this . parseGeneratorMethod ( ) , l = ! 0 ; else if ( n || this . throwUnexpectedToken ( this . lookahead ) , t = <string_literal> , this . match ( <string_literal> ) ) ! u && this . isPropertyKey ( n , <string_literal> ) && ( e . value && this . tolerateError ( i . Messages . DuplicateProtoProperty ) , e . value = ! 0 ) , this . nextToken ( ) , r = this . inheritCoverGrammar ( this . parseAssignmentExpression ) ; else if ( this . match ( <string_literal> ) ) r = this . parsePropertyMethodFunction ( ) , l = ! 0 ; else if ( s . type == = a . Token . Identifier ) { var h = this . finalize ( o , new c . Identifier ( s . value ) ) ; if ( this . match ( <string_literal> ) ) { this . context . firstCoverInitializedNameError = this . lookahead , this . nextToken ( ) , p = ! 0 ; var d = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; r = this . finalize ( o , new c . AssignmentPattern ( h , d ) ) } else p = ! 0 , r = h } else this . throwUnexpectedToken ( this . nextToken ( ) ) ; return this . finalize ( o , new c . Property ( t , n , u , r , l , p ) ) } , e . prototype . parseObjectInitializer = function ( ) { var e = this . createNode ( ) ; this . expect ( <string_literal> ) ; for ( var t = [ ] , n = { value : ! 1 } ; ! this . match ( <string_literal> ) ; ) t . push ( this . parseObjectProperty ( n ) ) , this . match ( <string_literal> ) || this . expectCommaSeparator ( ) ; return this . expect ( <string_literal> ) , this . finalize ( e , new c . ObjectExpression ( t ) ) } , e . prototype . parseTemplateHead = function ( ) { r . assert ( this . lookahead . head , <string_literal> ) ; var e = this . createNode ( ) , t = this . nextToken ( ) , n = { raw : t . value . raw , cooked : t . value . cooked } ; return this . finalize ( e , new c . TemplateElement ( n , t . tail ) ) } , e . prototype . parseTemplateElement = function ( ) { this . lookahead . type != = a . Token . Template && this . throwUnexpectedToken ( ) ; var e = this . createNode ( ) , t = this . nextToken ( ) , n = { raw : t . value . raw , cooked : t . value . cooked } ; return this . finalize ( e , new c . TemplateElement ( n , t . tail ) ) } , e . prototype . parseTemplateLiteral = function ( ) { var e = this . createNode ( ) , t = [ ] , n = [ ] , r = this . parseTemplateHead ( ) ; for ( n . push ( r ) ; ! r . tail ; ) t . push ( this . parseExpression ( ) ) , r = this . parseTemplateElement ( ) , n . push ( r ) ; return this . finalize ( e , new c . TemplateLiteral ( n , t ) ) } , e . prototype . reinterpretExpressionAsPattern = function ( e ) { switch ( e . type ) { case u . Syntax . Identifier : case u . Syntax . MemberExpression : case u . Syntax . RestElement : case u . Syntax . AssignmentPattern : break ; case u . Syntax . SpreadElement : e . type = u . Syntax . RestElement , this . reinterpretExpressionAsPattern ( e . argument ) ; break ; case u . Syntax . ArrayExpression : e . type = u . Syntax . ArrayPattern ; for ( var t = 0 ; t < e . elements . length ; t ++ ) null != = e . elements [ t ] && this . reinterpretExpressionAsPattern ( e . elements [ t ] ) ; break ; case u . Syntax . ObjectExpression : e . type = u . Syntax . ObjectPattern ; for ( var t = 0 ; t < e . properties . length ; t ++ ) this . reinterpretExpressionAsPattern ( e . properties [ t ] . value ) ; break ; case u . Syntax . AssignmentExpression : e . type = u . Syntax . AssignmentPattern , delete e . operator , this . reinterpretExpressionAsPattern ( e . left ) } } , e . prototype . parseGroupExpression = function ( ) { var e ; if ( this . expect ( <string_literal> ) , this . match ( <string_literal> ) ) this . nextToken ( ) , this . match ( <string_literal> ) || this . expect ( <string_literal> ) , e = { type : l , params : [ ] } ; else { var t = this . lookahead , n = [ ] ; if ( this . match ( <string_literal> ) ) e = this . parseRestElement ( n ) , this . expect ( <string_literal> ) , this . match ( <string_literal> ) || this . expect ( <string_literal> ) , e = { type : l , params : [ e ] } ; else { var r = ! 1 ; if ( this . context . isBindingElement = ! 0 , e = this . inheritCoverGrammar ( this . parseAssignmentExpression ) , this . match ( <string_literal> ) ) { var i = [ ] ; for ( this . context . isAssignmentTarget = ! 1 , i . push ( e ) ; this . startMarker . index < this . scanner . length && this . match ( <string_literal> ) ; ) { if ( this . nextToken ( ) , this . match ( <string_literal> ) ) { this . context . isBindingElement || this . throwUnexpectedToken ( this . lookahead ) , i . push ( this . parseRestElement ( n ) ) , this . expect ( <string_literal> ) , this . match ( <string_literal> ) || this . expect ( <string_literal> ) , this . context . isBindingElement = ! 1 ; for ( var o = 0 ; o < i . length ; o ++ ) this . reinterpretExpressionAsPattern ( i [ o ] ) ; r = ! 0 , e = { type : l , params : i } } else i . push ( this . inheritCoverGrammar ( this . parseAssignmentExpression ) ) ; if ( r ) break } r || ( e = this . finalize ( this . startNode ( t ) , new c . SequenceExpression ( i ) ) ) } if ( ! r ) { if ( this . expect ( <string_literal> ) , this . match ( <string_literal> ) && ( e . type == = u . Syntax . Identifier && <string_literal> == = e . name && ( r = ! 0 , e = { type : l , params : [ e ] } ) , ! r ) ) { if ( this . context . isBindingElement || this . throwUnexpectedToken ( this . lookahead ) , e . type == = u . Syntax . SequenceExpression ) for ( var o = 0 ; o < e . expressions . length ; o ++ ) this . reinterpretExpressionAsPattern ( e . expressions [ o ] ) ; else this . reinterpretExpressionAsPattern ( e ) ; var a = e . type == = u . Syntax . SequenceExpression ? e . expressions : [ e ] ; e = { type : l , params : a } } this . context . isBindingElement = ! 1 } } } return e } , e . prototype . parseArguments = function ( ) { this . expect ( <string_literal> ) ; var e = [ ] ; if ( ! this . match ( <string_literal> ) ) for ( ; ; ) { var t = this . match ( <string_literal> ) ? this . parseSpreadElement ( ) : this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; if ( e . push ( t ) , this . match ( <string_literal> ) ) break ; this . expectCommaSeparator ( ) } return this . expect ( <string_literal> ) , e } , e . prototype . isIdentifierName = function ( e ) { return e . type == = a . Token . Identifier || e . type == = a . Token . Keyword || e . type == = a . Token . BooleanLiteral || e . type == = a . Token . NullLiteral } , e . prototype . parseIdentifierName = function ( ) { var e = this . createNode ( ) , t = this . nextToken ( ) ; return this . isIdentifierName ( t ) || this . throwUnexpectedToken ( t ) , this . finalize ( e , new c . Identifier ( t . value ) ) } , e . prototype . parseNewExpression = function ( ) { var e = this . createNode ( ) , t = this . parseIdentifierName ( ) ; r . assert ( <string_literal> == = t . name , <string_literal> ) ; var n ; if ( this . match ( <string_literal> ) ) if ( this . nextToken ( ) , this . lookahead . type == = a . Token . Identifier && this . context . inFunctionBody && <string_literal> == = this . lookahead . value ) { var i = this . parseIdentifierName ( ) ; n = new c . MetaProperty ( t , i ) } else this . throwUnexpectedToken ( this . lookahead ) ; else { var o = this . isolateCoverGrammar ( this . parseLeftHandSideExpression ) , s = this . match ( <string_literal> ) ? this . parseArguments ( ) : [ ] ; n = new c . NewExpression ( o , s ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 } return this . finalize ( e , n ) } , e . prototype . parseLeftHandSideExpressionAllowCall = function ( ) { var e = this . lookahead , t = this . context . allowIn ; this . context . allowIn = ! 0 ; var n ; for ( this . matchKeyword ( <string_literal> ) && this . context . inFunctionBody ? ( n = this . createNode ( ) , this . nextToken ( ) , n = this . finalize ( n , new c . Super ) , this . match ( <string_literal> ) || this . match ( <string_literal> ) || this . match ( <string_literal> ) || this . throwUnexpectedToken ( this . lookahead ) ) : n = this . inheritCoverGrammar ( this . matchKeyword ( <string_literal> ) ? this . parseNewExpression : this . parsePrimaryExpression ) ; ; ) if ( this . match ( <string_literal> ) ) { this . context . isBindingElement = ! 1 , this . context . isAssignmentTarget = ! 0 , this . expect ( <string_literal> ) ; var r = this . parseIdentifierName ( ) ; n = this . finalize ( this . startNode ( e ) , new c . StaticMemberExpression ( n , r ) ) } else if ( this . match ( <string_literal> ) ) { this . context . isBindingElement = ! 1 , this . context . isAssignmentTarget = ! 1 ; var i = this . parseArguments ( ) ; n = this . finalize ( this . startNode ( e ) , new c . CallExpression ( n , i ) ) } else if ( this . match ( <string_literal> ) ) { this . context . isBindingElement = ! 1 , this . context . isAssignmentTarget = ! 0 , this . expect ( <string_literal> ) ; var r = this . isolateCoverGrammar ( this . parseExpression ) ; this . expect ( <string_literal> ) , n = this . finalize ( this . startNode ( e ) , new c . ComputedMemberExpression ( n , r ) ) } else { if ( this . lookahead . type != = a . Token . Template || ! this . lookahead . head ) break ; var o = this . parseTemplateLiteral ( ) ; n = this . finalize ( this . startNode ( e ) , new c . TaggedTemplateExpression ( n , o ) ) } return this . context . allowIn = t , n } , e . prototype . parseSuper = function ( ) { var e = this . createNode ( ) ; return this . expectKeyword ( <string_literal> ) , this . match ( <string_literal> ) || this . match ( <string_literal> ) || this . throwUnexpectedToken ( this . lookahead ) , this . finalize ( e , new c . Super ) } , e . prototype . parseLeftHandSideExpression = function ( ) { r . assert ( this . context . allowIn , <string_literal> ) ; for ( var e = this . startNode ( this . lookahead ) , t = this . matchKeyword ( <string_literal> ) && this . context . inFunctionBody ? this . parseSuper ( ) : this . inheritCoverGrammar ( this . matchKeyword ( <string_literal> ) ? this . parseNewExpression : this . parsePrimaryExpression ) ; ; ) if ( this . match ( <string_literal> ) ) { this . context . isBindingElement = ! 1 , this . context . isAssignmentTarget = ! 0 , this . expect ( <string_literal> ) ; var n = this . isolateCoverGrammar ( this . parseExpression ) ; this . expect ( <string_literal> ) , t = this . finalize ( e , new c . ComputedMemberExpression ( t , n ) ) } else if ( this . match ( <string_literal> ) ) { this . context . isBindingElement = ! 1 , this . context . isAssignmentTarget = ! 0 , this . expect ( <string_literal> ) ; var n = this . parseIdentifierName ( ) ; t = this . finalize ( e , new c . StaticMemberExpression ( t , n ) ) } else { if ( this . lookahead . type != = a . Token . Template || ! this . lookahead . head ) break ; var i = this . parseTemplateLiteral ( ) ; t = this . finalize ( e , new c . TaggedTemplateExpression ( t , i ) ) } return t } , e . prototype . parseUpdateExpression = function ( ) { var e , t = this . lookahead ; if ( this . match ( <string_literal> ) || this . match ( <string_literal> ) ) { var n = this . startNode ( t ) , r = this . nextToken ( ) ; e = this . inheritCoverGrammar ( this . parseUnaryExpression ) , this . context . strict && e . type == = u . Syntax . Identifier && this . scanner . isRestrictedWord ( e . name ) && this . tolerateError ( i . Messages . StrictLHSPrefix ) , this . context . isAssignmentTarget || this . tolerateError ( i . Messages . InvalidLHSInAssignment ) ; var o = ! 0 ; e = this . finalize ( n , new c . UpdateExpression ( r . value , e , o ) ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 } else if ( e = this . inheritCoverGrammar ( this . parseLeftHandSideExpressionAllowCall ) , ! this . hasLineTerminator && this . lookahead . type == = a . Token . Punctuator && ( this . match ( <string_literal> ) || this . match ( <string_literal> ) ) ) { this . context . strict && e . type == = u . Syntax . Identifier && this . scanner . isRestrictedWord ( e . name ) && this . tolerateError ( i . Messages . StrictLHSPostfix ) , this . context . isAssignmentTarget || this . tolerateError ( i . Messages . InvalidLHSInAssignment ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 ; var s = this . nextToken ( ) . value , o = ! 1 ; e = this . finalize ( this . startNode ( t ) , new c . UpdateExpression ( s , e , o ) ) } return e } , e . prototype . parseUnaryExpression = function ( ) { var e ; if ( this . match ( <string_literal> ) || this . match ( <string_literal> ) || this . match ( <string_literal> ) || this . match ( <string_literal> ) || this . matchKeyword ( <string_literal> ) || this . matchKeyword ( <string_literal> ) || this . matchKeyword ( <string_literal> ) ) { var t = this . startNode ( this . lookahead ) , n = this . nextToken ( ) ; e = this . inheritCoverGrammar ( this . parseUnaryExpression ) , e = this . finalize ( t , new c . UnaryExpression ( n . value , e ) ) , this . context . strict && <string_literal> == = e . operator && e . argument . type == = u . Syntax . Identifier && this . tolerateError ( i . Messages . StrictDelete ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 } else e = this . parseUpdateExpression ( ) ; return e } , e . prototype . parseExponentiationExpression = function ( ) { var e = this . lookahead , t = this . inheritCoverGrammar ( this . parseUnaryExpression ) ; if ( t . type != = u . Syntax . UnaryExpression && this . match ( <string_literal> ) ) { this . nextToken ( ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 ; var n = t , r = this . isolateCoverGrammar ( this . parseExponentiationExpression ) ; t = this . finalize ( this . startNode ( e ) , new c . BinaryExpression ( <string_literal> , n , r ) ) } return t } , e . prototype . binaryPrecedence = function ( e ) { var t , n = e . value ; return t = e . type == = a . Token . Punctuator ? this . operatorPrecedence [ n ] || 0 : e . type == = a . Token . Keyword && ( <string_literal> == = n || this . context . allowIn && <string_literal> == = n ) ? <number_literal> : 0 } , e . prototype . parseBinaryExpression = function ( ) { var e = this . lookahead , t = this . inheritCoverGrammar ( this . parseExponentiationExpression ) , n = this . lookahead , r = this . binaryPrecedence ( n ) ; if ( r > 0 ) { this . nextToken ( ) , n . prec = r , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 ; for ( var i = [ e , this . lookahead ] , o = t , a = this . isolateCoverGrammar ( this . parseExponentiationExpression ) , s = [ o , n , a ] ; ; ) { if ( r = this . binaryPrecedence ( this . lookahead ) , r < = 0 ) break ; for ( ; s . length > <number_literal> && r < = s [ s . length - <number_literal> ] . prec ; ) { a = s . pop ( ) ; var u = s . pop ( ) . value ; o = s . pop ( ) , i . pop ( ) ; var l = this . startNode ( i [ i . length - 1 ] ) ; s . push ( this . finalize ( l , new c . BinaryExpression ( u , o , a ) ) ) } n = this . nextToken ( ) , n . prec = r , s . push ( n ) , i . push ( this . lookahead ) , s . push ( this . isolateCoverGrammar ( this . parseExponentiationExpression ) ) } var p = s . length - 1 ; for ( t = s [ p ] , i . pop ( ) ; p > 1 ; ) { var l = this . startNode ( i . pop ( ) ) ; t = this . finalize ( l , new c . BinaryExpression ( s [ p - 1 ] . value , s [ p - <number_literal> ] , t ) ) , p -= <number_literal> } } return t } , e . prototype . parseConditionalExpression = function ( ) { var e = this . lookahead , t = this . inheritCoverGrammar ( this . parseBinaryExpression ) ; if ( this . match ( <string_literal> ) ) { this . nextToken ( ) ; var n = this . context . allowIn ; this . context . allowIn = ! 0 ; var r = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; this . context . allowIn = n , this . expect ( <string_literal> ) ; var i = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; t = this . finalize ( this . startNode ( e ) , new c . ConditionalExpression ( t , r , i ) ) , this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 } return t } , e . prototype . checkPatternParam = function ( e , t ) { switch ( t . type ) { case u . Syntax . Identifier : this . validateParam ( e , t , t . name ) ; break ; case u . Syntax . RestElement : this . checkPatternParam ( e , t . argument ) ; break ; case u . Syntax . AssignmentPattern : this . checkPatternParam ( e , t . left ) ; break ; case u . Syntax . ArrayPattern : for ( var n = 0 ; n < t . elements . length ; n ++ ) null != = t . elements [ n ] && this . checkPatternParam ( e , t . elements [ n ] ) ; break ; case u . Syntax . YieldExpression : break ; default : r . assert ( t . type == = u . Syntax . ObjectPattern , <string_literal> ) ; for ( var n = 0 ; n < t . properties . length ; n ++ ) this . checkPatternParam ( e , t . properties [ n ] . value ) } } , e . prototype . reinterpretAsCoverFormalsList = function ( e ) { var t , n = [ e ] ; switch ( e . type ) { case u . Syntax . Identifier : break ; case l : n = e . params ; break ; default : return null } t = { paramSet : { } } ; for ( var r = 0 ; r < n . length ; ++ r ) { var o = n [ r ] ; o . type == = u . Syntax . AssignmentPattern && o . right . type == = u . Syntax . YieldExpression && ( o . right . argument && this . throwUnexpectedToken ( this . lookahead ) , o . right . type = u . Syntax . Identifier , o . right . name = <string_literal> , delete o . right . argument , delete o . right . delegate ) , this . checkPatternParam ( t , o ) , n [ r ] = o } if ( this . context . strict || ! this . context . allowYield ) for ( var r = 0 ; r < n . length ; ++ r ) { var o = n [ r ] ; o . type == = u . Syntax . YieldExpression && this . throwUnexpectedToken ( this . lookahead ) } if ( t . message == = i . Messages . StrictParamDupe ) { var a = this . context . strict ? t . stricted : t . firstRestricted ; this . throwUnexpectedToken ( a , t . message ) } return { params : n , stricted : t . stricted , firstRestricted : t . firstRestricted , message : t . message } } , e . prototype . parseAssignmentExpression = function ( ) { var e ; if ( ! this . context . allowYield && this . matchKeyword ( <string_literal> ) ) e = this . parseYieldExpression ( ) ; else { var t = this . lookahead , n = t ; if ( e = this . parseConditionalExpression ( ) , e . type == = l || this . match ( <string_literal> ) ) { this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 ; var r = this . reinterpretAsCoverFormalsList ( e ) ; if ( r ) { this . hasLineTerminator && this . tolerateUnexpectedToken ( this . lookahead ) , this . context . firstCoverInitializedNameError = null ; var o = this . context . strict , a = this . context . allowYield ; this . context . allowYield = ! 0 ; var s = this . startNode ( t ) ; this . expect ( <string_literal> ) ; var p = this . match ( <string_literal> ) ? this . parseFunctionSourceElements ( ) : this . isolateCoverGrammar ( this . parseAssignmentExpression ) , f = p . type != = u . Syntax . BlockStatement ; this . context . strict && r . firstRestricted && this . throwUnexpectedToken ( r . firstRestricted , r . message ) , this . context . strict && r . stricted && this . tolerateUnexpectedToken ( r . stricted , r . message ) , e = this . finalize ( s , new c . ArrowFunctionExpression ( r . params , p , f ) ) , this . context . strict = o , this . context . allowYield = a } } else if ( this . matchAssign ( ) ) { if ( this . context . isAssignmentTarget || this . tolerateError ( i . Messages . InvalidLHSInAssignment ) , this . context . strict && e . type == = u . Syntax . Identifier ) { var h = e ; this . scanner . isRestrictedWord ( h . name ) && this . tolerateUnexpectedToken ( n , i . Messages . StrictLHSAssignment ) , this . scanner . isStrictModeReservedWord ( h . name ) && this . tolerateUnexpectedToken ( n , i . Messages . StrictReservedWord ) } this . match ( <string_literal> ) ? this . reinterpretExpressionAsPattern ( e ) : ( this . context . isAssignmentTarget = ! 1 , this . context . isBindingElement = ! 1 ) , n = this . nextToken ( ) ; var d = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; e = this . finalize ( this . startNode ( t ) , new c . AssignmentExpression ( n . value , e , d ) ) , this . context . firstCoverInitializedNameError = null } } return e } , e . prototype . parseExpression = function ( ) { var e = this . lookahead , t = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; if ( this . match ( <string_literal> ) ) { var n = [ ] ; for ( n . push ( t ) ; this . startMarker . index < this . scanner . length && this . match ( <string_literal> ) ; ) this . nextToken ( ) , n . push ( this . isolateCoverGrammar ( this . parseAssignmentExpression ) ) ; t = this . finalize ( this . startNode ( e ) , new c . SequenceExpression ( n ) ) } return t } , e . prototype . parseStatementListItem = function ( ) { var e = null ; if ( this . context . isAssignmentTarget = ! 0 , this . context . isBindingElement = ! 0 , this . lookahead . type == = a . Token . Keyword ) switch ( this . lookahead . value ) { case <string_literal> : <string_literal> != = this . sourceType && this . tolerateUnexpectedToken ( this . lookahead , i . Messages . IllegalExportDeclaration ) , e = this . parseExportDeclaration ( ) ; break ; case <string_literal> : <string_literal> != = this . sourceType && this . tolerateUnexpectedToken ( this . lookahead , i . Messages . IllegalImportDeclaration ) , e = this . parseImportDeclaration ( ) ; break ; case <string_literal> : e = this . parseLexicalDeclaration ( { inFor : ! 1 } ) ; break ; case <string_literal> : e = this . parseFunctionDeclaration ( ) ; break ; case <string_literal> : e = this . parseClassDeclaration ( ) ; break ; case <string_literal> : e = this . isLexicalDeclaration ( ) ? this . parseLexicalDeclaration ( { inFor : ! 1 } ) : this . parseStatement ( ) ; break ; default : e = this . parseStatement ( ) } else e = this . parseStatement ( ) ; return e } , e . prototype . parseBlock = function ( ) { var e = this . createNode ( ) ; this . expect ( <string_literal> ) ; for ( var t = [ ] ; ; ) { if ( this . match ( <string_literal> ) ) break ; t . push ( this . parseStatementListItem ( ) ) } return this . expect ( <string_literal> ) , this . finalize ( e , new c . BlockStatement ( t ) ) } , e . prototype . parseLexicalBinding = function ( e , t ) { var n = this . createNode ( ) , r = [ ] , o = this . parsePattern ( r , e ) ; this . context . strict && o . type == = u . Syntax . Identifier && this . scanner . isRestrictedWord ( o . name ) && this . tolerateError ( i . Messages . StrictVarName ) ; var a = null ; return <string_literal> == = e ? this . matchKeyword ( <string_literal> ) || this . matchContextualKeyword ( <string_literal> ) || ( this . expect ( <string_literal> ) , a = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ) : ( ! t . inFor && o . type != = u . Syntax . Identifier || this . match ( <string_literal> ) ) && ( this . expect ( <string_literal> ) , a = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ) , this . finalize ( n , new c . VariableDeclarator ( o , a ) ) } , e . prototype . parseBindingList = function ( e , t ) { for ( var n = [ this . parseLexicalBinding ( e , t ) ] ; this . match ( <string_literal> ) ; ) this . nextToken ( ) , n . push ( this . parseLexicalBinding ( e , t ) ) ; return n } , e . prototype . isLexicalDeclaration = function ( ) { var e = this . scanner . index , t = this . scanner . lineNumber , n = this . scanner . lineStart ; this . collectComments ( ) ; var r = this . scanner . lex ( ) ; return this . scanner . index = e , this . scanner . lineNumber = t , this . scanner . lineStart = n , r . type == = a . Token . Identifier || r . type == = a . Token . Punctuator && <string_literal> == = r . value || r . type == = a . Token . Punctuator && <string_literal> == = r . value || r . type == = a . Token . Keyword && <string_literal> == = r . value || r . type == = a . Token . Keyword && <string_literal> == = r . value } , e . prototype . parseLexicalDeclaration = function ( e ) { var t = this . createNode ( ) , n = this . nextToken ( ) . value ; r . assert ( <string_literal> == = n || <string_literal> == = n , <string_literal> ) ; var i = this . parseBindingList ( n , e ) ; return this . consumeSemicolon ( ) , this . finalize ( t , new c . VariableDeclaration ( i , n ) ) } , e . prototype . parseBindingRestElement = function ( e , t ) { var n = this . createNode ( ) ; this . expect ( <string_literal> ) ; var r = this . parsePattern ( e , t ) ; return this . finalize ( n , new c . RestElement ( r ) ) } , e . prototype . parseArrayPattern = function ( e , t ) { var n = this . createNode ( ) ; this . expect ( <string_literal> ) ; for ( var r = [ ] ; ! this . match ( <string_literal> ) ; ) if ( this . match ( <string_literal> ) ) this . nextToken ( ) , r . push ( null ) ; else { if ( this . match ( <string_literal> ) ) { r . push ( this . parseBindingRestElement ( e , t ) ) ; break } r . push ( this . parsePatternWithDefault ( e , t ) ) , this . match ( <string_literal> ) || this . expect ( <string_literal> ) } return this . expect ( <string_literal> ) , this . finalize ( n , new c . ArrayPattern ( r ) ) } , e . prototype . parsePropertyPattern = function ( e , t ) { var n , r , i = this . createNode ( ) , o = ! 1 , s = ! 1 , u = ! 1 ; if ( this . lookahead . type == = a . Token . Identifier ) { var l = this . lookahead ; n = this . parseVariableIdentifier ( ) ; var p = this . finalize ( i , new c . Identifier ( l . value ) ) ; if ( this . match ( <string_literal> ) ) { e . push ( l ) , s = ! 0 , this . nextToken ( ) ; var f = this . parseAssignmentExpression ( ) ; r = this . finalize ( this . startNode ( l ) , new c . AssignmentPattern ( p , f ) ) } else this . match ( <string_literal> ) ? ( this . expect ( <string_literal> ) , r = this . parsePatternWithDefault ( e , t ) ) : ( e . push ( l ) , s = ! 0 , r = p ) } else o = this . match ( <string_literal> ) , n = this . parseObjectPropertyKey ( ) , this . expect ( <string_literal> ) , r = this . parsePatternWithDefault ( e , t ) ; return this . finalize ( i , new c . Property ( <string_literal> , n , o , r , u , s ) ) } , e . prototype . parseObjectPattern = function ( e , t ) { var n = this . createNode ( ) , r = [ ] ; for ( this . expect ( <string_literal> ) ; ! this . match ( <string_literal> ) ; ) r . push ( this . parsePropertyPattern ( e , t ) ) , this . match ( <string_literal> ) || this . expect ( <string_literal> ) ; return this . expect ( <string_literal> ) , this . finalize ( n , new c . ObjectPattern ( r ) ) } , e . prototype . parsePattern = function ( e , t ) { var n ; return this . match ( <string_literal> ) ? n = this . parseArrayPattern ( e , t ) : this . match ( <string_literal> ) ? n = this . parseObjectPattern ( e , t ) : ( ! this . matchKeyword ( <string_literal> ) || <string_literal> != = t && <string_literal> != = t || this . tolerateUnexpectedToken ( this . lookahead , i . Messages . UnexpectedToken ) , e . push ( this . lookahead ) , n = this . parseVariableIdentifier ( t ) ) , n } , e . prototype . parsePatternWithDefault = function ( e , t ) { var n = this . lookahead , r = this . parsePattern ( e , t ) ; if ( this . match ( <string_literal> ) ) { this . nextToken ( ) ; var i = this . context . allowYield ; this . context . allowYield = ! 0 ; var o = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ; this . context . allowYield = i , r = this . finalize ( this . startNode ( n ) , new c . AssignmentPattern ( r , o ) ) } return r } , e . prototype . parseVariableIdentifier = function ( e ) { var t = this . createNode ( ) , n = this . nextToken ( ) ; return n . type == = a . Token . Keyword && <string_literal> == = n . value ? ( this . context . strict && this . tolerateUnexpectedToken ( n , i . Messages . StrictReservedWord ) , this . context . allowYield || this . throwUnexpectedToken ( n ) ) : n . type != = a . Token . Identifier ? this . context . strict && n . type == = a . Token . Keyword && this . scanner . isStrictModeReservedWord ( n . value ) ? this . tolerateUnexpectedToken ( n , i . Messages . StrictReservedWord ) : ( this . context . strict || <string_literal> != = n . value || <string_literal> != = e ) && this . throwUnexpectedToken ( n ) : <string_literal> == = this . sourceType && n . type == = a . Token . Identifier && <string_literal> == = n . value && this . tolerateUnexpectedToken ( n ) , this . finalize ( t , new c . Identifier ( n . value ) ) } , e . prototype . parseVariableDeclaration = function ( e ) { var t = this . createNode ( ) , n = [ ] , r = this . parsePattern ( n , <string_literal> ) ; this . context . strict && r . type == = u . Syntax . Identifier && this . scanner . isRestrictedWord ( r . name ) && this . tolerateError ( i . Messages . StrictVarName ) ; var o = null ; return this . match ( <string_literal> ) ? ( this . nextToken ( ) , o = this . isolateCoverGrammar ( this . parseAssignmentExpression ) ) : r . type == = u . Syntax . Identifier || e . inFor || this . expect ( <string_literal> ) , this . finalize ( t , new c . VariableDeclarator ( r , o ) ) } , e . prototype . parseVariableDeclarationList = function ( e ) { var t = { inFor : e . inFor } , n = [ ] ; for ( n . push ( this . parseVariableDeclaration ( t ) ) ; this . match ( <string_literal> ) ; ) this . nextToken ( ) , n . push ( this . parseVariableDeclaration ( t ) ) ; return n } , e . prototype . parseVariableStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) ; var t = this . parseVariableDeclarationList ( { inFor : ! 1 } ) ; return this . consumeSemicolon ( ) , \n \n this . finalize ( e , new c . VariableDeclaration ( t , <string_literal> ) ) } , e . prototype . parseEmptyStatement = function ( ) { var e = this . createNode ( ) ; return this . expect ( <string_literal> ) , this . finalize ( e , new c . EmptyStatement ) } , e . prototype . parseExpressionStatement = function ( ) { var e = this . createNode ( ) , t = this . parseExpression ( ) ; return this . consumeSemicolon ( ) , this . finalize ( e , new c . ExpressionStatement ( t ) ) } , e . prototype . parseIfStatement = function ( ) { var e , t = this . createNode ( ) , n = null ; this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) ; var r = this . parseExpression ( ) ; return ! this . match ( <string_literal> ) && this . config . tolerant ? ( this . tolerateUnexpectedToken ( this . nextToken ( ) ) , e = this . finalize ( this . createNode ( ) , new c . EmptyStatement ) ) : ( this . expect ( <string_literal> ) , e = this . parseStatement ( ) , this . matchKeyword ( <string_literal> ) && ( this . nextToken ( ) , n = this . parseStatement ( ) ) ) , this . finalize ( t , new c . IfStatement ( r , e , n ) ) } , e . prototype . parseDoWhileStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) ; var t = this . context . inIteration ; this . context . inIteration = ! 0 ; var n = this . parseStatement ( ) ; this . context . inIteration = t , this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) ; var r = this . parseExpression ( ) ; return this . expect ( <string_literal> ) , this . match ( <string_literal> ) && this . nextToken ( ) , this . finalize ( e , new c . DoWhileStatement ( n , r ) ) } , e . prototype . parseWhileStatement = function ( ) { var e , t = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) ; var n = this . parseExpression ( ) ; if ( ! this . match ( <string_literal> ) && this . config . tolerant ) this . tolerateUnexpectedToken ( this . nextToken ( ) ) , e = this . finalize ( this . createNode ( ) , new c . EmptyStatement ) ; else { this . expect ( <string_literal> ) ; var r = this . context . inIteration ; this . context . inIteration = ! 0 , e = this . parseStatement ( ) , this . context . inIteration = r } return this . finalize ( t , new c . WhileStatement ( n , e ) ) } , e . prototype . parseForStatement = function ( ) { var e , t , n = null , r = null , o = null , a = ! 0 , s = this . createNode ( ) ; if ( this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) , this . match ( <string_literal> ) ) this . nextToken ( ) ; else if ( this . matchKeyword ( <string_literal> ) ) { n = this . createNode ( ) , this . nextToken ( ) ; var l = this . context . allowIn ; this . context . allowIn = ! 1 ; var p = this . parseVariableDeclarationList ( { inFor : ! 0 } ) ; if ( this . context . allowIn = l , 1 == = p . length && this . matchKeyword ( <string_literal> ) ) { var f = p [ 0 ] ; f . init && ( f . id . type == = u . Syntax . ArrayPattern || f . id . type == = u . Syntax . ObjectPattern || this . context . strict ) && this . tolerateError ( i . Messages . ForInOfLoopInitializer , <string_literal> ) , n = this . finalize ( n , new c . VariableDeclaration ( p , <string_literal> ) ) , this . nextToken ( ) , e = n , t = this . parseExpression ( ) , n = null } else 1 == = p . length && null == = p [ 0 ] . init && this . matchContextualKeyword ( <string_literal> ) ? ( n = this . finalize ( n , new c . VariableDeclaration ( p , <string_literal> ) ) , this . nextToken ( ) , e = n , t = this . parseAssignmentExpression ( ) , n = null , a = ! 1 ) : ( n = this . finalize ( n , new c . VariableDeclaration ( p , <string_literal> ) ) , this . expect ( <string_literal> ) ) } else if ( this . matchKeyword ( <string_literal> ) || this . matchKeyword ( <string_literal> ) ) { n = this . createNode ( ) ; var h = this . nextToken ( ) . value ; if ( this . context . strict || <string_literal> != = this . lookahead . value ) { var l = this . context . allowIn ; this . context . allowIn = ! 1 ; var p = this . parseBindingList ( h , { inFor : ! 0 } ) ; this . context . allowIn = l , 1 == = p . length && null == = p [ 0 ] . init && this . matchKeyword ( <string_literal> ) ? ( n = this . finalize ( n , new c . VariableDeclaration ( p , h ) ) , this . nextToken ( ) , e = n , t = this . parseExpression ( ) , n = null ) : 1 == = p . length && null == = p [ 0 ] . init && this . matchContextualKeyword ( <string_literal> ) ? ( n = this . finalize ( n , new c . VariableDeclaration ( p , h ) ) , this . nextToken ( ) , e = n , t = this . parseAssignmentExpression ( ) , n = null , a = ! 1 ) : ( this . consumeSemicolon ( ) , n = this . finalize ( n , new c . VariableDeclaration ( p , h ) ) ) } else n = this . finalize ( n , new c . Identifier ( h ) ) , this . nextToken ( ) , e = n , t = this . parseExpression ( ) , n = null } else { var d = this . lookahead , l = this . context . allowIn ; if ( this . context . allowIn = ! 1 , n = this . inheritCoverGrammar ( this . parseAssignmentExpression ) , this . context . allowIn = l , this . matchKeyword ( <string_literal> ) ) this . context . isAssignmentTarget && n . type != = u . Syntax . AssignmentExpression || this . tolerateError ( i . Messages . InvalidLHSInForIn ) , this . nextToken ( ) , this . reinterpretExpressionAsPattern ( n ) , e = n , t = this . parseExpression ( ) , n = null ; else if ( this . matchContextualKeyword ( <string_literal> ) ) this . context . isAssignmentTarget && n . type != = u . Syntax . AssignmentExpression || this . tolerateError ( i . Messages . InvalidLHSInForLoop ) , this . nextToken ( ) , this . reinterpretExpressionAsPattern ( n ) , e = n , t = this . parseAssignmentExpression ( ) , n = null , a = ! 1 ; else { if ( this . match ( <string_literal> ) ) { for ( var m = [ n ] ; this . match ( <string_literal> ) ; ) this . nextToken ( ) , m . push ( this . isolateCoverGrammar ( this . parseAssignmentExpression ) ) ; n = this . finalize ( this . startNode ( d ) , new c . SequenceExpression ( m ) ) } this . expect ( <string_literal> ) } } <string_literal> == typeof e && ( this . match ( <string_literal> ) || ( r = this . parseExpression ( ) ) , this . expect ( <string_literal> ) , this . match ( <string_literal> ) || ( o = this . parseExpression ( ) ) ) ; var y ; if ( ! this . match ( <string_literal> ) && this . config . tolerant ) this . tolerateUnexpectedToken ( this . nextToken ( ) ) , y = this . finalize ( this . createNode ( ) , new c . EmptyStatement ) ; else { this . expect ( <string_literal> ) ; var v = this . context . inIteration ; this . context . inIteration = ! 0 , y = this . isolateCoverGrammar ( this . parseStatement ) , this . context . inIteration = v } return <string_literal> == typeof e ? this . finalize ( s , new c . ForStatement ( n , r , o , y ) ) : a ? this . finalize ( s , new c . ForInStatement ( e , t , y ) ) : this . finalize ( s , new c . ForOfStatement ( e , t , y ) ) } , e . prototype . parseContinueStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) ; var t = null ; if ( this . lookahead . type == = a . Token . Identifier && ! this . hasLineTerminator ) { t = this . parseVariableIdentifier ( ) ; var n = <string_literal> + t . name ; Object . prototype . hasOwnProperty . call ( this . context . labelSet , n ) || this . throwError ( i . Messages . UnknownLabel , t . name ) } return this . consumeSemicolon ( ) , null != = t || this . context . inIteration || this . throwError ( i . Messages . IllegalContinue ) , this . finalize ( e , new c . ContinueStatement ( t ) ) } , e . prototype . parseBreakStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) ; var t = null ; if ( this . lookahead . type == = a . Token . Identifier && ! this . hasLineTerminator ) { t = this . parseVariableIdentifier ( ) ; var n = <string_literal> + t . name ; Object . prototype . hasOwnProperty . call ( this . context . labelSet , n ) || this . throwError ( i . Messages . UnknownLabel , t . name ) } return this . consumeSemicolon ( ) , null != = t || this . context . inIteration || this . context . inSwitch || this . throwError ( i . Messages . IllegalBreak ) , this . finalize ( e , new c . BreakStatement ( t ) ) } , e . prototype . parseReturnStatement = function ( ) { this . context . inFunctionBody || this . tolerateError ( i . Messages . IllegalReturn ) ; var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) ; var t = ! this . match ( <string_literal> ) && ! this . match ( <string_literal> ) && ! this . hasLineTerminator && this . lookahead . type != = a . Token . EOF , n = t ? this . parseExpression ( ) : null ; return this . consumeSemicolon ( ) , this . finalize ( e , new c . ReturnStatement ( n ) ) } , e . prototype . parseWithStatement = function ( ) { this . context . strict && this . tolerateError ( i . Messages . StrictModeWith ) ; var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) ; var t = this . parseExpression ( ) ; this . expect ( <string_literal> ) ; var n = this . parseStatement ( ) ; return this . finalize ( e , new c . WithStatement ( t , n ) ) } , e . prototype . parseSwitchCase = function ( ) { var e , t = this . createNode ( ) ; this . matchKeyword ( <string_literal> ) ? ( this . nextToken ( ) , e = null ) : ( this . expectKeyword ( <string_literal> ) , e = this . parseExpression ( ) ) , this . expect ( <string_literal> ) ; for ( var n = [ ] ; ; ) { if ( this . match ( <string_literal> ) || this . matchKeyword ( <string_literal> ) || this . matchKeyword ( <string_literal> ) ) break ; n . push ( this . parseStatementListItem ( ) ) } return this . finalize ( t , new c . SwitchCase ( e , n ) ) } , e . prototype . parseSwitchStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) ; var t = this . parseExpression ( ) ; this . expect ( <string_literal> ) ; var n = this . context . inSwitch ; this . context . inSwitch = ! 0 ; var r = [ ] , o = ! 1 ; for ( this . expect ( <string_literal> ) ; ; ) { if ( this . match ( <string_literal> ) ) break ; var a = this . parseSwitchCase ( ) ; null == = a . test && ( o && this . throwError ( i . Messages . MultipleDefaultsInSwitch ) , o = ! 0 ) , r . push ( a ) } return this . expect ( <string_literal> ) , this . context . inSwitch = n , this . finalize ( e , new c . SwitchStatement ( t , r ) ) } , e . prototype . parseLabelledStatement = function ( ) { var e , t = this . createNode ( ) , n = this . parseExpression ( ) ; if ( n . type == = u . Syntax . Identifier && this . match ( <string_literal> ) ) { this . nextToken ( ) ; var r = n , o = <string_literal> + r . name ; Object . prototype . hasOwnProperty . call ( this . context . labelSet , o ) && this . throwError ( i . Messages . Redeclaration , <string_literal> , r . name ) , this . context . labelSet [ o ] = ! 0 ; var a = this . parseStatement ( ) ; delete this . context . labelSet [ o ] , e = new c . LabeledStatement ( r , a ) } else this . consumeSemicolon ( ) , e = new c . ExpressionStatement ( n ) ; return this . finalize ( t , e ) } , e . prototype . parseThrowStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) , this . hasLineTerminator && this . throwError ( i . Messages . NewlineAfterThrow ) ; var t = this . parseExpression ( ) ; return this . consumeSemicolon ( ) , this . finalize ( e , new c . ThrowStatement ( t ) ) } , e . prototype . parseCatchClause = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) , this . expect ( <string_literal> ) , this . match ( <string_literal> ) && this . throwUnexpectedToken ( this . lookahead ) ; for ( var t = [ ] , n = this . parsePattern ( t ) , r = { } , o = 0 ; o < t . length ; o ++ ) { var a = <string_literal> + t [ o ] . value ; Object . prototype . hasOwnProperty . call ( r , a ) && this . tolerateError ( i . Messages . DuplicateBinding , t [ o ] . value ) , r [ a ] = ! 0 } this . context . strict && n . type == = u . Syntax . Identifier && this . scanner . isRestrictedWord ( n . name ) && this . tolerateError ( i . Messages . StrictCatchVariable ) , this . expect ( <string_literal> ) ; var s = this . parseBlock ( ) ; return this . finalize ( e , new c . CatchClause ( n , s ) ) } , e . prototype . parseFinallyClause = function ( ) { return this . expectKeyword ( <string_literal> ) , this . parseBlock ( ) } , e . prototype . parseTryStatement = function ( ) { var e = this . createNode ( ) ; this . expectKeyword ( <string_literal> ) ; var t = this . parseBlock ( ) , n = this . matchKeyword ( <string_literal> ) ? this . parseCatchClause ( ) : null , r = this . matchKeyword ( <string_literal> ) ? this . parseFinallyClause ( ) : null ; return n || r || this . throwError ( i . Messages . NoCatchOrFinally ) , this . finalize ( e , new c . TryStatement ( t , n , r ) ) } , e . prototype . parseDebuggerStatement = function ( ) { var e = this . createNode ( ) ; return this . expectKeyword ( <string_literal> ) , this . consumeSemicolon ( ) , this . finalize ( e , new c . DebuggerStatement ) } , e . prototype . parseStatement = function ( ) { var e = null ; switch ( this . lookahead . type ) { case a . Token . BooleanLiteral : case a . Token . NullLiteral : case a . Token . NumericLiteral : case a . Token . StringLiteral : case a . Token . Template : case a . Token . RegularExpression : e = this . parseExpressionStatement ( ) ; break ; case a . Token . Punctuator : var t = this . lookahead . value ; e = <string_literal> == = t ? this . parseBlock ( ) : <string_literal> == = t ? this . parseExpressionStatement ( ) : <string_literal> == = t ? this . parseEmptyStatement ( ) : this . parseExpressionStatement ( ) ; break ; case a . Token . Identifier : e = this . parseLabelledStatement ( ) ; break ; case a . Token . Keyword : switch ( this . lookahead . value ) { case <string_literal> : e = this . parseBreakStatement ( ) ; break ; case <string_literal> : e = this . parseContinueStatement ( ) ; break ; case <string_literal> : e = this . parseDebuggerStatement ( ) ; break ; case <string_literal> : e = this . parseDoWhileStatement ( ) ; break ; case <string_literal> : e = this . parseForStatement ( ) ; break ; case <string_literal> : e = this . parseFunctionDeclaration ( ) ; break ; case <string_literal> : e = this . parseIfStatement ( ) ; break ; case <string_literal> : e = this . parseReturnStatement ( ) ; break ; case <string_literal> : e = this . parseSwitchStatement ( ) ; break ; case <string_literal> : e = this . parseThrowStatement ( ) ; break ; case <string_literal> : e = this . parseTryStatement ( ) ; break ; case <string_literal> : e = this . parseVariableStatement ( ) ; break ; case <string_literal> : e = this . parseWhileStatement ( ) ; break ; case <string_literal> : e = this . parseWithStatement ( ) ; break ; default : e = this . parseExpressionStatement ( ) } break ; default : this . throwUnexpectedToken ( this . lookahead ) } return e } , e . prototype . parseFunctionSourceElements = function ( ) { var e = this . createNode ( ) ; this . expect ( <string_literal> ) ; var t = this . parseDirectivePrologues ( ) , n = this . context . labelSet , r = this . context . inIteration , i = this . context . inSwitch , o = this . context . inFunctionBody ; for ( this . context . labelSet = { } , this . context . inIteration = ! 1 , this . context . inSwitch = ! 1 , this . context . inFunctionBody = ! 0 ; this . startMarker . index < this . scanner . length && ! this . match ( <string_literal> ) ; ) t . push ( this . parseStatementListItem ( ) ) ; return this . expect ( <string_literal> ) , this . context . labelSet = n , this . context . inIteration = r , this . context . inSwitch = i , this . context . inFunctionBody = o , this . finalize ( e , new c . BlockStatement ( t ) ) } , e . prototype . validateParam = function ( e , t , n ) { var r = <string_literal> + n ; this . context . strict ? ( this . scanner . isRestrictedWord ( n ) && ( e . stricted = t , e . message = i . Messages . StrictParamName ) , Object . prototype . hasOwnProperty . call ( e . paramSet , r ) && ( e . stricted = t , e . message = i . Messages . StrictParamDupe ) ) : e . firstRestricted || ( this . scanner . isRestrictedWord ( n ) ? ( e . firstRestricted = t , e . message = i . Messages . StrictParamName ) : this . scanner . isStrictModeReservedWord ( n ) ? ( e . firstRestricted = t , e . message = i . Messages . StrictReservedWord ) : Object . prototype . hasOwnProperty . call ( e . paramSet , r ) && ( e . stricted = t , e . message = i . Messages . StrictParamDupe ) ) , <string_literal> == typeof Object . defineProperty ? Object . defineProperty ( e . paramSet , r , { value : ! 0 , enumerable : ! 0 , writable : ! 0 , configurable : ! 0 } ) : e . paramSet [ r ] = ! 0 } , e . prototype . parseRestElement = function ( e ) { var t = this . createNode ( ) ; this . expect ( <string_literal> ) ; var n = this . parsePattern ( e ) ; return this . match ( <string_literal> ) && this . throwError ( i . Messages . DefaultRestParameter ) , this . match ( <string_literal> ) || this . throwError ( i . Messages . ParameterAfterRestParameter ) , this . finalize ( t , new c . RestElement ( n ) ) } , e . prototype . parseFormalParameter = function ( e ) { for ( var t = [ ] , n = this . match ( <string_literal> ) ? this . parseRestElement ( t ) : this . parsePatternWithDefault ( t ) , r = 0 ; r < t . length ; r ++ ) this . validateParam ( e , t [ r ] , t [ r ] . value ) ; return e . params . push ( n ) , ! this . match ( <string_literal> ) } , e . prototype . parseFormalParameters = function ( e ) { var t ; if ( t = { params : [ ] , firstRestricted : e } , this . expect ( <string_literal> || <string_literal> && <string_literal> use strict <string_literal> : <string_literal> . <string_literal> Identifier <string_literal> Text <string_literal> JSXIdentifier <string_literal> JSXText <string_literal> < <string_literal> } <string_literal> & <string_literal> ; <string_literal> # <string_literal> x <string_literal> 0 <string_literal> <string_literal> & <string_literal> . . . <string_literal> . <string_literal> <string_literal> { <string_literal> < <string_literal> \\ r <string_literal> \\ n <string_literal> : <string_literal> : <string_literal> . <string_literal> . <string_literal> . <string_literal> : <string_literal> : <string_literal> { <string_literal> } <string_literal> JSX attributes must only be assigned a non - empty expression <string_literal> { <string_literal> < <string_literal> = <string_literal> = <string_literal> { <string_literal> . . . <string_literal> / <string_literal> > <string_literal> { <string_literal> < <string_literal> / <string_literal> / <string_literal> > <string_literal> < <string_literal> / <string_literal> / <string_literal> > <string_literal> / <string_literal> / <string_literal> > <string_literal> { <string_literal> } <string_literal> } <string_literal> { <string_literal> Expected corresponding JSX closing tag for %0 <string_literal> use strict <string_literal> ' , amp : <string_literal> , apos : <string_literal> , gt : <string_literal> , nbsp : <string_literal> , iexcl : <string_literal> , cent : <string_literal> , pound : <string_literal> , curren : <string_literal> , yen : <string_literal> , brvbar : <string_literal> , sect : <string_literal> , uml : <string_literal> , copy : <string_literal> , ordf : <string_literal> , laquo : <string_literal> , not : <string_literal> , shy : <string_literal> , reg : <string_literal> , macr : <string_literal> , deg : <string_literal> , plusmn : <string_literal> , sup2 : <string_literal> , sup3 : <string_literal> , acute : <string_literal> , micro : <string_literal> , para : <string_literal> , middot : <string_literal> , cedil : <string_literal> , sup1 : <string_literal> , ordm : <string_literal> , raquo : <string_literal> , frac14 : <string_literal> , frac12 : <string_literal> , frac34 : <string_literal> , iquest : <string_literal> , Agrave : <string_literal> , Aacute : <string_literal> , Acirc : <string_literal> , Atilde : <string_literal> , Auml : <string_literal> , Aring : <string_literal> , AElig : <string_literal> , Ccedil : <string_literal> , Egrave : <string_literal> , Eacute : <string_literal> , Ecirc : <string_literal> , Euml : <string_literal> , Igrave : <string_literal> , Iacute : <string_literal> , Icirc : <string_literal> , Iuml : <string_literal> , ETH : <string_literal> , Ntilde : <string_literal> , Ograve : <string_literal> , Oacute : <string_literal> , Ocirc : <string_literal> , Otilde : <string_literal> , Ouml : <string_literal> , times : <string_literal> , Oslash : <string_literal> , Ugrave : <string_literal> , Uacute : <string_literal> , Ucirc : <string_literal> , Uuml : <string_literal> , Yacute : <string_literal> , THORN : <string_literal> , szlig : <string_literal> , agrave : <string_literal> , aacute : <string_literal> , acirc : <string_literal> , atilde : <string_literal> , auml : <string_literal> , aring : <string_literal> , aelig : <string_literal> , ccedil : <string_literal> , egrave : <string_literal> , eacute : <string_literal> , ecirc : <string_literal> , euml : <string_literal> , igrave : <string_literal> , iacute : <string_literal> , icirc : <string_literal> , iuml : <string_literal> , eth : <string_literal> , ntilde : <string_literal> , ograve : <string_literal> , oacute : <string_literal> , ocirc : <string_literal> , otilde : <string_literal> , ouml : <string_literal> , divide : <string_literal> , oslash : <string_literal> , ugrave : <string_literal> , uacute : <string_literal> , ucirc : <string_literal> , uuml : <string_literal> , yacute : <string_literal> , thorn : <string_literal> , yuml : <string_literal> , OElig : <string_literal> , oelig : <string_literal> , Scaron : <string_literal> , scaron : <string_literal> , Yuml : <string_literal> , fnof : <string_literal> , circ : <string_literal> , tilde : <string_literal> , Alpha : <string_literal> , Beta : <string_literal> , Gamma : <string_literal> , Delta : <string_literal> , Epsilon : <string_literal> , Zeta : <string_literal> , Eta : <string_literal> , Theta : <string_literal> , Iota : <string_literal> , Kappa : <string_literal> , Lambda : <string_literal> , Mu : <string_literal> , Nu : <string_literal> , Xi : <string_literal> , Omicron : <string_literal> , Pi : <string_literal> , Rho : <string_literal> , Sigma : <string_literal> , Tau : <string_literal> , Upsilon : <string_literal> , Phi : <string_literal> , Chi : <string_literal> , Psi : <string_literal> , Omega : <string_literal> , alpha : <string_literal> , beta : <string_literal> , gamma : <string_literal> , delta : <string_literal> , epsilon : <string_literal> , zeta : <string_literal> , eta : <string_literal> , theta : <string_literal> , iota : <string_literal> , kappa : <string_literal> , lambda : <string_literal> , mu : <string_literal> , nu : <string_literal> , xi : <string_literal> , omicron : <string_literal> , pi : <string_literal> , rho : <string_literal> , sigmaf : <string_literal> , sigma : <string_literal> , tau : <string_literal> , upsilon : <string_literal> , phi : <string_literal> , chi : <string_literal> , psi : <string_literal> , omega : <string_literal> , thetasym : <string_literal> , upsih : <string_literal> , piv : <string_literal> , ensp : <string_literal> , emsp : <string_literal> , thinsp : <string_literal> , zwnj : <string_literal> , zwj : <string_literal> , lrm : <string_literal> , rlm : <string_literal> , ndash : <string_literal> , mdash : <string_literal> , lsquo : <string_literal> , rsquo : <string_literal> , sbquo : <string_literal> , ldquo : <string_literal> , rdquo : <string_literal> , bdquo : <string_literal> , dagger : <string_literal> , Dagger : <string_literal> , bull : <string_literal> , hellip : <string_literal> , permil : <string_literal> , prime : <string_literal> , Prime : <string_literal> , lsaquo : <string_literal> , rsaquo : <string_literal> , oline : <string_literal> , frasl : <string_literal> , euro : <string_literal> , image : <string_literal> , weierp : <string_literal> , real : <string_literal> , trade : <string_literal> , alefsym : <string_literal> , larr : <string_literal> , uarr : <string_literal> , rarr : <string_literal> , darr : <string_literal> , harr : <string_literal> , crarr : <string_literal> , lArr : <string_literal> , uArr : <string_literal> , rArr : <string_literal> , dArr : <string_literal> , hArr : <string_literal> , forall : <string_literal> , part : <string_literal> , exist : <string_literal> , empty : <string_literal> , nabla : <string_literal> , isin : <string_literal> , notin : <string_literal> , ni : <string_literal> , prod : <string_literal> , sum : <string_literal> , minus : <string_literal> , lowast : <string_literal> , radic : <string_literal> , prop : <string_literal> , infin : <string_literal> , ang : <string_literal> , and : <string_literal> , or : <string_literal> , cap : <string_literal> , cup : <string_literal> , int : <string_literal> , there4 : <string_literal> , sim : <string_literal> , cong : <string_literal> , asymp : <string_literal> , ne : <string_literal> , equiv : <string_literal> , le : <string_literal> , ge : <string_literal> , sub : <string_literal> , sup : <string_literal> , nsub : <string_literal> , sube : <string_literal> , supe : <string_literal> , oplus : <string_literal> , otimes : <string_literal> , perp : <string_literal> , sdot : <string_literal> , lceil : <string_literal> , rceil : <string_literal> , lfloor : <string_literal> , rfloor : <string_literal> , loz : <string_literal> , spades : <string_literal> , clubs : <string_literal> , hearts : <string_literal> , diams : <string_literal> , lang : <string_literal> , rang : <string_literal> } } , function ( e , t ) { <string_literal> ; t . JSXSyntax = { JSXAttribute : <string_literal> , JSXClosingElement : <string_literal> , JSXElement : <string_literal> , JSXEmptyExpression : <string_literal> , JSXExpressionContainer : <string_literal> , JSXIdentifier : <string_literal> , JSXMemberExpression : <string_literal> , JSXNamespacedName : <string_literal> , JSXOpeningElement : <string_literal> , JSXSpreadAttribute : <string_literal> , JSXText : <string_literal> } } , function ( e , t , n ) { <string_literal> ; var r = n ( <number_literal> ) , i = function ( ) { function e ( e ) { this . type = r . JSXSyntax . JSXClosingElement , this . name = e } return e } ( ) ; t . JSXClosingElement = i ; var o = function ( ) { function e ( e , t , n ) { this . type = r . JSXSyntax . JSXElement , this . openingElement = e , this . children = t , this . closingElement = n } return e } ( ) ; t . JSXElement = o ; var a = function ( ) { function e ( ) { this . type = r . JSXSyntax . JSXEmptyExpression } return e } ( ) ; t . JSXEmptyExpression = a ; var s = function ( ) { function e ( e ) { this . type = r . JSXSyntax . JSXExpressionContainer , this . expression = e } return e } ( ) ; t . JSXExpressionContainer = s ; var u = function ( ) { function e ( e ) { this . type = r . JSXSyntax . JSXIdentifier , this . name = e } return e } ( ) ; t . JSXIdentifier = u ; var c = function ( ) { function e ( e , t ) { this . type = r . JSXSyntax . JSXMemberExpression , this . object = e , this . property = t } return e } ( ) ; t . JSXMemberExpression = c ; var l = function ( ) { function e ( e , t ) { this . type = r . JSXSyntax . JSXAttribute , this . name = e , this . value = t } return e } ( ) ; t . JSXAttribute = l ; var p = function ( ) { function e ( e , t ) { this . type = r . JSXSyntax . JSXNamespacedName , this . namespace = e , this . name = t } return e } ( ) ; t . JSXNamespacedName = p ; var f = function ( ) { function e ( e , t , n ) { this . type = r . JSXSyntax . JSXOpeningElement , this . name = e , this . selfClosing = t , this . attributes = n } return e } ( ) ; t . JSXOpeningElement = f ; var h = function ( ) { function e ( e ) { this . type = r . JSXSyntax . JSXSpreadAttribute , this . argument = e } return e } ( ) ; t . JSXSpreadAttribute = h ; var d = function ( ) { function e ( e , t ) { this . type = r . JSXSyntax . JSXText , this . value = e , this . raw = t } return e } ( ) ; t . JSXText = d } , function ( e , t , n ) { <string_literal> ; var r = n ( <number_literal> ) , i = n ( <number_literal> ) , o = n ( <number_literal> ) , a = function ( ) { function e ( ) { this . values = [ ] , this . curly = this . paren = - 1 } return e . prototype . beforeFunctionExpression = function ( e ) { return [ <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> ] . indexOf ( e ) >= 0 } , e . prototype . isRegexStart = function ( ) { var e = this . values [ this . values . length - 1 ] , t = null != = e ; switch ( e ) { case <string_literal> : case <string_literal> : t = ! 1 ; break ; case <string_literal> : var n = this . values [ this . paren - 1 ] ; t = <string_literal> == = n || <string_literal> == = n || <string_literal> == = n || <string_literal> == = n ; break ; case <string_literal> : if ( t = ! 1 , <string_literal> == = this . values [ this . curly - <number_literal> ] ) { var r = this . values [ this . curly - <number_literal> ] ; t = ! ! r && ! this . beforeFunctionExpression ( r ) } else if ( <string_literal> == = this . values [ this . curly - <number_literal> ] ) { var i = this . values [ this . curly - <number_literal> ] ; t = ! i || ! this . beforeFunctionExpression ( i ) } } return t } , e . prototype . push = function ( e ) { e . type == = o . Token . Punctuator || e . type == = o . Token . Keyword ? ( <string_literal> == = e . value ? this . curly = this . values . length : <string_literal> == = e . value && ( this . paren = this . values . length ) , this . values . push ( e . value ) ) : this . values . push ( null ) } , e } ( ) , s = function ( ) { function e ( e , t ) { this . errorHandler = new i . ErrorHandler , this . errorHandler . tolerant = ! ! t && ( <string_literal> == typeof t . tolerant && t . tolerant ) , this . scanner = new r . Scanner ( e , this . errorHandler ) , this . scanner . trackComment = ! ! t && ( <string_literal> == typeof t . comment && t . comment ) , this . trackRange = ! ! t && ( <string_literal> == typeof t . range && t . range ) , this . trackLoc = ! ! t && ( <string_literal> == typeof t . loc && t . loc ) , this . buffer = [ ] , this . reader = new a } return e . prototype . errors = function ( ) { return this . errorHandler . errors } , e . prototype . getNextToken = function ( ) { if ( 0 == = this . buffer . length ) { var e = this . scanner . scanComments ( ) ; if ( this . scanner . trackComment ) for ( var t = 0 ; t < e . length ; ++ t ) { var n = e [ t ] , r = void 0 , i = this . scanner . source . slice ( n . slice [ 0 ] , n . slice [ 1 ] ) ; r = { type : n . multiLine ? <string_literal> : <string_literal> , value : i } , this . trackRange && ( r . range = n . range ) , this . trackLoc && ( r . loc = n . loc ) , this . buffer . push ( r ) } if ( ! this . scanner . eof ( ) ) { var a = void 0 ; this . trackLoc && ( a = { start : { line : this . scanner . lineNumber , column : this . scanner . index - this . scanner . lineStart } , end : { } } ) ; var s = void 0 ; s = <string_literal> == = this . scanner . source [ this . scanner . index ] ? this . reader . isRegexStart ( ) ? this . scanner . scanRegExp ( ) : this . scanner . scanPunctuator ( ) : this . scanner . lex ( ) , this . reader . push ( s ) ; var u = void 0 ; u = { type : o . TokenName [ s . type ] , value : this . scanner . source . slice ( s . start , s . end ) } , this . trackRange && ( u . range = [ s . start , s . end ] ) , this . trackLoc && ( a . end = { line : this . scanner . lineNumber , column : this . scanner . index - this . scanner . lineStart } , u . loc = a ) , s . regex && ( u . regex = s . regex ) , this . buffer . push ( u ) } } return this . buffer . shift ( ) } , e } ( ) ; t . Tokenizer = s } ] ) } ) } , [ <number_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> ] , function ( e , t , n ) { <string_literal> ; function r ( e ) { if ( Array . isArray ( e ) ) { for ( var t = 0 , n = Array ( e . length ) ; t < e . length ; t ++ ) n [ t ] = e [ t ] ; return n } return Array . from ( e ) } function i ( e , t , n ) { var i = g ( e ) . getIn ( [ <string_literal> ] . concat ( r ( t ) , [ <string_literal> ] ) , ( 0 , f . fromJS ) ( [ ] ) ) ; return i . filter ( function ( e ) { return f . Map . isMap ( e ) && e . get ( <string_literal> ) == = n } ) . first ( ) } function o ( e , t , n ) { var i = g ( e ) . getIn ( [ <string_literal> ] . concat ( r ( t ) , [ <string_literal> ] ) , ( 0 , f . fromJS ) ( [ ] ) ) ; return i . reduce ( function ( e , t ) { var r = n && <string_literal> == = t . get ( <string_literal> ) ? t . get ( <string_literal> ) : t . get ( <string_literal> ) ; return e . set ( t . get ( <string_literal> ) , r ) } , ( 0 , f . fromJS ) ( { } ) ) } function a ( e ) { var t = arguments . length > 1 && void 0 != = arguments [ 1 ] ? arguments [ 1 ] : <string_literal> ; if ( f . List . isList ( e ) ) return e . some ( function ( e ) { return f . Map . isMap ( e ) && e . get ( <string_literal> ) == = t } ) } function s ( e ) { var t = arguments . length > 1 && void 0 != = arguments [ 1 ] ? arguments [ 1 ] : <string_literal> ; if ( f . List . isList ( e ) ) return e . some ( function ( e ) { return f . Map . isMap ( e ) && e . get ( <string_literal> ) == = t } ) } function u ( e , t ) { var n = g ( e ) . getIn ( [ <string_literal> ] . concat ( r ( t ) ) , ( 0 , f . fromJS ) ( { } ) ) , i = n . get ( <string_literal> ) || new f . List , o = s ( i , <string_literal> ) ? <string_literal> : a ( i , <string_literal> ) ? <string_literal> : n . get ( <string_literal> ) ; return ( 0 , f . fromJS ) ( { requestContentType : o , responseContentType : n . get ( <string_literal> ) } ) } function c ( e , t ) { return g ( e ) . getIn ( [ <string_literal> ] . concat ( r ( t ) , [ <string_literal> ] ) , ( 0 , f . fromJS ) ( { } ) ) } function l ( e ) { return f . Map . isMap ( e ) ? e : new f . Map } Object . defineProperty ( t , <string_literal> , { value : ! 0 } ) , t . validateBeforeExecute = t . canExecuteScheme = t . operationScheme = t . hasHost = t . allowTryItOutFor = t . requestFor = t . responseFor = t . requests = t . responses = t . taggedOperations = t . operationsWithTags = t . tagDetails = t . tags = t . operationsWithRootInherited = t . schemes = t . host = t . basePath = t . definitions = t . findDefinition = t . securityDefinitions = t . security = t . produces = t . consumes = t . operations = t . paths = t . semver = t . version = t . externalDocs = t . info = t . spec = t . specResolved = t . specJson = t . specSource = t . specStr = t . url = t . lastError = void 0 , t . getParameter = i , t . parameterValues = o , t . parametersIncludeIn = a , t . parametersIncludeType = s , t . contentTypeValues = u , t . operationConsumes = c ; var p = n ( <number_literal> ) , f = n ( <number_literal> ) , h = <string_literal> , d = [ <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> ] , m = function ( e ) { return e || ( 0 , f . Map ) ( ) } , y = ( t . lastError = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> ) } ) , t . url = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> ) } ) , t . specStr = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> ) || <string_literal> } ) , t . specSource = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> ) || <string_literal> } ) , t . specJson = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> , ( 0 , f . Map ) ( ) ) } ) ) , v = t . specResolved = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> , ( 0 , f . Map ) ( ) ) } ) , g = t . spec = function ( e ) { var t = v ( e ) ; return t . count ( ) < 1 && ( t = y ( e ) ) , t } , _ = t . info = ( 0 , p . createSelector ) ( g , function ( e ) { return l ( e && e . get ( <string_literal> ) ) } ) , b = ( t . externalDocs = ( 0 , p . createSelector ) ( g , function ( e ) { return l ( e && e . get ( <string_literal> ) ) } ) , t . version = ( 0 , p . createSelector ) ( _ , function ( e ) { return e && e . get ( <string_literal> ) } ) ) , x = ( t . semver = ( 0 , p . createSelector ) ( b , function ( e ) { return / v ? ( [ 0 - <number_literal> ] * ) \\ . ( [ 0 - <number_literal> ] * ) \\ . ( [ 0 - <number_literal> ] * ) / i . exec ( e ) . slice ( 1 ) } ) , t . paths = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> ) } ) ) , w = t . operations = ( 0 , p . createSelector ) ( x , function ( e ) { if ( ! e || e . size < 1 ) return ( 0 , f . List ) ( ) ; var t = ( 0 , f . List ) ( ) ; return e && e . forEach ? ( e . forEach ( function ( e , n ) { return e && e . forEach ? void e . forEach ( function ( e , r ) { d . indexOf ( r ) != = - 1 && ( t = t . push ( ( 0 , f . fromJS ) ( { path : n , method : r , operation : e , id : r + <string_literal> + n } ) ) ) } ) : { } } ) , t ) : ( 0 , f . List ) ( ) } ) , k = t . consumes = ( 0 , p . createSelector ) ( g , function ( e ) { return ( 0 , f . Set ) ( e . get ( <string_literal> ) ) } ) , S = t . produces = ( 0 , p . createSelector ) ( g , function ( e ) { return ( 0 , f . Set ) ( e . get ( <string_literal> ) ) } ) , E = ( t . security = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> , ( 0 , f . List ) ( ) ) } ) , t . securityDefinitions = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> ) } ) , t . findDefinition = function ( e , t ) { return v ( e ) . getIn ( [ <string_literal> , t ] , null ) } , t . definitions = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> ) || ( 0 , f . Map ) ( ) } ) , t . basePath = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> ) } ) , t . host = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> ) } ) , t . schemes = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> , ( 0 , f . Map ) ( ) ) } ) , t . operationsWithRootInherited = ( 0 , p . createSelector ) ( w , k , S , function ( e , t , n ) { return e . map ( function ( e ) { return e . update ( <string_literal> , function ( e ) { if ( e ) { if ( ! f . Map . isMap ( e ) ) return ; return e . withMutations ( function ( e ) { return e . get ( <string_literal> ) || e . update ( <string_literal> , function ( e ) { return ( 0 , f . Set ) ( e ) . merge ( t ) } ) , e . get ( <string_literal> ) || e . update ( <string_literal> , function ( e ) { return ( 0 , f . Set ) ( e ) . merge ( n ) } ) , e } ) } return ( 0 , f . Map ) ( ) } ) } ) } ) ) , C = t . tags = ( 0 , p . createSelector ) ( g , function ( e ) { return e . get ( <string_literal> , ( 0 , f . List ) ( ) ) } ) , A = t . tagDetails = function ( e , t ) { var n = C ( e ) || ( 0 , f . List ) ( ) ; return n . filter ( f . Map . isMap ) . find ( function ( e ) { return e . get ( <string_literal> ) == = t } , ( 0 , f . Map ) ( ) ) } , O = t . operationsWithTags = ( 0 , p . createSelector ) ( E , function ( e ) { return e . reduce ( function ( e , t ) { var n = ( 0 , f . Set ) ( t . getIn ( [ <string_literal> , <string_literal> ] ) ) ; return n . count ( ) < 1 ? e . update ( h , ( 0 , f . List ) ( ) , function ( e ) { return e . push ( t ) } ) : n . reduce ( function ( e , n ) { return e . update ( n , ( 0 , f . List ) ( ) , function ( e ) { return e . push ( t ) } ) } , e ) } , ( 0 , f . Map ) ( ) ) } ) , T = ( t . taggedOperations = ( 0 , p . createSelector ) ( m , O , function ( e , t ) { return t . map ( function ( t , n ) { return ( 0 , f . Map ) ( { tagDetails : A ( e , n ) , operations : t } ) } ) } ) , t . responses = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> , ( 0 , f . Map ) ( ) ) } ) ) , M = t . requests = ( 0 , p . createSelector ) ( m , function ( e ) { return e . get ( <string_literal> , ( 0 , f . Map ) ( ) ) } ) , D = ( t . responseFor = function ( e , t , n ) { return T ( e ) . getIn ( [ t , n ] , null ) } , t . requestFor = function ( e , t , n ) { return M ( e ) . getIn ( [ t , n ] , null ) } , t . allowTryItOutFor = function ( ) { return ! 0 } , t . hasHost = ( 0 , p . createSelector ) ( g , function ( e ) { var t = e . get ( <string_literal> ) ; return <string_literal> == typeof t && t . length > 0 && <string_literal> != = t [ 0 ] } ) , t . operationScheme = function ( e , t , n ) { return e . getIn ( [ <string_literal> , t , n ] ) || e . getIn ( [ <string_literal> , <string_literal> ] ) || <string_literal> } ) ; t . canExecuteScheme = function ( e , t , n ) { return [ <string_literal> , <string_literal> ] . indexOf ( D ( e , t , n ) ) > - 1 } , t . validateBeforeExecute = function ( e , t ) { var n = g ( e ) . getIn ( [ <string_literal> ] . concat ( r ( t ) , [ <string_literal> ] ) , ( 0 , f . fromJS ) ( [ ] ) ) , i = ! 0 ; return n . forEach ( function ( e ) { var t = e . get ( <string_literal> ) ; t && t . count ( ) && ( i = ! 1 ) } ) , i } } , function ( e , t ) { <string_literal> ; Object . defineProperty ( t , <string_literal> , { value : ! 0 } ) ; t . updateSpec = function ( e , t ) { var n = t . specActions ; return function ( ) { e . apply ( void 0 , arguments ) , n . parseToJson . apply ( n , arguments ) } } , t . updateJsonSpec = function ( e , t ) { var n = t . specActions ; return function ( ) { e . apply ( void 0 , arguments ) , n . resolveSpec . apply ( n , arguments ) } } , t . executeRequest = function ( e , t ) { var n = t . specActions ; return function ( t ) { return n . logRequest ( t ) , e ( t ) } } } , function ( e , t , n ) { <string_literal> ; function r ( e ) { if ( e && e . __esModule ) return e ; var t = { } ; if ( null != e ) for ( var n in e ) Object . prototype . hasOwnProperty . call ( e , n ) && ( t [ n ] = e [ n ] ) ; return t . default = e , t } Object . defineProperty ( t , <string_literal> , { value : ! 0 } ) , t . default = function ( e ) { var t = e . getComponents , n = e . getStore , r = e . getSystem , i = o . getComponent , s = o . render , u = o . makeMappedContainer , c = ( 0 , a . memoize ) ( i . bind ( null , r , n , t ) ) , l = ( 0 , a . memoize ) ( u . bind ( null , r , n , c , t ) ) ; return { rootInjects : { getComponent : c , makeMappedContainer : l , render : s . bind ( null , r , n , i , t ) } } } ; var i = n ( <number_literal> ) , o = r ( i ) , a = n ( <number_literal> ) } , function ( e , t , n ) { <string_literal> ; \n \n <ect>
\t3 } else { \n \n \t4 break ; <comment> \n \n \t2 <comment> \n \n \t2 if ( getSystemAvailMB ( ) < alertMB ) { \n \n <ect>
\t3 logger . info ( <string_literal> + vlcVersion + <string_literal> + vlcPath ) ; \n \n \t3 Version vlc = new Version ( vlcVersion ) ; \n \n \t3 Version requiredVersion = new Version ( <string_literal> ) ; \n \n \t3 if ( vlc . compareTo ( requiredVersion ) < = 0 ) { \n \n <ect>
\t5 + <string_literal> + present + <string_literal> + allowed ; \n \n \t3 if ( allowed ) { \n \n \t4 logger . info ( <string_literal> + status ) ; \n \n \t3 } else { \n \n <ect>
\t3 Log . warn ( GraphContainerUtils . class , <string_literal> ) ; \n \n \t3 return 0 ; } \n \n \t2 if ( member == null ) \n \n \t2 { \n \n <ect>
\t3 if ( conn != null && conn . getClient ( ) != null ) { \n \n \t4 try { \n \n \t5 conn . getClient ( ) . set_keyspace ( SYSTEM_KS ) ; \n \n \t4 } catch ( InvalidRequestException e ) { \n \n <ect>
\t5 context . jobRunner . newSalt ( ) , salter , resumed , \n \n \t5 callbackCompleteViaTruncation != null ) ; \n \n \t2 } catch ( ResumeFailedException e ) { \n \n \t3 raf . free ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 computeMaxEntriesHashAggr ( ) ; } \n \n \t1 memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; \n \n \t1 maxMemory = isTez ? getConf ( ) . getMaxMemoryAvailable ( ) : memoryMXBean . getHeapMemoryUsage ( ) . getMax ( ) ; \n \n \t1 memoryThreshold = this . getConf ( ) . getMemoryThreshold ( ) ; \n \n <ect>
\t2 cacheAccess . clear ( ) ; } \n \n \t1 @ Override \n \n \t1 public void evictQueryRegions ( ) { \n \n <ect>
\t3 <comment> \n \n \t3 pn . jfkNoncesSent . clear ( ) ; } \n \n \t2 final long t2 = System . currentTimeMillis ( ) ; \n \n \t2 if ( ( t2 - t1 ) > <number_literal> ) \n \n <ect>
\t2 @ Override \n \n \t2 public void initState ( Object state ) { \n \n \t3 if ( state != null ) { \n \n \t4 index = ( Integer ) state ; } \n \n <ect>
\t7 ( ( CONSTANT_InterfaceMethodref_info ) c ) . name_and_type_index ) ; \n \n \t1 if ( c instanceof CONSTANT_Fieldref_info ) \n \n \t2 return getTypeDescr ( constant_pool , \n \n \t7 ( ( CONSTANT_Fieldref_info ) c ) . name_and_type_index ) ; \n \n <ect>
\t5 break ; } \n \n \t4 <comment> \n \n \t4 possibleModuleParentFolder = possibleModuleParentFolder . getParent ( ) ; } \n \n \t2 } catch ( ParserConfigurationException | SAXException | IOException | XPathExpressionException | FrameworkException ex ) { \n \n <ect>
\t3 synchronized ( s_features ) { \n \n \t4 for ( FeatureTemplate f : features ) { \n \n \t5 s_features . put ( f . getName ( ) , f ) ; } } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t9 if ( ! theSocketChannel . isConnectionPending ( ) ) { \n \n \t10 error = true ; } \n \n \t8 } catch ( ClosedChannelException e ) { \n \n \t9 <comment> \n \n <ect>
\t1 { \n \n \t2 String optionValue = options . get ( TIMESTAMP_RESOLUTION_KEY ) ; \n \n \t2 timestampResolution = optionValue == null ? DEFAULT_TIMESTAMP_RESOLUTION : TimeUnit . valueOf ( optionValue ) ; \n \n \t2 if ( timestampResolution != DEFAULT_TIMESTAMP_RESOLUTION ) \n \n <ect>
\t1 public final void clean ( ) { \n \n \t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 SpringBeanAutowiringSupport . processInjectionBasedOnCurrentContext ( this ) ; \n \n \t2 cleanInternal ( ) ; \n \n <ect>
\t1 } else { \n \n \t1 String errMsg = <string_literal> ; \n \n \t1 LOG . error ( errMsg ) ; \n \n \t1 throw new EucalyptusCloudException ( errMsg ) ; } \n \n <ect>
\t3 <comment> \n \n \t3 currentKeys . clear ( ) ; \n \n \t3 currentKeys . putAll ( publicKeys ) ; \n \n \t2 } catch ( HttpClientAdapterException e ) { \n \n <ect>
\t6 case RequestSender . TIMED_OUT : \n \n \t7 throw new LowLevelGetException ( LowLevelGetException . REJECTED_OVERLOAD ) ; \n \n \t6 case RequestSender . INTERNAL_ERROR : \n \n \t6 default : \n \n <ect>
\t3 try { \n \n \t4 channel . sendResponse ( e ) ; \n \n \t3 } catch ( IOException inner ) { \n \n \t4 inner . addSuppressed ( e ) ; \n \n <ect>
\t2 if ( ! ( taskRoot . isDirectory ( ) && taskRoot . exists ( ) ) ) { \n \n \t3 return false ; } \n \n \t2 Integer taskID = LessNumbers . parseInt ( <number_literal> , taskRoot . getName ( ) , - 1 ) ; \n \n \t2 if ( taskID < 0 ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 newNetworkOfferingId = newNetworkOfferingMap . get ( networkOfferingId ) ; \n \n \t5 pstmt . setLong ( 1 , newNetworkOfferingId ) ; \n \n \t5 pstmt . setLong ( <number_literal> , networkId ) ; \n \n \t5 pstmt . executeUpdate ( ) ; } \n \n <ect>
\t1 for ( BootstrapExecution execution : bootstrap ) { \n \n \t2 execution . execute ( context ) ; } \n \n \t1 context . executeDeferred ( ) ; \n \n \t1 ( ( ErraiServiceConfiguratorImpl ) context . getConfig ( ) ) . lockdown ( ) ; \n \n <ect>
<comment> \n \n \t1 private static void obtainTokenForHBase ( Credentials credentials , Configuration conf ) throws IOException { \n \n \t2 if ( UserGroupInformation . isSecurityEnabled ( ) ) { \n \n <ect>
\t2 try { \n \n \t3 return getWebMonitorBaseUrl ( ) . get ( ) . toString ( ) ; \n \n \t2 } catch ( InterruptedException | ExecutionException e ) { \n \n \t3 ExceptionUtils . checkInterrupted ( e ) ; \n \n <ect>
\t2 ticketMap . set ( encTicket . getId ( ) , encTicket , ttl , TimeUnit . SECONDS ) ; \n \n \t2 LOGGER . debug ( <string_literal> , encTicket . getId ( ) , ttl ) ; } \n \n \t1 private IMap < String , Ticket > getTicketMapInstanceByMetadata ( final TicketDefinition metadata ) { \n \n \t2 final String mapName = metadata . getProperties ( ) . getStorageName ( ) ; \n \n <ect>
\t4 this . client . onUpdate ( newConfig ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 return InetAddress . getByName ( host ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t1 if ( e instanceof InterruptedIOException || e instanceof InterruptedException ) { \n \n \t2 Thread . currentThread ( ) . interrupt ( ) ; } \n \n <ect>
\t2 return false ; } \n \n \t1 @ Override \n \n \t1 public AgentControlAnswer processControlCommand ( long agentId , \n \n \t3 AgentControlCommand cmd ) { \n \n <ect>
\t5 createIndexRequest . settings ( settings . get ( index ) ) ; \n \n \t5 logger . info ( <string_literal> , index , types ) ; \n \n \t5 Map < String , String > mappings = getMapping ( client , index , \n \n \t7 types != null ? new HashSet < > ( types ) : null ) ; \n \n <ect>
\t2 if ( this . removeOnCancelPolicy ) { \n \n \t3 if ( this . scheduledExecutor instanceof ScheduledThreadPoolExecutor ) { \n \n \t4 ( ( ScheduledThreadPoolExecutor ) this . scheduledExecutor ) . setRemoveOnCancelPolicy ( true ) ; } \n \n \t3 else { \n \n <ect>
\t1 private final MessageLister eventLister = new MessageLister ( ) ; \n \n \t1 public RFXComBinding ( ) { } \n \n \t1 @ Override \n \n \t1 public void activate ( ) { \n \n <ect>
\t1 LOG . info ( <string_literal> + m ) ; } \n \n \t1 for ( ITestNGMethod m : m_beforeTestMethods ) { \n \n \t1 LOG . info ( <string_literal> + m ) ; } \n \n \t1 for ( ITestNGMethod m : m_testMethods ) { \n \n <ect>
synchronized void setMasterState ( MasterState newState ) { \n \n \t1 if ( state . equals ( newState ) ) \n \n \t1 return ; \n \n \t1 if ( ! transitionOK [ state . ordinal ( ) ] [ newState . ordinal ( ) ] ) { \n \n <ect>
\t2 try { \n \n \t3 zkCluster . disconnect ( ) ; \n \n \t3 cluster_state . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 refresh ( ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 50L ) ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 50L ) ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 50L ) ) ; \n \n <ect>
\t3 val sessionFiles = sessionsDir . listFiles ( ) \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( sessionFiles . size > 1 ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , type . getName ( ) , serializer . getClass ( ) . getName ( ) ) ; \n \n \t2 return super . register ( type , serializer ) ; } \n \n \t1 @ Override \n \n \t1 public Registration register ( final Registration registration ) { \n \n <ect>
\t1 @ Override \n \n \t1 public synchronized void parse ( InputStream stream , ContentHandler handler , Metadata metadata , ParseContext context ) \n \n \t3 throws IOException , SAXException , TikaException { \n \n \t2 if ( ! recogniser . isAvailable ( ) ) { \n \n <ect>
\t2 LoginCredential credentials = getLoginCredential ( u ) ; \n \n \t2 if ( ! credentials . checkPassword ( pw ) ) { \n \n \t3 log . error ( <string_literal> ) ; \n \n \t3 throw new DAOException ( <string_literal> ) ; } \n \n <ect>
\t7 String . valueOf ( contents . length ) ) . getConnection ( ) ; \n \n \t3 HttpResponse response = Utils . doSendOperation ( conn , contents ) ; \n \n \t3 if ( ! response . isSuccessCode ( ) ) { \n \n \t4 if ( response . isAuthDenied ( ) ) { \n \n <ect>
\t1 public AutoStartable startSessions ( @ Named ( <string_literal> ) Sessions sessions ) { \n \n \t2 return new AutoStartable ( ) { \n \n \t3 @ Override \n \n \t3 public void start ( ) { \n \n <ect>
\t2 cmd . getAccessDetail ( NetworkElementCommand . ROUTER_IP ) ; \n \n \t2 final List < IpAliasTO > revokedIpAliasTOs = cmd . getDeleteIpAliasTos ( ) ; \n \n \t2 final List < IpAliasTO > activeIpAliasTOs = cmd . getCreateIpAliasTos ( ) ; \n \n <ect>
\t2 logger . debug ( <string_literal> , classesDir . getAbsolutePath ( ) , clock . getElapsed ( ) ) ; } \n \n \t1 private void compileScript ( final ScriptSource source , ClassLoader classLoader , CompilerConfiguration configuration , File metadataDir , \n \n \t7 final CompileOperation < ? > extractingTransformer , final Action < ? super ClassNode > customVerifier ) { \n \n \t2 final Transformer transformer = extractingTransformer != null ? extractingTransformer . getTransformer ( ) : null ; \n \n <ect>
\t4 <comment> \n \n \t2 if ( doi != null ) { \n \n \t3 return doi ; \n \n \t2 } else { \n \n <ect>
\t4 . get ( ) ) ; \n \n \t2 assertAliasesExist ( client . admin ( ) . indices ( ) . prepareAliasesExist ( <string_literal> ) . get ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 assertThat ( client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) . setIndices ( ) . setWaitForCompletion ( true ) . get ( ) . getSnapshotInfo ( ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; \n \n <ect>
\t5 <comment> \n \n \t5 if ( connection != null ) { \n \n \t6 connection . close ( ) ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 ECKey rebornUnencryptedKey = encryptedKey . decrypt ( keyCrypter , aesKey ) ; \n \n \t3 byte [ ] originalPrivateKeyBytes = originalKey . getPrivKeyBytes ( ) ; \n \n \t3 byte [ ] rebornKeyBytes = rebornUnencryptedKey . getPrivKeyBytes ( ) ; \n \n \t3 if ( ! Arrays . equals ( originalPrivateKeyBytes , rebornKeyBytes ) ) { \n \n <ect>
\t4 try { \n \n \t5 log . info ( <string_literal> ) ; \n \n \t5 KeyParameter result = scrypt . deriveKey ( password ) ; \n \n \t5 timeTakenMsec = ( int ) ( System . currentTimeMillis ( ) - start ) ; \n \n <ect>
\t5 s_logger . debug ( <string_literal> + ruleAnswer . toString ( ) + <string_literal> + agentId \n \n \t7 + <string_literal> + ruleAnswer . getDetails ( ) \n \n \t7 + <string_literal> ) ; \n \n \t5 if ( ruleAnswer . getReason ( ) == FailureReason . CANNOT_BRIDGE_FIREWALL ) { \n \n <ect>
\t1 Assert . assertEquals ( logLevelWithParam , ILogger . WARN ) ; \n \n \t1 logger . warn ( <string_literal> + ILogger . WARN ) ; <comment> \n \n \t1 logger . warn ( <string_literal> + + ILogger . WARN , new Throwable ( ) ) ; <comment> \n \n \t1 logger . debug ( <string_literal> + ILogger . DEBUG ) ; <comment> \n \n <ect>
\t6 try { \n \n \t7 CompiledScript compile = compEngine . compile ( script ) ; \n \n \t7 entry . getValue ( ) . setCsript ( compile ) ; \n \n \t6 } catch ( ScriptException e ) { \n \n <ect>
\t2 List < String > nodesIds = internalCluster ( ) . startNodes ( <number_literal> ) ; \n \n \t2 final String node_0 = nodesIds . get ( 0 ) ; \n \n \t2 final String node_1 = nodesIds . get ( 1 ) ; \n \n \t2 assertThat ( cluster ( ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t6 new Processor ( ) { \n \n \t7 @ Override \n \n \t7 public void process ( Exchange exchange ) throws Exception { \n \n \t8 if ( exchange . getIn ( ) . getHeader ( <string_literal> , Boolean . class ) ) { \n \n <ect>
\t5 x = resolve ( e , x , tempBucketFactory , ctx , key , gotElement , element2 , callback , context ) ; \n \n \t4 } catch ( IOException e1 ) { \n \n \t5 throw new ArchiveFailureException ( <string_literal> + e1 , e1 ) ; } \n \n \t3 } catch ( IOException e1 ) { \n \n <ect>
\t5 s_logger . info ( <string_literal> + _msId + <string_literal> ) ; } \n \n \t3 } else { \n \n <ect>
\t1 TransportClient nativeClient = new MinimalTransportClient ( esSettings . build ( ) ) ; \n \n \t1 HostAndPort host = HostAndPort . fromParts ( esConfig . getHost ( ) , esConfig . getPort ( ) ) ; \n \n \t1 addHostToClient ( host , nativeClient ) ; \n \n <ect>
\t2 if ( dests != null ) \n \n \t2 { \n \n \t3 for ( ActiveMQDestination destination : dests ) { \n \n \t4 String name = destination . getPhysicalName ( ) ; \n \n <ect>
\t4 this . centralAuthenticationService . destroyTicketGrantingTicket ( ticketGrantingTicket ) ; } \n \n \t3 if ( isGatewayPresent ( context ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , CasWebflowConstants . STATE_ID_GATEWAY ) ; \n \n \t4 return result ( CasWebflowConstants . STATE_ID_GATEWAY ) ; } \n \n <ect>
\t5 if ( nodesIterator . hasNext ( ) ) { \n \n \t6 nextNodeMessage = <string_literal> ; \n \n \t5 } else { \n \n \t6 nextNodeMessage = <string_literal> ; } \n \n <ect>
\t1 public void open ( int taskNumber , int numTasks ) throws IOException { \n \n \t2 if ( taskNumber < 0 || numTasks < 1 ) { \n \n \t3 throw new IllegalArgumentException ( <string_literal> + taskNumber + <string_literal> + numTasks ) ; } \n \n <ect>
\t3 synchronized ( fileHandle ) { \n \n \t3 try { \n \n \t4 fileHandle . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 ZWaveSecurityCommandClass . realNetworkKey = new SecretKeySpec ( keyBytes , <string_literal> ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 ZWaveSecurityCommandClass . keyException = null ; <comment> \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t1 private TreeSet < OneTimeTokenAccount > readAccountsFromJsonRepository ( ) throws IOException { \n \n \t2 LOGGER . debug ( <string_literal> , this . location . getFile ( ) ) ; \n \n \t2 final boolean result = this . location . getFile ( ) . createNewFile ( ) ; \n \n \t2 if ( result ) { \n \n <ect>
\t3 result . setSuccessIsSet ( true ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t1 protected void manageConnection ( Socket s ) { \n \n \t2 if ( s == null ) return ; \n \n \t2 ThreadPoolExecutor tpe = _executor ; \n \n \t2 if ( tpe == null ) { \n \n <ect>
\t4 log . error ( <string_literal> , e ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n \t4 log . info ( <string_literal> , e ) ; } \n \n \t3 else \n \n <ect>
\t1 if ( isRegistered ( expirable ) ) { \n \n \t1 resetExpirable ( expirable ) ; \n \n \t1 } else { \n \n <ect>
\t3 try { \n \n \t4 message = StreamUtil . readString ( is , GeneralConstants . SAML_CHARSET ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 throw new RuntimeException ( e ) ; } \n \n <ect>
\t4 try { \n \n \t5 ByteBufInputStream in = new ByteBufInputStream ( msgContent ) ; \n \n \t5 request = MAPPER . readValue ( in , untypedResponseMessageHeaders . getRequestClass ( ) ) ; \n \n \t4 } catch ( JsonParseException | JsonMappingException je ) { \n \n <ect>
\t2 basic . seeking ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void versionedSeeking ( ) throws IOException , NoSuchAlgorithmException { \n \n <ect>
\t5 stateTransitTo ( vm , Event . OperationFailed , srcHostId ) ; \n \n \t4 } catch ( final AgentUnavailableException e ) { \n \n \t5 s_logger . warn ( <string_literal> , e ) ; \n \n \t4 } catch ( final NoTransitionException e ) { \n \n <ect>
\t2 if ( text == null ) { \n \n \t3 return ; } \n \n \t2 Voice voice = null ; \n \n \t2 if ( StringUtils . isBlank ( voiceName ) ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 if ( casProperties . getWebflow ( ) . isAutoconfigure ( ) ) { \n \n \t4 doInitialize ( ) ; \n \n \t3 } else { \n \n <ect>
\t1 public void enable ( ) { \n \n \t2 logger . debug ( <string_literal> , LoggerConstants . TFINIT , getSubId ( ) ) ; \n \n \t2 setSensorValue ( HighLowValue . UNDEF ) ; \n \n \t2 if ( tfConfig != null ) { \n \n <ect>
\t2 } catch ( NoClassDefFoundError e ) { \n \n \t3 LOG . warn ( <string_literal> , logLevelUpper , loggerName , e ) ; \n \n \t3 return false ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 bean . beanDefinition . dependencyCheck = AbstractBeanDefinition . DEPENDENCY_CHECK_NONE } \n \n \t5 if ( useJsessionId ) { \n \n \t6 useJessionId = useJsessionId } } } } \n \n \t2 if ( config . getProperty ( Settings . SETTING_LEGACY_JSON_BUILDER , Boolean . class , false ) ) { \n \n <ect>
\t2 addTicket ( ticket ) ; \n \n \t2 return ticket ; } \n \n \t1 @ Override \n \n \t1 public void addTicket ( final Ticket ticketToAdd ) { \n \n <ect>
\t3 throw new BadRequestException ( <string_literal> + cubeName + <string_literal> ) ; } \n \n \t2 Map < Long , Long > cuboidList = getRecommendCuboidList ( cube ) ; \n \n \t2 List < Set < String > > dimensionSetList = Lists . newLinkedList ( ) ; \n \n \t2 if ( cuboidList == null || cuboidList . isEmpty ( ) ) { \n \n <ect>
\t2 } else { \n \n \t3 return Answer . createUnsupportedCommandAnswer ( cmd ) ; } } \n \n \t1 private Answer execute ( HandleConfigDriveIsoCommand cmd ) { \n \n \t2 if ( cmd . isCreate ( ) ) { \n \n <ect>
\t4 disconnectWithInvestigation ( attache , event ) ; } \n \n \t2 } else { \n \n \t3 <comment> \n \n \t3 if ( tapLoadingAgents ( hostId , TapAgentsAction . Contains ) ) { \n \n <ect>
\t1 private final transient TypeResolver typeResolver ; \n \n \t1 private final transient TypeHelper typeHelper ; \n \n \t1 private transient StatisticsImplementor statisticsImplementor ; \n \n \t1 public SessionFactoryImpl ( final MetadataImplementor metadata , SessionFactoryOptions options ) { \n \n <ect>
\t1 public static void logError ( Throwable e , String message ) { \n \n \t2 String msg = e . getMessage ( ) ; \n \n \t2 if ( msg == null ) { \n \n \t3 msg = e . toString ( ) ; } \n \n <ect>
\t3 try { \n \n \t4 while ( ( line = in . readLine ( ) ) != null ) { \n \n \t5 logger . info ( line ) ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 copy = new byte [ newSize ] ; \n \n \t2 } catch ( OutOfMemoryError e ) { \n \n \t3 if ( buffer . length == 0 ) { \n \n <ect>
\t3 for ( final AgentAttache agent : _agents . values ( ) ) { \n \n \t4 final HostVO host = _hostDao . findById ( agent . getId ( ) ) ; \n \n \t4 if ( host == null ) { \n \n <ect>
\t3 running = true ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t2 } catch ( IOException ex ) { \n \n \t3 ex . printStackTrace ( ) ; \n \n <ect>
\t6 && FormatConfiguration . AAC . equals ( media . getAudioTracksList ( ) . get ( 0 ) . getCodecA ( ) ) ) { \n \n \t5 media . setContainer ( FormatConfiguration . AAC ) ; } \n \n \t4 media . finalize ( type , inputFile ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 c . tableOperations ( ) . addSplits ( tableName , splits ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 c . tableOperations ( ) . flush ( MetadataTable . NAME , null , null , true ) ; \n \n \t1 c . tableOperations ( ) . flush ( RootTable . NAME , null , null , true ) ; } \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 interruptFlag . set ( false ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 if ( slaStatus != null ) { \n \n \t5 SLADbOperations . writeStausEvent ( coordAction . getSlaXml ( ) , coordAction . getId ( ) , cstore , slaStatus , \n \n <number_literal> SlaAppType . COORDINATOR_ACTION ) ; } } } \n \n \t2 catch ( XException ex ) { \n \n <ect>
\t2 template . getTemplateData ( ) . setNote ( <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 template . setCustom ( null ) ; \n \n \t2 template . update ( SANDBOX_CONTEXT ) ; \n \n <ect>
\t5 if ( lbVmIps == null || lbVmIps . isEmpty ( ) ) { \n \n \t6 LoadBalancerVMMapVO map = _lb2VmMapDao . findByLoadBalancerIdAndVmId ( loadBalancerId , instanceId ) ; \n \n \t6 map . setRevoke ( false ) ; \n \n \t6 _lb2VmMapDao . persist ( map ) ; \n \n <ect>
\t5 throw new SWORDAuthenticationException ( \n \n \t6 <string_literal> ) ; } } \n \n \t3 return sc ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 _name = name ; \n \n \t2 ComponentLocator locator = ComponentLocator . getCurrentLocator ( ) ; \n \n \t2 ConfigurationDao configDao = locator . getDao ( ConfigurationDao . class ) ; \n \n \t2 if ( configDao == null ) { \n \n <ect>
\t2 try { \n \n \t3 return new String ( data , offset , length , charset ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
<comment> \n \n \t1 private void handleResponseFromDataStore ( Result result ) { \n \n \t2 if ( debug ) { \n \n <ect>
\t2 if ( doRejectedAttributesRefusePrincipalAccess ( principalAttributes ) ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! doRequiredAttributesAllowPrincipalAccess ( principalAttributes , this . requiredAttributes ) ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> ) ; \n \n \t4 return false ; \n \n \t3 } else { \n \n \t4 if ( vmInstance . getState ( ) == State . Stopped ) { \n \n <ect>
\t3 FileOutputStream fsOut = new FileOutputStream ( pathToKeystore ) ; \n \n \t3 certStore . store ( fsOut , keystorePassword . toCharArray ( ) ) ; \n \n \t3 <comment> \n \n \t3 String uniqueId = AuthenticationUtils . X509CertUniqueId ( userCert ) ; \n \n <ect>
\t2 final String logFile = environment . getProperty ( <string_literal> , <string_literal> ) ; \n \n \t2 LOGGER . debug ( <string_literal> , logFile ) ; \n \n \t2 if ( ResourceUtils . doesResourceExist ( logFile , resourceLoader ) ) { \n \n \t3 final Resource logConfigurationFile = resourceLoader . getResource ( logFile ) ; \n \n <ect>
\t4 metadataDirty = false ; } \n \n \t3 <comment> \n \n \t3 dos . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 logger . error ( <string_literal> ) ; \n \n \t4 return ; } } \n \n \t2 if ( watchList . getLength ( ) > 1 ) \n \n \t2 { \n \n <ect>
\t1 return ; \n \n \t1 } catch ( MBeanException e ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t4 . setParameter ( <string_literal> , uid ) \n \n \t4 . getSingleResult ( ) ; \n \n \t3 return Optional . of ( new YubiKeyAccount ( account . getId ( ) , getCipherExecutor ( ) . decode ( account . getPublicId ( ) ) , account . getUsername ( ) ) ) ; \n \n \t2 } catch ( final NoResultException e ) { \n \n <ect>
\t2 < input type = <string_literal> ng - model = <string_literal> / > \n \n \t2 < button ng - click = <string_literal> > log < / button > \n \n \t2 < button ng - click = <string_literal> > warn < / button > \n \n \t2 < button ng - click = <string_literal> > info < / button > \n \n <ect>
\t3 if ( memCap . getUsedCapacity ( ) == usedMemory && memCap . getReservedCapacity ( ) == reservedMemory ) { \n \n \t4 s_logger . debug ( <string_literal> + host . getId ( ) + <string_literal> + memCap . getUsedCapacity ( ) \n \n \t6 + <string_literal> + memCap . getReservedCapacity ( ) ) ; \n \n \t3 } else if ( memCap . getReservedCapacity ( ) != reservedMemory ) { \n \n <ect>
\t3 { \n \n \t4 log . error ( <string_literal> , e ) ; \n \n \t3 } catch ( InvocationTargetException e ) \n \n \t3 { \n \n <ect>
\t3 } else { \n \n \t4 LOG . warn ( <string_literal> + r . getName ( ) ) ; \n \n \t4 return false ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 if ( ! validateConnection ( conn ) ) { \n \n \t2 <comment> \n \n \t2 LOG . warn ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t3 if ( warnningStep % <number_literal> == 0 ) { \n \n \t4 LOG . warn ( <string_literal> ) ; } } } \n \n \t1 @ Override \n \n \t1 public void ack ( Object msgId ) { \n \n <ect>
\t3 default : \n \n \t4 LOG . error ( <string_literal> ) ; \n \n \t4 connection . close ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 createAutoScaleConfig ( loadBalancer ) ; } \n \n \t2 <comment> \n \n \t2 saveConfiguration ( ) ; \n \n <ect>
\t6 setIncreasePaymentFutureIfNeeded ( CloseReason . REMOTE_SENT_INVALID_MESSAGE , <string_literal> ) ; \n \n \t6 closeReason = CloseReason . REMOTE_SENT_INVALID_MESSAGE ; \n \n \t6 break ; } \n \n \t3 } catch ( VerificationException e ) { \n \n <ect>
\t2 if ( logDEBUG ) Logger . debug ( this , <string_literal> + result + <string_literal> + state ) ; \n \n \t2 result . data . free ( ) ; } \n \n \t1 @ Override \n \n \t1 public void onSuccess ( BaseClientPutter state ) { \n \n <ect>
\t1 long emptyMapSize = reflectionSizeOf . sizeOf ( map ) ; \n \n \t1 map . put ( new Long ( 1 ) , new Double ( <number_literal> . 0 ) ) ; \n \n \t1 long sizeOfMapOneEntry = reflectionSizeOf . deepSizeOf ( DEFAULT_MAX_DEPTH , DEFAULT_ABORT_WHEN_MAX_DEPTH_EXCEEDED , map ) . getCalculated ( ) ; \n \n \t1 this . sizeOfMapEntryOverhead = sizeOfMapOneEntry - ( emptyMapSize + this . sizeOfMapEntry ) ; \n \n <ect>
\t1 Preconditions . checkState ( total == from . length ( ) , \n \n \t2 <string_literal> ) ; \n \n \t1 return true ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t5 if ( inMessage != null ) { \n \n \t6 Map < String , List < String > > cxfHeaders = CastUtils . cast ( ( Map < ? , ? > ) inMessage . get ( Message . PROTOCOL_HEADERS ) ) ; \n \n \t6 endpoint . getCookieHandler ( ) . storeCookies ( camelExchange , endpoint . getRequestUri ( camelExchange ) , cxfHeaders ) ; } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 fs . delete ( mapPath , true ) ; } \n \n \t1 if ( fs . exists ( reducePath ) ) { \n \n \t2 fs . delete ( reducePath , true ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 rxHash = null ; } \n \n \t2 } catch ( IOException e ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t3 return n ; } \n \n \t2 catch ( TException ex ) { \n \n \t3 throw new TDBException ( <string_literal> , ex ) ; } \n \n \t2 catch ( RiotThriftException ex ) { \n \n <ect>
\t5 throw new CloudException ( <string_literal> + e . getMessage ( ) , e ) ; } } \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t2 y . promote ( ) ; \n \n \t2 Record splitKey = y . getSplitKey ( ) ; \n \n \t2 splitKey = keyRecord ( splitKey ) ; \n \n \t2 if ( logging ) \n \n <ect>
\t4 _log . warn ( <string_literal> + ann ) ; \n \n \t3 return false ; } } \n \n \t1 if ( existing . size ( ) >= MAX_TRACKERS ) { \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 <comment> \n \n \t1 if ( StringUtils . startsWith ( jobId , <string_literal> ) ) { \n \n <ect>
\t2 dbName = name ; \n \n \t2 File profileDirectory = new File ( configuration . getProfileDirectory ( ) ) ; \n \n \t2 dbDir = new File ( profileDirectory . isDirectory ( ) ? configuration . getProfileDirectory ( ) : null , <string_literal> ) . getAbsolutePath ( ) ; \n \n \t2 url = Constants . START_URL + dbDir + File . separator + dbName ; \n \n <ect>
\t4 timeOfLastWatcherInvocation = System . currentTimeMillis ( ) ; \n \n \t4 try { \n \n \t5 events . put ( event ) ; \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( killQuery != null ) { \n \n \t3 sessionState . getKillQuery ( ) . killQuery ( queryId , entry . getValue ( ) . getViolationMsg ( ) ) ; } \n \n \t2 } catch ( HiveException e ) { \n \n <ect>
\t3 } finally { \n \n \t4 IOUtils . closeStream ( is ) ; } \n \n \t3 return ExecuteResult . createSucceed ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 cluster = new MiniDFSCluster ( new Configuration ( ) , 1 , true , null ) ; \n \n \t1 cluster . waitActive ( ) ; \n \n \t1 String outputDir = <string_literal> ; \n \n \t1 Path outputDirPath = new Path ( outputDir ) ; \n \n <ect>
\t2 LOG . debug ( <string_literal> ) ; \n \n \t2 String json = exchange . getContext ( ) . getTypeConverter ( ) . mandatoryConvertTo ( String . class , new URL ( <string_literal> ) ) ; \n \n \t2 if ( isEmpty ( json ) ) { \n \n \t3 throw new IllegalStateException ( <string_literal> + json + <string_literal> ) ; } \n \n <ect>
\t2 return newMessage ; } \n \n \t1 @ Override \n \n \t1 public boolean handleResponse ( ZWaveController zController , SerialMessage lastSentMessage , \n \n \t3 SerialMessage incomingMessage ) { \n \n <ect>
\t3 conf = null ; \n \n \t3 try { \n \n \t4 conf = FileUtils . readFileToString ( file ) ; \n \n \t3 } catch ( FileNotFoundException ex ) { \n \n <ect>
\t3 Message start_msg = new Message ( flushStarter ) \n \n \t3 . putHeader ( this . id , new FlushHeader ( FlushHeader . FLUSH_COMPLETED , fh . viewID ) ) \n \n \t3 . setBuffer ( marshal ( tuple . getVal1 ( ) , digest ) ) ; \n \n \t3 down_prot . down ( start_msg ) ; \n \n <ect>
\t3 LOG . info ( <string_literal> , server . getPort ( ) ) ; } } \n \n \t1 @ Override \n \n \t1 protected void doStop ( ) throws Exception { \n \n \t2 if ( server != null ) { \n \n <ect>
\t4 if ( archive != null ) { \n \n \t5 attachmentParameters . put ( XWikiWikiAttachmentFilter . PARAMETER_JRCSREVISIONS , \n \n \t6 archive . getArchiveAsString ( ) ) ; } \n \n \t3 } catch ( XWikiException e ) { \n \n <ect>
\t4 if ( mageObject != null ) { \n \n \t5 this . zoneChangeCounter = mageObject . getZoneChangeCounter ( game ) ; \n \n \t5 logger . error ( <string_literal> ) ; \n \n \t4 } else { \n \n <ect>
\t3 if ( solrServer != null ) { \n \n \t4 editor = new SolrIndexEditor ( solrServer , configuration , callback ) ; \n \n \t3 } else { \n \n <ect>
\t2 httpSession . setAttribute ( <string_literal> , userContext . getLocale ( ) ) ; \n \n \t2 <comment> \n \n \t2 Context . setUserContext ( userContext ) ; \n \n \t2 Thread . currentThread ( ) . setContextClassLoader ( OpenmrsClassLoader . getInstance ( ) ) ; \n \n <ect>
\t2 return _name ; } \n \n \t1 @ Override @ DB \n \n \t1 public boolean start ( ) { \n \n <ect>
\t2 try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( \n \n \t4 new FileInputStream ( coreFile ) , <string_literal> ) ) ) { \n \n \t3 final String firstLine = reader . readLine ( ) ; \n \n \t3 if ( firstLine == null ) { \n \n <ect>
\t3 connectionLeakUtil . assertNoLeaks ( ) ; } } \n \n \t1 @ After \n \n \t1 public void releaseTransactions ( ) { \n \n \t2 if ( JtaStatusHelper . isActive ( TestingJtaPlatformImpl . INSTANCE . getTransactionManager ( ) ) ) { \n \n <ect>
\t1 migrationState . setStatus ( Status . SUCCEEDED ) ; \n \n \t1 profiler . stopInfo ( <string_literal> ) ; \n \n \t1 } catch ( MigrationStepExecutionException e ) { \n \n \t1 profiler . stopError ( <string_literal> ) ; \n \n <ect>
\t3 log . debug ( sm . getString ( <string_literal> , ciphers ) ) ; \n \n \t3 if ( ciphers . size ( ) != requestedCiphers . size ( ) ) { \n \n \t4 List < String > skipped = new ArrayList < String > ( requestedCiphers ) ; \n \n \t4 skipped . removeAll ( ciphers ) ; \n \n <ect>
\t2 return new CreateEntityDownloadURLAnswer ( <string_literal> , CreateEntityDownloadURLAnswer . RESULT_SUCCESS ) ; } \n \n \t1 @ Override \n \n \t1 public DeleteEntityDownloadURLAnswer handleDeleteEntityDownloadURLCommand ( DeleteEntityDownloadURLCommand cmd ) { \n \n \t2 <comment> \n \n <ect>
<comment> \n \n \t1 protected static String extractItemName ( HttpAction action ) { \n \n <comment> \n \n <ect>
\t4 f . onTimedOut ( _executor ) ; } } \n \n \t2 long tEnd = System . currentTimeMillis ( ) ; \n \n \t2 if ( tEnd - tStart > <number_literal> ) { \n \n \t3 if ( tEnd - tStart > <number_literal> ) \n \n <ect>
\t1 protected Digest readDigest ( byte [ ] buffer , int offset , int length ) { \n \n \t2 try { \n \n \t3 return buffer != null ? Util . streamableFromBuffer ( Digest : : new , buffer , offset , length ) : null ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
\t3 InetSocketAddress endpointSocketAddr = new InetSocketAddress ( p . getHost ( ) , p . getPort ( ) ) ; \n \n \t3 socket . connect ( endpointSocketAddr , <number_literal> ) ; \n \n \t3 return true ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 public boolean canAuthenticateAsInternal ( final String username , final Principal surrogate , final Service service ) { \n \n \t2 try { \n \n \t3 if ( username . equalsIgnoreCase ( surrogate . getId ( ) ) ) { \n \n \t4 return true ; } \n \n <ect>
\t2 try { \n \n \t3 String file = url . getFile ( ) ; \n \n \t3 new URL ( url . getProtocol ( ) , url . getHost ( ) , file . substring ( 0 , file . length ( ) - name . length ( ) ) ) ; } \n \n \t2 catch ( MalformedURLException mue ) { \n \n <ect>
\t2 List < GenomeLoc > allIntervals = new ArrayList < GenomeLoc > ( 0 ) ; \n \n \t2 for ( IntervalBinding intervalBinding : activeRegionBindings ) { \n \n \t3 List < GenomeLoc > intervals = intervalBinding . getIntervals ( this . getToolkit ( ) . getGenomeLocParser ( ) ) ; \n \n \t3 if ( intervals . isEmpty ( ) ) { \n \n <ect>
<comment> \n \n \t2 void onResult ( Throwable e ) { \n \n <ect>
\t2 if ( state != null ) { \n \n \t3 state . receiveSessionConfirmed ( reader . getSessionConfirmedReader ( ) ) ; \n \n \t3 notifyActivity ( ) ; \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 if ( upgrade ) { \n \n \t2 return upgrade ( checkpointFile , capacity , name , backupCheckpointDir , \n \n \t3 shouldBackup , compressBackup , counter ) ; } \n \n \t2 return new EventQueueBackingStoreFileV2 ( checkpointFile , capacity , name , counter ) ; } \n \n <ect>
\t2 setName ( name ) ; \n \n \t2 this . modifiers = modifiers ; \n \n \t2 initializeRefType ( name ) ; \n \n \t2 if ( Options . v ( ) . debug_resolver ( ) ) \n \n <ect>
\t2 HostDatastoreBrowserSearchResults results = browserMo . searchDatastore ( dirFile . getPath ( ) , file . getFileName ( ) , true ) ; \n \n \t2 if ( results != null ) { \n \n \t3 FileInfo [ ] info = results . getFile ( ) ; \n \n \t3 if ( info != null && info . length > 0 ) { \n \n <ect>
\t4 requestParameters . put ( <string_literal> , new Object [ ] { account . getAccountName ( ) } ) ; \n \n \t4 requestParameters . put ( <string_literal> , new Object [ ] { account } ) ; } \n \n \t3 return equalSig ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( logMINOR ) Logger . minor ( this , <string_literal> + m + <string_literal> + this . itemName + <string_literal> + this + <string_literal> + state + <string_literal> + persistent ) ; \n \n \t3 if ( metadata != null ) { \n \n <ect>
\t3 Iterator < LgtvEventListener > iterator = _listeners . iterator ( ) ; \n \n \t3 while ( iterator . hasNext ( ) ) { \n \n \t4 iterator . next ( ) . statusUpdateReceived ( event , remoteaddr , message ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 s_logger . info ( <string_literal> + vol . getPath ( ) + <string_literal> ) ; } } \n \n \t3 return new Answer ( cmd , true , <string_literal> ) ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t1 try { \n \n \t2 task . create ( imageInfo . getDisplayName ( ) ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n \t2 deallocator . apply ( imageInfo ) ; \n \n <ect>
<comment> \n \n \t1 private String processFlection ( Word word , Result currentResult , boolean allowOtherLanguage ) { \n \n \t2 String toBePhonemised = word . getToBePhonemised ( ) ; \n \n <ect>
\t4 while ( true ) { \n \n \t5 try { \n \n \t6 long delta = System . currentTimeMillis ( ) - start ; \n \n \t6 if ( delta > timeoutMilliSeconds ) { \n \n <ect>
\t4 . append ( <string_literal> ) \n \n \t4 . append ( whichMinutes ) ; \n \n \t3 return sB . toString ( ) ; \n \n \t2 } catch ( NaException nae ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 resources = classLoader . getResources ( <string_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 bindings . put ( <string_literal> , value ) ; <comment> \n \n \t6 <comment> \n \n \t6 value = evaluateScript ( entry , bindings ) ; \n \n \t5 } catch ( ScriptException e ) { \n \n <ect>
\t3 throw new CertificateException ( errorMsg ) ; } \n \n \t2 if ( activeCertMap != null && ! Strings . isNullOrEmpty ( clientAddress ) ) { \n \n \t3 activeCertMap . put ( clientAddress , primaryClientCertificate ) ; } \n \n <ect>
\t6 continue ; } \n \n \t5 LOGGER . info ( <string_literal> , provider , algorithm ) ; \n \n \t5 try { \n \n \t6 cipher . decryptValuePropagateExceptions ( encryptedValue ) ; \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( rollbackLoggingLevel == LoggingLevel . INFO || rollbackLoggingLevel == LoggingLevel . WARN \n \n \t5 || rollbackLoggingLevel == LoggingLevel . ERROR ) { \n \n <ect>
\t2 if ( domain == null ) { \n \n \t3 s_logger . error ( <string_literal> + id + <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( domain . getParent ( ) == null ) { \n \n <ect>
<comment> \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n <ect>
\t4 logger . trace ( <string_literal> ) ; \n \n \t4 invalidateCaches ( ) ; } \n \n \t2 } ; \n \n \t2 runWithCompactionsDisabled ( Executors . callable ( truncateRunnable ) , true , true ) ; \n \n <ect>
\t1 if ( rs1 != null ) { \n \n \t2 try { \n \n \t2 rs1 . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t3 m . put ( value , <string_literal> , value ) ; \n \n \t3 masterTable1Records ++ ; } \n \n \t2 bw . addMutation ( m ) ; } \n \n \t2 bw . close ( ) ; \n \n <ect>
\t5 debug . write ( b , 0 , n ) ; } } \n \n \t2 } catch ( InterruptedIOException e ) { \n \n \t4 if ( isNotBlank ( e . getMessage ( ) ) ) { \n \n <ect>
\t4 + appId \n \n \t4 + ( relativeTargetPath . isEmpty ( ) ? <string_literal> : <string_literal> + relativeTargetPath ) \n \n \t4 + <string_literal> + localSrcPath . getName ( ) ; \n \n \t2 Path dst = new Path ( homedir , suffix ) ; \n \n <ect>
\t1 try { \n \n \t1 SecurityToken token = SecurityTokenManager . issueSecurityToken ( role , RoleSecurityTokenAttributes . basic ( sessionName ) , durationInSec ) ; \n \n \t1 eucaS3Client = EucaS3ClientFactory . getEucaS3Client ( new BasicSessionCredentials ( token . getAccessKeyId ( ) , token . getSecretKey ( ) , token . getToken ( ) ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 logger . debug ( <string_literal> ) ; \n \n \t4 mDevice = factory . createMBrickletLCD20x4 ( ) ; \n \n \t4 mDevice . setDeviceIdentifier ( BrickletLCD20x4 . DEVICE_IDENTIFIER ) ; \n \n \t3 } else if ( deviceIdentifier == BrickletIndustrialDigitalIn4 . DEVICE_IDENTIFIER ) { \n \n <ect>
\t2 if ( updatePolicy . getAutoScalingRollingUpdate ( ) == null ) return newAction ; \n \n \t2 RollingUpdateStateEntity rollingUpdateStateEntity = RollingUpdateStateEntityManager . getRollingUpdateStateEntity ( newAction . info . getAccountId ( ) , newAction . getStackEntity ( ) . getStackId ( ) , newAction . info . getLogicalResourceId ( ) ) ; \n \n \t2 if ( ! Boolean . TRUE . equals ( rollingUpdateStateEntity . getNeedsRollbackUpdate ( ) ) ) return newAction ; \n \n \t2 while ( rollingUpdateStateEntity . getState ( ) != UpdateRollbackInfo . State . DONE ) { \n \n <ect>
\t3 LOG . info ( <string_literal> + current + <string_literal> + getRepositoryName ( ) ) ; \n \n \t2 } else { \n \n \t3 LOG . info ( <string_literal> + getRepositoryName ( ) ) ; } \n \n \t2 if ( completed > 0 ) { \n \n <ect>
\t2 log . debug ( <string_literal> + tls ) ; \n \n \t2 TabletStateStore . suspend ( TabletServer . this , tls , null , \n \n \t3 requestTimeSkew + MILLISECONDS . convert ( System . nanoTime ( ) , NANOSECONDS ) ) ; } \n \n \t1 } catch ( DistributedStoreException ex ) { \n \n <ect>
\t3 } else { \n \n \t4 fakeSource = new ConfigurationSource ( fakeStream ) ; } \n \n \t3 return new HoconConfiguration ( fakeSource ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t2 } catch ( final jcifs . spnego . AuthenticationException e ) { \n \n \t3 LOGGER . debug ( <string_literal> , e ) ; \n \n \t3 throw new FailedLoginException ( e . getMessage ( ) ) ; } \n \n \t2 if ( nextToken != null ) { \n \n <ect>
\t3 String schemeCaps = lbCaps . get ( Capability . LbSchemes ) ; \n \n \t3 if ( schemeCaps != null && rules != null && ! rules . isEmpty ( ) ) { \n \n \t4 for ( LoadBalancingRule rule : rules ) { \n \n \t5 if ( ! schemeCaps . contains ( rule . getScheme ( ) . toString ( ) ) ) { \n \n <ect>
\t2 } catch ( IllegalBlockSizeException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( BadPaddingException e ) { \n \n <ect>
\t2 if ( null != zooKeeperProcess ) { \n \n \t2 try { \n \n \t3 cluster . stopProcessWithTimeout ( zooKeeperProcess , <number_literal> , TimeUnit . SECONDS ) ; \n \n \t2 } catch ( ExecutionException | TimeoutException e ) { \n \n <ect>
\t2 compression ) ) ; \n \n \t1 conn . commit ( ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 } catch ( SQLException | InterruptedException sql ) { \n \n <ect>
\t8 responseConstructor . sendResponse ( this . coordinatorPerfStats , \n \n <number_literal> true , \n \n <number_literal> this . requestObject . getRequestOriginTimeInMs ( ) ) ; \n \n <ect>
\t2 assertFileDoesNotExists ( <string_literal> ) ; \n \n \t2 assertFileDoesNotExists ( <string_literal> ) ; \n \n \t2 assertEquals ( <number_literal> , this . numberOfFilesProcessed . get ( ) ) ; } \n \n \t1 private void writeFiles ( ) throws Exception { \n \n <ect>
\t4 Date updated = sdf . parse ( dcv . get ( 0 ) . getValue ( ) ) ; \n \n \t4 receipt . getWrappedEntry ( ) . setUpdated ( updated ) ; \n \n \t3 } catch ( ParseException e ) { \n \n \t4 <comment> \n \n <ect>
\t4 if ( calledMethodClass != null ) { \n \n \t5 logger . info ( <string_literal> + calledMethodClass . getName ( ) ) ; \n \n \t5 calledMethod = ( Method ) app . nodeQuery ( Method . class ) . and ( Method . name , calledMethodName ) . and ( Method . classOrInterface , calledMethodClass ) . getFirst ( ) ; \n \n \t5 if ( calledMethod != null ) { \n \n <ect>
\t3 if ( queueView != null ) { \n \n \t4 log . info ( <string_literal> + getJMSDestination ( ) + <string_literal> + messageId + <string_literal> + <string_literal> + destination ) ; \n \n \t4 queueView . moveMessageTo ( messageId , destination ) ; \n \n \t3 } else { \n \n <ect>
\t1 public void testTwoThreadWithAutoLockLock ( ) { \n \n \t2 final EC ec = createEC ( ) ; \n \n \t2 Runnable r2 = new Runnable ( ) { \n \n \t3 public void run ( ) { \n \n <ect>
\t1 public boolean isDiff ( ) \n \n \t1 { \n \n \t2 if ( this . content != null ) { \n \n \t3 if ( this . isDiff != isContentDiff ( ) ) { \n \n <ect>
\t4 byte [ ] newPubKeyHash = SHA256 . digest ( pubKey2 . asBytes ( ) ) ; \n \n \t4 if ( Arrays . equals ( pubKeyHash , newPubKeyHash ) ) { \n \n \t5 if ( pubKey != null ) { \n \n \t6 <comment> \n \n <ect>
\t4 } catch ( final IOException e ) { \n \n \t5 s_logger . warn ( <string_literal> + proxyManagementIp ) ; \n \n \t5 success = false ; } } \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
\t3 nodesBuilder . masterNodeId ( currentState . nodes ( ) . getLocalNodeId ( ) ) ; \n \n \t3 for ( final DiscoveryNode joiningNode : joiningNodes ) { \n \n \t4 final DiscoveryNode nodeWithSameId = nodesBuilder . get ( joiningNode . getId ( ) ) ; \n \n \t4 if ( nodeWithSameId != null && nodeWithSameId . equals ( joiningNode ) == false ) { \n \n <ect>
\t1 @ BeforeClass \n \n \t1 public void init ( ) { } \n \n \t1 @ Test \n \n \t1 public void testMostFrequentBaseFraction ( ) { \n \n <ect>
\t1 if ( opHandle != null ) { \n \n \t2 try { \n \n \t2 closeOperation ( opHandle ) ; \n \n \t2 } catch ( HiveSQLException e ) { \n \n <ect>
\t3 try { \n \n \t4 final Constructor < ? > cstr = clazz . getDeclaredConstructor ( paramClasses ) ; \n \n \t4 return ( TokenFilter ) cstr . newInstance ( paramValues ) ; \n \n \t3 } catch ( IllegalArgumentException | IllegalAccessException | InstantiationException | InvocationTargetException | SecurityException e ) { \n \n <ect>
<number_literal> null ) ; \n \n \t1 if ( factory instanceof LoggerFactory ) { \n \n \t2 catFactory = ( LoggerFactory ) factory ; \n \n \t1 } else { \n \n <ect>
\t1 private static final Logger log = LoggerFactory . getLogger ( RemoteTestListenerWrapper . class ) ; \n \n \t1 private static final long serialVersionUID = 241L ; \n \n \t1 private final RemoteSampleListener listener ; \n \n \t1 public RemoteTestListenerWrapper ( ) { \n \n <ect>
\t3 if ( _firewallMgr . revokeAllFirewallRulesForNetwork ( networkId , callerUserId , caller ) ) { \n \n \t4 s_logger . debug ( <string_literal> + networkId ) ; \n \n \t3 } else { \n \n \t4 success = false ; \n \n <ect>
\t3 this . wrapped = wrapped ; \n \n \t3 this . subject = subject ; \n \n \t3 Set < Principal > principals = ( Set < Principal > ) subject . getPrincipals ( ) ; \n \n \t3 if ( principals . size ( ) > 0 ) \n \n <ect>
\t2 Class clazz = new GroovyClassLoader ( ) . parseClass ( <string_literal> <string_literal> <ect>
\t3 } else { \n \n \t4 String content = IOUtils . toString ( resp . getEntity ( ) . getContent ( ) , HttpHelper . charset ( resp ) ) ; \n \n \t4 content = skipBOMIfPresent ( content ) ; \n \n \t4 System . out . println ( <string_literal> + content ) ; \n \n <ect>
\t3 if ( moveResult . isTopHit ( ) && endVelocity . y > 0 ) { \n \n \t4 if ( input . isFirstRun ( ) ) { \n \n \t5 Vector3f hitVelocity = new Vector3f ( state . getVelocity ( ) ) ; \n \n \t5 hitVelocity . y += ( distanceMoved . y / moveDelta . y ) * ( endVelocity . y - state . getVelocity ( ) . y ) ; \n \n <ect>
\t4 } ) ) ; } \n \n \t1 @ Override \n \n \t1 public void shutdown ( ) { \n \n \t2 if ( shutdown . getAndSet ( true ) ) { \n \n <ect>
\t4 continue ; \n \n \t3 return segUuid . equals ( segmentId ) ; } \n \n \t2 return false ; } \n \n \t1 public static void main ( String [ ] args ) throws Exception { \n \n <ect>
\t2 if ( ! isOk ) { \n \n \t2 if ( isActivate ) { \n \n \t3 LOG . error ( <string_literal> + name ) ; \n \n \t2 } else { \n \n <ect>
\t6 pair . getFirst ( ) . lock ( ) ; \n \n \t6 if ( pair . getSecond ( ) . await ( flowCtrlAwaitTime , TimeUnit . MILLISECONDS ) ) \n \n \t7 break ; \n \n \t5 } catch ( InterruptedException e ) { \n \n <ect>
\t1 try { \n \n \t2 manager . close ( ) ; \n \n \t2 manager = null ; \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t6 MAX_RECORDS_IN_RAM , \n \n \t6 TMP_DIR ) ; \n \n \t2 int readerCount = 1 ; \n \n \t2 for ( final VCFFileReader reader : readers ) { \n \n <ect>
\t3 if ( notPresent != null ) \n \n \t4 notPresent . add ( node ) ; \n \n \t3 return ; } \n \n \t2 if ( id == NodeId . NodeIdAny ) { \n \n <ect>
\t6 if ( lineNum < 0 || lineNum > <number_literal> ) { \n \n \t7 logger . error ( <string_literal> ) ; \n \n \t7 displayError ( <string_literal> ) ; \n \n \t6 } else if ( inLinePostition < 0 || inLinePostition > <number_literal> ) { \n \n <ect>
\t10 System . currentTimeMillis ( ) - startTimeMS , \n \n \t10 attempt , \n \n \t10 totalBytesRead , \n \n \t10 checkSum ) ; \n \n <ect>
\t3 ohtfDevice . setTfConfig ( configuration ) ; \n \n \t3 fillupConfig ( ohtfDevice , deviceConfig ) ; \n \n \t2 } else if ( deviceType . equals ( TypeKey . bricklet_loadcell . name ( ) ) ) { \n \n \t3 logger . debug ( <string_literal> , LoggerConstants . CONFIG , deviceType ) ; \n \n <ect>
\t4 Logger . minor ( this , <string_literal> + next + <string_literal> + this ) ; \n \n \t3 next . noLongerRoutingTo ( thisTag , false ) ; \n \n \t3 return DO . NEXT_PEER ; } \n \n \t2 if ( dataMessage == null ) { \n \n <ect>
\t1 this . locations = locations ; } \n \n @ Override \n \n public Set < ? extends Image > get ( ) { \n \n \t1 final Set < Image > images = Sets . newHashSet ( ) ; \n \n <ect>
\t3 cardinality = Math . min ( \n \n \t4 ( StatsUtils . safeMult ( parentNumRows , sizeOfGroupingSet ) ) / <number_literal> , \n \n \t4 StatsUtils . safeMult ( StatsUtils . safeMult ( ndvProduct , parallelism ) , sizeOfGroupingSet ) ) ; \n \n <ect>
\t1 ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \n \n \t1 PrintStream logFile = new PrintStream ( out ) ; \n \n \t1 TestLogger logger = new TestLogger ( logFile , TestLogger . LEVEL . INFO ) ; \n \n \t1 logger . trace ( <string_literal> ) ; \n \n <ect>
\t2 if ( ajaxSessionIdStr != null ) { \n \n \t3 try { \n \n \t4 ajaxSessionId = Long . parseLong ( ajaxSessionIdStr ) ; \n \n \t3 } catch ( NumberFormatException e ) { \n \n <ect>
\t8 Object result = interpreter . eval ( key ) ; \n \n \t8 if ( result != null && result instanceof Boolean && ( Boolean ) result ) { \n \n \t9 sb . append ( ' ' ) . append ( value ) ; } } \n \n \t6 } catch ( Throwable e ) { \n \n <ect>
\t10 roZk . startup ( ) ; } \n \n \t8 } catch ( InterruptedException e ) { \n \n \t9 LOG . info ( <string_literal> ) ; \n \n \t8 } catch ( Exception e ) { \n \n <ect>
\t4 result . add ( convertHistoryRecordToMessageEvent ( recs . next ( ) , room ) ) ; } \n \n \t3 removeHistorySearchProgressListeners ( reader ) ; \n \n \t2 } catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t2 KeyPair keyPair = KeyPairGenerator . getInstance ( <string_literal> ) . generateKeyPair ( ) ; \n \n \t2 String content = <string_literal> ; \n \n \t2 { \n \n \t3 String encoded = new JWEBuilder ( ) . contentBytes ( content . getBytes ( ) ) . RSA1_5 ( ( RSAPublicKey ) keyPair . getPublic ( ) ) ; \n \n <ect>
\t3 setPullUpResistorEnabled ( tfConfig . isPullUpResistorEnabled ( ) ) ; \n \n \t3 logger . debug ( <string_literal> , LoggerConstants . TFINIT , isPullUpResistorEnabled ( ) ) ; } \n \n \t2 MBrickletIO16 bricklet = getMbrick ( ) ; \n \n \t2 if ( bricklet == null ) { \n \n <ect>
<comment> \n \n \t1 protected void handleException ( String thName , Throwable e ) { \n \n <ect>
\t3 final boolean errorsAboveThreshold = tidy . getParseErrors ( ) > getErrorThreshold ( ) ; \n \n \t3 final boolean warningsAboveThreshold = tidy . getParseWarnings ( ) > getWarningThreshold ( ) ; \n \n \t3 if ( errorsAboveThreshold \n \n \t5 || ( ! isErrorsOnly ( ) && warningsAboveThreshold ) ) { \n \n <ect>
\t2 if ( ! lowerBoundNested . getTypeArgument ( ) . equals ( Primate . class ) ) { \n \n \t3 log . info ( <string_literal> + lowerBoundNested . getTypeArgument ( ) ) ; \n \n \t3 result = false ; } \n \n \t2 if ( ! upperBoundNested . getTypeArgument ( ) . equals ( Primate . class ) ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( simpleQueryStringQuery ( <string_literal> ) . minimumShouldMatch ( <string_literal> ) ) . get ( ) ; \n \n \t2 assertHitCount ( searchResponse , 2L ) ; \n \n \t2 assertSearchHits ( searchResponse , <string_literal> , <string_literal> ) ; \n \n <ect>
\t5 } else { \n \n \t6 logger . error ( <string_literal> ) ; \n \n \t6 state = PairingInitialisationState . FINISHED ; } \n \n \t4 } else { \n \n <ect>
\t1 public void update ( final TicketDefinition metadata ) { \n \n \t2 register ( metadata ) ; } \n \n \t1 @ Override \n \n \t1 public boolean contains ( final String ticketId ) { \n \n <ect>
\t2 if ( refUri == null ) { \n \n \t3 LOG . warn ( <string_literal> , ref ) ; \n \n \t3 return null ; } \n \n \t2 if ( ! refUri . startsWith ( <string_literal> ) ) { \n \n <ect>
\t2 EnumPipePart side = EnumPipePart . fromMeta ( nbt . getByte ( <string_literal> ) ) ; \n \n \t2 IStatement statement = StatementManager . statements . get ( kind ) ; \n \n \t2 if ( statement instanceof IAction ) { \n \n \t3 return ActionWrapper . wrap ( statement , side . face ) ; } \n \n <ect>
\t5 throw new CloudException ( <string_literal> + e . getMessage ( ) , e ) ; } } \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t4 if ( performBackChannelLogout ( logoutRequest ) ) { \n \n \t5 logoutRequest . setStatus ( LogoutRequestStatus . SUCCESS ) ; \n \n \t4 } else { \n \n \t5 logoutRequest . setStatus ( LogoutRequestStatus . FAILURE ) ; \n \n <ect>
\t1 public void store ( Item item , String alias ) { \n \n \t2 if ( item . getState ( ) instanceof UnDefType ) { \n \n \t3 return ; } \n \n \t2 if ( ! isProperlyConfigured ) { \n \n <ect>
\t3 GossipRouter gossipRouter = new GossipRouter ( matcher . group ( 1 ) , Integer . parseInt ( matcher . group ( <number_literal> ) ) ) ; \n \n \t3 try { \n \n \t4 gossipRouter . start ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 cacheStats . incrementSize ( length ) ; \n \n \t4 cacheStats . incrementMemSize ( memWeigher . weigh ( id , uploadFile ) ) ; \n \n \t4 return Optional . of ( stage ( id , uploadFile ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 jobs . add ( new GridComputeJobAdapter ( i ) { \n \n \t5 @ GridLoggerResource private GridLogger log ; \n \n \t5 @ Override public Serializable execute ( ) throws GridException { \n \n <ect>
\t6 . from ( jsonFile ) \n \n \t6 . get ( InfoDTO . class ) ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 this . dto = new InfoDTO ( ) ; \n \n <ect>
\t4 _log . error ( <string_literal> + new String ( buf ) + <string_literal> ) ; } \n \n \t3 try { Thread . sleep ( <number_literal> * <number_literal> ) ; } catch ( InterruptedException ie ) { } \n \n \t3 s . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 } finally { \n \n \t4 org . apache . commons . io . IOUtils . closeQuietly ( is ) ; } \n \n \t3 String resString = p . getProperty ( <string_literal> ) ; \n \n \t3 if ( resString == null ) { \n \n <ect>
\t4 if ( state != State . Stopped && state != State . Destroyed ) { \n \n \t5 try { \n \n \t6 stopRouter ( router . getId ( ) , false ) ; \n \n \t5 } catch ( ResourceUnavailableException e ) { \n \n <ect>
\t3 CloudRuntimeException ex = new CloudRuntimeException ( <string_literal> ) ; \n \n \t3 ex . addProxyObject ( project , projectId , <string_literal> ) ; \n \n \t3 throw ex ; } } \n \n \t1 private boolean suspendProject ( ProjectVO project ) throws ConcurrentOperationException , ResourceUnavailableException { \n \n <ect>
\t3 final ByteArrayOutputStream byteArray = writeToByteArray ( this ) ; \n \n \t3 final KieFileSystem kieFileSystem = readFromByteArray ( byteArray ) ; \n \n \t3 return kieFileSystem ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t3 final long size = filePointer . size ( ) ; \t3 \n \n \t3 numberOfShards ++ ; \n \n \t3 if ( filePointer . size ( ) < = threshold ) { \n \n \t4 if ( numberOfShards % <number_literal> == 0 ) \n \n <ect>
\t2 try ( BackgroundIndexer indexer = new BackgroundIndexer ( <string_literal> , <string_literal> , client ( ) , extraDocs ) ) { \n \n \t3 logger . info ( <string_literal> , waitFor ) ; \n \n \t3 waitForDocs ( waitFor , indexer ) ; \n \n \t3 indexer . assertNoFailures ( ) ; \n \n <ect>
\t2 final DaemonContext daemonContext = info . getContext ( ) ; \n \n \t2 final byte [ ] token = info . getToken ( ) ; \n \n \t2 final State state = info . getState ( ) ; \n \n \t2 lock . lock ( ) ; \n \n <ect>
\t1 if ( effectiveDuration < 0 ) { \n \n \t1 logger . warn ( <string_literal> + scheduledFireTime + <string_literal> + this . duration \n \n \t2 + <string_literal> ) ; \n \n \t1 } else { \n \n <ect>
\t5 if ( ! fixed ) { \n \n \t6 throw new VetoCamelContextStartException ( <string_literal> + context . getName ( ) + <string_literal> + on + <string_literal> \n \n \t7 + <string_literal> , context ) ; \n \n \t5 } else { \n \n <ect>
\t5 return host ; } } \n \n \t3 try { \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t1 try { \n \n \t2 if ( null != s ) { \n \n \t2 s . close ( ) ; } \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t1 @ Inject \n \n \t1 private Logger log ; \n \n \t1 @ Override \n \n \t1 public Object aroundReadFrom ( ReaderInterceptorContext context ) throws IOException , WebApplicationException { \n \n <ect>
\t2 long time = action . getTime ( ) ; \n \n \t2 if ( action . verbose ) \n \n \t2 { \n \n <comment> \n \n <ect>
\t3 if ( ObjectHelper . isNotEmpty ( getPropertiesFile ( ) ) ) { \n \n \t4 InputStream reader = ResourceHelper . resolveMandatoryResourceAsInputStream ( getCamelContext ( ) , getPropertiesFile ( ) ) ; \n \n \t4 try { \n \n \t5 properties . load ( reader ) ; \n \n <ect>
\t2 assertEquals ( <string_literal> , \n \n \t3 ChatRoomMemberRole . MEMBER , roleEventUser2 . getPreviousRole ( ) ) ; \n \n \t2 assertEquals ( <string_literal> , \n \n \t3 ChatRoomMemberRole . SILENT_MEMBER , roleEventUser2 . getNewRole ( ) ) ; \n \n <ect>
public int sendAll ( Iterable < Observable < Integer > > batches , \n \n \t5 final int numMetrics , long timeoutMillis ) { \n \n \t1 final AtomicBoolean err = new AtomicBoolean ( false ) ; \n \n \t1 final AtomicInteger updated = new AtomicInteger ( 0 ) ; \n \n <ect>
\t1 return ( useHTTPS \n \n \t1 ? new SslServerSocketFactory ( sslClientAuth , SslParameters . createSslParameters ( sslParameterClassName , classLoader ) ) \n \n \t1 : new PlainServerSocketFactory ( ) ) . createServerSocket ( context . port ) ; } \n \n private void executeSingleCommand ( FitNesse fitNesse , String command , String outputFile ) throws Exception { \n \n <ect>
\t1 tr . commit ( ) ; \n \n \t1 } catch ( WalrusException e ) { \n \n \t1 throw e ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 return actionRelease ( userCms , resources ) ; \n \n \t3 } else { \n \n \t4 return super . executeAction ( userCms , action , options , resources ) ; } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t1 clientRpc . call ( new JobMetrics ( jobId , sparkJobId , stageId , taskId , metrics ) ) ; } \n \n \t1 private void handle ( ChannelHandlerContext ctx , CancelJob msg ) { \n \n \t1 JobWrapper < ? > job = activeJobs . get ( msg . id ) ; \n \n \t1 if ( job == null || ! cancelJob ( job ) ) { \n \n <ect>
\t5 logger . error ( <string_literal> , e ) ; \n \n \t5 if ( firstError == null ) { \n \n \t6 firstError = e ; } } \n \n \t4 try { \n \n <ect>
\t10 return false ; } \n \n \t8 writePermanentRedirect ( ctx , <string_literal> , path ( ) ) ; \n \n \t8 return true ; \n \n \t7 } catch ( IdentifierCollisionException e ) { \n \n <ect>
\t5 <comment> \n \n \t5 Thread . sleep ( <number_literal> ) ; \n \n \t5 return null ; } \n \n \t3 } ) ; } \n \n <ect>
\t1 if ( null != hdfsStream ) \n \n \t2 try { \n \n \t2 hdfsStream . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 return <string_literal> + quoteTableOrSchemaName ( schema ) + <string_literal> + quoteTableOrSchemaName ( tableName ) ; } \n \n @ Before \n \n public void setUp ( ) { \n \n \t1 super . setUp ( ) ; \n \n <ect>
\t1 public void recipient ( String recipient ) { \n \n \t2 log . info ( <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void data ( InputStream data ) { \n \n <ect>
\t3 persistentCache . setBroadcastConfig ( broadcastConfig ) ; } \n \n \t2 journalCache = builder . getJournalCache ( ) ; \n \n \t2 this . mbean = createMBean ( builder ) ; \n \n \t2 LOG . info ( <string_literal> , changeSetMaxItems , changeSetMaxDepth ) ; \n \n <ect>
\t3 final boolean result = caManager . deployCertificate ( vmHost , certificate , false , sshAccessDetails ) ; \n \n \t3 if ( ! result ) { \n \n \t4 s_logger . error ( <string_literal> + vm . getInstanceName ( ) ) ; } \n \n \t2 } else { \n \n <ect>
\t3 log . error ( <string_literal> , className , methodName , methodArgType . getSimpleName ( ) , e ) ; \n \n \t2 } catch ( InvocationTargetException e ) { \n \n \t3 log . error ( <string_literal> , className , methodName , methodArgType . getSimpleName ( ) , e ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n <ect>
\t3 argumentsAreValid = false ; \n \n \t3 logger . warn ( <string_literal> ) ; } \n \n \t2 if ( clearingMask == 0 ) { \n \n \t3 argumentsAreValid = false ; \n \n <ect>
\t2 if ( setting == null ) { \n \n \t3 LOGGER . warn ( <string_literal> { } \\ <string_literal> , id ) ; \n \n \t3 return false ; \n \n \t2 } else if ( setting . hasSubscribers ( ) ) { \n \n <ect>
\t3 if ( channel == null ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t1 Iterator < Input > iter = inputList . iterator ( ) ; \n \n \t1 while ( iter . hasNext ( ) ) { \n \n \t2 Input iterInput = iter . next ( ) ; \n \n \t2 if ( iterInput . equals ( input ) ) { \n \n <ect>
\t3 _curIndex ++ ; \n \n \t3 requeue ( 0 ) ; } } \n \n \t1 void replyVerified ( ) { \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t5 log . error ( <string_literal> , coreName , e ) ; \n \n \t5 try { \n \n \t6 coreContainer . shutdown ( ) ; \n \n \t5 } catch ( Exception se ) { \n \n <ect>
\t6 failed . set ( true ) ; \n \n \t6 throw err ; } } } \n \n \t3 @ Override \n \n \t3 public void onSend ( MQTTFrame frame ) { \n \n <ect>
\t5 if ( duration != null ) { \n \n \t6 s = <string_literal> + duration ; \n \n \t5 } else { \n \n \t6 s = <string_literal> ; } \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 rv . put ( key , de . dest . toBase64 ( ) ) ; \n \n \t5 i ++ ; } \n \n \t4 return rv ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t3 NetworkType zoneType = zone . getNetworkType ( ) ; \n \n \t3 if ( zoneType != NetworkType . Basic ) { \n \n \t4 publicTrafficLabel = _netmgr . getDefaultPublicTrafficLabel ( dcId , HypervisorType . VMware ) ; \n \n \t4 if ( publicTrafficLabel != null ) { \n \n <ect>
\t3 try { \n \n \t4 CmsResource res = cms . readResource ( m_editId ) ; \n \n \t4 cms . unlockResource ( res ) ; \n \n \t3 } catch ( CmsException e ) { \n \n <ect>
\t2 MockEndpoint mock = getMockEndpoint ( <string_literal> ) ; \n \n \t2 mock . expectedBodiesReceived ( <string_literal> ) ; \n \n \t2 template . sendBody ( <string_literal> , <string_literal> ) ; \n \n \t2 assertMockEndpointsSatisfied ( ) ; \n \n <ect>
\t5 config . setBundleLocation ( null ) ; } \n \n \t4 if ( old == null ) { \n \n \t5 log . info ( <string_literal> , pidString ) ; \n \n \t4 } else { \n \n <ect>
\t2 TestUnicastZenPing zenPingD = new TestUnicastZenPing ( hostsSettingsMismatch , threadPool , handleD , \n \n \t3 EMPTY_HOSTS_PROVIDER , ( ) - > stateD ) ; \n \n \t2 zenPingD . start ( ) ; \n \n \t2 closeables . push ( zenPingD ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public boolean matchesRole ( PublisherID desiredRole , PublisherPublicKeyDigest thisKey ) { \n \n \t2 if ( desiredRole . type ( ) != PublisherID . PublisherType . KEY ) { \n \n <ect>
\t3 synchronized ( _vms ) { \n \n \t4 _vms . put ( vm . getName ( ) , State . Migrating ) ; } \n \n \t3 return new PrepareForMigrationAnswer ( cmd ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 } ) ; \n \n \t3 } else { \n \n \t4 handleUnmappedAttribute ( attributesToRelease , entry . getKey ( ) , entry . getValue ( ) ) ; } \n \n \t2 } ) ; \n \n <ect>
\t2 continue \n \n \t1 if value != None : \n \n \t2 value_text = value . text if value . text else <string_literal> \n \n \t1 else : \n \n <ect>
\t1 HCatNotificationEvent n = task . getEvent ( ) ; \n \n \t1 LOG . info ( <string_literal> + n . getEventId ( ) \n \n \t2 + <string_literal> + n . getEventTime ( ) + <string_literal> + n . getEventType ( ) + <string_literal> + n . getDbName ( ) + <string_literal> + n . getTableName ( ) \n \n \t2 + <string_literal> + n . getEventScope ( ) ) ; \n \n <ect>
\t2 _log . debug ( getPrefix ( ) + <string_literal> + num ) ; \n \n \t3 for ( I2PTunnelTask t : tasks ) { \n \n \t4 int id = t . getId ( ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 if ( bindingConfig != null ) { \n \n \t3 HttpBindingConfig config = parseBindingConfig ( item , bindingConfig ) ; \n \n \t3 addBindingConfig ( item , config ) ; \n \n \t2 } else { \n \n <ect>
\t2 * @ throws InterruptedException \n \n \t2 ** / \n \n \t2 private void waitStateMessages ( ) throws NumberFormatException , IOException , InterruptedException { \n \n \t3 PrimareStatusUpdateEvent event = new PrimareStatusUpdateEvent ( this ) ; \n \n <ect>
\t4 Worker worker = new Worker ( backendListenerClient , ( Arguments ) getArguments ( ) . clone ( ) , listenerClientData ) ; \n \n \t4 worker . setDaemon ( true ) ; \n \n \t4 worker . start ( ) ; \n \n <ect>
\t2 final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; \n \n \t2 inputStream . setReadListener ( new ReadListener ( ) { \n \n \t3 @ Override \n \n \t3 public void onDataAvailable ( ) throws IOException { \n \n <ect>
\t2 loginSettingsPage . form ( ) . setVerifyEmailAllowed ( true ) ; \n \n \t2 assertTrue ( loginSettingsPage . form ( ) . isVerifyEmailAllowed ( ) ) ; \n \n \t2 loginSettingsPage . form ( ) . save ( ) ; \n \n \t2 assertAlertSuccess ( ) ; \n \n <ect>
\t3 if ( md != null ) \n \n \t4 loadBalancer . set ( md ) ; \n \n \t3 return true ; \n \n \t3 } catch ( IllegalStateException e ) { \n \n <ect>
\t2 try { \n \n \t3 final double hue = Integer . valueOf ( value . substring ( <number_literal> , <number_literal> ) ) ; \n \n \t3 return new PercentType ( new BigDecimal ( hue / 255d * 100d ) ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t2 String serverVersion ; \n \n \t2 try { \n \n \t3 serverVersion = client . getClient ( ) . getVersion ( ) ; \n \n \t2 } catch ( TException e ) { \n \n <ect>
\t1 LOG . debug ( <string_literal> , this ) ; \n \n \t1 return asRefinableView ( ) . newWriter ( ) ; } \n \n @ Override \n \n public DatasetReader < E > newReader ( ) { \n \n <ect>
\t6 LOGGER . debug ( <string_literal> , attr , s ) ; \n \n \t6 attributeMap . put ( s , CollectionUtils . wrap ( attr . getStringValues ( ) ) ) ; \n \n \t5 } ) ; } \n \n \t3 } else { \n \n <ect>
\t2 if ( result . equals ( <string_literal> ) ) { \n \n \t3 _context . waitForTaskProgressDone ( morTask ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t2 future2 . get ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 assertCacheIfPresent ( 0 , cache , f ) ; \n \n \t2 assertCacheStats ( cache , 1 , <number_literal> * <number_literal> , 1 , 1 ) ; \n \n <ect>
\t4 StringUtils . defaultIfBlank ( service . getSigningCredentialType ( ) , samlIdp . getResponse ( ) . getCredentialType ( ) . name ( ) ) . toUpperCase ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , credType , service ) ; \n \n \t3 switch ( credType ) { \n \n \t4 case BASIC : \n \n <ect>
\t2 _debugPageProvider = null ; } \n \n \t1 public boolean disabled ( ) { return object ( ) == null ; } \n \n \t1 public WOComponent debug ( ) { \n \n \t2 WOComponent result = null ; \n \n <ect>
\t2 for ( String lvConfigPart : lvConfigParts ) { \n \n \t3 parseMaxWarning ( lvConfigPart ) ; \n \n \t3 parseMinWarning ( lvConfigPart ) ; } \n \n \t2 if ( ! ( ivMaxWarningValue != null || ivMinWarningValue != null ) ) { \n \n <ect>
\t5 dag . getCredentials ( ) , tezJobConf ) ; \n \n \t3 log . info ( <string_literal> + dag . getName ( ) ) ; \n \n \t3 dagClient = tezClient . submitDAG ( dag ) ; \n \n \t3 appId = tezClient . getAppMasterApplicationId ( ) ; \n \n <ect>
\t3 currentPos = 0 ; \n \n \t3 previousByte = 0 ; } \n \n \t2 void markStart ( int position ) { \n \n \t3 if ( isStarted ( ) ) { \n \n <ect>
\t1 if ( rs != null ) { \n \n \t2 try { \n \n \t2 rs . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 { \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t2 assertTrue ( loginSettingsPage . form ( ) . isVerifyEmailAllowed ( ) ) ; \n \n \t2 loginSettingsPage . form ( ) . save ( ) ; \n \n \t2 assertAlertSuccess ( ) ; \n \n \t2 log . debug ( <string_literal> ) ; \n \n <ect>
\t2 } catch ( ResourceUnavailableException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . RESOURCE_UNAVAILABLE_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ConcurrentOperationException e ) { \n \n <ect>
\t2 SendableGet storeChecker ; \n \n \t2 Bucket data ; \n \n \t2 synchronized ( this ) { \n \n \t3 if ( cancelled ) Logger . error ( this , <string_literal> + this ) ; \n \n <ect>
\t4 } catch ( JMSException e ) { \n \n \t5 <comment> \n \n \t5 LOG . info ( <string_literal> , e ) ; } \n \n \t4 sendDoneLatch . countDown ( ) ; \n \n <ect>
\t2 try ( FileOutputStream fos = new FileOutputStream ( out ) ; \n \n \t4 BufferedOutputStream bos = new BufferedOutputStream ( fos ) ) { \n \n \t3 JOrphanUtils . write ( s . getResponseData ( ) , bos ) ; <comment> \n \n \t2 } catch ( FileNotFoundException e ) { \n \n <ect>
\t1 hostname = self . _config . get_hostname_config ( ) \n \n \t1 logger . info ( 'Starting Aggregator thread . ' ) \n \n \t1 cmd = <string_literal> \\ \n \n \t1 . format ( java_home , jvm_agrs , ams_log_dir , ams_log_file , additional_classpath , class_name , hostname , collector_hosts ) \n \n <ect>
\t4 if ( r != null ) { \n \n \t5 bos . writeRecord ( r , tag ) ; } \n \n \t4 baos . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 QueryExecution qexec = QueryExecutionFactory . create ( query , model ) ; \n \n \t2 try { \n \n \t3 ResultSet results = qexec . execSelect ( ) ; \n \n \t3 if ( ! results . hasNext ( ) ) \n \n <ect>
\t1 @ Override \n \n \t1 public void check ( final X509Certificate cert ) throws GeneralSecurityException { \n \n \t2 if ( cert == null ) { \n \n \t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n <ect>
\t1 void connect ( ) throws Exception { \n \n \t2 final Promise < Object > promise = new Promise < Object > ( ) ; \n \n \t2 connection . connect ( new Callback < Void > ( ) { \n \n \t3 public void onSuccess ( Void value ) { \n \n <ect>
\t2 } catch ( ResourceUnavailableException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . RESOURCE_UNAVAILABLE_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ConcurrentOperationException ex ) { \n \n <ect>
\t7 newId = newData . registerBlock ( frozen . iBlockRegistry . getRaw ( itemName ) , itemName , currId ) ; } \n \n \t6 else \n \n \t6 { \n \n \t7 newId = newData . registerItem ( frozen . iItemRegistry . getRaw ( itemName ) , itemName , currId ) ; } \n \n <ect>
Logger . info ( <string_literal> . format ( name ) ) \n \n ( success , source_file , dest_file , prepare_function ) = get_tarball_paths ( name , use_upgrading_version_during_upgrade , \n \n <number_literal> custom_source_file , custom_dest_file ) \n \n if not success : \n \n <ect>
\t3 if ( vmr . powerState == VmPowerState . RUNNING ) { \n \n \t4 try { \n \n \t5 vm . hardShutdown ( conn ) ; \n \n \t4 } catch ( final Exception e ) { \n \n <ect>
\t3 securityContext = SecurityContext . getInstance ( structrUser , AccessMode . Backend ) ; \n \n \t3 this . user = new StructrFtpUser ( securityContext , structrUser ) ; \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t1 logger . info ( <string_literal> ) ; \n \n \t1 Thread . sleep ( <number_literal> ) ; <comment> \n \n private static void createQueue ( String queueName , \n \n \t3 RestContext < AzureQueueClient , AzureQueueAsyncClient > nullLoggingDefaultContext ) { \n \n <ect>
\t3 for ( String test : tests ) { \n \n \t4 tester . addTest ( test ) ; } } \n \n \t2 tester . prepare ( ) ; \n \n \t2 if ( ! isOk ( ) ) { \n \n <ect>
\t7 String newMacSequence = generateMacSequence ( nics ) ; \n \n \t7 vmSpec . setBootArgs ( replaceNicsMacSequenceInBootArgs ( oldMacSequence , newMacSequence , vmSpec ) ) ; } } } } \n \n \t3 VirtualEthernetCardType nicDeviceType = VirtualEthernetCardType . valueOf ( vmSpec . getDetails ( ) . get ( VmDetailConstants . NIC_ADAPTER ) ) ; \n \n <ect>
\t1 } finally { \n \n \t2 try { \n \n \t3 FileSystem . closeAllForUGI ( clientUgi ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 String range = request . getHeader ( RANGE ) ; \n \n \t2 if ( nonNull ( range ) ) { \n \n \t3 <comment> \n \n \t3 if ( ! range . matches ( <string_literal> ) ) { \n \n <ect>
\t1 } catch ( WebApplicationException ex ) { \n \n \t1 LOG . error ( <string_literal> , ex ) ; \n \n \t1 throw ex ; \n \n \t1 } catch ( ItemNotFound itemNotFound ) { \n \n <ect>
\t1 <comment> \n \n \t1 public void shutdown ( ) { \n \n <ect>
\t2 int numStopped = 0 ; \n \n \t2 while ( connection != null && ! timer . hasExpired ( ) ) { \n \n \t3 try { \n \n \t4 seen . add ( connection . getDaemon ( ) . getUid ( ) ) ; \n \n <ect>
\t2 try { \n \n \t3 checker . readAndChecksum ( ois , salt , 0 , salt . length ) ; \n \n \t3 loaded . setSalt ( salt ) ; \n \n \t2 } catch ( ChecksumFailedException e1 ) { \n \n <ect>
\t2 } catch ( InterruptedException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 throw new CloudRuntimeException ( e . getMessage ( ) ) ; \n \n \t2 } catch ( ExecutionException e ) { \n \n <ect>
\t5 gceed = true ; \n \n \t4 } catch ( ConcurrentOperationException e ) { \n \n \t5 s_logger . warn ( <string_literal> + elbVm + <string_literal> , e ) ; \n \n \t4 } catch ( ResourceUnavailableException e ) { \n \n <ect>
\t3 if ( i % batchSize == 0 ) { \n \n \t4 producerThread . setMessagePriority ( HIGH_PRI ) ; \n \n \t4 producerThread . setMessageCount ( 1 ) ; \n \n \t4 producerThread . run ( ) ; \n \n <ect>
\t2 || ( options . getHivePartitionKey ( ) != null && hCatTable == null ) \n \n \t2 || ( options . getHivePartitionValue ( ) != null && hCatTable == null ) \n \n \t2 || ( options . getMapColumnHive ( ) . size ( ) > 0 && hCatTable == null ) ) ) { \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t4 long countValue = dbCounter . addAndGet ( - counter . get ( ) ) ; \n \n \t4 doCount = true ; \n \n \t4 long sumValue = dbSum . addAndGet ( - sum . get ( ) ) ; \n \n \t4 doSum = true ; \n \n <ect>
\t2 ZWaveStateConverter < ? , ? > converter = this . getStateConverter ( item , event . getValue ( ) ) ; \n \n \t2 logger . debug ( <string_literal> , event . getNodeId ( ) , item . getName ( ) , \n \n \t4 event . getValue ( ) ) ; \n \n \t2 if ( converter == null ) { \n \n <ect>
\t1 if ( hasOption ( <string_literal> ) ) { \n \n \t1 try { \n \n \t2 maxNGramSize = Integer . parseInt ( getOption ( <string_literal> ) ) ; \n \n \t1 } catch ( NumberFormatException ex ) { \n \n <ect>
\t1 if ( options . isValidationEnabled ( ) ) { \n \n \t2 validateExport ( tableName , conf , job ) ; } \n \n \t1 if ( isHCatJob ) { \n \n \t2 <comment> \n \n <ect>
\t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t3 _log . debug ( <string_literal> + peers . size ( ) + <string_literal> ) ; \n \n \t2 for ( RouterInfo peer : peers ) { \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t1 public void render ( ) { \n \n \t2 try { \n \n \t3 Runtime . getRuntime ( ) . exec ( <string_literal> + output + <string_literal> + output + <string_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 try { \n \n \t3 Connection conn = ConnectionFactory . createConnection ( conf ) ; \n \n \t3 super . table = ( HTable ) conn . getTable ( TableName . valueOf ( tableName ) ) ; \n \n \t2 } catch ( TableNotFoundException tnfe ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 connector . playerOpen ( newState . toString ( ) ) ; \n \n \t3 } else if ( property . equals ( <string_literal> ) ) { \n \n \t4 connector . applicationSetVolume ( newState . toString ( ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 StackConfiguration . CLIENT_POOL_MAX_THREADS , \n \n \t3 Threads . threadFactory ( <string_literal> ) \n \n \t2 ) ; \n \n \t2 OrderedShutdown . registerPostShutdownHook ( ( ) - > { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t3 <comment> \n \n \t3 try { \n \n \t4 cached = store . cache . get ( getIdentifier ( ) . toString ( ) ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
public void test ( ) throws Exception { \n \n \t1 final StopWatch watch = new StopWatch ( ) ; \n \n \t1 watch . start ( <string_literal> ) ; \n \n \t1 final List < ResourcePreProcessor > processors = loadProcessors ( ) ; \n \n <ect>
\t2 self . public_ip_range = PublicIpRange . create ( \n \n \t9 self . apiclient , \n \n \t9 self . services [ <string_literal> ] \n \n \t7 ) \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t2 WeightedMultigraph < Node , DefaultLink > g3 = step3 ( g2 ) ; \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t1 Mutation m = new Mutation ( <string_literal> ) ; \n \n \t1 m . put ( <string_literal> , <string_literal> , <string_literal> ) ; \n \n \t1 bw . addMutation ( m ) ; \n \n \t1 bw . close ( ) ; \n \n <ect>
\t4 flush ( ) ; \n \n \t4 bufferedWriter . close ( ) ; } \n \n \t3 catch ( IOException e ) \n \n \t3 { \n \n <ect>
\t2 } finally { \n \n \t3 closeAutoCloseable ( inputFile , <string_literal> ) ; } \n \n \t2 _mgmtCidr = configProps . getProperty ( <string_literal> ) ; \n \n \t2 _mgmtGateway = configProps . getProperty ( <string_literal> ) ; \n \n <ect>
\t4 try { \n \n \t5 subpartition . release ( ) ; } \n \n \t4 <comment> \n \n \t4 catch ( Throwable t ) { \n \n <ect>
\t2 if ( _log . shouldLog ( Log . WARN ) ) { \n \n \t3 if ( success ) \n \n \t4 _log . warn ( <string_literal> + port + <string_literal> + Addresses . toString ( ip , externalPort ) ) ; \n \n \t3 else \n \n <ect>
\t6 persistCompletion ( txid ) ; \n \n \t5 } catch ( Exception ex ) { \n \n \t6 LOG . error ( <string_literal> + txid , ex ) ; } } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 final SamlIdPProperties samlIdp = casProperties . getAuthn ( ) . getSamlIdp ( ) ; \n \n \t2 try { \n \n \t3 final SamlIdPResponseProperties . SignatureCredentialTypes credType = SamlIdPResponseProperties . SignatureCredentialTypes . valueOf ( \n \n \t4 StringUtils . defaultIfBlank ( service . getSigningCredentialType ( ) , samlIdp . getResponse ( ) . getCredentialType ( ) . name ( ) ) . toUpperCase ( ) ) ; \n \n <ect>
\t3 long [ ] stats = getNetworkStats ( conn , cmd . getPrivateIP ( ) ) ; \n \n \t3 NetworkUsageAnswer answer = new NetworkUsageAnswer ( cmd , <string_literal> , stats [ 0 ] , stats [ 1 ] ) ; \n \n \t3 return answer ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 if ( onFailedLookupJob != null ) \n \n \t4 _context . jobQueue ( ) . addJob ( onFailedLookupJob ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t3 try { \n \n \t4 CallContext . current ( ) . setEventDetails ( <string_literal> + getEntityId ( ) ) ; \n \n \t4 result = _userVmService . startVirtualMachine ( this ) ; \n \n \t3 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t2 final boolean requireServiceHeader = oAuthProperties . getGrants ( ) . getResourceOwner ( ) . isRequireServiceHeader ( ) ; \n \n \t2 if ( requireServiceHeader ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; } \n \n \t2 final Service service = this . authenticationBuilder . buildService ( registeredService , context , requireServiceHeader ) ; \n \n <ect>
\t3 do { \n \n \t4 logFiles = bdb_env . cleanLog ( ) ; \n \n \t4 totalLogFiles += logFiles ; } \n \n \t3 while ( logFiles > 0 ) ; \n \n <ect>
\t5 LOG . debug ( <string_literal> ) ; \n \n \t5 gen . setOriginatorInfo ( originatorInformation ) ; } } \n \n \t3 AttributesGeneratorProvider attributeGeneratorProvider = conf . getUnprotectedAttributesGeneratorProvider ( ) ; \n \n \t3 if ( attributeGeneratorProvider != null ) { \n \n <ect>
\t1 String sqoopJar = Jars . getSqoopJarPath ( ) ; \n \n \t1 if ( null != sqoopJar ) { \n \n \t1 sqoopJar = File . pathSeparator + sqoopJar ; \n \n \t1 } else { \n \n <ect>
\t2 switch ( event . getState ( ) ) { \n \n \t2 case SyncConnected : \n \n \t3 break ; \n \n \t2 default : \n \n <ect>
\t3 return ; \n \n \t2 if ( serverConfig . quiet ) \n \n \t3 return ; \n \n \t2 Logger log = Fuseki . serverLog ; \n \n <ect>
\t3 String current = browser . getWindowHandle ( ) ; \n \n \t3 for ( String handle : browser . getWindowHandles ( ) ) { \n \n \t4 if ( ! handle . equals ( browser . getWindowHandle ( ) ) ) { \n \n \t5 browser . switchTo ( ) . window ( handle ) ; \n \n <ect>
\t3 result = getContentReferenceUrisForDetachedCase ( message , messageBodyNode ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n \t3 throw new IllegalStateException ( <string_literal> + signatureType + <string_literal> ) ; } \n \n <ect>
\t1 public Void apply ( final Collection < File > files ) { \n \n \t2 if ( baseNameFolder == null ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 writeProcessEvent . fire ( <string_literal> ) ; \n \n \t2 if ( book == null ) { \n \n \t3 throw new WebApplicationException ( Response . Status . NOT_FOUND ) ; } \n \n <ect>
\t2 if ( client != null ) { \n \n \t2 try { \n \n \t3 client . close ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
<comment> \n \n \t1 public ResultsLogger ( Date startDt ) { \n \n <ect>
public void onCachePeriodChanged ( final long period ) { \n \n \t1 try { \n \n \t1 managerInitializer . get ( ) . onCachePeriodChanged ( period ) ; \n \n \t1 } catch ( final WroRuntimeException e ) { \n \n <ect>
\t3 this . projectorWriter = new PrintWriter ( this . projectorSocket . getOutputStream ( ) , true ) ; \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 return true ; \n \n \t2 } catch ( UnknownHostException e ) { \n \n <ect>
\t3 Element rootElement = doc . getDocumentElement ( ) ; \n \n \t3 for ( int i = 0 ; i < tagNames . length ; i ++ ) { \n \n \t4 NodeList targetNodes = rootElement . getElementsByTagName ( tagNames [ i ] ) ; \n \n \t4 if ( targetNodes . getLength ( ) < = 0 ) { \n \n <ect>
\t1 protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { \n \n \t2 int length = in . readInt ( ) ; \n \n \t2 switch ( in . readByte ( ) ) { \n \n \t3 case Messages . HEADER_RECORD : \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t1 private static Cache < String , Map < Long , Long > > cuboidRecommendCache = CacheBuilder . newBuilder ( ) \n \n \t3 . removalListener ( new RemovalListener < String , Map < Long , Long > > ( ) { \n \n \t4 @ Override \n \n \t4 public void onRemoval ( RemovalNotification < String , Map < Long , Long > > notification ) { \n \n <ect>
\t4 applicationVersion = Integer . toString ( serialMessage . getMessagePayloadByte ( offset + <number_literal> ) ) + <string_literal> \n \n \t6 + Integer . toString ( serialMessage . getMessagePayloadByte ( offset + <number_literal> ) ) ; \n \n \t4 logger . debug ( <string_literal> , this . getNode ( ) . getNodeId ( ) , libraryType . key , \n \n \t6 libraryType . label ) ; \n \n <ect>
\t2 if ( freeClusterResources . totalFreeMemory < totalMemoryRequired ) { \n \n \t3 LOG . warn ( <string_literal> + totalMemoryRequired + <string_literal> \n \n \t4 + <string_literal> + freeClusterResources . totalFreeMemory + <string_literal> + noteRsc ) ; } \n \n \t2 if ( taskManagerMemoryMb > freeClusterResources . containerLimit ) { \n \n <ect>
\t3 result . add ( co ) ; \n \n \t3 for ( int i = co . name ( ) . count ( ) - 1 ; i > count ; i -- ) { \n \n \t4 result . addAll ( enumerate ( new Interest ( co . name ( ) . cut ( i ) ) , timeout ) ) ; } \n \n \t3 query = Interest . next ( co . name ( ) , count , null ) ; } \n \n <ect>
\t2 if ( skip ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t2 } else if ( testClass . isAnnotationPresent ( UseAdviceWith . class ) ) { \n \n \t3 if ( testClass . getAnnotation ( UseAdviceWith . class ) . value ( ) ) { \n \n <ect>
<comment> \n \n \t1 private void convertLangMatches ( E_LangMatches expr ) \n \n \t1 { \n \n <ect>
\t2 this . principalElectionStrategy = principalElectionStrategy ; } \n \n \t1 @ Override \n \n \t1 public Optional < Authentication > getInitialAuthentication ( ) { \n \n \t2 if ( this . authentications . isEmpty ( ) ) { \n \n <ect>
\t4 for ( int i = 0 ; i < _keyref . length ; i ++ ) { \n \n \t5 if ( _keyref [ i ] < 0 || _keyref [ i ] >= _objectTable . size ( ) ) { \n \n \t6 log . error ( <string_literal> , i , _objectTable . size ( ) ) ; \n \n \t5 } else if ( _objectTable . get ( _keyref [ i ] ) == this ) { \n \n <ect>
\t4 if ( e instanceof MessagingException && ( ( MessagingException ) e ) . getFailedMessage ( ) == null ) { \n \n \t5 throw new MessagingException ( message , <string_literal> , e ) ; } \n \n \t4 throw e ; } \n \n <ect>
\t3 final Optional < MultifactorAuthenticationProvider > providerFound = resolveProvider ( providerMap , values . get ( 0 ) ) ; \n \n \t3 if ( providerFound . isPresent ( ) ) { \n \n \t4 final MultifactorAuthenticationProvider provider = providerFound . get ( ) ; \n \n \t4 if ( provider . isAvailable ( service ) ) { \n \n <ect>
\t2 if ( rService == null || ! rService . getAccessStrategy ( ) . isServiceAccessAllowed ( ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , service , getDefaultThemeName ( ) ) ; \n \n \t3 return rememberThemeName ( request ) ; } \n \n \t2 if ( StringUtils . isBlank ( rService . getTheme ( ) ) ) { \n \n <ect>
\t5 JoinRsp join_rsp = Util . streamableFromBuffer ( JoinRsp : : new , msg . getRawBuffer ( ) , msg . getOffset ( ) , msg . getLength ( ) ) ; \n \n \t5 View new_view = join_rsp != null ? join_rsp . getView ( ) : null ; \n \n \t5 return new_view != null ? new_view . getCoord ( ) : null ; } \n \n \t4 catch ( Throwable t ) { \n \n <ect>
@ Test ( expected = EventDeliveryException . class ) \n \n public void testUnknownServerBatch ( ) throws FlumeException , \n \n \t1 EventDeliveryException { \n \n \t1 RpcTestUtils . handlerBatchAppendTest ( new UnknownAvroHandler ( ) ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public boolean createPrivateGateway ( PrivateGateway gateway ) \n \n \t3 throws ConcurrentOperationException , ResourceUnavailableException { \n \n \t2 <comment> \n \n <ect>
\t6 gitSourceSecretName = sourceSecret . getName ( ) ; } } } \n \n \t3 if ( ! foundExistingGitUrl ) { \n \n \t4 log . warn ( <string_literal> + buildConfig ) ; } \n \n \t3 log . info ( <string_literal> + gitSourceSecretName ) ; } \n \n <ect>
\t6 stmt . setString ( <number_literal> , value ) ; \n \n \t6 stmt . execute ( ) ; \n \n \t6 stmt . close ( ) ; \n \n \t5 } catch ( SQLException ex ) { \n \n <ect>
\t4 } catch ( CmsException e2 ) { \n \n \t5 LOG . info ( <string_literal> ) ; \n \n \t5 ouName = m_parentOU + siteRootResource . getName ( ) ; } \n \n \t3 } catch ( CmsException e ) { \n \n <ect>
<comment> \n \n \t1 static void flush ( Session session , boolean synch ) throws DataAccessException { \n \n \t2 if ( synch ) { \n \n <ect>
\t2 return repositoryCache ( ) . createSession ( context , systemWorkspaceName ( ) , readOnly ) ; } \n \n \t1 protected final TransactionManager transactionManager ( ) { \n \n \t2 return runningState ( ) . txnManager ( ) ; } \n \n \t1 protected final void prepareToRestore ( ) throws RepositoryException { \n \n <ect>
\t6 . stream ( ) \n \n \t6 . map ( a - > { \n \n \t7 Object value = null ; \n \n \t7 final TypedAttributeValue attributeValue = a . getValue ( ) ; \n \n <ect>
\t1 protected final void completeRestore ( RestoreOptions options ) throws ExecutionException , Exception { \n \n \t2 if ( getState ( ) == State . RESTORING ) { \n \n \t3 logger . debug ( <string_literal> , getName ( ) ) ; \n \n \t3 doShutdown ( false ) ; \n \n <ect>
\t4 Configuration conf = TezUtils . createConfFromUserPayload ( payload ) ; \n \n \t4 vertexStats . setConf ( conf ) ; \n \n \t4 VertexStatus status = tezJob . getVertexStatus ( v . getName ( ) ) ; \n \n \t4 if ( status == null ) { \n \n <ect>
\t2 public Object body ; \n \n \t2 public List < User > users ; \n \n \t2 public void myMethod ( @ Header ( value = <string_literal> ) List < User > users , Object body ) { \n \n \t3 LOG . info ( <string_literal> + this ) ; \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 @ Override public Map < UUID , Integer > reduce ( List < GridComputeJobResult > results ) throws GridException { \n \n \t2 Map < UUID , Integer > ret = U . newHashMap ( results . size ( ) ) ; \n \n \t2 for ( GridComputeJobResult res : results ) { \n \n <ect>
\t4 locUpdate = req ; } \n \n \t3 else { \n \n \t4 try { \n \n <ect>
\t5 vmInstanceIds . add ( vm . getId ( ) ) ; } \n \n \t4 txn . commit ( ) ; \n \n \t4 if ( ! vmInstanceIds . isEmpty ( ) ) { \n \n \t5 _lb2VmMapDao . remove ( loadBalancer . getId ( ) , vmInstanceIds , null ) ; \n \n <ect>
\t2 { \n \n \t3 socket . setKeepAlive ( this . keepAlive ) ; } \n \n \t2 catch ( SocketException se ) \n \n \t2 { \n \n <ect>
\t3 Class appClz = null ; \n \n \t3 try { \n \n \t4 appClz = loader . loadClass ( application . trim ( ) ) ; \n \n \t3 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t1 } catch ( IOException e ) { \n \n \t1 throw new RuntimeException ( e ) ; } } \n \n private Collection < TestBatch > parse ( ) throws IOException { \n \n \t1 RootConfig rootConfig = getRootConfig ( unitRootContext ) ; \n \n <ect>
\t3 if ( StringUtils . isNotBlank ( this . loginConf ) ) { \n \n \t4 LOGGER . warn ( <string_literal> , this . loginConf ) ; } \n \n \t2 } else { \n \n \t3 final String loginConf = StringUtils . isBlank ( this . loginConf ) ? DEFAULT_LOGIN_CONFIG : this . loginConf ; \n \n <ect>
\t3 List < JpaPersistentItem > result = query . getResultList ( ) ; \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 List < HistoricItem > historicList = JpaHistoricItem . fromResultList ( result , item ) ; \n \n \t3 if ( historicList != null ) { \n \n <ect>
\t5 eo . takeValueForKey ( val , key ) ; } \n \n \t4 NSArray relsUsingAttrib = ERXEOAccessUtilities . relationshipsForAttribute ( entity , attrib ) ; \n \n \t4 relationships . addObjectsFromArray ( relsUsingAttrib ) ; \n \n \t3 } else { \n \n <ect>
\t3 } else { \n \n \t3 token . getEbsVolumes ( ) . put ( attachment . getDevice ( ) , volume ) ; } } \n \n \t2 <comment> \n \n \t2 if ( ! foundRoot ) { \n \n <ect>
\t2 if ( networkId != null ) { \n \n \t3 if ( ip . getSystem ( ) ) { \n \n \t4 CallContext ctx = CallContext . current ( ) ; \n \n \t4 if ( ! disassociatePublicIpAddress ( ip . getId ( ) , ctx . getCallingUserId ( ) , ctx . getCallingAccount ( ) ) ) { \n \n <ect>
\t1 public Map getConfiguration ( final HttpServletRequest request , final HttpServletResponse response ) { \n \n \t2 final Map results = new TreeMap ( ) ; \n \n \t2 ensureEndpointAccessIsAuthorized ( request , response ) ; \n \n \t2 if ( environmentEndpoint == null || ! environmentEndpoint . isEnabled ( ) ) { \n \n <ect>
<comment> \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 public void reindexEntities ( final Class entityClass , final FullTextSession search ) \n \n \t1 { \n \n <ect>
\t2 @ GridLoggerResource private GridLogger log ; \n \n \t2 <comment> \n \n \t2 @ Override public Serializable execute ( ) throws GridException { \n \n <ect>
\t3 if ( bclass . getCustomMapping ( ) != null ) { \n \n \t4 this . customMappingFiles . add ( docinfo ) ; } \n \n \t3 return true ; \n \n \t2 } catch ( ExcludeDocumentException e ) { \n \n <ect>
\t1 reply . setByteRangeStart ( request . getByteRangeStart ( ) ) ; \n \n \t1 reply . setByteRangeEnd ( request . getByteRangeEnd ( ) ) ; \n \n \t1 return reply ; \n \n \t1 } catch ( AmazonServiceException e ) { \n \n <ect>
\t5 MessageHelper . infoString ( persister , event . getEntityId ( ) , event . getSession ( ) . getFactory ( ) ) \n \n \t3 ) ; } \n \n \t2 Object entity = loadFromSessionCache ( event , keyToLoad , options ) ; \n \n \t2 if ( entity == REMOVED_ENTITY_MARKER ) { \n \n <ect>
\t2 try { \n \n \t3 estimatedSizes = FileUtil . estimateSizes ( acuConf , entry . getKey ( ) , \n \n \t4 mapFileSizes . get ( entry . getKey ( ) ) , extentsOf ( entry . getValue ( ) ) , conf , vm ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 videoEncoder . finish ( ) . onSuccess { \n \n \t3 case fileName = > \n \n \t3 ReplayHandler . handleNewReplay ( fileName , lastMatch ) . onSuccess { \n \n \t4 case name = > \n \n <ect>
\t1 private int count = 0 ; \n \n \t1 public void flush ( ) { \n \n \t2 if ( msg != null ) { \n \n \t3 if ( count > 1 ) { \n \n <ect>
\t3 log . info ( <string_literal> ) ; } \n \n \t2 if ( forceCheckpoints ) { \n \n \t3 log . info ( <string_literal> ) ; } \n \n \t2 if ( ADD_SECONDARY_METADATA ) { \n \n <ect>
\t4 assignmentVersion = new HashMap < > ( ) ; } \n \n \t3 Map < String , Assignment > assignments = ( Map < String , Assignment > ) localState . get ( Common . LS_LOCAl_ZK_ASSIGNMENTS ) ; \n \n \t3 if ( assignments == null ) { \n \n \t4 assignments = new HashMap < > ( ) ; } \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t2 try { \n \n \t3 queue . add ( buffer ) ; \n \n \t2 } catch ( IllegalStateException ie ) { \n \n \t3 <comment> \n \n <ect>
\t3 try { \n \n \t4 if ( akmReader . ready ( ) ) { \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t5 String line = akmReader . readLine ( ) ; \n \n <ect>
\t2 throws Exception { \n \n \t2 Exchange exchange = getEndpoint ( ) . createExchange ( ) ; \n \n \t2 exchange . getIn ( ) . setHeaders ( properties ) ; \n \n \t2 exchange . getIn ( ) . setBody ( inputStream ) ; \n \n <ect>
\t2 for ( String line : new FileLineIterable ( in ) ) { \n \n \t2 try { \n \n \t3 result . add ( Long . parseLong ( line ) ) ; \n \n \t2 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t1 @ Override \n \n \t1 public Iterable < HistoricItem > query ( FilterCriteria filter ) { \n \n \t2 logger . debug ( <string_literal> , filter . getItemName ( ) ) ; \n \n \t2 if ( ! JpaConfiguration . isInitialized ) { \n \n <ect>
<comment> \n \n public Sqoop ( SqoopTool tool , Configuration conf , SqoopOptions opts ) { \n \n <ect>
\t5 System . err . println ( <string_literal> + version + <string_literal> + toString + <string_literal> + temp + <string_literal> ) ; \n \n \t4 <comment> \n \n \t4 } else if ( e . newURI != null ) { \n \n \t5 temp . delete ( ) ; \n \n <ect>
\t3 Command command = commands . get ( commandKey ) ; \n \n \t3 if ( command != null ) { \n \n \t4 if ( request . getMethod ( ) . equals ( <string_literal> ) ) { \n \n <ect>
\t8 file . getParentFile ( ) . mkdirs ( ) ; \n \n \t8 Files . copy ( resourceStream , file . toPath ( ) ) ; \n \n \t8 success = true ; } } } \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t4 clazz = classLoader . loadClass ( className ) ; \n \n \t3 } catch ( ClassNotFoundException ex ) { \n \n \t4 if ( FALL_BACK ) { \n \n \t5 <comment> \n \n <ect>
\t1 @ Override \n \n \t1 public void doDeleteOldMessages ( TransactionContext c ) throws SQLException , IOException { \n \n \t2 PreparedStatement s = null ; \n \n \t2 try { \n \n <ect>
\t2 CountDownLatch latch ; \n \n \t2 public LatchChildWatcher ( ) { \n \n \t3 latch = new CountDownLatch ( 1 ) ; } \n \n \t2 public void process ( WatchedEvent event ) { \n \n <ect>
\t1 public void testLoadTestJdbcAggregate ( ) throws Exception { \n \n \t2 MockEndpoint mock = getMockEndpoint ( <string_literal> ) ; \n \n \t2 mock . expectedMinimumMessageCount ( 1 ) ; \n \n \t2 mock . setResultWaitTime ( <number_literal> * <number_literal> ) ; \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 throw new RuntimeException ( e ) ; } } } \n \n \t2 } ) ; \n \n \t2 internalCluster ( ) . client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( index , shard , nodeFrom , nodeTo ) ) . get ( ) ; \n \n <ect>
\t2 setup ( <number_literal> , <string_literal> ) ; \n \n \t2 setup ( <number_literal> , <string_literal> ) ; } \n \n \t1 static void setup ( int idx , String unitName ) { \n \n \t2 if ( names . containsKey ( unitName ) ) \n \n <ect>
\t1 private static final Logger logger = LoggerFactory . getLogger ( ServerInfoRequestHandler . class ) ; \n \n \t1 private volatile ServerInfoMessage serverInfo ; \n \n \t1 @ Override \n \n \t1 public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) { \n \n <ect>
\t4 this . reTxMsg = msg ; \n \n \t4 this . reTxState = state ; } \n \n \t3 state = PairingInitialisationState . RETX_WAKEUP_ACK ; \n \n \t2 } else { \n \n <ect>
\t2 UTMaster master = createMaster ( i ) ; \n \n \t2 logger . info ( <string_literal> , i ) ; \n \n \t2 ebeanServer . save ( master ) ; \n \n \t2 <comment> \n \n <ect>
\t4 unsafeUnavailabilityCause = ( Throwable ) maybeUnsafe ; \n \n \t4 logger . debug ( <string_literal> , ( Throwable ) maybeUnsafe ) ; \n \n \t3 } else { \n \n \t4 unsafe = ( Unsafe ) maybeUnsafe ; \n \n <ect>
\t3 { \n \n \t4 ColumnDef cDef = new ColumnDef ( ) ; \n \n \t4 String columnName = def . name . toString ( ) ; \n \n \t4 String type = def . type . toString ( ) ; \n \n <ect>
\t3 return false ; \n \n \t2 } catch ( UnsupportedProtocolVersionException e ) { \n \n \t3 <comment> \n \n \t3 open . decrementAndGet ( ) ; \n \n <ect>
\t3 parkNanos ( MILLISECONDS . toNanos ( <number_literal> ) ) ; } \n \n \t2 try \n \n \t2 { \n \n \t3 InstanceId myId = config . get ( ClusterSettings . server_id ) ; \n \n <ect>
\t3 catch ( JMSException ex ) { \n \n \t4 logger . debug ( <string_literal> , ex ) ; } \n \n \t3 catch ( Throwable ex ) { \n \n \t4 <comment> \n \n <ect>
\t5 { \n \n \t6 if ( ! inmsg . equals ( outmsg ) ) { \n \n \t7 if ( _log . shouldLog ( Log . WARN ) ) { \n \n \t8 _log . warn ( <string_literal> + outmsg ) ; \n \n <ect>
\t4 dcmd = new DownloadProgressCommand ( dcmd , volumeHost . getJobId ( ) , RequestType . GET_OR_RESTART ) ; \n \n \t4 dcmd . setResourceType ( ResourceType . VOLUME ) ; } \n \n \t3 EndPoint ep = _epSelector . select ( volume ) ; \n \n \t3 if ( ep == null ) { \n \n <ect>
\t4 if ( shardRouting . getIndexName ( ) . equals ( <string_literal> ) && shardRouting . shardId ( ) . getId ( ) == 0 ) { \n \n \t5 return byteSize ; } \n \n \t4 return null ; } \n \n \t2 } ) ; \n \n <ect>
\t9 . build ( ) ; \n \n \t7 try { \n \n \t8 sched . scheduleJob ( job , trigger ) ; \n \n \t7 } catch ( SchedulerException e ) { \n \n <ect>
\t2 String response = HttpUtil . executeUrl ( <string_literal> , url , headers , null , null , HTTP_REQUEST_TIMEOUT ) ; \n \n \t2 if ( response == null ) { \n \n \t3 logger . error ( <string_literal> , url ) ; \n \n \t2 } else { \n \n <ect>
\t5 return dummyRes ; } \n \n \t3 } , <number_literal> , <string_literal> ) ; } \n \n \t2 try { \n \n \t3 for ( int i = 0 ; i < iters ; i ++ ) { \n \n <ect>
\t1 getContext ( ) . evaluateReader ( scope , new InputStreamReader ( stream ) , sourceName , 1 , null ) ; \n \n \t1 return this ; \n \n \t1 } catch ( final RhinoException e ) { \n \n \t1 if ( e instanceof RhinoException ) { \n \n <ect>
\t2 @ Override \n \n \t2 public void onError ( AsyncEvent event ) { \n \n \t3 logger . trace ( <string_literal> , event . getAsyncContext ( ) . getResponse ( ) ) ; \n \n \t3 if ( p == null ) { \n \n <ect>
\t3 log . error ( <string_literal> , e ) ; \n \n \t3 return - <number_literal> ; } \n \n \t2 String rsrcVal = new String ( bytes ) . trim ( ) ; \n \n <ect>
\t2 long oldNow = now ; \n \n \t2 <comment> \n \n \t2 now = System . currentTimeMillis ( ) ; \n \n \t2 if ( ( now - oldNow ) > SECONDS . toMillis ( <number_literal> ) ) \n \n <ect>
\t1 private boolean connect ( ) { \n \n \t2 try { \n \n \t3 clientSocket = new Socket ( host , cliPort ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 @ ActionDoc ( text = <string_literal> ) \n \n \t1 static public boolean sendTelegram ( @ ParamDoc ( name = <string_literal> ) String group , \n \n \t9 @ ParamDoc ( name = <string_literal> ) String message ) { \n \n \t2 if ( groupTokens . get ( group ) == null ) { \n \n <ect>
\t1 { \n \n \t2 log . error ( <string_literal> , e ) ; } \n \n \t1 catch ( InstanceAlreadyExistsException e ) \n \n \t1 { \n \n <ect>
\t3 } else if ( nic . getTrafficType ( ) == TrafficType . Control && nic . getIp4Address ( ) != null ) { \n \n \t4 controlNic = nic ; } } \n \n \t2 if ( controlNic == null ) { \n \n \t3 if ( managementNic == null ) { \n \n <ect>
\t3 } catch ( InterruptedException e ) { \n \n \t4 logger . warn ( <string_literal> ) ; \n \n \t4 break ; } \n \n \t3 if ( ! isComplete ( ) ) { \n \n <ect>
\t2 synchronized ( trackers ) { \n \n \t3 for ( Entry < String , Tracker > t : trackers . entrySet ( ) ) { \n \n \t4 LOG . info ( <string_literal> + t . getKey ( ) + <string_literal> + t . getValue ( ) . size ( ) + <string_literal> ) ; \n \n \t4 for ( Trace trace : t . getValue ( ) . values ( ) ) { \n \n <ect>
\t3 final OtpErlangTuple replyMsg = OtpErlang \n \n \t5 . mkTuple ( new OtpErlangAtom ( <string_literal> ) , replyAs , reply ) ; \n \n \t3 mbox . send ( from , replyMsg ) ; \n \n \t2 } else { \n \n <ect>
\t3 while ( ( bytesRead = cipherInputStream . read ( buf ) ) >= 0 ) { \n \n \t4 outputStream . write ( buf , 0 , bytesRead ) ; } \n \n \t3 return outputStream . toByteArray ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 else \n \n \t7 sess = MessageWrapper . generateSession ( getContext ( ) ) ; \n \n \t6 if ( sess != null ) { \n \n \t7 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t3 PublicKey publicKey = AdapterRSATokenVerifier . getPublicKey ( input . getHeader ( ) . getKeyId ( ) , deployment ) ; \n \n \t3 if ( RSAProvider . verify ( input , publicKey ) ) { \n \n \t4 return input ; } \n \n \t2 } catch ( JWSInputException ignore ) { } \n \n <ect>
\t2 conn . setClientID ( <string_literal> ) ; \n \n \t2 Session session = conn . createSession ( false , 1 ) ; \n \n \t2 Destination dest = session . createTopic ( topicName ) ; \n \n \t2 TopicSubscriber sub = session . createDurableSubscriber ( ( Topic ) dest , subName ) ; \n \n <ect>
\t1 @ Override \n \n \t1 @ DB \n \n \t1 public boolean stop ( ) { \n \n <ect>
\t1 upload . setObjectModifiedTimestamp ( response . getLastModified ( ) ) ; \n \n \t1 upload . setUploadId ( response . getUploadId ( ) ) ; \n \n \t1 LOG . trace ( <string_literal> + response . getStatusMessage ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 allPercentiles . put ( \n \n \t7 METRIC_ALL_PERCENTILE_PREFIX + sanitizedFormattedPercentile , \n \n \t7 percentileValue ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 if ( ! hasBeenSet ) { \n \n \t4 hasBeenSet = true ; \n \n \t4 framework . setWebsocketProcessorClassName ( annotatedClass . getName ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t1 public static FailoverStrategy . Factory loadFailoverStrategy ( Configuration config , @ Nullable Logger logger ) { \n \n \t2 final String strategyParam = config . getString ( JobManagerOptions . EXECUTION_FAILOVER_STRATEGY ) ; \n \n \t2 if ( StringUtils . isNullOrWhitespaceOnly ( strategyParam ) ) { \n \n \t3 if ( logger != null ) { \n \n <ect>
\t4 sink . closed ( ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t5 _log . debug ( <string_literal> + sink . getConnectionId ( ) + <string_literal> + sink . getDestination ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t1 Set < String > wals = new HashSet < > ( ) ; \n \n \t1 for ( Entry < Key , Value > entry : s ) { \n \n \t2 LogEntry logEntry = LogEntry . fromKeyValue ( entry . getKey ( ) , entry . getValue ( ) ) ; \n \n \t2 wals . add ( new Path ( logEntry . filename ) . toString ( ) ) ; } \n \n <ect>
\t3 this . nodeId = nodeId ; \n \n \t3 this . controller = controller ; } \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n <ect>
\t5 return ; } \n \n \t4 try { \n \n \t5 <comment> \n \n \t5 List < AccountVO > removedAccounts = _accountDao . findCleanupsForRemovedAccounts ( null ) ; \n \n <ect>
\t2 Short configTimeout = Short . valueOf ( configValue ) ; \n \n \t2 if ( null == timeout || configTimeout > timeout ) { \n \n \t3 timeout = configTimeout ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 _log . warn ( <string_literal> + _config . getSendTo ( ) \n \n \t7 + <string_literal> + _config + <string_literal> + _msg ) ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 break ; \n \n \t3 if ( respectTombstoneThresholds ( ) && columnCounter . ignored ( ) > DatabaseDescriptor . getTombstoneFailureThreshold ( ) ) \n \n \t3 { \n \n \t4 Tracing . trace ( <string_literal> , DatabaseDescriptor . getTombstoneFailureThreshold ( ) ) ; \n \n <ect>
\t4 continue ; } \n \n \t3 long bytesCopied = IOUtils . copyLarge ( in , output ) ; \n \n \t3 LOG . info ( <string_literal> , path , bytesCopied ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 String mgtCidr = _configDao . getValue ( Config . ManagementNetwork . key ( ) ) ; \n \n \t2 if ( mgtCidr == null || mgtCidr . trim ( ) . isEmpty ( ) ) { \n \n \t3 String [ ] localCidrs = NetUtils . getLocalCidrs ( ) ; \n \n \t3 if ( localCidrs . length > 0 ) { \n \n <ect>
\t3 } else { \n \n \t4 s_logger . debug ( <string_literal> + hostId + <string_literal> ) ; \n \n \t4 return false ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 catch ( Throwable t ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 ExceptionUtils . rethrowIfFatalErrorOrOOM ( t ) ; \n \n <ect>
\t1 <comment> \n \n \t1 try { \n \n \t2 results = executor . invokeAll ( tasks . values ( ) , <number_literal> , TimeUnit . MINUTES ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t2 if ( event . isEmpty ( ) ) { \n \n \t2 logger . info ( <string_literal> , serverName ) ; \n \n \t2 } else { \n \n \t2 event . writeFile ( profilingFile + <string_literal> + serverName ) ; \n \n <ect>
\t5 downloader . downloadSnapshot ( addressProvider ) ; \n \n \t5 break ; } \n \n \t4 catch ( StoreCopyFailedException e ) \n \n \t4 { \n \n <ect>
\t2 assertNotNull ( textFaceToDecodeInto ) ; \n \n \t2 FaceInstance binaryFaceToDecodeInto = new FaceInstance ( ) ; \n \n \t2 assertNotNull ( binaryFaceToDecodeInto ) ; \n \n \t2 XMLEncodableTester . encodeDecodeTest ( <string_literal> , faceToEncode , textFaceToDecodeInto , binaryFaceToDecodeInto ) ; \n \n <ect>
\t3 } finally { \n \n \t4 if ( output != null ) { \n \n \t5 output . close ( ) ; } } \n \n \t2 } catch ( IOException ie ) { \n \n <ect>
\t3 <comment> \n \n \t3 Logger loggerObtained = LoggerFactory . getLogger ( loggerName ) ; \n \n \t3 if ( loggerObtained == null ) { \n \n \t4 <comment> \n \n <ect>
\t4 newAllocationState = Grouping . AllocationState . valueOf ( allocationState ) ; \n \n \t3 } catch ( IllegalArgumentException ex ) { \n \n \t4 throw new InvalidParameterValueException ( <string_literal> + allocationState + <string_literal> ) ; } \n \n \t3 if ( newAllocationState == null ) { \n \n <ect>
\t4 tx . success ( ) ; } \n \n \t3 response . setContentLength ( 0 ) ; \n \n \t3 response . setHeader ( <string_literal> , <string_literal> ) ; \n \n \t2 } catch ( FrameworkException t ) { \n \n <ect>
\t2 { \n \n \t2 if ( null != proc ) { \n \n \t3 proc . close ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 private byte [ ] encryptExistingSession ( byte data [ ] , PublicKey target , SessionKey key , Set < SessionTag > tagsForDelivery , \n \n \t10 SessionTag currentTag , SessionKey newKey , long paddedSize ) { \n \n <ect>
\t2 internalCluster ( ) . startNode ( ) ; \n \n \t2 ensureStableCluster ( 1 ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 createIndexAndIndexData ( <number_literal> , 0 ) ; \n \n <ect>
\t3 <comment> \n \n \t3 Object svc = tracker . waitForService ( timeout ) ; \n \n \t3 if ( svc == null ) { \n \n \t4 Dictionary < ? , ? > dic = bundleContext . getBundle ( ) . getHeaders ( ) ; \n \n <ect>
\t2 if ( isSingleUse ( ) && getSoTimeout ( ) < 0 ) { \n \n \t3 try { \n \n \t4 socket . setSoTimeout ( DEFAULT_REPLY_TIMEOUT ) ; } \n \n \t3 catch ( SocketException e ) { \n \n <ect>
\t5 if ( LOG_ENABLED ) LOG . info ( <string_literal> ) ; \n \n \t5 handle = MethodHandles . catchException ( handle , MissingMethodException . class , GROOVY_OBJECT_INVOKER ) ; } } \n \n \t3 handle = MethodHandles . insertArguments ( handle , 1 , name ) ; \n \n \t3 if ( ! spread ) handle = handle . asCollector ( Object [ ] . class , targetType . parameterCount ( ) - 1 ) ; \n \n <ect>
\t5 discoverer . postDiscovery ( hosts , _nodeId ) ; } \n \n \t4 s_logger . info ( <string_literal> + discoverer . getName ( ) ) ; \n \n \t4 success = true ; \n \n \t4 return result ; } \n \n <ect>
\t2 List < Route > routes = context . getRoutes ( ) ; \n \n \t2 assertNotNull ( <string_literal> , routes ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , routes . size ( ) ) ; \n \n \t2 Route route = routes . get ( 0 ) ; \n \n <ect>
\t1 private static void addIfPresent ( String info , String path , NSMutableArray < String > propertiesPaths , NSMutableArray < String > projectsInfo ) { \n \n \t2 if ( path != null && path . length ( ) > 0 ) { \n \n \t3 path = getActualPath ( path ) ; \n \n \t3 if ( propertiesPaths . containsObject ( path ) ) { \n \n <ect>
\t3 snapDb . rollback ( ) ; \n \n \t3 snapDb = null ; } \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t3 setRowHeaderMode ( RowHeaderMode . ICON_ONLY ) ; \n \n \t3 setColumnWidth ( null , <number_literal> ) ; \n \n \t3 setVisibleColumns ( PROP_NAME , PROP_PERMISSION ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t4 if ( template . getRemoved ( ) == null ) { \n \n \t5 try { \n \n \t6 allTemplatesDeleted = _tmpltMgr . delete ( callerUserId , template . getId ( ) , null ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t3 cmdMap . get ( sock . getHost ( ) ) . append ( <string_literal> + cleanKey ) ; \n \n \t3 <comment> \n \n \t3 sock . close ( ) ; } \n \n <ect>
\t1 Preconditions . checkState ( descriptor . isPartitioned ( ) , \n \n \t1 <string_literal> , \n \n \t1 name ) ; \n \n \t1 Preconditions . checkArgument ( key != null , <string_literal> ) ; \n \n <ect>
\t3 vmiModel . addToVirtualNetwork ( vnModel ) ; } \n \n \t2 try { \n \n \t3 vmiModel . build ( _manager . getModelController ( ) , ( VMInstanceVO ) vm . getVirtualMachine ( ) , nic ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t3 LOG . trace ( <string_literal> , reader . getClass ( ) ) ; \n \n \t3 <comment> \n \n \t3 int coff = reader . getLocation ( ) . getCharacterOffset ( ) ; \n \n \t3 if ( coff != 0 ) { \n \n <ect>
\t2 return Hive . getFieldsFromDeserializerForMsStorage ( this , getDeserializer ( ) ) ; \n \n \t1 } else { \n \n \t2 return HiveMetaStoreUtils . getFieldsFromDeserializer ( getTableName ( ) , getDeserializer ( ) ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 else { \n \n \t6 logger . debug ( <string_literal> + channel . toString ( ) ) ; } } } \n \n \t3 catch ( Exception ex ) { \n \n <ect>
\t5 InputSource source = new InputSource ( resource . getInputStream ( ) ) ; \n \n \t5 source . setPublicId ( publicId ) ; \n \n \t5 source . setSystemId ( systemId ) ; \n \n <ect>
\t2 verifyConsistency ( dbSession ) ; } } } \n \n private void cleanOnUpgrade ( ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t3 try { \n \n \t4 maybeUpdatedState = allocationService . applyStartedShards ( currentState , shardRoutingsToBeApplied ) ; \n \n \t4 builder . successes ( tasksToBeApplied ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 private ReentrantLockManager slm = null ; \n \n \t1 private String qNameSfx = null ; \n \n \t1 @ BeforeClass \n \n \t1 public static void setup ( ) throws Exception { \n \n <ect>
\t3 try { \n \n \t4 socket . close ( ) ; \n \n \t3 } catch ( IOException ioe ) { } \n \n \t3 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t3 try { \n \n \t4 if ( runner == null ) { \n \n \t5 LOG . info ( <string_literal> , signal . getName ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t3 logger . error ( String . format ( <string_literal> %s \\ <string_literal> , new Object [ ] { TemplateEngine . threadIndex ( ) , templateSpec , e . getMessage ( ) } ) , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( final RuntimeException e ) { \n \n \t3 <comment> \n \n <ect>
\t2 final String password = credential . getPassword ( ) ; \n \n \t2 Principal principal = null ; \n \n \t2 final LoginContext lc = new LoginContext ( this . realm , new UsernamePasswordCallbackHandler ( username , password ) ) ; \n \n \t2 try { \n \n <ect>
\t6 <comment> \n \n \t6 client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . get ( ) ; } \n \n \t5 lastKnownCount . set ( count ) ; \n \n \t4 } catch ( Exception e ) { <comment> \n \n <ect>
\t2 MDC . put ( propertyName , propertyValue ) ; \n \n \t2 log . debug ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . warn ( <string_literal> ) ; \n \n <ect>
\t2 assertStoreHasExactly ( store , <string_literal> ) ; \n \n \t2 <comment> \n \n <comment> \n \n \t2 readAssertEquals ( store , <string_literal> , 1 ) ; \n \n <ect>
\t4 session . close ( ) ; \n \n \t3 } catch ( JMSException e ) { \n \n \t4 LOG . error ( <string_literal> , e ) ; } \n \n \t3 session = null ; } \n \n <ect>
\t2 TypedQuery < UserEntity > query = em . createNamedQuery ( <string_literal> , UserEntity . class ) ; \n \n \t2 query . setParameter ( <string_literal> , username ) ; \n \n \t2 List < UserEntity > result = query . getResultList ( ) ; \n \n \t2 if ( result . isEmpty ( ) ) { \n \n <ect>
\t5 for ( Listener listener : listeners ) { \n \n \t6 listener . onMasterFailure ( masterNode , cause , reason ) ; } \n \n \t4 } ) ; \n \n \t3 } catch ( EsRejectedExecutionException e ) { \n \n <ect>
\t4 output = output + line ; } \n \n \t3 p . getInputStream ( ) . close ( ) ; \n \n \t3 s_logger . info ( <string_literal> + output ) ; \n \n \t3 if ( output . contains ( <string_literal> ) || output . contains ( <string_literal> ) || output . contains ( <string_literal> ) ) { \n \n <ect>
\t2 usage . setFull ( false ) ; \n \n \t2 try { \n \n \t3 queue . wakeup ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 private static long parseLong ( String s ) { \n \n \t2 try { \n \n \t3 return Long . parseLong ( s ) ; \n \n \t2 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t5 <comment> \n \n \t5 eventHandler . streamConnectedReceived ( destination , <string_literal> ) ; } \n \n \t4 return destination ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 _vmDao . updateVM ( id , displayName , ha , osTypeId , userData , isDisplayVmEnabled , isDynamicallyScalable , customId , hostName , instanceName ) ; \n \n \t2 if ( updateUserdata ) { \n \n \t3 boolean result = updateUserDataInternal ( _vmDao . findById ( id ) ) ; \n \n \t3 if ( result ) { \n \n <ect>
\t4 performAnticompaction ( cfs , ranges , sstables , repairedAt ) ; } \n \n \t2 } ; \n \n \t2 if ( executor . isShutdown ( ) ) \n \n \t2 { \n \n <ect>
\t4 logger . debug ( <string_literal> , distanceAverageLength ) ; \n \n \t4 setDistanceAverageLength ( distanceAverageLength ) ; } \n \n \t3 if ( tfConfig . eIsSet ( tfConfig . eClass ( ) . getEStructuralFeature ( <string_literal> ) ) ) { \n \n \t4 Short velocityAverageLength = tfConfig . getVelocityAverageLength ( ) ; \n \n <ect>
\t7 throw new IllegalArgumentException ( <string_literal> + verb + <string_literal> ) ; } } \n \n \t4 <comment> \n \n \t4 timeout = 0 ; } \n \n \t3 catch ( IOException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 for ( int i = 0 ; i < node . getChildCount ( ) ; i ++ ) { \n \n \t4 addNode ( newNode , ( JMeterTreeNode ) node . getChildAt ( i ) ) ; } \n \n \t2 } catch ( IllegalUserActionException iuae ) { \n \n <ect>
\t3 log . debug ( <string_literal> + a ) ; \n \n \t2 MediaType item = choose ( a , myPrefs , defaultMediaType ) ; \n \n <ect>
\t1 { \n \n \t1 @ Override \n \n \t1 public void onError ( Throwable e ) \n \n \t1 { \n \n <ect>
<comment> \n \n \t2 @ Override \n \n \t2 public void sendBytes ( InputStream in , int size ) throws IOException { \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 if ( yesWeDoingMfaBasedOnClientIpAddress ( ) ) { \n \n \t3 final Map eventAttributes = buildEventAttributeMap ( authentication . getPrincipal ( ) , service , provider ) ) ; \n \n \t3 final Event event = validateEventIdForMatchingTransitionInContext ( provider . getId ( ) , context , eventAttributes ) ; \n \n \t3 return ImmutableSet . of ( event ) ; } \n \n <ect>
\t1 Host hostObj = null ; \n \n \t1 try { \n \n \t2 hostObj = clusters . getHost ( host ) ; \n \n \t1 } catch ( AmbariException e ) { \n \n <ect>
\t4 containerId , \n \n \t4 taskManagerParameters . taskManagerTotalMemoryMB ( ) , \n \n \t4 taskManagerParameters . taskManagerHeapSizeMB ( ) , \n \n \t4 taskManagerParameters . taskManagerDirectMemoryLimitMB ( ) ) ; \n \n <ect>
\t1 } finally { \n \n \t1 try { \n \n \t2 out . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 page . getFirstKey ( ) + <string_literal> + page . size ( ) + \n \n \t4 <string_literal> + page . getNextFirstKey ( ) + \n \n \t4 <string_literal> + direction + <string_literal> + nextKey ) ; \n \n \t2 if ( repair ) { \n \n <ect>
\t5 if ( Files . isReadable ( inputFile ) ) { \n \n \t6 try { \n \n \t7 tikaVisitor . visitFile ( inputFile , Files . readAttributes ( inputFile , BasicFileAttributes . class ) ) ; \n \n \t6 } catch ( IOException e ) { \n \n <ect>
\t6 removed = started . remove ( wrapper . getMessageID ( ) ) ; \n \n \t6 if ( removed != null ) { \n \n \t7 int size = wrapper . getLength ( ) ; \n \n \t7 npf . sendBufferUsed -= size ; \n \n <ect>
\t6 throw new InternalErrorException ( <string_literal> ) ; \n \n \t5 try { \n \n \t6 Model model = ModelFactory . createDefaultModel ( ) ; \n \n \t6 GraphLoadUtils . loadModel ( model , uri , MaxTriples ) ; \n \n <ect>
\t1 throw new RuntimeException ( msg ) ; } \n \n \t1 try { \n \n \t1 initiateClose ( true , false , false ) ; \n \n \t1 } catch ( IllegalStateException ise ) { \n \n <ect>
\t5 LOG . debug ( <string_literal> , exchange . getExchangeId ( ) ) ; } \n \n \t4 if ( session != null && session . getTransacted ( ) ) { \n \n \t5 session . commit ( ) ; } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 return true ; } \n \n \t1 } catch ( Exception e ) { \n \n \t1 LOG . warn ( <string_literal> + \n \n \t2 e ) ; } \n \n <ect>
\t2 } catch ( XmlRpcException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( UnknownHostException e ) { \n \n <ect>
\t3 thread . setTask ( null ) ; \n \n \t3 thread . stopStopWatch ( ) ; \n \n \t4 String elapsedTime = thread . elapsedTime ( ) ; \n \n <ect>
\t2 long attempt2 = context . getTypeConverterRegistry ( ) . getStatistics ( ) . getAttemptCounter ( ) ; \n \n \t2 long failed2 = context . getTypeConverterRegistry ( ) . getStatistics ( ) . getFailedCounter ( ) ; \n \n \t2 long hit2 = context . getTypeConverterRegistry ( ) . getStatistics ( ) . getHitCounter ( ) ; \n \n \t2 long miss2 = context . getTypeConverterRegistry ( ) . getStatistics ( ) . getMissCounter ( ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> , strTok . countTokens ( ) ) ; \n \n \t3 int i = 0 ; \n \n \t3 while ( strTok . hasMoreTokens ( ) ) { \n \n \t4 versionInfo [ i ] = strTok . nextToken ( ) ; \n \n <ect>
\t2 return new UploadAnswer ( jobId , getUploadPct ( jobId ) , getUploadError ( jobId ) , getUploadStatus2 ( jobId ) , getUploadLocalPath ( jobId ) , getInstallPath ( jobId ) , \n \n \t4 getUploadTemplateSize ( jobId ) ) ; } \n \n \t1 @ Override \n \n \t1 public UploadAnswer handleUploadCommand ( SecondaryStorageResource resource , UploadCommand cmd ) { \n \n <ect>
\t3 txn . commit ( ) ; \n \n \t3 if ( count < 1 ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> , new ClusterInvalidSessionException ( <string_literal> + runid + <string_literal> ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 session . put ( MessageStoreInterceptor . actionErrorsSessionKey , validationAwareAction . getActionErrors ( ) ) ; \n \n \t4 session . put ( MessageStoreInterceptor . actionMessagesSessionKey , validationAwareAction . getActionMessages ( ) ) ; \n \n \t4 session . put ( MessageStoreInterceptor . fieldErrorsSessionKey , validationAwareAction . getFieldErrors ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 unloadedAndSavingPlayerMap . clear ( ) ; \n \n \t2 try { \n \n \t3 FilesUtil . recursiveDelete ( getStoragePathProvider ( ) . getWorldPath ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 if ( obj != null ) { \n \n \t6 ret . add ( obj ) ; } } \n \n \t4 return ret ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 json . writeEndObject ( ) ; } } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n \t3 String key = metadata . partitionKeyType . getString ( partition . partitionKey ( ) . getKey ( ) ) ; \n \n <ect>
\t1 public final static InputStream getAsInputStream ( final String filename ) { \n \n \t2 InputStream stream = Resource . class . getClassLoader ( ) . getResourceAsStream ( filename ) ; \n \n \t2 if ( stream != null ) { \n \n \t3 return stream ; } \n \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t3 log . debug ( <string_literal> + getLDAPPropertyValue ( ROLE_BASE ) ) ; \n \n <ect>
\t8 if ( singlePrivateIp != null ) { \n \n \t9 s_logger . info ( <string_literal> + singlePrivateIp + <string_literal> ) ; } \n \n \t8 else { \n \n \t9 s_logger . info ( <string_literal> + myUser . getUserName ( ) ) ; \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> , config . masterUrl ( ) ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t4 conf . volume = Integer . parseInt ( array . get ( <string_literal> ) . toString ( ) ) ; \n \n \t4 conf . min = Integer . parseInt ( array . get ( <string_literal> ) . toString ( ) ) ; \n \n \t4 conf . max = Integer . parseInt ( array . get ( <string_literal> ) . toString ( ) ) ; \n \n \t3 } catch ( NumberFormatException ex ) { \n \n <ect>
\t3 org . w3c . dom . Document doc = db . parse ( new URL ( url ) . openStream ( ) ) ; \n \n \t3 rtn = URLEncoder . encode ( getSecurityInfo ( doc ) , <string_literal> ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t3 busNum ++ ; } \n \n \t2 if ( configureVm ( vmConfig ) ) { \n \n \t3 throw new Exception ( <string_literal> + getName ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t1 String url ; \n \n \t1 Connection connection ; \n \n \t1 public DatabaseInitializationBean ( ) { } \n \n \t1 public void create ( ) throws Exception { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t1 dbConn . commit ( ) ; } \n \n \t1 catch ( SQLException ex ) { \n \n \t1 LOG . error ( <string_literal> + getMessage ( ex ) , ex ) ; } \n \n \t1 catch ( Exception ex ) { \n \n <ect>
\t1 protected T computeNext ( ) { \n \n \t2 try { \n \n \t3 T next = null ; \n \n \t3 while ( ! finish && ! cancel && ( next = queue . poll ( timeout , timeoutUnit ) ) == null ) { \n \n <ect>
\t1 BufferedWriter bw = new BufferedWriter ( fw ) ; \n \n \t1 bw . write ( content ) ; \n \n \t1 bw . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 final TelnetClient tc = new TelnetClient ( ) ; \n \n \t3 tc . setSocketFactory ( mapper . socketFactory ( ) ) ; \n \n \t3 tc . setConnectTimeout ( connectionTimeoutMillis ) ; \n \n \t3 tc . addOptionHandler ( new WindowSizeOptionHandler ( <number_literal> , <number_literal> , true , false , true , false ) ) ; \n \n <ect>
\t7 if ( ! metrics . isEmpty ( ) ) { \n \n \t8 if ( externalStatsType != null && externalStatsType == ExternalStatsProtocol . GRAPHITE ) { \n \n \t9 if ( externalStatsPort == - 1 ) { \n \n \t10 externalStatsPort = <number_literal> ; } \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 CreateSnapshotResponse createSnapshotResponse = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) . setWaitForCompletion ( true ) . setIndices ( <string_literal> ) . get ( ) ; \n \n \t2 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( 0 ) ) ; \n \n \t2 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; \n \n <ect>
\t5 try { \n \n \t6 connected = false ; \n \n \t6 connectSocket ( ) ; \n \n \t5 } catch ( Exception ex ) { \n \n <ect>
\t1 private static final String URI = <string_literal> ; \n \n \t1 @ Test \n \n \t1 public void testSendToAlotOfMessageToQueues ( ) throws Exception { \n \n \t2 int size = <number_literal> ; \n \n <ect>
\t1 private void onHandshakeComplete ( ProtocolStack protocolStack , SocketChannel channel , Throwable failure ) \n \n \t1 { \n \n \t2 if ( failure != null ) \n \n \t2 { \n \n <ect>
\t3 s_logger . debug ( <string_literal> ) ; \n \n \t3 return new Pair < Boolean , ActionOnFailedAuthentication > ( false , null ) ; } \n \n \t2 UserAccount user = _userAccountDao . getUserAccount ( username , domainId ) ; \n \n \t2 if ( user == null ) { \n \n <ect>
\t4 log . info ( <string_literal> , <string_literal> + forcedType ) ; \n \n \t4 getConfiguredForcedTypes ( ) . add ( forcedType ) ; } } \n \n \t2 <comment> \n \n \t2 catch ( NoClassDefFoundError e ) { \n \n <ect>
\t2 if ( ! wsdlRequest . isStripWhitespaces ( ) ) { \n \n \t3 return ; } \n \n \t2 String content = ( String ) context . getProperty ( BaseHttpRequestTransport . REQUEST_CONTENT ) ; \n \n \t2 if ( content == null ) { \n \n <ect>
\t4 hazelcastInstance . getCluster ( ) . removeMembershipListener ( membershipRegistrationId ) ; \n \n \t4 hazelcastInstance . getLifecycleService ( ) . terminate ( ) ; } \n \n \t3 catch ( Throwable e ) \n \n \t3 { \n \n <ect>
\t4 logger . debug ( String . format ( <string_literal> , this . getNode ( ) . getNodeId ( ) , \n \n \t6 this . getNode ( ) . getDeviceId ( ) ) ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t5 owner = owner , \n \n \t5 mode = file_mode , \n \n \t5 replace_existing_files = replace_existing_files , \n \n ) \n \n <ect>
\t1 this . itemIndexes = new int [ numPrefs ] ; \n \n \t1 this . values = new float [ numPrefs ] ; \n \n \t1 this . cachedEstimates = new double [ numPrefs ] ; \n \n \t1 index = 0 ; \n \n <ect>
\t3 this . sessionFuture . setException ( ex ) ; <comment> \n \n \t3 this . sessionHandler . handleTransportError ( this , ex ) ; } \n \n \t2 catch ( Throwable ex2 ) { \n \n <ect>
public java . math . BigDecimal revenue ( ) { \n \n \t1 return ( java . math . BigDecimal ) storedValueForKey ( _Movie . REVENUE_KEY ) ; } \n \n public void setRevenue ( java . math . BigDecimal value ) { \n \n <ect>
\t2 message . setMessageAnnotation ( <string_literal> , 1 ) ; \n \n \t2 message . setText ( <string_literal> ) ; \n \n \t2 sender . send ( message ) ; \n \n \t2 sender . close ( ) ; \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t6 long templatePoolRefId = templatePoolRef . getId ( ) ; \n \n \t6 templatePoolRef = _tmpltPoolDao . acquireInLockTable ( templatePoolRefId , <number_literal> ) ; \n \n \t6 try { \n \n \t7 if ( templatePoolRef == null ) { \n \n <ect>
\t4 catch ( Throwable t ) { \n \n \t5 <comment> \n \n \t5 containersInLaunch . remove ( resourceID ) ; \n \n \t5 <comment> \n \n <ect>
\t4 final Constructor < ? > constructor = impl . getDeclaredConstructor ( ) ; \n \n \t4 constructor . setAccessible ( true ) ; \n \n \t4 storage = ( NfsSecondaryStorageResource ) constructor . newInstance ( ) ; \n \n \t3 } catch ( final ClassNotFoundException e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void unelected ( String role , InstanceId instanceId , URI electedMember ) \n \n \t1 { \n \n <ect>
\t5 return session \n \n \t7 . send ( input . doOnNext ( s - > logger . debug ( <string_literal> + s ) ) . map ( session : : textMessage ) ) \n \n \t7 . thenMany ( session . receive ( ) . take ( count ) . map ( WebSocketMessage : : getPayloadAsText ) ) \n \n \t7 . subscribeWith ( output ) \n \n <ect>
\t2 synchronized ( _rebuildLock ) { \n \n \t3 return locked_rebuildExternalAddress ( host , port , allowRebuildRouterInfo ) ; } } \n \n \t1 private RouterAddress locked_rebuildExternalAddress ( String host , int port , boolean allowRebuildRouterInfo ) { \n \n \t2 if ( _log . shouldDebug ( ) ) \n \n <ect>
\t10 final SamlRegisteredServiceServiceProviderMetadataFacade adaptor , \n \n \t10 final HttpServletResponse response , \n \n \t10 final HttpServletRequest request , \n \n \t10 final String binding ) throws SamlException { \n \n <ect>
\t2 } else if ( type == <string_literal> ) { \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t3 terminal . set_prompt ( event . data ) ; \n \n \t2 } else if ( type == <string_literal> ) { \n \n <ect>
\t2 public void handleFailure ( Throwable ex ) { \n \n \t3 if ( this . tcpConnection != null ) { \n \n \t4 handleTcpConnectionFailure ( <string_literal> + ex . getMessage ( ) , ex ) ; } \n \n \t3 else if ( logger . isErrorEnabled ( ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void subscribe ( String service , URL url , NotifyListener listener ) { \n \n \t2 String client = RpcContext . getContext ( ) . getRemoteAddressString ( ) ; \n \n <ect>
\t1 @ ResponseStatus ( HttpStatus . CREATED ) \n \n \t1 public ResponseEntity < String > namespacePost ( @ RequestBody NamespaceInfo namespace , UriComponentsBuilder builder ) { \n \n \t2 catalog . add ( namespace ) ; \n \n \t2 String name = namespace . getName ( ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( m_readThread != null ) { \n \n \t4 m_readThread . join ( ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t4 <comment> \n \n \t4 aborted = true ; \n \n \t4 publishConsumerFailedEvent ( <string_literal> , true , ex ) ; } \n \n \t3 catch ( PossibleAuthenticationFailureException ex ) { \n \n <ect>
public String feeType ( ) { \n \n \t1 return ( String ) storedValueForKey ( _FeeType . FEE_TYPE_KEY ) ; } \n \n public void setFeeType ( String value ) { \n \n <ect>
\t2 options . setFetchSize ( Integer . MIN_VALUE ) ; } \n \n \t1 } else if ( \n \n \t2 ! options . getFetchSize ( ) . equals ( Integer . MIN_VALUE ) \n \n \t2 && ! options . getFetchSize ( ) . equals ( 0 ) ) { \n \n <ect>
\t2 internalCluster ( ) . startNodes ( nodeCount , settings . build ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( Integer . toString ( nodeCount ) ) . get ( ) . isTimedOut ( ) ) ; \n \n \t2 int updateCount = randomIntBetween ( 1 , nodeCount ) ; \n \n <ect>
\t2 requestNonceTimer = new NonceTimer ( NonceTimerType . REQUESTED , node ) ; \n \n \t2 requestNonceMessage = message ; } \n \n \t1 synchronized void receivedNonceFromDevice ( byte [ ] nonceBytes ) { \n \n \t2 if ( requestNonceTimer == null ) { \n \n <ect>
\t1 boolean nonNative = false ; \n \n \t1 PartitionDesc part = HiveFileFormatUtils . getFromPathRecursively ( \n \n \t2 pathToPartitionInfo , hsplit . getPath ( ) , null ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> , securityGroup , inboundPort ) ; \n \n \t3 securityGroupApi . create ( \n \n \t4 Rule . CreateRule . createBuilder ( RuleDirection . INGRESS , RegionAndId . fromSlashEncoded ( securityGroup . getId ( ) ) . getId ( ) ) . protocol ( RuleProtocol . TCP ) \n \n \t6 . portRangeMin ( inboundPort ) . portRangeMax ( inboundPort ) . remoteIpPrefix ( <string_literal> ) . build ( ) ) ; \n \n <ect>
\t2 try { \n \n \t3 Host host = Host . getByUuid ( conn , _host . uuid ) ; \n \n \t3 pbds = host . getPBDs ( conn ) ; \n \n \t2 } catch ( XenAPIException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 api . sendCommand ( this . getClient ( ) , this . getConn ( ) ) ; \n \n \t3 <comment> \n \n \t3 if ( ( api . getResponseType ( ) == ResponseType . ERROR ) && ( api . getResponseCode ( ) == <number_literal> ) ) { \n \n <ect>
\t2 codec = <string_literal> ; \n \n \t1 } else if ( codec . trim ( ) . equalsIgnoreCase ( <string_literal> ) ) { \n \n \t2 codec = <string_literal> ; \n \n \t1 } else { \n \n <ect>
\t3 final int live = NumbersUtil . parseInt ( ( String ) params . get ( <string_literal> ) , <number_literal> ) ; \n \n \t3 final int idle = NumbersUtil . parseInt ( ( String ) params . get ( <string_literal> ) , <number_literal> ) ; \n \n \t3 _iamCache = new Cache ( getName ( ) , maxElements , false , live == - 1 , live == - 1 ? Integer . MAX_VALUE : live , idle ) ; \n \n \t3 cm . addCache ( _iamCache ) ; \n \n <ect>
\t2 RegisteredService registeredService = this . servicesManager . findServiceBy ( service ) ; \n \n \t2 if ( registeredService == null ) { \n \n \t3 LOGGER . debug ( <string_literal> , entityId , currentService ) ; \n \n \t3 registeredService = this . servicesManager . findServiceBy ( currentService ) ; } \n \n <ect>
\t3 valBoxIt = s . getDefBoxes ( ) . iterator ( ) ; \n \n \t3 while ( valBoxIt . hasNext ( ) ) { \n \n \t4 ValueBox vb = ( ValueBox ) valBoxIt . next ( ) ; \n \n \t4 if ( parityVarsDefs . containsKey ( vb . getValue ( ) ) ) { \n \n <ect>
\t4 sslContext = X509Util . createSSLContext ( clientConfig ) ; \n \n \t4 sslEngine = sslContext . createSSLEngine ( host , port ) ; \n \n \t4 sslEngine . setUseClientMode ( true ) ; } \n \n \t3 pipeline . addLast ( <string_literal> , new SslHandler ( sslEngine ) ) ; \n \n <ect>
\t3 success = false ; } \n \n \t2 <comment> \n \n \t2 final List < FirewallRuleVO > firewallRules = _firewallDao . listByNetworkPurposeTrafficType ( networkId , Purpose . Firewall , FirewallRule . TrafficType . Ingress ) ; \n \n <ect>
\t3 log . error ( <string_literal> , e ) ; \n \n \t3 return null ; } \n \n \t2 try { \n \n \t3 Repository r = cfd . getRepository ( rmiURI ) ; \n \n <ect>
\t4 traces . removeLastObject ( ) ; \n \n \t4 if ( traces . count ( ) == 0 ) { \n \n \t5 openLockTraces . removeObjectForKey ( lockingThread ) ; } \n \n \t3 } else { \n \n <ect>
\t4 log . debug ( <string_literal> + conceptId ) ; } \n \n \t3 return null ; } \n \n <ect>
\t2 if ( existingOntology != null && ! o . equals ( existingOntology ) \n \n \t3 && ! o . equalAxioms ( existingOntology ) ) { \n \n \t3 LOGGER . error ( <string_literal> , \n \n \t4 existingOntology ) ; \n \n <ect>
\t2 Properties properties = new Properties ( ) ; \n \n \t2 final File file = PropertiesUtil . findConfigFile ( <string_literal> ) ; \n \n \t2 if ( file == null ) { \n \n \t3 throw new ConfigurationException ( <string_literal> ) ; } \n \n <ect>
\t1 } else { \n \n \t2 platformPreferences = new HashMap ( Base . getPlatformPreferences ( platform ) ) ; } \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 logger . debug ( <string_literal> + program ) ; \n \n <ect>
public final class SplunkPublishEventClient { \n \n \t1 private static final Logger LOG = LoggerFactory . getLogger ( SplunkPublishEventClient . class ) ; \n \n \t1 private SplunkPublishEventClient ( ) { } \n \n \t1 public static void main ( String [ ] args ) throws Exception { \n \n <ect>
\t7 qfSession . setTargetDefaultApplicationVersionID ( applVerID ) ; \n \n \t7 sessionLog . onEvent ( <string_literal> + DefaultApplVerID . FIELD + <string_literal> \n \n \t9 + applVerID . getValue ( ) + <string_literal> ) ; } } \n \n \t4 } else { \n \n <ect>
\t4 CtMethod method = CtNewMethod . make ( <string_literal> + type . getName ( ) + <string_literal> , constructorClass ) ; \n \n \t4 constructorClass . addMethod ( method ) ; \n \n \t4 return ( ObjectConstructor < T > ) ( constructorClass . toClass ( type . getClassLoader ( ) , type . getProtectionDomain ( ) ) . getConstructor ( ) . newInstance ( ) ) ; \n \n \t3 } catch ( InstantiationException | IllegalAccessException | InvocationTargetException | CannotCompileException e ) { \n \n <ect>
\t1 public void uploadMetricData ( WorkerUploadMetrics metrics ) { \n \n \t2 if ( inTopology ) { \n \n \t3 <comment> \n \n \t3 if ( boltOutput != null ) { \n \n <ect>
\t2 PackageScanFilter test = getCompositeFilter ( new AssignableToPackageScanFilter ( parent ) ) ; \n \n \t2 Set < Class < ? > > classes = new LinkedHashSet < Class < ? > > ( ) ; \n \n \t2 for ( String pkg : packageNames ) { \n \n \t3 find ( test , pkg , classes ) ; } \n \n <ect>
\t6 result = LogoS7Client . WriteArea ( S7 . S7AreaDB , 1 , address , size , buffer ) ; \n \n \t6 logger . debug ( <string_literal> , address , buffer [ 0 ] ) ; } } \n \n \t4 <comment> \n \n \t4 if ( result != 0 ) { \n \n <ect>
\t3 int targetBlock = index / BLOCK_SIZE ; \n \n \t3 for ( int i = 0 ; i < blocks . length ; i ++ ) { \n \n \t4 Block block = blocks [ i ] ; \n \n \t4 if ( i != ( blocks . length - 1 ) && block . reqs . length != BLOCK_SIZE ) { \n \n <ect>
\t2 String ret = masterLocalDir ( conf ) + FILE_SEPERATEOR + <string_literal> ; \n \n \t2 try { \n \n \t3 FileUtils . forceMkdir ( new File ( ret ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 self . debug ( <string_literal> % ( vm . id , vpc . id ) ) \n \n \t2 except Exception as e : \n \n \t3 self . fail ( e ) \n \n \t2 finally : \n \n <ect>
<comment> \n \n \t2 } catch ( Exception e ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 return Boolean . TRUE ; } \n \n \t4 } ; \n \n \t4 zopdel . execute ( ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t1 return ; } \n \n \t1 try { \n \n \t1 createCredentialEntryMethod . invoke ( credentialProvider , name , credential ) ; \n \n \t1 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t5 sharedInstance = sharedInstance ( ERPersistentSessionStorage . class ) ; } } } \n \n \t2 return sharedInstance ; } \n \n \t1 @ Override \n \n \t1 public void finishInitialization ( ) { \n \n <ect>
\t5 accountId ) ; \n \n \t3 return ; } \n \n \t2 OAuthConsumer consumer = withingsAccount . consumer ; \n \n \t2 if ( provider == null || consumer == null ) { \n \n <ect>
\t4 try { \n \n \t5 fos . close ( ) ; \n \n \t4 } catch ( IOException e1 ) { \n \n \t5 Logger . error ( this , <string_literal> + e , e ) ; } \n \n <ect>
\t4 clientScheme = <string_literal> ; } \n \n \t2 String amqpURI = clientScheme + remoteURI . getHost ( ) + <string_literal> + remoteURI . getPort ( ) ; \n \n \t2 if ( useSSL ) { \n \n \t3 amqpURI += <string_literal> ; } \n \n <ect>
\t4 if ( volume != null ) { \n \n \t5 if ( ! nestedVolumeManager . areSnapshotsPending ( volume . getVolumeId ( ) ) ) { \n \n \t5 LOG . info ( <string_literal> + volume . getVolumeId ( ) ) ; \n \n \t5 LVMWrapper . disableLogicalVolume ( path ) ; \n \n <ect>
\t2 response . setCorrelationId ( command . getCommandId ( ) ) ; \n \n \t2 try { \n \n \t3 consumer . oneway ( response ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 if ( _debugEnabledForComponentMethod != null ) { \n \n \t4 debugEnabled = ( Boolean ) _debugEnabledForComponentMethod . invoke ( WOApplication . application ( ) , component . name ( ) ) ; } \n \n \t3 return debugEnabled . booleanValue ( ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t3 . setSettings ( sb2 ) \n \n \t3 . setIndicesOptions ( IndicesOptions . fromOptions ( true , false , true , true ) ) \n \n \t3 . get ( ) ; \n \n \t2 assert Files . exists ( startDir ) == false : <string_literal> ; \n \n <ect>
\t5 if ( article . equals ( <string_literal> ) ) { <comment> \n \n \t6 modules [ i ] = new PWMModule ( article , OROffset ) ; \n \n \t6 OROffset += <number_literal> ; <comment> \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( lowLevelClient == null ) \n \n \t3 Logger . error ( this , <string_literal> , new Exception ( <string_literal> ) ) ; \n \n \t2 if ( putter == null ) \n \n <ect>
\t5 result . fromByteArray ( decoded ) ; \n \n \t5 return result ; \n \n \t4 } catch ( DataFormatException dfe ) { \n \n \t5 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 try { \n \n \t4 invocation . setInput ( <string_literal> , name ) ; \n \n \t4 invocation . setInput ( <string_literal> , queueID ) ; \n \n \t3 } catch ( InvalidValueException ex ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 model . setNsPrefixes ( query . getPrefixMapping ( ) ) ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
public static void shutdown ( ) { \n \n \t1 for ( String ctx : emf . keySet ( ) ) { \n \n \t1 EntityManagerFactoryImpl em = emf . remove ( ctx ) ; \n \n \t1 if ( em . isOpen ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 StringWriter writer = new StringWriter ( ) ; \n \n \t2 Log log = newFormattedLog ( writer ) ; \n \n \t2 <comment> \n \n <ect>
\t2 Matcher m = p . matcher ( memberAttributeValue ) ; \n \n \t2 LOG . debug ( <string_literal> , memberAttributeValue , pattern ) ; \n \n \t2 if ( m . matches ( ) ) { \n \n \t2 memberAttributeValue = m . replaceAll ( MEMBER_ATTRIBUTE_REPLACE_STRING ) ; \n \n <ect>
\t1 private DBCollection createTicketCollection ( final TicketDefinition ticket , final MongoDbConnectionFactory factory ) { \n \n \t2 final String collectionName = ticket . getProperties ( ) . getStorageName ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , collectionName ) ; \n \n \t2 factory . createCollection ( mongoTemplate , collectionName , this . dropCollection ) ; \n \n <ect>
\t4 if ( gpuDevice != null ) { \n \n \t5 _resourceMgr . updateGPUDetails ( vm . getHostId ( ) , gpuDevice . getGroupDetails ( ) ) ; } \n \n \t4 if ( ! answer . getResult ( ) ) { \n \n \t5 final String details = answer . getDetails ( ) ; \n \n <ect>
\t1 @ Consumes ( <string_literal> ) \n \n \t1 @ Produces ( MediaType . APPLICATION_XML ) \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public List < ContextProvidersName > postList ( List < ContextProvidersCustomer > customers ) throws IOException { \n \n <ect>
\t3 RemoteFileConsumer < ? > rfc = ( RemoteFileConsumer < ? > ) consumer ; \n \n \t3 <comment> \n \n \t3 if ( rfc . isRunAllowed ( ) ) { \n \n \t4 <comment> \n \n <ect>
\t3 dao . insertAppIfNotExits ( domain , app ) ; \n \n \t3 dao . insertClusterIfNotExits ( domain , app , cluster ) ; \n \n \t3 dao . insertOrUpdateInstance ( domain , app , cluster , host , ip , Utils . getStartTime ( ) , pid ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 @ Override \n \n \t1 public Float get ( LongPair key ) throws TasteException { \n \n \t1 long userID = key . getFirst ( ) ; \n \n \t1 long itemID = key . getSecond ( ) ; \n \n <ect>
\t3 Class < ? > oracleConClass = con . getClass ( ) . getClassLoader ( ) . loadClass ( <string_literal> ) ; \n \n \t3 con = ( Connection ) con . unwrap ( oracleConClass ) ; } \n \n \t2 catch ( ClassNotFoundException | SQLException ex ) { \n \n <ect>
\t6 parent . getChildCount ( ) , job . getDescription ( ) , job . getTimer ( ) ) ; \n \n \t2 } else if ( parent != null && parent . getType ( ) . equals ( ExperimentJob . JOB_TYPE ) ) { \n \n \t3 logger . info ( <string_literal> , job , job . getTimer ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 <string_literal> , totalFoundErrors , totalResourcesWithErrors ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 log . info ( String . format ( <string_literal> , totalResources ) ) ; \n \n \t1 log . info ( message ) ; \n \n <ect>
\t5 if ( ! s2Comma ) { \n \n \t6 if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { \n \n \t7 filteredTokens . append ( buffer . substring ( 0 , <number_literal> ) ) ; \n \n \t7 if ( <string_literal> . indexOf ( buffer . charAt ( <number_literal> ) ) == - 1 ) { \n \n <ect>
\t1 @ ReflectionUse \n \n \t1 private Pair < JobInfo . Status , String > orchestrateStop ( final VmWorkStop work ) throws Exception { \n \n \t2 final VMInstanceVO vm = _entityMgr . findById ( VMInstanceVO . class , work . getVmId ( ) ) ; \n \n \t2 if ( vm == null ) { \n \n <ect>
\t5 sb . append ( <string_literal> ) ; \n \n \t5 sb . append ( colValue ) ; \n \n \t5 sb . append ( <string_literal> ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 if ( ! toCheck . isEmpty ( ) ) { \n \n \t4 for ( Long msgId : toCheck ) { \n \n \t5 MessagePayloadMessage removed = _availableMessages . remove ( msgId ) ; \n \n \t5 if ( removed != null ) \n \n <ect>
\t3 value = ( OnOffType ) state == OnOffType . ON ? 1 : 0 ; \n \n \t3 logger . debug ( <string_literal> , value ) ; \n \n \t2 } else if ( state instanceof OpenClosedType ) { \n \n \t3 value = ( OpenClosedType ) state == OpenClosedType . OPEN ? 1 : 0 ; \n \n <ect>
\t3 byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; \n \n \t3 org . apache . thrift . TSerializable msg ; \n \n \t3 getZooKeepers_result result = new getZooKeepers_result ( ) ; \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 try { \n \n \t4 json = mapper . writerWithDefaultPrettyPrinter ( ) \n \n \t5 . writeValueAsString ( schema ) ; \n \n \t3 } catch ( JsonProcessingException e ) { \n \n <ect>
\t3 ProtobufUtil . toString ( Status . parseFrom ( kv . getValue ( ) . get ( ) ) ) ) ; \n \n \t2 } else { \n \n \t2 log . info ( <string_literal> , kv . getKey ( ) . toStringNoTruncate ( ) , kv . getValue ( ) ) ; } } \n \n \t1 log . info ( <string_literal> ) ; \n \n <ect>
\t3 DOMImplementationLS ls = ( DOMImplementationLS ) docBuilder . getDOMImplementation ( ) ; \n \n \t3 LSSerializer lss = ls . createLSSerializer ( ) ; \n \n \t3 System . out . println ( lss . writeToString ( _docResponse ) ) ; \n \n \t2 } catch ( ParserConfigurationException e ) { \n \n <ect>
\t1 f . close ( ) \n \n else : \n \n \t1 logger . warn ( <string_literal> ) \n \n \t1 sys . exit ( ) \n \n <ect>
\t1 <comment> \n \n <ect>
\t1 return self . connected \n \n def attempt_connection ( self ) : \n \n \t1 self . ws . connect ( ) \n \n def send ( self , encoded_frame ) : \n \n <ect>
\t6 s_logger . warn ( <string_literal> + _id ) ; \n \n \t6 _mgr . disconnectWithInvestigation ( DirectAgentAttache . this , Event . AgentDisconnected ) ; \n \n \t6 return ; } \n \n <ect>
\t5 e ) ; } \n \n \t2 <comment> \n \n \t2 if ( user == null ) \n \n \t2 { \n \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 KeycloakDeployment deployment = httpFacade . getDeployment ( ) ; \n \n \t2 if ( ! deployment . getRealm ( ) . equals ( account . getKeycloakSecurityContext ( ) . getRealm ( ) ) ) { \n \n <ect>
\t5 } catch ( InterruptedException e ) { \n \n \t6 interrupt ( ) ; } } \n \n \t3 } catch ( \n \n \t3 Exception e ) { \n \n <ect>
\t3 if ( ! dfs . exist ( dfsDbPath ) ) \n \n \t4 dfs . mkdir ( dfsDbPath ) ; \n \n \t3 if ( ! dfs . exist ( dfsCheckpointPath ) ) \n \n \t4 dfs . mkdir ( dfsCheckpointPath ) ; \n \n <ect>
\t2 <comment> \n \n \t2 final LinkedHashMap < Network , List < ? extends NicProfile > > networks = new LinkedHashMap < Network , List < ? extends NicProfile > > ( <number_literal> ) ; \n \n \t2 <comment> \n \n \t2 if ( guestNetwork != null ) { \n \n <ect>
\t2 if ( ! canHandle ( network , Service . Connectivity ) ) { \n \n \t3 return false ; } \n \n \t2 List < NiciraNvpDeviceVO > devices = niciraNvpDao . listByPhysicalNetwork ( network . getPhysicalNetworkId ( ) ) ; \n \n \t2 if ( devices . isEmpty ( ) ) { \n \n <ect>
\t1 protected boolean writeString ( String s , String msg ) { \n \n \t2 return writeString ( s + createMessageString ( msg ) + ' \\ n' ) ; } \n \n \t1 public void receiveStreamBytes ( int id , ByteBuffer data ) throws IOException { \n \n \t2 if ( streamSession == null ) { \n \n <ect>
\t6 . collect ( Collectors . toList ( ) ) ; \n \n \t3 if ( ! algorithms . isEmpty ( ) ) { \n \n \t4 LOGGER . info ( <string_literal> , provider . getName ( ) , provider . getClass ( ) . getName ( ) ) ; \n \n \t4 for ( final String algorithm : algorithms ) { \n \n <ect>
\t2 ecb . init ( fileKey , stripeIx , OrcEncodedColumnBatch . ALL_RGS , physicalFileIncludes . length ) ; \n \n \t2 try { \n \n \t2 consumer . consumeData ( ecb ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t3 result . addStep ( parseToJobStep ( task , i , outputs . get ( task . getId ( ) ) ) ) ; } \n \n \t2 return result ; } \n \n \t1 public static JobInstance parseToJobInstance ( CheckpointExecutable job , Map < String , Output > outputs ) { \n \n \t2 if ( job == null ) { \n \n <ect>
\t2 public Integer call ( ) throws Exception { \n \n \t3 try { \n \n \t4 return doCall ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 File compressTo = new File ( pathString + <string_literal> ) ; \n \n \t4 if ( compressTo . exists ( ) ) { \n \n \t5 compressTo . delete ( ) ; } \n \n <ect>
\t2 sendRequest ( requestDocument , SoapAction . SEND ) ; \n \n \t2 logger . debug ( <string_literal> , commandId , shellId ) ; } \n \n \t1 public void signal ( ) { \n \n \t2 if ( commandId == null ) { \n \n <ect>
\t4 modelLearner = new ModelLearner_LOD ( new GraphBuilder ( ontologyManager , false ) , steinerNodes ) ; \n \n \t3 } else if ( ! recreateGraphs && new File ( graphPath ) . exists ( ) ) { \n \n \t4 <comment> \n \n \t4 try { \n \n <ect>
\t3 renderResponse ) ; \n \n \t2 filterChain . doFilter ( renderRequest , testRenderResponse ) ; \n \n \t2 PrintWriter printWriter = renderResponse . getWriter ( ) ; \n \n \t2 printWriter . print ( testRenderResponse . getString ( ) ) ; \n \n <ect>
\t3 VmwareManager mgr = context . getStockObject ( VmwareManager . CONTEXT_STOCK_NAME ) ; \n \n \t3 return ( PrimaryStorageDownloadAnswer ) mgr . getStorageManager ( ) . execute ( this , cmd ) ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t2 int val = nearKey + 1 ; \n \n \t2 for ( int i = 0 ; i < GRID_CNT ; i ++ ) { \n \n \t3 delay ( ) ; \n \n \t3 GridCache < Integer , Integer > cache = grid ( i ) . cache ( null ) ; \n \n <ect>
\t3 return answer ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n \t4 hostService . invalidateServiceContext ( context ) ; } \n \n <ect>
\t4 default : \n \n \t5 throw new UnsupportedOperationException ( <string_literal> + v . getType ( ) ) ; } } \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t8 log . warn ( <string_literal> + cacheKey ) ; } \n \n \t6 } else if ( ex instanceof ResourceIOException ) { \n \n <ect>
\t4 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t4 while ( rs . next ( ) ) { \n \n \t5 l . add ( rs . getLong ( 1 ) ) ; } \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
<comment> \n \n public AbstractLinter setOptions ( final String . . . options ) { \n \n \t1 this . options = StringUtils . join ( options , ' , ' ) ; \n \n <ect>
<comment> \n \n \t1 private void sendSource ( String host , String source ) { \n \n \t2 String url = <string_literal> + host + <string_literal> ; \n \n \t2 String content = <string_literal> id \\ <string_literal> <string_literal> \\ <string_literal> ; \n \n <ect>
\t3 HttpsURLConnection . setDefaultHostnameVerifier ( hv ) ; \n \n \t2 } catch ( NoSuchAlgorithmException e ) { \n \n \t3 <comment> \n \n \t2 } catch ( KeyManagementException e ) { \n \n <ect>
\t2 else : \n \n \t3 metadata_port = atlas_server_default_https_port \n \n \t1 atlas_rest_address_list = [ <string_literal> . format ( scheme , hostname , metadata_port ) for hostname in atlas_host_names ] \n \n \t1 atlas_rest_address = <string_literal> . join ( atlas_rest_address_list ) \n \n <ect>
\t2 logWriter . close ( ) ; \n \n \t2 logWriter = null ; \n \n \t2 logFile = null ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 txn . start ( ) ; \n \n \t3 parentDomain = this . lockRow ( parent , true ) ; \n \n \t3 if ( parentDomain == null ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t2 Thread . currentThread ( ) . interrupt ( ) ; } } \n \n \t1 for ( ComponentId c : ComponentIds . list ( ) ) { \n \n \t2 if ( c . hasCredentials ( ) ) { \n \n <ect>
<comment> \n \n \t1 @ GetMapping ( path = SamlIdPConstants . ENDPOINT_SAML2_SSO_PROFILE_POST_CALLBACK ) \n \n \t1 protected void handleCallbackProfileRequest ( final HttpServletResponse response , final HttpServletRequest request ) throws Exception { \n \n <ect>
\t4 logger . trace ( <string_literal> , this . getNode ( ) . getNodeId ( ) ) ; \n \n \t4 processThermostatFanStateReport ( serialMessage , offset , endpoint ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t1 cmd . execute ( ) \n \n \t1 if cmd . state is not <string_literal> or cmd . getretcode ( ) != 0 : \n \n \t2 logger . error ( <string_literal> . format ( cmd , cmd . getretcode ( ) ) ) \n \n \t2 ret = 1 \n \n <ect>
\t3 <comment> \n \n \t3 R2RMLMappingIdentifier modelIdentifier = new R2RMLMappingIdentifier ( \n \n \t5 <string_literal> , new URL ( r2rmlURI ) ) ; \n \n \t3 rdfGen . addModel ( modelIdentifier ) ; \n \n <ect>
\t7 Row row = table . addRow ( factory ) ; \n \n \t7 row . setValue ( splitValueHNodeId , rowVal , \n \n \t9 NodeStatus . edited , factory ) ; } } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 GridNearTxFinishFuture < K , V > fut = ( GridNearTxFinishFuture < K , V > ) ctx . mvcc ( ) . < GridCacheTx > future ( \n \n \t3 res . xid ( ) , res . futureId ( ) ) ; \n \n \t2 if ( fut == null ) { \n \n <ect>
\t2 try { \n \n \t3 NetworkGroup restoredGroup = NetworkGroups . create ( userFullName , orphanedSecGrp , orphanedSecGrp ) ; \n \n \t3 networks . add ( restoredGroup ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 boolean finished = false ; \n \n \t2 ItemIterable < CmisObject > itemIterable = folder . getChildren ( operationContext ) ; \n \n \t2 while ( ! finished ) { \n \n \t3 ItemIterable < CmisObject > currentPage = itemIterable . skipTo ( count ) . getPage ( ) ; \n \n <ect>
<comment> \n \n @ Override \n \n public void destroyLoadBalancer ( final String id ) { \n \n \t1 checkNotNull ( id , <string_literal> ) ; \n \n <ect>
\t4 for ( String contact : contacts ) \n \n \t5 chatRoom . invite ( contact , reason ) ; } } \n \n \t2 catch ( OperationFailedException ex ) \n \n \t2 { \n \n <ect>
\t3 } catch ( NoSuchPortException nspe ) { \n \n \t4 logger . error ( <string_literal> , portName , nspe ) ; \n \n \t4 return false ; \n \n \t3 } catch ( PortInUseException piue ) { \n \n <ect>
\t1 { } \n \n \t1 @ Override \n \n \t1 public void start ( ) \n \n \t1 { \n \n <ect>
\t2 for ( LanguageChangedListener listener : languageChangedListeners ) { \n \n \t3 try { \n \n \t4 listener . languageChanged ( new LanguageChangedEvent ( locale ) ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 s_logger . error ( <string_literal> + api . getTestCaseInfo ( ) + <string_literal> + api . getUrl ( ) ) ; \n \n \t3 } else { \n \n \t4 <comment> \n \n \t4 if ( api . setParam ( this . getParam ( ) ) == false ) { \t1 \n \n <ect>
protected void insertMetricRecords ( Connection conn , TimelineMetrics metrics , long currentTime ) \n \n \t9 throws SQLException , IOException { \n \n \t1 List < TimelineMetric > timelineMetrics = metrics . getMetrics ( ) ; \n \n \t1 if ( timelineMetrics == null || timelineMetrics . isEmpty ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 while ( newGroupsEnum . hasMoreElements ( ) ) \n \n \t2 { \n \n \t3 String groupName = newGroupsEnum . nextElement ( ) ; \n \n <ect>
\t2 if ( ! x . isLiteral ( ) ) { \n \n \t3 log . warn ( <string_literal> + list ) ; \n \n \t3 return null ; } \n \n \t2 if ( ! SpatialValueUtil . isDecimal ( x ) ) { \n \n <ect>
\t4 logger . warn ( <string_literal> , e ) ; \n \n \t3 } catch ( NotConnectedException e ) { \n \n \t4 logger . warn ( <string_literal> , e ) ; } \n \n \t2 } catch ( NotInitializedException e ) { \n \n <ect>
\t7 s_logger . debug ( <string_literal> + work . getId ( ) ) ; } \n \n \t6 return changeState ( vm , Event . AgentReportStopped , null , work , Step . Done ) ; \n \n \t5 } catch ( NoTransitionException e ) { \n \n <ect>
\t2 final Set < Map . Entry < String , Object > > values = names \n \n \t4 . stream ( ) \n \n \t4 . filter ( e - > { \n \n \t5 final Set < Object > valuesCol = CollectionUtils . toCollection ( e . getValue ( ) ) ; \n \n <ect>
\t1 return SelendroidResponse . forCatchAllError ( getSessionId ( request ) , e ) ; \n \n \t1 } catch ( Error e ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t3 case CurrentTemperature : \n \n \t4 BigDecimal currentTemperature = deviceInfo . getCurrentTemperature ( ) ; \n \n \t4 if ( currentTemperature . intValue ( ) == <number_literal> ) { \n \n \t5 <comment> \n \n <ect>
\t8 ChannelListener < Object > l = en . getValue ( ) ; \n \n \t8 if ( l instanceof MessageListener ) { \n \n \t9 ( ( MessageListener ) l ) . onTextMessage ( en . getKey ( ) , txt , remining ) ; } \n \n \t7 } catch ( Throwable e ) { \n \n <ect>
\t2 factory . setNamespaceAware ( true ) ; \n \n \t2 try { \n \n \t3 docBuilder = factory . newDocumentBuilder ( ) ; \n \n \t2 } catch ( ParserConfigurationException pcE ) { \n \n <ect>
\t3 logger . error ( <string_literal> , timeout , e ) ; \n \n \t2 } catch ( ExecutionException e ) { \n \n \t3 logger . error ( <string_literal> , timeout , e ) ; \n \n \t2 } catch ( TimeoutException e ) { \n \n <ect>
\t3 while ( it . hasNext ( ) ) { \n \n \t4 String tag = it . next ( ) ; \n \n \t4 if ( tag . startsWith ( <string_literal> ) ) { \n \n \t5 if ( tag . contains ( version ) ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> , entry ) ; \n \n \t3 return true ; } \n \n \t2 if ( lastUpdate != null ) { \n \n \t3 if ( lastUpdate . after ( updated ) ) { \n \n <ect>
\t4 logger . error ( <string_literal> , errors ) ; \n \n \t3 throw e ; } } \n \n \t1 @ Override \n \n \t1 public void stop ( int n ) { \n \n <ect>
\t2 Iterator < WebService > itr = servicesAndMappings . keySet ( ) . iterator ( ) ; \n \n \t2 if ( itr != null && itr . hasNext ( ) ) { \n \n \t3 service = itr . next ( ) ; } \n \n \t2 if ( service == null ) { \n \n <ect>
\t4 return new ExecuteResult ( ExecuteResult . State . DISCARDED , output . toString ( ) ) ; \n \n \t3 } else { \n \n \t4 return new ExecuteResult ( ExecuteResult . State . STOPPED , output . toString ( ) ) ; } \n \n \t2 } catch ( ReflectiveOperationException e ) { \n \n <ect>
\t1 @ Override public Integer reduce ( List < GridComputeJobResult > results ) throws GridException { \n \n \t2 assert results . size ( ) == 1 : <string_literal> + results . size ( ) + <string_literal> + 1 + ' ] ' ; \n \n \t2 GridComputeJobResult res = results . get ( 0 ) ; \n \n <ect>
<comment> \n \n \t3 try { \n \n \t4 HostManager . getMembershipChannel ( ) . getState ( v . getMembers ( ) . get ( 0 ) , 0L ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 SubjectMessageCallback < Cluster , ? , ? > callback = callbackClass . newInstance ( ) ; \n \n \t4 LOG . error ( <string_literal> + subject + <string_literal> + callbackClass . getCanonicalName ( ) ) ; \n \n \t4 return callback ; } \n \n \t3 } catch ( RuntimeException ex ) { \n \n <ect>
\t5 ( ( CCNHandle ) handle ) . getNetworkManager ( ) . setTap ( SystemConfiguration . DEBUG_DATA_DIRECTORY + <string_literal> + Integer . toString ( id ) + <string_literal> ) ; \n \n \t4 } catch ( IOException ie ) { } } } \n \n \t2 public void run ( ) { \n \n \t3 try { \n \n <ect>
\t3 { \n \n \t4 return value ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t2 Book book = new Book ( <string_literal> , <string_literal> ) ; \n \n \t2 String response = sendAddToCatalogRequest ( template , routeboxUri , <string_literal> , book ) ; \n \n \t2 assertEquals ( <string_literal> + book . getAuthor ( ) + <string_literal> + book . getTitle ( ) + <string_literal> , response ) ; \n \n \t2 book = sendFindBookRequest ( template , routeboxUri , <string_literal> , <string_literal> ) ; \n \n <ect>
\t4 throw new IllegalArgumentException ( e ) ; } } \n \n \t2 return config ; } \n \n \t1 @ Override \n \n \t1 public void reloadFromData ( ) { \n \n <ect>
\t2 if ( i > 0 ) { \n \n \t2 val rmsePrev = rmseIterations . last \n \n \t2 val convergence = ( rmsePrev - rmse ) / rmsePrev \n \n \t2 if ( convergence < 0 ) { \n \n <ect>
\t3 log ( <string_literal> + ie . getMessage ( ) ) ; \n \n \t3 return false ; \n \n \t2 } catch ( IOException ioe ) { \n \n \t3 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t5 break ; } \n \n \t4 String line = DataHelper . getUTF8 ( baos . toByteArray ( ) ) ; \n \n \t4 baos . reset ( ) ; \n \n \t4 if ( _log . shouldDebug ( ) ) \n \n <ect>
\t5 return OFFER_STATUS . TRY_ANOTHER ; } \n \n \t4 try { \n \n \t5 pubKey = DSAPublicKey . create ( ( ( ShortBuffer ) pk . getObject ( DMT . PUBKEY_AS_BYTES ) ) . getData ( ) ) ; \n \n \t4 } catch ( CryptFormatException e ) { \n \n <ect>
\t2 try { \n \n \t3 for ( T entity : entities ) { \n \n \t4 lifecycleHandler . onPrePersist ( entity ) ; \n \n \t4 if ( verbose ) \n \n <ect>
\t3 adminProperties . setProperty ( <string_literal> , <string_literal> ) ; \n \n \t3 adminClient = new AdminClient ( servers [ 0 ] . getMetadataStore ( ) . getCluster ( ) , \n \n \t10 new AdminClientConfig ( adminProperties ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 PreparedStatement prSt = null ; \n \n \t1 int sequencevalue = 0 ; \n \n \t1 ResultSet rs = null ; \n \n \t1 prSt = ambaridatabase . getSequenceNoFromAmbariSequence ( c , id ) ; \n \n <ect>
\t2 bw . flush ( ) ; } } \n \n \t1 bw . close ( ) ; \n \n \t1 attempts [ attempt ] = System . currentTimeMillis ( ) - now ; } \n \n \t1 Arrays . sort ( attempts ) ; \n \n <ect>
\t4 <comment> \n \n \t4 LOG . warn ( <string_literal> , getInProgressCompleteExchanges ( ) ) ; \n \n \t4 break ; } } \n \n \t2 if ( expected > 0 ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , attributeName ) ; \n \n \t2 if ( excludeUnmappedAttributes ) { \n \n \t3 LOGGER . debug ( <string_literal> , attributeName ) ; \n \n \t2 } else { \n \n <ect>
\t4 if ( button < 0 ) { \n \n \t5 handleNoButtons ( cmd2 , a , msg ) ; \n \n \t4 } else { \n \n \t5 boolean isOn = isLEDLit ( cmd2 , button ) ; \n \n <ect>
\t4 previous = sortableSemanticModels . get ( i - 1 ) ; \n \n \t4 if ( current . getScore ( ) == previous . getScore ( ) && current . getCost ( ) == previous . getCost ( ) ) \n \n \t5 continue ; \n \n \t4 uniqueModels . add ( current ) ; } } \n \n <ect>
\t2 . caseInstanceId ( caseInstanceId ) \n \n \t2 . activityId ( <string_literal> ) \n \n \t2 . singleResult ( ) \n \n \t2 . getId ( ) ; \n \n <ect>
\t7 if ( e . getErrorCode ( ) == <number_literal> ) { \n \n \t8 logger . debug ( <string_literal> + name ) ; \n \n \t7 } else { \n \n \t8 logger . debug ( <string_literal> + name ) ; } \n \n <ect>
\t1 this . module = module ; \n \n \t1 this . analysisMode = analysisMode ; } \n \n @ Override \n \n protected void doBeforeStart ( ) { \n \n <ect>
\t4 logger . warn ( <string_literal> ) ; \n \n \t4 Thread . dumpStack ( ) ; \n \n \t4 return ; } \n \n \t2 } catch ( java . lang . IllegalStateException ise ) { \n \n <ect>
\t2 log . info ( <string_literal> + topicStr + \n \n \t3 <string_literal> ) ; \n \n \t2 log . debug ( <string_literal> , kafkaOffsets ) ; \n \n \t2 return ; } \n \n <ect>
\t4 final DeleteLogicalRouterPortAnswer answerDelete = ( DeleteLogicalRouterPortAnswer ) agentMgr . easySend ( niciraNvpHost . getId ( ) , cmdDeletePort ) ; \n \n \t4 if ( answerDelete != null && answerDelete . getResult ( ) ) { \n \n \t5 s_logger . info ( <string_literal> + logicalRouterPortUuid ) ; } \n \n \t4 else { \n \n <ect>
\t3 super . close ( ) ; \n \n \t3 if ( Files . deleteIfExists ( file . toPath ( ) ) ) { \n \n \t4 log . debug ( <string_literal> , file . getAbsolutePath ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t1 result . writeTo ( fos ) ; \n \n \t1 fos . flush ( ) ; \n \n \t1 fos . close ( ) ; \n \n \t1 } catch ( FileNotFoundException e ) { \n \n <ect>
\t3 fis = new FileInputStream ( _peerDestFile ) ; \n \n \t3 peer = new Destination ( ) ; \n \n \t3 peer . readBytes ( fis ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t9 if ( profiler . getDuration ( ) > <number_literal> ) { \n \n <number_literal> s_logger . debug ( <string_literal> + profiler . getDuration ( ) + <string_literal> ) ; } \n \n \t9 } else { \n \n <ect>
\t2 } catch ( InsufficientCapacityException e ) { \n \n \t3 LOG . warn ( <string_literal> + name ) ; \n \n \t3 return ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 File storeParentDirectory = fileStore . getParentFile ( ) ; \n \n \t3 if ( storeParentDirectory != null && ! storeParentDirectory . exists ( ) ) { \n \n <ect>
\t3 webSocketData . setRawResultCount ( resultCountBeforePaging ) ; \n \n \t3 <comment> \n \n \t3 getWebSocket ( ) . send ( webSocketData , true ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 while ( true ) { \n \n \t4 LOG . warn ( <string_literal> + path ) ; \n \n \t4 doPopulate ( ) ; \n \n \t4 waitOutstanding ( ) ; \n \n <ect>
\t2 } catch ( Throwable t1 ) { \n \n \t3 try { \n \n \t4 callback . onFailure ( t1 ) ; \n \n \t3 } catch ( Throwable t2 ) { \n \n <ect>
\t1 fallbackStorageFile . createNewFile ( ) ; \n \n \t1 LOG . debug ( <string_literal> , fallbackStorageFile ) ; \n \n \t1 } else { \n \n \t1 fallbackStorage . load ( new AutoCloseInputStream ( new FileInputStream ( fallbackStorageFile ) ) ) ; \n \n <ect>
\t5 return cacheUpdateHandler . updateParentCacheEntry ( request . getRequestUri ( ) , existing , entry , variantKey , variantCacheKey ) ; } \n \n \t3 } ) ; \n \n \t2 } catch ( final HttpCacheUpdateException ex ) { \n \n <ect>
\t1 } ; \n \n \t1 try { \n \n \t1 Entities . asTransaction ( VmInstance . class , funcName ) . apply ( this . getRequest ( ) . getInstanceId ( ) ) ; \n \n \t1 } catch ( NoSuchElementException e1 ) { \n \n <ect>
\t3 { \n \n \t4 logger . warn ( <string_literal> ) ; } } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t6 vmMo = dcMo . findVm ( vmName ) ; } \n \n \t5 List < Map < String , String > > dynamicTargetsToRemove = null ; \n \n \t5 if ( vmMo != null ) { \n \n <ect>
\t1 return response ; } \n \n public static WebApplicationException createRESTException ( String errorMessage , MessageEnums messageEnum ) { \n \n \t1 VResponse response = createMessageResponse ( errorMessage , messageEnum ) ; \n \n \t1 WebApplicationException webAppEx = createRESTException ( response ) ; \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t1 root . setLevel ( org . apache . log4j . Level . DEBUG ) ; \n \n \t1 try { \n \n \t1 testServer . resetServer ( ) ; \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t3 decorateMessage ( new JobManagerLeaderAddress ( leaderAddress , leaderSessionID ) ) , \n \n \t3 getSelf ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public void handleError ( Exception exception ) { \n \n <ect>
\t2 assertThat ( routingTable . index ( <string_literal> ) . shard ( 0 ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( nodeHoldingPrimary ) ) ; \n \n \t2 assertThat ( routingTable . index ( <string_literal> ) . shard ( 0 ) . replicaShards ( ) . size ( ) , equalTo ( 1 ) ) ; \n \n \t2 assertThat ( routingTable . index ( <string_literal> ) . shard ( 0 ) . replicaShards ( ) . get ( 0 ) . state ( ) , equalTo ( UNASSIGNED ) ) ; \n \n \t2 assertThat ( routingTable . index ( <string_literal> ) . shard ( 0 ) . replicaShards ( ) . get ( 0 ) . currentNodeId ( ) , nullValue ( ) ) ; \n \n <ect>
\t1 throw exception ; } \n \n protected NoSuchElementException throwNoSuchElementExceptionAfterLoggingHardwareIds ( String message , Iterable < ? extends Hardware > hardwares ) { \n \n \t1 NoSuchElementException exception = new NoSuchElementException ( message ) ; \n \n <ect>
\t3 System . out . println ( <string_literal> + configFilePath + <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 List < Integer > ports = configFile . getIntegers ( <string_literal> ) ; \n \n \t2 if ( ports . isEmpty ( ) ) { \n \n <ect>
\t1 Optional < String > leader = appState . getLeaderHostName ( ) ; \n \n \t1 if ( leader . isPresent ( ) ) { \n \n \t2 LOG . info ( <string_literal> , leader . get ( ) ) ; \n \n \t1 } else { \n \n <ect>
\t2 store . setDirectory ( directory ) ; \n \n \t2 store . start ( ) ; \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 new Job ( i , PListTestSupport . TaskType . ADD , <number_literal> ) . run ( ) ; } \n \n <ect>
\t4 } else if ( isNotEmpty ( item ) ) { \n \n \t5 logger . debug ( <string_literal> , name ) ; \n \n \t5 processFile ( item , name , request ) ; \n \n \t4 } else { \n \n <ect>
\t4 objects = client . listObjects ( name , path ) ; } \n \n \t3 return objects ; } \n \n \t2 else \n \n \t2 { \n \n <ect>
\t2 try { \n \n \t3 final TicketGrantingTicket ticketGrantingTicket = this . centralAuthenticationService . getTicket ( ticketGrantingTicketId , TicketGrantingTicket . class ) ; \n \n \t3 return ticketGrantingTicket . getAuthentication ( ) . getPrincipal ( ) ; \n \n \t2 } catch ( final InvalidTicketException e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlHandlerConfigurationError ( Throwable t ) { \n \n <ect>
\t1 private ApiConnector _spy ; \n \n \t1 @ BeforeClass \n \n \t1 public static void globalSetUp ( ) throws Exception { \n \n \t2 ApiConnectorFactory . setImplementation ( ApiConnectorMockito . class ) ; \n \n <ect>
\t4 dl . setCurrState ( vmTemplateStore . getDownloadState ( ) ) ; } \n \n \t3 try { \n \n \t4 ep . sendMessageAsync ( dcmd , new UploadListener . Callback ( ep . getId ( ) , dl ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 <comment> \n \n \t3 DispatchRunnable runnable = new DispatchRunnable ( dispatcher , notification ) ; \n \n \t3 m_executor . execute ( runnable ) ; \n \n \t3 } catch ( Exception exception ) { \n \n <ect>
\t3 session . close ( ) ; \n \n \t2 } catch ( final Exception e ) { \n \n \t3 LOGGER . warn ( e . getMessage ( ) , e ) ; } \n \n \t2 try { \n \n <ect>
\t3 rs . close ( ) ; \n \n \t3 if ( resultCount == 0 ) { \n \n \t4 LOG . warn ( <string_literal> , resourceId ) ; \n \n \t3 } else if ( resultCount > 1 ) { \n \n <ect>
\t3 throw new RuntimeException ( message ) ; } \n \n \t2 { \n \n \t3 log . info ( <string_literal> + nativeSearchString ) ; \n \n <ect>
\t1 if ( fileHandle != null ) { \n \n \t2 try { \n \n \t2 fileHandle . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 try { \n \n \t3 closeWal ( bw , entry . getKey ( ) ) ; \n \n \t3 recordsClosed ++ ; \n \n \t2 } catch ( MutationsRejectedException e ) { \n \n <ect>
\t2 LOGGER . debug ( \n \n \t4 <string_literal> , \n \n \t4 configKeywordPrefix , maxSize , expireSeconds , initialCapacity , concurrencyLevel ) ; } \n \n \t1 private boolean cacheIsEnabled ( ) { \n \n <ect>
\t6 log . info ( <string_literal> + rsrc8 ) ; \n \n \t6 log . info ( <string_literal> + log ) ; \n \n \t6 log . info ( <string_literal> + grid ) ; \n \n \t6 log . info ( <string_literal> + nodeId ) ; \n \n <ect>
\t3 if ( establisher . getInboundState ( alice ) != null ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 String user = null ; \n \n \t1 try { \n \n \t2 user = SecurityUtils . getUGI ( ) . getShortUserName ( ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 <comment> \n \n \t1 } catch ( InterruptedException e ) { \n \n \t1 <comment> \n \n \t1 getKafkaConsumer ( ) ; \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 log . warn ( <string_literal> , e ) ; \n \n \t3 result . setResultForFailure ( e . getMessage ( ) ) ; \n \n \t2 } catch ( ParserConfigurationException e ) { \n \n <ect>
\t2 ThriftUtil . transportFactory ( maxMessageSize ) , protocolFactory , pool ) ; \n \n \t1 if ( address . getPort ( ) == 0 ) { \n \n \t1 address = HostAndPort . fromParts ( address . getHost ( ) , \n \n \t2 transport . getServerSocket ( ) . getLocalPort ( ) ) ; \n \n <ect>
\t2 configureSecureTransport ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> , ( Object [ ] ) this . igniteConfiguration . getCacheConfiguration ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , this . igniteConfiguration . getDiscoverySpi ( ) ) ; \n \n <ect>
\t4 if ( executorService != null ) { \n \n \t5 executorService . shutdownNow ( ) ; \n \n \t5 executorService . awaitTermination ( 1 , TimeUnit . SECONDS ) ; } } \n \n \t2 } else { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t2 this . encryptionEnabled = encryptionEnabled ; \n \n \t2 if ( this . encryptionEnabled ) { \n \n \t3 configureEncryptionParameters ( secretKeyEncryption , contentEncryptionAlgorithmIdentifier ) ; \n \n \t2 } else { \n \n <ect>
\t5 _state . addSkipped ( peer ) ; \n \n \t5 skipped ++ ; \n \n \t4 } else if ( ! shouldStoreTo ( ( RouterInfo ) ds ) ) { \n \n \t5 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 this . agentConfig = createAgentConfig ( ) ; \n \n \t2 try { \n \n \t3 new ArchLoaderInit ( ) . init ( agentConfig . getHome ( ) . getNativeDirectory ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 LOG . info ( <string_literal> ) ; \n \n \t5 start . await ( ) ; \n \n \t5 LOG . info ( <string_literal> , temp ) ; \n \n \t5 FileUtils . copyInputStreamToFile ( fStream , temp ) ; \n \n <ect>
\t4 _log . error ( <string_literal> + state . getRemoteHostId ( ) . toString ( ) ) ; \n \n \t3 packet . release ( ) ; \n \n \t3 return null ; } \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t9 String name , String value ) { \n \n \t2 if ( subject . hasProperty ( RDF . type , DMRM . ResourceGenerator ) ) { \n \n \t3 String generatedIRI = parseResourceGenerator ( subject , value , dsoIRI ) ; \n \n \t3 if ( generatedIRI == null ) { \n \n <ect>
\t3 try { \n \n \t4 materializeJobs ( false , job , jobConf , store ) ; \n \n \t4 updateJobTable ( job , store ) ; } \n \n \t3 catch ( CommandException ex ) { \n \n <ect>
private void zipDirectory ( ZipOutputStream zip , String path ) { \n \n \t1 try { \n \n \t1 zip . putNextEntry ( new ZipEntry ( path . substring ( 1 ) + <string_literal> ) ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t5 String req = <string_literal> + dest + <string_literal> + sopts + ' \\ n' ; \n \n \t5 samOut . write ( req . getBytes ( <string_literal> ) ) ; \n \n \t5 samOut . flush ( ) ; \n \n \t5 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 { \n \n \t4 addExtensionProvider ( elementName , namespace , provider ) ; } } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + router + <string_literal> ) ; \n \n \t3 _commandSetupHelper . createDhcpEntryCommandsForVMs ( router , cmds , guestNetworkId ) ; } \n \n \t2 if ( _networkModel . isProviderSupportServiceInNetwork ( guestNetworkId , Service . UserData , provider ) ) { \n \n \t3 <comment> \n \n <ect>
\t1 Object id = s . nextId ( null ) ; \n \n \t1 assertThat ( id ) . isEqualTo ( 1L ) ; \n \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 Object val = s . nextId ( null ) ; \n \n <ect>
\t2 if ( GROUPS_METHOD != null ) { \n \n \t3 try { \n \n \t4 return ( Map < String , Integer > ) GROUPS_METHOD . invoke ( pattern ) ; \n \n \t3 } catch ( ReflectiveOperationException ex ) { \n \n <ect>
\t4 if ( logDEBUG ) Logger . debug ( this , <string_literal> + c ) ; \n \n \t4 break ; } \n \n \t4 break ; \n \n \t3 case STATE1INQUOTE : \n \n <ect>
\t2 final String authorizationHeader = request . getHeader ( SpnegoConstants . HEADER_AUTHORIZATION ) ; \n \n \t2 final String userAgent = HttpRequestUtils . getHttpServletRequestUserAgent ( request ) ; \n \n \t2 LOGGER . debug ( <string_literal> , authorizationHeader , userAgent ) ; \n \n \t2 if ( ! StringUtils . hasText ( userAgent ) || this . supportedBrowser . isEmpty ( ) ) { \n \n <ect>
\t4 write_block_size , prev_lot_end_value , prev_lot_end_id , json_file ) : \n \n if os . path . exists ( tmp_file_path ) : \n \n \t1 os . remove ( tmp_file_path ) \n \n tmp_file = open ( tmp_file_path , 'w' ) \n \n <ect>
\t2 WOActionResults result = null ; \n \n \t2 if ( ERSelenium . testsEnabled ( ) ) { \n \n \t3 result = super . performActionNamed ( anActionName ) ; \n \n \t2 } else { \n \n <ect>
\t2 st . close ( ) ; } \n \n \t2 if ( null != manager ) { \n \n \t2 manager . close ( ) ; } \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t3 Functor setMethod = writeFunctors . get ( i ) ; \n \n \t3 if ( setMethod != null \n \n \t4 && ! setMethod . checkMethod ( value , getColumnClass ( i ) ) ) { \n \n \t5 status = false ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t2 logger . debug ( <string_literal> , this . getNode ( ) . getNodeId ( ) , this . getVersion ( ) ) ; \n \n \t2 int command = serialMessage . getMessagePayloadByte ( offset ) ; \n \n \t2 switch ( command ) { \n \n \t3 case SENSOR_BINARY_GET : \n \n <ect>
\t4 return null ; } \n \n \t3 UUID userId = session . get ( ) . getUserId ( ) ; \n \n \t3 Optional < User > _user = UserManager . instance . getUser ( userId ) ; \n \n \t3 if ( ! _user . isPresent ( ) ) { \n \n <ect>
\t4 } else if ( isNotEmpty ( item ) ) { \n \n \t5 logger . debug ( <string_literal> , name ) ; \n \n \t5 processFile ( item , name ) ; \n \n \t4 } else { \n \n <ect>
\t2 try { \n \n \t3 return ( List < String > ) context . getWiki ( ) . getGroupService ( context ) \n \n \t4 . getAllMatchedGroups ( null , false , 0 , 0 , null , context ) ; \n \n \t2 } catch ( XWikiException e ) { \n \n <ect>
\t4 break ; \n \n \t3 case AlgorithmIdentifiers . RSA_USING_SHA256 : \n \n \t3 default : \n \n \t4 hashAlg = MessageDigestAlgorithms . SHA_256 ; } \n \n <ect>
\t3 return false ; } \n \n \t2 NicVO nicVO = nicDao . findById ( nic . getId ( ) ) ; \n \n \t2 List < NiciraNvpDeviceVO > devices = niciraNvpDao . listByPhysicalNetwork ( network . getPhysicalNetworkId ( ) ) ; \n \n \t2 if ( devices . isEmpty ( ) ) { \n \n <ect>
\t1 } catch ( IllegalAccessException e ) { \n \n \t1 logger . warn ( <string_literal> , e ) ; \n \n \t1 Throwables . propagate ( e ) ; \n \n \t1 } catch ( InvocationTargetException e ) { \n \n <ect>
\t4 String data = bReader . readLine ( ) ; \n \n \t4 logger . trace ( <string_literal> , data ) ; \n \n \t4 notifyEventProcessors ( data ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 assertThat ( <string_literal> + initShard + <string_literal> + newState . routingTable ( ) , newState , not ( equalTo ( state ) ) ) ; \n \n \t2 assertTrue ( initShard + <string_literal> + newState . routingTable ( ) , \n \n \t4 newState . routingTable ( ) . index ( <string_literal> ) . shard ( initShard . id ( ) ) . allShardsStarted ( ) ) ; \n \n \t2 state = newState ; \n \n <ect>
\t5 endpointId ) ; \n \n \t2 } else { \n \n \t3 serialMessage = node . encapsulate ( commandClass . getValueMessage ( ) , commandClass , endpointId ) ; } \n \n \t2 if ( serialMessage == null ) { \n \n <ect>
\t2 return address ; } \n \n \t1 @ Override \n \n \t1 public void notifyLeaderAddress ( String leaderAddress , UUID leaderSessionID ) { \n \n \t2 synchronized ( lock ) { \n \n <ect>
\t6 Thread . sleep ( <number_literal> * <number_literal> ) ; \n \n \t6 log . info ( <string_literal> ) ; \n \n \t6 actx . dispatch ( ) ; \n \n \t5 } catch ( InterruptedException x ) { \n \n <ect>
\t2 cleanObjectHistoriesInBucket ( b , timeoutLevelSupplier ) ; \n \n \t2 buckets . remove ( idx ) ; \n \n \t2 bucketsCleaned ++ ; } \n \n \t1 } catch ( final Throwable f ) { \n \n <ect>
\t3 _itMgr . advanceStart ( router . getUuid ( ) , params , planToDeploy , null ) ; \n \n \t2 } catch ( final OperationTimedoutException e ) { \n \n \t3 throw new ResourceUnavailableException ( <string_literal> + router + <string_literal> + e . toString ( ) , DataCenter . class , router . getDataCenterId ( ) ) ; } \n \n \t2 if ( router . isStopPending ( ) ) { \n \n <ect>
\t2 PortletContext portletContext = getPortletContext ( ) ; \n \n \t2 PortletRequestDispatcher portletRequestDispatcher = \n \n \t3 portletContext . getRequestDispatcher ( <string_literal> ) ; \n \n \t2 if ( portletRequestDispatcher == null ) { \n \n <ect>
\t2 OutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; \n \n \t2 document . save ( byteArrayOutputStream ) ; \n \n \t2 return byteArrayOutputStream ; } \n \n \t1 private String doExtractText ( Exchange exchange ) throws IOException { \n \n <ect>
\t4 prefixedTopic = context . getWikiId ( ) + <string_literal> + topic ; \n \n \t4 localTopic = topic ; } \n \n \t3 XWikiDocument doc = null ; \n \n \t3 try { \n \n <ect>
<comment> \n \n \t1 public void onSuccess ( StreamState state ) \n \n \t1 { \n \n <ect>
\t3 processTransitionByDate ( ruleId , bucket , prefix , rule . getTransitionDate ( ) ) ; \n \n \t2 } else if ( rule . getTransitionDays ( ) != null ) { \n \n \t3 processTransitionByDays ( ruleId , bucket , prefix , rule . getExpirationDays ( ) ) ; } \n \n \t2 } else { \n \n <ect>
private static Iterable < String > iterateRangesAsString ( Iterable < String > rangeIterable ) { \n \n \t1 Iterables . transform ( iterateRanges ( rangeIterable ) . left , PrivateAddresses . fromInteger ( ) ) } \n \n private static Supplier < Void > managedFaultSupplier ( ) { \n \n \t1 return { \n \n <ect>
\t3 if ( theScriptFile . exists ( ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , theScriptFile . getCanonicalPath ( ) ) ; \n \n \t4 engine . eval ( Files . newBufferedReader ( theScriptFile . toPath ( ) , StandardCharsets . UTF_8 ) ) ; \n \n \t4 final Invocable invocable = ( Invocable ) engine ; \n \n <ect>
\t2 Exception cause = exchange . getException ( ) ; \n \n \t2 if ( cause != null ) { \n \n \t3 LOG . warn ( <string_literal> + exchange , cause ) ; \n \n \t2 } else { \n \n <ect>
} ; \n \n BrowserBot . prototype . openLocation = function ( target ) { \n \n \t1 <comment> \n \n \t1 var win = this . getCurrentWindow ( ) ; \n \n <ect>
<comment> \n \n void addFileForUpload ( String fileToUpload ) { \n \n \t1 boolean offerStatus = fileContextsToUpload . offer ( fileToUpload ) ; \n \n \t1 if ( ! offerStatus ) { \n \n <ect>
\t5 browserout . write ( ERR_UNAVAILABLE . getBytes ( <string_literal> ) ) ; \n \n \t4 } catch ( IOException ioe ) { } \n \n \t3 } catch ( IOException ioe ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 log . debug ( <string_literal> , failoverPolicy . sleepBetweenHostsMilli ) ; } \n \n \t1 try { \n \n \t2 Thread . sleep ( failoverPolicy . sleepBetweenHostsMilli ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , globalProviderId ) ; \n \n \t2 final Map < String , MultifactorAuthenticationProvider > providerMap = \n \n \t4 MultifactorAuthenticationUtils . getAvailableMultifactorAuthenticationProviders ( this . applicationContext ) ; \n \n \t2 if ( providerMap == null || providerMap . isEmpty ( ) ) { \n \n <ect>
<comment> \n \n \t1 public static void listAvailableCovariates ( final Logger logger ) { \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 for ( final Class < ? extends Covariate > covClass : new PluginManager < Covariate > ( Covariate . class ) . getPlugins ( ) ) { \n \n <ect>
\t3 this . serial = new String ( Arrays . copyOfRange ( this . payload , <number_literal> , this . payload . length ) ) ; } } \n \n \t1 @ Override \n \n \t1 protected void printFormattedPayload ( ) { \n \n \t2 logger . debug ( <string_literal> + this . firmwareMajor + <string_literal> + this . firmwareMinor ) ; \n \n <ect>
\t6 . forName ( mapReduceJobClass , AbstractHadoopJob . class ) . getConstructor ( ) ; \n \n \t4 final AbstractHadoopJob hadoopJob = constructor . newInstance ( ) ; \n \n \t4 hadoopJob . setConf ( conf ) ; \n \n \t4 hadoopJob . setAsync ( true ) ; <comment> \n \n <ect>
\t1 override fun getCompilableFileExtensions ( ) = arrayListOf ( <string_literal> ) \n \n \t1 override fun buildStarted ( context : CompileContext ) { \n \n \t2 LOG . debug ( <string_literal> ) \n \n \t2 LOG . info ( <string_literal> ) \n \n <ect>
\t3 coordinator . setCurrentURI ( entry ) ; \n \n \t3 coordinator . play ( ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t2 buffer [ bufferIndex ++ ] = row ; \n \n \t2 return null ; } \n \n \t1 private void dumpBufferToMFM ( ) { \n \n \t2 if ( bufferIndex > 0 ) { \n \n <ect>
<number_literal> success = ( cleanupResponseCode == <number_literal> ) ; \n \n \t10 } else { \n \n <number_literal> s_logger . info ( <string_literal> ) ; \n \n <number_literal> int stopResponseCode = executeStop ( server , developerServer , username , true ) ; \n \n <ect>
\t1 public boolean deleteAll ( JobID jobId ) { \n \n \t2 return delete ( BlobUtils . getStorageLocationPath ( basePath , jobId ) ) ; } \n \n \t1 private boolean delete ( String blobPath ) { \n \n \t2 try { \n \n <ect>
\t3 if ( ch != null ) { \n \n \t4 try { \n \n \t5 ch . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t3 stringBuilder . insert ( 0 , <string_literal> ) ; \n \n \t2 if ( StringUtils . isNotBlank ( serializationParams . getWrapSuffix ( ) ) ) \n \n \t3 stringBuilder . append ( serializationParams . getWrapSuffix ( ) ) ; \n \n \t2 String json = stringBuilder . toString ( ) ; \n \n <ect>
\t3 directory = VfsUtil . createDirectories ( path ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 Flog . error ( e ) ; } \n \n \t2 if ( directory == null ) { \n \n <ect>
\t2 try { \n \n \t3 if ( m_writeThread != null ) { \n \n \t4 m_writeThread . join ( ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t2 if ( commandLine . hasOption ( <string_literal> ) ) { \n \n \t3 String dbString = commandLine . getOptionValue ( <string_literal> ) ; \n \n \t3 if ( dbString . endsWith ( <string_literal> ) ) { \n \n \t4 dbString = dbString . substring ( 0 , dbString . length ( ) - <number_literal> ) ; \n \n <ect>
\t2 for ( Entry < Class < ? > , Set < Annotation > > entry : getRepositoryTypes ( ) ) { \n \n \t3 Set < Annotation > qualifiers = entry . getValue ( ) ; \n \n \t3 if ( ! redisKeyValueAdapters . containsKey ( qualifiers ) ) { \n \n <ect>
\t3 InputStream is = method . getResponseBodyAsStream ( ) ; \n \n \t3 Map < String , String > successStr = getSingleValueFromXML ( is , new String [ ] { <string_literal> } ) ; \n \n \t3 s_logger . info ( <string_literal> + successStr . get ( <string_literal> ) ) ; \n \n \t2 } else { \n \n <ect>
\t5 <comment> \n \n \t5 return true ; \n \n \t4 } else if ( backoffHandler . handleResponse ( request , response , supportsRetry ) ) { \n \n \t5 <comment> \n \n <ect>
\t3 success = super . remove ( id ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n \t3 success = false ; \n \n <ect>
\t2 if ( aclMode == ZkClientACLMode . CREATOR ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 aclProvider = new SecureAclProvider ( ) ; \n \n \t2 } else { \n \n <ect>
\t1 throw new RuntimeException ( <string_literal> ) ; } } \n \n public RequestStatusResponse scaleHosts ( final ScaleClusterRequest request ) \n \n \t1 throws InvalidTopologyException , AmbariException { \n \n \t1 ensureInitialized ( ) ; \n \n <ect>
\t1 void onChildBootstrap ( ChildBootstrap e ) throws IOException { \n \n \t2 logger . info ( <string_literal> + e . getSlave ( ) . id + <string_literal> + e . getSlave ( ) . getPidString ( ) + <string_literal> ) ; } \n \n \t1 @ Subscribe \n \n \t1 void onHeartbeat ( HeartBeatEvent e ) throws IOException { \n \n <ect>
\t2 FakeFile file = findFile ( filesystem , getStoreFileRequest . file ( ) . getName ( ) ) ; \n \n \t2 if ( file . getRemainingFailed ( ) > 0 ) \n \n \t2 { \n \n \t3 file . setRemainingFailed ( file . getRemainingFailed ( ) - 1 ) ; \n \n <ect>
\t2 } else { \n \n \t3 logger . debug ( <string_literal> + fullAddress ) ; } } \n \n \t1 @ Override \n \n \t1 public void error ( Exception e ) { \n \n <ect>
\t3 result . sec = ( org . apache . accumulo . core . client . impl . thrift . ThriftSecurityException ) e ; \n \n \t3 result . setSecIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t1 EntitySchema entitySchema = parser . parseEntitySchema ( schemaString ) ; \n \n \t1 if ( schemaManager . getEntityVersion ( tableName , entityName , entitySchema ) == - 1 ) { \n \n \t1 schemaManager . migrateSchema ( tableName , entityName , schemaString ) ; \n \n \t1 } else { \n \n <ect>
\t2 stopActiveMqBrokerAndAwait ( ) ; \n \n \t2 this . eventPublisher . expectBrokerAvailabilityEvent ( false ) ; } \n \n \t1 @ Test \n \n \t1 public void relayReconnectsIfBrokerComesBackUp ( ) throws Exception { \n \n <ect>
\t2 for ( long i : allCuboids ) { \n \n \t3 grantTotal += cuboidHLLMap . get ( i ) . getCountEstimate ( ) ; \n \n \t3 logger . info ( <string_literal> + i + <string_literal> + cuboidHLLMap . get ( i ) . getCountEstimate ( ) ) ; } \n \n \t2 logger . info ( <string_literal> + totalRowsBeforeMerge ) ; \n \n <ect>
\t1 int min = 0 ; \n \n \t1 int max = EditorHelper . getFileSize ( editor ) ; \n \n \t1 logger . debug ( <string_literal> + min ) ; \n \n <ect>
\t6 continue \n \n \t5 if vms . has_key ( dir ) : \n \n \t6 logger . debug ( OvmHost . getAllVms , <string_literal> %dir ) \n \n \t6 continue \n \n <ect>
\t1 public final ResultSet executeQuery ( String sql ) throws SQLException { \n \n \t2 if ( this . isClosed ( ) ) \n \n \t3 throw new SQLException ( <string_literal> ) ; \n \n \t2 <comment> \n \n <ect>
\t7 ViewInstanceEntity targetInstanceEntity ) { \n \n \t1 LOG . debug ( <string_literal> , sourceInstanceEntity . getName ( ) , targetInstanceEntity . getName ( ) ) ; \n \n \t1 List < PrivilegeEntity > targetInstancePrivileges = privilegeDAO . findByResourceId ( targetInstanceEntity . getResource ( ) . getId ( ) ) ; \n \n \t1 if ( targetInstancePrivileges . size ( ) > 0 ) { \n \n <ect>
\t2 LOGGER . info ( <string_literal> , token ) ; } \n \n \t1 private void configureJwtEncryption ( final int encryptionSecretSize , final String encryptionAlgorithm , \n \n \t10 final String encryptionMethod , final JwtGenerator < CommonProfile > g ) { \n \n \t2 if ( encryptionSecretSize < = 0 || StringUtils . isBlank ( encryptionMethod ) || StringUtils . isBlank ( encryptionAlgorithm ) ) { \n \n <ect>
\t7 mySocket . send ( requestPacket ) ; \n \n \t6 } catch ( IOException e ) { \n \n \t7 LOG . warn ( <string_literal> , e ) ; } \n \n \t5 } else { \n \n <ect>
\t6 <comment> \n \n \t6 return ; } \n \n \t5 catch ( IOException ee ) { \n \n \t6 lastException = ee ; \n \n <ect>
\t5 try { \n \n \t6 Module mod = ModuleFactory . loadModule ( f ) ; \n \n \t6 log . debug ( <string_literal> + mod + <string_literal> ) ; } \n \n \t5 catch ( Exception e ) { \n \n <ect>
\t2 _vmName = vm . getName ( ) ; \n \n \t2 return new StartAnswer ( cmd ) ; } \n \n \t1 protected ReadyAnswer execute ( ReadyCommand cmd ) { \n \n \t2 <comment> \n \n <ect>
\t3 <comment> \n \n \t3 int task = message . task ( ) ; \n \n \t3 DisruptorQueue queue = deserializeQueues . get ( task ) ; \n \n \t3 if ( queue == null ) { \n \n <ect>
\t4 try { \n \n \t5 StopWatch stopWatch = new StopWatch ( ) ; \n \n \t5 stopWatch . start ( ) ; \n \n \t5 stopInternal ( ) ; \n \n <ect>
\t2 reply . setConnectionString ( connectionString ) ; \n \n \t1 } else { \n \n \t2 throw new Exception ( <string_literal> ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 Thread . sleep ( <number_literal> ) ; \n \n \t4 } catch ( InterruptedException e ) { \n \n \t5 LOG . error ( <string_literal> , e ) ; } \n \n \t4 lastIndexedTime = indexStatsMBean . getLastIndexedTime ( ) ; } \n \n <ect>
\t8 <comment> \n \n \t8 <comment> \n \n \t8 break ; \n \n \t7 default : \n \n <ect>
\t1 host . topologyManager . onHostRegistered ( host , associatedWithCluster ) ; \n \n \t1 try { \n \n \t2 host . restoreComponentsStatuses ( ) ; \n \n \t1 } catch ( AmbariException e1 ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t6 if ( val == null ) { \n \n \t7 return null ; } \n \n \t6 state = new DecimalType ( val ) ; \n \n \t5 } else { \n \n <ect>
\t6 s_logger . warn ( <string_literal> + element . getName ( ) + <string_literal> \n \n \t8 + getPhysicalNetworkId ( network ) ) ; \n \n \t6 success = false ; } \n \n <ect>
\t3 d . put ( <string_literal> , config . getAgentStorageNetworkName ( ) ) ; \n \n \t3 d . put ( <string_literal> , config . getAgentIsMaster ( ) . toString ( ) ) ; \n \n \t3 d . put ( <string_literal> , config . getAgentHasMaster ( ) . toString ( ) ) ; \n \n \t3 cmd . setHostDetails ( d ) ; \n \n <ect>
\t2 catch ( UnsupportedEncodingException e ) { \n \n \t3 <comment> \n \n \t3 if ( errorHandler != null ) \n \n \t4 errorHandler . handleErrorOnGet ( this , e , key ) ; \n \n <ect>
\t1 public void write ( List < ? extends I > items ) throws Exception { \n \n \t2 for ( I item : items ) { \n \n \t3 LOG . debug ( <string_literal> , item ) ; \n \n \t3 producerTemplate . sendBody ( endpointUri , item ) ; \n \n <ect>
\t6 worldProvider . setBlock ( neighborLocation , neighborBlockAfterUpdate ) ; } } } } } \n \n \t1 @ Override \n \n \t1 public void update ( float delta ) { \n \n \t2 if ( largeBlockUpdateCount > 0 ) { \n \n <ect>
\t4 if ( warning != null ) { \n \n \t5 log . warn ( <string_literal> , this , warning ) ; \n \n \t5 getConnection ( ) . clearWarnings ( ) ; } \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t1 protected void write ( String command ) { \n \n \t2 try { \n \n \t3 synchronized ( serialPort ) { \n \n \t4 if ( bw == null ) { \n \n <ect>
\t3 <comment> \n \n \t3 try { \n \n \t4 properties . load ( ClassHelper . getClassLoader ( ) . getResourceAsStream ( fileName ) ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t7 } catch ( NotAllowedException e ) { \n \n \t8 writeError ( l10n ( <string_literal> ) , l10n ( <string_literal> , new String [ ] { <string_literal> } , new String [ ] { file . getName ( ) } ) , ctx ) ; \n \n \t8 return false ; \n \n \t7 } catch ( MetadataUnresolvedException e ) { \n \n <ect>
\t1 boolean success = false ; \n \n \t1 List < MPartitionPrivilege > mSecurityTabPartList = null ; \n \n \t1 try { \n \n \t1 openTransaction ( ) ; \n \n <ect>
\t2 false ) ; \t7 <comment> \n \n private void dropPartitionsIteratively ( String dbName , String tableName , \n \n \t10 Map < String , String > partitionSpec , boolean ifExists , boolean deleteData ) \n \n \t1 throws HCatException , TException { \n \n <ect>
\t4 return false ; } \n \n \t3 String wsKey = headers . getSecWebSocketKey ( ) ; \n \n \t3 if ( wsKey == null ) { \n \n \t4 if ( logger . isErrorEnabled ( ) ) { \n \n <ect>
\t10 <string_literal> + reason ) ; } \n \n \t8 s_logger . info ( <string_literal> + wait + <string_literal> ) ; \n \n \t8 Thread . sleep ( wait ) ; \n \n \t7 } catch ( Exception e ) { \n \n <ect>
\t1 org . sonar . check . Rule ruleAnnotation = AnnotationUtils . getAnnotation ( clazz , org . sonar . check . Rule . class ) ; \n \n \t1 if ( ruleAnnotation != null ) { \n \n \t1 return loadRule ( repo , clazz , ruleAnnotation ) ; \n \n \t1 } else { \n \n <ect>
\t3 if ( targetDir . fileLength ( file ) != sourceDir . fileLength ( file ) ) { \n \n \t4 FileSizeStatus fileStatus = new FileSizeStatus ( file , targetDir . fileLength ( file ) , sourceDir . fileLength ( file ) ) ; \n \n \t4 dirStatus . filesWithSizeMismatch . add ( fileStatus ) ; \n \n \t4 clean = false ; \n \n <ect>
\t2 while ( ( 1 < < ( expRetriesThreshold + 1 ) ) < ( ( maxSleepTimeMs - baseSleepTimeMs ) / <number_literal> ) ) \n \n \t3 expRetriesThreshold ++ ; \n \n \t2 LOG . info ( <string_literal> + baseSleepTimeMs + <string_literal> + maxSleepTimeMs + <string_literal> + <string_literal> + maxRetries + <string_literal> ) ; \n \n \t2 if ( baseSleepTimeMs > maxSleepTimeMs ) { \n \n <ect>
\t6 v . property ( VertexProperty . Cardinality . single , prop . getKey ( ) , prop . getValue ( ) ) ; } } \n \n \t4 tx . commit ( ) ; \n \n \t3 } catch ( Throwable e ) { \n \n \t4 failures . incrementAndGet ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlMetaDataIdentityProviderLoadingError ( Throwable t ) { \n \n <ect>
\t1 String serviceName = alert . getService ( ) ; \n \n \t1 String componentName = alert . getComponent ( ) ; \n \n \t1 String hostName = alert . getHostName ( ) ; \n \n \t1 if ( null == serviceName && null == hostName ) { \n \n <ect>
\t1 if ( null != strm ) { \n \n \t1 try { \n \n \t2 strm . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t5 mav . withBinaryValue ( ( ByteBuffer ) value ) ; \n \n \t5 result . put ( entry . getKey ( ) , mav ) ; \n \n \t4 } else { \n \n \t5 <comment> \n \n <ect>
\t5 return ; } \n \n \t4 <comment> \n \n \t3 long [ ] hisBufLong = Fields . bytesToLongs ( hisBuf ) ; \n \n \t3 if ( hisBufLong . length < <number_literal> ) { \n \n <ect>
\t5 List < PatientIdentifier > matchingIds = Context . getPatientService ( ) . getPatientIdentifiers ( hl7PersonId , \n \n \t6 Collections . singletonList ( pit ) , null , null , null ) ; \n \n \t5 if ( matchingIds == null || matchingIds . isEmpty ( ) ) { \n \n \t6 <comment> \n \n <ect>
\t1 try { \n \n \t2 if ( socket != null ) \n \n \t2 socket . close ( ) ; \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t3 if ( ! rebalancerState . remove ( stealInfo ) ) \n \n \t4 throw new IllegalArgumentException ( <string_literal> + stealInfo + <string_literal> \n \n <number_literal> + rebalancerState + <string_literal> ) ; \n \n \t3 if ( rebalancerState . isEmpty ( ) ) { \n \n <ect>
\t5 s_logger . warn ( <string_literal> + ip + <string_literal> + vmId + <string_literal> ) ; \n \n \t5 success = false ; } \n \n \t3 } catch ( ResourceUnavailableException e ) { \n \n \t4 success = false ; \n \n <ect>
\t1 <comment> \n \n \t1 @ SuppressWarnings ( { <string_literal> , <string_literal> } ) \n \n \t1 @ Override public boolean finish ( boolean commit ) throws GridException { \n \n <ect>
\t4 } else if ( sourceWrapper == null && attempts > MAX_GET_NEXT_SOURCE_ATTEMPTS ) { \n \n \t5 log . warn ( <string_literal> + queuedSourceInitTasks . get ( ) + <string_literal> + finished ) ; \n \n \t5 throw new RuntimeException ( <string_literal> ) ; } \n \n \t4 if ( attempts % <number_literal> == 0 ) { \n \n <ect>
\t3 return session . createDurableSubscriber ( ( Topic ) consumerDestination , getName ( ) ) ; } \n \n \t2 return session . createConsumer ( consumerDestination ) ; } \n \n \t1 protected void tearDown ( ) throws Exception { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n <ect>
\t2 final Service targetService = this . serviceSelectionStrategy . resolveServiceFrom ( this . webApplicationServiceFactory . createService ( serviceUrl ) ) ; \n \n \t2 final WSFederationRegisteredService svc = getWsFederationRegisteredService ( targetService ) ; \n \n \t2 final WsFederationProperties . IdentityProvider idp = casProperties . getAuthn ( ) . getWsfedIdp ( ) . getIdp ( ) ; \n \n \t2 if ( StringUtils . isBlank ( fedRequest . getWtrealm ( ) ) || ! StringUtils . equals ( fedRequest . getWtrealm ( ) , svc . getRealm ( ) ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 TestLoggerFactory . getInstance ( ) . setPrintLevel ( Level . DEBUG ) ; \n \n \t2 TestLoggerFactory . clearAll ( ) ; \n \n \t2 logger . info ( <string_literal> <ect>
<comment> \n \n \t1 public BoxFolder createFolder ( String parentFolderId , String folderName ) { \n \n \t2 try { \n \n <ect>
\t4 <comment> \n \n \t4 coordAction . setLastModifiedTime ( new Date ( ) ) ; \n \n \t4 jpaService . execute ( new CoordActionUpdateJPAExecutor ( coordAction ) ) ; \n \n \t4 return null ; } \n \n <ect>
\t2 { \n \n \t3 RepairJob completedJob = syncingJobs . remove ( job . desc . columnFamily ) ; \n \n \t3 String remaining = syncingJobs . size ( ) == 0 ? <string_literal> : String . format ( <string_literal> , syncingJobs . size ( ) ) ; \n \n \t3 if ( completedJob != null && completedJob . isFailed ( ) ) \n \n <ect>
\t1 public void startConsumer ( Socket clientSocket , MllpSocketBuffer mllpBuffer ) { \n \n \t2 TcpSocketConsumerRunnable client = new TcpSocketConsumerRunnable ( this , clientSocket , mllpBuffer ) ; \n \n \t2 consumerRunnables . put ( client , System . currentTimeMillis ( ) ) ; \n \n \t2 try { \n \n <ect>
\t3 String userIdStr = userIdValues . get ( <string_literal> ) ; \n \n \t3 if ( userIdStr != null ) { \n \n \t4 userId = userIdStr ; \n \n \t3 } else { \n \n <ect>
\t3 Message message = requestConsumer . receive ( <number_literal> ) ; \n \n \t3 if ( message != null ) { \n \n \t4 onMessage ( message ) ; \n \n \t3 } else { \n \n <ect>
\t3 if ( producerError . get ( ) != null ) { \n \n \t4 LOG . info ( <string_literal> ) ; \n \n \t4 throw new RuntimeException ( <string_literal> , producerError . get ( ) ) ; } \n \n \t3 if ( consumerError . get ( ) != null ) { \n \n <ect>
\t2 return new DelegatedClientFactory ( casProperties . getAuthn ( ) . getPac4j ( ) ) ; } \n \n \t1 @ Bean \n \n \t1 public Clients builtClients ( ) { \n \n \t2 final Set < BaseClient > clients = pac4jDelegatedClientFactory ( ) . build ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void deactivate ( ) { \n \n <ect>
\t8 processNormally ( itemNode , ProcessType . NORMAL ) ; } } \n \n \t6 catch ( Exception e ) \n \n \t6 { \n \n \t7 ThreadUtils . checkInterrupted ( e ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 if ( pr != null ) { \n \n \t4 if ( _notifier != null ) \n \n \t5 _notifier . pingComplete ( false ) ; \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 if ( output == null ) { \n \n \t3 throw new ExecException ( <string_literal> + outputKey + <string_literal> ) ; } \n \n \t2 try { \n \n \t3 writer = ( KeyValueWriter ) output . getWriter ( ) ; \n \n <ect>
\t2 loadSenderBulk . onDisconnect ( ) ; \n \n \t2 return ret ; } \n \n \t1 @ Override \n \n \t1 public void forceDisconnect ( ) { \n \n <ect>
\t5 cmdWrapper . add ( <string_literal> ) ; \n \n \t5 try { \n \n \t6 launchProcess ( cmdWrapper , environment ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t2 if ( classReference != null ) { \n \n \t3 try { \n \n \t4 baseClass = context . getWiki ( ) . getXClass ( classReference , context ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 stmt . addBatch ( ) ; } \n \n \t3 stmt . executeBatch ( ) ; \n \n \t3 stmt . close ( ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t2 assert nodeAttrs == null ; \n \n \t2 assert nodeVer == null ; \n \n \t3 log . debug ( <string_literal> + attrs ) ; \n \n <ect>
\t4 LOG . info ( <string_literal> + getEndpoint ( ) . getDelay ( ) + <string_literal> ) ; \n \n \t4 Thread . sleep ( getEndpoint ( ) . getDelay ( ) ) ; \n \n \t4 int count = counter . incrementAndGet ( ) ; \n \n \t4 if ( getEndpoint ( ) . getFailFirstAttempts ( ) >= count ) { \n \n <ect>
\t2 break ; } } \n \n \t1 <comment> \n \n \t1 if ( ! isConnected && retryDelaySeconds > 0 ) { \n \n \t2 try { \n \n <ect>
\t4 in . readFully ( data ) ; \n \n \t4 SAMMessageSess sess = isRaw ? rawSession : datagramSession ; \n \n \t4 if ( ! sess . sendBytes ( dest , data , proto , fromPort , toPort ) ) { \n \n \t5 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t5 clientRunOnCommand . run ( ) ; } } \n \n \t3 @ Override \n \n \t3 public void onException ( IOException error ) { \n \n \t4 if ( ! ignoreClientError . get ( ) ) { \n \n <ect>
\t2 if ( cassandraHost == null ) { \n \n \t2 continue ; } \n \n \t2 if ( connectionManager . getHosts ( ) . size ( ) == 0 ) { \n \n \t2 listenerHandler . fireOnAllHostsDown ( ) ; \n \n <ect>
\t7 <string_literal> + Thread . currentThread ( ) . getName ( ) + <string_literal> + msg ) ; \n \n \t5 if ( msg instanceof OtpErlangTuple ) { \n \n \t6 handleMessage ( msg ) ; \n \n \t5 } else { \n \n <ect>
\t5 String filename = File . createTempFile ( <string_literal> , <string_literal> ) . getCanonicalPath ( ) ; \n \n \t5 FileOutputStream fileOutputStream = new FileOutputStream ( filename ) ; \n \n \t5 sourceMessage . writeToStream ( fileOutputStream ) ; \n \n \t5 fileOutputStream . close ( ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> + SERVLET_NAME ) ; \n \n \t3 Hashtable < String , String > props = new Hashtable < String , String > ( ) ; \n \n \t3 httpService . registerServlet ( SERVLET_NAME , this , props , createHttpContext ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 SendableGet [ ] reqs ; \n \n \t3 try { \n \n \t4 reqs = listener . getRequestsForKey ( key , saltedKey , context ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 log . error ( <string_literal> , filename , cacheFile . getAbsoluteFile ( ) , \n \n \t5 e . getMessage ( ) ) ; \n \n \t2 } catch ( ValidationException e ) { \n \n <ect>
\t5 final Domain domain = domainDao . findById ( account . getDomainId ( ) ) ; \n \n \t5 if ( ! addUserAccount ( account , domain ) ) { \n \n \t6 LOG . warn ( String . format ( <string_literal> , account . getAccountName ( ) , domain . getPath ( ) ) ) ; } \n \n \t4 } catch ( final Exception e ) { \n \n <ect>
\t4 return findEndpoint ( endpoints ) ; \n \n \t3 } catch ( final URISyntaxException e ) { \n \n \t4 throw new RuntimeException ( <string_literal> , e ) ; } \n \n \t2 } ) . get ( ) ; \n \n <ect>
\t7 . forEach { \n \n \t8 val request = debugProcess . requestsManager . createBreakpointRequest ( this , it ) \n \n \t8 debugProcess . requestsManager . enableRequest ( request ) \n \n <ect>
\t2 LOG . debug ( <string_literal> ) ; \n \n \t2 camelContext . setPackageScanClassResolver ( new OsgiPackageScanClassResolver ( bundleContext ) ) ; \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 camelContext . setComponentResolver ( new OsgiComponentResolver ( bundleContext ) ) ; \n \n <ect>
\t2 if ( delayedStartup ) { \n \n \t3 try { \n \n \t4 threadStarter . interrupt ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 if ( skip ) { \n \n \t3 LOG . trace ( <string_literal> , this ) ; \n \n \t3 return ; } \n \n \t2 if ( ! isStarted ( ) && ! isStarting ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( clc . isOutDated ( compile ) ) { \n \n <ect>
\t4 asString = asString . substring ( 0 , asString . length ( ) - <number_literal> ) ; <comment> \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t4 sendText ( asString ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t7 <comment> \n \n \t7 f . get ( ) ; } \n \n \t6 catch ( GridException e ) { \n \n <ect>
\t1 return new ACLProvider ( ) { \n \n \t1 @ Override \n \n \t1 public List < ACL > getDefaultAcl ( ) { \n \n \t2 <comment> \n \n <ect>
\t2 RebalanceUtils . validateClusterStores ( this . currentCluster , this . currentStoreDefs ) ; \n \n \t2 RebalanceUtils . validateClusterStores ( this . finalCluster , this . finalStoreDefs ) ; \n \n \t2 RebalanceUtils . validateClusterStores ( interimCluster , this . finalStoreDefs ) ; \n \n \t2 <comment> \n \n <ect>
\t2 throws ThriftSecurityException , TException { \n \n \t1 try { \n \n \t2 checkPermission ( credentials , null , <string_literal> ) ; \n \n \t1 } catch ( ThriftSecurityException e ) { \n \n <ect>
\t3 LOGGER . error ( <string_literal> ) ; \n \n \t3 return error ( ) ; } \n \n \t2 final String username = passwordManagementService . parseToken ( token ) ; \n \n \t2 if ( StringUtils . isBlank ( username ) ) { \n \n <ect>
\t3 if ( rowService != null ) { \n \n \t4 long timestamp = System . currentTimeMillis ( ) ; \n \n \t4 rowService . index ( key , columnFamily , timestamp ) ; } \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t4 ModelNode value = prop . getValue ( ) ; \n \n \t4 if ( value . isDefined ( ) ) { \n \n \t5 json . get ( name ) . set ( value ) ; } } } } \n \n \t1 public boolean isSecureDeployment ( DeploymentUnit deploymentUnit ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected boolean isResponseValid ( SatelMessage response ) { \n \n \t2 <comment> \n \n \t2 if ( response . getCommand ( ) != COMMAND_CODE ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void testGet ( ) throws Exception { \n \n \t2 final com . google . api . services . drive . model . About result = requestBody ( <string_literal> , null ) ; \n \n \t2 assertNotNull ( <string_literal> , result ) ; \n \n <ect>
\t1 <comment> \n \n \t1 for ( Index index : definitions . getIndices ( ) . values ( ) ) { \n \n \t1 boolean exists = client . prepareIndicesExist ( index . getName ( ) ) . get ( ) . isExists ( ) ; \n \n \t1 if ( exists && ! index . getName ( ) . equals ( MetadataIndexDefinition . INDEX_TYPE_METADATA . getIndex ( ) ) && hasDefinitionChange ( index ) ) { \n \n <ect>
\t1 public void init ( ) throws Exception { \n \n \t2 log . info ( <string_literal> + baseDN + <string_literal> + bindHost + <string_literal> + bindPort + \n \n \t4 <string_literal> + ldapSaslPrincipal + <string_literal> + directoryServiceFactory + <string_literal> + ldifFile ) ; \n \n \t2 this . directoryService = createDirectoryService ( ) ; \n \n <ect>
\t2 if ( authentication == null ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 if ( StringUtils . isBlank ( globalProviderId ) ) { \n \n <ect>
\t2 for ( VmVolumeAttachment attachment : allAttachments ) { \n \n \t2 if ( arg0 . containsKey ( attachment . getVolumeId ( ) ) ) { \n \n \t3 attachment . setRemoteDevice ( arg0 . get ( attachment . getVolumeId ( ) ) ) ; \n \n \t2 } else { \n \n <ect>
\t1 VersionManager versionManager = session . getWorkspace ( ) . getVersionManager ( ) ; \n \n \t1 try { \n \n \t1 version = versionManager . getBaseVersion ( node . getPath ( ) ) ; \n \n \t1 } catch ( NullPointerException ex ) { \n \n <ect>
\t2 for ( int i = 0 ; i < count ; i ++ ) { \n \n \t3 realm = st . nextToken ( ) ; } \n \n \t2 realm = realm . toUpperCase ( ) ; \n \n \t2 if ( StringUtils . isBlank ( realm ) || ! realmMap . containsKey ( realm ) ) { \n \n <ect>
\t2 if ( activity != null ) \n \n \t2 { \n \n \t3 log . info ( <string_literal> + currentActivity . getId ( ) ) ; \n \n \t3 postCachedActivityMapper . execute ( activity ) ; \n \n <ect>
\t1 if ( state != null ) { \n \n \t2 try { \n \n \t2 state . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 deleteKeysThatSucceeded . add ( entry . getValue ( ) ) ; \n \n \t3 } catch ( VoldemortException e ) { \n \n \t4 logger . warn ( e , e ) ; \n \n \t4 numDeleteExceptions ++ ; } } \n \n <ect>
\t4 catch ( Throwable e ) { \n \n \t5 Exception log = new Exception ( <string_literal> , e ) ; \n \n \t5 log . printStackTrace ( ) ; } } } \n \n \t2 private void sweep ( ) throws Exception { \n \n <ect>
<comment> \n \n \t1 private void checkNodes ( ZooKeeper zk , int start , int count ) throws Exception { \n \n <ect>
\t4 if ( expectedSometimesOnFailoverRecovery . getMessage ( ) . contains ( <string_literal> ) ) { \n \n \t5 <comment> \n \n \t5 <comment> \n \n \t5 resumeOnNextOrPreviousIsOk = true ; \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 onApplyError ( <string_literal> + sourceName + <string_literal> + e + <string_literal> + replicationController , e ) ; } } } \n \n \t2 } else { \n \n \t3 if ( ! isAllowCreate ( ) ) { \n \n <ect>
\t7 byte [ ] readBuffer = new byte [ MAX_BUFFER_SIZE ] ; \n \n \t7 IntByReference lpNumberOfBytesRead = new IntByReference ( 0 ) ; \n \n \t7 assertCallSucceeded ( <string_literal> , Kernel32 . INSTANCE . ReadFile ( hNamedPipe , readBuffer , readBuffer . length , lpNumberOfBytesRead , null ) ) ; \n \n \t7 int readSize = lpNumberOfBytesRead . getValue ( ) ; \n \n <ect>
\t5 . getConnection ( ) ; \n \n \t3 Response response = doVoidOperation ( urlConnection ) ; \n \n \t3 if ( ! response . isSuccessCode ( ) ) { \n \n \t4 if ( response . isAuthDenied ( ) ) { \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 protected < OUT , IN1 , IN2 > TypeInformation < OUT > analyzePojo ( Class < OUT > clazz , ArrayList < Type > typeHierarchy , \n \n \t3 ParameterizedType parameterizedType , TypeInformation < IN1 > in1Type , TypeInformation < IN2 > in2Type ) { \n \n \t2 if ( ! Modifier . isPublic ( clazz . getModifiers ( ) ) ) { \n \n <ect>
\t2 if ( deleteTables ) { \n \n \t3 final DeleteTableRequest delete = new DeleteTableRequest ( request . getTableName ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , delete ) ; \n \n \t3 TableUtils . deleteTableIfExists ( amazonDynamoDBClient , delete ) ; } \n \n <ect>
\t3 DedicatedResourceVO dedicatedPod = _dedicatedDao . findByPodId ( podId ) ; \n \n \t3 DedicatedResourceVO dedicatedZoneOfPod = _dedicatedDao . findByZoneId ( pod . getDataCenterId ( ) ) ; \n \n \t3 <comment> \n \n \t3 if ( dedicatedPod != null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<number_literal> final Service service , final RegisteredService registeredService ) { \n \n \t2 if ( StringUtils . isNotBlank ( getPrincipalIdAttribute ( ) ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , registeredService . getServiceId ( ) ) ; \n \n \t3 final String id = registeredService . getUsernameAttributeProvider ( ) . resolveUsername ( principal , service , registeredService ) ; \n \n <ect>
\t2 for ( int i = 0 ; i < numMessages ; i ++ ) { \n \n \t3 sendMessage ( false ) ; } \n \n \t2 final BrokerView brokerView = broker . getAdminView ( ) ; \n \n \t2 broker . getSystemUsage ( ) . getStoreUsage ( ) . isFull ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 String encoding = message . getHeader ( SmppConstants . ENCODING , String . class ) ; \n \n \t3 if ( Charset . isSupported ( encoding ) ) { \n \n \t4 return Charset . forName ( encoding ) ; \n \n \t3 } else { \n \n <ect>
\t2 expectTopologyChange ( InetSocketAddress . createUnresolved ( hotRodServer3 . getHost ( ) , hotRodServer3 . getPort ( ) ) , true ) ; \n \n \t2 assertEquals ( <number_literal> , channelFactory . getServers ( ) . size ( ) ) ; \n \n \t1 } finally { \n \n \t2 log . info ( <string_literal> + manager ( 0 ) . getCache ( ) . getAdvancedCache ( ) . getRpcManager ( ) . getTransport ( ) . getMembers ( ) ) ; \n \n <ect>
\t5 if ( state . isSuspect ( ) ) state . setFailing ( ) ; \n \n \t5 if ( state . isReady ( ) ) { \n \n \t6 state . setSuspect ( ) ; \n \n \t6 if ( retry ) \n \n <ect>
\t3 BufferedReader buffReader = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) , <string_literal> ) ) ; \n \n \t3 String line = buffReader . readLine ( ) ; \n \n \t3 logger . debug ( <string_literal> + line + <string_literal> ) ; \n \n \t3 if ( line == null ) { \n \n <ect>
\t3 } <comment> \n \n \t2 } catch ( ConcurrentModificationException e ) { \n \n \t3 log . debug ( <string_literal> , e ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 youtubeSource = new ReplacementServiceYoutubeImpl ( ) ; \n \n \t2 youtubeSourceServReg = \n \n \t3 context . registerService ( ReplacementService . class . getName ( ) , \n \n \t4 youtubeSource , hashtable ) ; \n \n <ect>
\t5 log . warn ( <string_literal> , i ) ; \n \n \t5 pullThreads [ i ] . interrupt ( ) ; } } \n \n \t3 for ( int i = 0 ; i < processors . length ; i ++ ) { \n \n \t4 processors [ i ] . finish ( ) ; } \n \n <ect>
\t5 getSubdirectoryList ( directory , directoryList ) ; } } } \n \n \t2 return directoryList ; } \n \n \t1 private boolean validatePurgeParameters ( DataPurgeConfig dataPurgeConfig , DateTime currentTime ) { \n \n \t2 if ( dataPurgeConfig . getDirectoryPrefix ( ) == null || dataPurgeConfig . getDirectoryPrefix ( ) . length == 0 ) { \n \n <ect>
\t1 if ( ( request . headerForKey ( <string_literal> ) ) . toLowerCase ( ) . indexOf ( <string_literal> ) == - 1 ) \n \n \t2 log . debug ( <string_literal> , request . formValues ( ) ) ; \n \n \t1 else \n \n <ect>
\t3 RemotePeerBean rBean = jmxRemotePeerBean . remove ( id ) ; \n \n \t3 try { \n \n \t4 MBeanRegistry . getInstance ( ) . unregister ( rBean ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 throw new HiveException ( e . getMessage ( ) , e ) ; } \n \n \t1 try { \n \n \t1 srcFs = sourcePath . getFileSystem ( conf ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 if ( method . isAnnotationPresent ( PreDestroy . class ) ) { \n \n \t4 if ( ! visitContext . contains ( methodName ) ) { \n \n \t5 try { \n \n \t6 LifecycleAction destroyAction = new JSR250LifecycleAction ( PreDestroy . class , method , validationMode ) ; \n \n <ect>
\t1 HostRoleCommand mapRedCmdHost3 = null ; \n \n \t1 for ( Stage stage : stages ) { \n \n \t1 List < HostRoleCommand > hrcs = stage . getOrderedHostRoleCommands ( ) ; \n \n \t1 for ( HostRoleCommand hrc : hrcs ) { \n \n <ect>
\t2 for ( AstroBindingProvider provider : context . getProviders ( ) ) { \n \n \t3 if ( bindingConfig == null ) { \n \n \t4 bindingConfig = provider . getBindingFor ( itemName ) ; } } \n \n \t2 if ( bindingConfig == null ) { \n \n <ect>
\t2 xyzresult . expectedMessageCount ( 1 ) ; \n \n \t2 xyzresult . whenAnyExchangeReceived ( new Processor ( ) { \n \n \t3 @ Override \n \n \t3 public void process ( Exchange exchange ) throws Exception { \n \n <ect>
\t1 try : \n \n \t1 config = ConfigParser . RawConfigParser ( ) \n \n \t1 config . read ( config_file_path ) \n \n \t1 except Exception , e : \n \n <ect>
\t2 try { \n \n \t3 custom . starting ( ) ; \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 LOG . info ( <string_literal> ) ; \n \n <ect>
\t3 if ( subprotocols != null ) { \n \n \t4 String selectedSubprotocol = selectSubprotocol ( subprotocols ) ; \n \n \t4 if ( selectedSubprotocol == null ) { \n \n <ect>
\t3 throw new IllegalArgumentException ( ) ; \n \n \t2 try { \n \n \t3 port = Integer . parseInt ( portStr ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t3 } finally { \n \n \t4 callback . done ( false ) ; } } \n \n \t2 @ Override \n \n \t2 public void failed ( Throwable throwable ) { \n \n <ect>
<comment> \n \n \t1 protected static List < String > getSupportedNameIdFormats ( final SamlRegisteredService service , \n \n <number_literal> final SamlRegisteredServiceServiceProviderMetadataFacade adaptor ) { \n \n \t2 final List < String > supportedNameFormats = adaptor . getSupportedNameIdFormats ( ) ; \n \n <ect>
\t5 writer . write ( msg ) ; \n \n \t4 } else { \n \n \t5 putInContext ( msg ) ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 _log . debug ( <string_literal> + line ) ; \n \n \t3 String req = <string_literal> + destName + <string_literal> + conOptions + <string_literal> ; \n \n \t3 out . write ( DataHelper . getASCII ( req ) ) ; \n \n \t3 line = reader . readLine ( ) ; \n \n <ect>
\t2 e ) ; \n \n \t1 } catch ( IllegalArgumentException exception ) { \n \n \t1 <comment> \n \n \t1 if ( exception . getCause ( ) instanceof UnknownHostException ) { \n \n <ect>
\t4 HttpResponseCodes . SC_SEE_OTHER , conn . getResponseCode ( ) ) ; } \n \n \t1 @ SuppressWarnings ( value = <string_literal> ) \n \n \t1 private void testRedirect ( Response response ) { \n \n \t2 MultivaluedMap < String , Object > headers = response . getHeaders ( ) ; \n \n <ect>
\t2 writer . close ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testInterestReexpression ( ) throws Exception { \n \n <ect>
<comment> \n \n public void end ( Map < String , String > extraMetaData ) throws IOException { \n \n \t1 state = state . end ( ) ; \n \n <ect>
\t5 return ; } \n \n \t4 if ( reply == null ) { \n \n \t5 if ( pn . isRoutable ( ) && ( System . currentTimeMillis ( ) - pn . timeLastConnectionCompleted ( ) > TIMEOUT * <number_literal> ) ) { \n \n \t6 <comment> \n \n <ect>
\t3 <comment> \n \n \t3 if ( res == null ) { \n \n \t4 _log . warn ( <string_literal> + print ( ) ) ; \n \n \t3 } else if ( res [ 1 ] == null ) { \n \n <ect>
\t2 logger . debug ( <string_literal> , soapToString ( response ) ) ; \n \n \t2 <comment> \n \n \t2 try { \n \n \t3 if ( response . getSOAPBody ( ) . getFault ( ) != null ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testCCNTimeTimestamp ( ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return new RejectResultCodeLdapPasswordPolicyHandlingStrategy ( ) ; } \n \n \t2 final Resource location = l . getPasswordPolicy ( ) . getGroovy ( ) . getLocation ( ) ; \n \n \t2 if ( l . getPasswordPolicy ( ) . getStrategy ( ) == PasswordPolicyProperties . PasswordPolicyHandlingOptions . GROOVY && location != null ) { \n \n <ect>
\t3 subObject = object ( ) ; \n \n \t3 subKey = key ; } \n \n \t3 log . debug ( <string_literal> + existingListArray ) ; \n \n <ect>
\t1 public static class ModuleA extends AbstractModule \n \n \t1 { \n \n \t2 public ModuleA ( ) \n \n \t2 { \n \n <ect>
\t4 Logger . normal ( this , <string_literal> + type + <string_literal> ) ; } \n \n \t3 @ Override \n \n \t3 public void onGeneratedMetadata ( Bucket metadata , \n \n \t5 BaseClientPutter state ) { \n \n <ect>
\t5 output . write ( bufferEntry ) ; } \n \n \t3 } catch ( FileNotFoundException e ) { \n \n \t4 throw new TikaException ( e . getMessage ( ) ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t4 logger . error ( <string_literal> , e ) ; \n \n \t3 } finally { \n \n \t4 serverSocket = null ; } } \n \n <ect>
\t4 return false ; } \n \n \t3 IpmISetBootDevCommand bootCmd = new IpmISetBootDevCommand ( BootDev . pxe ) ; \n \n \t3 Answer anw = _agentMgr . send ( dest . getHost ( ) . getId ( ) , bootCmd ) ; \n \n \t3 if ( ! anw . getResult ( ) ) { \n \n <ect>
\t2 try { \n \n \t3 Connect conn = LibvirtConnection . getConnection ( ) ; \n \n \t3 storage = conn . storagePoolLookupByUUIDString ( uuid ) ; \n \n \t3 if ( storage . getInfo ( ) . state != StoragePoolState . VIR_STORAGE_POOL_RUNNING ) { \n \n <ect>
\t2 final List < ModelNode > updates = new ArrayList < ModelNode > ( ) ; \n \n \t2 for ( SystemProperty systemProperty : systemProperties ) { \n \n \t3 final String propertyName = systemProperty . getName ( ) ; \n \n \t3 if ( propertyName == null || propertyName . trim ( ) . length ( ) == 0 ) { \n \n <ect>
\t1 private static ContentType parse ( final String contentTypeString ) { \n \n \t2 try { \n \n \t3 return new ContentType ( contentTypeString ) ; \n \n \t2 } catch ( ParseException pe ) { \n \n <ect>
\t2 if ( results . isEmpty ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , principal ) ; \n \n \t3 return no ( ) ; } \n \n \t2 final String fingerprint = deviceFingerprintStrategy . determineFingerprint ( principal , requestContext ) ; \n \n <ect>
\t1 ResourceType type = null ; \n \n \t1 try { \n \n \t1 type = ResourceType . get ( FilenameUtils . getExtension ( stripSessionID ( uri ) ) ) ; \n \n \t1 } catch ( final IllegalArgumentException e ) { \n \n <ect>
\t2 if ( sibling . getStatistics ( ) != null ) { \n \n \t3 numberOfBytes = StatsUtils . safeAdd ( \n \n \t4 numberOfBytes , sibling . getStatistics ( ) . getDataSize ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t1 QueryInfo queryInfo = queryInfoMap . get ( qId ) ; \n \n \t1 if ( queryInfo == null ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t5 } else { \n \n \t6 s_logger . error ( <string_literal> + api . getTestCaseInfo ( ) + <string_literal> + api . getUrl ( ) ) ; } \n \n \t4 } else { \n \n \t5 if ( api . isEmpty ( ) != false ) \n \n <ect>
\t4 try { \n \n \t5 timeout . remove ( ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
<comment> \n \n public void push ( List < Metric > rawMetrics ) { \n \n \t1 List < Metric > validMetrics = ValidCharacters . toValidValues ( filter ( rawMetrics ) ) ; \n \n \t1 List < Metric > metrics = transformMetrics ( validMetrics ) ; \n \n <ect>
\t3 String volume = m . group ( 1 ) ; \n \n \t3 eventPublisher . postUpdate ( itemName , new DecimalType ( volume ) ) ; \n \n \t3 logger . debug ( <string_literal> , itemName , volume ) ; \n \n \t2 } else { \n \n <ect>
\t3 if ( isNearEnabled ( cacheCfg ) && nearTx == null && ! F . isEmpty ( req . nearWrites ( ) ) && req . groupLock ( ) ) \n \n \t4 nearTx = near ( ) . startRemoteTxForFinish ( nodeId , req ) ; } \n \n \t2 catch ( GridCacheTxRollbackException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 jobDetail . getJobDataMap ( ) . put ( QuartzConstants . QUARTZ_TRIGGER_TYPE , <string_literal> ) ; \n \n \t3 jobDetail . getJobDataMap ( ) . put ( QuartzConstants . QUARTZ_TRIGGER_CRON_EXPRESSION , cron ) ; \n \n \t2 } else { \n \n <ect>
\t4 CoordinateReferenceSystem sourceCRS = null ; \n \n \t4 try { \n \n \t5 sourceCRS = CRS . decode ( srid , true ) ; \n \n \t4 } catch ( NoSuchAuthorityCodeException e ) { \n \n <ect>
\t4 filtered ++ ; \n \n \t3 Message message = session . createMessage ( ) ; \n \n \t3 message . setStringProperty ( <string_literal> , filter ? <string_literal> : <string_literal> ) ; \n \n \t3 producer . send ( topic , message ) ; } \n \n <ect>
\t2 Log . info ( this , <string_literal> + getLabel ( ) ) ; \n \n \t2 Log . info ( this , <string_literal> + readBlocks ) ; \n \n \t2 Log . info ( this , <string_literal> + writeBlocks ) ; \n \n \t2 Log . info ( this , <string_literal> + iteratorBlocks ) ; \n \n <ect>
\t4 dis . readFully ( arr2 ) ; \n \n \t3 } catch ( EOFException e ) { \n \n \t4 s_logger . info ( <string_literal> ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 if ( conn != null ) { \n \n \t4 libvirtComputingResource . handleVmStartFailure ( conn , vmName , vm ) ; } \n \n \t3 return new StartAnswer ( command , e . getMessage ( ) ) ; \n \n \t2 } catch ( final URISyntaxException e ) { \n \n <ect>
\t3 waitForFlush_result result = new waitForFlush_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 springSecurityContextSource . setPassword ( ldapServerProperties . get ( ) . getManagerPassword ( ) ) ; } \n \n \t1 try { \n \n \t2 springSecurityContextSource . afterPropertiesSet ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 public void put ( String uri , Class < ? > procClass ) \n \n \t1 { \n \n \t2 if ( ! Procedure . class . isAssignableFrom ( procClass ) ) \n \n \t2 { \n \n <ect>
\t3 long time = System . nanoTime ( ) - startTime ; \n \n \t3 log . debug ( <string_literal> , i , time / 1 . 0e6 ) ; \n \n \t3 if ( i % <number_literal> == 0 ) { \n \n \t3 Arrays . sort ( times ) ; \n \n <ect>
\t3 keyProviderType ; \n \n \t2 logger . error ( errMessage ) ; \n \n \t2 throw new FlumeException ( errMessage ) ; } \n \n \t1 } catch ( ClassNotFoundException ex ) { \n \n <ect>
\t2 <comment> \n \n \t2 doTearDown ( ) ; \n \n \t2 doSetUp ( false ) ; \n \n \t2 Thread . sleep ( <number_literal> ) ; \n \n <ect>
\t2 co = testNext ( co , segments [ <number_literal> ] ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testWaitForPutDrain ( ) throws Throwable { \t1 \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 File storeParentDirectory = fileStore . getParentFile ( ) ; \n \n \t3 if ( storeParentDirectory != null && ! storeParentDirectory . exists ( ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 { \n \n \t4 LOG . error ( <string_literal> , iox ) ; } } \n \n \t2 else \n \n \t2 { \n \n <ect>
\t2 if ( resources != null ) { \n \n \t3 for ( FunctionResource resource : resources ) { \n \n \t3 outStream . writeBytes ( <string_literal> + resource . getResourceURI ( ) + <string_literal> ) ; } } } } \n \n \t1 } catch ( FileNotFoundException e ) { \n \n <ect>
\t3 log . warn ( <string_literal> + taskKey ) ; \n \n \t3 spawn . fixTaskDir ( taskKey . getJobUuid ( ) , taskKey . getNodeNumber ( ) , false , false ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! task . getHostUUID ( ) . equals ( sourceHostUUID ) && ! task . hasReplicaOnHost ( sourceHostUUID ) ) { \n \n <ect>
<comment> \n \n @ Deprecated \n \n public void unlink ( ServiceConfiguration config ) { \n \n <ect>
\t7 onReceiveFailure ( ) ; \n \n \t6 } else { \n \n \t7 data . close ( ) ; \n \n \t7 if ( ! dest . renameTo ( node . clientCore . downloadsDir ( ) . file ( baseFilename ) ) ) { \n \n <ect>
\t3 log . info ( <string_literal> + mbeanSrv ) ; \n \n \t3 log . info ( <string_literal> + exec ) ; \n \n \t3 log . info ( <string_literal> + ggHome ) ; \n \n \t3 log . info ( <string_literal> + gridName ) ; \n \n <ect>
\t6 <comment> \n \n \t6 break ; \n \n \t5 case <string_literal> : \n \n \t6 if ( matchesModel . isTournament ( modelRow ) ) { \n \n <ect>
\t2 for ( TaskFilePropertySpec propertySpec : fileProperties ) { \n \n \t3 FileCollectionSnapshot result ; \n \n \t3 try { \n \n \t4 FileCollectionSnapshotter snapshotter = snapshotterRegistry . getSnapshotter ( propertySpec . getNormalizer ( ) ) ; \n \n <ect>
\t2 ProcessingCriteria . create ( ProcessingType . IMPORT_ONLY , false ) ) ) ; \n \n \t1 if ( ! foundImports . isEmpty ( ) ) { \n \n \t1 LOG . debug ( <string_literal> , foundImports . size ( ) ) ; } \n \n \t1 sb . append ( cssContent ) ; \n \n <ect>
\t2 if ( bean != null ) { \n \n \t3 try { \n \n \t4 bean . destroy ( ) ; } \n \n \t3 catch ( Throwable ex ) { \n \n <ect>
\t4 if ( sspPort . vlanId != null ) { \n \n \t5 nic . setBroadcastType ( BroadcastDomainType . Vlan ) ; \n \n \t5 nic . setBroadcastUri ( BroadcastDomainType . Vlan . toUri ( String . valueOf ( sspPort . vlanId ) ) ) ; } \n \n \t4 return true ; } } \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 if ( connection != null ) { \n \n \t3 connection . stop ( ) ; \n \n \t3 connection = null ; } \n \n <ect>
\t2 if ( parent . isFinishing ( ) ) { \n \n \t3 throw new IOException ( <string_literal> + blockNo + <string_literal> + this + <string_literal> + parent ) ; } \n \n \t2 synchronized ( this ) { \n \n \t3 if ( this . blockChooser . hasSucceeded ( blockNo ) ) { \n \n <ect>
\t2 final MetricsFile < BaseDistributionByCycleMetrics , ? > metrics = getMetricsFile ( ) ; \n \n \t2 hist . addToMetricsFile ( metrics ) ; \n \n \t2 metrics . write ( OUTPUT ) ; \n \n \t2 if ( hist . isEmpty ( ) ) { \n \n <ect>
\t5 continue ; } \n \n \t4 if ( ! actionFile . getName ( ) . toLowerCase ( ) . endsWith ( <string_literal> ) ) { \n \n \t5 continue ; } \n \n \t4 try { \n \n <ect>
\t4 catch ( IOException | GridException e ) { \n \n \t5 if ( e instanceof GridGgfsHadoopCommunicationException ) \n \n \t6 hadoop . close ( true ) ; \n \n <ect>
\t3 if ( svc == null ) { \n \n \t4 Dictionary < ? , ? > dic = bundleContext . getBundle ( ) . getHeaders ( ) ; \n \n \t4 LOG . warn ( <string_literal> + explode ( dic ) ) ; \n \n \t4 for ( ServiceReference ref : asCollection ( bundleContext . getAllServiceReferences ( null , null ) ) ) { \n \n <ect>
\t4 log . info ( <string_literal> + jobFullName + <string_literal> + msg \t1 + <string_literal> ) ; \n \n \t3 if ( errorMsg != null ) \n \n \t4 log . info ( <string_literal> + jobFullName + <string_literal> + errorMsg \t1 + <string_literal> ) ; \n \n \t3 else \n \n <ect>
\t5 if ( ! path . isAbsolute ( ) ) { \n \n \t6 path = path . makeAbsolute ( ) ; } \n \n \t5 return path ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t3 if ( null == secretKey || 0 == secretKey . length ) { \n \n \t4 response . sendError ( <number_literal> , <string_literal> ) ; \n \n \t4 return ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 if ( volumeCreated ) { \n \n \t4 try { \n \n \t5 deleteRogueVolume ( volName , s ) ; <comment> \n \n \t4 } catch ( NaException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 Set < Integer > removedTaskIds = getRemovedTaskIds ( oldWorkers , workers ) ; \n \n \t2 for ( Integer removedTaskId : removedTaskIds ) { \n \n \t3 startTimes . remove ( removedTaskId ) ; \n \n \t3 NimbusUtils . removeTopologyTaskHb ( nimbusData , topologyId , removedTaskId ) ; } \n \n <ect>
\t4 LOGGER . error ( <string_literal> ) ; \n \n \t4 LOGGER . error ( <string_literal> ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 if ( LOGGER . isErrorEnabled ( ) ) { \n \n <ect>
\t2 bf . log . warn ( <string_literal> + width ) ; \n \n \t2 bf . log . warn ( <string_literal> + this . levels . length ) ; \n \n \t2 bf . log . warn ( <string_literal> + this . key ( ) ) ; \n \n \t2 bf . log . warn ( <string_literal> + this . spanPage ) ; \n \n <ect>
\t1 if ( path != null && ! path . isEmpty ( ) ) { \n \n \t2 gz = new File ( new File ( path , <string_literal> ) , SLIDER_GZ ) ; \n \n \t2 if ( gz . exists ( ) ) { \n \n \t2 path = gz . getParentFile ( ) . getAbsolutePath ( ) ; \n \n <ect>
\t1 protected boolean getWriteLock ( ) { \n \n \t2 try { \n \n \t3 boolean rv = _reorganizeLock . writeLock ( ) . tryLock ( <number_literal> , TimeUnit . MILLISECONDS ) ; \n \n \t3 if ( ! rv ) \n \n <ect>
\t6 + <string_literal> + reg ) ; \n \n \t4 reg . bind ( rc . getRmiName ( ) , remote ) ; \n \n \t4 <comment> \n \n \t4 this . rmiRepository = remote ; \n \n <ect>
\t1 protected void endFilteredBlock ( FilteredBlock m ) { \n \n \t3 log . debug ( <string_literal> , getAddress ( ) , m . getHash ( ) . toString ( ) ) ; \n \n \t2 if ( ! vDownloadData ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 <comment> \n \n \t3 Thread . sleep ( 1000L ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 final String s ; \n \n \t2 if ( SHORT_CF_NAME_MAP . containsKey ( longName ) ) { \n \n \t3 s = SHORT_CF_NAME_MAP . get ( longName ) ; \n \n \t3 Preconditions . checkNotNull ( s ) ; \n \n <ect>
\t2 try { \n \n \t3 doService ( request , response ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t2 } catch ( SQLException e ) { \n \n \t3 try { \n \n \t4 connection . rollback ( ) ; \n \n \t3 } catch ( SQLException e1 ) { \n \n <ect>
\t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 assertAcked ( admin ( ) . indices ( ) . prepareAliases ( ) . addAlias ( <string_literal> , <string_literal> + i ) ) ; \n \n \t3 client ( ) . index ( indexRequest ( <string_literal> + i ) . type ( <string_literal> ) . id ( <string_literal> ) . source ( source ( <string_literal> , <string_literal> ) , XContentType . JSON ) ) . get ( ) ; } } \n \n \t1 public void testWaitForAliasCreationSingleShard ( ) throws Exception { \n \n <ect>
\t2 log . warn ( <string_literal> ) ; <comment> \n \n \t2 listener = null ; } \n \n \t1 HoldSampleSender ( RemoteSampleListener listener ) { \n \n \t2 this . listener = listener ; \n \n <ect>
\t2 try { \n \n \t3 binder . runPlan ( args ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 System . out . println ( <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t2 if ( result != null ) { \n \n \t3 List < FileInfo > info = result . getFile ( ) ; \n \n \t3 for ( FileInfo fi : info ) { \n \n \t4 if ( file . getFileName ( ) . equals ( fi . getPath ( ) ) ) { \n \n <ect>
\t5 buffer . delete ( 0 , i ) ; \n \n \t5 if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { \n \n \t6 braceSpace += buffer . substring ( 0 , <number_literal> ) ; \n \n \t6 if ( <string_literal> . indexOf ( buffer . charAt ( <number_literal> ) ) == - 1 ) { \n \n <ect>
\t3 return null ; } \n \n \t2 try { \n \n \t3 return new FormattableColor ( defaultValue ) ; \n \n \t2 } catch ( InvalidArgumentException e ) { \n \n <ect>
\t3 if ( ! initializedLogin ) { \n \n \t4 synchronized ( this ) { \n \n \t5 if ( login == null ) { \n \n <ect>
\t3 } finally { \n \n \t4 try { \n \n \t5 is . close ( ) ; \n \n \t4 } catch ( final IOException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 createSequenceFile ( 0 , TOTAL_RECORDS , className ) ; \n \n \t1 <comment> \n \n <ect>
\t4 throw new DSpaceSWORDException ( \n \n \t5 <string_literal> ) ; } \n \n \t3 return ( Collection ) dso ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 if ( server != null ) { \n \n \t3 try { \n \n \t4 return ( ( InetSocketAddress ) server . localAddress ( ) ) . getPort ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( ResourceUnavailableException ex1 ) { \n \n \t3 s_logger . warn ( <string_literal> , ex1 ) ; \n \n \t3 throw new ServerApiException ( BaseCmd . RESOURCE_UNAVAILABLE_ERROR , ex1 . getMessage ( ) ) ; \n \n \t2 } catch ( ResourceInUseException ex2 ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( head . hasKey ( kLink ) ) { \n \n \t4 List < String > links = new ArrayList < > ( ) ; \n \n \t4 if ( head . get ( kLink ) . isString ( ) ) { \n \n <ect>
\t2 return true ; } \n \n \t1 @ Override \n \n \t1 public boolean prepare ( Network network , NicProfile nicProfile , VirtualMachineProfile vm , DeployDestination dest , ReservationContext context ) \n \n \t2 throws ConcurrentOperationException , ResourceUnavailableException , InsufficientCapacityException { \n \n <ect>
\t5 return ; } } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n \t4 this . connection = null ; \n \n <ect>
\t1 public void start ( ) { \n \n \t2 super . start ( ) ; \n \n \t2 logger = ( ( LoggerContext ) getContext ( ) ) . getLogger ( <string_literal> ) ; } \n \n \t1 protected void append ( ILoggingEvent eventObject ) { \n \n <ect>
<number_literal> generatorClass ) ; } } } \n \n \t5 } catch ( Exception e ) { \n \n \t6 logger . error ( <string_literal> , module . getId ( ) , e ) ; } \n \n \t4 } else { \n \n <ect>
\t2 DeliveryStatusMessage dsm = buildDSM ( ctx , replyToken ) ; \n \n \t2 GarlicMessage msg = wrapDSM ( ctx , skm , dsm ) ; \n \n \t2 if ( msg == null ) { \n \n \t3 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 NID nID = nInfo . getNID ( ) ; \n \n \t2 NodeInfo oldInfo = _knownNodes . get ( nID ) ; \n \n \t2 if ( oldInfo == null ) { \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 public int read ( boolean firstRead , long readCount ) { \n \n \t2 if ( readCount > INITIAL_BUFFER_SIZE && readCount < maxMemorySize ) { \n \n \t3 int newMargin = maxMemorySize - MARGIN_MEDIUM ; \n \n \t3 if ( bufferOverflowWarning != newMargin ) { \n \n <ect>
\t4 public void stop ( BundleContext bundleContext ) throws Exception { \n \n \t5 unregisterOSGi ( ) ; } \n \n \t3 } ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
<comment> \n \n private void throwPoolInitializationException ( Throwable t ) \n \n { \n \n <ect>
\t3 return null ; } \n \n \t2 String lang = x . getLiteralLanguage ( ) ; \n \n \t2 if ( lang . isEmpty ( ) ) { \n \n \t3 if ( x . getLiteralDatatype ( ) != null && ! x . getLiteralDatatype ( ) . equals ( XSDDatatype . XSDstring ) ) { \n \n <ect>
\t1 if ( mimeType != null ) { \n \n \t1 try { \n \n \t2 mediaType = MediaType . valueOf ( mimeType ) ; \n \n \t1 } catch ( IllegalArgumentException iae ) { \n \n <ect>
\t2 if ( rs != null ) { \n \n \t2 if ( rs . next ( ) && rs . getInt ( 1 ) == 0 ) { \n \n \t3 dbAccessor . executeQuery ( String . format ( <string_literal> , ambariSequencesTable , seqName , seqDefaultValue ) , ignoreFailure ) ; \n \n \t2 } else { \n \n <ect>
\t1 throw new ExportException ( msg ) ; } \n \n \t1 if ( ! options . isBatchMode ( ) ) { \n \n \t1 if ( ! NetezzaManager . batchModeWarningPrinted ) { \n \n \t2 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t6 . build ( ) ; \n \n \t4 this . scheduler . scheduleJob ( jobTrigger ) ; \n \n \t4 log . info ( <string_literal> , eventRuntime . getConfig ( ) . getKey ( ) ) ; \n \n \t3 } catch ( SchedulerException e ) { \n \n <ect>
\t5 repositories \n \n \t5 . add ( obj . optJSONObject ( <string_literal> ) . optString ( <string_literal> ) ) ; } \n \n \t4 <comment> \n \n \t4 if ( ! repositories . contains ( karma_model_repo ) ) { \n \n <ect>
\t2 final String fingerprint = deviceFingerprintStrategy . determineFingerprint ( principal , requestContext ) ; \n \n \t2 LOGGER . debug ( <string_literal> , principal , fingerprint ) ; \n \n \t2 if ( results . stream ( ) \n \n \t4 . noneMatch ( entry - > entry . getDeviceFingerprint ( ) . equals ( fingerprint ) ) ) { \n \n <ect>
\t2 try { \n \n \t3 transactionHandler = zoneDAO . createTransaction ( ) ; \n \n \t3 DBZone dbZone = this . zoneDAO . get ( new HighLevelQuery < DBZone > ( this . zoneIDQueryParameterFactory . getParameter ( zoneID ) , ( Field ) null ) , transactionHandler ) ; \n \n \t3 if ( dbZone == null ) { \n \n <ect>
\t1 if ( ClusterType . MINI == type \n \n \t2 && TRUE . equals ( System . getProperty ( MiniClusterHarness . USE_KERBEROS_FOR_IT_OPTION ) ) ) { \n \n \t1 krb = new TestingKdc ( ) ; \n \n \t1 krb . start ( ) ; \n \n <ect>
\t3 LOG . info ( <string_literal> + column + <string_literal> + table + <string_literal> ) ; \n \n \t3 sql . execute ( String . format ( <string_literal> , table , column ) ) ; } } \n \n \t2 return Boolean . TRUE ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 if ( _resourceMgr . findHostByGuid ( record . uuid ) != null ) { \n \n \t5 s_logger . debug ( <string_literal> + record . address + <string_literal> + record . uuid + <string_literal> ) ; \n \n \t5 continue ; } \n \n \t4 CitrixResourceBase resource = createServerResource ( dcId , podId , record , latestHotFix ) ; \n \n <ect>
\t1 public BigDecimal lastQuotaBalance ( final Long accountId , final Long domainId , Date startDate ) { \n \n \t2 List < QuotaBalanceVO > quotaBalance = lastQuotaBalanceVO ( accountId , domainId , startDate ) ; \n \n \t2 BigDecimal finalBalance = new BigDecimal ( 0 ) ; \n \n \t2 if ( quotaBalance . isEmpty ( ) ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + pool + <string_literal> ) ; \n \n \t3 avoid . addPool ( pool . getId ( ) ) ; } \n \n \t2 if ( pools . size ( ) == 0 ) { \n \n <ect>
\t1 log . debug ( <string_literal> , sleep , p ) ; \n \n \t1 try { \n \n \t1 Thread . sleep ( sleep ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t1 private void backUpConfig ( final Resource xmlFile ) throws IOException { \n \n \t2 String timeStamp = new SimpleDateFormat ( <string_literal> ) . format ( new Date ( ) ) ; \n \n \t2 String backUpFileName = <string_literal> + timeStamp + <string_literal> ; \n \n \t2 Resource parentFile = xmlFile . parent ( ) ; \n \n <ect>
\t5 try { \n \n \t6 logger . warn ( <string_literal> ) ; \n \n \t6 connect ( ) ; \n \n \t5 } catch ( InboundConnectionFailure e ) { \n \n <ect>
\t2 . getUpgradeCatalog ( targetVersion ) ; \n \n \t1 LOG . debug ( <string_literal> , targetUpgradeCatalog ) ; \n \n \t1 <comment> \n \n \t1 String sourceVersion = schemaUpgradeHelper . readSourceVersion ( ) ; \n \n <ect>
\t4 <string_literal> ) ; \n \n \t3 if ( stream != null ) { \n \n \t4 types . loadFromXML ( stream ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t5 LOG . debug ( <string_literal> ) ; } \n \n \t4 <comment> \n \n \t4 runIteration ( context ) ; \n \n <ect>
\t6 reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , <string_literal> ) ) ; \n \n \t5 } else { \n \n \t6 reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , <string_literal> ) ) ; } \n \n \t4 } catch ( UnsupportedEncodingException ex ) { \n \n <ect>
\t2 s_logger . debug ( <string_literal> + ipId + <string_literal> ) ; \n \n \t2 try { \n \n \t3 _vpnMgr . destroyRemoteAccessVpnForIp ( ipId , caller , false ) ; \n \n \t2 } catch ( ResourceUnavailableException e ) { \n \n <ect>
\t3 broker . waitUntilStopped ( ) ; } } \n \n \t1 public List < TextMessage > consumeMessages ( String queue , \n \n \t9 String transportURL ) throws JMSException { \n \n \t2 Connection connection = null ; \n \n <ect>
\t1 descs . setMember ( ( ArrayList < PolicyAttributeDescription > ) policyAttrs ) ; \n \n \t1 policyDesc . setPolicyAttributeDescriptions ( descs ) ; \n \n \t1 return policyDesc ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t4 String destination = eventHandler . waitForNamingReply ( <string_literal> ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t5 _log . debug ( <string_literal> + destination ) ; \n \n \t4 if ( destination == null ) { \n \n <ect>
\t2 PurityNode n = ( PurityNode ) itt . next ( ) ; \n \n \t2 if ( ! nodes . contains ( n ) ) \n \n \t3 { logger . debug ( <string_literal> + l + <string_literal> + n ) ; err = true ; } \n \n \t2 if ( ! backLocals . get ( n ) . contains ( l ) ) \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t4 } else { \n \n \t5 authServer = hostname + <string_literal> + host . getPort ( ) ; } \n \n \t4 final String serviceName = host . getSchemeName ( ) . toUpperCase ( Locale . ROOT ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 success = compiler . compile ( className , classDeclString ) ; \n \n \t2 } catch ( IOException ex ) { \n \n \t3 String msg = <string_literal> ; \n \n \t3 msg += ex . toString ( ) ; \n \n <ect>
\t2 <comment> \n \n \t2 connection = ProxyConnection . create ( this ) ; \n \n \t2 if ( ! registerUsingNextAddress ( ) ) \n \n \t2 { \n \n <ect>
\t6 boolean processed = messageProcessor . execute ( message , responseMessages ) ; \n \n \t6 ( processed ? successMessages : discardMessages ) . add ( message ) ; } \n \n \t5 catch ( Exception ex ) \n \n \t5 { \n \n <ect>
\t5 curColumn = 0 ; \n \n \t5 curRow ++ ; } } \n \n \t3 repaint ( ) ; \n \n \t2 } else { \n \n <ect>
\t6 { \n \n \t7 toolchains . add ( toolchain ) ; } } \n \n \t5 catch ( MisconfiguredToolchainException ex ) \n \n \t5 { \n \n <ect>
\t1 end \n \n \t1 break if servername \n \n \t1 sleep 0 . <number_literal> \n \n end \n \n <ect>
\t3 for ( int i = 0 ; i < num ; i ++ ) { \n \n \t4 unsafe . putInt ( keyTemplate , offset , i ) ; \n \n \t4 rocksDB . put ( writeOptions , keyTemplate , valueBytes ) ; } \n \n \t3 final long endInsert = System . nanoTime ( ) ; \n \n <ect>
\t4 try { \n \n \t5 while ( ! emitQueue . offer ( message , TIME_OUT , TimeUnit . MILLISECONDS ) ) { \n \n \t6 LOG . error ( <string_literal> ) ; } \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t7 StringDescriptionWriter sdw = Descriptions . stringWriter ( ) ; \n \n \t7 NodeDescriber . INSTANCE . describe ( node , sdw ) ; \n \n \t7 logger . debug ( <string_literal> , sdw . finish ( ) ) ; } \n \n \t6 writeCompressedObject ( file , obj ) ; \n \n <ect>
\t2 <comment> \n \n \t2 DSpaceObject obj = handleService . resolveToObject ( context , testItemHandle ) ; \n \n \t2 assertThat ( <string_literal> + testItemHandle + <string_literal> , obj , nullValue ( ) ) ; \n \n \t2 <comment> \n \n <ect>
\t6 if ( m_TransDelayMS > 0 ) { \n \n \t7 try { \n \n \t8 Thread . sleep ( m_TransDelayMS ) ; \n \n \t7 } catch ( InterruptedException ex ) { \n \n <ect>
\t3 _log . debug ( <string_literal> ) ; \n \n \t3 try { Thread . sleep ( <number_literal> * <number_literal> ) ; } catch ( InterruptedException ie ) { } \n \n \t3 s . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
public CreateBucketResponseType createBucket ( CreateBucketType request ) throws S3Exception { \n \n \t1 try { \n \n \t1 return proxyRequest ( request , com . eucalyptus . walrus . msgs . CreateBucketType . class , com . eucalyptus . walrus . msgs . CreateBucketResponseType . class ) ; \n \n \t1 } catch ( EucalyptusCloudException e ) { \n \n <ect>
\t3 _cluster . setStatus ( topId , <string_literal> ) ; \n \n \t3 return 0 ; } \n \n \t2 int slotsNeeded = slotsToUse - slotsFree ; \n \n \t2 int numNewNodes = NodePool . getNodeCountIfSlotsWereTaken ( slotsNeeded , lesserPools ) ; \n \n <ect>
\t5 <comment> \n \n \t5 <comment> \n \n \t5 for ( VMInstanceVO vm : vms ) { \n \n \t6 if ( ! vm . isHaEnabled ( ) || vm . getState ( ) == State . Stopping ) { \n \n <ect>
\t2 { \n \n \t3 if ( self == null ) \n \n \t4 return ; <comment> \n \n \t3 <comment> \n \n <ect>
\t5 settings . log ( ) ; \n \n \t4 } else if ( commandStr . equalsIgnoreCase ( <string_literal> ) ) { \n \n \t5 settings . helpItems ( ) ; \n \n \t4 } else { \n \n <ect>
\t3 con . setTcpNoDelay ( getNoDelay ( ) ) ; \n \n \t4 log . debug ( <string_literal> , this , getTimeout ( ) , getNoDelay ( ) ) ; <comment> \n \n \t2 } catch ( SocketException se ) { \n \n <ect>
\t7 downloadFinished ( progress ) ; } } \n \n \t5 finally { \n \n \t6 progress . setDone ( true ) ; } } } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t4 return email ; } \n \n \t3 LOGGER . debug ( <string_literal> , username ) ; \n \n \t3 return null ; \n \n \t2 } catch ( final EmptyResultDataAccessException e ) { \n \n <ect>
\t2 File dump = temporaryFolder . newFolder ( ) ; \n \n \t2 List < String > argsList = Lists \n \n \t3 . newArrayList ( <string_literal> + dsOption , cfgFilePath , <string_literal> , storePath , \n \n \t4 <string_literal> , dump . getAbsolutePath ( ) ) ; \n \n <ect>
\t4 log . info ( <string_literal> , \n \n \t5 keyExtent ) ; } } } \n \n \t3 <comment> \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t2 Message messageExceedingTtl = receiveMessage ( connection3 , <number_literal> ) ; \n \n \t2 if ( messageExceedingTtl != null ) { \n \n \t3 LOG . error ( <string_literal> + messageExceedingTtl ) ; \n \n \t3 connection3 . send ( createAck ( consumerInfoS3 , messageExceedingTtl , 1 , MessageAck . INDIVIDUAL_ACK_TYPE ) ) ; } \n \n <ect>
\t2 try { \n \n \t3 String formattedQuery = String . format ( \n \n \t5 <string_literal> , configuration . getPathField ( ) , path ) ; \n \n <ect>
\t4 . filter ( p - > p . getKey ( ) . startsWith ( <string_literal> ) \n \n \t6 && ( StringUtils . isBlank ( p . getValue ( ) . getShortDescription ( ) ) || StringUtils . isBlank ( p . getValue ( ) . getDescription ( ) ) ) ) \n \n \t4 . map ( Map . Entry : : getValue ) \n \n \t4 . sorted ( Comparator . comparing ( ConfigurationMetadataProperty : : getId ) ) \n \n <ect>
\t2 clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . add ( newNode ( <string_literal> ) ) . add ( newNode ( <string_literal> ) ) ) . build ( ) ; \n \n \t2 clusterState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n \t2 while ( ! clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . isEmpty ( ) ) { \n \n \t3 clusterState = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; } \n \n <ect>
\t4 return ; } \n \n \t3 LOGGER . debug ( <string_literal> , metadata ) ; \n \n \t3 final String collectionName = getTicketCollectionInstanceByMetadata ( metadata ) ; \n \n \t3 if ( StringUtils . isBlank ( collectionName ) ) { \n \n <ect>
\t4 && lastCheckpointCleanUpTime + cleanupIntervalMinutes < currentMinutes ) { \n \n \t3 try { \n \n \t4 cleanUpCheckpoints ( ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t4 public boolean isTerminateSignal ( ) { \n \n \t5 return false ; } \n \n \t3 } ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t4 final String msg = <string_literal> + srr . nameLabel + <string_literal> + _host . getUuid ( ) ; \n \n \t4 s_logger . warn ( msg ) ; \n \n \t4 return false ; } \n \n <ect>
\t4 } catch ( IOException e ) { \n \n \t5 log . warn ( <string_literal> , e ) ; } } } \n \n \t3 if ( resultEntry == null ) { \n \n <ect>
\t5 if ( command instanceof DecimalType ) { \n \n \t6 float temperature = ( ( DecimalType ) command ) . floatValue ( ) ; \n \n \t6 int value = ( int ) ( temperature * <number_literal> . ) ; \n \n \t6 if ( sendParamToHeatpump ( PARAM_COOLING_RELEASE_TEMP , value ) ) { \n \n <ect>
\t2 except Exception as e : \n \n \t3 self . fail ( e ) \n \n \t2 finally : \n \n \t3 self . assertIsNotNone ( ntwk2 , <string_literal> ) \n \n <ect>
\t3 doAddJob ( add . getJob ( ) , add . getTrigger ( ) ) ; } \n \n \t2 jobsToAdd . clear ( ) ; \n \n \t2 if ( ! getScheduler ( ) . isStarted ( ) ) { \n \n \t3 if ( getStartDelayedSeconds ( ) > 0 ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( createConnector ) { \n \n \t4 createJmxConnector ( hostName ) ; } \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t3 AdminClient adminClient = adminClients . get ( clusterNode . getPrefixId ( ) ) ; \n \n \t3 List < Integer > singlePartition = new ArrayList < Integer > ( ) ; \n \n \t3 singlePartition . add ( partitionId ) ; \n \n <ect>
\t2 byte [ ] imgBits = null ; \n \n \t2 try { \n \n \t3 imgBits = ImageHelper . jpegFromImage ( bufferedImage ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 return ; } \n \n \t3 deleteVirtualMachineInterfaces ( vncVm . getVirtualMachineInterfaces ( ) , syncLogMesg ) ; \n \n \t3 api . delete ( VirtualMachine . class , vncVm . getUuid ( ) ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t10 iterator . remove ( ) ; \n \n \t10 continue ; } \n \n \t9 if ( w . matcher . matches ( filename ) ) { \n \n \t10 <comment> \n \n <ect>
\t3 String key = <string_literal> + endpoint . getEndpointKey ( ) . replaceFirst ( <string_literal> , <string_literal> ) ; \n \n \t3 <comment> \n \n \t3 if ( key . contains ( <string_literal> ) ) { \n \n \t4 key = ObjectHelper . before ( key , <string_literal> ) ; } \n \n <ect>
\t3 Versioned < String > existingValue = this . systemStoreRepository . getClientRegistryStore ( ) \n \n <number_literal> . getSysStore ( clientId ) ; \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t3 logger . warn ( <string_literal> + clientInfo + <string_literal> + lastVersion ) ; \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t4 log . error ( <string_literal> , e ) ; } \n \n \t3 this . externalResults = false ; \n \n \t2 } else { \n \n <ect>
\t2 registerJMX ( new ReadOnlyBean ( this ) , self . jmxLocalPeerBean ) ; \n \n \t2 super . startup ( ) ; \n \n \t2 self . setZooKeeperServer ( this ) ; \n \n \t2 self . adminServer . setZooKeeperServer ( this ) ; \n \n <ect>
\t5 else \n \n \t6 newData = core . tempBucketFactory . makeBucket ( origData . size ( ) ) ; \n \n \t5 BucketTools . copy ( origData , newData ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t4 variantPath = t . getVariantFolder ( variant ) . getAbsolutePath ( ) ; \n \n \t3 } else { \n \n \t4 Target t = Base . targetsTable . get ( variant . substring ( 0 , variant . indexOf ( ' : ' ) ) ) ; \n \n \t4 variantPath = t . getVariantFolder ( variant ) . getAbsolutePath ( ) ; } } \n \n <ect>
\t6 LOGGER . info ( <string_literal> ) ; \n \n \t6 final Properties call = getGit ( ) . gc ( ) . call ( ) ; \n \n \t6 LOGGER . info ( <string_literal> + call . toString ( ) ) ; \n \n \t5 } catch ( final GitAPIException e ) { \n \n <ect>
\t5 result = currentResult ; } \n \n \t3 } catch ( NumberFormatException ex ) { \n \n \t4 LOGGER . warn ( <string_literal> , matchResult , mediaInfoValue ) ; } } \n \n \t2 if ( result < 1 ) { \n \n <ect>
\t4 numberOfMessageSent ++ ; } \n \n \t3 LOG . info ( <string_literal> + numberOfMessageSent ) ; \n \n \t3 return numberOfMessageSent ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 try { \n \n \t3 final Query query = new Query ( ) ; \n \n \t3 query . addCriteria ( Criteria . where ( <string_literal> ) . lte ( onOrBefore ) ) ; \n \n \t3 final WriteResult res = this . mongoTemplate . remove ( query , MultifactorAuthenticationTrustRecord . class , this . collectionName ) ; \n \n <ect>
\t5 swapIsPossible = strategy . dealWithIt ( storeName , pushVersion , fetchResponseMap ) ; \n \n \t5 logger . info ( <string_literal> + strategy . toString ( ) + <string_literal> + swapIsPossible ) ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 if ( strategyIterator . hasNext ( ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 ipToRelease . setVpcId ( null ) ; \n \n \t4 ipToRelease . setAssociatedWithNetworkId ( null ) ; \n \n \t4 _ipAddressDao . update ( ipToRelease . getId ( ) , ipToRelease ) ; \n \n <ect>
\t3 msg . setOnSendJob ( _onSend ) ; \n \n \t3 msg . setReplySelector ( _selector ) ; \n \n \t3 getContext ( ) . outNetMessagePool ( ) . add ( msg ) ; \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 ohtfDevice . getSubDeviceIds ( ) . addAll ( Arrays . asList ( NoSubIds . values ( ) ) ) ; \n \n \t3 ohtfDevice . setTfConfig ( tfBrickDCConfiguration ) ; \n \n \t3 fillupConfig ( ohtfDevice , deviceConfig ) ; \n \n \t2 } else if ( deviceType . equals ( TypeKey . io_actuator . name ( ) ) ) { \n \n <ect>
\t3 final WSFederationMetadataWriter mw = new WSFederationMetadataWriter ( ) ; \n \n \t3 final Document metadata = mw . produceMetadataDocument ( casProperties ) ; \n \n \t3 out . write ( DOM2Writer . nodeToString ( metadata ) ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t3 return Optional . of ( beanName ) ; } \n \n \t2 Optional < AbstractBeanDefinition > beanDefinition = implementationDetector . detectCustomImplementation ( configuration ) ; \n \n \t2 return beanDefinition . map ( it - > { \n \n <ect>
\t1 if ( dbParams != null ) { \n \n \t1 for ( HiveConf . ConfVars var : HiveConf . dbVars ) { \n \n \t2 String newValue = dbParams . get ( var . varname ) ; \n \n \t2 if ( newValue != null ) { \n \n <ect>
\t3 } catch ( FileNotFoundException e ) { \n \n \t4 Logger . error ( this , <string_literal> + source + <string_literal> + name + <string_literal> + e , e ) ; \n \n \t4 return ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 } catch ( final Exception e ) { \n \n \t6 s_logger . warn ( <string_literal> + task . toString ( ) + <string_literal> + e . toString ( ) ) ; } } \n \n \t4 if ( srcSr != null ) { \n \n \t5 hypervisorResource . removeSR ( conn , srcSr ) ; } } } \n \n <ect>
\t4 List < FlywayCallback > flywayCallbacks = DSpaceServicesFactory . getInstance ( ) . getServiceManager ( ) \n \n <number_literal> . getServicesByType ( FlywayCallback . class ) ; \n \n \t4 flywaydb . setCallbacks ( flywayCallbacks . toArray ( new FlywayCallback [ flywayCallbacks . size ( ) ] ) ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t3 if ( transactionStatus != null ) { \n \n \t4 try { \n \n \t5 this . transactionManager . rollback ( transactionStatus ) ; } \n \n \t4 catch ( TransactionException tex ) { \n \n <ect>
\t2 while ( tok . hasMoreTokens ( ) ) { \n \n \t3 String elem = tok . nextToken ( ) . trim ( ) ; \n \n \t3 File f = new File ( elem ) ; \n \n \t3 if ( ! f . isAbsolute ( ) ) { \n \n <ect>
\t4 qp , \n \n \t4 OgmLoadingContext . EMPTY_CONTEXT , \n \n \t4 true \n \n \t3 ) ; \n \n <ect>
\t1 String tracker = JobTrackerURLResolver . getURL ( conf ) + <string_literal> + threshold ; \n \n \t1 while ( true ) { \n \n \t2 <comment> \n \n \t2 URL url = new URL ( tracker ) ; \n \n <ect>
\t2 this . dontHopForLocalCL = ! allowRemoteDCsForLocalConsistencyLevel ; } \n \n \t1 @ Override \n \n \t1 public void init ( Cluster cluster , Collection < Host > hosts ) { \n \n \t2 if ( localDc != UNSET ) \n \n <ect>
\t3 if ( vm . getHypervisorType ( ) != HypervisorType . BareMetal ) { \n \n \t4 _storageMgr . release ( profile ) ; \n \n \t4 s_logger . debug ( <string_literal> + vm ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 LOG . debug ( <string_literal> , message ) ; \n \n \t2 if ( this . consumer != null ) { \n \n \t3 this . consumer . sendMessage ( this . connectionKey , message ) ; \n \n \t2 } else { \n \n <ect>
\t5 s_logger . error ( <string_literal> + vm ) ; \n \n \t5 try { \n \n \t6 _agentMgr . send ( srcHostId , new Commands ( cleanup ( vm . getInstanceName ( ) ) ) , null ) ; \n \n \t5 } catch ( final AgentUnavailableException e ) { \n \n <ect>
\t6 break ; } } } \n \n \t3 state = DomainState . VIR_DOMAIN_RUNNING ; \n \n \t3 return new StartAnswer ( command ) ; \n \n \t2 } catch ( final LibvirtException e ) { \n \n <ect>
\t4 if ( ! Arrays . equals ( command . getToken ( ) , token ) ) { \n \n \t5 throw new BadlyFormedRequestException ( String . format ( <string_literal> , command , connection ) ) ; } \n \n \t4 commandExecuter . executeCommand ( daemonConnection , command , daemonContext , daemonStateControl ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t2 return true ; } \n \n \t1 protected class CleanupTask extends ManagedContextRunnable { \n \n \t2 @ Override \n \n \t2 protected void runInContext ( ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 VMTemplateStoragePoolVO templatePoolRef = _tmpltPoolDao . acquireInLockTable ( templatePoolVO . getId ( ) ) ; \n \n \t2 if ( templatePoolRef == null ) { \n \n <ect>
\t3 if ( testHandler . exceptions . isEmpty ( ) ) { \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t3 } else { \n \n \t4 for ( Throwable t : testHandler . exceptions ) { \n \n <ect>
\t8 List < Class < ? extends Throwable > [ ] > failures , Runnable dispatchTask ) { \n \n \t2 int failureCount = failures . size ( ) ; \n \n \t2 if ( ! isExplicitlyNonTransient ( lastFailure ) && failureCount < = maxRetryCount ) { \n \n <ect>
\t1 writeLock . lock ( ) ; \n \n \t1 try { \n \n \t1 ti = tasksById . get ( attemptId ) ; \n \n \t1 if ( ti == null ) { \n \n <ect>
\t8 ex . toString ( ) ) ; } } \n \n \t3 } else { \n \n \t4 logger . warn ( <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t5 textDocProducer = ( TextDocProducer ) dyadic . newInstance ( ds . asDatasetGraph ( ) , textIndex ) ; \n \n \t4 } else if ( monadic != null ) { \n \n \t5 textDocProducer = ( TextDocProducer ) monadic . newInstance ( textIndex ) ; \n \n \t4 } else { \n \n <ect>
\t2 asynSocket . setHandler ( new NginxClojureSocketHandler ( ) { \n \n \t3 @ Override \n \n \t3 public void onWrite ( NginxClojureAsynSocket s , long sc ) throws IOException { \n \n \t4 if ( sc != NginxClojureAsynSocket . NGX_HTTP_CLOJURE_SOCKET_OK ) { \n \n <ect>
\t2 <comment> \n \n \t2 for ( LocationConfig lc : locationConfigs . values ( ) ) { \n \n \t3 if ( ! lc . isValid ( ) ) { \n \n \t4 parseCompleted = true ; \n \n <ect>
\t3 { \n \n \t4 r . close ( ) ; } \n \n \t3 catch ( IOException ex ) \n \n \t3 { \n \n <ect>
\t1 Path exportDir = new Path ( baseDir , <string_literal> ) ; \n \n \t1 Path importDir = new Path ( baseDir , <string_literal> ) ; \n \n \t1 for ( Path p : new Path [ ] { exportDir , importDir } ) { \n \n \t1 assertTrue ( <string_literal> + baseDir , fs . mkdirs ( p ) ) ; } \n \n <ect>
\t4 LOGGER . info ( <string_literal> + ex . getMessage ( ) ) ; \n \n \t3 } catch ( EvaluatorException ex ) { \n \n \t4 LOGGER . info ( <string_literal> + ex . getMessage ( ) ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 input = new CCNInputStream ( name , getHandle ) ; \n \n \t2 input . read ( testBytes ) ; \n \n \t2 Assert . assertArrayEquals ( data , testBytes ) ; \n \n \t2 input . close ( ) ; \n \n <ect>
\t3 while ( ! isExtractorFinished ( ) ) { \n \n \t4 wait ( ) ; } \n \n \t3 return extract ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
@ Override \n \n public void startThreads ( ) throws IOException { \n \n \t1 String principalUser = LlapUtil . getUserNameFromPrincipal ( \n \n \t2 conf . get ( SecretManager . ZK_DTSM_ZK_KERBEROS_PRINCIPAL ) ) ; \n \n <ect>
\t5 public void run ( ) { \n \n \t6 try { \n \n \t7 reallyRun ( ) ; \n \n \t6 } catch ( Throwable e ) { \n \n <ect>
\t2 for ( String childName : childNames ) { \n \n \t3 try { \n \n \t4 <comment> \n \n \t4 if ( ! childName . regionMatches ( 0 , prefix , 0 , prefix . length ( ) ) ) { \n \n <ect>
\t5 if ( c . incoming . size ( ) > 0 && c . isDone ( ) ) \n \n \t6 loadMulti ( new ByteBufArrayInputStream ( c . incoming ) , ret , asString ) ; } \n \n \t4 catch ( Exception e ) { \n \n \t5 <comment> \n \n <ect>
\t1 @ Test \n \n \t1 public void testRequestNetCDFCompression ( ) throws Exception { \n \n \t2 boolean isNC4Available = NetCDFUtilities . isNC4CAvailable ( ) ; \n \n \t2 if ( ! isNC4Available && LOGGER . isLoggable ( Level . INFO ) ) { \n \n <ect>
\t2 command . add ( user ) ; \n \n \t2 command . add ( passwd ) ; \n \n \t2 String result = command . execute ( ) ; \n \n \t2 if ( result != null ) { \n \n <ect>
\t2 if ( dataPurgeConfig . getMaxAgeInDays ( ) < = 0 && dataPurgeConfig . getMaxAgeInHours ( ) < = 0 ) { \n \n \t3 logger . error ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( dataPurgeConfig . isFileBasedPurge ( ) && dataPurgeConfig . getDateStartIndex ( ) < 0 ) { \n \n <ect>
\t4 messagesLog . info ( <string_literal> ) ; } } \n \n \t2 catch ( InterruptedException e ) \n \n \t2 { \n \n \t3 Thread . interrupted ( ) ; \n \n <ect>
\t2 APIContext apiContext = new APIContext ( generateAccessToken ( ) ) ; \n \n \t2 apiContext . setConfigurationMap ( configurationMap ) ; \n \n \t2 Userinfo userInfo = Userinfo . getUserinfo ( apiContext ) ; \n \n \t2 Assert . assertNotNull ( userInfo . getUserId ( ) ) ; \n \n <ect>
\t5 if ( ! valid ) \n \n \t5 { \n \n \t6 ignoreElementsS1 = true ; \n \n \t6 <comment> \n \n <ect>
\t6 break ; <comment> \n \n \t4 } finally { \n \n \t5 jedis . close ( ) ; } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 s = set . ceilingCompatible ( <string_literal> ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> + s ) ; \n \n \t2 Assert . assertTrue ( <string_literal> . equals ( s ) ) ; \t2 \n \n \t2 s = set . ceilingCompatible ( <string_literal> ) ; \n \n <ect>
\t2 private Validator checkPrivateStoreCommit ( String commitPath ) throws CommitFailedException { \n \n \t3 Mount mountInfo = mountInfoProvider . getMountByPath ( commitPath ) ; \n \n \t3 if ( mountInfo . isReadOnly ( ) ) { \n \n \t4 Throwable throwable = new Throwable ( <string_literal> + commitPath ) ; \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 this . mysqlImportProcess = null ; } \n \n \t1 if ( null != this . passwordFile && this . passwordFile . exists ( ) ) { \n \n \t1 if ( ! this . passwordFile . delete ( ) ) { \n \n <ect>
\t2 { \n \n \t3 logger . debug ( <string_literal> ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t6 response = HttpUtil . executeUrl ( <string_literal> , address , timeout ) ; \n \n \t6 server . cache = response ; \n \n \t6 if ( response == null ) { \n \n \t7 server . lastUpdate = ( long ) 0 ; \n \n <ect>
\t3 String line = reader . readLine ( ) ; \n \n \t3 _log . info ( <string_literal> + line ) ; \n \n \t3 s . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 updateLoginAttempts ( userAccount . getId ( ) , 0 , false ) ; \n \n \t3 return userAccount ; \n \n \t2 } else { \n \n <ect>
\t1 LoadBalancer lb ; \n \n \t1 try { \n \n \t1 lb = LoadBalancers . getLoadbalancer ( accountNumber , lbName ) ; \n \n \t1 } catch ( NoSuchElementException ex ) { \n \n <ect>
\t3 . withProvisionedThroughput ( new ProvisionedThroughput ( dynamoDbProperties . getReadCapacity ( ) , \n \n \t4 dynamoDbProperties . getWriteCapacity ( ) ) ) . withTableName ( dynamoDbProperties . getTableName ( ) ) ; \n \n \t2 if ( deleteTables ) { \n \n \t3 final DeleteTableRequest delete = new DeleteTableRequest ( request . getTableName ( ) ) ; \n \n <ect>
\t4 } else { \n \n \t5 long vlanTag = Integer . parseInt ( broadcastURI . getHost ( ) ) ; \n \n \t5 long [ ] bytesSentAndReceived = answer . guestVlanBytes . get ( String . valueOf ( vlanTag ) ) ; \n \n \t5 if ( bytesSentAndReceived == null ) { \n \n <ect>
\t3 return ; \n \n \t2 } else { \n \n \t3 int spaceIndex = params . indexOf ( ' ' ) ; \n \n \t3 if ( spaceIndex == - 1 ) { \n \n <ect>
\t3 bshInterpreter . set ( <string_literal> , sam ) ; <comment> \n \n \t3 processFileOrScript ( bshInterpreter ) ; \n \n \t2 } catch ( JMeterException e ) { \n \n <ect>
\t1 updateJobStatePercentAndChildId ( conf , context . getJobID ( ) . toString ( ) , null , childJobIdString ) ; \n \n \t1 do { \n \n \t2 org . apache . hadoop . mapred . JobStatus jobStatus = tracker . getJobStatus ( childJobId ) ; \n \n \t2 if ( jobStatus . isJobComplete ( ) ) { \n \n <ect>
\t3 VmwareManager mgr = getServiceContext ( ) . getStockObject ( VmwareManager . CONTEXT_STOCK_NAME ) ; \n \n \t3 return mgr . getStorageManager ( ) . execute ( this , cmd ) ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t3 dev = getDevice ( uuid ) ; \n \n \t3 data = rendererMap . get ( uuid , instanceID ) . connect ( this ) ; \n \n \t3 lasturi = null ; \n \n \t3 ignoreUpnpDuration = false ; \n \n <ect>
\t1 @ Override \n \n \t1 public void process ( Exchange exchange ) throws Exception { \n \n \t2 Object body = exchange . getIn ( ) . getBody ( ) ; \n \n \t2 if ( body != null ) { \n \n <ect>
\t5 sd . post ( span , exchange , route . getEndpoint ( ) ) ; \n \n \t5 span . finish ( ) ; \n \n \t5 ActiveSpanManager . deactivate ( exchange ) ; \n \n \t4 } else { \n \n <ect>
\t3 } catch ( final NoTransitionException e1 ) { \n \n \t4 throw new ConcurrentOperationException ( <string_literal> + e1 . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t4 if ( ! checkVmOnHost ( vm , dstHostId ) ) { \n \n <ect>
\t2 xyzresult . expectedMessageCount ( 1 ) ; \n \n \t2 xyzresult . whenAnyExchangeReceived ( new Processor ( ) { \n \n \t3 @ Override \n \n \t3 public void process ( Exchange exchange ) throws Exception { \n \n <ect>
\t3 if ( elapsed < 80L ) { \n \n \t4 assertThat ( history . getMean ( ) , lessThan ( before ) ) ; \n \n \t4 assertThat ( history . getStatistics ( ) . getMean ( ) , lessThan ( statisticsBefore . getMean ( ) ) ) ; } \n \n \t3 else { \n \n <ect>
\t4 Connection conn ; \n \n \t4 try { \n \n \t5 conn = txn . getConnection ( ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t4 if ( m . find ( ) ) { \n \n \t5 try { \n \n \t6 threadId = Integer . valueOf ( m . group ( 1 ) ) ; \n \n \t5 } catch ( NumberFormatException e ) { \n \n <ect>
\t2 if ( socket == null ) { \n \n \t3 _log . log ( Log . CRIT , <string_literal> + _bindAddress ) ; \n \n \t2 } else if ( port != _listenPort ) { \n \n \t3 if ( _listenPort > 0 ) \n \n <ect>
\t1 do { \n \n \t1 <comment> \n \n \t1 val = runningFragmentCount . get ( ) ; \n \n \t1 if ( val == 0 ) { \n \n <ect>
\t1 self . configure ( env ) \n \n \t1 common . validate_configuration ( ) \n \n \t1 exchange_ssh_keys = default ( ' / configurations / hawq - env / hawq_ssh_exkeys' , None ) \n \n \t1 if exchange_ssh_keys is None or str ( exchange_ssh_keys ) . lower ( ) == 'false' : \n \n <ect>
\t1 TraversingStructureEnum . SPARSEROWWISE , <string_literal> ) \n \n \t1 jvmRWRW ( aclone , b , r ) } \n \n <comment> \n \n private def gpuSparseRWRW ( a : Matrix , b : Matrix , r : Option [ Matrix ] = None ) : Matrix = { \n \n <ect>
\t4 NewDriver . addURL ( path ) ; \n \n \t4 log . info ( <string_literal> , path ) ; \n \n \t3 } catch ( MalformedURLException e ) { \n \n \t4 <comment> \n \n <ect>
\t2 final Map < String , Object > attributes = repository . getUser ( username ) ; \n \n \t2 if ( attributes == null || attributes . isEmpty ( ) \n \n \t4 || ! attributes . containsKey ( cloudDirectoryProperties . getUsernameAttributeName ( ) ) \n \n \t4 || ! attributes . containsKey ( cloudDirectoryProperties . getPasswordAttributeName ( ) ) ) { \n \n <ect>
\t1 public void compileErl ( @ NonNull final IProject project , final BuildResource resource , final String outputDir , \n \n \t3 final IOtpRpc b , final OtpErlangList compilerOptions ) { \n \n \t2 final RpcFuture res = startCompileErl ( project , resource , outputDir , b , compilerOptions , true ) ; \n \n \t2 if ( res == null ) { \n \n <ect>
\t1 this . credentialStore = credentialStore ; } \n \n public void execute ( OrgAndName orgTag ) { \n \n \t1 for ( KeyPair keyPair : terremarkClient . listKeyPairsInOrg ( orgTag . getOrg ( ) ) ) { \n \n \t2 if ( keyPair . getName ( ) . matches ( <string_literal> + orgTag . getName ( ) . replaceAll ( <string_literal> , <string_literal> ) + <string_literal> ) ) { \n \n <ect>
\t4 IcqSlickFixture . testerAgent . getAuthCmdFactory ( ) . ACCEPT ) ; \n \n \t3 Object obj = new Object ( ) ; \n \n \t3 synchronized ( obj ) \n \n \t3 { \n \n <ect>
\t5 journal = new JournalImpl ( journalDir , journalLogFiles , journalLogFileSize , \n \n <number_literal> getJournalArchiveDirectory ( ) ) ; \n \n \t5 break ; \n \n \t4 } catch ( JournalLockedException e ) { \n \n <ect>
\t5 <comment> \n \n \t5 indexToOverwrite = 0 ; } \n \n \t4 <comment> \n \n \t4 if ( logDEBUG ) \n \n <ect>
\t2 if ( FileStore . isOnline ) { \n \n \t3 log . info ( TAG , <string_literal> ) \n \n \t3 broadcastFileSync ( lbm ) \n \n \t2 } else { \n \n <ect>
\t3 connection = defaultOutput ; } \n \n \t2 if ( connection != null ) { \n \n \t3 connection . say ( text , voiceName ) ; \n \n \t2 } else { \n \n <ect>
public class KylinMapper < KEYIN , VALUEIN , KEYOUT , VALUEOUT > extends Mapper < KEYIN , VALUEIN , KEYOUT , VALUEOUT > { \n \n \t1 private static final Logger logger = LoggerFactory . getLogger ( KylinMapper . class ) ; \n \n \t1 protected int mapCounter = 0 ; \n \n \t1 protected void bindCurrentConfiguration ( Configuration conf ) { \n \n <ect>
\t6 return true ; \n \n \t5 } catch ( LibvirtException l ) { \n \n \t6 s_logger . error ( <string_literal> + l ) ; } \n \n \t4 } else { \n \n <ect>
\t2 messagesA . assertMessagesReceived ( 0 ) ; \n \n \t2 messagesB . assertMessagesReceived ( 1 ) ; } \n \n \t1 public void testSendRestart ( ) throws Exception { \n \n \t2 Thread . sleep ( <number_literal> ) ; \n \n <ect>
\t2 if ( result . isSuccess ( ) ) { \n \n \t3 ModuleEnvironment modEnv = moduleManager . loadEnvironment ( result . getModules ( ) , true ) ; \n \n \t3 logger . debug ( <string_literal> + modEnv . getModuleIdsOrderedByDependencies ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t1 <comment> \n \n \t1 if ( key . size ( ) > 0 ) { \n \n \t2 applies = predicate . apply ( key ) ; \n \n \t1 } else { \n \n <ect>
\t3 OutputStream outputStream = _session . getStdin ( ) ; \n \n \t3 outputStream . write ( message . getBytes ( ) ) ; \n \n \t3 outputStream . flush ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 BlockGunzipper . setDefaultInflaterFactory ( new IntelInflaterFactory ( ) ) ; } \n \n \t2 final boolean usingIntelDeflater = ( BlockCompressedOutputStream . getDefaultDeflaterFactory ( ) instanceof IntelDeflaterFactory && ( ( IntelDeflaterFactory ) BlockCompressedOutputStream . getDefaultDeflaterFactory ( ) ) . usingIntelDeflater ( ) ) ; \n \n \t2 logger . info ( <string_literal> + ( usingIntelDeflater ? <string_literal> : <string_literal> ) ) ; \n \n \t2 final boolean usingIntelInflater = ( BlockGunzipper . getDefaultInflaterFactory ( ) instanceof IntelInflaterFactory && ( ( IntelInflaterFactory ) BlockGunzipper . getDefaultInflaterFactory ( ) ) . usingIntelInflater ( ) ) ; \n \n <ect>
\t1 setup . preTest ( conf ) ; \n \n \t1 setupMiniCluster ( shims , confDir ) ; \n \n \t1 initConf ( ) ; \n \n \t1 if ( withLlapIo && ( clusterType == MiniClusterType . none ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 Set < Class < ? > > classes = new HashSet < Class < ? > > ( ) ; \n \n \t2 packageNames = filterPackageNamesOnly ( resolver , packageNames , classes ) ; \n \n \t2 if ( ! classes . isEmpty ( ) ) { \n \n <ect>
\t3 ModificationQueue modificationQueue = command . getModificationQueue ( ) ; \n \n \t3 if ( modificationQueue != null ) { \n \n \t4 modificationQueue . postProcess ( key , process ) ; \n \n \t3 } else { \n \n <ect>
\t5 LOG . debug ( <string_literal> , this . connected , connected ) ; \n \n \t5 final Connected oldConnected = this . connected ; \n \n \t5 this . connected = connected ; \n \n \t5 if ( oldConnected != null ) { \n \n <ect>
\t3 return null ; } \n \n \t2 try { \n \n \t3 vms = conn . listDefinedDomains ( ) ; \n \n \t2 } catch ( final LibvirtException e ) { \n \n <ect>
\t3 case Event . CREATE : \n \n \t3 case Event . MODIFY : \n \n \t3 case Event . MODIFY_METADATA : \n \n \t4 if ( subject == null ) { \n \n <ect>
\t2 try { \n \n \t3 MetadataHandler . getInstance ( ) . generate ( Weather . class ) ; \n \n \t3 CommonIdHandler . getInstance ( ) . loadMapping ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t5 val campaignLink = CrmLinkGenerator . generateCampaignPreviewFullLink ( context . siteUrl , campaign . id ) \n \n \t5 val link = FormatUtils . newA ( campaignLink , campaign . campaignname ) \n \n \t5 return FormatUtils . newLink ( img , link ) . write ( ) } \n \n \t3 } catch ( e : Exception ) { \n \n <ect>
\t1 public void terminateSession ( ) { \n \n \t2 try { \n \n \t3 zk . closeSession ( sessionId ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t7 final String ip = addr . getHostAddress ( ) ; \n \n \t7 if ( ip . equalsIgnoreCase ( defaultHostIp ) ) { \n \n \t8 cidrList . add ( ipAndNetMaskToCidr ( ip , getCidrNetmask ( prefixLength ) ) ) ; } } } } } \n \n \t2 } catch ( final SocketException e ) { \n \n <ect>
\t3 ExecutionConfig executionConfig = jobInformation . getSerializedExecutionConfig ( ) . deserializeValue ( userClassLoader ) ; \n \n \t3 if ( executionConfig != null ) { \n \n \t4 return executionConfig . archive ( ) ; } \n \n \t2 } catch ( IOException | ClassNotFoundException e ) { \n \n <ect>
\t1 private void xmlDefault ( String path ) throws Exception { \n \n \t2 WebTarget target = client . target ( PortProviderUtil . generateURL ( <string_literal> , path ) ) ; \n \n \t2 logger . info ( entityXml ) ; \n \n \t2 logger . info ( <string_literal> + Charset . defaultCharset ( ) ) ; \n \n <ect>
\t6 true ) ; \n \n \t5 <comment> \n \n \t5 addDocuments ( client , documents , true ) ; } } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t4 try { \n \n \t5 DataStore dataStore = storeMgr . getDataStore ( volumeDataStore . getDataStoreId ( ) , DataStoreRole . Image ) ; \n \n \t5 EndPoint ep = _epSelector . select ( dataStore , volumeDataStore . getExtractUrl ( ) ) ; \n \n \t5 if ( ep == null ) { \n \n <ect>
\t1 try { <comment> \n \n \t2 client . getPartition ( dbName , tableName , partitionSpec ) ; \n \n \t2 assertTrue ( <string_literal> , false ) ; \n \n \t1 } catch ( Exception exception ) { \n \n <ect>
\t2 server . start ( ) ; } \n \n \t1 protected static void setupClient ( ) throws Exception { \n \n \t2 olingoApp = new Olingo2AppImpl ( TEST_SERVICE_URL + <string_literal> ) ; \n \n \t2 olingoApp . setContentType ( TEST_FORMAT_STRING ) ; \n \n <ect>
\t4 executorService . shutdownNow ( ) ; \n \n \t3 } else { \n \n \t4 try { \n \n \t5 if ( ! executorService . awaitTermination ( timeLeft , TimeUnit . MILLISECONDS ) ) { \n \n <ect>
\t3 URI uri ; \n \n \t3 try { \n \n \t4 uri = new URI ( storageUrl ) ; \n \n \t3 } catch ( URISyntaxException e ) { \n \n <ect>
\t3 logger . info ( <string_literal> + entry . getKey ( ) + <string_literal> \n \n \t5 + entry . getValue ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public boolean run ( IndexDocument indexDocument ) { \n \n <ect>
\t5 stateTransferred = true ; \n \n \t4 } else { \n \n \t5 log . warn ( <string_literal> ) ; } } \n \n \t2 } catch ( ChannelException x ) { \n \n <ect>
\t2 if ( resultSet != null ) { \n \n \t3 try { \n \n \t4 resultSet . close ( ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t9 _log . warn ( _router . getFriendlyName ( ) + <string_literal> ) ; } } } \n \n \t5 if ( _log . shouldWarn ( ) ) { \n \n \t6 Service svc2 = current2 . getService ( WAN_IPV6_CONNECTION ) ; \n \n \t6 if ( svc2 != null ) \n \n <ect>
\t4 PipeTransportRenderer renderer = PipeTransportRenderer . RENDERER_MAP . get ( pipe . pipe . transport . getClass ( ) ) ; \n \n \t4 if ( renderer != null ) { \n \n \t5 renderer . render ( pipe . pipe , x , y , z , f ) ; } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testUndertow ( ) throws Exception { \n \n <ect>
\t2 Configuration conf ; \n \n \t2 try { \n \n \t3 conf = new XConfiguration ( new StringReader ( actionBean . getRunConf ( ) ) ) ; } \n \n \t2 catch ( IOException e1 ) { \n \n <ect>
\t6 + msg . getMessageType ( ) + <string_literal> + msg . getMessageId ( ) + <string_literal> + _context . routerHash ( ) . toBase64 ( ) . substring ( 0 , <number_literal> ) \n \n \t6 + <string_literal> + msg . getTarget ( ) . getIdentity ( ) . calculateHash ( ) . toBase64 ( ) . substring ( 0 , <number_literal> ) + <string_literal> + msg . toString ( ) ) ; } \n \n \t2 if ( sendSuccessful ) { \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 Date currentDate = new Date ( System . currentTimeMillis ( ) ) ; \n \n \t3 s_logger . debug ( <string_literal> + currentDate . toString ( ) ) ; \n \n \t3 _aggregationDuration = Integer . parseInt ( aggregationRange ) ; \n \n \t3 if ( _aggregationDuration < UsageUtils . USAGE_AGGREGATION_RANGE_MIN ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t3 if ( request . getHeaderNames ( ) . contains ( <string_literal> ) && f . addHandlers ( Channels . pipeline ( ) ) . get ( SoapHandler . class ) == null ) { \n \n \t3 continue ; <comment> \n \n \t3 } else if ( ! request . getHeaderNames ( ) . contains ( <string_literal> ) && f . addHandlers ( Channels . pipeline ( ) ) . get ( SoapHandler . class ) != null ) { \n \n \t3 continue ; <comment> \n \n <ect>
\t3 byte [ ] encoded = encoder . encode ( encrypted ) ; \n \n \t3 return new String ( encoded , CHARACTER_ENCODING ) ; } \n \n \t2 catch ( GeneralSecurityException e ) \n \n \t2 { \n \n <ect>
\t1 private < T , U extends CopyStrategy < T > > void registerCopyStrategy ( CopyStrategyLibrary copyStrategyLibrary , Class < T > type , Class < U > strategy ) { \n \n \t2 try { \n \n \t3 copyStrategyLibrary . register ( type , strategy . newInstance ( ) ) ; \n \n \t2 } catch ( InstantiationException | IllegalAccessException e ) { \n \n <ect>
\t1 if ( hookContext != null ) { \n \n \t2 try { \n \n \t2 invokeFailureHooks ( perfLogger , hookContext , errorMessage , e ) ; \n \n \t2 } catch ( Exception t ) { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> \n \n \t6 + <string_literal> , \n \n \t5 ticketGrantingTicketId , service ) ; \n \n \t4 return false ; } } \n \n <ect>
\t3 ) { \n \n \t3 if ( result__index . next ( ) ) { \n \n \t4 try ( PreparedStatement alterTable = conn . prepareStatement ( <string_literal> ) ; ) { \n \n \t5 alterTable . executeUpdate ( ) ; \n \n <ect>
\t1 auth = <string_literal> ; } \n \n \t1 for ( String param : auth . split ( <string_literal> ) ) { \n \n \t1 String [ ] keyvalue = param . split ( <string_literal> ) ; \n \n \t1 if ( keyvalue . length != <number_literal> ) { \n \n <ect>
\t2 while ( keepTrying ) { \n \n \t3 ContentObject segment = handle . get ( interest , remainingTime ) ; \n \n \t3 if ( null == segment ) { \n \n \t4 if ( Log . isLoggable ( Log . FAC_IO , Level . INFO ) ) \n \n <ect>
\t4 PasswordToken passwordToken = ( PasswordToken ) getAdminToken ( ) ; \n \n \t4 opts . setPassword ( new Password ( new String ( passwordToken . getPassword ( ) , UTF_8 ) ) ) ; } \n \n \t3 VerifyIngest . verifyIngest ( c , opts , new ScannerOpts ( ) ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 FileSystem fs = FileSystem . get ( conf ) ; \n \n \t1 r = new SequenceFile . Reader ( fs , new Path ( filename ) , conf ) ; \n \n \t1 Object key = ReflectionUtils . newInstance ( r . getKeyClass ( ) , conf ) ; \n \n \t1 Object val = ReflectionUtils . newInstance ( r . getValueClass ( ) , conf ) ; \n \n <ect>
\t3 Future < ? > fut = executor . submitIfRunning ( runnable , <string_literal> ) ; \n \n \t3 if ( ! fut . isCancelled ( ) ) \n \n \t4 futures . add ( fut ) ; } \n \n \t2 if ( nonEmptyTasks > 1 ) \n \n <ect>
\t4 throw new InvalidParameterValueException ( <string_literal> + templateId + <string_literal> ) ; } \n \n \t3 if ( template . isCrossZones ( ) ) { \n \n \t4 <comment> \n \n \t4 _tmpltSvr . syncTemplateToRegionStore ( templateId , srcSecStore ) ; \n \n <ect>
\t3 JsonArray jsonArray = new JsonParser ( ) . parse ( json ) . getAsJsonObject ( ) . get ( <string_literal> ) . getAsJsonArray ( ) ; \n \n \t3 for ( JsonElement jsonElement : jsonArray ) { \n \n \t4 languages . add ( jsonElement . toString ( ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( 0 ) ) ; \n \n \t3 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . failedShards ( ) , greaterThan ( 0 ) ) ; \n \n \t3 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , lessThan ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 volumes . add ( convertVolumeInfo ( volumeInfo ) ) ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t4 if ( initAnnotationType != null && method . isAnnotationPresent ( initAnnotationType ) ) { \n \n \t5 LifecycleElement element = new LifecycleElement ( method ) ; \n \n \t5 currInitMethods . add ( element ) ; \n \n \t5 if ( debug ) { \n \n <ect>
\t2 if ( isCompressed ) { \n \n \t3 try { \n \n \t4 strm = new CompressorStreamFactory ( ) . createCompressorInputStream ( fileStream ) ; \n \n \t3 } catch ( CompressorException e ) { \n \n <ect>
\t4 tx . rollback ( ) ; } \n \n \t3 catch ( GridException ex ) { \n \n \t4 U . error ( log , <string_literal> + tx , ex ) ; } \n \n <ect>
\t6 assert jobCtx != null ; \n \n \t6 log . info ( <string_literal> + rsrc1 ) ; \n \n \t6 log . info ( <string_literal> + rsrc2 ) ; \n \n \t6 log . info ( <string_literal> + rsrc3 ) ; \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 return microScheduler . execute ( this . walker , shardStrategy ) ; \n \n \t2 <comment> \n \n <ect>
\t4 public void remove ( ) { \n \n \t5 throw new UnsupportedOperationException ( <string_literal> ) ; } \n \n \t3 } ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 return editor ; } \n \n public DataContext getContext ( ) { \n \n \t1 return context ; } \n \n public void handleKey ( @ NotNull KeyStroke stroke ) { \n \n <ect>
\t3 <comment> \n \n \t3 PreparedStatement pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 pstmt . executeUpdate ( ) ; \n \n \t3 pstmt . close ( ) ; \n \n <ect>
\t5 . build ( ) ; \n \n \t4 <comment> \n \n \t4 this . surrogateEligibilityAuditableExecution . execute ( surrogateEligibleAudit ) ; \n \n \t4 return ; } \n \n <ect>
\t2 if ( closeable != null ) { \n \n \t3 try { \n \n \t4 closeable . close ( ) ; \n \n \t3 } catch ( JMSException e ) { \n \n <ect>
\t3 if ( storageVOs . size ( ) > 1 ) { \n \n \t4 s_logger . warn ( <string_literal> + snapId + <string_literal> + event . getAccountId ( ) + <string_literal> ) ; } \n \n \t3 for ( UsageStorageVO storageVO : storageVOs ) { \n \n <ect>
\t6 bf . log . warn ( <string_literal> + higher . key ( ) ) ; } \n \n \t3 } else { \n \n \t4 bf . log . info ( <string_literal> + i + <string_literal> ) ; \n \n \t4 if ( higher != null ) \n \n <ect>
\t7 @ Override \n \n \t7 public void run ( ) { \n \n \t8 try { \n \n \t9 if ( exception . get ( ) == null ) { \n \n <ect>
\t5 } else { \n \n \t6 logger . error ( <string_literal> , \n \n \t8 KEY_PARITY , parsedParityNumber , validParitiesMap . keySet ( ) ) ; } } \n \n \t3 } catch ( NumberFormatException e ) { \n \n <ect>
\t3 } else { \n \n \t4 LOG . info ( <string_literal> , logPrefix ( ) ) ; } \n \n \t2 } else if ( this . latestLeaderInfo . isValidLeader ( this . lockConfiguration . getPodName ( ) ) ) { \n \n \t3 <comment> \n \n <ect>
\t1 if ( str == null || str . isEmpty ( ) ) { \n \n \t1 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t1 String signature = getSignature ( str ) ; \n \n <ect>
\t2 try { \n \n \t3 return altVerifySigRaw ( signature , hash , verifyingKey ) ; \n \n \t2 } catch ( GeneralSecurityException gse ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 final Pattern pattern = RegexUtils . createPattern ( this . entityIds ) ; \n \n \t2 final Matcher matcher = pattern . matcher ( entityDescriptor . getEntityID ( ) ) ; \n \n \t2 LOGGER . debug ( <string_literal> , pattern . pattern ( ) , entityDescriptor . getEntityID ( ) ) ; \n \n \t2 final boolean matched = fullMatch ? matcher . matches ( ) : matcher . find ( ) ; \n \n <ect>
\t1 LOG . debug ( <string_literal> ) ; } \n \n @ Override \n \n public void start ( ) throws EucalyptusCloudException { \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n <ect>
\t1 private List < Integer > receivedHeaders = new ArrayList < Integer > ( getMessageCount ( ) ) ; \n \n \t1 private List < Object > receivedMessages = new ArrayList < Object > ( getMessageCount ( ) ) ; \n \n \t1 @ Test \n \n \t1 public void testSendingAndReceivingMessages ( ) throws Exception { \n \n <ect>
\t1 if ( launchConfigName != null ) { \n \n \t2 try { \n \n \t2 EucalyptusActivityTasks . getInstance ( ) . deleteLaunchConfiguration ( launchConfigName , lb . useSystemAccount ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 item = items . get ( i ) ; \n \n \t4 check = item . checkMCID ( pageref . getNumber ( ) , mcid . intValue ( ) ) ; \n \n \t4 switch ( check ) { \n \n \t4 case 1 : \n \n <ect>
\t1 } catch ( Exception e ) { \n \n \t2 synchronized ( openingTablets ) { \n \n \t2 openingTablets . remove ( extent ) ; \n \n \t2 openingTablets . notifyAll ( ) ; } \n \n <ect>
\t3 if ( key != null ) \n \n \t4 return lookupBase64 ( key ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n \t3 if ( _file . exists ( ) ) \n \n <ect>
\t7 obj . put ( changelog_val , _gson . toJson ( jsonObj . get ( <string_literal> ) ) ) ; \n \n \t7 list . add ( obj ) ; \n \n \t7 break ; \n \n \t6 default : \n \n <ect>
\t3 throw new SQLException ( <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 LOGGER . info ( <string_literal> , sql ) ; \n \n \t2 sql = this . connection . applyPreProcessors ( sql ) ; \n \n <ect>
\t2 int command = serialMessage . getMessagePayloadByte ( offset ) ; \n \n \t2 switch ( command ) { \n \n \t3 case HAIL : \n \n \t4 logger . trace ( <string_literal> ) ; \n \n <ect>
\t4 _newVersion = newVersion ; \n \n \t3 } else { \n \n \t4 updateStatus ( <string_literal> + _t ( <string_literal> , linkify ( url ) ) + <string_literal> ) ; \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 String file = files . get ( Collections . max ( files . keySet ( ) ) ) ; \n \n \t2 TarReader reader = openFirstFileWithValidIndex ( singletonList ( file ) , archiveManager ) ; \n \n \t2 if ( reader != null ) { \n \n \t3 return reader ; } \n \n <ect>
\t2 { \n \n \t3 sdp . setAttributes ( attributes ) ; } \n \n \t2 catch ( SdpException e ) \n \n \t2 { \n \n <ect>
\t3 if ( targetText == null ) { \n \n \t4 parsedArgs . targetTypes = TargetTypeHelper . parseLegacyCommandLineOptions ( script , doUpdate , parsedArgs . outputFile ) ; } \n \n \t3 else { \n \n \t4 if ( ! script || ! doUpdate ) { \n \n <ect>
\t4 <comment> \n \n \t4 return ; } } \n \n \t2 catch ( BadLocationException e ) \n \n \t2 { \n \n <ect>
\t4 n2 . getModelIds ( ) . add ( modelId ) ; \n \n \t3 } else { \n \n \t4 LabeledLink link = e . copy ( id ) ; \n \n \t4 if ( link == null ) { \n \n <ect>
\t5 String [ ] result = null ; \n \n \t5 try { \n \n \t6 s_logger . info ( <string_literal> + line ) ; \n \n \t6 result = parseLine ( line , <string_literal> ) ; \n \n <ect>
\t1 try { \n \n \t1 final Iterator < T > iterator = lookupProviders ( type ) ; \n \n \t1 for ( ; iterator . hasNext ( ) ; ) { \n \n \t2 final T provider = iterator . next ( ) ; \n \n <ect>
\t4 TaskBarList3 . getInstance ( ) . SetOverlayIcon ( \n \n \t5 ( Component ) mainWindow . getSource ( ) , img , null ) ; } \n \n \t3 catch ( Exception ex ) \n \n \t3 { \n \n <ect>
\t2 synchronized ( _stateLock ) { \t1 \n \n \t3 shouldSend = _state == State . OB_INIT ; } \n \n \t2 if ( shouldSend ) { \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t4 <string_literal> + <string_literal> + <string_literal> + \n \n \t4 <string_literal> + Stomp . NULL ; \n \n \t2 stompConnection . sendFrame ( frame ) ; \n \n \t2 receipt = stompConnection . receive ( ) ; \n \n <ect>
\t3 _context . statManager ( ) . addRateData ( <string_literal> , remaining , lifetime ) ; \n \n \t2 if ( removed > 0 ) \n \n \t3 _context . statManager ( ) . addRateData ( <string_literal> , removed , remaining ) ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 try { \n \n \t3 result = SshHelper . sshExecute ( router . getPrivateIpAddress ( ) , DEFAULT_DOMR_SSHPORT , <string_literal> , getSystemVMKeyFile ( ) , null , \n \n \t5 <string_literal> ) ; \n \n \t3 if ( ! result . first ( ) ) { \n \n <ect>
private String generateMigration ( Request request , Migration dbMigration , String dropsFor ) throws IOException { \n \n \t1 String fullVersion = getFullVersion ( request . migrationModel , dropsFor ) ; \n \n \t1 logger . info ( <string_literal> , fullVersion ) ; \n \n \t1 if ( ! writeMigrationXml ( dbMigration , request . modelDir , fullVersion ) ) { \n \n <ect>
\t4 setCurrentStage ( currentStage . getNextStage ( ) ) ; \n \n \t4 stageAdvanced = true ; \n \n \t4 <comment> \n \n \t4 retryTimer = BACKOFF_TIMER_START ; \n \n <ect>
\t3 throw lookupFailedException ( e , null ) ; } } \n \n \t1 @ Override \n \n \t1 public ExternalUser authenticate ( @ Nonnull Credentials credentials ) throws ExternalIdentityException , LoginException { \n \n \t2 if ( ! ( credentials instanceof SimpleCredentials ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 loginPage . login ( CHILD_USERNAME_1 , CHILD_PASSWORD_1 ) ; \n \n \t3 Assert . assertTrue ( loginPage . isCurrent ( PARENT_REALM ) ) ; \n \n \t3 loginPage . login ( PARENT_USERNAME , PARENT_PASSWORD ) ; \n \n <ect>
\t5 streamGenerator . writeTo ( output , context ) ; \n \n \t5 <comment> \n \n \t5 output . close ( ) ; output = null ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 for ( int i = 0 ; i < pollNum ; i ++ ) { \n \n \t4 Integer e = queue . poll ( ) ; \n \n \t4 if ( atomicityMode ( ) == ATOMIC ) { \n \n \t5 if ( e == null || e != exp ) { \n \n <ect>
\t1 private QueryIteratorCheck ( QueryIterator qIter , ExecutionContext execCxt ) \n \n \t1 { \n \n \t2 super ( qIter ) ; \n \n \t2 if ( qIter instanceof QueryIteratorCheck ) \n \n <ect>
\t2 try { \n \n \t3 if ( resource != null ) { \n \n \t4 resource . close ( ) ; } \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t4 try { \n \n \t5 objectName = createJmxObjectName ( entry . key , entry . value ) \n \n \t5 doRegister ( entry . value . pool . jmxPool , objectName ) \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t5 log . debug ( <string_literal> + candidate [ i ] ) ; \n \n \t5 log . debug ( <string_literal> + netmask [ i ] ) ; \n \n \t5 log . debug ( <string_literal> + ( candidate [ i ] & netmask [ i ] ) ) ; \n \n \t5 log . debug ( <string_literal> + network [ i ] ) ; \n \n <ect>
\t3 LOG . debug ( <string_literal> + i ) ; \n \n \t3 Thread . sleep ( <number_literal> ) ; } \n \n \t2 fos . flush ( ) ; \n \n \t2 fos . close ( ) ; \n \n <ect>
\t3 try { \n \n \t4 return altSignSHA1 ( data , offset , length , signingKey ) ; \n \n \t3 } catch ( GeneralSecurityException gse ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 } else { \n \n \t4 ( ( DMNModelImpl ) model ) . setResource ( resource ) ; \n \n \t4 return model ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 if ( authAllowed && oboAllowed ) { \n \n \t5 allowed . add ( comm ) ; } } \n \n \t3 return allowed ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t3 long estimatedTotalKeys = Math . max ( cfs . metadata . getMinIndexInterval ( ) , SSTableReader . getApproximateKeyCount ( actuallyCompact ) ) ; \n \n \t3 long estimatedSSTables = Math . max ( 1 , cfs . getExpectedCompactedFileSize ( actuallyCompact , compactionType ) / strategy . getMaxSSTableBytes ( ) ) ; \n \n \t3 long keysPerSSTable = ( long ) Math . ceil ( ( double ) estimatedTotalKeys / estimatedSSTables ) ; \n \n \t3 long expectedSSTableSize = Math . min ( getExpectedWriteSize ( ) , strategy . getMaxSSTableBytes ( ) ) ; \n \n <ect>
\t4 String . format ( <string_literal> , _tftpDir , cmd . getMac ( ) , kernelPath , initrdPath , cmd . getKsFile ( ) , \n \n \t5 cmd . getMac ( ) ) ; \n \n \t3 if ( ! SSHCmdHelper . sshExecuteCmd ( sshConnection , script ) ) { \n \n \t4 return new Answer ( cmd , false , <string_literal> + _ip + <string_literal> + script ) ; } \n \n <ect>
\t5 return environments . get ( SHARED_ENV_KEY ) ; \n \n \t4 File bdbDir = new File ( bdbMasterDir ) ; \n \n \t4 createBdbDirIfNecessary ( bdbDir ) ; \n \n \t4 Environment environment = new Environment ( bdbDir , environmentConfig ) ; \n \n <ect>
\t2 eventMsg . setDescription ( eventDescription ) ; \n \n \t2 try { \n \n \t3 s_eventBus . publish ( eventMsg ) ; \n \n \t2 } catch ( EventBusException e ) { \n \n <ect>
\t4 LOGGER . trace ( <string_literal> , e ) ; \n \n \t4 return false ; } } \n \n \t2 if ( ! ( permissions . isBrowsable ( ) && permissions . isWritable ( ) && permissions . isFolder ( ) ) ) { \n \n \t3 if ( ! permissions . isFolder ( ) ) { \n \n <ect>
\t1 if ( zooKeeperClient . checkExists ( ) . forPath ( znodePath ) == null ) { \n \n \t2 <comment> \n \n \t2 throw new Exception ( <string_literal> ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 <comment> \n \n \t4 fileContents = newContents ; } \n \n \t3 return testMatrix ; \n \n \t2 } catch ( @ Nonnull final JsonParseException e ) { \n \n <ect>
\t2 if ( this . request . isUpdateLinksOnFarm ( ) ) { \n \n \t3 try { \n \n \t4 wikiIds = this . wikiDescriptorManager . getAllIds ( ) ; \n \n \t3 } catch ( WikiManagerException e ) { \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t2 roi . drain ( <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 } else { \n \n \t5 <comment> \n \n \t5 unsafe = null ; \n \n \t5 unsafeUnavailabilityCause = ( Throwable ) maybeException ; \n \n <ect>
\t2 then = state . getCreated ( ) ; } \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 if ( now - then > maxage ) { \n \n <ect>
\t3 syntax = FileUtils . guessLang ( mappedURI ) ; \n \n \t3 if ( syntax == null || syntax . equals ( <string_literal> ) ) \n \n \t4 syntax = FileUtils . langXML ; \n \n <ect>
\t4 try { \n \n \t5 Long dcId = Long . parseLong ( tokenOrIdOrName ) ; \n \n \t5 return findById ( dcId ) ; \n \n \t4 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t3 if ( ! startVpc ( vpcId , false ) ) { \n \n \t4 s_logger . warn ( <string_literal> + vpc + <string_literal> ) ; \n \n \t4 restartRequired = true ; \n \n \t4 return false ; } \n \n <ect>
\t2 if ( stateOperator instanceof Closeable ) \n \n \t3 try { \n \n \t4 ( ( Closeable ) stateOperator ) . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 mBeanServer . registerMBean ( hikariPool , beanPoolName ) ; } \n \n \t2 else { \n \n \t3 LOGGER . error ( <string_literal> , poolName , poolName ) ; } } \n \n \t1 catch ( Exception e ) { \n \n <ect>
\t1 public Label getUriLabel ( String uri ) { \n \n \t2 return getResourceLabel ( ontModel . getResource ( uri ) ) ; } \n \n \t1 public Label getResourceLabel ( Resource r ) { \n \n \t2 if ( r == null || ! ontModel . containsResource ( r ) ) { \n \n <ect>
\t3 loadData ( false ) ; \n \n \t3 if ( this . nKeys > 0 ) \n \n \t4 this . firstKey = this . keys [ 0 ] ; \n \n \t3 flush ( ) ; \n \n <ect>
\t4 } catch ( RuntimeException e ) { \n \n \t5 logger . warn ( e . getMessage ( ) ) ; } \n \n \t3 } ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t6 LOG . error ( <string_literal> , e ) ; \n \n \t6 <comment> \n \n \t6 JStormUtils . halt_process ( <number_literal> , <string_literal> + e . getMessage ( ) ) ; } } \n \n \t3 } ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t2 throw new RuntimeException ( <string_literal> ) ; } \n \n \t1 txn . commit ( ) ; \n \n \t1 } finally { \n \n \t1 txn . end ( ) ; \n \n <ect>
\t2 SSLContext context = SSLContext . getInstance ( <string_literal> ) ; \n \n \t2 CertChainCatcher catcher = new CertChainCatcher ( ) ; \n \n \t2 context . init ( null , new TrustManager [ ] { catcher } , null ) ; \n \n \t2 SSLSocketFactory factory = context . getSocketFactory ( ) ; \n \n <ect>
\t2 Object [ ] params = { componentName , properties , completionText } ; \n \n \t2 String [ ] signature = { <string_literal> , <string_literal> , <string_literal> } ; \n \n \t2 List < ? > completions = assertIsInstanceOf ( List . class , \n \n \t4 mbeanServer . invoke ( on , <string_literal> , params , signature ) ) ; \n \n <ect>
\t2 final AuditableExecutionResult result = delegatedAuthenticationPolicyEnforcer . execute ( context ) ; \n \n \t2 if ( ! result . isExecutionFailure ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , registeredService , client ) ; \n \n \t3 return true ; } \n \n <ect>
\t3 { \n \n \t4 discardFolder = store . getFolder ( discardFolderName ) ; \n \n \t4 if ( ! discardFolder . exists ( ) ) \n \n \t4 { \n \n <ect>
\t1 public void run ( ) { \n \n \t1 try { \n \n \t2 MuleContainer . this . stop ( ) ; \n \n \t1 } catch ( MuleException e ) { \n \n <ect>
\t4 return responseCode ; } } \n \n \t2 <comment> \n \n \t2 { \n \n \t3 url = server + <string_literal> + s_newVolume . get ( ) + <string_literal> + s_linuxVmId . get ( ) ; \n \n <ect>
\t2 logShardStates ( clusterState ) ; \n \n \t2 <comment> \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( 1 ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( 1 ) ) ; \n \n <ect>
\t3 <comment> \n \n \t3 if ( cacheOnly ) { \n \n \t4 <comment> \n \n <ect>
\t1 if ( keyPairApi . isPresent ( ) ) { \n \n \t2 for ( String group : groups ) { \n \n \t3 for ( KeyPair pair : keyPairApi . get ( ) . list ( ) . filter ( nameMatches ( namingConvention . create ( ) . containsGroup ( group ) ) ) ) { \n \n \t3 ZoneAndName zoneAndName = ZoneAndName . fromZoneAndName ( zoneId , pair . getName ( ) ) ; \n \n <ect>
\t4 try { \n \n \t5 File thumbDir = new File ( configuration . getTempFolder ( ) , THUMBNAIL_DIRECTORY_NAME ) ; \n \n \t5 logger . trace ( <string_literal> , inputFile . getFile ( ) . getAbsolutePath ( ) ) ; \n \n \t5 if ( ! thumbDir . exists ( ) && ! thumbDir . mkdirs ( ) ) { \n \n <ect>
\t4 } else { \n \n \t5 printWriter . println ( entry . getKey ( ) + <string_literal> + entry . getValue ( ) ) ; } } \n \n \t3 printWriter . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 protected Set < Event > resolveEventsInternal ( final Set < Event > resolveEvents , final Authentication authentication , final RegisteredService registeredService , \n \n <number_literal> final HttpServletRequest request , final RequestContext context ) { \n \n <ect>
\t3 handleException ( ex ) ; } } \n \n \t1 protected void replayGame ( UUID gameId ) { \n \n \t2 try { \n \n \t3 frame . replayGame ( gameId ) ; \n \n <ect>
\t7 bytesSentAndReceived [ 0 ] = 0 ; } } \n \n \t4 } else { \n \n \t5 bytesSentAndReceived = answer . ipBytes . get ( publicIp ) ; } \n \n \t4 if ( bytesSentAndReceived == null ) { \n \n <ect>
private void loadServiceConfigTypes ( ) throws AmbariException { \n \n \t1 try { \n \n \t1 serviceConfigTypes = collectServiceConfigTypesMapping ( ) ; \n \n \t1 } catch ( AmbariException e ) { \n \n <ect>
\t3 if ( portSettings == DSMRPortSettings . HIGH_SPEED_SETTINGS ) { \n \n \t4 portSettings = DSMRPortSettings . LOW_SPEED_SETTINGS ; \n \n \t3 } else { \n \n \t4 portSettings = DSMRPortSettings . HIGH_SPEED_SETTINGS ; } \n \n <ect>
\t1 @ Autowired \n \n \t1 private CasConfigurationProperties casProperties ; \n \n \t1 @ Override \n \n \t1 public void configureTicketCatalog ( final TicketCatalog plan ) { \n \n <ect>
\t2 this . encryptionEnabled = encryptionEnabled ; \n \n \t2 if ( this . encryptionEnabled ) { \n \n \t3 configureEncryptionParameters ( secretKeyEncryption , contentEncryptionAlgorithmIdentifier ) ; \n \n \t2 } else { \n \n <ect>
\t4 owner = new Owner ( ( Address ) req . object , req . request ) ; \n \n \t4 handleRemoveRunRequest ( owner ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t1 private static final Logger log = Logger . create ( Parser ) \n \n \t1 private final Parsing delegate \n \n \t1 Parser ( ) { \n \n \t2 String flavor = Preferences . getParserFlavor ( ) \n \n <ect>
\t3 isRO = bbia . readBool ( <string_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
<comment> \n \n \t1 public void refreshAuthenticatedUser ( ) { \n \n <ect>
\t2 if ( ( isConnected ( ) ) && ( ! isUpToDate ( ) ) ) { \n \n \t2 throw new EucalyptusCloudException ( <string_literal> ) ; } \n \n \t2 if ( Component . State . DISABLED . equals ( Components . lookup ( WalrusBackend . class ) . getState ( ) ) ) { \n \n \t2 if ( ! isSecondary ( ) ) { \n \n <ect>
\t3 String phonStr = null ; \n \n \t3 try { \n \n \t4 phonStr = lineParts [ 1 ] ; \n \n \t3 } catch ( ArrayIndexOutOfBoundsException e ) { \n \n <ect>
\t4 } else { \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t5 return new StringType ( valueStr ) ; } \n \n \t3 } catch ( ItemNotFoundException e ) { \n \n <ect>
\t2 String value = _configDao . getValue ( Config . ConsoleProxyManagementState . key ( ) ) ; \n \n \t2 if ( value != null ) { \n \n \t3 ConsoleProxyManagementState state = ConsoleProxyManagementState . valueOf ( value ) ; \n \n \t3 if ( state == null ) { \n \n <ect>
\t2 final List < RegisteredService > services = new ArrayList < > ( ) ; \n \n \t2 final ScanRequest scan = new ScanRequest ( dynamoDbProperties . getTableName ( ) ) ; \n \n \t2 LOGGER . debug ( <string_literal> , scan ) ; \n \n \t2 final ScanResult result = this . amazonDynamoDBClient . scan ( scan ) ; \n \n <ect>
\t5 rv = SessionStatusMessage . STATUS_REFUSED ; } } } \n \n \t2 if ( rv == SessionStatusMessage . STATUS_INVALID ) { \n \n \t3 _log . log ( Log . CRIT , <string_literal> + dest . toBase32 ( ) ) ; \n \n \t2 } else if ( rv == SessionStatusMessage . STATUS_REFUSED ) { \n \n <ect>
\t3 response . setResponseName ( getCommandName ( ) ) ; \n \n \t3 response . setObjectName ( <string_literal> ) ; \n \n \t3 this . setResponseObject ( response ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 if ( isInheritedExtensionService ( stackManager , stack , service . getName ( ) , extension . getName ( ) ) ) { \n \n \t3 stackService = null ; } } } \n \n \t2 catch ( Exception e ) { \n \n \t2 <comment> \n \n <ect>
\t2 CacheControl cacheControl = lookupCacheControl ( lookupPath ) ; \n \n \t2 Integer cacheSeconds = lookupCacheSeconds ( lookupPath ) ; \n \n \t2 if ( cacheControl != null ) { \n \n <ect>
\t3 info = makeInfo ( c ) ; \n \n \t3 map . put ( productVersion , info ) ; } \n \n \t2 return info ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 if ( causeOfDeath != null ) { \n \n \t3 List < Obs > obssDeath = Context . getObsService ( ) . getObservationsByPersonAndConcept ( patient , causeOfDeath ) ; \n \n \t3 if ( obssDeath != null ) { \n \n \t4 if ( obssDeath . size ( ) > 1 ) { \n \n <ect>
\t5 log . error ( <string_literal> , segmentToRetry . getUuid ( ) , e . getCause ( ) ) ; \n \n \t5 try { \n \n \t6 Thread . sleep ( <number_literal> ) ; \n \n \t5 } catch ( InterruptedException e1 ) { \n \n <ect>
\t3 ret = 1 \n \n \t3 self . logger . error ( <string_literal> . \n \n \t7 format ( self ) ) \n \n \t3 indent = <string_literal> \n \n <ect>
\t2 final TKeyExtent textent ) { \n \n \t1 try { \n \n \t2 checkPermission ( credentials , lock , <string_literal> ) ; \n \n \t1 } catch ( ThriftSecurityException e ) { \n \n <ect>
\t2 return answer ; } \n \n \t1 @ Override \n \n \t1 public PrimaryStorageDownloadAnswer execute ( PrimaryStorageDownloadCommand cmd ) { \n \n <ect>
\t3 snmp = new Snmp ( transport ) ; \n \n \t3 transport . listen ( ) ; \n \n \t3 logger . debug ( <string_literal> + address ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t3 if ( securityConfiguration . getSecurityAuthenticator ( ) == null ) { \n \n \t4 <comment> \n \n \t4 JAASSecurityAuthenticator jaas = new JAASSecurityAuthenticator ( ) ; \n \n \t4 jaas . setName ( securityConfiguration . getRealm ( ) ) ; \n \n <ect>
\t1 @ Consumes ( MediaType . APPLICATION_FORM_URLENCODED ) \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public Response JSON ( MultivaluedMap < String , String > formParams ) { \n \n \t2 try { \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public long getIdleConnectionTestPeriod ( ) { \n \n <ect>
\t4 this . weakRegionDFS ( this . m_blockCFG . getTails ( ) . get ( 0 ) , this . m_regCount ) ; } \n \n \t3 else \n \n \t3 { \n \n \t4 if ( Options . v ( ) . verbose ( ) ) \n \n <ect>
\t2 Map < String , String > configs = _configDao . getConfiguration ( <string_literal> , params ) ; \n \n \t2 _storagePoolAcquisitionWaitSeconds = NumbersUtil . parseInt ( configs . get ( <string_literal> ) , <number_literal> ) ; \n \n \t2 s_logger . info ( <string_literal> + _storagePoolAcquisitionWaitSeconds + <string_literal> ) ; \n \n \t2 _agentMgr . registerForHostEvents ( new StoragePoolMonitor ( this , _storagePoolDao , _dataStoreProviderMgr ) , true , false , true ) ; \n \n <ect>
\t1 <comment> \n \n \t1 VectorReduceSinkDesc . ReduceSinkKeyType reduceSinkKeyType = VectorReduceSinkDesc . ReduceSinkKeyType . MULTI_KEY ; \n \n \t1 <comment> \n \n \t1 if ( reduceSinkKeyColumnVectorTypes != null && reduceSinkKeyColumnVectorTypes . length == 1 ) { \n \n <ect>
\t4 InputStream is = method . getResponseBodyAsStream ( ) ; \n \n \t4 Map < String , String > values = getSingleValueFromXML ( is , \n \n \t6 new String [ ] { <string_literal> } ) ; \n \n \t4 if ( values . get ( <string_literal> ) == null ) { \n \n <ect>
\t4 status . status = AttemptStatus . PROCESSED ; \n \n \t3 } else if ( status . status == AttemptStatus . COMMITTING ) { \n \n \t4 _activeTx . remove ( tx . getTransactionId ( ) ) ; \n \n \t4 _attemptIds . remove ( tx . getTransactionId ( ) ) ; \n \n <ect>
\t1 { \n \n \t2 @ Override \n \n \t2 public void onError ( Throwable e ) \n \n \t2 { \n \n <ect>
\t1 sanSnapshot = lookup ( snapshotId ) ; \n \n \t1 sanSnapshotId = sanSnapshot . getSanVolumeId ( ) ; \n \n \t1 iqn = sanSnapshot . getIqn ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 public void verifyHammer ( long start , HammerThread [ ] threads , int childCount ) \n \n \t2 throws IOException , InterruptedException , KeeperException \n \n \t1 { \n \n \t2 <comment> \n \n <ect>
\t2 <comment> \n \n \t2 if ( caCertCrt . exists ( ) && caCertCrt . canRead ( ) ) { \n \n \t3 FileUtils . copyFile ( caCertCrt , caCertUsr ) ; \t3 \n \n \t2 } else { \n \n <ect>
\t1 VectorizedRowBatch batch = ( VectorizedRowBatch ) row ; \n \n \t1 batchCounter ++ ; \n \n \t1 if ( batch . size == 0 ) { \n \n <ect>
\t3 return Byte . parseByte ( substringBefore ( value , <string_literal> ) ) ; \n \n \t2 } catch ( NumberFormatException ex ) { \n \n \t3 <comment> \n \n \t3 LOGGER . warn ( <string_literal> , value ) ; \n \n <ect>
\t1 if ( headerValueSpillStmt != null ) { \n \n \t2 try { \n \n \t2 headerValueSpillStmt . close ( ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t4 throw new InvalidParameterValueException ( <string_literal> ) ; } \n \n \t3 s_logger . debug ( <string_literal> + elbVm ) ; \n \n \t3 return elbVm ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t4 <comment> \n \n \t4 long id = rs . getLong ( 1 ) ; <comment> \n \n \t4 result . add ( findById ( id ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bc ) throws Exception { \n \n <ect>
\t1 public void testInjected ( ) throws Exception { \n \n \t2 s_logger . info ( <string_literal> ) ; \n \n \t2 archiveEvents ( ) ; \n \n \t2 deleteEvents ( ) ; \n \n <ect>
\t3 new HashMap < String , Map > ( ) ; \n \n \t2 for ( int i = 0 ; i < servers . length ; i ++ ) { \n \n \t3 SockIOPool . SockIO sock = pool . getConnection ( servers [ i ] ) ; \n \n \t3 if ( sock == null ) { \n \n <ect>
\t7 <string_literal> + \n \n \t8 <string_literal> , \n \n \t7 sse ) ; \n \n \t5 } catch ( SQLException | IOException e ) { \n \n <ect>
\t3 try { \n \n \t4 SkipList < String , DestEntry > sl = _bf . getIndex ( listname , _stringSerializer , _destSerializer ) ; \n \n \t4 if ( sl == null ) { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 this . pool . releaseConnection ( handle ) ; \n \n \t4 } catch ( SQLException e ) { \n \n \t5 logger . error ( <string_literal> , e ) ; } } } \n \n \t2 if ( this . warnApp . compareAndSet ( false , true ) ) { <comment> \n \n <ect>
\t6 Map . Entry < ? , ? > me = ( Map . Entry < ? , ? > ) it . next ( ) ; \n \n \t6 String key = ( String ) me . getKey ( ) ; \n \n \t6 String value = ( String ) me . getValue ( ) ; \n \n \t6 if ( value == null ) { \n \n <ect>
\t1 char [ ] result = null ; \n \n \t1 try { \n \n \t1 result = hadoopConfiguration . getPassword ( key ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 mappings . offer ( updated ) ; \n \n \t4 cur = updated ; } } \n \n \t2 if ( isDone ( ) ) { \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t4 e . printStackTrace ( ) ; } } } \n \n \t1 @ Test \n \n \t1 public void testLENewEpoch ( ) throws Exception { \n \n <ect>
\t3 eventContainer . getEventList ( ) . add ( calDavEvent ) ; \n \n \t3 eventContainer . setLastChanged ( calDavEvent . getLastChanged ( ) ) ; \n \n \t3 this . addEventToMap ( eventContainer , false ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t3 DbUpgradeUtils . dropKeysIfExist ( conn , tableName , indexes . get ( tableName ) , false ) ; } } \n \n \t1 private void addMissingKeys ( Connection conn ) { \n \n \t2 PreparedStatement pstmt = null ; \n \n \t2 try { \n \n <ect>
\t3 for ( final ResourceAccess access : app . nodeQuery ( ResourceAccess . class ) . getAsList ( ) ) { \n \n \t4 app . delete ( access ) ; } \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException t ) { \n \n <ect>
\t3 int len = Math . min ( entity . length ( ) , <number_literal> ) ; \n \n \t3 logger . info ( <string_literal> + entity . substring ( 0 , len ) + <string_literal> ) ; \n \n \t3 Assert . assertEquals ( <string_literal> foo \\ <string_literal> , <number_literal> , countFoos ( entity ) ) ; } } \n \n \t1 void doMaxAttributesFails ( String ext ) throws Exception { \n \n <ect>
\t1 String passwd = conf . getVar ( HiveConf . ConfVars . HIVE_SERVER2_THRIFT_CLIENT_PASSWORD ) ; \n \n \t1 try { \n \n \t1 transport = PlainSaslHelper . getPlainTransport ( userName , passwd , transport ) ; \n \n \t1 } catch ( SaslException e ) { \n \n <ect>
\t6 <comment> \n \n \t6 name = StringUtils . startsWithIgnoreCase ( name , this . userDefinedHeaderPrefix ) ? name : \n \n \t8 this . userDefinedHeaderPrefix + name ; } \n \n <ect>
\t1 @ DB \n \n \t1 public void createVolumeOnFiler ( String ipAddress , String aggName , String poolName , String volName , String volSize , String snapshotPolicy , Integer snapshotReservation , String username , String password ) throws UnknownHostException , ServerException , InvalidParameterValueException \n \n \t1 { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t4 _recvBps15s = ( 0 . 955f ) * _recvBps15s + ( 0 . 045f ) * ( ( float ) recv * <number_literal> ) / time ; \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t4 logger . error ( <string_literal> ) ; } } \n \n \t2 if ( StringUtils . isNotBlank ( ( String ) config . get ( <string_literal> ) ) ) { \n \n \t3 try { \n \n \t4 isSUC = Boolean . parseBoolean ( ( String ) config . get ( <string_literal> ) ) ; \n \n <ect>
\t8 { \n \n \t9 destVolumeObjectTO . path += <string_literal> + destVolumeObjectTO . format . ToLower ( ) ; } } \n \n \t7 else \n \n \t7 { \n \n <ect>
\t2 assertEquals ( mFired \t1 , mb . getStatsForRule ( ruleName ) . getMatchesFired ( ) \t1 ) ; } \n \n \t1 private void print ( GenericKieSessionMonitoringMXBean mb ) { \n \n \t2 LOG . debug ( <string_literal> , mb . getTotalMatchesCreated ( ) ) ; \n \n \t2 LOG . debug ( <string_literal> , mb . getTotalMatchesCancelled ( ) ) ; \n \n <ect>
\t3 } catch ( I2NPMessageException ime ) { \n \n \t4 throw ime ; \n \n \t3 } catch ( RuntimeException e ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 <comment> \n \n \t5 scaleIndex | = ( ( serialMessage . getMessagePayloadByte ( offset + 1 ) & 0x80 ) > > 0x05 ) ; } \n \n \t4 scale = MeterScale . getMeterScale ( meterType , scaleIndex ) ; \n \n \t4 if ( scale == null ) { \n \n <ect>
\t2 throw new AndroidDeviceException ( <string_literal> + getAvdName ( ) \n \n \t3 + <string_literal> + ( System . currentTimeMillis ( ) - start ) / <number_literal> \n \n \t3 + <string_literal> ) ; } } \n \n \t1 log . info ( <string_literal> + ( System . currentTimeMillis ( ) - start ) / <number_literal> + <string_literal> ) ; \n \n <ect>
\t5 log . debug ( <string_literal> + candidate [ i ] ) ; \n \n \t5 log . debug ( <string_literal> + netmask [ i ] ) ; \n \n \t5 log . debug ( <string_literal> + ( candidate [ i ] & netmask [ i ] ) ) ; \n \n <ect>
\t9 + ( node == null ? <string_literal> : node . getHost ( ) ) + <string_literal> ) ; \n \n \t5 pipeline . addEvent ( completeEvent ) ; } } \n \n \t2 } else { \n \n <ect>
\t3 store . getKey ( ) . stop ( ) ; \n \n \t3 store . getValue ( ) . stop ( ) ; \n \n \t3 it . remove ( ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 if ( block != null ) { \n \n \t5 nodeStats . avgClientCacheSSKSuccess . report ( loc ) ; \n \n \t5 if ( dist > nodeStats . furthestClientCacheSSKSuccess ) \n \n \t5 nodeStats . furthestClientCacheSSKSuccess = dist ; \n \n <ect>
\t1 return true ; } \n \n @ NotNull \n \n public String executeCommand ( @ NotNull String command , @ Nullable CharSequence input ) throws IOException { \n \n <ect>
\t3 if ( inputStream != null ) { \n \n \t4 try { \n \n \t5 inputStream . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t4 while ( this . isRunning ( ) ) { \n \n \t5 readPacket ( qp ) ; \n \n \t5 processPacket ( qp ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 <comment> \n \n \t5 <comment> \n \n \t5 <comment> \n \n \t5 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 && ! StatsUtil . getStorageFilteredUsers ( context ) . contains ( \n \n \t5 this . currentDocumentReferenceResolver . resolve ( context . getUser ( ) ) ) ) { \n \n \t4 this . statsRegister . addStats ( document , action , context ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t10 problemList . add ( ErrorDispatcher . createJavacError \n \n <number_literal> ( name , pageNodes , new StringBuilder ( problem . getMessage ( ) ) , \n \n <number_literal> problem . getSourceLineNumber ( ) , ctxt ) ) ; \n \n \t9 } catch ( JasperException e ) { \n \n <ect>
<comment> \n \n \t5 switch ( n . state ) { \n \n \t5 case LOOKING : \n \n \t6 if ( getInitLastLoggedZxid ( ) == - 1 ) { \n \n <ect>
\t2 CompoundVariable function = new CompoundVariable ( functionCall . toString ( ) ) ; \n \n \t2 try { \n \n \t3 resultTextArea . setText ( function . execute ( ) . trim ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 InputStream is = method . getResponseBodyAsStream ( ) ; \n \n \t3 Map < String , String > userIdValues = getSingleValueFromXML ( is , \n \n \t5 new String [ ] { <string_literal> , <string_literal> } ) ; \n \n \t3 String userIdStr = userIdValues . get ( <string_literal> ) ; \n \n <ect>
\t3 LOG . error ( <string_literal> ) ; \n \n \t3 LOG . error ( <string_literal> + ase . getErrorCode ( ) ) ; \n \n \t3 LOG . error ( <string_literal> + ase . getErrorMessage ( ) , ase ) ; \n \n \t2 } catch ( AmazonClientException ace ) { \n \n <ect>
\t1 if ( containsType ( t , DeploymentStartException . class ) ) { \n \n \t1 logger . error ( miniSplash ( format ( <string_literal> , artifactName ) ) ) ; \n \n \t1 logger . error ( t . getMessage ( ) ) ; \n \n \t1 } else { \n \n <ect>
\t1 try { \n \n \t1 sanVolume = lookup ( volumeId ) ; \n \n \t1 sanVolumeId = sanVolume . getSanVolumeId ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 Class < ? > clazz = Utils . loadClass ( passwordCallbackClassName ) ; \n \n \t2 if ( clazz != null ) { \n \n \t3 this . passwordCallback = ( PasswordCallback ) clazz . newInstance ( ) ; \n \n \t2 } else { \n \n <ect>
\t5 Map < Object , Object > map = ( Map < Object , Object > ) value ; \n \n \t5 for ( Entry < Object , Object > entry : map . entrySet ( ) ) { \n \n \t6 properties . put ( newPrefix + entry . getKey ( ) , entry . getValue ( ) . toString ( ) ) ; } } \n \n \t4 else { \n \n <ect>
<number_literal> this , \n \n <number_literal> this . properties ) ; \n \n \t3 } catch ( Throwable e ) { \n \n \t4 <comment> \n \n <ect>
\t3 } else { \n \n \t4 EventHelper . notifyExchangeDone ( exchange . getContext ( ) , exchange ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n \t3 <comment> \n \n <ect>
\t4 } catch ( Exception e ) { \n \n \t5 getExceptionHandler ( ) . handleException ( <string_literal> , exchange , e ) ; } \n \n \t3 } else { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 LOGGER . debug ( <string_literal> , this . warnUnregisteredClasses ) ; \n \n \t2 LOGGER . debug ( <string_literal> , this . autoReset ) ; \n \n \t2 LOGGER . debug ( <string_literal> , this . replaceObjectsByReferences ) ; \n \n <ect>
\t5 if ( translate != null ) { \n \n \t6 list . add ( translate ) ; } \n \n \t4 } else { \n \n \t5 <comment> \n \n <ect>
\t4 try { \n \n \t5 serverSocket = new ServerSocket ( port ) ; \n \n \t4 } catch ( IOException ioex ) { \n \n \t5 throw new CloudRuntimeException ( <string_literal> , ioex ) ; } \n \n <ect>
\t2 File geoFile = new File ( context . getBaseDir ( ) , GEOIP_DIR_DEFAULT ) ; \n \n \t2 geoFile = new File ( geoFile , GEOIP_FILE_DEFAULT ) ; \n \n \t2 if ( ! geoFile . exists ( ) ) { \n \n \t3 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 public NSMutableDictionary currentErrorDictionary ( ) { \n \n \t2 Object key = d2wContext ( ) . valueForKeyPath ( <string_literal> ) ; \n \n \t2 if ( errorMessagesDictionaries ( ) . objectForKey ( key ) == null ) { \n \n \t3 errorMessagesDictionaries ( ) . setObjectForKey ( new NSMutableDictionary ( ) , key ) ; } \n \n <ect>
\t4 cms . writeUser ( user ) ; \n \n \t4 afterWrite . run ( ) ; } \n \n \t2 } catch ( CmsException | CommitException | IllegalAccessException | InvocationTargetException \n \n \t2 | NoSuchMethodException e ) { \n \n <ect>
\t1 public class RelayRequestReader extends Reader { \n \n \t2 public long readTag ( ) { \n \n \t3 long rv = DataHelper . fromLong ( _message , readBodyOffset ( ) , <number_literal> ) ; \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t4 for ( int i = 0 ; i < componentParams . size ( ) ; ++ i ) { \n \n \t5 params [ i + <number_literal> ] = entity . getComponent ( componentParams . get ( i ) ) ; } \n \n \t4 method . invoke ( handler , params ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t5 localBrokerInfo = ( BrokerInfo ) command ; \n \n \t5 localBrokerId = localBrokerInfo . getBrokerId ( ) ; \n \n \t5 if ( remoteBrokerId != null ) { \n \n \t6 if ( remoteBrokerId . equals ( localBrokerId ) ) { \n \n <ect>
\t5 dd . addDependencyConfiguration ( conf , substitute ( attributes . getValue ( <string_literal> ) ) ) ; \n \n \t4 } else if ( ( <string_literal> . equals ( qName ) && state == State . DEPS ) || <string_literal> . equals ( qName ) && state == State . CONFLICT ) { \n \n \t5 LOGGER . debug ( <string_literal> , getResource ( ) . getDisplayName ( ) ) ; \n \n \t4 } else if ( <string_literal> . equals ( qName ) && state == State . DEPS ) { \n \n <ect>
\t7 details = <string_literal> ; \n \n \t7 break ; } } } \n \n \t4 catch ( Exception e ) \n \n \t4 { \n \n <ect>
\t5 consume ( tokens , dataType , true , L_PAREN ) ; \n \n \t5 consume ( tokens , dataType , true ) ; \n \n \t5 consume ( tokens , dataType , true , R_PAREN ) ; \n \n \t4 } else { \n \n <ect>
\t3 this . fsRoot = Paths . get ( rootPath ) ; \n \n \t3 FileSystemEmitterConfiguration . getGroup ( ) ; \n \n \t3 isEnabled = true ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t3 FileUtils . writeStringToFile ( file , errMsg , true ) ; \n \n \t3 FileUtils . writeStringToFile ( file , <string_literal> , true ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 <comment> \n \n <ect>
\t2 final AuthenticationBuilder authenticationBuilder = DefaultAuthenticationBuilder . newInstance ( ) ; \n \n \t2 buildAuthenticationHistory ( this . authentications , authenticationAttributes , principalAttributes , authenticationBuilder ) ; \n \n \t2 final Principal primaryPrincipal = getPrimaryPrincipal ( this . authentications , principalAttributes ) ; \n \n \t2 authenticationBuilder . setPrincipal ( primaryPrincipal ) ; \n \n <ect>
\t2 path = path . replaceAll ( <string_literal> , <string_literal> ) ; \n \n \t2 try { \n \n \t3 return FilenameUtils . getName ( path ) ; \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t3 FileInputFormat . addInputPath ( job , input ) ; \n \n \t3 FileOutputFormat . setOutputPath ( job , output ) ; \n \n \t3 job . waitForCompletion ( true ) ; } \n \n \t2 catch ( IOException e ) { \n \n <ect>
\t1 try { \n \n \t1 if ( dbConn != null && ! dbConn . isClosed ( ) ) { \n \n \t2 dbConn . close ( ) ; } \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
<comment> \n \n \t1 @ SuppressFBWarnings ( <string_literal> ) \n \n \t1 private static void upgradeTable ( final Connection connection , final int currentVersion ) throws SQLException { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , address , configuration . getNodes ( ) ) ; \n \n \t4 this . atomix . bootstrap ( configuration . getNodes ( ) ) . join ( ) ; \n \n \t4 LOGGER . debug ( <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t2 if ( debug ) handleSQLException ( sqlException ) ; \n \n \t2 try { \n \n \t3 close ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 try { \n \n \t1 new SolrCollectionConfigurer ( this , true ) . start ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 } else { \n \n \t2 int endTime = convertToNumber ( feedEnd ) . intValue ( ) ; \n \n \t2 int totalTime = endTime - startTime ; \n \n <ect>
\t3 _keys . add ( key ) ; } } \n \n \t1 public static boolean executeTest ( String key , Class < ? > c , TestCase component ) { \n \n \t2 boolean finalResult = false ; \n \n \t2 try { \n \n <ect>
\t6 try { \n \n \t7 isHutdownHookCalled = true ; \n \n \t7 if ( connectorServer . isActive ( ) ) { \n \n \t8 connectorServer . stop ( ) ; \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t3 inputStream . close ( ) ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t3 Meter m = ( Meter ) metric ; \n \n \t3 <comment> \n \n \t3 meters . put ( m , new DMeter ( m , name , host , tags ) ) ; \n \n \t2 } else if ( metric instanceof Histogram ) { \n \n <ect>
\t2 for ( source in args ) { \n \n \t3 URL url \n \n \t3 if ( isWin ) { \n \n \t4 source = source . replaceAll ( ' \\ \\ \\ \\ ' , ' ' ) } \n \n <ect>
\t5 candidates . add ( entry . getValue ( ) ) ; } } \n \n \t3 for ( final ClusterServiceRequestPdu pdu : candidates ) { \n \n \t4 _outgoingPdusWaitingForAck . remove ( pdu . getSequenceId ( ) ) ; } } \n \n \t2 for ( final ClusterServiceRequestPdu pdu : candidates ) { \n \n <ect>
\t8 _log . warn ( request , use ) ; \n \n \t8 method = null ; \n \n \t8 break ; } \n \n \t6 } else { \n \n <ect>
\t5 logger . debug ( <string_literal> , t ) ; \n \n \t5 try { \n \n \t6 WebSocketEventListener . class . cast ( l ) . onThrowable ( new AtmosphereResourceEventImpl ( r , false , false , t ) ) ; \n \n \t5 } catch ( Throwable t2 ) { \n \n <ect>
\t7 <comment> \n \n \t7 if ( ( new File ( exportDir + File . separator + exportName + <string_literal> ) ) . exists ( ) ) { \n \n \t8 success = true ; \n \n \t7 } else { \n \n <ect>
\t3 command = new CompletedActionXCommand ( actionId , externalStatus , actionData , HIGH_PRIORITY ) ; } \n \n \t2 else { \n \n \t3 command = new CompletedActionCommand ( actionId , externalStatus , actionData , HIGH_PRIORITY ) ; } \n \n \t2 if ( ! Services . get ( ) . get ( CallableQueueService . class ) . queue ( command ) ) { \n \n <ect>
\t3 } else if ( ! police . getRest ( ) . isEmpty ( ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , RestfulAuthenticationPolicy . class . getSimpleName ( ) ) ; \n \n \t4 police . getRest ( ) . forEach ( r - > plan . registerAuthenticationPolicy ( new RestfulAuthenticationPolicy ( new RestTemplate ( ) , r . getEndpoint ( ) ) ) ) ; \n \n \t3 } else if ( police . getAny ( ) . isEnabled ( ) ) { \n \n <ect>
\t7 configIsValid = false ; \n \n \t6 } <comment> \n \n \t4 } catch ( UnreachableStoreException e ) { \n \n \t5 currentAmountOfUnreachableNodes ++ ; \n \n <ect>
\t3 if ( targetScaler != null ) { \n \n \t4 result = createVariation ( targetScaler ) ; } \n \n \t2 } else { \n \n <ect>
\t7 Log . warning ( Log . FAC_ACCESSCONTROL , <string_literal> + latestKey . getVersionedName ( ) + <string_literal> ) ; } } \n \n \t4 } else { \n \n \t5 <comment> \n \n \t5 if ( Log . isLoggable ( Log . FAC_ACCESSCONTROL , Level . INFO ) ) { \n \n <ect>
\t3 cleanupLRouterPort ( logicalRouterUuid , lRouterPort , niciraNvpApi ) ; \n \n \t3 cleanupLSwitchPort ( logicalSwitchUuid , lSwitchPort , niciraNvpApi ) ; \n \n \t3 return handleException ( e , command , niciraNvpResource ) ; } \n \n \t2 s_logger . debug ( <string_literal> + lSwitchPort . getUuid ( ) + <string_literal> + lSwitchPort . getDisplayName ( ) + <string_literal> + lRouterPort . getUuid ( ) + <string_literal> + lRouterPort . getDisplayName ( ) + <string_literal> ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 private void safeCloseConnection ( ) { \n \n \t2 try { \n \n \t3 connection . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 public Double exec ( Tuple input ) throws IOException \n \n \t1 { \n \n \t2 if ( input == null || input . size ( ) == 0 ) { \n \n <ect>
\t3 if ( ! packages . contains ( customPackage ) ) \n \n \t3 { \n \n \t4 packages . add ( 0 , customPackage ) ; \n \n \t4 if ( loggerIsDebugEnabled ) \n \n <ect>
\t2 cache . close ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void loadError ( ) throws Exception { \n \n <ect>
\t4 return True , 1 \n \n \t3 else : \n \n \t4 return False , 1 \n \n \t2 except Exception as e : \n \n <ect>
\t2 try { \n \n \t3 Class . forName ( <string_literal> ) ; \n \n \t2 } catch ( ClassNotFoundException ignored ) { \n \n \t3 <comment> \n \n <ect>
\t3 result . ouch2 = ( AccumuloSecurityException ) e ; \n \n \t3 result . setOuch2IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t10 @ QueryParam ( <string_literal> ) String user_agent , \n \n \t10 @ QueryParam ( <string_literal> ) String xforwardedfor , \n \n \t10 @ Context HttpHeaders headers , @ Context HttpServletRequest request ) \n \n \t2 throws WebApplicationException { \n \n <ect>
\t7 return new Answer ( cmd ) ; \n \n \t6 else \n \n \t7 return new Answer ( cmd , false , <string_literal> ) ; } } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 public BoxFile uploadNewFileVersion ( String fileId , InputStream fileContent , Date modified , Long fileSize , \n \n \t3 ProgressListener listener ) { \n \n \t2 try { \n \n <ect>
\t3 vm [ <number_literal> ] = rs . getString ( <number_literal> ) ; <comment> \n \n \t3 vms . add ( vm ) ; } \n \n \t2 rs . close ( ) ; \n \n \t2 pstmt . close ( ) ; \n \n <ect>
\t2 R2RMLMappingIdentifier id = null ; \n \n \t2 try { \n \n \t3 id = new R2RMLMappingIdentifier ( sourceNamespace , new URL ( sourceNamespace + sourcePrefix + UUID . randomUUID ( ) ) ) ; \n \n \t2 } catch ( MalformedURLException e ) { \n \n <ect>
\t1 private void endFunction ( String function , MetaStoreEndFunctionContext context ) { \n \n - \t1 try { \n \n - \t2 Metrics . endScope ( function ) ; \n \n - \t1 } catch ( IOException e ) { \n \n <ect>
\t1 if ( defaultErrorHandling ) { \n \n \t1 DefaultErrorCallback . INSTANCE . error ( message , t ) ; } \n \n \t1 return defaultErrorHandling ; } \n \n public void encodeAndTransmit ( final Message message ) { \n \n <ect>
\t2 } catch ( UnknownHostException e ) { \n \n \t3 logger . error ( <string_literal> , m_host , e ) ; \n \n \t3 return ( false ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 protected Collection < CasEvent > getCasTicketGrantingTicketCreatedEventsFor ( final String principal ) { \n \n \t2 final String type = CasTicketGrantingTicketCreatedEvent . class . getName ( ) ; \n \n <ect>
\t1 result = Charset . forName ( StringUtils . trim ( encodingStr ) ) ; \n \n \t1 LOG . info ( <string_literal> , result . displayName ( ) , Locale . getDefault ( ) ) ; \n \n \t1 } else { \n \n \t1 result = Charset . defaultCharset ( ) ; \n \n <ect>
\t2 for ( long cachedRequestId : cachedRequestIds ) { \n \n \t3 if ( ! requestsInProgress . contains ( cachedRequestId ) ) { \n \n \t3 requestSharedDataMap . remove ( cachedRequestId ) ; } } } \n \n \t1 } catch ( Exception exception ) { \n \n <ect>
\t1 public String getOne ( User user , @ RemainedPath String path , \n \n \t6 @ RequestParam ( value = <string_literal> , required = false ) Long revision , ModelMap model ) { \n \n \t2 FileEntry script = fileEntryService . getOne ( user , path , revision ) ; \n \n \t2 if ( script == null || ! script . getFileType ( ) . isEditable ( ) ) { \n \n <ect>
\t1 final String sig = EuareServerCertificateUtil . generateSignatureWithEuare ( msg ) ; \n \n \t1 result . setSignature ( sig ) ; \n \n \t1 reply . setDownloadServerCertificateResult ( result ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t1 port = conf . getString ( COLLECTOR_PORT , <string_literal> ) ; \n \n \t1 hostInMemoryAggregationEnabled = conf . getBoolean ( HOST_IN_MEMORY_AGGREGATION_ENABLED_PROPERTY ) ; \n \n \t1 hostInMemoryAggregationPort = conf . getInt ( HOST_IN_MEMORY_AGGREGATION_PORT_PROPERTY ) ; \n \n \t1 if ( collectorHosts . isEmpty ( ) ) { \n \n <ect>
\t5 buffer . append ( <string_literal> ) ; } \n \n \t4 buffer . append ( hex ) ; } \n \n \t3 md5 = buffer . toString ( ) ; \n \n \t2 } catch ( NoSuchAlgorithmException ex ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t3 controllerCmd . putCommandParameter ( <string_literal> , <string_literal> ) ; \n \n \t3 controllerCmd . putCommandParameter ( <string_literal> , nfsServiceResponse . getNfsService ( ) . getControllerid ( ) ) ; \n \n \t3 UpdateControllerResponse controllerResponse = ( UpdateControllerResponse ) getElastistorRestClient ( ) . executeCommand ( controllerCmd ) ; \n \n \t3 if ( controllerResponse . getController ( ) . getUuid ( ) != null ) { \n \n <ect>
\t2 if ( hasOpenSsl ) { \n \n \t3 OpenSslServerContext context = new OpenSslServerContext ( CERT_FILE , KEY_FILE ) ; \n \n \t3 serverContexts . add ( context ) ; \n \n \t2 } else { \n \n <ect>
\t3 { \n \n \t4 Tuple t = result . next ( ) ; \n \n \t4 System . out . println ( TupleFormat . format ( t ) ) ; } \n \n \t2 } else { \n \n <ect>
\t3 stmt . setInt ( <number_literal> , securityGroup ) ; \n \n \t3 stmt . executeUpdate ( ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n \t3 System . out . println ( <string_literal> + ex . getMessage ( ) ) ; \n \n <ect>
\t3 Date start = new Date ( ) ; \n \n \t3 if ( Options . v ( ) . verbose ( ) ) \n \n \t3 { \n \n \t4 logger . debug ( <string_literal> + m . getName ( ) ) ; \n \n <ect>
\t2 LOG . info ( <string_literal> + msg ) ; \n \n \t2 assertEquals ( <string_literal> , LOW_PRI + 1 , msg . getJMSPriority ( ) ) ; \n \n \t2 msg = sub . receive ( <number_literal> ) ; \n \n \t2 assertNotNull ( <string_literal> , msg ) ; \n \n <ect>
\t1 server . find ( Country . class ) . findCount ( ) ; \n \n \t1 try { \n \n \t2 someInnerMethodWithFailure ( ) ; \n \n \t1 } catch ( RuntimeException e ) { \n \n <ect>
\t4 KubernetesConstants . KUBERNETES_POD_NAME , String . class ) ; \n \n \t2 String namespaceName = exchange . getIn ( ) . getHeader ( \n \n \t4 KubernetesConstants . KUBERNETES_NAMESPACE_NAME , String . class ) ; \n \n \t2 if ( ObjectHelper . isEmpty ( podName ) ) { \n \n <ect>
\t4 Lock _lock = em . getReference ( Lock . class , lock . getId ( ) ) ; \n \n \t4 em . lock ( _lock , LockModeType . PESSIMISTIC_WRITE ) ; \n \n \t4 final Integer id = _lock . getId ( ) ; \n \n \t4 _lock . getName ( ) ; \t2 <comment> \n \n <ect>
\t7 } else if ( fileIterator . isRootFile ( ) && ( endsWithIgnoreCase ( name , <string_literal> ) || isZipFile ( file ) ) && file . exists ( ) ) { \n \n \t8 try { \n \n \t9 zipIterator = new ZipFileIterator ( new ZipFile ( file ) , pkgNameFilter ) ; \n \n \t8 } catch ( Exception ex ) { \n \n <ect>
\t2 if ( howMany != orig . length ) \n \n \t3 fail ( <string_literal> + howMany + <string_literal> ) ; \n \n \t2 if ( ! DataHelper . eq ( orig , read ) ) \n \n \t3 fail ( <string_literal> ) ; \n \n <ect>
\t2 String moduleName = null ; \n \n \t2 String firstModuleName = iter . getNext ( ) ; <comment> \n \n \t2 while ( iter . hasNext ( ) ) { \n \n \t3 moduleName = iter . next ( ) ; \n \n <ect>
\t3 <comment> \n \n \t3 if ( newNode instanceof File ) { \n \n \t4 getWebSocket ( ) . createFileUploadHandler ( ( File ) newNode ) ; } \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 pkValue = s ; } \n \n \t3 EOEnterpriseObject eo = EOUtilities . objectWithPrimaryKeyValue ( sourceObject . editingContext ( ) , destinationEntityName , pkValue ) ; \n \n \t3 selections . addObject ( eo ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 public static < T > T ignoredAndLogged ( UncheckedRun < T > runnable ) { \n \n \t2 try { \n \n \t3 return runnable . run ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
<number_literal> SNPEFF_VCF_HEADER_COMMAND_LINE_KEY , supportedSnpEffVersionsString ( ) ) ) ; \n \n \t3 return false ; } \n \n \t2 String snpEffVersionString = snpEffVersionLine . getValue ( ) . replaceAll ( <string_literal> , <string_literal> ) . split ( <string_literal> ) [ 0 ] ; \n \n \t2 if ( ! isSupportedSnpEffVersion ( snpEffVersionString , snpEffCommandLine . getValue ( ) ) ) { \n \n <ect>
\t4 log . warn ( <string_literal> + \n \n \t6 <string_literal> + \n \n \t6 <string_literal> ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t2 taskLatch . countDown ( ) ; \n \n \t2 callbackLatch . countDown ( ) ; \n \n \t2 future1 . get ( ) ; \n \n \t2 waitFinish ( ) ; \n \n <ect>
\t2 } else { \n \n \t4 s_logger . debug ( <string_literal> + config . getUuid ( ) ) ; } } \n \n \t2 if ( rules != null ) { \n \n <ect>
\t1 . caseInstanceId ( caseInstanceId ) \n \n \t1 . activityId ( <string_literal> ) \n \n \t1 . singleResult ( ) ; \n \n \t1 caseService . manuallyStartCaseExecution ( thirdTask . getId ( ) ) ; \n \n <ect>
\t1 <comment> \n \n \t1 srcOpInfo = lastPTFOp != null ? lastPTFOp : srcOpInfo ; } \n \n \t1 Operator bodyOpInfo = genBodyPlan ( qb , srcOpInfo , aliasToOpInfo ) ; \n \n <ect>
\t5 . map ( LdapConsentRepository : : mapFromJson ) \n \n \t5 . collect ( Collectors . toSet ( ) ) ) \n \n \t4 . forEach ( decisions : : addAll ) ; \n \n \t3 return CollectionUtils . wrap ( decisions ) ; } \n \n <ect>
import org . apache . hadoop . metrics2 . sink . timeline . AbstractTimelineMetricsSink ; \n \n public class TestAmbariMetricsSinkImpl extends AbstractTimelineMetricsSink implements MetricsSink { \n \n @ Override \n \n public void publish ( List < SingleMetric > metrics ) { \n \n <ect>
\t2 } catch ( ConcurrentOperationException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . INTERNAL_ERROR , e . getMessage ( ) ) ; \n \n \t2 } catch ( ManagementServerException e ) { \n \n <ect>
\t3 config . appendChild ( policyMapDetails ( doc , name , averageRate , maxRate , burstRate ) ) ; \n \n \t3 editConfig . appendChild ( config ) ; \n \n \t3 return serialize ( domImpl , doc ) ; \n \n \t2 } catch ( ParserConfigurationException e ) { \n \n <ect>
\t3 return ; } \n \n \t2 Node attributeGroupNode = null ; \n \n \t2 if ( defn . isAttributeGroupDefinitionReference ( ) ) { \n \n \t3 XSDAttributeGroupDefinition resolved = defn . getResolvedAttributeGroupDefinition ( ) ; \n \n <ect>
\t2 response . setStatusCode ( status ) ; \n \n \t2 StringWriter sw = new StringWriter ( ) ; \n \n \t2 exception . printStackTrace ( new PrintWriter ( sw , true ) ) ; \n \n \t2 String logMessage = ( message != null ? message + <string_literal> : <string_literal> ) + sw . toString ( ) ; \n \n <ect>
\t3 return _gson . toJson ( answers ) ; } \n \n \t2 try { \n \n \t3 long startTick = System . currentTimeMillis ( ) ; \n \n <ect>
\t2 if ( metadata != null ) { \n \n \t3 final Map < String , AttributeValue > keys = new HashMap < > ( ) ; \n \n \t3 keys . put ( ColumnNames . ID . getColumnName ( ) , new AttributeValue ( encodedTicketId ) ) ; \n \n \t3 final GetItemRequest request = new GetItemRequest ( ) . withKey ( keys ) . withTableName ( metadata . getProperties ( ) . getStorageName ( ) ) ; \n \n <ect>
\t5 <comment> \n \n \t5 setNeedToRestart ( true ) ; } \n \n \t4 removeRequest ( request ) ; \n \n \t4 throw new IOException ( <string_literal> + name ( ) + <string_literal> ) ; } } \n \n <ect>
\t3 catch ( EOFException ignored ) { \n \n \t4 err = new GridException ( <string_literal> ) ; } \n \n \t3 catch ( IOException e ) { \n \n \t4 if ( ! stopping ) \n \n <ect>
\t4 <comment> \n \n \t3 else \n \n \t3 { \n \n <ect>
\t3 response . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \n \n \t3 return ; } \n \n \t2 <comment> \n \n \t2 if ( consumer . isSuspended ( ) ) { \n \n <ect>
\t4 return false ; \n \n \t3 } else { \n \n \t4 return _projectDao . remove ( project . getId ( ) ) ; } \n \n \t2 } else { \n \n <ect>
\t2 logger . info ( <string_literal> + config . getMailgunApiKey ( ) ) ; \n \n \t2 logger . info ( <string_literal> + config . getMailgunDomain ( ) ) ; \n \n \t2 logger . info ( <string_literal> + config . getMailSmtpHost ( ) ) ; \n \n \t2 logger . info ( <string_literal> + config . getMailSmtpPort ( ) ) ; \n \n <ect>
\t2 while ( e . hasMoreElements ( ) ) { \n \n \t3 MqttBrokerConnection conn = brokerConnections . get ( e . nextElement ( ) ) ; \n \n \t3 logger . info ( <string_literal> , conn . getName ( ) ) ; \n \n \t3 conn . close ( ) ; } \n \n <ect>
\t3 return CollectionUtils . wrapSet ( event ) ; } \n \n \t2 LOGGER . debug ( <string_literal> , id , service ) ; \n \n \t2 final Pair < Boolean , Optional < MultifactorAuthenticationProvider > > result = this . authenticationContextValidator . validate ( authentication , id , service ) ; \n \n \t2 if ( result . getKey ( ) ) { \n \n <ect>
\t2 for ( Map . Entry < String , Collection < String > > e : newReferences . asMap ( ) . entrySet ( ) ) { \n \n \t3 String uuid = e . getKey ( ) ; \n \n \t3 String passivePath = getPathByUuid ( uuid ) ; \n \n \t3 if ( passivePath == null ) { \n \n <ect>
\t2 } catch ( NoSuchAlgorithmException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( NoSuchPaddingException e ) { \n \n <ect>
\t1 @ Rule \n \n \t1 public TestWatcher watchman = new TestWatcher ( ) { \n \n \t2 @ Override \n \n \t2 public void starting ( Description description ) { \n \n <ect>
\t4 result . add ( convertHistoryRecordToMessageEvent ( recs . next ( ) , room ) ) ; } \n \n \t3 removeHistorySearchProgressListeners ( reader ) ; \n \n \t2 } catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t6 if ( ( contextInfo . getRequestedUri ( ) . startsWith ( <string_literal> ) \n \n \t7 <comment> \n \n \t7 || request . getRequestURI ( ) . startsWith ( OpenCms . getSystemInfo ( ) . getWorkplaceContext ( ) ) ) \n \n \t7 && getRoleManager ( ) . hasRole ( newCms , CmsRole . ELEMENT_AUTHOR ) ) { \n \n <ect>
\t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t2 syncTransport . open ( ) ; } \n \n \t1 protected void initializeAsyncTransport ( ) throws IOException , TTransportException { \n \n \t2 if ( ! ObjectHelper . isEmpty ( configuration . getHost ( ) ) && ! ObjectHelper . isEmpty ( configuration . getPort ( ) ) ) { \n \n <ect>
\t5 Msg m = dev . makeStandardMessage ( ( byte ) 0x0f , ( byte ) 0x13 , ( byte ) 0x00 ) ; \n \n \t5 dev . enqueueMessage ( m , m_feature ) ; \n \n \t5 logger . info ( <string_literal> , nm ( ) , dev . getAddress ( ) ) ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t6 statusHolder . setVentilationLevel ( value ) ; \n \n \t5 } else { \n \n \t6 logger . warn ( <string_literal> , value , itemName ) ; } \n \n \t4 } else { \n \n <ect>
\t1 <comment> \n \n \t1 TransportCallback < StreamResponse > callback = ctx . channel ( ) . attr ( CALLBACK_ATTR_KEY ) . getAndSet ( null ) ; \n \n \t1 if ( callback != null ) \n \n \t1 { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 public Repository getRepository ( Map parameters ) throws RepositoryException { \n \n <ect>
\t1 filterKeyValue . setOutputManager ( mockOutputManager ) ; \n \n \t1 filterKeyValue . init ( new LogFeederProps ( ) ) ; } \n \n @ Test \n \n public void testFilterKeyValue_extraction ( ) throws Exception { \n \n <ect>
\t3 try { \n \n \t4 Runnable r = new Runnable ( ) { \n \n \t5 public void run ( ) { \n \n \t6 boolean reconnected = false ; \n \n <ect>
\t1 } catch ( final PatternSyntaxException ex ) { \n \n \t1 throw new RuntimeException ( <string_literal> + ERRAI_VETO_PATTERN , ex ) ; } } \n \n private < T > void maybeRegisterServices ( final AnnotatedType < T > type ) { \n \n \t1 if ( type . isAnnotationPresent ( Remote . class ) ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t3 message . setJMSExpiration ( 0 ) ; \n \n \t3 message . setStringProperty ( <string_literal> , <string_literal> ) ; \n \n \t3 producer . send ( topic , message ) ; \n \n \t3 producerSessions . commit ( ) ; } \n \n <ect>
\t4 return new Answer ( null ) ; } \n \n \t3 pool . deletePhysicalDisk ( vol . getPath ( ) , vol . getFormat ( ) ) ; \n \n \t3 return new Answer ( null ) ; \n \n \t2 } catch ( final CloudRuntimeException e ) { \n \n <ect>
\t4 if ( port == - 1 ) \n \n \t5 port = <number_literal> ; \n \n \t4 if ( _shouldProxy ) { \n \n \t5 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t1 <string_literal> <string_literal> <string_literal> \n \n \t1 <string_literal> <string_literal> <string_literal> \n \n \t1 <string_literal> <string_literal> <string_literal> \n \n \t1 if not commands : \n \n <ect>
\t1 Logger . info ( <string_literal> . format ( service_name ) ) \n \n \t1 return None \n \n data = data [ service_name ] \n \n if component_name not in data : \n \n <ect>
\t4 ftpFiles . add ( ftpFile ) ; } \n \n \t3 tx . success ( ) ; \n \n \t3 return ftpFiles ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t5 throw new RuntimeException ( <string_literal> ) ; } \n \n \t2 } catch ( RuntimeException re ) { \n \n \t3 logger . error ( <string_literal> , i ) ; \n \n \t3 throw re ; } \n \n <ect>
\t1 public int deleteById ( DatabaseConnection databaseConnection , ID id , ObjectCache objectCache ) throws SQLException { \n \n \t2 try { \n \n \t3 Object [ ] args = new Object [ ] { convertIdToFieldObject ( id ) } ; \n \n \t3 int rowC = databaseConnection . delete ( statement , args , argFieldTypes ) ; \n \n <ect>
\t6 return ; } \n \n \t4 } catch ( InterruptedException e ) { \n \n \t5 errorMsg . append ( <string_literal> + e ) ; \n \n \t5 return ; } \n \n <ect>
\t1 } finally { \n \n \t2 try { \n \n \t2 reader . close ( ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t2 FMLLog . fine ( <string_literal> ) ; \n \n \t2 discoverer . findClasspathMods ( modClassLoader ) ; \n \n \t2 FMLLog . fine ( <string_literal> ) ; \n \n \t2 FMLLog . getLogger ( ) . log ( Level . INFO , <string_literal> , ModListHelper . additionalMods . size ( ) ) ; \n \n <ect>
\t1 try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( fs . open ( fileListing ) ) ) ) { \n \n \t1 <comment> \n \n \t1 String line = null ; \n \n \t1 while ( ( line = br . readLine ( ) ) != null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 throw new RuntimeException ( Configs . SOURCE_DIR + <string_literal> ) ; } \n \n \t1 this . sourceDirPath = new Path ( conf . get ( Configs . SOURCE_DIR ) . toString ( ) ) ; \n \n \t1 <comment> \n \n \t1 if ( ! conf . containsKey ( Configs . ARCHIVE_DIR ) ) { \n \n <ect>
\t6 } else { \n \n \t7 s_logger . warn ( <string_literal> + e . getScope ( ) . getName ( ) , e ) ; \n \n \t7 throw e ; } } \n \n \t4 } catch ( InsufficientCapacityException e ) { \n \n <ect>
\t2 PackageBuilderErrors errors = kbuilder . getErrors ( ) ; \n \n \t2 if ( ! errors . isEmpty ( ) ) { \n \n \t3 for ( KnowledgeBuilderError error : errors . getErrors ( ) ) { \n \n \t4 ctx . results . addMessage ( error ) . setKieBaseName ( ctx . newKieBaseModel . getName ( ) ) ; } \n \n <ect>
\t2 synchronized ( m_pollQueue ) { \n \n \t3 for ( Iterator < PQEntry > i = m_pollQueue . iterator ( ) ; i . hasNext ( ) ; ) { \n \n \t4 if ( i . next ( ) . getDevice ( ) . getAddress ( ) . equals ( d . getAddress ( ) ) ) { \n \n \t5 i . remove ( ) ; \n \n <ect>
\t1 counterGroup = new CounterGroup ( ) ; \n \n \t1 lifecycleState = LifecycleState . IDLE ; } \n \n @ Override \n \n public void start ( ) { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , config . getPersistenceConfiguration ( ) . getStrategy ( ) ) ; \n \n \t4 LOGGER . debug ( <string_literal> , config . getPersistenceConfiguration ( ) . getSynchronousWrites ( ) ) ; \n \n \t4 LOGGER . debug ( <string_literal> , config . getTimeToLiveSeconds ( ) ) ; \n \n \t4 LOGGER . debug ( <string_literal> , config . getTimeToIdleSeconds ( ) ) ; \n \n <ect>
\t8 PreparedStatement pstmt2 = conn . prepareStatement ( <string_literal> + lbId + <string_literal> ) ; \n \n \t8 ResultSet rs2 = pstmt2 . executeQuery ( ) ; \n \n \t7 ) { \n \n \t7 if ( ! rs1 . next ( ) && rs2 . next ( ) ) { \n \n <ect>
\t1 private void logException ( String msg , Exception e ) { \n \n \t3 log . debug ( msg , e ) ; \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 String [ ] fields = _raw . split ( <string_literal> ) ; \n \n \t2 if ( fields . length < <number_literal> ) { \n \n <ect>
\t1 if ( keyIndex == null ) { \n \n \t1 return false ; } \n \n \t1 for ( int idx = 0 ; idx < keyIndex . length ; ++ idx ) { \n \n \t1 if ( keyIndex [ idx ] == null ) { \n \n <ect>
\t1 V sqlType = super . get ( col ) ; \n \n \t1 if ( sqlType == null ) { \n \n \t1 LOG . error ( <string_literal> ) ; \n \n \t1 LOG . error ( <string_literal> ) ; \n \n <ect>
\t3 return emptyOptional ( ) ; } \n \n \t2 try { \n \n \t3 return optional ( new GZIPInputStream ( new ByteArrayInputStream ( buffer ) ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 sourceFile . delete ( ) ; \n \n \t1 if ( deleteOnEnd ) { \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 if ( ! fileToUpload . delete ( ) ) { \n \n <ect>
\t4 beans = conn ( ) . queryNames ( \n \n \t6 new ObjectName ( CommonNames . DOMAIN + <string_literal> ) , null ) ; \n \n \t3 } catch ( MalformedObjectNameException e ) { \n \n \t4 throw new RuntimeException ( e ) ; } \n \n <ect>
<comment> \n \n \t1 InitVotes . waitFor ( ClientMessageBus . class ) ; \n \n \t1 InitVotes . voteFor ( ClientMessageBus . class ) ; \n \n \t1 return ; } \n \n <ect>
\t1 IOException , URISyntaxException { \n \n \t1 httpServletRequest = JerseyUtil . correctPostRequest ( formParams , httpServletRequest ) ; \n \n \t1 for ( Object key : httpServletRequest . getParameterMap ( ) . keySet ( ) ) { \n \n <ect>
\t4 else \n \n \t5 try { \n \n \t6 executor . execute ( r . job , r . name , true ) ; \n \n \t5 } catch ( Throwable t ) { \n \n <ect>
\t3 try { \n \n \t4 connector . connect ( ) ; \n \n \t3 } catch ( OpenEnergyMonitorException e ) { \n \n \t4 logger . error ( <string_literal> , e ) ; \n \n <ect>
\t3 } ) ; \n \n \t3 <comment> \n \n \t3 String baseSolrUrl = ( ( HttpSolrServer ) solr ) . getBaseURL ( ) . replace ( <string_literal> , <string_literal> ) ; \n \n \t3 for ( File solrCoreFile : solrCoreFiles ) { \n \n <ect>
\t2 for ( TorrentClient torrentClient : torrentClients ) { \n \n \t3 torrentClient . bye ( ) ; } } \n \n \t1 } ) ; \n \n \t1 } else { \n \n <ect>
\t2 } else if ( System . getProperties ( ) . getProperty ( EXEC_CLUSTER ) . equalsIgnoreCase ( <string_literal> ) ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 execType = ExecTypeProvider . fromString ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
<number_literal> queue . getCompositeKey ( queue . getName ( ) , message . getKey ( ) ) ) . putEmptyColumn ( mostRecentMessageMetadata , queue . metadataDeleteTTL ) ; \n \n <number_literal> mostRecentTriggerTime = currMessageTriggerTime ; \n \n <number_literal> mostRecentMessageMetadata = currMessageEntry . getName ( ) ; \n \n <number_literal> } else { \n \n <ect>
\t1 @ Inject \n \n \t1 private CDIInjectionBookWriter writer ; \n \n \t1 @ Override \n \n \t1 public void setUp ( String key ) { \n \n <ect>
\t3 bug . setTargetRelease ( randomRelease ( ) ) ; \n \n \t3 bug . setRequirementType ( randomRequirementType ( ) ) ; \n \n \t3 bug . setRequirementSubType ( randomRequirementSubType ( ) ) ; \n \n \t3 addComments ( bug ) ; } \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 publisher = new ExportQueuePublisher ( activemqURL , activemqQueues , publisherMessagesPerThread , publisherThreadCount ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 consumer = new ExportQueueConsumer ( activemqURL , activemqQueues , consumerThreadsPerQueue , consumerBatchSize , publisherMessagesPerThread * publisherThreadCount ) ; \n \n <ect>
\t1 private static void startupHttpMain ( ) { \n \n \t2 try { \n \n \t3 ConsoleProxyServerFactory factory = getHttpServerFactory ( ) ; \n \n \t3 if ( factory == null ) { \n \n <ect>
\t3 DBStructSerializer dbss = new DBStructSerializer ( historyServiceImpl ) ; \n \n \t3 dbss . writeHistory ( dbDatFile , this ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t1 protected void disconnect ( final FTPClient ftp ) { \n \n \t2 try { \n \n \t3 ftp . disconnect ( ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t2 if ( wfAction . getStatus ( ) != WorkflowActionBean . Status . KILLED ) { \n \n \t3 throw new PreconditionException ( ErrorCode . E0726 , wfAction . getId ( ) ) ; } } \n \n \t1 @ Override \n \n \t1 protected Void execute ( ) throws CommandException { \n \n <ect>
\t7 try { \n \n \t8 lastFailed = ! queryTime ( servers . toArray ( new String [ servers . size ( ) ] ) , SHORT_TIMEOUT , preferIPv6 ) ; \n \n \t7 } catch ( IllegalArgumentException iae ) { \n \n \t8 if ( ! lastFailed && _log != null && _log . shouldWarn ( ) ) \n \n <ect>
<number_literal> Thread . sleep ( sleepTime ) ; \n \n <number_literal> } else { \n \n <number_literal> success = true ; } } \n \n \t10 if ( users == null ) { \n \n <ect>
\t1 public void postStart ( PersistentTestContext context ) throws Exception \n \n \t1 { \n \n \t2 context . getUtil ( ) . setDefaultCredentials ( TestUtils . ADMIN_CREDENTIALS ) ; \n \n \t2 <comment> \n \n <ect>
<comment> \n \n public \n \n void overrideAsNeeded ( String override ) { \n \n <ect>
\t3 while ( ( lineIn = br . readLine ( ) ) != null ) { \n \n \t4 license = license + lineIn + ' \\ n' ; } \n \n \t3 br . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 throw new CloudAuthenticationException ( <string_literal> + vmId ) ; } \n \n \t4 } else { \n \n \t5 domainRecord = _domainDao . findById ( caller . getDomainId ( ) ) ; \n \n \t5 if ( domainRecord == null ) { \n \n <ect>
\t2 public long logAround ( ) \n \n \t2 { \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t3 log . info ( <string_literal> ) ; \n \n <ect>
\t4 pool = null ; \n \n \t4 if ( p != null ) { \n \n \t5 p . close ( all ) ; } } \n \n \t2 } catch ( Exception x ) { \n \n <ect>
\t2 String groupId = config . getConsumerGroup ( ) ; \n \n \t2 String key = groupId ; \n \n \t2 MetaPushConsumer consumer = consumers . get ( key ) ; \n \n \t2 if ( consumer != null ) { \n \n <ect>
\t2 if ( syncIndexing ) { \n \n \t3 PropertyIndexCleaner cleaner = new PropertyIndexCleaner ( nodeStore , indexPathService , asyncIndexInfoService , statsProvider ) ; \n \n \t3 regs . add ( scheduleWithFixedDelay ( whiteboard , cleaner , \n \n \t5 cleanerIntervalInSecs , true , true ) ) ; } \n \n <ect>
\t2 CSeqHeader cseqHeader \n \n \t3 = ( CSeqHeader ) response . getHeader ( CSeqHeader . NAME ) ; \n \n \t2 if ( cseqHeader == null ) \n \n \t2 { \n \n <ect>
<comment> \n \n \t1 public Answer execute ( DettachCommand cmd ) { \n \n <ect>
\t4 } catch ( Exception e1 ) { \n \n \t5 LOG . debug ( <string_literal> + cls + <string_literal> + option , e ) ; \n \n \t5 return <string_literal> ; } \n \n \t3 } else { \n \n <ect>
\t4 log . warn ( <string_literal> + ex + <string_literal> ) ; \n \n \t4 job . setStatus ( CoordinatorJobBean . Status . FAILED ) ; \n \n \t4 store . updateCoordinatorJob ( job ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t3 } else { \n \n \t3 error += ( attemptId + <string_literal> ) ; } \n \n \t3 getContext ( ) . containerAlive ( entry . getKey ( ) ) ; } } } \n \n \t1 if ( ! error . isEmpty ( ) ) { \n \n <ect>
\t2 if ( r == 0 ) { \n \n \t3 return ; } \n \n \t2 if ( req . isReleased ( ) ) { \n \n \t3 if ( resp . type ( ) > 0 ) { \n \n <ect>
\t1 this ( quickLinksConfigurationFile , new QuickLinksConfigurationInfo ( ) ) ; } \n \n public QuickLinksConfigurationModule ( File quickLinksConfigurationFile , QuickLinksConfigurationInfo moduleInfo ) { \n \n \t1 this . moduleInfo = moduleInfo ; \n \n \t1 if ( ! moduleInfo . isDeleted ( ) && quickLinksConfigurationFile != null ) { \n \n <ect>
\t2 basic . seekZero ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void versionedSeekZero ( ) throws IOException , NoSuchAlgorithmException { \n \n <ect>
\t3 pNetworktrafficType = _pNTrafficTypeDao . persist ( pNetworktrafficType ) ; \n \n \t3 txn . commit ( ) ; \n \n \t3 return pNetworktrafficType ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 assert ippart . length == <number_literal> : <string_literal> + entry ; \n \n \t4 if ( <string_literal> . equals ( ippart [ 0 ] ) && ippart [ 1 ] . equals ( ip ) ) { \n \n \t5 return c ; } \n \n \t4 c += 1 ; } \n \n <ect>
\t7 log . debug ( <string_literal> ) ; \n \n \t7 log . debug ( <string_literal> ) ; \n \n \t7 log . debug ( <string_literal> , key ) ; \n \n <ect>
\t1 public void onMode ( String chan , IRCUser user , IRCModeParser ircModeParser ) { \n \n \t2 log . info ( <string_literal> + server + <string_literal> + chan + <string_literal> + user + <string_literal> + ircModeParser ) ; } \n \n \t1 @ Override \n \n \t1 public void onMode ( IRCUser user , String passiveNick , String mode ) { \n \n <ect>
\t2 validateIndexRecoveryState ( nodeCRecoveryStates . get ( 0 ) . getIndex ( ) ) ; } \n \n \t1 public void testSnapshotRecovery ( ) throws Exception { \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 String nodeA = internalCluster ( ) . startNode ( ) ; \n \n <ect>
\t3 trRow4 . appendChild ( cell41 , cell42 ) \n \n \t3 tooltipManager . appendRow ( trRow4 ) \n \n \t3 return tooltipManager . create ( ) . write ( ) \n \n \t2 } catch ( e : Exception ) { \n \n <ect>
\t1 private void report ( Bndrun run ) { \n \n \t2 for ( String warning : run . getWarnings ( ) ) { \n \n \t3 logger . warn ( <string_literal> , warning ) ; } \n \n \t2 for ( String error : run . getErrors ( ) ) { \n \n <ect>
\t5 DatastoreMO dsMo = new DatastoreMO ( _context , mount . first ( ) ) ; \n \n \t5 String dsFullPath = String . format ( <string_literal> , dsMo . getName ( ) , snapshotDiskFile . substring ( mount . second ( ) . length ( ) + 1 ) ) ; \n \n \t5 s_logger . info ( <string_literal> + snapshotDiskFile + <string_literal> + dsFullPath ) ; \n \n \t5 return dsFullPath ; } } \n \n <ect>
\t4 e1 . setName ( <string_literal> ) ; <comment> \n \n \t4 tx . commit ( ) ; \n \n \t4 fail ( <string_literal> ) ; } \n \n \t3 catch ( ConstraintViolationException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( endpoint . isAttachmentMultipartBinding ( ) ) { \n \n \t3 if ( disableStreamCache == null ) { \n \n \t4 <comment> \n \n <ect>
\t6 log . debug ( <string_literal> + sock_ex ) ; \n \n \t6 break ; } \n \n \t5 log . error ( Util . getMessage ( <string_literal> ) , sock_ex ) ; } \n \n \t4 catch ( Throwable ex ) { \n \n <ect>
\t3 Assert . fail ( <string_literal> + e . getMessage ( ) ) ; } \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testEnumeratedNameListWithThreads ( ) throws Exception { \n \n <ect>
\t1 for ( Cluster cl : clusters . getClusters ( ) . values ( ) ) { \n \n \t1 Map < String , Map < String , String > > configurations = new HashMap < > ( ) ; \n \n \t1 Map < String , Map < String , Map < String , String > > > configurationAttributes = new HashMap < > ( ) ; \n \n <ect>
\t1 private static final String activeEnv ; \n \n \t1 static { \n \n \t2 String env = System . getenv ( <string_literal> ) ; \n \n \t2 if ( env == null ) { \n \n <ect>
\t2 } else if ( ! hostName . toLowerCase ( ) . matches ( <string_literal> ) ) { \n \n \t3 s_logger . warn ( <string_literal> ) ; \n \n \t3 return false ; \n \n \t2 } else if ( hostName . startsWith ( <string_literal> ) || hostName . endsWith ( <string_literal> ) ) { \n \n <ect>
\t3 BCLog . logger . warn ( <string_literal> ) ; \n \n \t3 BCLog . logger . warn ( <string_literal> ) ; \n \n \t3 BCLog . logger . warn ( <string_literal> ) ; \n \n \t3 BCLog . logger . warn ( <string_literal> ) ; \n \n <ect>
\t10 + engine . getName ( ) ) ; } \n \n \t5 } finally { \n \n \t6 executor . shutdown ( ) ; } \n \n \t4 } else { \n \n <ect>
\t3 int pRecLen = mf . getPropertyAsInteger ( ParamValueLength ) ; \n \n \t3 return new BPlusTreeParams ( pOrder , pKeyLen , pRecLen ) ; \n \n \t2 } catch ( NumberFormatException ex ) \n \n \t2 { \n \n <ect>
\t2 metadataUpgrade . update ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 if ( ! metadataUpgrade . updatedResources . isEmpty ( ) ) { \n \n <ect>
\t2 logger . debug ( <string_literal> \n \n \t3 + <string_literal> + \n \n \t3 <string_literal> + fsClass . getName ( ) + <string_literal> + e ) ; } } \n \n \t1 if ( m != null ) { \n \n <ect>
\t1 @ Path ( <string_literal> ) \n \n \t1 @ Consumes ( <string_literal> ) \n \n \t1 public KeepCharsetFavoriteMovieXmlRootElement xmlAccepts ( KeepCharsetFavoriteMovieXmlRootElement movie ) { \n \n \t2 logger . info ( <string_literal> + Charset . defaultCharset ( ) ) ; \n \n <ect>
\t2 currentStack . getStackName ( ) , currentStack . getStackVersion ( ) ) ; \n \n \t1 UpgradePack pack = null ; \n \n \t1 if ( StringUtils . isNotEmpty ( preferredUpgradePackName ) && packs . containsKey ( preferredUpgradePackName ) ) { \n \n \t1 pack = packs . get ( preferredUpgradePackName ) ; \n \n <ect>
\t4 Utils . setProxyIfNeeded ( properties ) ; \n \n \t4 containerName = ( String ) properties . get ( AzureConstants . AZURE_BLOB_CONTAINER_NAME ) ; \n \n \t4 connectionString = Utils . getConnectionStringFromProperties ( properties ) ; \n \n \t4 concurrentRequestCount = PropertiesUtil . toInteger ( properties . get ( AzureConstants . AZURE_BLOB_CONCURRENT_REQUESTS_PER_OPERATION ) , 1 ) ; \n \n <ect>
\t2 clusterState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( 0 ) . currentNodeId ( ) , equalTo ( <string_literal> ) ) ; \n \n <ect>
\t2 } catch ( PortInUseException portInUseException ) { \n \n \t3 logger . debug ( <string_literal> , portInUseException . getMessage ( ) ) ; \n \n \t3 setConnected ( false ) ; \n \n \t2 } catch ( UnsupportedCommOperationException unsupportedCommOperationException ) { \n \n <ect>
\t2 _systemLogger . setLevel ( Level . ALL ) ; \n \n \t2 for ( int i = FAC_DEFAULT ; i < nFac ; i ++ ) { \n \n \t3 _facilityLoggers [ i ] = Logger . getLogger ( FAC_NAME [ i ] ) ; \n \n \t3 _facilityLoggers [ i ] . setLevel ( Level . ALL ) ; } \n \n <ect>
\t2 try \n \n \t2 { \n \n \t3 mlockall ( MCL_CURRENT ) ; \n \n \t3 jnaLockable = true ; \n \n <ect>
\t2 { \n \n \t3 StringBuilder sb = new StringBuilder ( ) ; \n \n \t3 for ( Map . Entry < InetAddress , String [ ] > entry : reloadedMap . entrySet ( ) ) \n \n \t4 sb . append ( entry . getKey ( ) ) . append ( <string_literal> ) . append ( Arrays . toString ( entry . getValue ( ) ) ) . append ( <string_literal> ) ; \n \n <ect>
\t3 } . start ( ) ; } \n \n \t2 latch . await ( ) ; \n \n \t2 if ( ! errors . isEmpty ( ) ) \n \n \t2 { \n \n <ect>
\t2 if ( mBeanServer != null ) { \n \n \t3 try { \n \n \t4 unregisterMBean ( mBeanServer , objectName ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 attrNames = new String [ names . size ( ) ] ; \n \n \t2 names . toArray ( attrNames ) ; } } \n \n \t1 print ( modelName , datasetName , attrNames ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 this . fileName = fileName ; } \n \n \t1 @ Override \n \n \t1 protected void doStart ( ) throws Exception { <comment> \n \n \t2 if ( Security . getProvider ( BC ) == null && BC . equals ( getProvider ( ) ) ) { \n \n <ect>
\t2 return response ; } \n \n \t1 private Status updateStatus ( String status ) throws Exception { \n \n \t2 Status response = endpoint . getProperties ( ) . getTwitter ( ) . updateStatus ( status ) ; \n \n \t2 log . debug ( <string_literal> , status ) ; \n \n <ect>
\t8 ( ( StringProperty ) property ) . setValue ( resKey ) ; <comment> \n \n \t8 super . setProperty ( property ) ; \n \n \t8 return ; \t10 } } \n \n \t6 <comment> \n \n <ect>
\t5 } catch ( JSONException e ) { \n \n \t6 logger . error ( <string_literal> , e ) ; } } \n \n \t3 } ) ; \n \n \t2 } catch ( Exception e1 ) { \n \n <ect>
\t2 try { \n \n \t3 return innerHandle ( props , build ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n \t3 broken = true ; \n \n <ect>
\t4 taskMetricGroup , \n \n \t4 resultPartitionConsumableNotifier , \n \n \t4 partitionStateChecker , \n \n \t4 getRpcService ( ) . getExecutor ( ) ) ; \n \n <ect>
\t3 try { \n \n \t4 List < CmsResource > sharedFiles = m_guestCms . readResources ( shared , filter , true ) ; \n \n \t4 result . addAll ( sharedFiles ) ; \n \n \t3 } catch ( CmsException e ) { \n \n <ect>
\t3 final byte [ ] token = EncodingUtils . decodeBase64 ( authorizationHeader . substring ( this . messageBeginPrefix . length ( ) ) ) ; \n \n \t3 if ( token == null ) { \n \n \t4 LOGGER . warn ( <string_literal> ) ; \n \n \t4 return null ; } \n \n <ect>
<number_literal> <string_literal> + maxAttempts + <string_literal> + randomDelay + <string_literal> ) ; \n \n \t6 try { \n \n \t7 Thread . sleep ( randomDelay ) ; \n \n \t6 } catch ( InterruptedException ie ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 cmiAddress = InetAddress . getByName ( ( String ) configuration . get ( <string_literal> ) ) ; \n \n \t2 } catch ( UnknownHostException e1 ) { \n \n <ect>
\t3 return result ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n \t3 LogLog . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t1 public static void tryFailure ( Promise < ? > p , Throwable cause , InternalLogger logger ) { \n \n \t2 if ( ! p . tryFailure ( cause ) && logger != null ) { \n \n \t3 Throwable err = p . cause ( ) ; \n \n \t3 if ( err == null ) { \n \n <ect>
\t2 if ( mbean != null ) \n \n \t3 try { \n \n \t4 cfg . getMBeanServer ( ) . unregisterMBean ( mbean ) ; \n \n <ect>
\t1 public void testEnded ( String host ) { \n \n \t2 for ( Map . Entry < String , DirContext > entry : ldapContexts . entrySet ( ) ) { \n \n \t3 DirContext dc = entry . getValue ( ) ; \n \n \t3 try { \n \n <ect>
\t3 return Collections . emptyList ( ) ; } \n \n \t2 if ( item instanceof GroupItem ) { \n \n \t3 <comment> \n \n \t3 item = GroupItem . class . cast ( item ) . getBaseItem ( ) ; \n \n <ect>
\t2 if ( _ssvmPSK == null ) { \n \n \t3 try { \n \n \t4 _ssvmPSK = FileUtils . readFileToString ( new File ( POST_UPLOAD_KEY_LOCATION ) , <string_literal> ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t7 handleUpDownForRollershutter ( device , cm ) ; } } \n \n \t4 } else if ( device . getOutputMode ( ) . equals ( OutputModeEnum . UP_DOWN ) ) { \n \n \t5 handleUpDownForRollershutter ( device , cm ) ; \n \n \t4 } else { \n \n <ect>
\t3 String infoKey = token . getAdditionalInfoKey ( ) ; \n \n \t3 String addInfoValue = ( String ) user . getAdditionalInfo ( ) . get ( infoKey ) ; \n \n \t3 logContext = logContext + <string_literal> + addInfoValue + <string_literal> ; \n \n \t3 if ( addInfoValue == null ) { \n \n <ect>
\t2 log . error ( <string_literal> , e ) ; \n \n \t2 throw new RuntimeException ( e ) ; } \n \n \t1 Tablet tablet = onlineTablets . get ( new KeyExtent ( textent ) ) ; \n \n \t1 if ( tablet != null ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( ! previouslyAvailable ) { \n \n <ect>
\t2 for ( TrainerRunnable runnable : runnables ) { \n \n \t3 writeModel . update ( runnable . docTopicModel ) ; } } \n \n \t2 break ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
\t2 log . info ( <string_literal> , size , TimeUtils . printDuration ( watch . taken ( ) ) ) ; \n \n \t2 log . info ( <string_literal> + tiny . get ( ) + <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + small . get ( ) + <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + med . get ( ) + <string_literal> ) ; \n \n <ect>
\t2 cd . put ( <string_literal> , <string_literal> ) ; \n \n \t2 cd . put ( <string_literal> , new byte [ ] { 1 , <number_literal> , <number_literal> , <number_literal> } ) ; \n \n \t2 cd . put ( <string_literal> , ContentName . fromNative ( <string_literal> ) ) ; \n \n \t2 XMLEncodableTester . encodeDecodeTest ( <string_literal> , cd , cdec , bdec ) ; \n \n <ect>
\t2 { \n \n \t3 return Integer . parseInt ( property ) ; } \n \n \t2 catch ( NumberFormatException e ) \n \n \t2 { \n \n <ect>
\t4 log . trace ( <string_literal> , local_addr , hdr , sender ) ; \n \n \t3 try { \n \n \t4 down_prot . down ( msg ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t3 + <string_literal> ) ; } \n \n \t1 assertEquals ( <string_literal> , expectedTtl , result ) ; \n \n \t1 } catch ( IllegalArgumentException exception ) { \n \n \t1 if ( ! expectException ) { \n \n <ect>
\t5 msgCount ++ ; \n \n \t4 } catch ( JMSException e ) { \n \n \t5 logger . error ( <string_literal> , e ) ; \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t2 StopWatch watch = new StopWatch ( ) ; \n \n \t2 LOG . info ( <string_literal> + uuidGenerator . generateUuid ( ) ) ; \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 uuidGenerator . generateUuid ( ) ; } \n \n <ect>
<comment> \n \n \t1 public void log ( String s ) { \n \n \t2 System . out . println ( s ) ; \n \n \t2 <comment> \n \n <ect>
\t5 } else { \n \n \t6 sp . destroy ( ) ; } \n \n \t5 sp . free ( ) ; \n \n \t4 } catch ( LibvirtException l ) { \n \n <ect>
\t2 } else { \n \n \t3 LOGGER . info ( <string_literal> \n \n \t5 + <string_literal> ) ; } \n \n \t2 if ( ticketGrantingTicketValueFromCookie != null && ! ticketGrantingTicketId . equals ( ticketGrantingTicketValueFromCookie ) ) { \n \n <ect>
\t4 configuration . setEndDate ( reportEndDate ) ; } \n \n \t2 } catch ( ParseException e ) { \n \n \t3 log . error ( <string_literal> , REPORT_GENERATOR_KEY_END_DATE , \n \n \t5 endDateValue , rangeDateFormat , e ) ; } \n \n <ect>
\t1 if ( ! matchedToRequest ) { \n \n \t2 boolean addToAvailableList = true ; \n \n \t2 for ( HostImpl registered : availableHosts ) { \n \n \t2 if ( registered . getHostId ( ) == host . getHostId ( ) ) { \n \n <ect>
\t4 if ( ! threw && block . throwsException ) { \n \n \t5 log . error ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \n \t5 rulesSinceFirstFail ++ ; \n \n \t4 } else if ( ! chain . getChainHead ( ) . getHeader ( ) . getHash ( ) . equals ( block . hashChainTipAfterBlock ) ) { \n \n <ect>
\t4 if ( result == null ) { \n \n \t5 s_logger . error ( <string_literal> + targetPath ) ; \n \n \t5 try { \n \n \t6 conn . storagePoolCreateXML ( spd . toString ( ) , 0 ) ; \n \n <ect>
\t1 public void afterCreate ( EntryEvent < Object , Object > event ) { \n \n \t2 log . info ( <string_literal> + messageLog ( event ) + <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void afterDestroy ( EntryEvent < Object , Object > event ) { \n \n <ect>
\t4 assertEquals ( <number_literal> , response . getStatus ( ) ) ; \n \n \t4 assertNotNull ( response . getHeader ( <string_literal> ) ) ; \n \n \t4 assertTrue ( response . getHeader ( <string_literal> ) . endsWith ( base + typeName ) ) ; \n \n \t4 <comment> \n \n <ect>
\t2 for ( final PluginDescription plugin : plugins . getPluginDescriptions ( ) ) { \n \n \t3 if ( plugin instanceof PhasePluginDescription ) { \n \n \t4 handlePhasePlugin ( ( PhasePluginDescription ) plugin ) ; \n \n \t3 } else { \n \n <ect>
\t5 count ++ ; \n \n \t5 <comment> \n \n \t4 } catch ( IllegalArgumentException iae ) { \n \n \t5 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 if ( doesAttributePolicyAllow ) { \n \n \t4 LOGGER . debug ( <string_literal> , attributeName ) ; \n \n \t4 attributes . put ( attributeName , CollectionUtils . wrap ( attributeValue ) ) ; \n \n \t3 } else { \n \n <ect>
\t1 if ( shouldRunInParallel ( resources ) ) { \n \n \t2 result . append ( runInParallel ( resources , criteria ) ) ; \n \n \t1 } else { \n \n \t2 for ( final Resource resource : resources ) { \n \n <ect>
\t2 if ( ! routerInfo . isValid ( ) ) { \n \n \t3 <comment> \n \n \t3 processStoreFailure ( key , routerInfo ) ; \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 CrawlRecord record = null ; \n \n \t2 try { \n \n \t3 record = mapper . readValue ( recordFile , CrawlRecord . class ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 s_logger . debug ( log ( seq , <string_literal> ) ) ; } } \n \n \t3 throw new OperationTimedoutException ( req . getCommands ( ) , _id , seq , wait * <number_literal> , true ) ; \n \n \t2 } catch ( OperationTimedoutException e ) { \n \n <ect>
\t5 connection . commit ( ) ; } \n \n \t3 } catch ( SQLException e ) { \n \n \t4 <comment> \n \n \t3 if ( result [ 0 ] < 1 ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 } else if ( this . rotationPolicy instanceof FileSizeRotationPolicy ) { \n \n \t4 long rotationBytes = ( ( FileSizeRotationPolicy ) rotationPolicy ) . getMaxBytes ( ) ; \n \n \t4 LOG . warn ( <string_literal> , rotationBytes ) ; \n \n \t4 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t5 multi = ( List < OutNetMessage > ) oldMsg ; \n \n \t5 multi . add ( msg ) ; \n \n \t5 _selectorToMessage . put ( sel , multi ) ; } \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 checkSolrStatus ( cloudSolrClient ) ; \n \n \t3 createCollectionsIfNeeded ( cloudSolrClient , state , solrPropsConfig , reloadCollectionNeeded ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 retryCount ++ ; \n \n <ect>
\t2 if ( discoveryAgent instanceof Suspendable ) { \n \n \t3 try { \n \n \t4 ( ( Suspendable ) discoveryAgent ) . resume ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t6 if ( mllpBuffer . hasLeadingOutOfBandData ( ) ) { \n \n \t7 <comment> \n \n \t7 log . warn ( <string_literal> , Hl7Util . convertToPrintFriendlyString ( mllpBuffer . getLeadingOutOfBandData ( ) ) ) ; } \n \n \t6 if ( mllpBuffer . hasTrailingOutOfBandData ( ) ) { \n \n <ect>
\t2 return PARTITION_CONFIG_ERROR_EXIT_CODE ; } \n \n \t2 int partitionCount = parsePartitionCount ( partitionProperties , clusterName ) ; \n \n \t2 if ( partitionCount < 0 ) \n \n \t2 { \n \n <ect>
\t4 setResponseObject ( responseObject ) ; \n \n \t4 responseObject . setResponseName ( getCommandName ( ) ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n \t3 <comment> \n \n <ect>
\t3 Configuration [ ] configs = parser . getModuleDescriptor ( ) . getConfigurations ( ) ; \n \n \t3 for ( Configuration config : configs ) { \n \n \t4 getMd ( ) . addConfiguration ( config ) ; } \n \n \t3 if ( parser . getDefaultConfMapping ( ) != null ) { \n \n <ect>
\t4 s_logger . debug ( sd . toString ( ) ) ; \n \n \t4 s = conn . secretDefineXML ( sd . toString ( ) ) ; \n \n \t4 s . setValue ( Base64 . decodeBase64 ( userInfoTemp [ 1 ] ) ) ; \n \n \t3 } catch ( LibvirtException e ) { \n \n <ect>
\t3 if ( avoidVerbose ++ % <number_literal> == 0 ) { \n \n \t4 logger . warn ( <string_literal> + hexLength + <string_literal> + valueLen + <string_literal> + Bytes . toString ( value , 0 , valueLen ) + <string_literal> + avoidVerbose ) ; } } \n \n \t2 if ( valueLen >= hexLength && isF ( value , 0 , hexLength ) ) { \n \n \t3 if ( avoidVerbose2 ++ % <number_literal> == 0 ) { \n \n <ect>
\t2 if ( ! result ) { \n \n \t3 s_logger . warn ( <string_literal> + command . getVmName ( ) ) ; \n \n \t3 return new SecurityGroupRuleAnswer ( command , false , <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t2 lastCompactID , lastLocation , getBulkIngestedFiles ( ) ) ) ; \n \n \t1 newTablets . put ( low , new TabletData ( lowDirectory , lowDatafileSizes , time , lastFlushID , \n \n \t2 lastCompactID , lastLocation , getBulkIngestedFiles ( ) ) ) ; \n \n \t1 long t2 = System . currentTimeMillis ( ) ; \n \n <ect>
\t2 serialDevice . setEventWorker ( this ) ; \n \n \t2 try { \n \n \t3 serialDevice . initialize ( ) ; \n \n \t2 } catch ( InitializationException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 if ( ! ArrayUtils . isEmpty ( getLogFiles ( ) ) ) { \n \n \t2 if ( isTail ( ) && getLogFiles ( ) . length > 1 ) { \n \n \t2 LOG . warn ( <string_literal> + getLogFiles ( ) . length + <string_literal> + getFilePath ( ) + \n \n \t3 <string_literal> + getLogFiles ( ) [ 0 ] . getAbsolutePath ( ) ) ; } \n \n <ect>
\t1 @ StartProcess ( processKey = <string_literal> ) \n \n \t1 public void startProcess ( @ ProcessVariable ( <string_literal> ) long customerId ) { \n \n \t2 log . info ( <string_literal> + customerId ) ; \n \n \t2 this . methodState += 1 ; \n \n <ect>
\t1 private static class MVELDebugger implements Debugger { \n \n \t2 public MVELDebugger ( ) { } \n \n \t2 public int onBreak ( Frame frame ) { \n \n \t3 if ( verbose ) { \n \n <ect>
\t4 transactionManager . rollback ( ) ; \n \n \t3 } else { \n \n \t4 transactionManager . setRollbackOnly ( ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 while ( iterator . hasNext ( ) ) { \n \n \t5 Work work = convertWork ( iterator . next ( ) ) ; \n \n \t5 result . add ( work ) ; } \n \n \t3 } catch ( XPathExpressionException e ) { \n \n <ect>
\t2 logger = Logger . getLogger ( this . getClass ( ) ) ; \n \n \t2 logger . info ( voiceDescription . getName ( ) + <string_literal> + voiceDescription . getVersion ( ) + <string_literal> + voiceDescription . getLocale ( ) + <string_literal> \n \n \t4 + voiceDescription . getGender ( ) + <string_literal> ) ; } \n \n \t1 private void convert ( ) throws Exception { \n \n <ect>
\t1 public static String localize ( String key , Object . . . args ) { \n \n \t2 String localized = I18n . translateToLocal ( key ) ; \n \n \t2 if ( localized == key ) { \n \n \t3 if ( DEBUG && failedStrings . add ( localized ) ) { \n \n <ect>
\t2 if ( ! insert ) throw new IllegalStateException ( ) ; \n \n \t2 inc ( k . code ) ; } \n \n \t1 public synchronized void inc ( int k ) { \n \n \t2 if ( k == 0 ) { \n \n <ect>
\t2 Server server = new Server ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 server . start ( ) ; \n \n \t2 Thread . sleep ( <number_literal> * <number_literal> * <number_literal> ) ; \n \n <ect>
\t3 messageProducer . send ( message , DeliveryMode . PERSISTENT , message . getJMSPriority ( ) , 0 ) ; \n \n \t3 long duration = System . currentTimeMillis ( ) - start ; \n \n \t3 max = Math . max ( max , duration ) ; \n \n \t3 if ( duration == max ) { \n \n <ect>
\t3 if ( remapped ) \n \n \t4 return ; \n \n \t3 remapped = true ; \n \n <ect>
\t2 logger . debug ( <string_literal> + batchId + <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void onPrepareEnd ( Map < String , Object > parameters ) \n \n \t1 { \n \n <ect>
\t3 this . logger . debug ( <string_literal> , session ) ; \n \n \t3 this . logger . debug ( <string_literal> , transaction ) ; \n \n \t3 return false ; } \n \n \t2 <comment> \n \n <ect>
\t3 statsFileWriter . newLine ( ) ; \n \n \t3 statsFileWriter . flush ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 statsFileWriter = null ; \n \n <ect>
\t2 LOGGER . info ( <string_literal> ) ; \n \n \t2 throw new AmbariLdapException ( <string_literal> ) ; } \n \n \t1 LOGGER . info ( <string_literal> , filter ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 logger . debug ( <string_literal> , e ) ; } \n \n \t3 catch ( IOException e ) \n \n \t3 { \n \n <ect>
\t4 return new Result ( PagingHelper . subList ( resultList , pageSize , page ) , rawResultCount , true , false ) ; \n \n \t3 } catch ( Throwable t ) { \n \n \t4 logger . warn ( <string_literal> , t ) ; } \n \n \t2 } else { \n \n <ect>
<comment> \n \n \t1 public static boolean matches ( final Pattern pattern , final String value , final boolean completeMatch ) { \n \n \t2 final Matcher matcher = pattern . matcher ( value ) ; \n \n <ect>
\t3 s_logger . debug ( <string_literal> + podIdSpecified ) ; \n \n \t3 HostPodVO pod = podDao . findById ( podIdSpecified ) ; \n \n \t3 if ( pod != null ) { \n \n \t4 if ( avoid . shouldAvoid ( pod ) ) { \n \n <ect>
\t4 ProjectTicketSearchCriteria searchCriteria = SearchFieldInfo . buildSearchCriteria ( baseCriteria , searchFieldInfos ) ; \n \n \t4 searchCriteria . setProjectIds ( new SetSearchField < > ( CurrentProjectVariables . getProjectId ( ) ) ) ; \n \n \t4 queryTickets ( searchCriteria ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testExternalParameterEntityExpand ( ) throws Exception { \n \n <ect>
\t3 cfg . setLocalAddress ( InetAddress . getByName ( dynamoDbProperties . getLocalAddress ( ) ) ) ; } \n \n \t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 final AmazonDynamoDBClient client = new AmazonDynamoDBClient ( provider , cfg ) ; \n \n \t2 if ( StringUtils . isNotBlank ( dynamoDbProperties . getEndpoint ( ) ) ) { \n \n <ect>
\t3 Message sendMessage = createTextMessage ( producerSession ) ; \n \n \t3 for ( int i = 0 ; i < messageCount ; i ++ ) { \n \n \t4 jmsProducer . send ( sendMessage ) ; \n \n \t4 numberOfMessageSent ++ ; } \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t4 hasErrors = true \n \n \t4 logger . error ( formatMsg ( <string_literal> ) ) } \n \n \t3 CompilerMessageSeverity . WARNING , \n \n \t3 CompilerMessageSeverity . STRONG_WARNING - > { \n \n <ect>
\t3 String filename = CommandHistory . getHistorySaver ( workspace . getId ( ) ) . getHistoryFilepath ( worksheetId ) ; \n \n \t3 JSONArray historyJson = CommandHistory . getHistorySaver ( workspace . getId ( ) ) . loadHistory ( filename ) ; \n \n \t3 filteredHistoryJson = HistoryJsonUtil . filterCommandsByTag ( tag , historyJson ) ; \n \n \t2 } catch ( JSONException e ) { \n \n <ect>
\t2 log . error ( <string_literal> , e ) ; \n \n \t1 } catch ( IllegalArgumentException exception ) { \n \n \t2 if ( exception . getCause ( ) instanceof UnknownHostException ) { \n \n \t2 <comment> \n \n <ect>
\t6 + <string_literal> + selected . size ( ) + <string_literal> + selected + <string_literal> + _notFailingPeersList . size ( ) + <string_literal> + _strictCapacityOrder . size ( ) ) ; \n \n \t3 matches . addAll ( selected ) ; } \n \n \t2 if ( matches . size ( ) < howMany ) { \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 while ( templates . hasNext ( ) ) { \n \n \t3 String template = templates . next ( ) ; \n \n \t3 String renderedSrc = templateEngine . applyPackageTemplate ( template , packageDoc ) ; \n \n \t3 String destFileName = destdir + FS + packageDoc . name ( ) + FS + tool . getFile ( template ) ; \n \n <ect>
\t2 try { \n \n \t2 Object newInstance = constructor . newInstance ( parameterValues ) ; \n \n \t2 return type . cast ( newInstance ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t3 return ; \n \n \t2 _context . statManager ( ) . addRateData ( <string_literal> , 1 ) ; \n \n \t2 if ( ! _transport . allowConnection ( ) ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 jsonGenerator = jsonFactory . createJsonGenerator ( response . getWriter ( ) ) ; \n \n \t3 jsonObjectMapper . writeValue ( jsonGenerator , personProperties ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t2 configFiles . forEach ( Unchecked . consumer ( f - > { \n \n \t3 LOGGER . debug ( <string_literal> , f ) ; \n \n \t3 if ( f . getName ( ) . toLowerCase ( ) . endsWith ( <string_literal> ) ) { \n \n \t4 final Map < String , Object > pp = loadYamlProperties ( new FileSystemResource ( f ) ) ; \n \n <ect>
\t3 d . enqueueMessage ( m , f ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 logger . warn ( <string_literal> , d . getAddress ( ) ) ; \n \n \t2 } catch ( FieldException e ) { \n \n <ect>
\t5 if ( service . getInterface ( ) == XLogService . class ) { \n \n \t6 log . info ( <string_literal> ) ; } \n \n \t5 service . destroy ( ) ; } \n \n \t4 catch ( Throwable ex ) { \n \n <ect>
\t3 Future < ? > future = iterator . next ( ) ; \n \n \t3 iterator . remove ( ) ; \n \n \t3 if ( ! future . isDone ( ) && ! future . isCancelled ( ) && ! future . cancel ( true ) ) \n \n \t3 { \n \n <ect>
\t4 if ( stack != null && ! stack . empty ( ) ) { \n \n \t5 String stackContent = ( String ) stack . pop ( ) ; \n \n \t5 if ( stackContent . equals ( WO_REPLACEMENT_MARKER ) ) { \n \n <ect>
\t3 log . debug ( <string_literal> + mongoOptions . toString ( ) ) ; } \n \n \t2 if ( getThreadContext ( ) . getVariables ( ) . getObject ( getSource ( ) ) != null ) { \n \n <ect>
\t2 stats = client . getMasterStats ( Tracer . traceInfo ( ) , context . rpcCreds ( ) ) ; \n \n \t2 break ; \n \n \t2 } catch ( ThriftNotActiveServiceException e ) { \n \n \t2 <comment> \n \n <ect>
\t1 self . logger . info ( <string_literal> ) \n \n \t1 putRangerHDFSPluginProperty = self . putProperty ( configurations , <string_literal> , services ) \n \n \t1 putRangerHDFSPluginProperty ( <string_literal> , hdfs_user ) \n \n \t1 else : \n \n <ect>
\t7 log . warn ( <string_literal> + sender . getDestination ( ) . getName ( ) + <string_literal> ) ; \n \n \t6 else \n \n \t7 log . warn ( <string_literal> + sender . getDestination ( ) . getName ( ) + <string_literal> , x ) ; } } \n \n \t4 if ( ! isConnected ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 dbConn . rollback ( ) ; } } \n \n \t2 LOG . info ( <string_literal> + numTxnsAborted + <string_literal> ) ; } \n \n \t1 } catch ( SQLException ex ) { \n \n <ect>
\t5 request . sync ( ) ; \n \n \t4 } else { \n \n \t5 request . sync ( closeTimeout , TimeUnit . MILLISECONDS ) ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 } else { \n \n \t6 try { \n \n \t7 repository = createRepository ( repositoryMetaData ) ; \n \n \t6 } catch ( RepositoryException ex ) { \n \n <ect>
\t3 currentlySelectedWindow = this . getCurrentWindow ( true ) ; \n \n \t3 currentlySelectedWindowMarker = currentlySelectedWindow [ this . uniqueId ] ; \n \n \t3 LOG . debug ( <string_literal> + marker + <string_literal> + newMarker ) ; \n \n \t3 if ( / ( TestRunner - splash | Blank ) \\ . html \\ ? start = true$ / . test ( currentHref ) ) { \n \n <ect>
\t2 final Callback < None > callback ; \n \n \t2 synchronized ( _mutex ) \n \n \t2 { \n \n \t2 callback = _factoryShutdownCallback ; } \n \n <ect>
\t2 webhookRequest . setEventTypes ( EventTypeListTestCase . createAuthEventTypeList ( ) ) ; \n \n \t2 Webhook webhookResponse = webhookRequest . create ( TestConstants . SANDBOX_CONTEXT , webhookRequest ) ; \n \n \t2 String webhookId = webhookResponse . getId ( ) ; \n \n \t2 EventTypeList eventTypeList = EventType . subscribedEventTypes ( TestConstants . SANDBOX_CONTEXT , webhookId ) ; \n \n <ect>
\t2 return nat_rule \n \n \t1 @ attr ( tags = [ <string_literal> , <string_literal> ] , required_hardware = <string_literal> ) \n \n \t1 def test_01_VPC_nics_after_destroy ( self ) : \n \n \t2 <string_literal> <string_literal> <string_literal> \n \n <ect>
\t3 setNamespaceProperty_result result = new setNamespaceProperty_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 { \n \n \t3 MessageConsumer consumer = session . createConsumer ( queue ) ; \n \n \t3 for ( int i = 0 ; i < msgCount ; ++ i ) { \n \n \t4 if ( ( i % <number_literal> ) == 0 ) { \n \n <ect>
\t6 reader . close ( ) ; \n \n \t5 } else { \n \n \t6 mapping = packet . payload ( ) ; } \n \n \t5 if ( ! <string_literal> . equals ( index ) ) { \n \n <ect>
\t2 double left = builder . topLeft ( ) . getLon ( ) ; \n \n \t2 double bottom = builder . bottomRight ( ) . getLat ( ) ; \n \n \t2 double right = builder . bottomRight ( ) . getLon ( ) ; \n \n \t2 assumeTrue ( <string_literal> , top != bottom ) ; \n \n <ect>
\t4 ret = file . getCanonicalPath ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 LOG . error ( <string_literal> , e ) ; } \n \n \t2 } else { \n \n <ect>
\t2 return _vmDao . remove ( vm . getId ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public < T extends VMInstanceVO > boolean destroy ( T vm , User user , Account caller ) throws AgentUnavailableException , OperationTimedoutException , ConcurrentOperationException { \n \n <ect>
\t10 this . mystromClient . RestartMaster ( deviceId ) ; } } } } \n \n \t5 } catch ( Exception e ) { \n \n \t6 logger . error ( <string_literal> , command , e ) ; } } \n \n \t3 } else { \n \n <ect>
\t3 throw new RuntimeException ( e ) ; } \n \n \t2 try { \n \n \t3 sl . join ( 1000L ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t1 try { \n \n \t2 GetVolumeTokenType req = new GetVolumeTokenType ( volume . getDisplayName ( ) ) ; \n \n \t2 scGetTokenResponse = AsyncRequests . sendSync ( sc , req ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 && StringUtils . isNotBlank ( svc . getIdTokenEncryptionEncoding ( ) ) ) { \n \n \t3 innerJwt = encryptIdToken ( svc , jws , innerJwt ) ; } \n \n \t2 return innerJwt ; } \n \n \t1 private String encryptIdToken ( final OidcRegisteredService svc , final JsonWebSignature jws , final String innerJwt ) throws Exception { \n \n <ect>
\t1 private void processPublish ( RequestEvent requestEvent , \n \n \t3 ServerTransaction serverTransactionId ) { \n \n \t2 try { \n \n \t3 Request request = requestEvent . getRequest ( ) ; \n \n <ect>
\t4 . prepareStatement ( <string_literal> ) ; \n \n \t2 pstmt . setLong ( 1 , dataCenterId ) ; \n \n \t2 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t2 if ( ! rs . next ( ) ) { \n \n <ect>
\t1 bw . addMutation ( m ) ; \n \n \t1 bw . close ( ) ; \n \n \t1 log . info ( <string_literal> , tableName ) ; \n \n \t1 conn . tableOperations ( ) . online ( tableName , true ) ; \n \n <ect>
\t5 HeatpumpCommandType . TYPE_COOLING_STOP_AFTER_HOURS ) ; \n \n \t2 } catch ( UnknownHostException e ) { \n \n \t3 logger . warn ( <string_literal> , ip ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 pigLogger . warn ( this , <string_literal> , PigWarning . UDF_WARNING_2 ) ; \n \n \t3 return null ; } \n \n \t2 if ( ! accumulated ) { \n \n <ect>
\t1 } catch ( IOException e ) { \n \n \t2 if ( <string_literal> . equals ( e . getMessage ( ) ) ) { \n \n \t2 <comment> \n \n \t2 throw new IOException ( <string_literal> , e ) ; } \n \n <ect>
public static void main ( String [ ] args ) { \n \n \t1 try { \n \n \t1 throwException ( ) ; \n \n \t1 } catch ( ClassCastException castException ) { \n \n <ect>
\t7 <comment> \n \n \t7 try { \n \n \t8 retryFailed ( ) ; \n \n \t7 } catch ( Throwable t ) { <comment> \n \n <ect>
\t7 <string_literal> ) ; } \n \n \t4 config . setDeviceParam ( value ) ; \n \n \t4 <comment> \n \n \t3 } else { \n \n <ect>
\t3 long timeout , CCNHandle handle ) throws IOException { \n \n \t2 <comment> \n \n \t2 PublicKeyObject theKey = retrieve ( locator . name ( ) . name ( ) , locator . name ( ) . publisher ( ) ) ; \n \n \t2 if ( ( null != theKey ) && ( theKey . available ( ) ) ) { \n \n <ect>
\t1 throws IOException { \n \n \t1 final UriLocator uriLocator = getInstance ( uri ) ; \n \n \t1 if ( uriLocator == null ) { \n \n \t1 throw new WroRuntimeException ( <string_literal> + uri ) ; } \n \n <ect>
\t2 } catch ( SocketTimeoutException timeoutEx ) { \n \n \t3 if ( 0 < acknowledgement . length ( ) ) { \n \n \t4 log . error ( <string_literal> , timeoutEx ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 public void messageReceived ( I2NPMessage inMsg , RouterIdentity remoteIdent , Hash remoteIdentHash , long msToReceive , int bytesReceived ) { \n \n \t2 <comment> \n \n <ect>
\t3 if ( blk != Blocks . AIR ) \n \n \t3 { \n \n \t4 AEApi . instance ( ) . registries ( ) . movable ( ) . blacklistBlock ( blk ) ; \n \n \t4 return ; } } \n \n <ect>
\t2 assertThat ( response . getIndex ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 assertThat ( response . getSourceAsBytes ( ) , nullValue ( ) ) ; \n \n \t2 assertThat ( response . getField ( <string_literal> ) . getValues ( ) . get ( 0 ) . toString ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 assertThat ( response . getField ( <string_literal> ) , nullValue ( ) ) ; \n \n <ect>
\t2 waitForBridgeFormation ( ) ; \n \n \t2 <comment> \n \n \t2 Destination dest = createDestination ( <string_literal> , false ) ; \t1 \n \n \t2 <comment> \n \n <ect>
\t3 serialOutput = null ; } \n \n \t2 serialPort . close ( ) ; \n \n \t2 serialPort = null ; \n \n \t2 connected = false ; \n \n <ect>
\t3 } catch ( InterruptedException e ) { \n \n \t4 logger . error ( <string_literal> , e . getLocalizedMessage ( ) , e ) ; } \n \n \t2 } else { \n \n \t3 logger . error ( <string_literal> , voiceName ) ; \n \n <ect>
\t2 LOGGER . warn ( <string_literal> , this . groovyScript , principal . getId ( ) ) ; \n \n \t2 return principal . getId ( ) ; } \n \n \t1 private String resolveUsernameFromExternalGroovyScript ( final Principal principal , final Service service , final String scriptFile ) { \n \n \t2 try { \n \n <ect>
\t4 final Status determinedState = investigate ( attache ) ; \n \n \t4 final Status currentStatus = host . getStatus ( ) ; \n \n \t4 s_logger . info ( <string_literal> + determinedState ) ; \n \n \t4 if ( determinedState == null || determinedState == Status . Down ) { \n \n <ect>
\t2 Charset original = charset ; \n \n \t2 try { \n \n \t3 charset = Charset . forName ( name ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 content != null ? HeapResourceFactory . INSTANCE . generate ( null , content . array ( ) , 0 , content . length ( ) ) : null ) ; } } \n \n \t1 @ Override \n \n \t1 public HttpCacheEntry getCacheEntry ( final HttpHost host , final HttpRequest request ) { \n \n <ect>
\t1 public void processConnect ( final Host agent , final StartupCommand cmd , final boolean forRebalance ) throws ConnectionException { \n \n \t2 if ( ! ( cmd instanceof StartupRoutingCommand ) ) { \n \n \t3 return ; } \n \n <ect>
\t2 LOG . warn ( <string_literal> ) ; \n \n \t2 LOG . warn ( <string_literal> ) ; } \n \n \t1 if ( options . getOutputEnclosedBy ( ) != DelimiterSet . NULL_CHAR ) { \n \n \t2 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t1 array . put ( args [ i ] ) ; } \n \n \t1 try { \n \n \t1 return executeAtom ( atom , array , ke ) ; \n \n \t1 } catch ( JSONException je ) { \n \n <ect>
\t3 public boolean isSatisified ( ) throws Exception { \n \n \t4 int totalUnconsumed = 0 ; \n \n \t4 for ( TestConsumer testConsumer : testConsumers ) { \n \n \t5 long unconsumed = testConsumer . unconsumedSize ( ) ; \n \n <ect>
<comment> \n \n private static void copy ( SeekableInputStream from , PositionOutputStream to , \n \n \t6 long start , long length ) throws IOException { \n \n <ect>
\t3 String response = sendMessage ( data , timeout ) ; \n \n \t3 if ( response != null ) { \n \n \t4 notifier . notifyMessage ( new OnkyoStatusUpdateEvent ( this ) , response . getBytes ( ) , <number_literal> ) ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 poReduce . getPKGOp ( ) . getPkgr ( ) . attachInput ( key , new DataBag [ ] { ( DataBag ) t . get ( 1 ) } , new boolean [ ] { true } ) ; \n \n \t4 packagedTuple = ( Tuple ) poReduce . getPKGOp ( ) . getPkgr ( ) . getNext ( ) . result ; \n \n \t3 } catch ( ExecException e ) { \n \n \t4 throw new RuntimeException ( e ) ; } \n \n <ect>
\t1 private static UsageDao m_usageDao = _locator . getDao ( UsageDao . class ) ; \n \n \t1 private static UsageNetworkOfferingDao m_usageNetworkOfferingDao = _locator . getDao ( UsageNetworkOfferingDao . class ) ; \n \n \t1 public static boolean parse ( AccountVO account , Date startDate , Date endDate ) { \n \n <ect>
\t3 result . tnase = ( org . apache . accumulo . core . client . impl . thrift . ThriftNotActiveServiceException ) e ; \n \n \t3 result . setTnaseIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t2 JobTaskItemByHostMap tasksByHost = generateTaskCountByHost ( hosts , job . getCopyOfTasks ( ) ) ; \n \n \t2 <comment> \n \n \t2 int maxPerHost = maxTasksPerHost ( job , tasksByHost . size ( ) ) ; \n \n <ect>
\t1 try { \n \n \t2 if ( in != null ) { \n \n \t2 in . close ( ) ; } \n \n \t1 } catch ( Throwable ex ) { \n \n <ect>
\t5 if ( ! calledByProcessor ) { \n \n \t6 switch ( sd . keepAliveState ) { \n \n \t6 case NONE : { \n \n <ect>
\t2 try { \n \n \t2 if ( fileSystem . exists ( metadataPath ) ) { \n \n \t3 fileSystem . delete ( metadataPath , true ) ; } \n \n \t2 } catch ( Exception e2 ) { \n \n <ect>
\t3 exception = null ; \n \n \t3 try { \n \n \t4 onExecuteFinished ( result , executableContext ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 proxy . getAttributes ( ) . forEach ( connector : : setAttribute ) ; \n \n \t4 LOGGER . info ( <string_literal> , tomcat . getPort ( ) ) ; \n \n \t3 } ) ; \n \n \t2 } else { \n \n <ect>
\t6 } else { \n \n \t7 s_logger . info ( <string_literal> + responseCode ) ; \n \n \t7 windowsVMPrivateIP = values . get ( <string_literal> ) ; \n \n \t7 long windowsVMId = Long . parseLong ( values . get ( <string_literal> ) ) ; \n \n <ect>
\t3 for ( TransactionInput input : req . tx . getInputs ( ) ) \n \n \t4 if ( input . getConnectedOutput ( ) != null ) \n \n \t5 totalInput = totalInput . add ( input . getConnectedOutput ( ) . getValue ( ) ) ; \n \n \t4 else \n \n <ect>
\t2 NetworkOffering offering = getFirst ( \n \n \t3 client . getOfferingApi ( ) . listNetworkOfferings ( \n \n \t3 ListNetworkOfferingsOptions . Builder . zoneId ( template . getZoneId ( ) ) . specifyVLAN ( true ) ) , null ) ; \n \n \t2 checkNotNull ( offering , <string_literal> ) ; \n \n <ect>
\t1 public void afterTest ( ) { \n \n \t2 try { \n \n \t3 camelContext . stopRoute ( CamelTestConfiguration . SIMPLE_ROUTE_ID ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t2 public void reconnectingIn ( int i ) \n \n \t2 { \n \n <ect>
\t3 empty . setString ( 0 , <string_literal> ) ; \n \n \t3 ret = vrOverlay . ShowKeyboard . apply ( 0 , 0 , pointer , <number_literal> , empty , ( byte ) 1 , 0 ) ; \n \n \t3 keyboardShowing = 0 == ret ; <comment> \n \n \t3 if ( ret != 0 ) { \n \n <ect>
\t3 return rv ; } \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t5 public boolean isTrusted ( X509Certificate [ ] arg0 , String arg1 ) throws CertificateException { \n \n \t6 return true ; } \n \n \t4 } ) . build ( ) ) ; \n \n \t3 } catch ( KeyManagementException e ) { \n \n <ect>
\t4 numberOfMessageSent ++ ; } \n \n \t3 LOG . info ( <string_literal> + numberOfMessageSent ) ; \n \n \t3 return numberOfMessageSent ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 <comment> \n \n \t4 return false ; } \n \n \t3 return true ; \n \n \t2 } catch ( DSpaceSwordException e ) { \n \n <ect>
\t2 final Optional < DistributedCacheObject < RegisteredService > > result = this . distributedCacheManager . find ( predicate ) ; \n \n \t2 if ( result . isPresent ( ) ) { \n \n \t3 final DistributedCacheObject < RegisteredService > item = result . get ( ) ; \n \n \t3 final RegisteredService cachedService = item . getValue ( ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public WebSocket write ( AtmosphereResponse r , String data ) throws IOException { \n \n \t2 firstWrite . set ( true ) ; \n \n \t2 if ( data == null ) { \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 s_logger . debug ( <string_literal> + host . getId ( ) ) ; \n \n \t6 continue ; } } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 fileRead ( contents ) } \n \n \t1 override fun loginActivity ( ) : KClass < * > ? { \n \n \t2 return LoginScreen : : class } \n \n \t1 private fun setWatching ( path : String ) { \n \n <ect>
\t2 params . put ( <string_literal> , uri . toString ( ) ) ; \n \n \t2 try { \n \n \t3 storage . configure ( <string_literal> , params ) ; \n \n \t2 } catch ( ConfigurationException e ) { \n \n <ect>
\t3 Account systemAcct = _accountMgr . getSystemAccount ( ) ; \n \n \t3 User systemUser = _accountMgr . getSystemUser ( ) ; \n \n \t3 return _itMgr . start ( secStorageVm , null , systemUser , systemAcct ) ; \n \n \t2 } catch ( StorageUnavailableException e ) { \n \n <ect>
\t2 if ( ! engine . isLazy ( ) ) { \n \n \t3 LOG . info ( <string_literal> , engine . getUri ( ) ) ; \n \n \t3 engine . start ( ) ; \n \n \t2 } else { \n \n <ect>
\t1 public Map getConfiguration ( final HttpServletRequest request , final HttpServletResponse response ) { \n \n \t2 final Map results = new TreeMap ( ) ; \n \n \t2 ensureEndpointAccessIsAuthorized ( request , response ) ; \n \n \t2 if ( environmentEndpoint == null || ! environmentEndpoint . isEnabled ( ) ) { \n \n <ect>
\t1 threadTwo . startAndWaitUntilControlIsReturned ( ) ; \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n \t1 threadOne . proceedAndWaitTillDone ( ) ; \n \n \t1 assertNull ( threadOne . exception ) ; \n \n <ect>
\t4 if ( applicationContext . containsBean ( <string_literal> ) ) { \n \n \t5 LOGGER . debug ( <string_literal> ) ; \n \n \t5 repository = applicationContext . getBean ( <string_literal> , PrincipalAttributesRepository . class ) ; \n \n \t4 } else { \n \n <ect>
\t3 String output = JStormUtils . launchProcess ( sb . toString ( ) , new HashMap < String , String > ( ) , false ) ; \n \n \t3 BufferedReader reader = new BufferedReader ( new StringReader ( output ) ) ; \n \n \t3 JStormUtils . sleepMs ( <number_literal> ) ; \n \n \t3 <comment> \n \n <ect>
\t6 indexFailures = mutator . commitIndexes ( ) ; \n \n \t6 if ( ! indexFailures . isEmpty ( ) ) { \n \n \t7 status = LogTxStatus . SECONDARY_FAILURE ; \n \n \t7 for ( Map . Entry < String , Throwable > entry : indexFailures . entrySet ( ) ) { \n \n <ect>
\t4 System . out . println ( <string_literal> ) ; } \n \n \t3 Pair < Boolean , String > result = SshHelper . sshExecute ( <string_literal> , <number_literal> , <string_literal> , file , null , <string_literal> ) ; \n \n \t3 System . out . println ( <string_literal> + result . second ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 connection . start ( ) ; \n \n \t2 Session session2 = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; \n \n \t2 consumer = session2 . createConsumer ( destination ) ; \n \n \t2 msg = consumer . receive ( <number_literal> ) ; \n \n <ect>
\t1 public Long [ ] getDisabledVmsForScheduler ( ) { \n \n \t2 Long [ ] result = new Long [ _disabledVms . size ( ) ] ; \n \n \t2 return _disabledVms . toArray ( result ) ; } \n \n \t1 public void enableAllVmsForScheduler ( ) { \n \n <ect>
\t3 LogLog . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n \t3 LogLog . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( InvocationTargetException e ) { \n \n <ect>
\t3 case ChatFocusEvent . FOCUS_LOST : \n \n \t4 listener . chatFocusLost ( evt ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t8 . lastIndexOf ( File . separator ) ) ; \n \n \t7 File fdirs = new File ( destDir + File . separator \n \n <number_literal> + dirs ) ; \n \n \t7 if ( ! fdirs . exists ( ) && ! fdirs . mkdirs ( ) ) { \n \n <ect>
\t2 eventListener . waitForEvents ( Master . TIME_TO_WAIT_BETWEEN_SCANS ) ; \n \n \t2 } else { \n \n \t2 Master . log . info ( <string_literal> ) ; } \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t2 synchronized ( s_features ) { \n \n \t3 if ( s_features . containsKey ( s ) ) { \n \n \t4 f = s_features . get ( s ) . build ( ) ; \n \n \t3 } else { \n \n <ect>
\t3 if ( ! knownCorruption . isEmpty ( ) ) { \n \n \t4 LOG . error ( <string_literal> + knownCorruption ) ; \n \n \t4 throw new IOException ( <string_literal> + knownCorruption ) ; } \n \n \t3 if ( ! missingJournalFiles . isEmpty ( ) ) { \n \n <ect>
\t1 private static String findJar ( String className , String perferLibraryName ) { \n \n \t2 try { \n \n \t3 return ClassUtil . findContainingJar ( Class . forName ( className ) , perferLibraryName ) ; \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t2 DataCenter dc = _dcDao . findById ( network . getDataCenterId ( ) ) ; \n \n \t2 String interfaceMac = nic . getMacAddress ( ) ; \n \n \t2 List < BrocadeVcsDeviceVO > devices = _brocadeVcsDao . listByPhysicalNetwork ( network . getPhysicalNetworkId ( ) ) ; \n \n \t2 if ( devices . isEmpty ( ) ) { \n \n <ect>
\t2 Instructions instructions = new Instructions ( getProject ( ) . getProperty ( Constants . REMOVEHEADERS ) ) ; \n \n \t2 Collection < Object > result = instructions . select ( main . keySet ( ) , false ) ; \n \n \t2 main . keySet ( ) \n \n \t3 . removeAll ( result ) ; \n \n <ect>
\t2 equalsIgnoreCase ( hiveConf . getVar ( ConfVars . HIVE_SERVER2_AUTHENTICATION ) ) ) { \n \n \t1 return proxyUser ; } \n \n \t1 <comment> \n \n \t1 HiveAuthFactory . verifyProxyAccess ( realUser , proxyUser , ipAddress , hiveConf ) ; \n \n <ect>
\t2 try { \n \n \t3 userDetails = ldapUserDetailsService . loadUserByUsername ( userName ) ; \n \n \t2 } catch ( org . springframework . security . core . userdetails . UsernameNotFoundException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; } \n \n <ect>
\t2 if ( vo . getHypervisorType ( ) != HypervisorType . BareMetal ) { \n \n \t3 return true ; } \n \n \t2 HostVO host = _hostDao . findById ( vo . getHostId ( ) ) ; \n \n \t2 if ( host == null ) { \n \n <ect>
\t2 return keyCache . size ( ) ; } \n \n \t1 public void saveCaches ( ) throws ExecutionException , InterruptedException \n \n \t1 { \n \n \t2 List < Future < ? > > futures = new ArrayList < > ( <number_literal> ) ; \n \n <ect>
@ Test \n \n public void testGetRolesForUser ( ) throws Exception { \n \n \t1 List < String > userAuths = dao . getRolesForUser ( null , <string_literal> ) ; <comment> \n \n <ect>
\t4 FileUtils . deleteDirectory ( testDir ) ; \n \n \t3 } else { \n \n \t4 testDir . delete ( ) ; } \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t6 } else { \n \n \t7 final HostVO host = _hostDao . findById ( agentId ) ; \n \n \t7 if ( host != null \n \n \t9 && ( host . getType ( ) == Host . Type . ConsoleProxy || host . getType ( ) == Host . Type . SecondaryStorageVM || host . getType ( ) == Host . Type . SecondaryStorageCmdExecutor ) ) { \n \n <ect>
\t4 String mgmtHost = ( String ) params . get ( <string_literal> ) ; \n \n \t4 addRouteToInternalIpOrCidr ( _localgw , _eth1ip , _eth1mask , mgmtHost ) ; \n \n \t4 String internalDns1 = ( String ) params . get ( <string_literal> ) ; \n \n \t4 if ( internalDns1 == null ) { \n \n <ect>
\t1 { \n \n \t1 _reader . onInit ( rh ) ; } \n \n \t1 catch ( RuntimeException ex ) \n \n \t1 { \n \n <ect>
\t2 LOGGER . info ( <string_literal> , token ) ; } \n \n \t1 private void configureJwtEncryption ( final int encryptionSecretSize , final String encryptionAlgorithm , \n \n \t10 final String encryptionMethod , final JwtGenerator < CommonProfile > g ) { \n \n \t2 if ( encryptionSecretSize < = 0 || StringUtils . isBlank ( encryptionMethod ) || StringUtils . isBlank ( encryptionAlgorithm ) ) { \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName + <string_literal> + replDumpId , driver ) ; \n \n \t1 String postDropReplDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String postDropReplDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t4 id = leader . lastProposed ; } \n \n \t3 QuorumPacket ping = new QuorumPacket ( Leader . PING , id , null , null ) ; \n \n \t3 queuePacket ( ping ) ; \n \n \t2 } else { \n \n <ect>
\t5 candidates . add ( entry . getValue ( ) ) ; } \n \n \t3 for ( ClusterServiceRequestPdu pdu : candidates ) { \n \n \t4 _outgoingPdusWaitingForAck . remove ( pdu . getSequenceId ( ) ) ; } } \n \n \t2 for ( ClusterServiceRequestPdu pdu : candidates ) { \n \n <ect>
\t3 logger . error ( e . getMessage ( ) , e ) ; \n \n \t3 em . getTransaction ( ) . rollback ( ) ; \n \n \t2 } finally { \n \n \t3 em . close ( ) ; } \n \n <ect>
public void removeFromRoles ( webobjectsexamples . businesslogic . eo . MovieRole object ) { \n \n \t1 excludeObjectFromPropertyWithKey ( object , _Movie . ROLES_KEY ) ; } \n \n public void addToRolesRelationship ( webobjectsexamples . businesslogic . eo . MovieRole object ) { \n \n <ect>
\t4 valueList . add ( bytes ( v ) ) ; } \n \n \t3 QueryProcessor . process ( fmtQry , ConsistencyLevel . ONE , valueList ) ; } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t4 || ( ( ( WsrmContainer ) wsdlRequest ) . getWsrmConfig ( ) . getSequenceIdentifier ( ) == null ) ) { \n \n \t3 return ; } \n \n \t2 String content = ( String ) context . getProperty ( BaseHttpRequestTransport . REQUEST_CONTENT ) ; \n \n \t2 if ( content == null ) { \n \n <ect>
\t3 _docResponse = docBuilder . parse ( new InputSource ( new StringReader ( _xmlResponse ) ) ) ; \n \n \t3 if ( _docResponse != null ) { \n \n \t4 parse ( _docResponse . getDocumentElement ( ) ) ; } \n \n \t2 } catch ( ParserConfigurationException e ) { \n \n <ect>
\t3 . filter ( entry - > entry . getRecordDate ( ) . isEqual ( onOrBefore ) || entry . getRecordDate ( ) . isBefore ( onOrBefore ) ) \n \n \t3 . sorted ( ) \n \n \t3 . distinct ( ) \n \n \t3 . collect ( Collectors . toSet ( ) ) ; \n \n <ect>
\t4 return record . getReference ( ) ; \n \n \t3 } else { \n \n \t4 log . debug ( <string_literal> , blobId ) ; } \n \n \t2 } catch ( DataStoreException e ) { \n \n <ect>
\t3 StyleInfo style = factory . createStyle ( ) ; \n \n \t3 style . setName ( ( String ) entry . getKey ( ) ) ; \n \n \t3 style . setFilename ( ( String ) entry . getValue ( ) ) ; \n \n \t3 catalog . add ( style ) ; \n \n <ect>
\t2 return applyRules ( network , router , typeString , isPodLevelException , podId , failWhenDisconnect , new RuleApplierWrapper < RuleApplier > ( keyToRouterRules ) ) ; } \n \n \t1 @ Override \n \n \t1 public boolean saveUserDataToRouter ( final Network network , final NicProfile nic , final VirtualMachineProfile profile , final VirtualRouter router ) \n \n \t3 throws ResourceUnavailableException { \n \n <ect>
\t7 log . warn ( <string_literal> , soLingerEx ) ; } \n \n \t6 try { \n \n \t7 clientSocket . close ( ) ; \n \n \t6 } catch ( IOException ioEx ) { \n \n <ect>
\t1 refreshHelper . refresh ( alreadyRefreshed ) ; } \n \n private void reload ( ) { \n \n \t1 try { \n \n \t1 <comment> \n \n <ect>
\t2 try { \n \n \t3 ret = supervisor_local_dir ( conf ) + FILE_SEPERATEOR + <string_literal> ; \n \n \t3 FileUtils . forceMkdir ( new File ( ret ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t8 <comment> \n \n \t8 if ( data . startsWith ( commandResponse ) ) { \n \n \t9 match = true ; } } \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t5 new DefaultHostnameVerifier ( ) ) ; <comment> \n \n \t2 } catch ( KeyManagementException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( NoSuchAlgorithmException e ) { \n \n <ect>
\t2 < p > Reload this page with open console , enter text and hit the log button . . . < / p > \n \n \t2 Message : \n \n \t2 < input type = <string_literal> ng - model = <string_literal> / > \n \n \t2 < button ng - click = <string_literal> > log < / button > \n \n <ect>
\t2 if ( eventStr != null ) { \n \n \t3 try { \n \n \t4 event = Integer . parseInt ( eventStr ) ; \n \n \t3 } catch ( NumberFormatException e ) { \n \n <ect>
\t3 throw new RepositoryException ( metadata . name ( ) , <string_literal> ) ; } \n \n \t2 Path locationFile = environment . resolveRepoFile ( location ) ; \n \n \t2 if ( locationFile == null ) { \n \n \t3 if ( environment . repoFiles ( ) . length > 0 ) { \n \n <ect>
\t1 RuntimeStatsSource rss = context . getRuntimeStatsSource ( ) . get ( ) ; \n \n \t1 Optional < OperatorStats > os = rss . lookup ( op ) ; \n \n \t1 if ( ! os . isPresent ( ) ) { \n \n \t1 return stats ; } \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t1 private ASTNode nodeOfInterest ; \n \n \t1 private Type \t1 type = Type . NONE ; \n \n \t1 private void set ( Type type , ASTNode ast ) { \n \n \t1 if ( this . type != Type . NONE ) { \n \n <ect>
\t3 operationalInfo . put ( <string_literal> , md . getDatabaseProductName ( ) + <string_literal> + md . getDatabaseProductVersion ( ) ) ; \n \n \t3 operationalInfo . put ( <string_literal> , md . getDriverName ( ) + <string_literal> + md . getDriverVersion ( ) ) ; \n \n \t3 logger . debugf ( <string_literal> , operationalInfo . toString ( ) ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 StoragePoolVO poolVO = this . primaryStoreDao . findById ( poolId ) ; \n \n \t2 poolVO . setUsedBytes ( mspAnswer . getPoolInfo ( ) . getCapacityBytes ( ) - mspAnswer . getPoolInfo ( ) . getAvailableBytes ( ) ) ; \n \n \t2 poolVO . setCapacityBytes ( mspAnswer . getPoolInfo ( ) . getCapacityBytes ( ) ) ; \n \n \t2 primaryStoreDao . update ( pool . getId ( ) , poolVO ) ; \n \n <ect>
\t2 args . transportFactory ( ( TTransportFactory ) new TZlibTransport . Factory ( ) ) ; \n \n \t2 server = new TThreadPoolServer ( args ) ; \n \n \t2 Runnable simple = new Runnable ( ) { \n \n \t3 public void run ( ) { \n \n <ect>
\t5 LOG . warn ( <string_literal> ) ; \n \n \t4 } else { \n \n \t5 LOG . debug ( <string_literal> ) ; } \n \n \t3 } else { \n \n <ect>
\t2 try { \n \n \t3 perfTestService . markProgressAndStatusAndFinishTimeAndStatistics ( perfTest , Status . STOP_BY_ERROR , \n \n \t5 <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 if ( resource == null ) { \n \n \t3 throw new MissingResourceException ( metadataLocation . getUri ( ) , String . format ( <string_literal> , metadataLocation ) ) ; } \n \n \t2 parseMavenMetadataInto ( resource , metadata ) ; } \n \n \t1 private void parseMavenMetadataInto ( ExternalResource metadataResource , final MavenMetadata mavenMetadata ) { \n \n <ect>
\t4 NetworkFailuresProxy proxy = createProxy ( KAFKA_HOST , kafkaPort ) ; \n \n \t4 kafkaProperties . put ( <string_literal> , proxy . getLocalPort ( ) ) ; } \n \n \t3 <comment> \n \n \t3 if ( config . isSecureMode ( ) ) { \n \n <ect>
\t2 if ( holder . isGenerateRefreshToken ( ) ) { \n \n \t3 refreshToken = generateRefreshToken ( holder ) ; \n \n \t3 LOGGER . debug ( <string_literal> , refreshToken ) ; \n \n \t2 } else { \n \n <ect>
\t2 } catch ( IllegalArgumentException e ) { \n \n \t3 s_logger . error ( <string_literal> + target . getClass ( ) . getName ( ) + <string_literal> + handler . getName ( ) , e ) ; \n \n \t3 throw new RuntimeException ( <string_literal> + subject ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n <ect>
\t2 offset = <string_literal> ; } \n \n \t2 else { \n \n \t2 p . inc ( ) ; \n \n \t2 offset = p . toString ( ) ; \n \n <ect>
\t4 <comment> \n \n \t4 ex . setCSErrorCode ( ref . getCSErrorCode ( ) ) ; \n \n \t4 throw ex ; \n \n \t3 } else if ( t instanceof ResourceUnavailableException ) { \n \n <ect>
\t3 while ( namesIter . hasNext ( ) && valueIter . hasNext ( ) ) { \n \n \t4 String name = namesIter . next ( ) . getStringValue ( ) ; \n \n \t4 String value = valueIter . next ( ) . getStringValue ( ) ; \n \n <ect>
\t3 if ( structrWorkingDir == null || structrWorkingDir instanceof File ) { \n \n \t4 return new StructrFtpFolder ( securityContext , null ) ; } \n \n \t3 return new StructrFtpFolder ( securityContext , ( Folder ) structrWorkingDir ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 LOG . info ( <string_literal> ) ; } \n \n \t2 @ Override \n \n \t2 public void onMode ( String string , IRCUser ircUser , IRCModeParser ircModeParser ) { \n \n \t3 super . onMode ( string , ircUser , ircModeParser ) ; \n \n <ect>
\t3 try { \n \n \t4 ObjectName objectName = createNetworkConnectorObjectName ( connector ) ; \n \n \t4 getManagementContext ( ) . unregisterMBean ( objectName ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n public enum RestxLogLevel { \n \n \t1 VERBOSE { \n \n \t2 public void log ( Logger logger , RestxRequest restxRequest , RestxResponse restxResponse , Stopwatch stopwatch ) { \n \n <ect>
\t3 if ( id instanceof String ) { \n \n \t4 String name = ( String ) id ; \n \n \t4 Object value = scope . get ( name , scope ) ; \n \n \t4 if ( ! ( value instanceof NativeFunction ) ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void validateItemType ( Item item , String bindingConfig ) throws BindingConfigParseException { \n \n <ect>
\t3 for ( int j = 0 ; j < <number_literal> ; j ++ ) { \n \n \t4 c . setProperty ( <string_literal> + j , nodeStore . createBlob ( randomStream ( j , <number_literal> ) ) ) ; } } \n \n \t2 nodeStore . merge ( a , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; \n \n \t2 final long dataSize = store . getStats ( ) . getApproximateSize ( ) ; \n \n <ect>
\t2 if ( ! leaseSet . verifySignature ( ) ) { \n \n \t3 <comment> \n \n \t3 processStoreFailure ( key , leaseSet ) ; \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 rotateOutputFile ( false ) ; \n \n \t4 this . rotationPolicy . reset ( ) ; \n \n \t4 if ( nBytes > 0 ) { \n \n \t5 doRecover ( srcPath , nBytes ) ; \n \n <ect>
\t5 NSNotification notification = new NSNotification ( name , object , userInfo ) ; \n \n \t6 log . debug ( <string_literal> , notification ) ; \n \n <ect>
<comment> \n \n \t1 protected OAuthToken getOAuthTokenFromRequest ( final HttpServletRequest request ) { \n \n \t2 final OAuthToken token = this . ticketRegistry . getTicket ( getOAuthParameter ( request ) , OAuthToken . class ) ; \n \n \t2 if ( token == null || token . isExpired ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 boolean ssuOK = ip != null ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 Date valueDate = getDate ( value . getYear ( ) , value . getMonth ( ) , value . getDay ( ) , value . getHour ( ) , value \n \n \t6 . getMinute ( ) , value . getSecond ( ) ) ; \n \n \t4 obs . setValueDatetime ( valueDate ) ; \n \n \t3 } else { \n \n <ect>
\t2 ) ; \n \n \t2 consoleCommunication . sendMessage ( new LogReportGrinderMessage ( testId , compressedLog , new AgentAddress ( m_agentIdentity ) ) ) ; \n \n \t2 <comment> \n \n \t2 if ( ! agentConfig . getAgentProperties ( ) . getPropertyBoolean ( PROP_AGENT_KEEP_LOGS ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( StringUtils . isNotBlank ( _showConditions ) && Boolean . FALSE . equals ( Scripting . evaluate ( renderContext , thisNode , <string_literal> . concat ( _showConditions ) . concat ( <string_literal> ) , <string_literal> ) ) ) { \n \n \t4 return false ; } \n \n \t2 } catch ( UnlicensedException | FrameworkException ex ) { \n \n <ect>
\t2 VolumeApiResult result = new VolumeApiResult ( volume ) ; \n \n \t2 try { \n \n \t3 volume . processEvent ( Event . ResizeRequested ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 private static int countContainerMember ( Graph graph , Node container , Node containerType , Node member , boolean stopEarly ) \n \n \t1 { \n \n \t2 if ( graph == null ) \n \n \t2 { \n \n <ect>
\t5 logger . info ( <string_literal> , message ) ; \n \n \t4 } else { \n \n \t5 logger . warn ( <string_literal> , message ) ; } } \n \n \t2 } else { \n \n <ect>
\t3 else if ( NOTFOUND . equals ( line ) ) { \n \n \t5 log . info ( <string_literal> + key + <string_literal> ) ; } \n \n \t3 else { \n \n <ect>
\t2 sendExecutor . shutdown ( ) ; \n \n \t2 sendExecutor . awaitTermination ( <number_literal> , TimeUnit . MINUTES ) ; \n \n \t2 boolean allMessagesReceived = messagesReceivedCountDown . await ( <number_literal> , TimeUnit . MINUTES ) ; \n \n \t2 if ( ! allMessagesReceived ) { \n \n <ect>
\t2 return \n \n \t1 @ attr ( tags = [ <string_literal> , <string_literal> , <string_literal> ] , required_hardware = <string_literal> ) \n \n \t1 def test_02_isolate_network_FW_PF_default_routes_egress_false ( self ) : \n \n \t2 <string_literal> <string_literal> <string_literal> \n \n <ect>
\t4 public void onCompleted ( ) { \n \n \t5 try { \n \n \t6 executionHook . onExecutionSuccess ( cmd ) ; \n \n \t5 } catch ( Throwable hookEx ) { \n \n <ect>
<comment> \n \n \t2 void write ( byte [ ] b ) throws IOException { \n \n \t3 if ( sock == null || ! sock . isConnected ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 ringInfo = buildRingInfo ( ) ; \n \n \t2 if ( ringInfo != null && ringInfo . isEmpty ( ) ) { \n \n \t2 ringInfo = null ; \n \n <ect>
\t5 if ( dist > nodeStats . furthestSlashdotCacheCHKSuccess ) \n \n \t5 nodeStats . furthestSlashdotCacheCHKSuccess = dist ; \n \n \t5 return block ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 public final void handleRequest ( ServerHttpRequest request , ServerHttpResponse response , \n \n \t3 @ Nullable String sockJsPath , WebSocketHandler wsHandler ) throws SockJsException { \n \n \t2 if ( sockJsPath == null ) { \n \n <ect>
\t5 byte [ ] data = OpenSSL . decrypt ( StringUtils . isNullOrEmpty ( encryptionAlgorithm ) ? <string_literal> : encryptionAlgorithm , password , encryptedContent ) ; \n \n \t5 try { \n \n \t6 settingsDocument = SoapuiSettingsDocumentConfig . Factory . parse ( new String ( data , <string_literal> ) ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 ranges = stringToAcceptList ( headerString ) ; } \n \n \t2 catch ( Exception ex ) { \n \n \t3 ex . printStackTrace ( System . err ) ; \n \n <ect>
\t1 public int testUse ( @ PathParam ( <string_literal> ) int count ) { \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + readerEJB . getUses ( ) ) ; \n \n \t2 log . info ( <string_literal> + writerEJB . getUses ( ) ) ; \n \n <ect>
\t3 try { \n \n \t4 boolean batchSupported = true ; \n \n \t4 if ( ! JdbcUtils . supportsBatchUpdates ( ps . getConnection ( ) ) ) { \n \n \t5 batchSupported = false ; \n \n <ect>
\t1 public void setTypeConverterHolder ( TypeConverterHolder converterHolder ) { \n \n \t2 this . converterHolder = converterHolder ; } \n \n \t1 @ Override \n \n \t1 public void init ( ) { \n \n <ect>
\t2 if ( code == Code . NONODE ) { \n \n \t3 log . error ( <string_literal> + e . getPath ( ) , e ) ; \n \n \t2 } else if ( code == Code . CONNECTIONLOSS || code == Code . OPERATIONTIMEOUT \n \n \t3 || code == Code . SESSIONEXPIRED ) { \n \n <ect>
\t5 s_logger . error ( <string_literal> , e ) ; \n \n \t4 } finally { \n \n \t5 lock . unlock ( ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public static String subst ( final String value , final Properties props ) { \n \n \t2 try { \n \n \t3 return OptionConverter . substVars ( value , props ) ; \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
<comment> \n \n public JobData read ( String jobName ) throws IOException { \n \n \t1 try { \n \n \t1 if ( ! jobExists ( jobName ) ) { \n \n <ect>
\t6 . getDefaultJainSipProvider ( ) \n \n \t6 . getNewClientTransaction ( req ) ; } \n \n \t4 catch ( TransactionUnavailableException e ) \n \n \t4 { \n \n <ect>
\t2 LOGGER . info ( <string_literal> , connectorAddress ) ; \n \n \t2 try { \n \n \t3 daemonRegistry . markState ( connectorAddress , Canceled ) ; \n \n \t2 } catch ( DaemonRegistry . EmptyRegistryException e ) { \n \n <ect>
\t2 if ( null != manager ) { \n \n \t2 manager . close ( ) ; } \n \n \t1 } catch ( SQLException sqlE ) { \n \n \t2 LOG . warn ( <string_literal> + sqlE ) ; } } \n \n <ect>
\t2 super ( connection ) ; \n \n \t2 engineType = tableType ; \n \n \t2 if ( engineType == null ) \n \n \t2 { \n \n <ect>
\t5 log . error ( <string_literal> + connection . getServer ( ) . toString ( ) ) ; \n \n \t5 connectionPool . markServerDown ( connection ) ; \n \n \t5 try { Thread . sleep ( Math . min ( i + 1 , <number_literal> ) * <number_literal> ) ; } catch ( InterruptedException e ) { } <comment> \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 applicationStatus , \n \n \t4 diagnostics ) . whenComplete ( \n \n \t4 ( Void ignored , Throwable t ) - > { \n \n \t5 if ( t != null ) { \n \n <ect>
\t3 . range ( 1 , <number_literal> ) <comment> \n \n \t3 . forEach ( i - > f . bars . add ( new Bar ( <string_literal> + i + <string_literal> + f . name ) ) ) ) ; <comment> \n \n \t1 Stream . of ( <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> ) <comment> \n \n \t2 . filter ( s - > { <comment> \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n <ect>
\t4 SkipList < Integer , Properties > rev = _bf . getIndex ( REVERSE_SKIPLIST , _hashIndexSerializer , _infoSerializer ) ; \n \n \t4 if ( rev == null ) { \n \n \t5 rev = _bf . makeIndex ( REVERSE_SKIPLIST , _hashIndexSerializer , _infoSerializer ) ; \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
@ Override \n \n protected void doAfterStart ( ) { \n \n \t1 GlobalAnalysisMode analysisMode = getComponentByType ( GlobalAnalysisMode . class ) ; \n \n \t1 InputModuleHierarchy tree = getComponentByType ( InputModuleHierarchy . class ) ; \n \n <ect>
\t1 private void save ( JFreeChart chart , String pngFile ) { \n \n \t2 try { \n \n \t3 ChartUtilities . saveChartAsPNG ( new File ( pngFile ) , chart , <number_literal> , <number_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void enable ( ) { \n \n <ect>
\t2 _classMap . put ( <string_literal> , net . juniper . contrail . api . types . Domain . class ) ; \n \n \t2 _classMap . put ( <string_literal> , net . juniper . contrail . api . types . Project . class ) ; } \n \n \t1 @ MessageHandler ( topic = <string_literal> ) \n \n \t1 public void defaultMessageHandler ( String subject , String topic , Object args ) { \n \n <ect>
\t2 final NicProfile nicProfile = _networkModel . getNicProfile ( router , privateNetwork . getId ( ) , null ) ; \n \n \t2 s_logger . debug ( <string_literal> + gateway + <string_literal> + router ) ; \n \n \t2 result = setupVpcPrivateNetwork ( router , false , nicProfile ) ; \n \n \t2 if ( ! result ) { \n \n <ect>
\t1 private Map < String , Map < String , String > > parseMetaData ( ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 Map < String , Map < String , String > > metaValues = new HashMap < String , Map < String , String > > ( ) ; \n \n <ect>
public void fail ( String message ) { \n \n \t1 outputClient . fail ( message ) ; \n \n \t1 close ( ) ; } \n \n void close ( ) { \n \n <ect>
\t1 } catch ( Exception e1 ) { \n \n \t2 try { \n \n \t2 conf = Transactions . find ( new DASInfo ( ) ) ; \n \n \t2 } catch ( Exception e2 ) { \n \n <ect>
\t5 listOfLocations . add ( crlFetched ) ; \n \n \t4 } else { \n \n \t5 LOGGER . warn ( <string_literal> , url ) ; } \n \n \t3 } else { \n \n <ect>
\t1 JobHandleImpl < ? > handle = jobs . get ( msg . id ) ; \n \n \t1 if ( handle != null ) { \n \n \t2 handle . changeState ( JobHandle . State . STARTED ) ; \n \n \t1 } else { \n \n <ect>
<number_literal> final HttpServletRequest request , \n \n <number_literal> final RequestAbstractType authnRequest , \n \n <number_literal> final SamlRegisteredServiceServiceProviderMetadataFacade adaptor ) throws Exception { \n \n \t2 if ( ! SAMLBindingSupport . isMessageSigned ( ctx ) ) { \n \n <ect>
public LogLevelQueryResponse sendLogLevelQueryRequest ( String componentName , String hostName ) { \n \n \t1 try { \n \n \t1 <comment> \n \n \t1 URI logLevelQueryURI = createLogLevelQueryURI ( protocol , componentName , hostName ) ; \n \n <ect>
\t3 res = backend . call_noexception ( WranglerRefactoringBackend . MODULE , functionName , signature , parameters ) ; \n \n \t2 } else { \n \n \t3 res = backend . call_noexception ( timeout , WranglerRefactoringBackend . MODULE , functionName , signature , \n \n \t5 parameters ) ; } \n \n <ect>
\t3 if ( store != null && store . isActive ( ) ) { \n \n \t4 try { \n \n \t5 store . rollbackTrx ( ) ; } \n \n \t4 catch ( RuntimeException rex ) { \n \n <ect>
\t2 String hypervisor = cmd . getContextParam ( <string_literal> ) ; \n \n \t2 if ( hypervisor != null ) { \n \n \t3 Hypervisor . HypervisorType hypervisorType = Hypervisor . HypervisorType . getType ( hypervisor ) ; \n \n \t3 if ( hypervisorType == null ) { \n \n <ect>
\t1 public boolean load ( IResourceManager manager , ResourceLocation location , Function < ResourceLocation , TextureAtlasSprite > textureGetter ) { \n \n \t2 location = SpriteUtil . transformLocation ( srcLocation ) ; \n \n \t2 TextureAtlasSprite src = Minecraft . getMinecraft ( ) . getTextureMapBlocks ( ) . getTextureExtry ( srcLocation . toString ( ) ) ; \n \n \t2 if ( src == null ) { \n \n <ect>
\t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 return error ( ) ; } \n \n \t2 final String to = passwordManagementService . findEmail ( username ) ; \n \n \t2 if ( StringUtils . isBlank ( to ) ) { \n \n <ect>
\t2 MBeanServer mbeanServer = ManagementFactory . getPlatformMBeanServer ( ) ; \n \n \t2 try { \n \n \t3 mbeanServer . unregisterMBean ( objectName ) ; \n \n \t2 } catch ( Throwable ex ) { \n \n <ect>
\t2 try { \n \n \t3 _runner . doSend ( msg ) ; \n \n \t2 } catch ( I2CPMessageException ime ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
<number_literal> usageIterator ++ ; } \n \n \t10 if ( ( users == null ) && ( accountName == null ) ) { \n \n <number_literal> s_logger . info ( <string_literal> ) ; \n \n <number_literal> int cleanupResponseCode = executeCleanup ( server , developerServer , username ) ; \n \n <ect>
\t1 } catch ( final NumberFormatException ex ) { \n \n \t1 printHelp ( opts , <string_literal> ) ; \n \n \t1 System . exit ( 1 ) ; } \n \n \t1 initLogs ( ) ; \n \n <ect>
\t3 if ( acceptTransportType == ProtocolFactory . SOCKET ) { \n \n \t4 useSSL = true ; \n \n \t4 sslConfig = SSLSupport . getSslConfig ( getSettings ( ) , sessionID ) ; \n \n \t3 } else { \n \n <ect>
\t2 if ( destPrimaryStorage != null && ( volumeToAttach . getState ( ) == Volume . State . Allocated || volumeOnSecondary ) ) { \n \n \t3 try { \n \n \t4 newVolumeOnPrimaryStorage = _volumeMgr . createVolumeOnPrimaryStorage ( vm , volumeToAttach , rootDiskHyperType , destPrimaryStorage ) ; \n \n \t3 } catch ( NoTransitionException e ) { \n \n <ect>
\t1 public void testAssertionBadXSDFile ( ) throws Exception { \n \n \t2 result . setResponseData ( readFile ( <string_literal> ) ) ; \n \n \t2 assertion . setXsdFileName ( <string_literal> ) ; \n \n \t2 AssertionResult res = assertion . getResult ( jmctx . getPreviousResult ( ) ) ; \n \n <ect>
\t2 private MemoryLocks . LockToken lock ; \n \n \t2 public PauseTransitRunnable ( ) { \n \n \t3 jpaService = Services . get ( ) . get ( JPAService . class ) ; \n \n \t3 if ( jpaService == null ) { \n \n <ect>
\t7 ServiceStopper stopper = new ServiceStopper ( ) ; \n \n \t7 broker . stopAllConnectors ( stopper ) ; \n \n \t7 LOG . info ( <string_literal> + broker ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t3 public void run ( ) { \n \n \t4 try { \n \n \t5 slaveThreadStarted . countDown ( ) ; \n \n \t5 slave . start ( ) ; \n \n <ect>
\t2 if ( invokable != null && this . invokable != null && invokableHasBeenCanceled . compareAndSet ( false , true ) ) { \n \n \t3 try { \n \n \t4 invokable . cancel ( ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t3 MD5Token serverToken = ( MD5Token ) token ; \n \n \t3 <comment> \n \n \t3 return ( this . auth_value != null ) && ( serverToken . auth_value != null ) \n \n \t3 && ( this . auth_value . equalsIgnoreCase ( serverToken . auth_value ) ) ; } \n \n <ect>
\t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 50L ) ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 50L ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client . admin ( ) . indices ( ) . prepareClose ( <string_literal> , <string_literal> ) . get ( ) ; \n \n <ect>
\t3 server . setDirectoryService ( ds ) ; \n \n \t3 server . start ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n \t3 t . printStackTrace ( ) ; \n \n <ect>
\t1 public void testRWRebalanceWithReplicationSerial ( ) throws Exception { \n \n \t2 try { \n \n \t3 testRWRebalanceWithReplication ( true ) ; \n \n \t2 } catch ( AssertionError ae ) { \n \n <ect>
\t2 status = sc ; \n \n \t2 NginxClojureSocketImpl ns = ( NginxClojureSocketImpl ) s . getHandler ( ) ; \n \n \t2 if ( ns . coroutine != null && ns . coroutine . getState ( ) == State . SUSPENDED ) { \n \n <ect>
\t2 log . error ( prefix + <string_literal> ) ; \n \n \t2 if ( blocker != null ) { \n \n \t3 log . error ( prefix + blocker . getLogName ( ) + <string_literal> + attacker . getLogName ( ) ) ; } \n \n \t2 log . error ( prefix ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( null != stmt ) { \n \n \t3 stmt . close ( ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 finally { \n \n \t3 try { \n \n \t4 storagePoolManager . disconnectPhysicalDisk ( destPrimaryDataStore . getPoolType ( ) , destPrimaryDataStore . getUuid ( ) , destPath ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t2 if ( entityName != null ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 EOEntity e = EOModelGroup . defaultGroup ( ) . entityNamed ( entityName ) ; \n \n <ect>
<comment> \n \n \t1 final String cssStatement = matcher . group ( ) ; \n \n \t1 LOG . debug ( <string_literal> , cssStatement ) ; \n \n \t1 if ( ! new CssImportInspector ( cssStatement ) . containsImport ( ) ) { \n \n <ect>
private boolean hasRelevantChanges ( ) { \n \n \t1 final String generatorName = this . getClass ( ) . getSimpleName ( ) ; \n \n \t1 final Set < String > relevantClasses = cacheRelevantClasses . get ( this . getClass ( ) ) ; \n \n \t1 if ( relevantClasses == null ) { \n \n <ect>
\t3 info ( <string_literal> + checkPeriod + <string_literal> + configToMonitor + <string_literal> + new Date ( lastModified ) ) ; } } \n \n \t1 private void applyModifications ( Resource configToMonitor ) { \n \n \t2 DtoBroker changed = loadConfiguration ( configToMonitor ) ; \n \n \t2 if ( changed != null && ! currentConfiguration . equals ( changed ) ) { \n \n <ect>
public void setSerde ( MapJoinObjectSerDeContext keyCtx , MapJoinObjectSerDeContext valCtx ) \n \n \t1 throws SerDeException { \n \n \t1 AbstractSerDe keySerde = keyCtx . getSerDe ( ) , valSerde = valCtx . getSerDe ( ) ; \n \n \t1 if ( writeHelper == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 MaryData result = new MaryData ( outputType ( ) , d . getLocale ( ) ) ; \n \n \t2 result . readFrom ( from ( ) , outputType ( ) . endMarker ( ) ) ; \n \n <ect>
\t1 public boolean stopConsumer ( Consumer consumer ) throws Exception { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 ServiceHelper . stopAndShutdownServices ( consumer ) ; \n \n <ect>
\t5 s_logger . warn ( <string_literal> + ip + <string_literal> + vmId + <string_literal> ) ; \n \n \t5 success = false ; } } \n \n \t2 } catch ( ResourceUnavailableException e ) { \n \n \t3 success = false ; \n \n <ect>
\t2 writer . addMutation ( m ) ; \n \n \t1 } catch ( MutationsRejectedException e ) { \n \n \t2 log . warn ( <string_literal> , e ) ; } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 if ( ! newServiceOffering . getSystemUse ( ) ) { \n \n \t3 throw new InvalidParameterValueException ( <string_literal> + serviceOfferingId ) ; } \n \n \t2 <comment> \n \n \t2 if ( ! router . getState ( ) . equals ( VirtualMachine . State . Stopped ) ) { \n \n <ect>
\t1 try { \n \n \t1 OBJECT_NAME = new ObjectName ( <string_literal> + serverName \n \n \t2 + <string_literal> + threadName ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 jobPool = new ThreadPoolExecutor ( corePoolSize , corePoolSize , Long . MAX_VALUE , TimeUnit . DAYS , \n \n \t4 new SynchronousQueue < Runnable > ( ) ) ; \n \n \t2 context = new DefaultContext ( Maps . < String , Executable > newConcurrentMap ( ) , jobEngineConfig . getConfig ( ) ) ; \n \n \t2 int pollSecond = jobEngineConfig . getPollIntervalSecond ( ) ; \n \n <ect>
\t4 getTabletServer ( ) . getConfiguration ( ) , extent . getPrevEndRow ( ) , extent . getEndRow ( ) , \n \n \t4 FileUtil . toPathStrings ( getDatafileManager ( ) . getFiles ( ) ) , tsp ) , \n \n \t3 tsp ) ; } \n \n \t1 if ( splitPoint == null || splitPoint . row == null ) { \n \n <ect>
\t5 LOGGER . debug ( <string_literal> , name ) ; \n \n \t5 try { \n \n \t6 addURL ( urls , DERIA5String . getInstance ( name . getName ( ) ) . getString ( ) ) ; \n \n \t5 } catch ( final Exception e ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 searchResponse = client ( ) . prepareSearch ( <string_literal> , <string_literal> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) ; \n \n \t2 assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( 8L ) ) ; \n \n \t2 assertThat ( client ( ) . prepareSearch ( <string_literal> , <string_literal> ) . setSize ( 0 ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 8L ) ) ; \n \n <ect>
\t3 log . warn ( <string_literal> ) ; \n \n \t3 facade . getResponse ( ) . sendError ( <number_literal> , <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! deployment . getResourceName ( ) . equals ( action . getResource ( ) ) ) { \n \n <ect>
\t1 checkNotNull ( rootArtifactClassesFolder , <string_literal> ) ; \n \n \t1 File rootArtifactFolder = rootArtifactClassesFolder . getParentFile ( ) . getParentFile ( ) ; \n \n \t1 logger . debug ( <string_literal> , rootArtifactFolder ) ; \n \n \t1 if ( ! containsMavenProject ( rootArtifactFolder ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 completed . await ( ) ; \n \n \t3 if ( exception == null ) \n \n \t3 { \n \n <ect>
\t1 @ Override \n \n \t1 protected FCPMessage persistentTagMessage ( ) { \n \n \t2 <comment> \n \n \t2 if ( lowLevelClient == null ) \n \n <ect>
\t4 log . warn ( <string_literal> , \n \n \t6 jettyAddress ) ; } } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
static public void unsetTestLogging ( ) \n \n { \n \n \t1 if ( errorHandlers . size ( ) == 0 ) \n \n \t1 { \n \n <ect>
\t2 if ( _testName . contains ( <string_literal> ) ) { \n \n \t3 _testName = testClassName . substring ( testClassName . lastIndexOf ( <string_literal> ) + 1 ) ; } \n \n \t2 _testTime = new CCNTime ( ) ; \n \n \t2 _testNamespace = new ContentName ( externalPrefix , _testName + <string_literal> + _testTime . toShortString ( ) ) ; \n \n <ect>
\t3 LOGGER . trace ( <string_literal> + json ) ; \n \n \t3 RemoteUtil . respond ( t , <string_literal> , <number_literal> , <string_literal> ) ; \n \n \t3 RootFolder root = parent . getRoot ( RemoteUtil . userName ( t ) , t ) ; \n \n \t3 if ( root == null ) { \n \n <ect>
\t2 tablet . getTabletServer ( ) . minorCompactionStarted ( commitSession , \n \n \t3 commitSession . getWALogSeq ( ) + 1 , newMapfileLocation . path ( ) . toString ( ) ) ; \n \n \t2 break ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
private int alterTable ( Hive db , AlterTableDesc alterTbl ) throws HiveException { \n \n \t1 if ( alterTbl . getOp ( ) == AlterTableDesc . AlterTableTypes . RENAME ) { \n \n \t1 String names [ ] = Utilities . getDbTableName ( alterTbl . getOldName ( ) ) ; \n \n \t1 if ( Utils . isBootstrapDumpInProgress ( db , names [ 0 ] ) ) { \n \n <ect>
\t5 client . connect ( server . getPort ( ) ) ; \n \n \t5 logger . info ( <string_literal> ) ; \n \n \t5 try { Thread . sleep ( <number_literal> ) ; } catch ( Exception e ) { } \n \n \t5 int sent = client . send ( new byte [ <number_literal> ] , false , 0 , 0 ) ; \n \n <ect>
\t3 RateStat loadedRs = new RateStat ( <string_literal> , <string_literal> , <string_literal> , new long [ ] { <number_literal> * <number_literal> , \n \n <number_literal> <number_literal> * <number_literal> * <number_literal> , \n \n <number_literal> <number_literal> * <number_literal> * <number_literal> * <number_literal> } ) ; \n \n \t3 loadedRs . load ( props , <string_literal> , true ) ; \n \n <ect>
\t1 conn = getDataSource ( ) . getConnection ( ) ; \n \n \t1 stmt = conn . prepareStatement ( setPreferenceSQL ) ; \n \n \t1 setLongParameter ( stmt , 1 , userID ) ; \n \n \t1 setLongParameter ( stmt , <number_literal> , itemID ) ; \n \n <ect>
\t4 if ( ! bFakeFail ) { \n \n \t5 LOG . info ( <string_literal> + destinationName + <string_literal> + message . toString ( ) ) ; \n \n \t5 session . commit ( ) ; \n \n \t4 } else { \n \n <ect>
\t5 if ( ( flag & F_SERIALIZED ) != F_SERIALIZED ) { \n \n \t6 if ( primitiveAsString || asString ) { \n \n \t7 <comment> \n \n <ect>
\t3 logger . error ( <string_literal> + rs . getInt ( 1 ) ) ; \n \n \t2 } catch ( SQLException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 for ( StepListener stepListener : getAllListeners ( ) ) { \n \n \t3 try { \n \n \t4 stepListener . testFailed ( outcome , cause ) ; \n \n \t3 } catch ( AbstractMethodError ame ) { \n \n <ect>
\t2 } catch ( NoSuchPortException e ) { \n \n \t3 logger . error ( <string_literal> , serialPortName ) ; \n \n \t3 throw new SerialInterfaceException ( String . format ( <string_literal> , serialPortName ) , e ) ; \n \n \t2 } catch ( PortInUseException e ) { \n \n <ect>
\t3 if ( result != null ) { \n \n \t4 setEntityId ( result . getId ( ) ) ; \n \n \t4 setEntityUuid ( result . getUuid ( ) ) ; } \n \n \t2 } catch ( NetworkRuleConflictException ex ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> ) ; } \n \n \t3 return null ; } \n \n \t2 if ( work . getTimesTried ( ) > _maxRetries ) { \n \n <ect>
\t4 } else { \n \n \t5 WatchListEvent existingCompositeEvent = events . get ( events . indexOf ( event ) ) ; \n \n \t5 existingCompositeEvent . addEvent ( event ) ; } } \n \n \t2 } catch ( ActivityStreamException e ) { \n \n <ect>
\t2 if ( use_external_key_exchange ) { \n \n \t3 log . debug ( <string_literal> , local_addr ) ; \n \n \t3 down_prot . down ( new Event ( Event . FETCH_SECRET_KEY , key_server ) ) ; \n \n \t3 return ; } \n \n <ect>
\t2 logger . debug ( <string_literal> , ex ) ; \n \n \t2 try { \n \n \t3 manager . rollback ( status ) ; } \n \n \t2 catch ( RuntimeException ex2 ) { \n \n <ect>
\t1 if ( c . collectible ) { \n \n \t1 val l = cardLabels . get ( c . name ) \n \n \t1 if ( l . isDefined ) l \t1 \n \n \t1 else { \n \n <ect>
\t5 } catch ( IOException ignored ) { \n \n \t6 <comment> \n \n \t3 <comment> \n \n \t3 if ( ! file . delete ( ) ) { \n \n <ect>
\t1 public void dispatchRule ( TreeMapperPathReference t ) { \n \n \t2 if ( ( t != null ) && ( bundle != null ) && ( processor != null ) ) { \n \n \t3 processor . processBundle ( bundle , t ) ; \n \n \t2 } else if ( debug > 0 ) { \n \n <ect>
\t3 storeInCache ( cacheKey , host , request , updatedEntry ) ; \n \n \t3 return updatedEntry ; \n \n \t2 } catch ( final ResourceIOException ex ) { \n \n <ect>
\t4 String sessionId = pathSegments [ 1 ] ; \n \n \t4 String transport = pathSegments [ <number_literal> ] ; \n \n \t4 if ( ! isWebSocketEnabled ( ) && transport . equals ( <string_literal> ) ) { \n \n \t5 if ( requestInfo != null ) { \n \n <ect>
\t1 if ( ptnRootLocation == null ) { \n \n \t1 <comment> \n \n \t1 Path ptnRoot = new Path ( ptnLocn ) ; \n \n \t1 for ( int i = 0 ; i < numPtnKeys ; i ++ ) { \n \n <ect>
\t6 if ( pingOneOnly ) \n \n \t7 shouldPingFirewall = false ; } } \n \n \t3 if ( ! _expireBuffer . isEmpty ( ) ) { \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 LOG . debug ( <string_literal> , ioe ) ; \n \n \t4 ExecResult result = new ExecResult ( command , stdout , stderr , exitValue ) ; \n \n \t4 return result ; } \n \n \t3 <comment> \n \n <ect>
\t4 if ( EndpointHelper . matchEndpoint ( this , oldEndpoint . getEndpointUri ( ) , uri ) ) { \n \n \t5 try { \n \n \t6 stopServices ( oldEndpoint ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t4 keyspaces . add ( keyspaceDir ) ; } } \n \n \t2 for ( String keyspace : keyspaces ) \n \n \t3 Keyspace . clearSnapshot ( tag , keyspace ) ; \n \n <ect>
\t2 LOG . info ( <string_literal> , queueView . getDequeueCount ( ) ) ; \n \n \t2 LOG . info ( <string_literal> , queueView . getDispatchCount ( ) ) ; \n \n \t2 LOG . info ( <string_literal> , queueView . getEnqueueCount ( ) ) ; \n \n \t2 LOG . info ( <string_literal> , queueView . getExpiredCount ( ) ) ; \n \n <ect>
\t6 if ( ! file . delete ( ) ) \n \n \t7 logger . warn ( <string_literal> , file . getAbsolutePath ( ) ) ; } } } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t3 _contents . remove ( manager ) ; \n \n \t3 _managers . remove ( manager ) ; \n \n \t3 return true ; } \n \n \t2 if ( Log . isLoggable ( Log . FAC_ACCESSCONTROL , Level . INFO ) ) { \n \n <ect>
\t4 break ; } \n \n \t3 default : \n \n \t4 throw new UnsupportedOperationException ( <string_literal> ) ; } \n \n \t2 final ShardRouting shardRouting = indexShard . routingEntry ( ) ; \n \n <ect>
\t1 private PersistentIdGenerator persistentIdGenerator = new OidcPairwisePersistentIdGenerator ( ) ; \n \n \t1 @ Override \n \n \t1 public String resolveUsernameInternal ( final Principal principal , final Service service , final RegisteredService registeredService ) { \n \n \t2 if ( registeredService == null || ! OidcRegisteredService . class . isAssignableFrom ( registeredService . getClass ( ) ) ) { \n \n <ect>
\t2 if ( ! producerConfig . containsKey ( ProducerConfig . TRANSACTION_TIMEOUT_CONFIG ) ) { \n \n \t3 long timeout = DEFAULT_KAFKA_TRANSACTION_TIMEOUT . toMilliseconds ( ) ; \n \n \t3 checkState ( timeout < Integer . MAX_VALUE && timeout > 0 , <string_literal> ) ; \n \n \t3 this . producerConfig . put ( ProducerConfig . TRANSACTION_TIMEOUT_CONFIG , ( int ) timeout ) ; \n \n <ect>
\t4 sc . addAnd ( <string_literal> , SearchCriteria . Op . NULL ) ; \n \n \t4 sc . addAnd ( <string_literal> , SearchCriteria . Op . EQ , UsageTypes . ALLOCATED_VM ) ; \n \n \t4 usageInstances = _usageInstanceDao . search ( sc , null ) ; \n \n \t4 if ( usageInstances == null || ( usageInstances . size ( ) == 0 ) ) { \n \n <ect>
\t2 if ( ipToAssoc != null ) { \n \n \t3 _accountMgr . checkAccess ( caller , null , true , ipToAssoc ) ; \n \n \t3 owner = _accountMgr . getAccount ( ipToAssoc . getAllocatedToAccountId ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t5 LOG . warn ( <string_literal> , message ) ; \n \n \t4 } else if ( level == INFO ) { \n \n \t5 <comment> \n \n \t5 if ( isVerboseLogging ( ) ) { \n \n <ect>
\t4 wai = forcefirst ? inputStreams . get ( 0 ) : inputStreams . get ( inputStreams . size ( ) - 1 ) ; \n \n \t3 } catch ( IndexOutOfBoundsException e ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t1 LOGGER . log ( Level . SEVERE , <string_literal> ) ; } \n \n \t1 <comment> \n \n \t1 if ( deployment != null && PropertyHelper . getBooleanProperty ( processArchive . getProperties ( ) , ProcessArchiveXml . PROP_IS_DELETE_UPON_UNDEPLOY , false ) ) { \n \n \t1 try { \n \n <ect>
\t5 if ( objectClass . equalsIgnoreCase ( userObjectClass ) ) { \n \n \t6 user = true ; \n \n \t6 Attribute name = memberAttributes . get ( userNameAttribute ) ; \n \n \t6 if ( name == null ) { \n \n <ect>
\t4 <string_literal> ) ; \n \n \t2 logger . error ( <string_literal> ) ; \n \n \t2 logger . error ( <string_literal> , \n \n \t4 new IOException ( <string_literal> ) ) ; \n \n <ect>
\t2 <comment> \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 try { \n \n \t4 exec_command ( <string_literal> + pid ) ; \n \n <ect>
\t3 upgradeStatement = con . createStatement ( ) ; \n \n \t3 upgradeStatement . execute ( statement ) ; \n \n \t3 upgradeStatement . close ( ) ; \n \n \t3 con . commit ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 protected void apply ( List < OWLOntologyChange > changes ) { \n \n \t2 try { \n \n \t3 manager . applyChanges ( changes ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 parse ( _docResponse . getDocumentElement ( ) ) ; } \n \n \t2 } catch ( ParserConfigurationException e ) { \n \n \t3 s_logger . error ( <string_literal> + e . toString ( ) ) ; \n \n \t2 } catch ( SAXException e ) { \n \n <ect>
\t2 expiredUpdateCount . increment ( ) ; \n \n \t2 return ; } \n \n \t1 wrappedObserver . update ( update . getMetrics ( ) ) ; \n \n \t1 } catch ( InterruptedException ie ) { \n \n <ect>
\t2 assertAcked ( prepareCreate ( <string_literal> ) \n \n \t4 . addMapping ( <string_literal> , <string_literal> , <string_literal> ) \n \n \t4 . setSettings ( Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , 1 ) ) ) ; \n \n \t2 ensureGreen ( ) ; \n \n <ect>
\t1 public void parse ( InputStream stream , ContentHandler handler , \n \n \t5 Metadata metadata , ParseContext context ) throws IOException , \n \n \t3 SAXException , TikaException { \n \n \t2 if ( ! isAvailable ) { \n \n <ect>
\t4 SockIO socket = j . next ( ) ; \n \n \t4 try { \n \n \t5 socket . trueClose ( ) ; } \n \n \t4 catch ( IOException ioe ) { \n \n <ect>
\t1 public void ack ( Object msgId ) { \n \n \t2 LOG . debug ( <string_literal> + msgId ) ; } \n \n \t1 @ Override \n \n \t1 public void fail ( Object msgId ) { \n \n <ect>
\t1 log . debug ( <string_literal> + server . address ) ; \n \n \t1 return server . address ; \n \n \t1 } catch ( Exception ex ) { \n \n \t1 <comment> \n \n <ect>
\t1 void doDTDFailsWithApacheLinkMessage ( String ext ) throws Exception { \n \n \t2 logger . info ( <string_literal> + ext + <string_literal> ) ; \n \n \t2 Response response = client . target ( generateURL ( <string_literal> , URL_PREFIX + ext ) ) . request ( ) \n \n \t4 . post ( Entity . entity ( bar , <string_literal> ) ) ; \n \n <ect>
\t3 throw new CamelAsteriskException ( <string_literal> ) ; } } \n \n \t1 public void addListener ( ManagerEventListener listener ) throws CamelAsteriskException { \n \n \t2 if ( managerConnection != null ) { \n \n \t3 managerConnection . addEventListener ( listener ) ; \n \n <ect>
\t3 <string_literal> \n \n \t2 ) ; \n \n \t2 return true ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t2 final SamReader in = SamReaderFactory . makeDefault ( ) . referenceSequence ( REFERENCE_SEQUENCE ) . open ( INPUT ) ; \n \n \t2 final ReferenceSequenceFile reference = ReferenceSequenceFileFactory . getReferenceSequenceFile ( REFERENCE_SEQUENCE ) ; \n \n \t2 final SAMSequenceDictionary refDict = reference . getSequenceDictionary ( ) ; \n \n \t2 if ( refDict == null ) { \n \n <ect>
\t2 options . addOption ( OPTION_LOG_PERIOD ) ; \n \n \t2 config = KylinConfig . getInstanceFromEnv ( ) ; } \n \n \t1 private void beforeExtract ( ) { \n \n \t2 <comment> \n \n <ect>
\t2 if ( object instanceof String ) { \n \n \t2 try { \n \n \t3 permissionId = Integer . valueOf ( ( String ) object ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t2 } catch ( EJBAccessException e ) { \n \n \t3 <comment> \n \n \t3 writer . append ( RESULT_EJB_ACCESS_EXCEPTION ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 <comment> \n \n \t4 if ( errorHandler != null ) \n \n \t5 errorHandler . handleErrorOnSet ( this , e , key ) ; \n \n \t4 log . error ( <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t1 } finally { \n \n \t1 try { \n \n \t2 zip . closeEntry ( ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t3 catch ( UnknownHostException e ) \n \n \t3 { \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t3 try { \n \n \t4 ServiceTemplate tmpl = ( ServiceTemplate ) api . findById ( ServiceTemplate . class , ref . getUuid ( ) ) ; \n \n \t4 _templateId = tmpl . getUuid ( ) ; \n \n \t3 } catch ( IOException ex ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testShellCommand ( ) throws Exception { \n \n <ect>
protected void setIpAddress ( final TProtocol in ) { \n \n \t1 TTransport transport = in . getTransport ( ) ; \n \n \t1 TSocket tSocket = getUnderlyingSocketFromTransport ( transport ) ; \n \n \t1 if ( tSocket == null ) { \n \n <ect>
\t1 <comment> \n \n \t1 public int executeRaw ( DatabaseConnection connection , String statement , String [ ] arguments ) throws SQLException { \n \n <ect>
\t2 Type . MONTHLY . setMax ( NumbersUtil . parseInt ( configDao . getValue ( <string_literal> ) , MONTHLYMAX ) ) ; \n \n \t2 _deltaSnapshotMax = NumbersUtil . parseInt ( configDao . getValue ( <string_literal> ) , DELTAMAX ) ; \n \n \t2 _totalRetries = NumbersUtil . parseInt ( configDao . getValue ( <string_literal> ) , <number_literal> ) ; \n \n \t2 _pauseInterval = <number_literal> * NumbersUtil . parseInt ( configDao . getValue ( <string_literal> ) , <number_literal> ) ; \n \n <ect>
\t6 . withTag ( SINK_ID , getSinkId ( ) ) \n \n \t6 . withTag ( TagKey . ROUTING_KEY , message . getRoutingKey ( ) ) \n \n \t6 . build ( ) ) . increment ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 super . internalReceiveCommand ( itemName , command ) ; \n \n <ect>
\t4 setDisconnected ( ) ; } } } \n \n \t1 private UploadCommand getCommand ( ) { \n \n \t2 return cmd ; } \n \n \t1 public void logDisconnect ( ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t1 } catch ( SQLException e1 ) { \n \n \t2 logger . error ( <string_literal> , e1 ) ; } \n \n \t1 } catch ( ClassNotFoundException e2 ) { \n \n <ect>
\t2 try { \n \n \t3 ClassLoader appcl = camelContext . getApplicationContextClassLoader ( ) ; \n \n \t3 if ( appcl != null ) { \n \n \t4 Thread . currentThread ( ) . setContextClassLoader ( appcl ) ; } \n \n <ect>
\t3 if ( result . getError ( ) != null ) { \n \n \t4 logger . error ( result . getError ( ) ) ; \n \n \t4 continue ; } \n \n \t3 if ( seriess == null ) { \n \n <ect>
\t2 <comment> \n \n <ect>
\t5 List < Subscription > subscriptions = destination . getConsumers ( ) ; \n \n \t5 LOG . info ( destination + <string_literal> + subscriptions ) ; \n \n \t5 for ( Subscription subscription : subscriptions ) { \n \n \t6 if ( subscription . getConsumerInfo ( ) . isNetworkSubscription ( ) ) { \n \n <ect>
\t4 controlNic = nic ; \n \n \t4 buf . append ( createRedundantRouterArgs ( controlNic , router ) ) ; \n \n \t4 <comment> \n \n \t4 if ( dest . getHost ( ) . getHypervisorType ( ) == HypervisorType . VMware || dest . getHost ( ) . getHypervisorType ( ) == HypervisorType . Hyperv ) { \n \n <ect>
<comment> \n \n \t1 public void stop ( BundleContext context ) throws Exception \n \n \t1 { \n \n \t2 smileyServReg . unregister ( ) ; \n \n <ect>
\t2 elements = queueView . browse ( ) ; \n \n \t2 assertEquals ( MSG_COUNT - 1 , elements . length ) ; \n \n \t2 for ( CompositeData element : elements ) { \n \n \t3 String messageID = ( String ) element . get ( <string_literal> ) ; \n \n <ect>
<comment> \n \n \t1 public static List < Long > getJavaProcessIds ( String . . . classNameFilter ) { \n \n \t2 String commands = <string_literal> ; \n \n \t2 String message = commands ; \n \n <ect>
\t2 else { \n \n \t3 <comment> \n \n \t3 try { \n \n <ect>
\t2 } else { \n \n \t2 <comment> \n \n \t2 log . warn ( <string_literal> , instances . size ( ) ) ; } \n \n \t1 } else { \n \n <ect>
\t2 self . logger . debug ( <string_literal> % vpc1 . id ) \n \n \t2 vpn2_response = Vpn . createVpnGateway ( self . apiclient , vpc2 . id ) \n \n \t2 self . assert_ ( \n \n \t3 vpn2_response is not None , <string_literal> ) \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t6 makeDecider ( diskSettings ) ) ) ) ; \n \n \t2 ClusterInfoService cis = new ClusterInfoService ( ) { \n \n \t3 @ Override \n \n \t3 public ClusterInfo getClusterInfo ( ) { \n \n <ect>
\t1 return foundItems ; } \n \n @ Override \n \n public void addService ( Service service ) { \n \n <ect>
<comment> \n \n \t1 public static void validateSchemaAsNeeded ( StoreDefinition storeDefinition ) { \n \n <ect>
\t1 public void testGenerateJSONWithContext ( ) { \n \n \t2 try { \n \n \t3 String filename = <string_literal> ; \n \n \t3 String contextName = <string_literal> ; \n \n <ect>
\t4 cost = index . getCost ( filter , rootState ) ; } \n \n \t4 logDebug ( <string_literal> + indexName + <string_literal> + cost ) ; } \n \n \t3 if ( cost < 0 ) { \n \n <ect>
\t1 testServer = new HsqldbTestServer ( ) ; \n \n \t1 try { \n \n \t2 testServer . resetServer ( ) ; \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 private void setPhantomJSPathIfNotSet ( ) { \n \n \t2 if ( ! phantomJSIsAvailable ( ) ) { \n \n <ect>
\t2 s_logger . info ( <string_literal> + _version ) ; \n \n \t2 parseCommand ( args ) ; \n \n \t2 _storage = locator . getManager ( StorageComponent . class ) ; \n \n \t2 if ( _storage == null ) { \n \n <ect>
\t6 protected void onFailure ( Exception e ) { \n \n \t7 try { \n \n \t8 channel . sendResponse ( e ) ; \n \n \t7 } catch ( IOException e1 ) { \n \n <ect>
\t5 totalFilesProcessed += future . get ( ) ; } \n \n \t3 } catch ( InterruptedException | ExecutionException e ) { \n \n \t4 LOG . error ( e . getMessage ( ) , e ) ; } } \n \n \t2 double elapsedSeconds = ( double ) ( new Date ( ) . getTime ( ) - start ) / ( double ) <number_literal> ; \n \n <ect>
<comment> \n \n \t2 public static < T extends ERXEnterpriseObject > void referenceCopyClassRelationships ( T source , T destination ) { \n \n <ect>
\t3 return null ; } \n \n \t2 final Map < String , MultifactorAuthenticationProvider > providerMap = \n \n \t4 MultifactorAuthenticationUtils . getAvailableMultifactorAuthenticationProviders ( this . applicationContext ) ; \n \n \t2 if ( providerMap == null || providerMap . isEmpty ( ) ) { \n \n <ect>
\t2 { \n \n \t3 base = base . merge ( cardinalities . toArray ( new ICardinality [ cardinalities . size ( ) ] ) ) ; } \n \n \t2 catch ( CardinalityMergeException e ) \n \n \t2 { \n \n <ect>
\t4 s_logger . error ( <string_literal> + e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t4 resp . sendRedirect ( SAML2AuthManager . SAMLCloudStackRedirectionUrl . value ( ) ) ; \n \n \t3 } catch ( IOException ignored ) { \n \n <ect>
\t4 log . trace ( <string_literal> , ccl ) ; \n \n \t4 classLoaders . add ( ccl ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t6 LOG . debug ( <string_literal> ) \n \n \t5 } else { \n \n \t6 LOG . debug ( <string_literal> ) } \n \n \t4 } else { \n \n <ect>
\t5 new ShellUtils . ShellCommandExecutor ( new String [ ] { <string_literal> , <string_literal> } ) ; \n \n \t3 shellExecutorClk . execute ( ) ; \n \n \t3 jiffiesPerSecond = Long . parseLong ( shellExecutorClk . getOutput ( ) . replace ( <string_literal> , <string_literal> ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 ts = timestampField . get ( msgMap ) ; } \n \n \t5 return ts ; } \n \n \t3 } ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 s_logger . error ( <string_literal> + o . getClass ( ) . getName ( ) + <string_literal> + propName ) ; \n \n \t5 } catch ( IllegalAccessException e ) { \n \n \t6 s_logger . error ( <string_literal> + o . getClass ( ) . getName ( ) + <string_literal> + propName ) ; \n \n \t5 } catch ( InvocationTargetException e ) { \n \n <ect>
\t1 try { \n \n \t1 if ( ps != null ) { \n \n \t2 ps . close ( ) ; } \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t2 || ds . assignedCount != 0 ; ds = TabletLocations . retrieve ( ctx , tableName ) ) { \n \n \t1 Thread . sleep ( <number_literal> ) ; } \n \n \t1 Assert . assertEquals ( deadTabletsByServer . get ( restartedServer ) , ds . hosted . get ( restartedServer ) ) ; \n \n \t1 <comment> \n \n <ect>
\t4 s_logger . debug ( <string_literal> , e ) ; \n \n \t4 throw new AgentUnavailableException ( <string_literal> , router . getHostId ( ) , e ) ; } \n \n \t3 Answer answer = cmds . getAnswer ( <string_literal> ) ; \n \n \t3 if ( ! answer . getResult ( ) ) { \n \n <ect>
\t4 try { \n \n \t5 suroInput . start ( ) ; \n \n \t5 inputMap . put ( suroInput . getId ( ) , suroInput ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 result += line ; \n \n \t2 line = rd . readLine ( ) ; } \n \n \t2 rd . close ( ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 ServiceDiscoveryProfile . getLocalServiceKeys ( ServiceDiscoveryProfile . REPOSITORY_SERVICE_NAME , \n \n \t5 TEST_TIMEOUT , readerHandle ) ; \n \n \t2 printResults ( results ) ; \n \n \t2 Assert . assertEquals ( 1 , results . size ( ) ) ; \t2 \n \n <ect>
\t5 if ( test . getReceiveBobTime ( ) > 0 ) \n \n \t6 testComplete ( true ) ; \n \n \t4 } catch ( UnknownHostException uhe ) { \n \n \t5 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t3 respondError ( response , e . getMessage ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t3 respondException ( response , e ) ; } \n \n <ect>
\t2 threadService . set ( camelContextService ) ; } \n \n \t1 @ Before \n \n \t1 public void setUp ( ) throws Exception { \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t4 isVargs = mc . isVargsMethod ( ) ; \n \n \t4 Constructor con = mc . getCachedConstrcutor ( ) . cachedConstructor ; \n \n \t4 try { \n \n \t5 handle = LOOKUP . unreflectConstructor ( con ) ; \n \n <ect>
\t5 oldKey , bucket , newS3Key ) ; \n \n \t4 Copy copy = tmx . copy ( s3ReqDecorator . decorate ( copReq ) ) ; \n \n \t4 try { \n \n \t5 copy . waitForCopyResult ( ) ; \n \n <ect>
\t3 synchronized ( this ) { \n \n \t4 bogusNoderef = true ; \n \n \t4 <comment> \n \n \t4 isConnected . set ( false , now ) ; } \n \n <ect>
\t3 if ( ! resource . isReadable ( ) ) { \n \n \t4 if ( strict ) { \n \n \t5 throw new IllegalStateException ( \n \n \t7 <string_literal> ) ; } \n \n <ect>
\t2 } catch ( InvalidKeyException ike ) { \n \n \t3 logger . error ( <string_literal> Message Authentication Code \\ <string_literal> , ike ) ; \n \n \t3 throw new AssertionError ( ike ) ; \n \n \t2 } catch ( NoSuchAlgorithmException nsae ) { \n \n <ect>
\t3 protected void runExportImportTask ( KeycloakSession session ) throws IOException { \n \n \t4 RealmModel realm = session . realms ( ) . getRealmByName ( realmName ) ; \n \n \t4 RealmRepresentation rep = ExportUtils . exportRealm ( session , realm , exportUsersIntoRealmFile , true ) ; \n \n \t4 writeRealm ( realmName + <string_literal> , rep ) ; \n \n <ect>
\t3 runCommand ( command , out ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n \t3 _log . error ( <string_literal> , ioe ) ; } } \n \n \t1 private void runCommand ( String command , OutputStream out ) throws IOException { \n \n <ect>
\t1 sink . start ( ) ; <comment> \n \n \t1 <comment> \n \n \t1 logger . error ( <string_literal> ) ; \n \n \t1 sink . process ( ) ; \n \n <ect>
\t1 public boolean unsubscribe ( MessageHandler handler ) { \n \n \t2 boolean result = this . handlers . remove ( handler ) ; \n \n \t2 if ( result ) { \n \n <ect>
\t4 . add ( new MoveAllocationCommand ( <string_literal> , 0 , relocationSource . getId ( ) , relocationTarget . getId ( ) ) ) \n \n \t4 . execute ( ) . actionGet ( ) ; \n \n \t3 ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNoRelocatingShards ( true ) . execute ( ) . actionGet ( ) ; \n \n \t3 assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testBackwardElectionRound ( ) throws Exception { \n \n <ect>
\t1 @ Override \n \n \t1 public void check ( ) { \n \n \t2 GlobalLock lock = GlobalLock . getInternLock ( <string_literal> ) ; \n \n \t2 try { \n \n <ect>
\t2 Short speed = null ; \n \n \t2 if ( direction . equals ( UpDownType . DOWN ) ) { \n \n \t3 speed = Tools . getShortOpt ( ConfigOptsMove . RIGHTSPEED . toString ( ) , opts ) ; \n \n \t3 if ( speed == null ) { \n \n <ect>
\t3 UserGroupInformation loginUser ; \n \n \t3 try { \n \n \t4 loginUser = UserGroupInformation . getLoginUser ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 Linux host = new Linux ( c ) ; \n \n \t3 if ( ! host . getOvmVersion ( ) . startsWith ( <string_literal> ) && ! host . getOvmVersion ( ) . startsWith ( <string_literal> ) ) { \n \n <ect>
\t1 private static LoadingCache < String , AtomicInteger > runningStats = CacheBuilder . newBuilder ( ) \n \n \t3 . removalListener ( new RemovalListener < String , AtomicInteger > ( ) { \n \n \t4 @ Override \n \n \t4 public void onRemoval ( RemovalNotification < String , AtomicInteger > notification ) { \n \n <ect>
\t3 String peerName = Long . toString ( peer ) ; \n \n \t3 Answer [ ] answers = _clusterMgr . execute ( peerName , agentId , cmds , true ) ; \n \n \t3 return answers ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t8 logger . trace ( <string_literal> , lock . id ) ; \n \n \t8 try { \n \n \t9 releaseLock ( null , lock . pid , lock . uid , lock . id ) ; \n \n \t8 } catch ( Exception e ) { \n \n <ect>
\t5 LOG . error ( message + <string_literal> , t ) ; \n \n \t5 throw new IOException ( message , t ) ; } \n \n \t4 <comment> \n \n \t4 ++ attempt ; \n \n <ect>
\t4 objectFiles . put ( fileRef , objFile ) ; } \n \n \t2 @ Override \n \n \t2 public void record ( FileRef fileRef , NodeTable nodeTable ) { \n \n \t3 if ( recording ) \n \n <ect>
\t3 } while ( ! done ) ; \n \n \t3 return response ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 final String errMsg = <string_literal> ; \n \n <ect>
<comment> \n \n \t2 <comment> \n \n \t2 catch ( NoClassDefFoundError ex ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void shutdown ( ) { \n \n <ect>
\t2 it . next ( ) . submit ( ) ; } } } \n \n private void addShutdownHook ( ) { \n \n \t1 Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ( ) - > { \n \n \t1 if ( running ) { \n \n <ect>
\t5 } catch ( IOException e ) { \n \n \t6 if ( stopAwait ) { \n \n \t7 <comment> \n \n \t7 break ; } \n \n <ect>
\t3 for ( int i = emptyAttributes . getLength ( ) - 1 ; i >= 0 ; i -- ) { \n \n \t4 Attr emptyAttribute = ( Attr ) emptyAttributes . item ( i ) ; \n \n \t4 emptyAttribute . getOwnerElement ( ) . removeAttributeNode ( emptyAttribute ) ; } \n \n \t2 } catch ( TransformerException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t2 cleanSnapshot ( snapshotInfo ) ; } \n \n \t1 } else { \n \n \t2 LOG . trace ( <string_literal> ) ; } \n \n \t1 } catch ( Exception e ) { <comment> \n \n <ect>
\t4 Logger . error ( this , <string_literal> + HexUtil . bytesToHex ( buf . getData ( ) ) + <string_literal> ) ; \n \n \t4 fail = true ; \n \n \t4 raf = null ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t2 final String agentError = StringUtils . isBlank ( req . getAgentError ( ) ) ? SWIVEL_ERR_CODE_AUTHN_FAIL : req . getAgentError ( ) ; \n \n <ect>
\t9 Object . class , byte [ ] . class , String . class ) ; \n \n \t7 method . invoke ( null , _properties , resource , ksBits , \n \n \t9 ksPassword ) ; \n \n \t6 } catch ( SecurityException e ) { \n \n <ect>
\t2 if ( nbt != null ) { \n \n \t3 try { \n \n \t4 stack . setTagCompound ( JsonToNBT . getTagFromJson ( nbt ) ) ; \n \n \t3 } catch ( NBTException e ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , svc ) ; \n \n \t2 final JsonWebSignature jws = new JsonWebSignature ( ) ; \n \n \t2 final String jsonClaims = claims . toJson ( ) ; \n \n \t2 jws . setPayload ( jsonClaims ) ; \n \n <ect>
\t4 log . debug ( <string_literal> + filenameOrURI ) ; \n \n \t3 uri = filenameOrURI ; \n \n \t2 } else { \n \n <ect>
\t4 . build ( ) ; \n \n \t2 RoutingTable initialRoutingTable = RoutingTable . builder ( ) \n \n \t4 . addAsNew ( metaData . index ( <string_literal> ) ) \n \n \t4 . build ( ) ; \n \n <ect>
\t3 codeGenerators . remove ( generateAsync . value ( ) ) ; \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t2 catch ( Throwable e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t5 result . add ( findById ( id ) ) ; } \n \n \t3 } catch ( SQLException e ) { \n \n \t4 s_logger . warn ( <string_literal> + e . getMessage ( ) , e ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 assertFalse ( ec . isAutoLocked ( ) ) ; } \n \n \t2 } ; \n \n \t2 Runnable r2 = new Runnable ( ) { \n \n \t3 public void run ( ) { \n \n <ect>
\t2 if ( xml != null ) { \n \n \t3 try { \n \n \t4 xml . free ( ) ; } \n \n \t3 catch ( Exception ignore ) { \n \n <ect>
\t4 SslContext . setCurrentSslContext ( getBrokerService ( ) . getSslContext ( ) ) ; \n \n \t4 try { \n \n \t5 remoteTransport = TransportFactory . connect ( connectUri ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t4 try { \n \n \t5 resource . configure ( <string_literal> , params ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n \t5 _alertMgr . sendAlert ( AlertManager . AlertType . ALERT_TYPE_HOST , dcId , podId , <string_literal> + record . address , <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t3 if ( account . isPresent ( ) ) { \n \n \t4 return account . get ( ) . getPublicId ( ) . equals ( yubikeyPublicId ) ; } \n \n \t3 return false ; \n \n \t2 } catch ( final NoResultException e ) { \n \n <ect>
\t3 if ( locallyCreateMBeanServer && beanServer != null ) { \n \n \t4 <comment> \n \n \t4 List < MBeanServer > list = MBeanServerFactory . findMBeanServer ( null ) ; \n \n \t4 if ( list != null && ! list . isEmpty ( ) && list . contains ( beanServer ) ) { \n \n <ect>
\t1 public static class MsgPrint extends BaseFunction { \n \n \t2 @ Override \n \n \t2 public void execute ( TridentTuple tuple , TridentCollector collector ) { \n \n \t3 MetaTuple metaTuple = ( MetaTuple ) tuple . getValue ( 0 ) ; \n \n <ect>
\t3 jmdns . close ( ) ; \n \n \t3 jmdns = null ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t2 AndroidSdk . setAdbHome ( config . getAdbHome ( ) ) ; } \n \n \t1 log . info ( <string_literal> + AndroidSdk . androidHome ( ) ) ; \n \n \t1 log . info ( <string_literal> + AndroidSdk . androidSdkFolder ( ) . getAbsolutePath ( ) ) ; \n \n \t1 log . info ( <string_literal> + AndroidSdk . buildToolsFolder ( ) . getAbsolutePath ( ) ) ; \n \n <ect>
\t4 StringUtils . defaultIfBlank ( service . getSigningCredentialType ( ) , samlIdp . getResponse ( ) . getCredentialType ( ) . name ( ) ) . toUpperCase ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , credType , service ) ; \n \n \t3 switch ( credType ) { \n \n \t4 case BASIC : \n \n <ect>
\t1 public static String getMD5Checksum ( final java . io . File fileOnDisk ) { \n \n \t2 try ( final InputStream is = FileUtils . openInputStream ( fileOnDisk ) ) { \n \n \t3 return DigestUtils . md5Hex ( is ) ; \n \n \t2 } catch ( final IOException ex ) { \n \n <ect>
\t4 seeds . add ( InetAddressAndPort . getByName ( host . trim ( ) ) ) ; } \n \n \t3 catch ( UnknownHostException ex ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t3 if ( this . topics . contains ( topik ) ) { \n \n \t4 throw new MessagingException ( <string_literal> + topic + <string_literal> ) ; } \n \n \t3 this . topics . add ( topik ) ; \n \n <ect>
\t3 List < VolumeInfo > volumesMigrating = new ArrayList < VolumeInfo > ( ) ; \n \n \t3 for ( Map . Entry < VolumeInfo , DataStore > entry : volumeMap . entrySet ( ) ) { \n \n \t4 VolumeInfo volume = entry . getKey ( ) ; \n \n \t4 if ( ! snapshotMgr . canOperateOnVolume ( volume ) ) { \n \n <ect>
\t4 log = LOG ; } \n \n \t3 if ( name != null ) { \n \n \t4 log . warn ( <string_literal> + name + <string_literal> + e . getMessage ( ) , e ) ; \n \n \t3 } else { \n \n <ect>
\t1 String publicKey = exchange . getExchangeSpecification ( ) . getApiKey ( ) ; \n \n \t1 log . debug ( <string_literal> , publicKey ) ; \n \n \t1 BTCTradeSession session = sessions . get ( publicKey ) ; \n \n \t1 if ( session == null ) { \n \n <ect>
\t4 logger . info ( <string_literal> , customTracingClass ) ; } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n \t4 JVMStabilityInspector . inspectThrowable ( e ) ; \n \n <ect>
\t6 log . error ( <string_literal> + nodeId ) ; \n \n \t6 error . set ( true ) ; \n \n \t6 return false ; } \n \n \t5 if ( ! MSG_2 . equals ( msg ) ) { \n \n <ect>
\t6 <comment> \n \n \t6 configuration . load ( pmsSkelConfFile ) ; \n \n \t6 logger . info ( <string_literal> + SKEL_PROFILE_PATH ) ; \n \n \t5 } else { \n \n <ect>
\t3 return homeService . getLeftPanelEntries ( leftPanelRssURL ) ; } \n \n \t2 return Collections . emptyList ( ) ; } \n \n \t1 private void recordReferrer ( String region ) { \n \n \t2 if ( StringUtils . isNotEmpty ( region ) ) { \n \n <ect>
\t1 final long expiry = System . currentTimeMillis ( ) - TimeUnit . MINUTES . toMillis ( <number_literal> ) ; \n \n \t1 for ( final Map . Entry < String , Long > entry : pendingUpdates . entrySet ( ) ) { \n \n \t2 if ( entry . getValue ( ) < expiry ) { \n \n \t2 if ( pendingUpdates . remove ( entry . getKey ( ) , entry . getValue ( ) ) ) { \n \n <ect>
\t1 @ EventsRead ( context = <string_literal> ) \n \n \t1 Event < String > readEvent ; \n \n \t1 private ArrayList < Object > eventList = new ArrayList < Object > ( ) ; \n \n \t1 static { \n \n <ect>
\t1 SerializationResult result ; \n \n \t1 try { \n \n \t1 result = currTest . getSerializer ( ) . serialize ( currTest . getWorld ( ) ) ; \n \n \t1 } catch ( UnsupportedObjectException e1 ) { \n \n <ect>
\t1 if ( consoleConfig == null ) { \n \n \t1 try { \n \n \t2 consoleConfig = new ConsoleConfigXml ( new File ( ClassLoader . getSystemResource ( CONFIG_FILE_NAME ) . toURI ( ) ) ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( tgtId == null ) { \n \n \t3 tgtId = this . ticketGrantingTicketCookieGenerator . retrieveCookieValue ( request ) ; } \n \n \t2 if ( tgtId != null ) { \n \n <ect>
\t3 logger . error ( <string_literal> , ae ) ; \n \n \t3 throw ae ; } } \n \n \t1 @ Test ( timeout = <number_literal> ) \n \n \t1 public void testRWRebalanceWithReplication ( ) throws Exception { \n \n <ect>
<comment> \n \n \t1 private RemoveContainerCmd executeRemoveContainerRequest ( DockerClient client , Message message ) { \n \n <ect>
\t5 listener . onSucceeded ( ) ; \n \n \t4 else { \n \n \t5 switch ( status ) { \n \n \t6 case RequestSender . NOT_FINISHED : \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 throw new IllegalStateException ( e . getMessage ( ) , e ) ; } } \n \n \t1 private void unicast ( String msg , String host ) { \n \n <ect>
\t2 Scheduler sched = null ; \n \n \t2 try { \n \n \t3 sched = StdSchedulerFactory . getDefaultScheduler ( ) ; \n \n \t2 } catch ( SchedulerException e ) { \n \n <ect>
\t1 private void scanResources ( ) { \n \n \t2 Set < String > resourcePaths = getResourcesToScan ( ) ; \n \n \t2 for ( String resourcePath : resourcePaths ) { \n \n \t3 scanResource ( resourcePath ) ; } \n \n <ect>
\t3 return Pair . of ( false , null ) ; } \n \n \t2 LOGGER . debug ( <string_literal> , service ) ; \n \n \t2 final ConsentDecision decision = findConsentDecision ( service , registeredService , authentication ) ; \n \n \t2 if ( decision == null ) { \n \n <ect>
\t3 if ( ! isRootAdmin ( vmProfile ) ) { \n \n \t4 List < Long > disabledPods = listDisabledPods ( plan . getDataCenterId ( ) ) ; \n \n \t4 if ( ! disabledPods . isEmpty ( ) ) { \n \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \n \t3 logger . debug ( <string_literal> , options . getConnectionsPerHost ( ) ) ; \n \n \t3 logger . debug ( <string_literal> , options . getConnectTimeout ( ) ) ; \n \n <ect>
\t3 public void run ( ) { \n \n \t4 try { \n \n \t5 log . debug ( <string_literal> , in , out ) ; \n \n \t5 copy ( ) ; \n \n <ect>
\t3 public void run ( ) { \n \n \t4 try { \n \n \t5 Thread . sleep ( STOP_PLAYING_DELAY ) ; \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t4 state . terms . append ( state . appendIndex , entry . logEntry ( ) . term ( ) ) ; } } \n \n \t2 if ( mustRecoverLastHeader ) \n \n \t2 { \n \n \t3 SegmentHeader header = new SegmentHeader ( state . appendIndex , expectedVersion , state . appendIndex , state . terms . latest ( ) ) ; \n \n <ect>
\t3 tempDirectory = System . getProperty ( <string_literal> ) ; } \n \n \t2 if ( ! tempDirectory . endsWith ( System . getProperty ( <string_literal> ) ) ) { \n \n \t3 tempDirectory += System . getProperty ( <string_literal> ) ; } \n \n \t2 File tempDir = new File ( tempDirectory ) ; \n \n <ect>
\t1 req . getSchemaName ( ) , req . getTableName ( ) ) ; \n \n \t1 resp . setOperationHandle ( opHandle . toTOperationHandle ( ) ) ; \n \n \t1 resp . setStatus ( OK_STATUS ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 dsDesc . init ( ) ; \n \n \t2 if ( DatasetRegistry . get ( ) . isRegistered ( datasetPath ) ) \n \n \t3 throw new FusekiException ( <string_literal> + datasetPath ) ; \n \n \t2 DatasetRegistry . get ( ) . put ( datasetPath , dsDesc ) ; \n \n <ect>
\t5 if ( Desktop . isDesktopSupported ( ) ) { \n \n \t6 try { \n \n \t7 Desktop . getDesktop ( ) . browse ( new URI ( e . getDescription ( ) ) ) ; \n \n \t6 } catch ( IOException | URISyntaxException ex ) { \n \n <ect>
\t1 if ( requiredKeys != null ) { \n \n \t2 requiredKeys . remove ( key ) ; } \n \n \t1 partSpec . put ( key , kvs . get ( i - 1 ) [ 1 ] ) ; } \n \n \t1 if ( requiredKeys == null || requiredKeys . isEmpty ( ) ) return true ; \n \n <ect>
\t1 public String validateMessage ( long expiration ) { \n \n \t2 long now = _context . clock ( ) . now ( ) ; \n \n \t2 if ( now - ( Router . CLOCK_FUDGE_FACTOR * <number_literal> / <number_literal> ) >= expiration ) { \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 Cache cache = fork . get ( ) ; \n \n \t4 cache . put ( <string_literal> , <string_literal> ) ; \n \n \t4 log . debug ( <string_literal> ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t3 throws StorageUnavailableException , InsufficientCapacityException , ConcurrentOperationException , ResourceUnavailableException { \n \n \t2 s_logger . debug ( <string_literal> + internalLbVm ) ; \n \n \t2 _itMgr . start ( internalLbVm . getUuid ( ) , params , null , null ) ; \n \n \t2 if ( internalLbVm . isStopPending ( ) ) { \n \n <ect>
\t5 SamlUtil . sendSaml ( true , httpFacade , deployment . getIDP ( ) . getSingleSignOnService ( ) . getRequestBindingUrl ( ) , binding , document , samlBinding ) ; } } \n \n \t2 } ; } \n \n \t1 protected boolean verifySSL ( ) { \n \n \t2 if ( ! facade . getRequest ( ) . isSecure ( ) && deployment . getSslRequired ( ) . isRequired ( facade . getRequest ( ) . getRemoteAddr ( ) ) ) { \n \n <ect>
\t2 } else { \n \n \t3 if ( errors > 0 ) { \n \n \t4 logger . info ( <string_literal> , errors ) ; \n \n \t3 } else { \n \n <ect>
\t2 if ( ! canDownloadTask ) { \n \n \t3 Calendar c = Calendar . getInstance ( ) ; \n \n \t3 c . setTime ( foundedExp . getReleaseDate ( ) ) ; \n \n \t3 c . add ( Calendar . DATE , - 1 * DAYS_BEFORE_RELEASE_TO_DOWNLOAD ) ; \n \n <ect>
\t5 R . getI18NString ( <string_literal> ) ) ; } \n \n \t2 } ) ; } \n \n \t1 catch ( Throwable t ) \n \n \t1 { \n \n <ect>
\t4 logger . error ( <string_literal> , item . getClass ( ) . getSimpleName ( ) , \n \n \t6 statusAddress . getAddressType ( ) ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t1 if ( update ( context ) ) { \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n <ect>
\t2 if ( result ) { \n \n \t3 _context . waitForTaskProgressDone ( morTask ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t3 StreamResult sr = new StreamResult ( sw ) ; \n \n \t3 transformer . transform ( domSource , sr ) ; \n \n \t3 return sw . toString ( ) ; \n \n \t2 } catch ( TransformerException e ) { \n \n <ect>
\t2 try { \n \n \t3 connection . subscribe ( new Topic [ ] { topic } ) ; \n \n \t3 fail ( <string_literal> ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 log . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t3 throw new ProtocolException ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , <string_literal> ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t1 final Logger logger = Logger . getLogger ( PigScriptMigrationUtility . class ) ; \n \n \t1 Connection connectionHuedb = null ; \n \n \t1 Connection connectionAmbaridb = null ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \n \t2 else \n \n \t3 System . out . println ( <string_literal> ) ; \n \n <ect>
\t5 s_logger . debug ( <string_literal> + hostId + <string_literal> + agent . getPrivateIpAddress ( ) + <string_literal> ) ; } \n \n \t4 return Status . Disconnected ; <comment> \n \n \t3 } else if ( hostState == Status . Down ) { \n \n <ect>
\t2 return null ; } \n \n \t1 try { \n \n \t1 return substVars ( value , props ) ; \n \n \t1 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t3 } catch ( KeeperException e ) { \n \n \t4 Assert . fail ( <string_literal> ) ; } \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 zk . delete ( <string_literal> , 0 ) ; \n \n <ect>
\t4 cidrPair . add ( 0 , cidrAddress ) ; \n \n \t4 cidrPair . add ( 1 , new Long ( cidrSize ) ) ; \n \n \t4 currentPodCidrSubnets . put ( podId , cidrPair ) ; } \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t3 LOG . info ( <string_literal> ) ; \n \n \t3 flink = new TestingCluster ( config ) ; \n \n \t3 flink . start ( true ) ; \n \n \t3 <comment> \n \n <ect>
\t2 . getId ( ) ; \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n \t1 SingleThread threadOne = new CompletionSingleThread ( firstHumanTaskId ) ; \n \n \t1 threadOne . startAndWaitUntilControlIsReturned ( ) ; \n \n <ect>
\t3 comp . configure ( curNode ) ; \n \n \t3 currentNodeUpdated = false ; \n \n \t3 return comp ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 try { \n \n \t5 vbd . unplug ( conn ) ; \n \n \t5 vbd . destroy ( conn ) ; \n \n \t4 } catch ( final Exception e ) { \n \n <ect>
\t2 currentMovieID = Long . parseLong ( line . replaceAll ( MOVIE_DENOTER , <string_literal> ) ) ; \n \n \t1 } else { \n \n \t2 long userID = Long . parseLong ( SEPARATOR . split ( line ) [ 0 ] ) ; \n \n \t2 probes . add ( new GenericPreference ( userID , currentMovieID , 0 ) ) ; } } \n \n <ect>
\t1 char separator = ( char ) ( ( int ) oi . getSeparator ( ) + 1 ) ; \n \n \t1 log . info ( <string_literal> + String . format ( <string_literal> , ( int ) separator ) ) ; \n \n \t1 <comment> \n \n \t1 String [ ] fieldBytes = StringUtils . split ( bytesAsString , separator ) ; \n \n <ect>
\t2 final int numToSend = <number_literal> ; \n \n \t2 for ( int i = 0 ; i < ITERATIONS ; i ++ ) { \n \n \t3 produceMessages ( numToSend - 1 , <number_literal> , <string_literal> ) ; \n \n \t3 ArrayList < Message > browsed = browseMessages ( <string_literal> ) ; \n \n <ect>
\t2 if ( getRequest ( ) . isVerbose ( ) ) { \n \n \t3 if ( documentDiff . getNextReference ( ) == null ) { \n \n \t4 this . logger . info ( <string_literal> , documentDiff . getPreviousReference ( ) ) ; \n \n \t3 } else if ( documentDiff . getPreviousReference ( ) == null ) { \n \n <ect>
\t10 String xml = exchange . getIn ( ) . getBody ( String . class ) ; \n \n \t10 assertTrue ( xml , xml . contains ( <string_literal> ) ) ; \n \n \t10 int num = med . incrementAndGet ( ) ; \n \n \t10 if ( num % <number_literal> == 0 ) { \n \n <ect>
\t1 stripeKey = new OrcBatchKey ( 0 , 0 , 0 ) ; \n \n \t1 osm = new OrcStripeMetadata ( stripeKey , mr , si , null , null , null , null ) ; \n \n \t1 LOG . info ( <string_literal> + root . estimate ( osm , map ) + <string_literal> ) ; \n \n \t1 osm . resetRowIndex ( ) ; \n \n <ect>
\t5 if ( failOnDetection ) { \n \n \t6 throw new CommitFailedException ( INTEGRITY , 1 , \n \n \t8 <string_literal> + passivePath + <string_literal> + activePath + <string_literal> ) ; \n \n \t5 } else { \n \n <ect>
\t3 return false ; } \n \n \t2 final boolean ipCheck = ipPatternCanBeChecked ( remoteIp ) ; \n \n \t2 if ( ipCheck && ! ipPatternMatches ( remoteIp ) ) { \n \n \t3 return false ; } \n \n <ect>
\t1 static { \n \n \t2 try { \n \n \t3 instantiator = new ObjenesisStd ( false ) . getInstantiatorOf ( FastStringPrintWriter . class ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 req . taskNameHash ( ) ) ; \n \n \t4 tx = ctx . tm ( ) . onCreated ( tx ) ; \n \n \t4 if ( tx == null || ! ctx . tm ( ) . onStarted ( tx ) ) { \n \n <ect>
\t3 Long zoneId = imageStore . getScope ( ) . getScopeId ( ) ; \n \n \t3 if ( zoneId != null ) { \n \n \t4 DataCenterVO zone = _dcDao . findById ( zoneId ) ; \n \n \t4 if ( zone == null ) { \n \n <ect>
\t6 <comment> \n \n \t6 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t6 interrupted = true ; } } \n \n \t4 if ( debug ) { \n \n <ect>
\t5 if ( uuid != null && ! uuid . isEmpty ( ) ) \n \n \t6 return uuid ; \n \n \t5 return identityString ; } \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t5 while ( ! thread . isInterrupted ( ) && channel . isOpen ( ) ) { <comment> \n \n \t6 if ( selector . select ( ) > 0 ) { \n \n \t7 processSelectedKeys ( selector . selectedKeys ( ) ) ; } } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 } finally { \n \n \t3 removeNamespace ( testName ) ; \n \n \t3 removeNamespace ( testName2 ) ; \n \n \t3 tHandle . close ( ) ; } \n \n <ect>
\t3 redirector = ( ERXComponentActionRedirector ) responses . valueForKeyPath ( request . sessionID ( ) + <string_literal> + request . uri ( ) ) ; } \n \n \t2 if ( redirector != null ) { \n \n \t3 log . debug ( <string_literal> , redirector . url ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 LOG . debug ( <string_literal> ) ; \n \n \t2 rollbackDBConn ( dbConn ) ; \n \n \t2 checkRetryable ( dbConn , e , <string_literal> ) ; \n \n \t2 if ( e . getMessage ( ) . contains ( <string_literal> ) ) { \n \n <ect>
\t4 if ( LOG_LEVELS . contains ( logLevel ) ) { \n \n \t5 boolean isInfoLevel = <string_literal> . equals ( logLevel ) ; \n \n \t5 logFilter = new TikaLoggingFilter ( isInfoLevel ) ; \n \n \t4 } else { \n \n <ect>
\t2 case UPLOAD_FINISHED : \n \n \t3 tu . setUploadError ( <string_literal> ) ; \n \n \t3 String result = postUpload ( jobId ) ; \n \n \t3 if ( result != null ) { \n \n <ect>
\t1 @ Override \n \n \t1 public ApplicationContext loadContext ( MergedContextConfiguration mergedConfig ) throws Exception { \n \n \t2 Class < ? > testClass = getTestClass ( ) ; \n \n <ect>
\t2 host = prop . getProperty ( <string_literal> ) ; \n \n \t2 secretkey = prop . getProperty ( <string_literal> ) ; \n \n \t2 port = prop . getProperty ( <string_literal> ) ; \n \n \t2 if ( host == null ) { \n \n <ect>
\t1 Table t ; \n \n \t1 try { \n \n \t2 t = msClient . getTable ( endPoint . database , endPoint . table ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 if ( sprite == null ) { \n \n \t6 sprite = AtlasSpriteVariants . createForConfig ( new ResourceLocation ( name ) ) ; \n \n \t6 map . setTextureEntry ( sprite ) ; \n \n \t5 } else { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n <comment> \n \n <ect>
\t3 try { \n \n \t4 com . sendTransaction ( new Cardio2eLoginTransaction ( programCode ) ) ; <comment> \n \n <number_literal> <comment> \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t5 new String [ ] { <string_literal> } ) ; \n \n \t3 s_logger . info ( <string_literal> \n \n \t5 + success . get ( <string_literal> ) ) ; \n \n \t2 } else { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , CasProtocolConstants . PARAMETER_RENEW , renewParam ) ; \n \n \t2 if ( StringUtils . isNotBlank ( ticketGrantingTicketId ) && service != null ) { \n \n \t3 final Authentication authn = ticketRegistrySupport . getAuthenticationFrom ( ticketGrantingTicketId ) ; \n \n \t3 if ( StringUtils . isNotBlank ( renewParam ) ) { \n \n <ect>
\t3 long reservedCpuValueToUse = reservedCpu ; \n \n \t3 long reservedMemValueToUse = reservedMem ; \n \n \t3 if ( ! considerReservedCapacity ) { \n \n <ect>
<comment> \n \n \t1 protected boolean checkConditions ( ) { \n \n \t2 if ( getFromAddress ( ) == null && getDomainName ( ) == null ) { \n \n <ect>
\t2 List < RemoteConfig > result = null ; \n \n \t2 try { \n \n \t3 result = git . remoteList ( ) . call ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected void initRepository ( ) throws SQLException { \n \n \t2 if ( repository ( ) != null ) { \n \n \t3 return ; } \n \n <ect>
\t4 stateMap . putAll ( mapToProcess ) ; \n \n \t4 sonosBinding . processVariableMap ( device , mapToProcess ) ; } } \n \n \t2 @ Override \n \n \t2 public void eventsMissed ( GENASubscription sub , int numberOfMissedEvents ) { \n \n <ect>
<comment> \n \n \t1 public Future < Void > deleteActivities ( final UserId userId , final GroupId groupId , final String appId , \n \n \t3 final Set < String > activityIds , final SecurityToken token ) \n \n \t1 { \n \n <ect>
\t6 statement . close ( ) ; } \n \n \t5 catch ( Throwable ignore ) { \n \n \t6 <comment> \n \n \t3 catch ( Exception e ) { \n \n <ect>
<number_literal> altKeyName , \n \n <number_literal> resource ) ) ; } \n \n \t2 catch ( InvalidAlternativeKeyException e ) \n \n \t2 { \n \n <ect>
\t4 try { \n \n \t5 log . info ( <string_literal> + msg + <string_literal> + nodeId + \n \n \t6 <string_literal> ) ; \n \n \t5 if ( ! nodeId . equals ( grid1 . localNode ( ) . id ( ) ) ) { \n \n <ect>
\t3 String reason = getFailReason ( KEY_RANGER_UNKNOWN_RESPONSE , check , request ) ; \n \n \t3 warnReasons . add ( String . format ( reason , rangerAdminUsername , response , rangerAuthUrl ) ) ; \n \n \t3 break ; } } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t6 val = simulateBlockers ( game , node , playerId , alpha , beta , true ) ; \n \n \t5 else \n \n \t6 val = GameStateEvaluator . evaluate ( playerId , game ) ; } } \n \n \t3 else if ( ! node . getChildren ( ) . isEmpty ( ) ) { \n \n <ect>
\t2 configure ( p ) ; \n \n \t2 String inputDirectoryName = p . getProperty ( <string_literal> ) ; \n \n \t2 File f = new File ( inputDirectoryName ) ; \n \n \t2 if ( ! f . exists ( ) || ! f . isDirectory ( ) ) { \n \n <ect>
\t2 <string_literal> + \n \n \t3 <string_literal> + \n \n \t3 <string_literal> , rows ) ; \n \n \t2 for ( String query : queries ) { \n \n <ect>
\t3 else { \n \n \t4 result = this . scriptEngine . eval ( script ) ; } \n \n \t3 result = postProcess ( result , this . scriptEngine , script , bindings ) ; \n \n <ect>
\t2 <comment> \n \n \t2 this . store . close ( ) ; } \n \n \t1 @ Override \n \n \t1 public void txStarted ( String id ) { \n \n <ect>
\t3 return true ; \n \n \t2 } catch ( AuthException e ) { \n \n \t3 LOG . debug ( <string_literal> + context . describe ( resourceAccountNumber , resourceName ) + <string_literal> + e . getMessage ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 if ( videoCodec != null ) { \n \n \t4 try { \n \n \t5 pVideoCodec = Pattern . compile ( videoCodec ) ; \n \n \t4 } catch ( PatternSyntaxException pse ) { \n \n <ect>
\t2 { \n \n \t3 waiter . onSuccess ( item ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t4 getReport ( ) . println ( \n \n \t5 Messages . get ( ) . container ( Messages . RPT_DATABASEAPP_DEL_PROPERTY_END_OK_0 ) , \n \n \t5 I_CmsReport . FORMAT_OK ) ; \n \n \t3 } catch ( CmsException e ) { \n \n <ect>
\t2 when ( severity ) { \n \n \t3 CompilerMessageSeverity . ERROR , \n \n \t3 CompilerMessageSeverity . EXCEPTION - > { \n \n \t4 hasErrors = true \n \n <ect>
\t2 connection . request ( createCommitTransaction2Phase ( connectionInfo , txid ) ) ; \n \n \t2 <comment> \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 m = receiveMessage ( connectionC , TimeUnit . SECONDS . toMillis ( <number_literal> ) ) ; \n \n <ect>
\t5 mimeType = <string_literal> + imgReader . next ( ) . getFormatName ( ) . toLowerCase ( ) ; \n \n \t4 } else { \n \n \t5 log . warn ( <string_literal> + file . getAbsolutePath ( ) + <string_literal> ) ; } } \n \n \t3 catch ( FileNotFoundException e ) { \n \n <ect>
\t5 map . put ( sizeKey , fileSize ) ; } \n \n \t4 file . unlockSystemPropertiesOnce ( ) ; \n \n \t4 file . setProperties ( file . getSecurityContext ( ) , map ) ; \n \n \t3 } catch ( IOException ioex ) { \n \n <ect>
\t3 logger . error ( e . getMessage ( ) , e ) ; \n \n \t3 if ( e . getMessage ( ) != null && \n \n \t3 e . getMessage ( ) . startsWith ( <string_literal> ) ) { \n \n \t3 if ( Options . v ( ) . verbose ( ) ) \n \n <ect>
\t3 if ( aliases != null && ! aliases . contains ( new EquivalentValue ( stmtToLocal . get ( u ) ) ) ) \n \n \t3 { \n \n <comment> \n \n \t4 return false ; } } \n \n <ect>
\t5 } catch ( SocketTimeoutException e ) { \n \n \t6 sendKeepalive ( ) ; } } \n \n \t4 disconnect ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 String hostname = s . getHosts ( ) . get ( 0 ) ; \n \n \t1 List < ExecutionCommandWrapper > wrappers = s . getExecutionCommands ( hostname ) ; \n \n \t1 for ( ExecutionCommandWrapper wrapper : wrappers ) { \n \n \t1 <comment> \n \n <ect>
\t1 private Instance < ServiceLoader > loader ; \n \n \t1 public void createRegistry ( @ Observes ArquillianDescriptor event ) { \n \n \t2 ContainerRegistry reg = new Registry ( injector . get ( ) ) ; \n \n \t2 ServiceLoader serviceLoader = loader . get ( ) ; \n \n <ect>
\t2 LOG . warn ( String . format ( <string_literal> , groupName ) ) ; } \n \n \t1 try { \n \n \t2 EucalyptusActivityTasks . getInstance ( ) . updateAutoScalingGroup ( groupName , null , 0 , lb . useSystemAccount ( ) ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t5 Constants . SHARE_FILE_NAME , text ) \n \n \t3 val fileUri = Uri . parse ( <string_literal> + CachedFileProvider . AUTHORITY + <string_literal> + Constants . SHARE_FILE_NAME ) \n \n \t3 shareIntent . putExtra ( android . content . Intent . EXTRA_STREAM , fileUri ) \n \n \t2 } catch ( e : Exception ) { \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; } \n \n \t2 @ Override \n \n \t2 public void onError ( Throwable e ) \n \n \t2 { \n \n <ect>
\t1 _store . put ( propertyName , propertyValue ) ; \n \n \t1 LOG . debug ( <string_literal> + propertyName + <string_literal> + propertyValue ) ; } \n \n \t1 catch ( PropertyStoreException e ) \n \n \t1 { \n \n <ect>
\t3 accumulate = selfRef . ensureReleased ( accumulate ) ; \n \n \t3 return accumulate ; } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t2 ops . resetMessage ( ) ; \n \n \t2 xLog . debug ( <string_literal> ) ; \n \n \t2 assertTrue ( log . getMessage ( ) . endsWith ( <string_literal> ) ) ; \n \n \t2 assertNull ( ops . getMessage ( ) ) ; \n \n <ect>
\t4 <comment> <ect>
\t3 sock . close ( ) ; \n \n \t3 long afterSending = System . currentTimeMillis ( ) ; \n \n \t3 System . out . println ( <string_literal> + ( size / <number_literal> ) + <string_literal> + ( afterSending - beforeSending ) + <string_literal> ) ; \n \n \t2 } catch ( InterruptedIOException iie ) { \n \n <ect>
\t5 asyncExecCallback . failed ( new HttpException ( <string_literal> ) ) ; \n \n \t5 return ; \n \n \t4 case HttpRouteDirector . LAYER_PROTOCOL : \n \n \t5 execRuntime . upgradeTls ( clientContext ) ; \n \n <ect>
\t2 LOG . info ( <string_literal> + function + <string_literal> + args + <string_literal> + ( System . currentTimeMillis ( ) ) ) ; \n \n \t2 try { \n \n \t3 sem . acquire ( ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , ip . getId ( ) , ports ) ; \n \n \t3 Set < FirewallRule > rules = setupFirewallRulesForIP . apply ( ip , ports ) ; \n \n \t3 logger . trace ( <string_literal> , rules . size ( ) , ip . getId ( ) ) ; } } \n \n \t1 } catch ( RuntimeException re ) { \n \n <ect>
\t2 conf , HiveConf . ConfVars . HIVE_EXECUTION_MODE ) ) ; \n \n \t1 <comment> \n \n \t1 UserGroupInformation ugi = Utils . getUGI ( ) ; \n \n \t1 user = ugi . getShortUserName ( ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( jmxServerBean != null ) { \n \n \t4 MBeanRegistry . getInstance ( ) . unregister ( jmxServerBean ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 Method method = Method . getMethodById ( dev . getStatus ( ) ) ; \n \n \t5 sendToOpenHab ( name , resolveCommand ( method , dev . getData ( ) ) ) ; } } } \n \n \t2 lastRefresh = System . currentTimeMillis ( ) ; } \n \n \t1 private void resetTellstick ( ) { \n \n <ect>
\t2 return - 1 ; } \n \n \t1 public static boolean sshExecuteCmd ( com . trilead . ssh2 . Connection sshConnection , String cmd ) { \n \n \t2 return sshExecuteCmd ( sshConnection , cmd , <number_literal> ) ; } \n \n \t1 public static int sshExecuteCmdOneShotWithExitCode ( com . trilead . ssh2 . Connection sshConnection , String cmd ) throws sshException { \n \n <ect>
\t3 success = false ; } \n \n \t2 try { \n \n \t3 amRMClient . unregisterApplicationMaster ( appStatus , appMessage , null ) ; \n \n \t2 } catch ( YarnException ex ) { \n \n <ect>
\t2 try ( Tx tx = StructrApp . getInstance ( ) . tx ( ) ) { \n \n \t3 size = page . getContent ( RenderContext . EditMode . RAW ) . length ( ) ; \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t2 try { \n \n \t3 if ( resource != null ) { \n \n \t4 resource . close ( ) ; } \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t5 PropertiesConfiguration config = new PropertiesConfiguration ( solrConfigDir ) ; \n \n \t5 config . setProperty ( <string_literal> , new DCDate ( oldestDate ) ) ; \n \n \t5 config . save ( ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n <ect>
\t4 return false ; } } \n \n \t2 try { \n \n \t3 expungeVolume ( volume , false ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 SHUFFLE = getShuffle ( conf ) ; \n \n \t1 <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t2 if ( mappingContext == null ) { \n \n \t3 throw new GrailsConfigurationException ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t2 public void run ( ) { \n \n \t3 try { \n \n \t4 listener . notifyLeaderAddress ( address , leaderSessionId ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t5 s_logger . error ( <string_literal> + ex ) ; } \n \n \t4 if ( conn == null ) { \n \n \t5 s_logger . error ( <string_literal> ) ; } \n \n \t4 Session sess = conn . openSession ( ) ; \n \n <ect>
\t5 this . zController . sendData ( wakeupCommandClass . getIntervalMessage ( ) ) ; } \n \n \t4 if ( splitDomain [ <number_literal> ] . equals ( <string_literal> ) ) { \n \n \t5 if ( splitDomain [ <number_literal> ] . equals ( <string_literal> ) ) { \n \n \t6 ZWaveDeviceType type = ZWaveDeviceType . fromString ( value ) ; \n \n <ect>
\t6 target . getClass ( ) . getField ( propertyNames [ rowIndex ] ) ; \n \n \t5 Object obj = f . get ( target ) ; \n \n \t5 return obj ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 if ( notifier . isEnabled ( event ) ) { \n \n \t5 notifier . notify ( event ) ; } } } } \n \n \t1 @ Deprecated \n \n \t1 public void setStatisticsLevel ( ManagementStatisticsLevel level ) { \n \n <ect>
\t3 return ; \n \n \t2 } finally { \n \n \t3 if ( in != null ) try { in . close ( ) ; } catch ( IOException ioe ) { } } \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 PreparedStatement pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t2 try { \n \n \t3 pstmt . executeUpdate ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t1 try { \n \n \t2 if ( ! dfs . recoverLease ( source ) ) { \n \n \t2 log . info ( <string_literal> , source . toString ( ) ) ; \n \n \t2 return conf . getTimeInMillis ( Property . MASTER_LEASE_RECOVERY_WAITING_PERIOD ) ; } \n \n <ect>
\t2 try { \n \n \t3 if ( ! pingXenServer ( ) ) { \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n \t4 if ( ! pingXenServer ( ) ) { \n \n <ect>
\t2 st . close ( ) ; } \n \n \t2 if ( null != manager ) { \n \n \t2 manager . close ( ) ; } \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t3 return empty ; } \n \n \t2 try { \n \n \t3 return jobStoreGit . getGitLog ( jobId ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 if ( ! directory . exists ( ) ) { \n \n \t6 this . logger . warn ( <string_literal> , directory ) ; \n \n \t6 continue ; } \n \n \t5 if ( ! directory . isDirectory ( ) ) { \n \n <ect>
\t2 } catch ( ExecutionException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 throw new CloudRuntimeException ( e . getMessage ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t4 initiator . start ( ) ; \n \n \t4 initiatorStarted = true ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 EOModel modelForCopy = model . modelGroup ( ) . modelNamed ( modelName ) ; \n \n \t3 if ( modelForCopy != null && modelForCopy != model ) { \n \n \t4 jdbcInfoDictionary = ( NSDictionary ) modelForCopy . connectionDictionary ( ) . objectForKey ( <string_literal> ) ; } \n \n \t3 else { \n \n <ect>
\t4 try { \n \n \t5 jobClient . close ( ) ; } \n \n \t4 catch ( Exception e ) { \n \n \t5 if ( exception ) { \n \n <ect>
\t3 return no ( ) ; } \n \n \t2 final String principal = c . getPrincipal ( ) . getId ( ) ; \n \n \t2 final LocalDate onOrAfter = LocalDate . now ( ) . minus ( trustedProperties . getExpiration ( ) , \n \n \t4 DateTimeUtils . toChronoUnit ( trustedProperties . getTimeUnit ( ) ) ) ; \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t4 closer . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 objectInputStream . close ( ) ; \n \n \t4 return throwable ; } \n \n \t3 catch ( ClassNotFoundException cnfe ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 index ( <string_literal> , <string_literal> , Integer . toString ( i ) , <string_literal> , <string_literal> + i ) ; \n \n \t3 index ( <string_literal> , <string_literal> , Integer . toString ( i ) , <string_literal> , <string_literal> + i ) ; \n \n \t3 index ( <string_literal> , <string_literal> , Integer . toString ( i ) , <string_literal> , <string_literal> + i ) ; } \n \n \t2 refresh ( ) ; \n \n <ect>
\t2 chain . add ( new ClasspathPropertiesFileCredentialsProvider ( <string_literal> ) ) ; \n \n \t2 if ( StringUtils . isNotBlank ( credentialAccessKey ) && StringUtils . isNotBlank ( credentialSecretKey ) ) { \n \n \t3 final BasicAWSCredentials credentials = new BasicAWSCredentials ( credentialAccessKey , credentialSecretKey ) ; \n \n \t3 chain . add ( new AWSStaticCredentialsProvider ( credentials ) ) ; } \n \n <ect>
\t3 <comment> \n \n \t3 if ( NodeStateUtils . isHidden ( dirName ) && MultiplexersLucene . isIndexDirName ( dirName ) ) { \n \n \t4 DirectoryStatus dirStatus = new DirectoryStatus ( dirName ) ; \n \n \t4 result . dirStatus . add ( dirStatus ) ; \n \n <ect>
\t2 } else { \n \n \t3 List < PhysicalOperator > leafPOs = sparkOperator . physicalPlan . getLeaves ( ) ; \n \n \t3 <comment> \n \n <ect>
\t1 public void commit ( ) { \n \n \t2 commitedState = new TxIdState < > ( DEFAULT_TXID , new ConcurrentHashMap < > ( state ) ) ; } \n \n \t1 @ Override \n \n \t1 public void prepareCommit ( long txid ) { \n \n <ect>
\t4 <comment> \n \n \t4 boolean warn = System . currentTimeMillis ( ) - latestErrorWarn > ERROR_WARN_INTERVAL ; \n \n \t4 if ( warn ) { \n \n \t5 latestErrorWarn = System . currentTimeMillis ( ) ; \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( oldMcNode == null ) \n \n \t2 { \n \n <ect>
\t1 return ifReplayableBackoffAndReturnTrue ( command ) ; } \n \n private boolean ifReplayableBackoffAndReturnTrue ( HttpCommand command ) { \n \n \t1 command . incrementFailureCount ( ) ; \n \n \t1 if ( ! command . isReplayable ( ) ) { \n \n <ect>
\t4 getStore ( ) . createWiki ( wikiName , context ) ; \n \n \t3 } catch ( XWikiException e ) { \n \n \t4 if ( LOGGER . isErrorEnabled ( ) ) { \n \n \t5 if ( e . getCode ( ) == <number_literal> ) { \n \n <ect>
\t3 try { \n \n \t4 TaskShutdownDameon shutdown = Task . mk_task ( workerData , taskId ) ; \n \n \t4 workerData . addShutdownTask ( shutdown ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 sb . append ( <string_literal> ) ; \n \n \t1 sb . append ( port ) ; \n \n \t1 sb . append ( COLLECTOR_LIVE_NODES_PATH ) ; \n \n \t1 String connectUrl = sb . toString ( ) ; \n \n <ect>
\t3 m_details . setValue ( generateInfoDetails ( cms , UI . getCurrent ( ) . getLocale ( ) ) ) ; \n \n \t3 m_infoPanel . addComponent ( createImageButton ( ) , 0 ) ; \n \n \t3 m_menu . setVisible ( false ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t2 if ( hasWorld ( ) ) { \n \n \t3 final Side side = world . isRemote ? Side . CLIENT : Side . SERVER ; \n \n \t3 return createMessage ( id , ( buffer ) - > writePayload ( id , buffer , side ) ) ; \n \n \t2 } else { \n \n <ect>
\t7 onUp ( host , connection ) ; \n \n \t6 } catch ( InterruptedException e ) { \n \n \t7 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + sequenceIndex + <string_literal> + lookupListIndex ) ; \n \n \t3 posLookupRecords . add ( new PosLookupRecord ( sequenceIndex , lookupListIndex ) ) ; } \n \n \t2 for ( int backtrackGlyphOffset : backtrackGlyphOffsets ) { \n \n \t3 List < Integer > backtrackGlyphs = readCoverageFormat ( lookupTableLocation + backtrackGlyphOffset ) ; \n \n <ect>
\t6 relatedNodes . add ( n ) ; } \n \n \t4 } else { \n \n \t5 relatedNodes . add ( ( T ) source ) ; } } \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t4 BlobContainer indexMetaDataBlobContainer = blobStore ( ) . blobContainer ( indexPath ) ; \n \n \t4 try { \n \n \t5 indexMetaDataFormat . delete ( indexMetaDataBlobContainer , snapshotId . getUUID ( ) ) ; \n \n \t4 } catch ( IOException ex ) { \n \n <ect>
\t3 clientLog . logSeek ( logStreamId , pos ) ; \n \n \t2 if ( pos > limit ) \n \n \t3 pos = limit ; \n \n <ect>
\t3 LOG . info ( <string_literal> + this . getClass ( ) . getName ( ) \n \n \t4 + <string_literal> \n \n \t4 + ( System . currentTimeMillis ( ) - start ) + <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 final int numLists = <number_literal> ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 for ( int i = 0 ; i < numLists ; i ++ ) { \n \n \t3 new Job ( i , PListTestSupport . TaskType . CREATE , iterations ) . run ( ) ; } \n \n <ect>
\t2 URI uri ; \n \n \t2 try { \n \n \t3 uri = new URI ( url ) ; \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
\t3 minionPid = Integer . valueOf ( processName . substring ( 0 , processName . indexOf ( <string_literal> ) ) ) ; \n \n \t3 log . info ( <string_literal> , minionPid ) ; \n \n \t3 minionTaskDeleter . startDeletionThread ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 { \n \n \t3 logger . error ( <string_literal> , e ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t1 jr . endArray ( ) ; \n \n \t1 } catch ( FileNotFoundException e ) { \n \n \t1 logger . info ( <string_literal> + filePath + <string_literal> ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 try { \n \n \t1 Type type = new TypeToken < Map < String , Map < String , List < AlertDefinition > > > > ( ) { } . getType ( ) ; \n \n \t1 serviceDefinitionMap = m_gson . fromJson ( reader , type ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 byte [ ] hisHash = ( ( ShortBuffer ) origMessage . getObject ( DMT . HASH ) ) . getData ( ) ; \n \n \t3 if ( hisHash . length != md . getDigestLength ( ) ) { \n \n <ect>
\t2 jg . close ( ) ; } \n \n \t2 if ( writer != null ) { \n \n \t2 writer . close ( ) ; } } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 return null ; } \n \n \t4 s_logger . debug ( <string_literal> + vm . toString ( ) + <string_literal> + _restartRetryInterval ) ; } \n \n \t2 } catch ( final InsufficientCapacityException e ) { \n \n <ect>
\t1 public void testMapProduceMultiPoints ( ) throws Exception { \n \n \t2 final FeatureSource < SimpleFeatureType , SimpleFeature > fs = testDS \n \n \t4 . getFeatureSource ( <string_literal> ) ; \n \n \t2 final ReferencedEnvelope env = new ReferencedEnvelope ( fs . getBounds ( ) , WGS84 ) ; \n \n <ect>
\t4 if ( replyChannel == null ) { \n \n \t5 throw new IllegalArgumentException ( <string_literal> + this ) ; } \n \n \t4 replyChannel . subscribe ( new MessageHandler ( ) { \n \n \t5 public void handleMessage ( Message < ? > message ) { \n \n <ect>
\t2 final ReservationContext context = new ReservationContextImpl ( null , null , callerUser , owner ) ; \n \n \t2 final List < NicVO > nics = _nicDao . listByVmId ( routerId ) ; \n \n \t2 for ( final NicVO nic : nics ) { \n \n \t3 if ( ! _networkMgr . startNetwork ( nic . getNetworkId ( ) , dest , context ) ) { \n \n <ect>
\t3 @ Override \n \n \t3 public Boolean execute ( ) throws MageException { \n \n \t4 Optional < Session > session = SessionManager . instance . getSession ( sessionId ) ; \n \n \t4 if ( ! session . isPresent ( ) ) { \n \n <ect>
<comment> \n \n \t1 public void resetTemplateCache ( NSNotification n ) { \n \n \t2 _cache = new Hashtable < > ( <number_literal> ) ; \n \n <ect>
\t3 <comment> \n \n \t3 assertionMap . put ( key , true ) ; <comment> \n \n \t10 <comment> \n \n <ect>
\t5 logger . debug ( contextImpl , <string_literal> , <string_literal> , <string_literal> , name ) ; \n \n \t4 name = Boon . add ( field . declaringParent ( ) . getPackage ( ) . getName ( ) , <string_literal> , field . alias ( ) ) ; } \n \n \t3 value = this . get ( name ) ; \n \n \t3 if ( debug && value == null ) { \n \n <ect>
\t4 <comment> \n \n \t4 wakeUpCommandClass . setAwake ( false ) ; \n \n \t4 wakeUpCommandClass . processOutgoingWakeupMessage ( originalMessage ) ; \n \n \t4 return false ; } } \n \n <ect>
\t1 public Action invokeInterceptors ( List < AtmosphereInterceptor > c , AtmosphereResource r , int tracing ) { \n \n \t2 Action a = Action . CONTINUE ; \n \n \t2 for ( AtmosphereInterceptor arc : c ) { \n \n \t3 if ( ! AtmosphereResourceImpl . class . cast ( r ) . isInScope ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( completeHandler != null ) { \n \n \t4 future . addListener ( completeHandler , client . getConfig ( ) . executorService ( ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 serverTransaction . sendResponse ( response ) ; \n \n \t5 return ; } \n \n \t4 catch ( SipException e ) \n \n \t4 { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t1 if ( hosts == null ) { \n \n \t1 return ; } \n \n \t1 File done ; \n \n \t1 File log ; \n \n <ect>
\t4 logger . info ( <string_literal> ) ; \n \n \t4 libraryLoaded = true ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t3 session = request . getSession ( false ) ; } \n \n \t2 if ( session != null ) { \n \n \t3 logger . debug ( <string_literal> + session . getId ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t4 = GuiActivator . bundleContext . getServiceReferences ( \n \n \t5 CustomContactActionsService . class . getName ( ) , null ) ; } \n \n \t2 catch ( InvalidSyntaxException e ) \n \n \t2 { \n \n <ect>
\t4 try { \n \n \t5 ( ( Channel ) recoverable ) . basicCancel ( <string_literal> ) ; } \n \n \t4 catch ( IOException e ) { } \n \n <ect>
\t2 catalog . validate ( ftInfo , true ) . throwIfInvalid ( ) ; \n \n \t2 catalog . add ( ftInfo ) ; \n \n \t2 <comment> \n \n \t2 catalog . add ( new CatalogBuilder ( catalog ) . buildLayer ( ftInfo ) ) ; \n \n <ect>
\t5 log . info ( <string_literal> , value , value . getClass ( ) ) ; \n \n \t5 continue ; } \n \n \t4 optParams . add ( optParam ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t9 + this . identityNode . getStateString ( ) ; \n \n \t4 logger . error ( errorMessage ) ; \n \n \t4 throw new VoldemortApplicationException ( errorMessage ) ; \n \n \t3 } else { \n \n <ect>
\t3 sslContext = SSLContext . getInstance ( <string_literal> , <string_literal> ) ; \n \n \t2 } catch ( NoSuchAlgorithmException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( NoSuchProviderException e ) { \n \n <ect>
\t4 updateCounter ( getCounter ( c , <string_literal> ) , stats . size ) ; \n \n \t4 updateCounter ( getCounter ( c , <string_literal> ) , stats . storageSize ) ; \n \n \t4 updateCounter ( getCounter ( c , <string_literal> ) , stats . totalIndexSize ) ; } \n \n \t2 } catch ( MongoException e ) { \n \n <ect>
\t2 StreamReader esr = null ; \n \n \t2 Result result ; \n \n \t2 try { \n \n <ect>
\t5 logger . info ( <string_literal> , nm ( ) , dev . getAddress ( ) ) ; } \n \n \t3 } catch ( IOException e ) { \n \n \t4 logger . error ( <string_literal> , nm ( ) , e ) ; \n \n \t3 } catch ( FieldException e ) { \n \n <ect>
\t2 LOG . info ( <string_literal> , RANDOM_SEED ) ; \n \n \t2 final ExecutionEnvironment env = ExecutionEnvironment . getExecutionEnvironment ( ) ; \n \n \t2 env . getConfig ( ) . disableSysoutLogging ( ) ; \n \n \t2 for ( int parallelism = MAX_PARALLELISM ; parallelism > 0 ; parallelism -- ) { \n \n <ect>
\t4 group . getAttributes ( ) . get ( <string_literal> ) . get ( 1 ) + <string_literal> ) ; \n \n \t2 group = updateEntityOnCurrentFailNode ( group , <string_literal> ) ; \n \n \t2 verifyEntityUpdateDuringFailover ( group , backendFailover ) ; \n \n \t2 <comment> \n \n <ect>
\t4 new Class < ? > [ 0 ] ) ; \n \n \t4 unixos = classRef . cast ( osMbean ) ; \n \n \t4 return ( Long ) mBeanMethod . invoke ( unixos ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t4 LOG . error ( <string_literal> ) ; \n \n \t4 throw e ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 gameZone = Zone . BATTLEFIELD ; \n \n \t4 } else if ( <string_literal> . equalsIgnoreCase ( command . zone ) ) { \n \n \t5 gameZone = Zone . COMMAND ; \n \n \t4 } else { \n \n <ect>
\t5 public ClusterState execute ( ClusterState currentState ) throws Exception { \n \n \t6 return ClusterState . builder ( currentState ) . build ( ) ; } \n \n \t5 @ Override \n \n \t5 public void onFailure ( String source , Exception e ) { \n \n <ect>
\t6 Preconditions . checkState ( setup . getFilterPartitionedVertices ( ) , \n \n \t8 <string_literal> + \n \n \t8 <string_literal> , \n \n \t8 relation . relationId , vertexId , relation . getOtherVertexId ( ) , type . name ( ) ) ; \n \n <ect>
\t1 } catch ( IOException e ) { \n \n \t2 String msg = <string_literal> + srcPath . toUri ( ) . toString ( ) ; \n \n \t2 LOG . error ( msg ) ; \n \n \t2 throw new HiveException ( msg , e ) ; } \n \n <ect>
\t2 evt . setDbName ( REPORTING_DB_NAME ) ; \n \n \t2 DatabaseEventListeners . getInstance ( ) . fire ( evt ) ; \n \n \t2 vmCreated = true ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t7 logger . info ( <string_literal> ) ; \n \n \t7 readLatch . countDown ( ) ; \n \n \t7 <comment> \n \n \t7 updateLatch . await ( ) ; \n \n <ect>
\t3 lock . unlock ( ) ; } } \n \n \t1 @ Override \n \n \t1 public void storeStopEvent ( final DaemonStopEvent stopEvent ) { \n \n \t2 lock . lock ( ) ; \n \n <ect>
\t3 log . debug ( <string_literal> + concept . getConceptId ( ) ) ; } \n \n \t2 ConceptName conceptName = getConceptName ( obx . getObservationIdentifier ( ) ) ; \n \n <ect>
\t1 public boolean bfck ( boolean fix ) { \n \n \t2 if ( log . shouldLog ( Log . INFO ) ) { \n \n \t3 log . info ( <string_literal> + magicBytes ) ; \n \n \t3 log . info ( <string_literal> + fileLen ) ; \n \n <ect>
\t1 example . setVolumeId ( vol ) ; \n \n \t1 VolumeInfo volEntity = Entities . uniqueResult ( example ) ; \n \n \t1 LOG . info ( <string_literal> + volEntity . getVolumeId ( ) + <string_literal> + volEntity . getStatus ( ) ) ; \n \n \t1 for ( VolumeToken tok : volEntity . getAttachmentTokens ( ) ) { \n \n <ect>
\t2 return i < fonts . size ( ) ? fonts . get ( i ) : unsupportedFonts . get ( i ) ; } \n \n \t1 private boolean isSupported ( Font font ) { \n \n \t2 BaseFont bf = font . getBaseFont ( ) ; \n \n \t2 if ( bf instanceof TrueTypeFont && BaseFont . WINANSI . equals ( bf . getEncoding ( ) ) && ! ( ( TrueTypeFont ) bf ) . isWinAnsiSupported ( ) ) { \n \n <ect>
\t6 return Calendar . SATURDAY ; \n \n \t5 case So : \n \n \t6 return Calendar . SUNDAY ; } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t7 log . debug ( <string_literal> + d ) ; \n \n \t6 if ( d . senderId ( ) . equals ( id ) || d . removeParticipant ( id ) ) { \n \n \t7 deps . remove ( entry . getKey ( ) , d ) ; \n \n <ect>
\t6 . put ( <string_literal> , randomIntBetween ( <number_literal> , <number_literal> ) , ByteSizeUnit . BYTES ) ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 CreateSnapshotResponse createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) . setWaitForCompletion ( true ) . setIndices ( <string_literal> ) . get ( ) ; \n \n \t2 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . state ( ) , equalTo ( SnapshotState . PARTIAL ) ) ; \n \n <ect>
\t2 if ( StringUtils . hasText ( this . userFlag ) ) { \n \n \t3 receiver . setUserFlag ( this . userFlag ) ; } \n \n \t2 if ( isPop3 ) { \n \n <ect>
\t1 protected int trimAlignWrite ( final VariantContext vc , final ReferenceContext ref , final int numBiallelics ) { \n \n \t2 final int refLength = vc . getReference ( ) . length ( ) ; \n \n \t2 <comment> \n \n \t2 if ( refLength > MAX_INDEL_LENGTH && refLength > referenceWindowStop ) { \n \n <ect>
\t3 LOG . info ( <string_literal> + numberOfMessageSent ) ; \n \n \t3 return numberOfMessageSent ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 LOG . info ( <string_literal> , ex ) ; \n \n <ect>
\t5 if ( key instanceof String ) { \n \n \t6 if ( this . defaultOverwrite || headerMap . get ( key ) == null ) { \n \n \t7 headerMap . put ( ( String ) key , entry . getValue ( ) ) ; } } \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
\t4 PopupMessageHandler . class . getName ( ) \n \n \t4 , new NonePopupMessageHandlerImpl ( ) \n \n \t4 , null ) ; \n \n <ect>
\t3 while ( ! found && it . hasNext ( ) ) { \n \n \t4 try { \n \n \t5 final WsFederationConfiguration c = it . next ( ) ; \n \n \t5 final Decrypter decrypter = buildAssertionDecrypter ( c ) ; \n \n <ect>
\t2 logger . info ( <string_literal> ) ; } \n \n \t1 public boolean isReadable ( Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 boolean b = InterceptorBook . class . equals ( type ) ; \n \n <ect>
\t3 public void run ( ) { \n \n \t4 try { \n \n \t5 tick ( ) ; \n \n \t4 } catch ( RuntimeException e ) { \n \n <ect>
\t6 try { \n \n \t7 <comment> \n \n \t7 persistenceAdapter . stop ( ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t2 public void run ( ) { \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 synchronized ( LOCK ) { \n \n \t4 flushFileOutput ( ) ; \t5 } \n \n <ect>
\t2 if ( log != null ) log . info ( <string_literal> , msg ) ; } \n \n \t1 public static void error ( Log log , String msg ) { \n \n \t2 if ( log != null ) log . error ( <string_literal> , msg ) ; } \n \n \t1 public static void error ( Log log , Throwable t ) { \n \n <ect>
\t3 Thread . currentThread ( ) . setContextClassLoader ( getClass ( ) . getClassLoader ( ) ) ; \n \n \t3 CloudBlobDirectory metaDir = getAzureContainer ( ) . getDirectoryReference ( META_DIR_NAME ) ; \n \n \t3 CloudBlockBlob blob = metaDir . getBlockBlobReference ( name ) ; \n \n \t3 if ( ! blob . exists ( ) ) { \n \n <ect>
\t1 public void onResume ( Route route ) { \n \n \t2 LOG . debug ( <string_literal> + route . getId ( ) ) ; \n \n \t2 <comment> \n \n \t1 public void onExchangeBegin ( Route route , Exchange exchange ) { \n \n <ect>
\t1 if ( ! areHostGroupsResolved ( requiredHostGroups ) ) { \n \n \t1 String msg = <string_literal> ; \n \n \t1 LOG . info ( msg ) ; \n \n \t1 throw new AsyncCallableService . RetryTaskSilently ( msg ) ; } \n \n <ect>
\t3 Stmt s = ( Stmt ) extCall . getO2 ( ) ; \n \n \t3 if ( s . getInvokeExpr ( ) . getMethodRef ( ) . resolve ( ) == method ) \n \n \t3 { \n \n \t4 if ( dfa . printDebug ( ) && method . getDeclaringClass ( ) . isApplicationClass ( ) ) \n \n <ect>
\t1 public abstract void handle ( ObjectEntity retrieved ) ; \n \n \t1 public void interrupt ( ) { \n \n \t1 this . interrupted = true ; } } \n \n public void processExpirationByDate ( String ruleId , Bucket bucket , String prefix , Date expirationDate ) { \n \n <ect>
\t3 Settings . builder ( ) \n \n \t4 . put ( <string_literal> , randomRepoPath ( ) ) \n \n \t4 . put ( <string_literal> , randomAlphaOfLength ( <number_literal> ) ) \n \n \t4 . put ( <string_literal> , <number_literal> ) ) . get ( ) ) ; \n \n <ect>
\t2 if ( ! x . isLiteral ( ) ) { \n \n \t3 log . warn ( <string_literal> + list ) ; \n \n \t3 return null ; } \n \n \t2 if ( ! SpatialValueUtil . isDecimal ( x ) ) { \n \n <ect>
\t3 throw new CloudRuntimeException ( <string_literal> + routerId ) ; } } \n \n \t1 @ Override \n \n \t1 public boolean savePasswordToRouter ( Network network , NicProfile nic , VirtualMachineProfile < UserVm > profile , List < ? extends VirtualRouter > routers ) throws ResourceUnavailableException { \n \n \t2 if ( routers == null || routers . isEmpty ( ) ) { \n \n <ect>
\t1 is done as a workaround for https : <comment> \n \n \t1 <string_literal> <string_literal> <ect>
\t1 private static Pattern nonTapePattern = Pattern . compile ( NON_TAPE_REGEX ) ; \n \n \t1 private static final Log LOG = LogFactory . getLog ( MainframeFTPFileEntryParser . class . getName ( ) ) ; \n \n \t1 public MainframeFTPFileEntryParser ( ) { \n \n \t2 super ( REGEX ) ; \n \n <ect>
\t5 session = jcrRepository ( repositoryId ) . login ( new ServletCredentials ( request ) , workspace ( repositoryId ) ) ; \n \n \t5 sessions . put ( repositoryId , session ) ; \n \n \t5 return session ; \n \n \t4 } catch ( CmisPermissionDeniedException e ) { \n \n <ect>
\t2 { \n \n \t2 <comment> \n \n \t2 quarantineMap . remove ( client ) ; \n \n \t2 quarantineHistory . put ( client , quarantine ) ; \n \n <ect>
\t4 delayedUpdateCall ( action ) ; \n \n \t3 } else { \n \n \t4 doUpdateCall ( action ) ; } \n \n \t2 } else { \n \n <ect>
\t2 if ( tp . getUseIpAddresses ( ) ) \n \n \t3 throw new IllegalArgumentException ( String . format ( <string_literal> , \n \n <number_literal> RELAY2 . class . getSimpleName ( ) , tp . getClass ( ) . getSimpleName ( ) ) ) ; \n \n \t2 if ( max_site_masters < 1 ) { \n \n <ect>
\t5 . append ( oldUpdated ) \n \n \t5 . append ( <string_literal> ) \n \n \t5 . append ( oldUpdatedTime ) ; \n \n \t3 } else { \n \n <ect>
\t4 try { \n \n \t5 BufferedImage tileImage = imageFutures . get ( pos ) . get ( ) ; \n \n \t5 g . drawImage ( tileImage , x * TILE_SIZE_X , z * TILE_SIZE_Y , null ) ; \n \n \t4 } catch ( ExecutionException e ) { \n \n <ect>
\t2 return context . getRedirectInSameState ( ) ; } \n \n \t1 private void render ( RequestControlContext context , View view ) throws ViewRenderingException { \n \n \t3 logger . debug ( <string_literal> + view ) ; \n \n <ect>
\t4 log . trace ( <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t1 public synchronized void persistToStore ( ) { \n \n \t2 if ( ! config . persistent || lastVal == null ) { \n \n \t3 return ; } \n \n <ect>
\t3 s_logger . warn ( <string_literal> + host . getResource ( ) , e ) ; \n \n \t2 } catch ( SecurityException e ) { \n \n \t3 s_logger . warn ( <string_literal> + host . getResource ( ) , e ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t2 String restHostUrlStr = null ; \n \n \t2 try { \n \n \t3 restHostUrlStr = readRestUrl ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 return ; } \n \n \t1 private void processBindingConfiguration ( ) { \n \n \t2 if ( m_config . containsKey ( <string_literal> ) ) { \n \n \t3 m_refreshInterval = Integer . parseInt ( m_config . get ( <string_literal> ) ) ; \n \n <ect>
\t5 urlBuf . append ( ' = ' ) ; \n \n \t5 try { \n \n \t6 urlBuf . append ( URLEncoder . encode ( value . toString ( ) , <string_literal> ) ) ; \n \n \t5 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t5 _nicDao . expunge ( loadBalancingIpNic . getId ( ) ) ; \n \n \t5 s_logger . debug ( <string_literal> ) ; \n \n \t5 nic . setState ( MappingState . Remove ) ; } \n \n \t3 } else { \n \n <ect>
\t3 String name = KubernetesHelper . getName ( entity ) ; \n \n \t3 if ( Strings . isNotBlank ( kind ) ) { \n \n \t4 name = kind . toLowerCase ( ) + <string_literal> + name ; } \n \n \t3 if ( Strings . isNullOrBlank ( name ) ) { \n \n <ect>
\t6 try { \n \n \t7 Map < ByteArray , List < Versioned < byte [ ] > > > versionedResponses = this . storeClient . getAllWithCustomTimeout ( this . requestObject ) ; \n \n \t7 if ( versionedResponses == null \n \n \t7 || versionedResponses . values ( ) . size ( ) == 0 ) { \n \n <ect>
\t4 } catch ( ConfigurationException e ) { \n \n \t5 s_logger . error ( <string_literal> + info . name , e ) ; \n \n \t5 System . exit ( 1 ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 if ( this . writerHintMap . containsKey ( hintType ) ) { \n \n \t3 this . writerHintMap . remove ( hintType ) ; \n \n \t3 LOG . info ( String . format ( <string_literal> , hintType . toString ( ) ) ) ; \n \n \t2 } else { \n \n <ect>
\t3 : keyValueSeparatorPosition ) ; \n \n \t2 valueLength [ mapSize ] = elementByteEnd - ( keyEnd [ mapSize ] + 1 ) ; \n \n \t2 LazyPrimitive < ? , ? > lazyKey = uncheckedGetKey ( mapSize ) ; \n \n \t2 if ( lazyKey == null ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 log . warning ( <string_literal> ) ; \n \n \t2 log . warning ( <string_literal> , new Exception ( <string_literal> ) ) ; \n \n \t2 log . error ( <string_literal> ) ; \n \n <ect>
\t1 public boolean apply ( VmInfo arg0 ) { \n \n \t1 if ( arg0 . getGroupNames ( ) . isEmpty ( ) ) { \n \n \t2 LOG . warn ( <string_literal> + arg0 . getInstanceId ( ) + <string_literal> + arg0 . getGroupNames ( ) ) ; } \n \n \t1 if ( arg0 . getInstanceType ( ) . getName ( ) == null ) { \n \n <ect>
\t1 LOG . warn ( <string_literal> , \n \n \t2 attempts , RETRY_ATTEMPTS_LIMIT , OPERATIONS_RETRY_ATTEMPTS . getDefaultValue ( ) ) ; \n \n \t1 attempts = OPERATIONS_RETRY_ATTEMPTS . getDefaultValue ( ) ; \n \n \t1 } else if ( attempts > RETRY_ATTEMPTS_LIMIT ) { \n \n <ect>
\t4 { \n \n \t5 logger . error ( <string_literal> , e ) ; } \n \n \t4 catch ( DnssecException e ) \n \n \t4 { \n \n <ect>
\t2 <comment> \n \n \t2 OutboundSession sess = getSession ( target ) ; \n \n \t2 if ( sess == null ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 model . addAttribute ( <string_literal> , defaultLang ) ; \n \n \t2 try { \n \n \t3 getCurrentUser ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 this . exceptionSorter = NullExceptionSorter . getInstance ( ) ; \n \n \t3 return ; } \n \n \t2 Class < ? > clazz = Utils . loadClass ( exceptionSorter ) ; \n \n \t2 if ( clazz == null ) { \n \n <ect>
\t2 ServiceHelper . startServices ( nettyServerBootstrapFactory ) ; \n \n \t2 LOG . info ( <string_literal> + configuration . getAddress ( ) ) ; } \n \n \t1 @ Override \n \n \t1 protected void doStop ( ) throws Exception { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( InvalidMetadataException e ) { \n \n \t3 try { \n \n \t4 this . storeClientThunk . call ( ) ; \n \n \t3 } catch ( Exception e2 ) { \n \n <ect>
\t4 if ( ! key . endsWith ( <string_literal> ) ) { \n \n \t5 _log . error ( <string_literal> + url + hostname ) ; \n \n \t5 return null ; } \n \n \t4 if ( key . replaceAll ( <string_literal> , <string_literal> ) . length ( ) != 0 ) { \n \n <ect>
\t4 . setRenamePattern ( <string_literal> ) . setRenameReplacement ( <string_literal> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; \n \n \t2 assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( 0 ) ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 100L ) ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 100L ) ) ; \n \n <ect>
\t1 @ AfterMethod ( alwaysRun = true ) \n \n \t1 public void tearDown ( ) throws Exception { \n \n \t2 long time = watch . stop ( ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t3 } else { \n \n \t4 enabled = true ; \n \n \t4 LOG . info ( <string_literal> ) ; } \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t4 <comment> \n \n \t4 setupFeatures ( builderFactory ) ; \n \n \t4 builder = builderFactory . newDocumentBuilder ( ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t2 producer . send ( outbound [ 0 ] ) ; \n \n \t2 producer . send ( outbound [ 1 ] ) ; \n \n \t2 commitTx ( ) ; \n \n \t2 LOG . info ( <string_literal> + outbound [ 0 ] ) ; \n \n <ect>
\t3 @ Override \n \n \t3 public void onNewState ( CrawlerContext context , StateVertex newState ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t3 super ( arg ) ; } \n \n \t2 <comment> \n \n \t2 @ Override public Serializable execute ( ) { \n \n <ect>
\t1 String request = new Json ( ) . serialize ( hostMetrics ) ; <comment> \n \n \t1 String response = sender . pushMetrics ( request ) ; \n \n \t1 return response ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 Connection connection = createConnection ( ) ; \n \n \t2 final AtomicBoolean gotException = new AtomicBoolean ( ) ; \n \n \t2 connection . setExceptionListener ( new ExceptionListener ( ) { \n \n \t3 public void onException ( JMSException exception ) { \n \n <ect>
\t6 String b_alg = bitstream . getChecksumAlgorithm ( ) ; \n \n \t6 String b_md = bitstream . getChecksum ( ) ; \n \n \t6 if ( StringUtils . equals ( alg , b_alg ) ) { \n \n \t7 if ( StringUtils . equals ( md , b_md ) ) { \n \n <ect>
\t3 RemoteHostId oldID = oldPeer . getRemoteHostId ( ) ; \n \n \t3 if ( ! remoteId . equals ( oldID ) ) { \n \n \t4 <comment> \n \n \t4 if ( _log . shouldInfo ( ) ) \n \n <ect>
\t2 if ( root . hasProperty ( ResultSetGraphVocab . size ) ) { \n \n \t3 try { \n \n \t4 int size = root . getRequiredProperty ( ResultSetGraphVocab . size ) . getInt ( ) ; \n \n \t4 if ( size != count ) \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 . filter ( b - > b . supports ( context ) ) \n \n \t3 . findFirst ( ) \n \n \t3 . orElse ( null ) ; \n \n \t2 if ( validator == null ) { \n \n <ect>
\t3 return false ; } \n \n \t2 s_logger . debug ( <string_literal> + vmName ) ; \n \n \t2 <comment> \n \n \t2 if ( ! createVmdataFiles ( vmName , vmDataList , configDriveLabel ) ) { \n \n <ect>
\t4 String script = FileUtils . readFileToString ( new File ( scriptFile ) , Charset . defaultCharset ( ) ) ; \n \n \t4 return bsfEngine . eval ( scriptFile , 0 , 0 , script ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 DCDate date = new DCDate ( new Date ( ) ) ; \n \n \t3 itemService . addMetadata ( context , item , info . schema , \n \n \t9 info . element , info . qualifier , null , date . toString ( ) ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t1 private String getBackupByTime ( long time , String type ) { \n \n \t2 ScheduledBackupType backupType = ScheduledBackupType . getBackupTypes ( ) . get ( type ) ; \n \n \t2 String [ ] backups = findLocalBackups ( true ) ; \n \n \t2 if ( backups == null || backups . length == 0 ) { \n \n <ect>
\t4 } else { \n \n \t5 ErlLogger . debug ( msg ) ; } \n \n \t4 return result ; } \n \n \t2 } catch ( final RpcException e ) { \n \n <ect>
\t2 LOGGER . trace ( <string_literal> + requestFileLoc ) ; \n \n \t2 final InputStream requestStream = JBossPDPInteroperabilityTestCase . class \n \n \t4 . getResourceAsStream ( XACMLTestUtils . TESTOBJECTS_REQUESTS + <string_literal> + requestFileLoc ) ; \n \n \t2 if ( requestStream == null ) { \n \n <ect>
\t2 } catch ( UnauthorizedActionException ex ) { \n \n \t3 throw ex ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 throwEx = true ; \n \n <ect>
\t3 <comment> \n \n \t2 if ( canBeDeleted ) { \n \n \t3 arg0 . getRbd ( ) . close ( image ) ; \n \n \t3 image = null ; \n \n <ect>
\t7 sublistItem . addAttribute ( <string_literal> , getPluginL10nCSSIdentifier ( l10n , navigationTitle ) ) ; \n \n \t7 if ( navigationTitle != null ) { \n \n \t8 String newNavigationTitle = l10n . getString ( navigationTitle ) ; \n \n \t8 if ( newNavigationTitle == null ) { \n \n <ect>
\t6 snapshotInfo . processEvent ( Event . OperationSuccessed ) ; } \n \n \t5 else { \n \n \t6 snapshotInfo . processEvent ( Event . OperationFailed ) ; } } \n \n \t4 catch ( Exception ex ) { \n \n <ect>
\t2 if ( cubeInstance == null ) { \n \n \t3 logger . error ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( cubeInstance . getSegments ( ) . isEmpty ( ) ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> + vmUuid ) ; } \n \n \t3 throw new CloudRuntimeException ( <string_literal> + vmUuid ) ; } \n \n \t2 migrate ( vm , srcHostId , dest ) ; } \n \n \t1 protected void migrate ( final VMInstanceVO vm , final long srcHostId , final DeployDestination dest ) throws ResourceUnavailableException , ConcurrentOperationException { \n \n <ect>
\t1 while ( ( document = documentReader . read ( ) ) != null ) { \n \n \t2 if ( writer != null && writtenCount >= writeBlockSize ) { \n \n \t2 stepExecution = jobContextRepository . getStepExecution ( stepExecution . getJobExecutionId ( ) , stepExecution . getId ( ) ) ; \n \n \t2 if ( stepExecution . getJobExecution ( ) . getStatus ( ) == BatchStatus . STOPPING ) { \n \n <ect>
\t1 @ ReflectionUse \n \n \t1 private Pair < JobInfo . Status , String > orchestrateRemoveVmFromNetwork ( final VmWorkRemoveVmFromNetwork work ) throws Exception { \n \n \t2 final VMInstanceVO vm = _entityMgr . findById ( VMInstanceVO . class , work . getVmId ( ) ) ; \n \n \t2 if ( vm == null ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testUpdateStoresXmlWithIncompatibleAvroSchema ( ) { \n \n \t2 try { \n \n <ect>
\t3 sLogger . debug ( <string_literal> , autoRefreshTimeInSecs ) ; \n \n \t3 mScheduleMap . put ( autoRefreshTimeInSecs , new LinkedList < Datapoint > ( ) ) ; \n \n \t3 if ( mIsRunning ) { \n \n \t4 <comment> \n \n <ect>
\t3 image = new byte [ in . available ( ) ] ; \n \n \t3 in . read ( image ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t2 LOG . debug ( <string_literal> ) ; \n \n \t2 camelContext . setComponentResolver ( new OsgiComponentResolver ( bundleContext ) ) ; \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 camelContext . setLanguageResolver ( new OsgiLanguageResolver ( bundleContext ) ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> , tempFile , SshScpFile . this ) ; \n \n \t3 return asBuffered ( new FileOutputStream ( tempFile ) { \n \n \t4 @ Override \n \n \t4 public void close ( ) throws IOException { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 throw new UnsupportedOperationException ( <string_literal> ) ; <comment> \n \n \t1 @ Override \n \n \t1 public WatchService newWatchService ( ) throws IOException { \n \n <ect>
\t4 doSubscribe ( consumerInfo , topicName , qoS ) ; \n \n \t4 <comment> \n \n \t4 restoredQueues . add ( queue ) ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 return CommandType . notUndoable ; } \n \n \t1 @ Override \n \n \t1 public UpdateContainer doIt ( Workspace workspace ) throws CommandException { \n \n \t2 <comment> <ect>
\t6 convertHistoryRecordToMessageEvent ( recs . next ( ) , \n \n \t7 item ) ) ; } } \n \n \t3 catch ( IOException e ) \n \n \t3 { \n \n <ect>
\t3 return connector ; } \n \n \t2 return null ; } \n \n \t1 public void masterFailed ( ) { \n \n \t2 if ( shutdownOnMasterFailure ) { \n \n <ect>
\t4 m = null ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 logger . error ( <string_literal> , nm ( ) , e ) ; \n \n \t3 } catch ( FieldException e ) { \n \n <ect>
\t2 < label > Message : \n \n \t2 < input type = <string_literal> ng - model = <string_literal> / > < / label > \n \n \t2 < button ng - click = <string_literal> > log < / button > \n \n \t2 < button ng - click = <string_literal> > warn < / button > \n \n <ect>
\t7 } catch ( Exception e ) { \n \n \t8 s_logger . warn ( <string_literal> , e ) ; \n \n \t8 try { \n \n \t9 int stopResponseCode = executeStop ( server , developerServer , username ) ; \n \n <ect>
\t2 testStartAlreadyFired = false ; \n \n \t2 retryAwareRunNotifier . fireTestIgnored ( description ) ; } \n \n \t1 @ Override \n \n \t1 public void fireTestAssumptionFailed ( Failure failure ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t4 LOGGER . error ( <string_literal> , e ) ; } \n \n \t3 try { \n \n \t4 removeOverlay ( DEPLOYMENT_SHELL_ARCHIVE , OVERLAY , overlay . keySet ( ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 protected boolean invokeDeleteLifecycle ( EventSource session , Object entity , EntityPersister persister ) { \n \n \t2 if ( persister . implementsLifecycle ( ) ) { \n \n \t3 LOG . debug ( <string_literal> ) ; \n \n \t3 if ( ( ( Lifecycle ) entity ) . onDelete ( session ) ) { \n \n <ect>
\t2 Closeables . close ( avroParquetWriter , false ) ; \n \n \t1 } catch ( IOException e ) { \n \n \t2 throw new DatasetWriterException ( \n \n \t2 <string_literal> + avroParquetWriter + <string_literal> + pathTmp ) ; } \n \n <ect>
\t1 public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { \n \n \t2 logHttpHeaders ( responseContext . getStringHeaders ( ) ) ; } \n \n \t1 public Object aroundReadFrom ( ReaderInterceptorContext context ) throws IOException , WebApplicationException { \n \n \t2 byte [ ] buffer = IOUtils . toByteArray ( context . getInputStream ( ) ) ; \n \n <ect>
\t1 } else { \n \n \t2 log . info ( <string_literal> , \n \n \t3 accumuloSite ) ; } } \n \n \t1 URL url = new URL ( scheme + monitorLocation ) ; \n \n <ect>
\t5 if ( matcher . find ( ) ) { \n \n \t6 return matcher . group ( <number_literal> ) ; } \n \n \t5 line = output . readLine ( ) ; } \n \n \t3 } catch ( final IOException e ) { \n \n <ect>
\t4 if ( sheetRef . equals ( expectedSheetRef ) ) { \n \n \t5 documentReferences . add ( docRef ) ; } } \n \n \t3 return documentReferences ; \n \n \t2 } catch ( QueryException e ) { \n \n <ect>
\t2 < input type = <string_literal> ng - model = <string_literal> / > < / label > \n \n \t2 < button ng - click = <string_literal> > log < / button > \n \n \t2 < button ng - click = <string_literal> > warn < / button > \n \n \t2 < button ng - click = <string_literal> > info < / button > \n \n <ect>
\t2 Assert . assertEquals ( SignedInfo . valueToType ( SignedInfo . GONE_VAL ) , SignedInfo . ContentType . GONE ) ; \n \n \t2 byte [ ] key = new byte [ <number_literal> ] ; \n \n \t2 System . arraycopy ( SignedInfo . KEY_VAL , 0 , key , 0 , key . length ) ; \n \n \t2 Assert . assertEquals ( SignedInfo . valueToType ( key ) , SignedInfo . ContentType . KEY ) ; \n \n <ect>
\t4 try { \n \n \t5 this . format . close ( ) ; } \n \n \t4 catch ( Throwable t ) { \n \n <ect>
\t3 initDB ( ) ; } } \n \n \t1 @ Override \n \n \t1 public void putAll ( Map < String , VersionedEntry < String , byte [ ] > > values ) { \n \n \t2 initIfNeeded ( ) ; \n \n <ect>
\t2 String [ ] part = zkMaster . split ( <string_literal> ) ; \n \n \t2 return NetWorkUtils . equals ( part [ 0 ] , NetWorkUtils . ip ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public void run ( ) { \n \n <ect>
\t3 setSpeed ( ( short ) 0 , null , null , null ) ; \n \n \t2 } else if ( state == OnOffValue . ON ) { \n \n \t3 setSpeed ( Tools . getShortOpt ( ConfigOptsSwitchSpeed . SPEED . toString ( ) , opts ) , null , null , null ) ; \n \n \t2 } else { \n \n <ect>
\t3 boolean eof = false ; \n \n \t3 s_logger . info ( <string_literal> ) ; \n \n \t3 while ( ! eof ) { \n \n \t4 String line = consoleInput . readLine ( ) ; \n \n <ect>
\t3 def p = pb . start ( ) \n \n \t3 <comment> \n \n \t3 log . debug ( <string_literal> ) \n \n \t3 p . waitFor ( ) \n \n <ect>
\t2 MappingMetaData mappingMetaData = getMappingsResponse . mappings ( ) . get ( <string_literal> ) . get ( <string_literal> ) ; \n \n \t2 assertThat ( mappingMetaData , not ( nullValue ( ) ) ) ; \n \n \t2 Map < String , Object > mappingSource = mappingMetaData . sourceAsMap ( ) ; \n \n \t2 Map aField = ( ( Map ) XContentMapValues . extractValue ( <string_literal> , mappingSource ) ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 try { \n \n \t3 Thread . sleep ( delayBeforeStartingBroker ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 e . printStackTrace ( ) ; } \n \n <ect>
\t1 throw new HiveException ( e ) ; } } \n \n protected void flushToFile ( ) throws IOException , HiveException { \n \n \t1 <comment> \n \n \t1 Path tmpURI = getExecContext ( ) . getLocalWork ( ) . getTmpPath ( ) ; \n \n <ect>
\t4 conflict = true ; \n \n \t4 _agents . put ( hostId , removed ) ; \n \n \t4 removed = attache ; } } \n \n \t2 if ( conflict ) { \n \n <ect>
\t4 queuedOutgoingEvents . add ( NetData . EventMessage . newBuilder ( ) \n \n \t6 . setEvent ( eventSerializer . serialize ( event ) ) \n \n \t6 . setTargetId ( netComp . getNetworkId ( ) ) . build ( ) ) ; \n \n \t3 } catch ( SerializationException e ) { \n \n <ect>
<comment> \n \n \t1 protected void showTournament ( UUID tournamentId ) { \n \n \t2 try { \n \n \t3 frame . showTournament ( tournamentId ) ; \n \n <ect>
\t3 Logger . error ( this , <string_literal> + this + <string_literal> + next , e ) ; \n \n \t3 ackOpennet ( next ) ; \n \n \t3 return false ; \n \n \t2 } catch ( PeerParseException e ) { \n \n <ect>
\t6 java . util . AbstractMap . SimpleEntry < Object , ChannelListener < Object > > en = localListeners . get ( i ) ; \n \n \t6 try { \n \n \t7 en . getValue ( ) . onConnect ( status , en . getKey ( ) ) ; \n \n \t6 } catch ( Throwable e ) { \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 public boolean blvlck ( boolean fix , int width , SkipLevels < K , V > [ ] prevLevels ) { \n \n \t2 bf . log . warn ( <string_literal> + width ) ; \n \n \t2 bf . log . warn ( <string_literal> + this . levels . length ) ; \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t2 boolean pass = p < = ALPHA ; \n \n \t2 if ( pass ) { \n \n \t3 LOG . info ( <string_literal> + ALPHA , name , p ) ; \n \n \t2 } else { \n \n <ect>
\t2 Collections . sort ( items , Collections . reverseOrder ( ) ) ; } \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t1 protected RealmResource migrationRealm2 ; \n \n \t1 protected RealmResource migrationRealm3 ; \n \n \t1 protected RealmResource masterRealm ; \n \n \t1 protected void testMigratedData ( ) { \n \n <ect>
\t4 AsyncAnnotatedMBean . registerMBean ( asyncInvokeService , mbeanTimeout , managementContext , view , objectName ) ; \n \n \t4 registeredMBeans . add ( objectName ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 LOG . warn ( <string_literal> , transaction ) ; \n \n <ect>
\t1 throws DescriptorException , IOException { \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 String descriptor = DescriptorUtils . generateDescriptor ( description ) ; \n \n \t1 Path fPath = validateOutput ( filePath ) ; \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t4 logger . warn ( <string_literal> ) ; \n \n \t4 logger . warn ( e . getMessage ( ) ) ; } \n \n \t2 } else { \n \n <ect>
\t4 if ( segment . isUnused ( ) ) \n \n \t5 recycleSegment ( segment ) ; \n \n \t3 CommitLogSegment first ; \n \n \t3 if ( ( first = activeSegments . peek ( ) ) != null && first . id < = last . id ) \n \n <ect>
\t2 OrcCodecPool . returnCodec ( kind , codec ) ; \n \n \t2 } else { \n \n \t2 codec . close ( ) ; } \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t3 logger . info ( <string_literal> + sparkHome ) ; \n \n \t3 return sparkHome ; } \n \n \t2 sparkHome = System . getProperty ( <string_literal> ) ; \n \n \t2 if ( StringUtils . isNotEmpty ( sparkHome ) ) { \n \n <ect>
\t3 for ( GridRestProtocol proto : protos ) \n \n \t4 proto . onKernalStart ( ) ; \n \n \t3 startLatch . countDown ( ) ; \n \n <ect>
\t2 LOG . warn ( <string_literal> , e ) ; \n \n \t2 Thread . currentThread ( ) . interrupt ( ) ; } \n \n \t2 finally \n \n \t2 { \n \n <ect>
\t2 String format = restRequest . getFormat ( ) ; \n \n \t2 for ( Object s : request . getParameterMap ( ) . keySet ( ) ) \n \n \t3 logger . debug ( s + <string_literal> + request . getParameterMap ( ) . get ( s ) . toString ( ) ) ; \n \n \t2 logger . debug ( <string_literal> + serviceId ) ; \n \n <ect>
\t2 { \n \n \t2 ServerStart . initContextParameters ( this . getServletContext ( ) , contextParameters ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t4 exclusive , \n \n \t4 error , \n \n \t4 usePermanentRedirects ) ; \n \n \t2 } catch ( CmsConfigurationException e ) { \n \n <ect>
\t7 extension , e1 ) ; } } \n \n \t4 this . alwaysUsedExtensions . put ( currentWiki , extensions ) ; \n \n \t4 return extensions ; \n \n \t3 } catch ( XWikiException e ) { \n \n <ect>
\t1 private void updateOffset ( List < Update > updates ) { \n \n \t2 OptionalLong ol = updates . stream ( ) . mapToLong ( Update : : getUpdateId ) . max ( ) ; \n \n \t2 if ( ol . isPresent ( ) ) { \n \n \t3 this . offset = ol . getAsLong ( ) + 1 ; \n \n <ect>
\t1 expiringGroupRunnable = new ExpiringGroupMonitoringRunnable ( ) ; \n \n \t1 scheduler . scheduleWithFixedDelay ( expiringGroupRunnable , 0 , DELAY_TIME , MILLISECONDS ) ; } } \n \n @ Override \n \n public void stop ( ) throws MuleException { \n \n <ect>
\t2 if ( itr != null ) { \n \n \t3 try { \n \n \t4 itr . close ( ) ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t1 if ( satisfyPrecondition ( parentStats ) ) { \n \n \t2 <comment> \n \n \t2 hashAgg = checkMapSideAggregation ( gop , colStats , conf ) ; \n \n <ect>
\t5 <comment> \n \n \t4 ftpFiles = new FTPFile [ listing . size ( ) ] ; \n \n \t4 for ( int i = 0 ; i < listing . size ( ) ; i ++ ) { \n \n \t5 ftpFiles [ i ] = listing . get ( i ) ; } \n \n <ect>
\t2 ViewRegistry viewRegistryMock = EasyMock . createNiceMock ( ViewRegistry . class ) ; \n \n \t2 bind ( ViewRegistry . class ) . toInstance ( viewRegistryMock ) ; } \n \n \t1 } ) ; \n \n \t1 SchemaUpgradeHelper schemaUpgradeHelper = injector . getInstance ( SchemaUpgradeHelper . class ) ; \n \n <ect>
\t2 } catch ( Exception ex ) { \n \n \t3 if ( getPoolProperties ( ) . getLogValidationErrors ( ) ) { \n \n \t4 log . warn ( <string_literal> , ex ) ; \n \n <ect>
\t6 @ Override \n \n \t6 public void onExchangeComplete ( final HttpConnection connection , final boolean keepAlive ) { \n \n \t8 if ( keepAlive ) { \n \n <ect>
\t2 eucaS3Client . deleteObject ( arg0 ) ; \n \n \t2 return null ; } \n \n \t1 } , new DeleteObjectRequest ( bucketName , keyName ) , REFRESH_TOKEN_RETRIES ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 public Set < Class < ? > > findAnnotated ( Class < ? extends Annotation > annotation , String . . . packageNames ) { \n \n \t2 if ( packageNames == null ) { \n \n \t3 return Collections . emptySet ( ) ; } \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( debugEnabled ( ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 api . sendCommand ( this . getClient ( ) , null ) ; \n \n \t4 <comment> \n \n \t4 if ( ( api . getResponseType ( ) == ResponseType . ERROR ) && ( api . getResponseCode ( ) == <number_literal> ) && ( api . getTestCaseInfo ( ) != null ) ) { \n \n <ect>
\t4 resourceListPanel = createResourceListPanel ( \n \n \t5 CmsVaadinUtils . getMessageText ( Messages . GUI_COPYTOPROJECT_PART_1 , projectName ) , \n \n \t5 resources ) ; } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t4 LOGGER . trace ( <string_literal> ) ; \n \n \t4 executeUpdate ( conn , <string_literal> ) ; \n \n \t3 } catch ( SQLException se ) { \n \n \t4 if ( se . getErrorCode ( ) != <number_literal> ) { <comment> \n \n <ect>
\t2 RoutingTable initialRoutingTable = RoutingTable . builder ( ) \n \n \t4 . addAsNew ( metaData . index ( <string_literal> ) ) \n \n \t4 . build ( ) ; \n \n \t2 ClusterState clusterState = ClusterState . builder ( CLUSTER_NAME_SETTING . getDefault ( Settings . EMPTY ) ) . metaData ( metaData ) . routingTable ( initialRoutingTable ) . build ( ) ; \n \n <ect>
\t3 affectedVms . addAll ( _securityGroupVMMapDao . listVmIdsBySecurityGroup ( securityGroup . getId ( ) ) ) ; \n \n \t3 scheduleRulesetUpdateToHosts ( affectedVms , true , null ) ; \n \n \t3 return newRules ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 boolean result = future . get ( ) ; \n \n \t3 Assert . assertEquals ( false , result ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t5 listener . onResponse ( task . taskInfoGivenSubtaskInfo ( localNodeId , r . getTasks ( ) ) ) ; \n \n \t4 } , \n \n \t4 listener : : onFailure ) ) ; \n \n \t2 } else { \n \n <ect>
\t1 log . info ( <string_literal> , System . getProperty ( <string_literal> , krbServicePrincipalName ) ) ; \n \n \t1 log . info ( <string_literal> , System . getProperty ( <string_literal> ) ) ; \n \n \t1 log . info ( <string_literal> , System . getProperty ( <string_literal> ) ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n <ect>
\t3 @ Override \n \n \t3 public void onSuccess ( Void result ) { \n \n \t4 HostConnectionPool previous = pools . put ( host , newPool ) ; \n \n \t4 if ( previous == null ) { \n \n <ect>
\t3 vApp = client . getVAppClient ( ) . getVApp ( vApp . getHref ( ) ) ; \n \n \t3 logger . debug ( <string_literal> , vApp . getStatus ( ) , vApp . getName ( ) ) ; \n \n \t2 } catch ( IllegalStateException e ) { \n \n \t3 logger . warn ( e , <string_literal> , vApp . getStatus ( ) , vApp . getName ( ) ) ; } \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 search . flushToIndexes ( ) ; \n \n \t4 search . clear ( ) ; } } \n \n <ect>
\t6 return null ; } \n \n \t5 UUID userId = session . get ( ) . getUserId ( ) ; \n \n \t5 Optional < User > _user = UserManager . instance . getUser ( userId ) ; \n \n \t5 if ( ! _user . isPresent ( ) ) { \n \n <ect>
\t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 private void prepareEntityFlushes ( EventSource session , PersistenceContext persistenceContext ) throws HibernateException { \n \n <ect>
\t5 Throwable c = evt . getSourceException ( ) . getCause ( ) ; \n \n \t5 while ( c != null ) { \n \n \t6 logger . error ( <string_literal> , c . getClass ( ) , c . getMessage ( ) != null ? c . getMessage ( ) : <string_literal> ) ; \n \n \t6 c = c . getCause ( ) ; } \n \n <ect>
\t2 outbound [ 0 ] . acknowledge ( ) ; \n \n \t2 <comment> \n \n \t2 beginTx ( ) ; \n \n \t2 ArrayList < Message > messages = new ArrayList < Message > ( ) ; \n \n <ect>
\t2 return ticket ; } \n \n \t1 @ Override \n \n \t1 public void addTicket ( final Ticket ticket ) { \n \n \t2 try { \n \n <ect>
\t1 try { \n \n \t1 return fileSystem . getClass ( ) . getMethod ( <string_literal> , \n \n \t2 Path . class ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 String [ ] lines = rdf . split ( <string_literal> ) ; \n \n \t3 int count = lines . length ; \n \n \t3 assertEquals ( <number_literal> , count ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 s_logger . debug ( <string_literal> + vm . getUuid ( ) , e ) ; \n \n \t5 CloudRuntimeException ex = new CloudRuntimeException ( <string_literal> + e . getMessage ( ) ) ; \n \n \t5 ex . addProxyObject ( vm . getUuid ( ) , <string_literal> ) ; \n \n \t5 throw ex ; } } } \n \n <ect>
\t2 <comment> \n \n \t2 DateFormat dateFormat = new SimpleDateFormat ( <string_literal> ) ; \n \n \t2 Date currentDate = new Date ( ) ; \n \n \t2 String endDate = dateFormat . format ( currentDate ) ; \n \n <ect>
\t4 return ; } \n \n \t3 GridTaskWorker < ? , ? > task = tasks . get ( sesId ) ; \n \n \t3 if ( task == null ) { \n \n <ect>
\t3 log . info ( <string_literal> + rsrc3 ) ; \n \n \t3 log . info ( <string_literal> + rsrc4 ) ; \n \n \t3 log . info ( <string_literal> + log ) ; \n \n \t3 log . info ( <string_literal> + grid ) ; \n \n <ect>
\t2 try { \n \n \t3 bFilter = Configs . decodeObject ( BundleFilter . class , filter ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 errorBuilder . append ( <string_literal> + ex + <string_literal> ) ; \n \n <ect>
\t1 while ( server == null ) { \n \n \t1 try { \n \n \t2 server = new TestingServer ( ) ; \n \n \t1 } catch ( BindException e ) { \n \n <ect>
\t3 if ( code == ErrorMapping . OffsetOutOfRangeCode ( ) && config . resetOffsetIfOutOfRange ) { \n \n \t4 long startOffset = getOffset ( topic , partition , config . startOffsetTime ) ; \n \n \t4 offset = startOffset ; } \n \n \t3 if ( leaderBroker != null ) { \n \n <ect>
\t1 try { \n \n \t1 this . conn = manager . getConnection ( ) ; \n \n \t1 this . conn . setAutoCommit ( false ) ; \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t2 throw new IllegalStateException ( ) ; } \n \n \t2 lastUserID = userID ; \n \n \t2 out . write ( result . getResultBytes ( ) ) ; } } \n \n \t1 end = System . currentTimeMillis ( ) ; \n \n <ect>
\t4 if ( idsIter instanceof Closeable ) { \n \n \t5 try { \n \n \t6 Closeables . close ( ( Closeable ) idsIter , false ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t3 final GenericObjectPool connectionPoolUsage = new GenericObjectPool ( null , <number_literal> ) ; \n \n \t3 final ConnectionFactory connectionFactoryUsage = new DriverManagerConnectionFactory ( <string_literal> , <string_literal> , <string_literal> ) ; \n \n \t3 final PoolableConnectionFactory poolableConnectionFactoryUsage = new PoolableConnectionFactory ( connectionFactoryUsage , connectionPoolUsage , null , null , false , true ) ; \n \n \t3 s_usageDS = new PoolingDataSource ( poolableConnectionFactoryUsage . getPool ( ) ) ; \n \n <ect>
\t1 String regexTableName = getPoolNameForTable ( tableName ) ; \n \n \t1 SortedMap < TServerInstance , TabletServerStatus > currentView = currentGrouped \n \n \t2 . get ( regexTableName ) ; \n \n \t1 if ( null == currentView ) { \n \n <ect>
\t3 log . info ( <string_literal> , lastQueuedTxId ) ; \n \n \t3 state = STORE_COPYING ; \n \n \t3 return false ; \n \n \t2 default : \n \n <ect>
\t2 kpg = KeyPairGenerator . getInstance ( <string_literal> ) ; \n \n \t2 kpg . initialize ( <number_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testDisjointMerge ( ) throws Exception { \n \n <ect>
\t3 db . productVersion = md . getDatabaseProductVersion ( ) ; \n \n \t3 db . catalogName = conn . getCatalog ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> + db . catalogName ) ; \n \n \t3 LOGGER . debug ( <string_literal> + db . productName ) ; \n \n <ect>
\t5 try { \n \n \t6 var n = jQuery . proxy ( this . notify , this ) ; \n \n \t6 return f ( n ) ; } \n \n \t5 catch ( e ) { \n \n <ect>
\t2 LOG . trace ( <string_literal> , principal . getName ( ) , getName ( ) ) ; \n \n \t2 LoginContext context = new LoginContext ( getName ( ) , new HttpPrincipalCallbackHandler ( principal ) ) ; \n \n \t2 context . login ( ) ; \n \n \t2 Subject subject = context . getSubject ( ) ; \n \n <ect>
\t4 long thostId = thost . getId ( ) ; \n \n \t4 PoolEjectCommand eject = new PoolEjectCommand ( host . getGuid ( ) ) ; \n \n \t4 Answer answer = _agentMgr . easySend ( thostId , eject ) ; \n \n \t4 if ( answer != null && answer . getResult ( ) ) { \n \n <ect>
\t3 } else if ( filterType . equals ( <string_literal> ) ) { \n \n \t4 tableNames = filterByProjects ( tableNames , Arrays . asList ( args ) . subList ( curIdx , args . length ) ) ; \n \n \t3 } else if ( ! filterType . equals ( <string_literal> ) ) { \n \n \t4 printUsageAndExit ( ) ; } \n \n <ect>
\t4 String segmentId = getSegmentIdFromJobId ( jobId ) ; \n \n \t4 if ( segmentId != null ) { <comment> \n \n \t5 segmentId2JobId . put ( segmentId , jobId ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t7 for ( int i = 1 ; i < vmIds . length ; i ++ ) { \n \n \t8 vmIdLogStr = vmIdLogStr + <string_literal> + vmIds [ i ] ; } } \n \n \t6 s_logger . info ( <string_literal> + vmIdLogStr ) ; } } \n \n \t3 } else { \n \n <ect>
\t1 c . tableOperations ( ) . create ( tableName ) ; \n \n \t1 SortedSet < Text > splits = new TreeSet < > ( ) ; \n \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 splits . add ( new Text ( <string_literal> + i ) ) ; } \n \n <ect>
\t1 double clusterClassificationThreshold , boolean runSequential ) throws IOException , InterruptedException , \n \n \t1 ClassNotFoundException { \n \n \t1 log . info ( <string_literal> ) ; \n \n <ect>
\t5 <comment> \n \n \t5 <comment> \n \n \t5 return true ; \n \n \t4 } else { \n \n <ect>
\t3 byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; \n \n \t3 org . apache . thrift . TSerializable msg ; \n \n \t3 echoPass_result result = new echoPass_result ( ) ; \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t3 <comment> \n \n \t3 Thread . sleep ( ThreadLocalRandom . current ( ) . nextInt ( <number_literal> ) ) ; \n \n \t3 context . start ( ) ; \n \n \t3 contextLatch . await ( ) ; \n \n <ect>
\t3 if ( pstmt != null ) { \n \n \t4 try { \n \n \t5 pstmt . close ( ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t4 numberToCompare = sbAskNumber . substring ( 0 , compareCount ) ; \n \n \t3 } else { \n \n \t4 numberToCompare = sbAskNumber . substring ( 0 , sbAskNumber . length ( ) ) ; } \n \n \t3 if ( sbPhonebookNumber . toString ( ) . startsWith ( numberToCompare ) ) { \n \n <ect>
\t2 final PasswordManagementProperties pm = casProperties . getAuthn ( ) . getPm ( ) ; \n \n \t2 final HttpServletRequest request = WebUtils . getHttpServletRequestFromExternalWebflowContext ( requestContext ) ; \n \n \t2 final String username = request . getParameter ( <string_literal> ) ; \n \n \t2 if ( StringUtils . isBlank ( username ) ) { \n \n <ect>
\t9 entries . add ( entry ) ; \n \n \t9 break ; } \n \n \t8 catch ( GridCacheEntryRemovedException ignore ) { \n \n <ect>
\t2 return jcrTemplate . execute ( ( JcrCallback < List < Resource > > ) session - > new ArrayList < > ( ) ) ; } \n \n \t1 @ SuppressWarnings ( { <string_literal> , <string_literal> } ) \n \n \t1 @ Override \n \n \t1 public void rename ( final String oldPath , final String newPath ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t1 public void testGetGroupMemberships ( ) throws Exception { \n \n \t2 <comment> \n \n \t2 @ SuppressWarnings ( <string_literal> ) final java . util . Collection result = requestBody ( <string_literal> , testGroup . getID ( ) ) ; \n \n \t2 assertNotNull ( <string_literal> , result ) ; \n \n <ect>
\t2 String address ; \n \n \t2 try { \n \n \t3 address = KubernetesHelper . getServiceURL ( kubernetes , ServiceNames . GITLAB , namespace , <string_literal> , true ) ; \n \n \t3 if ( Strings . isNullOrBlank ( address ) ) { \n \n <ect>
<comment> \n \n public void addPersistControllers ( DeployBeanDescriptor < ? > deployDesc ) { \n \n \t1 for ( BeanPersistController c : list ) { \n \n \t1 if ( c . isRegisterFor ( deployDesc . getBeanType ( ) ) ) { \n \n <ect>
\t2 LOG . debug ( <string_literal> + benefit \n \n \t3 + <string_literal> + cost \n \n \t3 + <string_literal> + filDataSize \n \n \t3 + <string_literal> + ( benefit - cost ) ) ; } } \n \n <ect>
\t3 if ( charsetName != null ) { \n \n \t4 try { \n \n \t5 bytes = value . getBytes ( charsetName ) ; \n \n \t4 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t1 protected String getSchemaResourceUri ( Message message ) { \n \n \t2 String schemaResourceUri = message . getHeader ( XmlSignatureConstants . HEADER_SCHEMA_RESOURCE_URI , String . class ) ; \n \n \t2 if ( schemaResourceUri == null ) { \n \n \t3 schemaResourceUri = getConfiguration ( ) . getSchemaResourceUri ( ) ; } \n \n <ect>
\t2 obj . toStringAutomatic ( ) ; \n \n \t2 long start = System . currentTimeMillis ( ) ; \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) \n \n \t3 obj . toStringManual ( ) ; \n \n <ect>
\t6 + <string_literal> \n \n \t6 + <string_literal> ; \n \n \t2 try ( PreparedStatement pstmtUpdate = conn . prepareStatement ( insertPNSP ) ; ) { \n \n \t3 <comment> \n \n <ect>
\t4 _log . error ( <string_literal> + new String ( buf ) + <string_literal> ) ; } \n \n \t3 try { Thread . sleep ( <number_literal> * <number_literal> ) ; } catch ( InterruptedException ie ) { } \n \n \t3 s . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 System . exit ( 1 ) ; } \n \n \t2 if ( httpListenPort != 0 ) { \n \n \t3 startupHttpMain ( ) ; \n \n \t2 } else { \n \n <ect>
\t6 log . error ( <string_literal> + script . getName ( ) + <string_literal> ) ; \n \n \t5 } catch ( ScriptException scE ) { \n \n \t6 log . error ( <string_literal> + script . getName ( ) + <string_literal> + scE . getMessage ( ) ) ; } \n \n \t4 } else { \n \n <ect>
\t2 metaspaceSize = <string_literal> \n \n \t2 cmd = cmd [ : - 1 ] + <string_literal> + metaspaceSize + <string_literal> \n \n \t1 run_file_path = None \n \n \t1 try : \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 final String fileLocation = System . getenv ( UserGroupInformation . HADOOP_TOKEN_FILE_LOCATION ) ; \n \n \t2 if ( fileLocation != null ) { \n \n <ect>
\t3 length = inputCtx . getContentLength ( ) ; } \n \n \t2 if ( length < 0 && inputFile != null ) { \n \n \t3 length = inputFile . length ( ) ; } \n \n \t2 if ( length < 0 ) { \n \n <ect>
\t3 <comment> \n \n \t3 if ( ( errorCounter . getAndIncrement ( ) % <number_literal> ) == 0 ) { \n \n \t4 log . error ( <string_literal> , e . getMessage ( ) , e ) ; \n \n \t3 } else { \n \n <ect>
\t6 LOG . info ( <string_literal> + id + <string_literal> + ( counter + 1 ) ) ; } \n \n \t5 idx ++ ; \n \n \t5 counter ++ ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 GraphObject obj \t2 = getNode ( webSocketData . getId ( ) ) ; \n \n \t2 if ( obj != null ) { \n \n \t3 if ( ! ( ( AbstractNode ) obj ) . isGranted ( Permission . write , getWebSocket ( ) . getSecurityContext ( ) ) ) { \n \n \t4 getWebSocket ( ) . send ( MessageBuilder . status ( ) . message ( <string_literal> ) . code ( <number_literal> ) . build ( ) , true ) ; \n \n <ect>
\t3 Method method = jdbcSqlStat . getClass ( ) . getMethod ( <string_literal> ) ; \n \n \t3 Object obj = method . invoke ( jdbcSqlStat ) ; \n \n \t3 return ( Map < String , Object > ) obj ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 node . incrementResendCount ( ) ; \n \n \t2 <comment> \n \n \t2 if ( node . isDead ( ) ) { \n \n <ect>
\t2 try { \n \n \t3 fis = new FileInputStream ( privkey ) ; \n \n \t3 sockMgr = createManager ( fis ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t3 new ByteArrayInputStream ( content . getBytes ( StandardCharsets . UTF_8 ) ) , new ObjectMetadata ( ) ) \n \n \t3 . withCannedAcl ( CannedAccessControlList . BucketOwnerFullControl ) ; \n \n \t1 s3c . putObject ( req ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t7 s_logger . debug ( <string_literal> + _gson . toJson ( isoInfo . first ( ) ) ) ; \n \n \t6 deviceConfigSpecArray [ i ] . setOperation ( VirtualDeviceConfigSpecOperation . ADD ) ; \n \n \t5 } else { \n \n <ect>
\t4 req . getHeader ( ToHeader . NAME ) ; \n \n \t3 if ( toHeader == null ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t2 try { \n \n \t3 return dso . getType ( ) == Constants . ITEM && \n \n \t4 creativeCommonsService . getLicenseRdfBitstream ( ( Item ) dso ) != null ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<number_literal> . getConfigurationService ( ) . getProperty ( <string_literal> ) + <string_literal> ) ) { \n \n \t4 urlBuilder . append ( <string_literal> ) ; \n \n \t4 urlBuilder . append ( handle ) . append ( <string_literal> ) . append ( extraPathInfo ) ; } \n \n \t3 String url = urlBuilder . toString ( ) ; \n \n <ect>
\t6 foundName = name ; \n \n \t5 } else { \n \n \t6 throw new IllegalArgumentException ( <string_literal> ) ; } } } \n \n \t3 if ( found != null ) { \n \n <ect>
\t3 byte [ ] digest = md5 . digest ( uid . getBytes ( <string_literal> ) ) ; \n \n \t3 for ( int l = digest . length , i = Math . max ( 0 , digest . length - <number_literal> ) ; i < l ; i ++ ) { \n \n \t4 hash = hash < < <number_literal> | ( ( long ) digest [ i ] & 0xFF ) ; } \n \n \t2 } catch ( NoSuchAlgorithmException ex ) { \n \n <ect>
\t3 log . info ( <string_literal> ) ; } \n \n \t2 closeWriter ( ) ; \n \n \t2 <comment> \n \n \t2 if ( ! differentOutputSpecified ) { \n \n <ect>
\t2 timer = new Timer ( ) ; \n \n \t2 timer . schedule ( new DnsActivationTask ( ) , 0 , ttl ) ; } \n \n \t1 @ Override \n \n \t1 protected void doStop ( ) throws Exception { \n \n <ect>
\t2 VmInstances . removeVolumeAttachment ( vm , VolumeAttachCallback . this . getRequest ( ) . getVolumeId ( ) ) ; \n \n \t2 return vm ; } \n \n \t1 } ; \n \n \t1 Entities . asTransaction ( VmInstance . class , removeVolAttachment ) . apply ( this . getRequest ( ) . getInstanceId ( ) ) ; \n \n <ect>
\t1 public boolean filter ( Bundle row ) { \n \n \t2 for ( BundleFilter f : filter ) { \n \n \t3 if ( ! f . filter ( row ) && failStop ) { \n \n \t4 if ( debug ) { \n \n <ect>
\t3 logMap . put ( key , value ) ; \n \n \t3 if ( initialised ) { \n \n \t4 logger . debug ( <string_literal> , key , quote ( oldValue ) , quote ( value ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 logger . error ( <string_literal> , e ) ; \n \n \t3 return ExecuteResult . createError ( e ) ; } } \n \n \t1 private void logMapperAndCuboidStatistics ( Map < Long , HLLCounter > cuboidHLLMap , int samplingPercentage , \n \n \t3 int mapperNumber , long grantTotal , long totalRowsBeforeMerge ) throws IOException { \n \n <ect>
\t2 executor = createTestExecutor ( threadSafeResultProcessor , threadSafeTestClassListener ) ; } \n \n \t1 protected abstract Action < String > createTestExecutor ( TestResultProcessor threadSafeResultProcessor , TestClassExecutionListener threadSafeTestClassListener ) ; \n \n \t1 @ Override \n \n \t1 public void processTestClass ( TestClassRunInfo testClass ) { \n \n <ect>
\t3 <comment> \n \n \t3 try { \n \n \t4 String skip = System . getProperty ( PySystemState . PYTHON_CACHEDIR_SKIP , <string_literal> ) ; \n \n \t4 if ( skip . equalsIgnoreCase ( <string_literal> ) ) { \n \n <ect>
<comment> \n \n @ Deprecated \n \n public void shutdown ( ) \n \n { \n \n <ect>
\t3 while ( mayRun ( ) ) { \n \n \t4 try { \n \n \t5 Thread . sleep ( SLEEP_PERIOD_MS ) ; \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t3 final WebApplicationService logoutService = request . getService ( ) ; \n \n \t3 logoutService . setLoggedOutAlready ( true ) ; \n \n \t3 LOGGER . debug ( <string_literal> , logoutService . getId ( ) , request . getLogoutUrl ( ) ) ; \n \n \t3 final LogoutHttpMessage msg = new LogoutHttpMessage ( request . getLogoutUrl ( ) , logoutRequest , this . asynchronous ) ; \n \n <ect>
\t2 logger . error ( OvmDispatch , <string_literal> %clzName ) \n \n \t2 raise Fault ( dispatchErrCode ( 'InvaildClass' ) , <string_literal> %clzName ) \n \n \t1 clz = ExposedClass [ clzName ] \n \n \t1 if not hasattr ( clz , funcName ) : \n \n <ect>
<comment> \n \n \t3 if ( this . containsElementIgnoreCase ( this . excludedInboundStandardResponseHeaderNames , headerName ) ) { \n \n <ect>
\t10 Thread . sleep ( 300000L ) ; <comment> \n \n \t10 s_logger . info ( <string_literal> ) ; \n \n \t10 reason = sshTest ( method . getResponseHeader ( <string_literal> ) . getValue ( ) ) ; \n \n \t10 if ( reason == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 producer . stop ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 { \n \n \t1 oName = getName ( name ) ; } \n \n \t1 catch ( Exception e ) \n \n \t1 { \n \n <ect>
\t2 try { \n \n \t2 if ( sql != null ) { \n \n \t3 sql . close ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 LOG . info ( <string_literal> ) ; \n \n \t5 else \n \n \t6 LOG . warn ( <string_literal> ) ; \n \n \t4 } else { \n \n <ect>
\t3 tableNames = filterByGitCommit ( hbaseAdmin , tableNames ) ; \n \n \t3 logger . info ( <string_literal> + tableNames ) ; \n \n \t3 long start = System . currentTimeMillis ( ) ; \n \n \t3 Set < String > oldJarPaths = getCoprocessorJarPaths ( hbaseAdmin , tableNames ) ; \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 _zkConnection . shutdown ( ) ; } \n \n \t2 catch ( InterruptedException e ) \n \n \t2 { \n \n <ect>
\t3 if ( numRetries > 0 ) { \n \n \t4 login ( ) ; \n \n \t4 return true ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 if ( rule . length ( ) == 0 || MATCH_ALL_WORKSPACES . equals ( rule ) ) return MATCH_ALL_WORKSPACES_RULE ; \n \n \t2 try { \n \n \t3 return new RegexWorkspaceMatchRule ( rule , Pattern . compile ( rule ) ) ; \n \n \t2 } catch ( PatternSyntaxException e ) { \n \n <ect>
\t4 case READ_WRITE : \n \n \t5 dbConnection . setConnectionMode ( false , false ) ; \n \n \t5 break ; \n \n \t4 default : \n \n <ect>
\t3 Logger . minor ( this , <string_literal> + block . getClientKey ( ) . getURI ( ) + <string_literal> + this , new Exception ( <string_literal> ) ) ; \n \n \t2 try { \n \n \t3 binaryBlobWriter . addKey ( block , context ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 else { \n \n \t3 messageTag = ( String ) message . getMessageProperties ( ) \n \n \t5 . getHeaders ( ) . get ( this . correlationKey ) ; } \n \n \t2 if ( messageTag == null ) { \n \n <ect>
\t3 cls . services [ <string_literal> ] , \n \n \t3 admin = True , \n \n \t3 domainid = cls . domain . id \n \n \t2 ) \n \n <ect>
\t2 nodes = internalCluster ( ) . startNodes ( numNodes , \n \n \t3 Settings . builder ( ) . put ( IndexGraveyard . SETTING_MAX_TOMBSTONES . getKey ( ) , randomIntBetween ( <number_literal> , <number_literal> ) ) . build ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 createIndex ( indexName ) ; \n \n <ect>
\t3 pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 rs = pstmt . executeQuery ( ) ; \n \n \t3 while ( rs . next ( ) ) { \n \n \t4 if ( rs . getInt ( 1 ) != defaultDirectNetworkId ) { \n \n <ect>
\t3 v = true ; \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n \t3 logger . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( UnsatisfiedLinkError e ) { \n \n <ect>
\t6 Logger . error ( this , <string_literal> + phys ) ; \n \n \t6 continue ; \n \n \t5 } catch ( UnknownHostException e ) { \n \n \t6 <comment> \n \n <ect>
\t2 assertOrderedSearchHits ( response , <string_literal> , <string_literal> ) ; \n \n \t2 response = client ( ) . prepareSearch ( ) . setQuery ( \n \n \t4 new MoreLikeThisQueryBuilder ( null , new Item [ ] { new Item ( <string_literal> , <string_literal> , <string_literal> ) } ) . minTermFreq ( 1 ) . minDocFreq ( 1 ) . include ( true ) . minimumShouldMatch ( <string_literal> ) ) . get ( ) ; \n \n \t2 assertOrderedSearchHits ( response , <string_literal> , <string_literal> ) ; \n \n <ect>
\t1 private class AsyncSetDataCallback implements StatCallback { \n \n \t2 public void processResult ( int rc , String node , Object ctx , Stat statistics ) { \n \n \t3 if ( Code . NONODE . equals ( Code . get ( rc ) ) ) { \n \n \t4 if ( configuration . isCreate ( ) ) { \n \n <ect>
\t4 String defaultViewName = getDefaultViewName ( request ) ; \n \n \t4 if ( defaultViewName != null ) { \n \n \t5 exMv . setViewName ( defaultViewName ) ; } } \n \n <ect>
\t3 if ( host . getProxyPort ( ) != null && host . getProxyPort ( ) . intValue ( ) > 0 ) { \n \n \t4 urlPort = host . getProxyPort ( ) . intValue ( ) ; } \n \n \t3 return new ConsoleProxyInfo ( _sslEnabled , publicIp , _consoleProxyPort , urlPort , _consoleProxyUrlDomain ) ; \n \n \t2 } else { \n \n <ect>
\t3 Assert . assertEquals ( 1 , dumpreg ( readFaceId ) ) ; \n \n \t3 Assert . assertEquals ( <number_literal> , dumpreg ( listenerFaceId ) ) ; \n \n \t3 lcw . close ( ) ; \n \n \t3 Thread . sleep ( SHORT_TIMEOUT ) ; \n \n <ect>
\t1 @ Inject \n \n \t1 DataStoreManager dataStoreMgr ; \n \n \t1 @ Override \n \n \t1 protected List < StoragePool > select ( DiskProfile dskCh , VirtualMachineProfile vmProfile , DeploymentPlan plan , ExcludeList avoid , int returnUpTo ) { \n \n <ect>
\t4 { \n \n \t5 @ Override \n \n \t5 public void onChange ( IModifiable modifiable ) \n \n \t5 { \n \n <ect>
\t2 command . add ( <string_literal> ) ; \n \n \t2 String result = command . execute ( ) ; \n \n \t2 <comment> \n \n \t2 if ( result != null ) { \t5 \n \n <ect>
\t3 sqlLog . warn ( who + <string_literal> + ex . getMessage ( ) + <string_literal> + sqlString + <string_literal> ) ; } \n \n \t1 private void exception ( String who , SQLException ex ) \n \n \t1 { \n \n \t2 if ( this . loggingSQLExceptions ( ) ) \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n <ect>
\t4 logger . trace ( <string_literal> , name , status ) ; \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( Status . TERMINATED . equals ( status ) ) { \n \n <ect>
\t1 private void encryptAndStorePassword ( UserVmVO vm , String password ) { \n \n \t2 String sshPublicKey = vm . getDetail ( <string_literal> ) ; \n \n \t2 if ( sshPublicKey != null && ! sshPublicKey . equals ( <string_literal> ) && password != null && ! password . equals ( <string_literal> ) ) { \n \n \t3 if ( ! sshPublicKey . startsWith ( <string_literal> ) ) { \n \n <ect>
\t2 try { \n \n \t3 return hasAccessLevel ( ADMIN_RIGHT , getFullName ( ) ) || hasAccessLevel ( <string_literal> , getFullName ( ) ) ; \n \n \t2 } catch ( XWikiException ex ) { \n \n \t3 <comment> \n \n <ect>
\t1 mapper . setSerializationInclusion ( JsonSerialize . Inclusion . NON_EMPTY ) ; \n \n \t1 try { \n \n \t1 writer . println ( mapper . writerWithDefaultPrettyPrinter ( ) . writeValueAsString ( appStatusBuilder ) ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 data = new TreeMap < IndexableObject , String > ( ) ; \n \n \t2 counter = 0L ; } \n \n \t1 @ Override \n \n \t1 public void index ( IndexableObject object , boolean create ) throws IOException { \n \n <ect>
\t3 if ( read != <number_literal> ) { \n \n \t4 _log . error ( <string_literal> ) ; \n \n \t4 return ; } \n \n \t3 if ( new String ( buf ) . equals ( <string_literal> ) ) { \n \n <ect>
\t4 } else { \n \n \t5 path = rr . getPath ( ) ; } } \n \n \t3 return path ; \n \n \t2 } catch ( ParseException ex ) { \n \n <ect>
\t3 final Message m = new Message ( ) . setKey ( key ) ; \n \n \t3 <comment> \n \n \t3 LOG . info ( m . toString ( ) ) ; \n \n \t3 String messageId = producer . sendMessage ( m ) ; \n \n <ect>
\t4 log . warn ( <string_literal> , ioe ) ; \n \n \t2 } finally { \n \n \t3 if ( br != null ) try { br . close ( ) ; } catch ( IOException ioe ) { } } \n \n \t2 if ( log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t1 protected String templateForEntityPropertyType ( String entityName , \n \n <number_literal> String property , \n \n <number_literal> String type , \n \n <number_literal> String targetLanguage ) { \n \n <ect>
\t3 } else { \n \n \t4 try { \n \n \t5 PermissionMap . fromJsonString ( permissionVal ! ! ) \n \n \t4 } catch ( e : Exception ) { \n \n <ect>
\t2 throw new AmbariException ( e . getMessage ( ) , e ) ; } } } \n \n \t1 String content = gson . toJson ( combinedUpgradeJsonOutput ) ; \n \n \t1 System . out . println ( content ) ; } \n \n public void resetUIState ( ) throws AmbariException { \n \n <ect>
\t1 LOG . info ( <string_literal> + id + <string_literal> + getName ( ) + <string_literal> ) ; } \n \n \t1 if ( childOperators == null || childOperators . isEmpty ( ) ) { \n \n \t1 return ; } \n \n <ect>
\t3 Fuseki . serverLog . warn ( <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 DatasetRef ref = registry . get ( dataset ) ; \n \n \t2 if ( ref == null ) \n \n <ect>
\t2 ActionRequest actionReq = getRequest ( propertyMap ) ; \n \n \t2 LOG . debug ( <string_literal> , actionReq . getActionName ( ) ) ; \n \n \t2 requests . add ( actionReq ) ; } \n \n \t1 } else { \n \n <ect>
\t4 getClass ( ) , null ) ; \n \n \t2 final SortedSet < LocalizedMessage > messages = new TreeSet < > ( ) ; \n \n \t2 messages . add ( message ) ; \n \n \t2 getMessageDispatcher ( ) . fireErrors ( file . getPath ( ) , messages ) ; \n \n <ect>
\t3 public void onMessage ( Message message ) { \n \n \t4 try { \n \n \t5 consumerProducer . send ( message . getJMSReplyTo ( ) , message ) ; \n \n \t4 } catch ( JMSException e ) { \n \n <ect>
\t2 } catch ( TTransportException e ) { \n \n \t3 logger . warn ( <string_literal> , e . getMessage ( ) ) ; \n \n \t3 return false ; \n \n \t2 } catch ( SocketException e ) { \n \n <ect>
\t3 throw new IOException ( dstPath + <string_literal> ) ; } \n \n \t2 FSDataInputStream in = null ; \n \n \t2 try { \n \n \t3 in = fs . open ( path ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( itemRegistry != null ) { \n \n \t4 item = itemRegistry . getItem ( itemName ) ; } \n \n \t2 } catch ( ItemNotFoundException e1 ) { \n \n <ect>
\t2 removeGeneratedClassFiles ( ) ; \n \n \t2 try { \n \n \t3 File javaFile = new File ( ctxt . getServletJavaFileName ( ) ) ; \n \n <ect>
\t3 final EntityRoleFilter filter = new EntityRoleFilter ( roles ) ; \n \n \t3 filter . setRemoveEmptyEntitiesDescriptors ( service . isMetadataCriteriaRemoveEmptyEntitiesDescriptors ( ) ) ; \n \n \t3 filter . setRemoveRolelessEntityDescriptors ( service . isMetadataCriteriaRemoveRolelessEntityDescriptors ( ) ) ; \n \n \t3 metadataFilterList . add ( filter ) ; \n \n <ect>
\t1 protected Path getKeyDir ( String key ) { \n \n \t2 String hash = String . valueOf ( Math . abs ( ( long ) key . hashCode ( ) ) % BUCKETS ) ; \n \n \t2 Path hashDir = new Path ( _fullPath , hash ) ; \n \n \t2 Path ret = new Path ( hashDir , key ) ; \n \n <ect>
\t3 if ( Faults . filter ( parent , ex ) ) { \n \n \t3 try { \n \n \t4 DISABLE . fire ( parent ) ; \n \n \t3 } catch ( Exception ex1 ) { \n \n <ect>
\t4 } ) ; \n \n \t4 break ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t3 if ( c . getConsumerId ( ) . equals ( id ) ) { \n \n \t4 try { \n \n \t5 c . close ( ) ; \n \n \t4 } catch ( JMSException e ) { \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public TestBeanGUI ( ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t2 if ( groupUsers == null ) { \n \n \t3 LOG . error ( <string_literal> + group ) ; \n \n \t2 } else { \n \n \t3 for ( String user : groupUsers ) { \n \n <ect>
\t2 this . dirCorrectionMsg = dirCorrectionMsg ; \n \n \t2 this . dirOptimizationMsg = dirOptimizationMsg ; \n \n \t2 this . id = id ; \n \n \t2 <comment> \n \n <ect>
\t4 ans = false ; \n \n \t3 } else { \n \n \t4 ans = Integer . parseInt ( strVal ) == 1 ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 _dlMgr . configure ( <string_literal> , _params ) ; \n \n \t3 _upldMgr = new UploadManagerImpl ( ) ; \n \n \t3 _upldMgr . configure ( <string_literal> , params ) ; \n \n \t2 } catch ( ConfigurationException e ) { \n \n <ect>
\t2 String ret = masterLocalDir ( conf ) + FILE_SEPERATEOR + <string_literal> ; \n \n \t2 try { \n \n \t3 FileUtils . forceMkdir ( new File ( ret ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 protected void resolveUrls ( KeycloakUriBuilder authUrlBuilder ) { \n \n <ect>
\t2 if ( bean instanceof CamelContextAware && canSetCamelContext ( bean , beanName ) ) { \n \n \t3 CamelContextAware contextAware = ( CamelContextAware ) bean ; \n \n \t3 CamelContext context = getOrLookupCamelContext ( ) ; \n \n \t3 if ( context == null ) { \n \n <ect>
\t1 public Boolean fenceOff ( VMInstanceVO vm , HostVO host ) { \n \n \t2 VirtualMachine . Type type = vm . getType ( ) ; \n \n \t2 if ( type != VirtualMachine . Type . ConsoleProxy && type != VirtualMachine . Type . DomainRouter && type != VirtualMachine . Type . SecondaryStorageVm ) { \n \n <ect>
\t3 for ( Resource resource : resources ) { \n \n \t4 log . info ( <string_literal> , def . getName ( ) , resource ) ; } } \n \n \t2 context . refresh ( ) ; \n \n <ect>
\t1 if ( ldap != null ) { \n \n \t2 ldap . close ( ) ; } } \n \n \t1 if ( VERBOSE ) { \n \n \t1 LOG . debug ( <string_literal> + accountingGroups ) ; \n \n <ect>
\t1 driver . getResults ( valuesReadFromHiveDriver ) ; \n \n \t1 int rowIdx = 0 ; \n \n \t1 LOG . debug ( msg ) ; \n \n \t1 for ( String row : valuesReadFromHiveDriver ) { \n \n <ect>
\t1 if self . log_out_files : \n \n \t1 log_folder = self . get_log_folder ( ) \n \n \t1 user = self . get_user ( ) \n \n \t1 if log_folder == <string_literal> : \n \n <ect>
\t3 _log . debug ( <string_literal> + msgText ) ; \n \n \t2 writeBytes ( ByteBuffer . wrap ( msg . toByteArray ( ) ) ) ; } \n \n \t1 public void stopRawReceiving ( ) { \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 I2PSocketOptions opts = socketMgr . buildOptions ( props ) ; \n \n \t2 if ( props . getProperty ( I2PSocketOptions . PROP_CONNECT_TIMEOUT ) == null ) \n \n \t3 opts . setConnectTimeout ( <number_literal> * <number_literal> ) ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; \n \n \t2 clusterState = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 clusterState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n <ect>
\t10 shards . put ( shardEntry . key , shardEntry . value ) ; \n \n \t9 } else { \n \n \t10 <comment> \n \n \t10 snapshotChanged = true ; \n \n <ect>
\t3 Throwable t = e ; \n \n \t3 List < URL > urls = getCacheUrls ( url ) ; \n \n \t3 if ( urls != null && ! urls . isEmpty ( ) ) { \n \n \t4 notify ( url , listener , urls ) ; \n \n <ect>
\t4 client . isResponse413 ( ) ) ; \n \n \t2 client . reset ( ) ; } \n \n \t1 @ Test \n \n \t1 public void testAbortedPOST413NoSwallow ( ) { \n \n <ect>
\t3 logger . error ( <string_literal> , e ) ; \n \n \t3 return false ; } } \n \n \t1 private boolean waitForTableToBecomeActive ( String tableName ) { \n \n \t2 try { \n \n <ect>
\t3 try { \n \n \t4 <comment> \n \n \t4 sock . setSoTimeout ( 0 ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 rebalanceWeightToggle = ! rebalanceWeightToggle ; \n \n \t4 lastHostAutobalanceTime = now ; \n \n \t4 minutesSinceLastBalanceGauge . setLastBalanceTime ( now ) ; \n \n \t3 } else if ( ( now - lastJobAutobalanceTime ) > spawnBalancer . getConfig ( ) . getJobAutobalanceIntervalMillis ( ) ) { \n \n <ect>
\t6 connection . close ( ) ; } \n \n \t4 } catch ( Exception e ) { \n \n \t5 LOG . error ( <string_literal> + destinationName + <string_literal> + e ) ; } } } \n \n \t2 public synchronized void onException ( JMSException ex ) { \n \n <ect>
\t1 public void tearDown ( ) throws Exception { \n \n \t2 logger . info ( <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void test1 ( ) { \n \n <ect>
\t1 public boolean announceMigration ( boolean isLocalOnly ) throws RequestValidationException \n \n \t1 { \n \n \t2 CFMetaData cfm = Schema . instance . getCFMetaData ( keyspace ( ) , columnFamily ( ) ) . copy ( ) ; \n \n \t2 IndexTarget target = rawTarget . prepare ( cfm ) ; \n \n <ect>
\t2 if ( ObjectHelper . isEmpty ( buildName ) ) { \n \n \t3 LOG . error ( <string_literal> ) ; \n \n \t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t2 if ( ObjectHelper . isEmpty ( namespaceName ) ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t1 MBeanServerConnection con = connector . getConnection ( ) ; \n \n \t1 for ( ObjectName query : queries ) { \n \n \t2 Set < ObjectName > names = con . queryNames ( query , null ) ; \n \n \t2 if ( names . isEmpty ( ) ) { \n \n <ect>
\t2 PurityEdge e = ( PurityEdge ) itt . next ( ) ; \n \n \t2 if ( ! dst . equals ( e . getTarget ( ) ) ) \n \n \t3 { logger . debug ( <string_literal> + e + <string_literal> + dst ) ; err = true ; } \n \n \t2 if ( ! edges . get ( e . getSource ( ) ) . contains ( e ) ) \n \n <ect>
\t2 ucast_receivers = createReceivers ( unicast_receiver_threads , sock , UCAST_NAME ) ; \n \n \t2 if ( ip_mcast ) \n \n \t3 mcast_receivers = createReceivers ( multicast_receiver_threads , mcast_sock , MCAST_NAME ) ; } \n \n \t1 public void stop ( ) { \n \n <ect>
\t3 byte [ ] initialValue = null ; \n \n \t3 mutator . cas ( inKey , initialValue , MAX_EXPIRATION_TIME , mutation ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t6 } catch ( InvalidVariableException \n \n \t8 | IllegalUserActionException e ) { \n \n \t7 <comment> \n \n \t7 <comment> \n \n <ect>
\t1 public void start ( ) \n \n \t1 { \n \n \t2 if ( requests . isEmpty ( ) && transfers . isEmpty ( ) ) \n \n \t2 { \n \n <ect>
\t2 if ( commandClass == null ) { \n \n \t3 logger . error ( \n \n \t5 String . format ( <string_literal> , node . getNodeId ( ) , commandClassCode ) ) ; \n \n \t3 return null ; } \n \n <ect>
\t3 newRoot = root . getMatchingState ( game . getState ( ) . getValue ( game , playerId ) ) ; \n \n \t3 if ( newRoot != null ) { \n \n \t4 newRoot . emancipate ( ) ; } \n \n \t3 else \n \n <ect>
\t4 catch ( Throwable cce ) { \n \n \t5 <comment> \n \n \t5 if ( cce instanceof ClosedChannelException ) { \n \n \t6 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t2 final Class < ? extends ComponentId > idClass = candidate ; \n \n \t2 ComponentIds . lookup ( idClass ) ; \n \n \t1 } catch ( final Throwable ex ) { \n \n \t2 LOG . error ( ex , ex ) ; \n \n <ect>
\t2 for ( String s : collSel ) { \n \n \t3 try { \n \n \t4 uuids . add ( UUID . fromString ( s ) ) ; \n \n \t3 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t2 @ Override \n \n \t2 public void exceptionCaught ( ChannelHandlerContext ctx , \n \n \t9 Throwable cause ) throws Exception { \n \n <ect>
<comment> \n \n \t6 resultFile . print ( <string_literal> ) ; } \n \n \t4 } finally { \n \n \t5 long responseTime = System . currentTimeMillis ( ) - start ; \n \n <ect>
\t6 populateCookieValueIntoStack ( name , value , cookiesMap , stack ) ; \n \n \t5 } else if ( cookiesNameSet . contains ( cookie . getName ( ) ) ) { \n \n \t6 populateCookieValueIntoStack ( name , value , cookiesMap , stack ) ; } \n \n \t4 } else { \n \n <ect>
\t4 consumerCache = new EmptyConsumerCache ( this , camelContext ) ; \n \n \t4 LOG . debug ( <string_literal> , this ) ; \n \n \t3 } else if ( cacheSize == 0 ) { \n \n \t4 consumerCache = new ConsumerCache ( this , camelContext ) ; \n \n <ect>
\t1 public static String formUrlEncode ( NameValuePair [ ] pairs , String charset ) { \n \n \t2 try { \n \n \t3 return doFormUrlEncode ( pairs , charset ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t4 ring = new DirKeyRing ( new File ( ctx . getConfigDir ( ) , <string_literal> ) ) ; \n \n \t4 try { \n \n \t5 pubkey = ring . getKey ( signer , CONTENT_ROUTER , type ) ; \n \n \t4 } catch ( IOException ioe ) { \n \n <ect>
\t5 if ( notify ) { \n \n \t6 notify = false ; \n \n \t6 notifyListeners ( ) ; } \n \n \t5 if ( b . getScope ( ) == Broadcaster . SCOPE . REQUEST ) { \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t2 roi . drain ( <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 for ( DestinationBridge bridge : inboundBridges ) { \n \n \t4 bridge . start ( ) ; } \n \n \t3 for ( DestinationBridge bridge : outboundBridges ) { \n \n \t4 bridge . start ( ) ; } \n \n <ect>
\t3 for ( Service service : list ) { \n \n \t4 try { \n \n \t5 log . trace ( <string_literal> , service . getInterface ( ) ) ; \n \n \t5 if ( service . getInterface ( ) == XLogService . class ) { \n \n <ect>
\t4 requiredComponents . addAll ( Arrays . asList ( receiveEventAnnotation . components ( ) ) ) ; \n \n \t4 List < Class < ? extends Component > > componentParams = Lists . newArrayList ( ) ; \n \n \t4 for ( int i = <number_literal> ; i < types . length ; ++ i ) { \n \n \t5 if ( ! Component . class . isAssignableFrom ( types [ i ] ) ) { \n \n <ect>
\t8 this . logger . debug ( <string_literal> + consumer ) ; } \n \n \t7 try { \n \n \t8 doConsumeFromQueue ( consumer . getQueue ( ) ) ; } \n \n \t7 catch ( AmqpConnectException | AmqpIOException e ) { \n \n <ect>
\t4 HostConnectionPool previous = pools . put ( host , newPool ) ; \n \n \t4 if ( previous == null ) { \n \n \t5 logger . debug ( <string_literal> , host ) ; \n \n \t4 } else { \n \n <ect>
\t6 System . err . println ( <string_literal> + phys ) ; \n \n \t6 continue ; \n \n \t5 } catch ( PeerParseException e ) { \n \n \t6 if ( fromLocal ) \n \n <ect>
\t4 <comment> \n \n \t4 JaxrsSAML2BindingBuilder binding = createBindingBuilder ( samlClient ) ; \n \n \t4 return binding . postBinding ( logoutBuilder . buildDocument ( ) ) . request ( bindingUri ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 public Metadata createFileMetadata ( String fileId , Metadata metadata , String typeName ) { \n \n \t2 try { \n \n <ect>
\t1 public AudioManager ( ) { \n \n \t2 try { \n \n \t3 linePool = new LinePool ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 new String [ ] { vo . getItemsManageTable ( ) . toUpperCase ( ) , vo . getColname ( ) , vo . getColtype ( ) } ) ; \n \n \t3 logger . debug ( <string_literal> , tableExists , sql ) ; \n \n \t3 Yank . execute ( sql , null ) ; \n \n \t2 } else { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 for ( AbstractClient client : clients . values ( ) ) { \n \n \t3 client . close ( ) ; } \n \n \t2 clients . clear ( ) ; \n \n <ect>
\t4 . add ( newNode ( <string_literal> , singletonMap ( <string_literal> , <string_literal> ) ) ) \n \n \t2 ) . build ( ) ; \n \n \t2 clusterState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n <ect>
\t5 if ( ! element . destroy ( network , context ) ) { \n \n \t6 success = false ; \n \n \t6 s_logger . warn ( <string_literal> + element . getName ( ) ) ; } \n \n \t4 } catch ( final ResourceUnavailableException e ) { \n \n <ect>
\t5 this . componentManager . getInstanceList ( WikiObjectComponentBuilder . class ) ; \n \n \t3 for ( WikiObjectComponentBuilder componentBuilder : componentBuilders ) { \n \n \t4 wikiObjectsList . add ( componentBuilder . getClassReference ( ) ) ; } \n \n \t2 } catch ( ComponentLookupException e ) { \n \n <ect>
\t3 dt . createNode ( <string_literal> + count , new byte [ 0 ] , null , 0 , - 1 , count , \n \n \t5 Time . currentElapsedTime ( ) ) ; } \n \n \t2 DataNode zk = dt . getNode ( <string_literal> ) ; \n \n \t2 <comment> \n \n <ect>
\t3 eval . setExtendedOutputFile ( out . toPath ( ) ) ; } \n \n \t2 List < AlgorithmInstance > algos = AlgorithmInstance . load ( ctx . getConfigFile ( ) . toPath ( ) , <string_literal> , \n \n <number_literal> environment . getClassLoader ( ) ) ; \n \n \t2 if ( algos . size ( ) != 1 ) { \n \n <ect>
\t4 MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; \n \n \t4 mbs . registerMBean ( new StandardMBean ( new NativeAccess ( ) , NativeAccessMBean . class ) , new ObjectName ( MBEAN_NAME ) ) ; } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n <ect>
\t6 logger . debug ( <string_literal> , session ) ; \n \n \t6 deleteSession ( session . sessionID ) ; } \n \n \t5 else \n \n \t5 { \n \n <ect>
\t2 for ( String url : urls ) { \n \n \t3 try { \n \n \t4 super . addURL ( new URL ( url ) ) ; \n \n \t3 } catch ( MalformedURLException e ) { \n \n <ect>
<comment> \n \n \t1 private void addHandler ( GridRestCommandHandler hnd ) { \n \n \t2 assert ! handlers . containsValue ( hnd ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public void close ( ) \n \n \t1 { \n \n \t2 closed = true ; \n \n <ect>
\t4 } catch ( ResourceUnavailableException e ) { \n \n \t5 s_logger . warn ( <string_literal> + element . getName ( ) , e ) ; \n \n \t5 success = false ; \n \n \t4 } catch ( ConcurrentOperationException e ) { \n \n <ect>
\t1 assertFalse ( repo . hasAccess ( <string_literal> , EnumSet . of ( RepositoryFilePermission . WRITE ) ) ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 List < RepositoryFileAce > folder1EffectiveAces = repo . getEffectiveAces ( folder1 . getId ( ) ) ; \n \n \t1 assertEquals ( 1 , folder1EffectiveAces . size ( ) ) ; \n \n <ect>
\t1 SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; \n \n \t1 return authentication ; \n \n \t1 } catch ( ExpiredJwtException | MalformedJwtException | SignatureException | IllegalArgumentException e ) { \n \n \t1 LOG . info ( <string_literal> + request . getRequestURL ( ) ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> , cmd . getCommand ( ) ) ; \n \n \t3 res = connection . send ( cmd ) ; \n \n \t3 logger . debug ( <string_literal> , res . getMessage ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 if ( null != gcCycleDelay ) { \n \n \t1 iops . setProperty ( Property . GC_CYCLE_DELAY . getKey ( ) , gcCycleDelay ) ; } \n \n \t1 if ( null != gcCycleStart ) { \n \n \t1 iops . setProperty ( Property . GC_CYCLE_START . getKey ( ) , gcCycleStart ) ; } \n \n <ect>
\t2 String address = bindAddress . getAddress ( ) . getHostAddress ( ) ; \n \n \t2 int port = bindAddress . getPort ( ) ; \n \n \t2 String httpProtocol = ( serverSSLContext != null ) ? <string_literal> : <string_literal> ; \n \n \t2 baseURL = new URL ( httpProtocol , serverHostname , port , <string_literal> + prefix + <string_literal> ) ; \n \n <ect>
\t1 Transaction tx = TransactionCoordination . getInstance ( ) . getTransaction ( ) ; \n \n \t1 byte action = transactionConfig . getAction ( ) ; \n \n \t1 if ( ( action == TransactionConfig . ACTION_NONE || action == TransactionConfig . ACTION_ALWAYS_BEGIN ) && tx != null && tx . isXA ( ) ) { \n \n <ect>
\t6 if ( line == null ) { \n \n \t7 break ; } \n \n \t6 output1 = output1 + line ; } \n \n \t5 pd . getInputStream ( ) . close ( ) ; \n \n <ect>
\t3 try { \n \n \t4 if ( servletContext . getResource ( canonicalPath ) != null ) { \n \n \t5 return new Resource ( canonicalPath , ext ) ; } \n \n \t3 } catch ( MalformedURLException e ) { \n \n <ect>
\t3 final Marker marker = Marker . fromString ( split [ i ] ) ; \n \n \t3 if ( marker != null ) { \n \n \t4 i ++ ; } \n \n \t3 if ( split . length < <number_literal> ) { \n \n <ect>
\t1 public T call ( ) throws Exception { \n \n \t2 try { \n \n \t3 log . trace ( <string_literal> ) ; \n \n \t3 T result = c . call ( ) ; \n \n <ect>
\t1 try { \n \n \t1 LOG . debug ( <string_literal> + snapshotId ) ; \n \n \t1 connectionManager . completeSnapshotDeltaRestoration ( sanVolumeId , iqn ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 for ( int i = 0 ; i < clusterState . routingTable ( ) . index ( <string_literal> ) . shards ( ) . size ( ) ; i ++ ) { \n \n \t3 for ( ShardRouting routing : clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) ) { \n \n \t4 if ( routing . state ( ) == RELOCATING || routing . state ( ) == INITIALIZING ) { \n \n \t5 assertEquals ( routing . getExpectedShardSize ( ) , sizes [ i ] ) ; } } } \n \n <ect>
\t3 for ( EventHandler handler : event_handlers ) { \n \n \t4 try { \n \n \t5 handler . down ( evt ) ; } \n \n \t4 catch ( Throwable t ) { \n \n <ect>
\t2 { \n \n \t3 return UDFunction . create ( name , argNames , argTypes , returnType , calledOnNullInput , language , body ) ; } \n \n \t2 catch ( InvalidRequestException e ) \n \n \t2 { \n \n <ect>
\t1 public void mkdir ( ) { \n \n \t2 makeDirectory ( getPathOnShare ( ) ) ; } \n \n \t1 private void makeDirectory ( String path ) { \n \n \t2 String sharePath = getPathOnShare ( ) ; \n \n <ect>
\t3 final Network ntwk = _ntwkModel . getNetwork ( nic . getNetworkId ( ) ) ; \n \n \t3 if ( ntwk . getTrafficType ( ) == TrafficType . Control ) { \n \n \t4 controlIpAddress = nic . getIPv4Address ( ) ; } } \n \n \t2 if ( controlIpAddress == null ) { \n \n <ect>
\t2 if ( server != null ) { \n \n \t3 try { \n \n \t4 server . stop ( ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t5 logger . info ( <string_literal> , service , decodedData ) ; \n \n \t5 device . serviceMap . put ( id , newObject ) ; } \n \n \t2 } catch ( \n \n \t2 JSONException e ) { \n \n <ect>
\t2 assertTrue ( <string_literal> , latch . await ( <number_literal> , TimeUnit . SECONDS ) ) ; \n \n \t2 logger . debug ( <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void publishSubscribe ( ) throws Exception { \n \n <ect>
\t6 try { \n \n \t7 UpdateFilter . setUpdatesRequired ( false ) ; \n \n \t7 WebDaemon . startOpenmrs ( filterConfig . getServletContext ( ) ) ; } \n \n \t6 catch ( DatabaseUpdateException updateEx ) { \n \n <ect>
\t2 event . getServletContext ( ) . removeAttribute ( SERVER_CONFIG_KEY ) ; \n \n \t2 event . getServletContext ( ) . removeAttribute ( VELOCITY_ENGINE_KEY ) ; } \n \n \t1 public void contextInitialized ( ServletContextEvent event ) { \n \n \t2 try { \n \n <ect>
\t1 try { \n \n \t1 return oozieDelegate . consumeService ( headers , ui . getAbsolutePath ( ) \n \n \t2 . getPath ( ) , ui . getQueryParameters ( ) , HttpMethod . PUT , body ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 public void createVGPU ( final Connection conn , final StartCommand cmd , final VM vm , final GPUDeviceTO gpuDevice ) throws XenAPIException , XmlRpcException { } \n \n \t1 public VIF createVif ( final Connection conn , final String vmName , final VM vm , final VirtualMachineTO vmSpec , final NicTO nic ) throws XmlRpcException , XenAPIException { \n \n \t2 assert nic . getUuid ( ) != null : <string_literal> ; \n \n <ect>
\t2 releaseAfterFailure ( ) ; \n \n \t2 <comment> \n \n \t2 boolean locked = false ; \n \n \t2 if ( ! lock . isHeldByCurrentThread ( ) ) { \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t2 updateScores ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 . append ( CasProtocolConstants . PARAMETER_PROXY_GRANTING_TICKET_ID ) \n \n \t4 . append ( ' = ' ) \n \n \t4 . append ( proxyGrantingTicketId ) ; \n \n \t2 if ( this . httpClient . isValidEndPoint ( stringBuffer . toString ( ) ) ) { \n \n <ect>
\t5 if ( _contentLengthAsInt >= 0 ) { \n \n \t6 oResponse . setContentLength ( _contentLengthAsInt ) ; } \n \n \t4 } catch ( NumberFormatException e ) { \n \n \t5 LOG . warn ( <string_literal> , _contentLength , e ) ; } } \n \n <ect>
\t5 mbeanServer . registerMBean ( instance , objectName ) ; } \n \n \t3 } catch ( Throwable ex ) { \n \n \t4 if ( LOG == null ) { \n \n \t5 LOG = LogFactory . getLog ( DruidDriver . class ) ; } \n \n <ect>
\t1 if ( null != protocol && protocolSkipList . contains ( protocol ) ) { \n \n \t2 policy . setCheckHomeDirectory ( false ) ; \n \n \t2 return policy ; } \n \n \t1 } catch ( URISyntaxException e ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> + callerUserId + <string_literal> + ipOwner . getId ( ) ) ; } \n \n \t3 accountToLock = _accountDao . acquireInLockTable ( ipOwner . getId ( ) ) ; \n \n \t3 if ( accountToLock == null ) { \n \n <ect>
\t5 logger . warn ( <string_literal> { } \\ <string_literal> , typeString ) ; \n \n \t5 return ERROR_MESSAGE_TYPE_NOT_FOUND + typeString ; } } \n \n \t3 <comment> \n \n \t3 if ( type == null ) { \n \n <ect>
\t1 } catch ( ThriftSecurityException e ) { \n \n \t1 log . warn ( <string_literal> , server , e . getMessage ( ) ) ; \n \n \t1 throw new AccumuloSecurityException ( e . user , e . code , e ) ; \n \n \t1 } catch ( TException e ) { \n \n <ect>
\t6 log . trace ( <string_literal> + oi ) ; } } \n \n \t4 <comment> \n \n \t4 registry . addManagedBean ( managed ) ; } \n \n \t3 long t2 = System . currentTimeMillis ( ) ; \n \n <ect>
\t4 { \n \n \t5 internals . releaseLock ( path ) ; } \n \n \t4 catch ( KeeperException . NoNodeException e ) \n \n \t4 { \n \n <ect>
\t1 try { \n \n \t2 inputStream = httpUrlConnection . getResponseCode ( ) != HttpURLConnection . HTTP_OK \n \n \t3 ? httpUrlConnection . getErrorStream ( ) : httpUrlConnection . getInputStream ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t2 final InputStream pythonIs = new FileInputStream ( pythonPath ) ; \n \n \t2 ByteArrayDataSource ds = new ByteArrayDataSource ( pythonIs , <string_literal> ) ; \n \n \t2 MimeMultipart mm = new MimeMultipart ( ds ) ; \n \n \t2 logger . info ( mm . getContentType ( ) ) ; \n \n <ect>
\t6 <string_literal> + sinkOutputDirChildren . length + <string_literal> , \n \n \t6 1 , sinkOutputDirChildren . length ) ; \n \n \t1 File actualOutput = sinkOutputDirChildren [ 0 ] ; \n \n \t1 if ( ! Files . toString ( actualOutput , Charsets . UTF_8 ) . equals ( expectedOutput ) ) { \n \n <ect>
\t3 StorageNetworkIpRangeResponse response = _responseGenerator . createStorageNetworkIpRangeResponse ( result ) ; \n \n \t3 response . setResponseName ( getCommandName ( ) ) ; \n \n \t3 this . setResponseObject ( response ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 if ( conn != null ) { \n \n \t2 try { \n \n \t2 conn . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t3 ) ; } \n \n \t2 indexRandom ( true , docs ) ; \n \n \t2 refresh ( ) ; \n \n \t2 QueryBuilder q = QueryBuilders . boolQuery ( ) ; \n \n <ect>
\t4 Ternary < Integer , Integer , DiskControllerType > vmScsiControllerInfo = vmMo . getScsiControllerInfo ( ) ; \n \n \t4 controllerType = vmScsiControllerInfo . third ( ) ; } \n \n \t3 return controllerType . toString ( ) ; } \n \n \t2 if ( vol . getType ( ) == Volume . Type . ROOT ) { \n \n <ect>
\t8 job . setEnabled ( false ) ; \n \n \t8 spawn . updateJob ( job ) ; \n \n \t8 throw new Exception ( ex ) ; } } } } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 public boolean revokeFirewallRulesForIp ( long ipId , long userId , Account caller ) throws ResourceUnavailableException { \n \n \t2 List < FirewallRule > rules = new ArrayList < FirewallRule > ( ) ; \n \n \t2 List < FirewallRuleVO > fwRules = _firewallDao . listByIpAndPurposeAndNotRevoked ( ipId , Purpose . Firewall ) ; \n \n <ect>
\t2 if ( offering . getGuestType ( ) . equals ( GuestType . Shared ) ) { \n \n \t3 try { \n \n \t4 checkL2GatewayServiceSharedNetwork ( niciraNvpHost ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t3 this . ticketRegistry . deleteTicket ( ticket . getId ( ) ) ; \n \n \t3 throw new UnauthorizedServiceException ( UnauthorizedServiceException . CODE_UNAUTHZ_SERVICE , StringUtils . EMPTY ) ; } \n \n \t2 LOGGER . debug ( <string_literal> , ticket . getId ( ) ) ; \n \n \t2 restoreDelegatedAuthenticationRequest ( requestContext , webContext , ticket ) ; \n \n <ect>
\t2 try { \n \n \t3 module . getClassLoader ( ) . loadClass ( CDI_INJECTOR_FACTORY_CLASS ) ; \n \n \t3 <comment> \n \n \t3 if ( WeldDeploymentMarker . isWeldDeployment ( deploymentUnit ) ) { \n \n <ect>
\t2 long timeDiff = now - time ; \n \n \t2 if ( timeDiff > MAX_REQUEST_AGE ) { \n \n \t3 _context . statManager ( ) . addRateData ( <string_literal> , 1 ) ; \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 return classObj . newInstance ( ) ; \n \n \t1 } catch ( ClassNotFoundException e ) { \n \n \t2 LogLog . error ( <string_literal> + className + <string_literal> , e ) ; \n \n \t1 } catch ( IllegalAccessException e ) { \n \n <ect>
\t1 if ( ! security . canPerformSystemActions ( credentials ) ) \n \n \t2 throw new AccumuloSecurityException ( credentials . getPrincipal ( ) , \n \n \t3 SecurityErrorCode . PERMISSION_DENIED ) ; \n \n \t1 bulkImportStatus . updateBulkImportStatus ( files , BulkImportState . INITIAL ) ; \n \n <ect>
\t3 LogMessages . LOGGER . error ( Messages . MESSAGES . failedToTurnCodeIntoToken ( ) ) ; \n \n \t3 sendError ( Response . Status . FORBIDDEN . getStatusCode ( ) ) ; \n \n \t3 return false ; } \n \n \t2 LogMessages . LOGGER . debug ( Messages . MESSAGES . mediaType ( res . getMediaType ( ) ) ) ; \n \n <ect>
\t4 logger . warn ( <string_literal> , \n \n \t7 e ) ; } \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t1 return ( region . left >= this . left && \n \n \t3 region . right < = this . right && \n \n \t3 region . top \t1 >= this . top \t1 && \n \n \t3 region . bottom < = this . bottom \t1 ) ; \n \n <ect>
\t1 for ( VmTypeAvailability v : tailSet ) \n \n \t1 v . decrement ( quantity ) ; \n \n \t1 for ( VmTypeAvailability v : headSet ) \n \n \t1 v . setAvailable ( vmTypeStatus . getAvailable ( ) ) ; \n \n <ect>
\t3 logger . error ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 Short max = Tools . getShortOpt ( ConfigOptsDimmable . MAX . toString ( ) , opts ) ; \n \n \t2 if ( max == null ) { \n \n <ect>
\t1 public void addTicket ( final Ticket ticket ) { \n \n \t2 final long ttl = ticket . getExpirationPolicy ( ) . getTimeToLive ( ) ; \n \n \t2 if ( ttl < 0 ) { \n \n \t3 throw new IllegalArgumentException ( <string_literal> + ticket . getId ( ) + <string_literal> ) ; } \n \n <ect>
\t1 public void process ( WatchedEvent event ) \n \n \t1 { \n \n \t2 if ( LOG_EVENTS ) \n \n \t2 { \n \n <ect>
\t2 LOG . info ( <string_literal> + haloToHectorCtr + <string_literal> ) ; \n \n \t2 assertEquals ( haloToXenaCtr , counter ) ; \n \n \t2 LOG . info ( <string_literal> + haloToXenaCtr + <string_literal> ) ; \n \n \t2 assertEquals ( haloToTroyCtr , counter ) ; \n \n <ect>
\t3 } else { \n \n \t4 for ( String text : descriptionText ) { \n \n \t5 s_logger . info ( <string_literal> + text ) ; } } \n \n \t2 } else { \n \n <ect>
\t1 protected void fatalError ( String message , Throwable error ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 LOG . error ( <string_literal> + message , error ) ; \n \n <ect>
\t6 this . translationMessageParser ) ; \n \n \t4 this . documentBundlesCache . set ( uid , documentBundle ) ; \n \n \t3 } catch ( ComponentLookupException e ) { \n \n \t4 <comment> \n \n <ect>
\t6 if ( _log . shouldDebug ( ) ) \n \n \t7 _log . debug ( <string_literal> + Addresses . toString ( ip ) + <string_literal> + h ) ; \n \n \t6 ipstrings . add ( Addresses . toString ( ip ) ) ; } } \n \n \t4 if ( valid == 0 ) \n \n <ect>
\t4 key_prefix + os . path . basename ( upload_file_path ) ) \n \n \t1 os . remove ( upload_file_path ) \n \n def upload_file_local ( upload_command , upload_file_path , local_path ) : \n \n if os . path . exists ( local_path ) and not os . path . isdir ( local_path ) : \n \n <ect>
\t3 public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) \n \n \t3 { \n \n \t4 if ( ! ( msg instanceof ByteBuf ) ) \n \n \t4 { \n \n <ect>
\t4 invocation . setInput ( <string_literal> , <string_literal> ) ; \n \n \t4 invocation . setInput ( <string_literal> , URI ) ; \n \n \t4 invocation . setInput ( <string_literal> , URIMetaData ) ; \n \n \t3 } catch ( InvalidValueException ex ) { \n \n <ect>
\t3 transMgr . commit ( transStatus ) ; } \n \n \t2 catch ( ValidationException vex ) \n \n \t2 { \n \n \t3 onException ( transStatus ) ; \n \n <ect>
\t2 LOG . debug ( <string_literal> + user + <string_literal> + g . getName ( ) ) ; \n \n \t2 g . removeUserByName ( user ) ; } \n \n \t1 } catch ( AuthException e ) { \n \n \t1 LOG . error ( e , e ) ; \n \n <ect>
\t2 return ; } \n \n \t1 gram [ pos ] = value . getString ( ) ; \n \n \t1 gramFreq [ pos ] = value . getFrequency ( ) ; } \n \n \t1 if ( gramFreq [ 0 ] == - 1 ) { \n \n <ect>
\t1 <comment> \n \n \t1 public void testFutureEcho ( ) throws Exception { \n \n \t2 Echo service = ProxyHelper . createProxy ( context . getEndpoint ( <string_literal> ) , Echo . class ) ; \n \n \t2 Future < String > future = service . asText ( <number_literal> ) ; \n \n <ect>
private void delete ( Path operatorOutputPath , FileSystem fs ) { \n \n \t1 try { \n \n \t1 fs . delete ( operatorOutputPath , true ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 host = findHostByGuid ( firstCmd . getGuid ( ) ) ; \n \n \t4 if ( host == null ) { \n \n \t5 host = findHostByGuid ( firstCmd . getGuidWithoutResource ( ) ) ; } \n \n \t4 if ( host != null && host . getRemoved ( ) == null ) { \n \n <ect>
\t5 . queryParam ( OAuth2Constants . SCOPE , scopeParam ) ; \n \n \t3 URI url = uriBuilder . build ( ) ; \n \n \t3 NewCookie cookie = new NewCookie ( getStateCookieName ( ) , state , getStateCookiePath ( uriInfo ) , null , null , - 1 , isSecure , true ) ; \n \n \t3 logger . debug ( <string_literal> + cookie . toString ( ) ) ; \n \n <ect>
\t3 String path = readDir + File . separator + fileName ; \n \n \t3 try { \n \n \t4 PathUtils . rmr ( path ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 try { \n \n \t5 serializeMeter ( buffer , entry . getValue ( ) . f0 , entry . getValue ( ) . f1 , entry . getKey ( ) ) ; \n \n \t5 numMeters ++ ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 final long hostId , final String nwName ) { \n \n \t2 try { \n \n \t3 final boolean findResult = findOrCreateTunnelNetwork ( nwName ) ; \n \n \t3 if ( ! findResult ) { \n \n <ect>
\t4 if ( valid == 0 ) \n \n \t5 _log . error ( <string_literal> + h ) ; \n \n \t4 continue ; } } \n \n \t2 if ( ipstrings . isEmpty ( ) ) { \n \n <ect>
\t2 URI uri ; \n \n \t2 try { \n \n \t3 uri = new URI ( url ) ; \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
\t2 } catch ( InvalidTopologyException e ) { \n \n \t3 LOG . warn ( <string_literal> , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( AlreadyAliveException e ) { \n \n <ect>
\t1 try { \n \n \t2 <comment> \n \n \t2 Files . createDirectories ( metricsDir , DIR_ATTRS ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 public void setJcifsUsername ( final String jcifsUsername ) { \n \n \t2 if ( StringUtils . isNotBlank ( jcifsUsername ) ) { \n \n <ect>
\t1 LlapIoImpl . LOG . trace ( <string_literal> , \n \n \t2 isClosed , isInterrupted , pendingError . get ( ) , queue . size ( ) ) ; } \n \n \t1 LlapIoImpl . LOG . info ( <string_literal> + maxQueueSize ) ; \n \n <ect>
\t3 CubeManager cubeMgr = CubeManager . getInstance ( KylinConfig . getInstanceFromEnv ( ) ) ; \n \n \t3 CubeInstance cube = cubeMgr . getCube ( cubeName ) ; \n \n \t3 CubeSegment optSegment = cube . getSegmentById ( segmentID ) ; \n \n \t3 CubeSegment originalSegment = cube . getOriginalSegmentToOptimize ( optSegment ) ; \n \n <ect>
<comment> \n \n \t1 public void sendRequest ( HttpRequest request , FiniteDuration timeout ) throws InterruptedException , TimeoutException { \n \n <ect>
\t3 configureNamedPlugin ( iname ) ; \n \n \t3 String key = iname + SEP + name ; \n \n \t3 String cname = namedPluginClasses . get ( key ) ; \n \n \t3 if ( cname == null ) { \n \n <ect>
\t2 Collection < ClusterEntity > clusterEntities = UIUtils . clustersCache . values ( ) ; \n \n \t2 model . addAttribute ( <string_literal> , clusterEntities ) ; \n \n \t2 model . addAttribute ( <string_literal> , getNodeCount ( clusterEntities ) ) ; \n \n \t2 UIUtils . addTitleAttribute ( model , null ) ; \n \n <ect>
\t5 _asyncJobMgr . completeAsyncJob ( job . getId ( ) , JobInfo . Status . FAILED , 0 , <string_literal> ) ; \n \n \t5 return ; } \n \n \t4 VmWorkJobHandler handler = _handlers . get ( work . getHandlerName ( ) ) ; \n \n \t4 if ( handler == null ) { \n \n <ect>
\t2 } catch ( Error | RuntimeException ex ) { <comment> \n \n \t3 log . error ( <string_literal> , ex ) ; \n \n \t3 throw ex ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
<comment> \n \n \t1 public static void cutoverBetweenDataStore ( SpawnDataStore sourceDataStore , SpawnDataStore targetDataStore , boolean checkAllWrites ) throws Exception { \n \n <ect>
\t3 ExecutableRunner runner = ( ( CommandServiceTimerJobFactoryManager ) ( ( TimerService ) scheduler ) . getTimerJobFactoryManager ( ) ) . getRunner ( ) ; \n \n \t3 runner . execute ( command ) ; \n \n \t3 return null ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 Map < MediaType , Parser > parsers = defaultParser . getParsers ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , parsers . size ( ) ) ; \n \n \t2 for ( MediaType mediaType : parsers . keySet ( ) ) { \n \n \t3 parserSupportedMediaTypes . add ( mediaType ) ; \n \n <ect>
\t3 BaremetalDhcpResponse response = mgr . generateApiResponse ( vo ) ; \n \n \t3 response . setResponseName ( getCommandName ( ) ) ; \n \n \t3 this . setResponseObject ( response ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 throws IOException { \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 SqoopHCatUtilities . instance ( ) . configureHCat ( opts , job , connMgr , dbTable , \n \n \t1 job . getConfiguration ( ) ) ; \n \n <ect>
\t2 HttpMethod method = new GetMethod ( resultUrl ) ; \n \n \t2 while ( true ) { \n \n \t3 try { \n \n \t4 client . executeMethod ( method ) ; \n \n <ect>
\t3 String code = writer . toString ( ) ; \n \n \t3 Collection < String > imports = builder . getImports ( ) ; \n \n \t3 return new CodeSnippet ( code , imports ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 e . addSuppressed ( uee ) ; } \n \n \t4 new StartupException ( e ) . printStackTrace ( ps ) ; \n \n \t4 ps . flush ( ) ; \n \n \t4 try { \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t8 throw new Exception ( <string_literal> ) ; } } \n \n \t6 elapsedTimeMillis = ( System . nanoTime ( ) - startTimeNanos ) / <number_literal> ; } } \n \n \t4 InetAddress heuristic = null ; \n \n \t4 if ( targetAddress != null ) { \n \n <ect>
\t4 if ( success ) \n \n \t5 logger . info ( <string_literal> + getName ( ) \n \n \t8 + <string_literal> ) ; \n \n \t4 else \n \n <ect>
\t4 if ( p != 0 ) { \n \n \t5 bps += p ; \n \n \t5 cnt ++ ; } } \n \n \t3 double speedInMbits1 = bps / ( cnt * <number_literal> ) ; \n \n <ect>
\t3 s_logger . warn ( <string_literal> + host . getResource ( ) , e ) ; \n \n \t2 } catch ( final InstantiationException e ) { \n \n \t3 s_logger . warn ( <string_literal> + host . getResource ( ) , e ) ; \n \n \t2 } catch ( final IllegalAccessException e ) { \n \n <ect>
\t2 final DefaultRegisteredServiceConsentPolicy consentPolicy = new DefaultRegisteredServiceConsentPolicy ( ) ; \n \n \t2 consentPolicy . setEnabled ( false ) ; \n \n \t2 policy . setConsentPolicy ( consentPolicy ) ; \n \n \t2 service . setAttributeReleasePolicy ( policy ) ; \n \n <ect>
\t2 for ( int i = 0 ; i < results . length ; i ++ ) { \n \n \t3 if ( results [ i ] . type != hashes [ i ] . type ) { \n \n \t4 <comment> \n \n \t4 if ( HashType . valueOf ( results [ i ] . type . name ( ) ) != HashType . valueOf ( hashes [ i ] . type . name ( ) ) ) { \n \n <ect>
\t6 LOGGER . debug ( <string_literal> , predicate , value ) ; \n \n \t6 LOGGER . debug ( <string_literal> , \n \n \t7 provider , service ) ; \n \n \t6 if ( provider . isAvailable ( service ) ) { \n \n <ect>
\t2 } ) ; \n \n \t1 } else { \n \n \t2 server . run ( ) ; } \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 } else { \n \n \t2 lastReplId = incrementalDump ( dumpRoot , dmd , cmRoot ) ; } \n \n \t1 prepareReturnValues ( Arrays . asList ( dumpRoot . toUri ( ) . toString ( ) , String . valueOf ( lastReplId ) ) , dumpSchema ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 private void logSearchResponse ( int numberOfShards , long numberOfDocs , int iteration , SearchResponse searchResponse ) { \n \n \t2 logger . info ( <string_literal> , iteration , searchResponse . getSuccessfulShards ( ) , numberOfShards ) ; \n \n \t2 logger . info ( <string_literal> , iteration , searchResponse . getFailedShards ( ) ) ; \n \n \t2 if ( searchResponse . getShardFailures ( ) != null && searchResponse . getShardFailures ( ) . length > 0 ) { \n \n <ect>
\t2 } catch ( SAMException e ) { \n \n \t3 _log . error ( <string_literal> , e ) ; \n \n \t3 return writeString ( SESSION_ERROR , e . getMessage ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 assertTrue ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( indexName ) \n \n \t5 . setSettings ( Settings . builder ( ) . put ( IndexMetaData . INDEX_ROUTING_EXCLUDE_GROUP_SETTING . getKey ( ) + <string_literal> , node ) ) \n \n \t5 . get ( ) \n \n \t5 . isAcknowledged ( ) ) ; \n \n <ect>
\t2 publisher . start ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 consumer . start ( ) ; \n \n \t2 int distinctPublishedCount = 0 ; \n \n <ect>
\t3 return getSystemTempFolder ( ) ; } \n \n \t2 try { \n \n \t3 return getUserSpecifiedTempFolder ( userSpecifiedFolder ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 if ( ! Objects . equals ( oldVal , currVal ) ) { \n \n \t3 notifyMetaListeners ( key , oldVal , currVal ) ; } } \n \n \t2 logInfo ( <string_literal> ) ; \n \n \t1 } catch ( MetaException e ) { \n \n <ect>
\t3 serialPort . addEventListener ( this ) ; \n \n \t3 serialPort . notifyOnDataAvailable ( true ) ; \n \n \t3 return true ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public void clearTable ( String tableString , long timestamp ) throws IOException \n \n \t1 { \n \n \t2 TableName tableName = TableName . valueOf ( tableString ) ; \n \n \t2 if ( ! adm . tableExists ( tableName ) ) { \n \n <ect>
\t5 map . put ( <string_literal> , param . getUsername ( ) ) ; \n \n \t4 if ( param . getPassword ( ) != null ) \n \n \t5 map . put ( <string_literal> , param . getPassword ( ) ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 public long tell ( ) throws IOException { \n \n \t2 if ( Log . isLoggable ( Log . FAC_PIPELINE , Level . INFO ) ) \n \n <ect>
\t2 s_logger . info ( <string_literal> + vmdkDatastorePath + <string_literal> + srcBaseName ) ; \n \n \t2 if ( devices != null && devices . size ( ) > 0 ) { \n \n \t3 for ( VirtualDevice device : devices ) { \n \n \t4 if ( device instanceof VirtualDisk ) { \n \n <ect>
\t1 public void post ( Representation entity ) { \n \n \t2 InputStream input = null ; \n \n \t2 Request request = getRequest ( ) ; \n \n \t2 try { \n \n <ect>
<comment> \n \n \t2 @ Override \n \n \t2 public void onServerNotice ( final ServerNotice msg ) \n \n \t2 { \n \n <ect>
<number_literal> } else { \n \n <number_literal> success = true ; } } \n \n \t10 if ( usageIterator >= numThreads ) { \n \n <number_literal> int eventsAndBillingResponseCode = executeEventsAndBilling ( server , developerServer ) ; \n \n <ect>
\t7 GridTaskSessionAttributeTestListener lsnr = \n \n \t8 new GridTaskSessionAttributeTestListener ( log ) ; \n \n \t7 taskSes . addAttributeListener ( lsnr , false ) ; \n \n <ect>
\t5 } else { \n \n \t6 exceptionQueue . add ( id ) ; \n \n \t6 totalDeleted += 1 ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 if ( maxNbChannels != null ) { \n \n \t4 try { \n \n \t5 iMaxNbChannels = Integer . parseInt ( maxNbChannels ) ; \n \n \t4 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t3 { \n \n \t4 if ( ! printedDeprecationMessage ) \n \n \t4 { \n \n \t5 printedDeprecationMessage = true ; \n \n <ect>
\t3 result . tsnpe = ( TSampleNotPresentException ) e ; \n \n \t3 result . setTsnpeIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t4 int i = m . getIntProperty ( <string_literal> ) ; \n \n \t4 <comment> \n \n \t4 if ( i < MAX_MESSAGES ) { \n \n \t5 if ( dupChecker [ i ] == 1 ) { \n \n <ect>
\t1 public Boolean call ( ) { \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t3 return metricsList ; } \n \n \t2 } ; \n \n \t2 metric . processWith ( this , metricName , context ) ; } \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t1 private static UsageDao m_usageDao = _locator . getDao ( UsageDao . class ) ; \n \n \t1 private static UsageLoadBalancerPolicyDao m_usageLoadBalancerPolicyDao = _locator . getDao ( UsageLoadBalancerPolicyDao . class ) ; \n \n \t1 public static boolean parse ( AccountVO account , Date startDate , Date endDate ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 dexMap = Collections . singletonMap ( entryName , new DexContainer ( entry , entryName , dexSourceFile ) ) ; \n \n \t4 if ( dexFileCount > 1 ) \n \n <ect>
\t2 long attempt = 0 ; \n \n \t2 while ( isRunning ) { \n \n \t3 try ( Socket socket = new Socket ( ) ) { \n \n \t4 currentSocket = socket ; \n \n <ect>
\t1 if ( browserVersion . isKonqueror || browserVersion . isSafari ) { \n \n \t2 <comment> \n \n \t2 markedLoc = true ; } \n \n \t1 <comment> \n \n <ect>
<number_literal> } else { \n \n <number_literal> success = true ; } } \n \n \t10 if ( usageIterator >= numThreads ) { \n \n <number_literal> int eventsAndBillingResponseCode = executeEventsAndBilling ( server , developerServer ) ; \n \n <ect>
\t3 return null ; } \n \n \t3 s_logger . debug ( <string_literal> + vm ) ; } \n \n <ect>
\t2 if ( result == null ) { \n \n \t2 <comment> \n \n \t2 result = getManifestTestJarURL ( ) ; } \n \n \t1 } catch ( IOException e1 ) { \n \n <ect>
\t4 results = resolveEventViaMultivaluedAttribute ( principal , attributeValue , service , context , provider , predicate ) ; } \n \n \t3 if ( results != null && ! results . isEmpty ( ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , attributeName , results ) ; \n \n \t4 return results ; } } \n \n <ect>
<comment> \n \n \t1 public static void forceGC ( int maxLoop ) { \n \n <ect>
\t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 if ( rs . next ( ) ) { \n \n \t4 return Long . valueOf ( rs . getLong ( 1 ) ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 . setQuery ( simpleQueryStringQuery ( <string_literal> ) . field ( <string_literal> ) . field ( <string_literal> ) . minimumShouldMatch ( <string_literal> ) ) . get ( ) ; \n \n \t2 assertHitCount ( searchResponse , 2L ) ; \n \n \t2 assertSearchHits ( searchResponse , <string_literal> , <string_literal> ) ; \n \n \t2 <comment> \n \n <ect>
\t2 FileLock fileLock = raf . getChannel ( ) . lock ( ) ; \n \n \t2 <comment> \n \n \t2 File file2 = new File ( tmpDir , <string_literal> ) ; \n \n \t2 if ( ! file1 . renameTo ( file2 ) ) { \n \n <ect>
\t3 log . info ( <string_literal> + springCtx ) ; \n \n \t3 log . info ( <string_literal> + ses ) ; \n \n \t3 log . info ( <string_literal> + balancer ) ; \n \n \t3 log . info ( <string_literal> + springBean ) ; \n \n <ect>
\t2 Amount amount = new Amount ( ) ; \n \n \t2 amount . setCurrency ( <string_literal> ) . setTotal ( <string_literal> ) ; \n \n \t2 authorization . setAmount ( amount ) ; \n \n \t2 Authorization reauthorization = \t1 authorization . reauthorize ( TestConstants . SANDBOX_CONTEXT ) ; \n \n <ect>
\t2 log . debug ( <string_literal> + ArgumentUtils . convertArgumentsToStringList ( arguments ) ) \n \n \t2 setupK2JsArguments ( outputFile , sourceFiles , libraries , friendModules , arguments ) \n \n \t2 if ( arguments . sourceMap ) { \n \n \t3 arguments . sourceMapBaseDirs = sourceRoots . joinToString ( File . pathSeparator ) { it . path } } \n \n <ect>
\t1 private static Map < String , Object > getGroovyAttributeValue ( final String groovyScript , final Map < String , Object > resolvedAttributes ) { \n \n \t2 final Map < String , Object > args = CollectionUtils . wrap ( <string_literal> , resolvedAttributes , <string_literal> , LOGGER ) ; \n \n \t2 return ScriptingUtils . executeGroovyShellScript ( groovyScript , args , Map . class ) ; } \n \n \t1 private static Map < String , Object > filterInlinedGroovyAttributeValues ( final Map < String , Object > resolvedAttributes , final String script ) { \n \n <ect>
\t2 if ( fileOutputStream != null ) { \n \n \t3 try { \n \n \t3 fileOutputStream . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t1 } catch ( Exception e ) { \n \n \t1 fail ( ) ; } } \n \n @ Test \n \n public void testaddNode2 ( ) { \n \n <ect>
\t2 return null ; } \n \n \t1 @ Override \n \n \t1 protected void finalize ( ) { \n \n \t2 if ( isOpen ( ) ) { \n \n <ect>
\t2 } catch ( TException e ) { \n \n \t3 LOG . info ( <string_literal> , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 assertThat ( clusterHealth . getIndices ( ) . get ( <string_literal> ) . getActivePrimaryShards ( ) , equalTo ( numShards . numPrimaries ) ) ; \n \n \t2 assertThat ( clusterHealth . getIndices ( ) . get ( <string_literal> ) . getNumberOfReplicas ( ) , equalTo ( 0 ) ) ; \n \n \t2 assertThat ( clusterHealth . getIndices ( ) . get ( <string_literal> ) . getActiveShards ( ) , equalTo ( numShards . numPrimaries ) ) ; } \n \n \t1 public void testAutoExpandNumberReplicas1ToData ( ) throws IOException { \n \n <ect>
\t6 log . debug ( <string_literal> , MgmtLogType . CACHED_TYPE_EVICTION_ACK , evictionId , originId ) ; \n \n \t5 } catch ( ResourceUnavailableException e ) { \n \n \t6 <comment> \n \n \t6 <comment> \n \n <ect>
<comment> \n \n \t1 public void addPolicy ( final Enum name , final ExpirationPolicy policy ) { \n \n <ect>
\t3 removeJob ( graph . getJobID , clearPersistedJob ) match { \n \n \t3 case Some ( futureToComplete ) = > \n \n \t4 futuresToComplete = Some ( futuresToComplete . getOrElse ( Seq ( ) ) : + futureToComplete ) \n \n \t3 case None = > } \n \n <ect>
\t1 for ( EmbeddedCacheManager cm : cacheManagers ) { \n \n \t2 try { \n \n \t3 clearContent ( cm ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 throw new IllegalArgumentException ( <string_literal> ) ; \n \n \t3 return sxDGram . toByteArray ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 Log log = I2PAppContext . getGlobalContext ( ) . logManager ( ) . getLog ( I2PDatagramMaker . class ) ; \n \n <ect>
\t2 try { \n \n \t3 NDC . push ( name ) ; \n \n \t3 runnable . run ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t2 InetAddress addr = null ; \n \n \t2 try { \n \n \t3 addr = InetAddress . getByName ( strClusterAddress ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 String json ; \n \n \t1 try { \n \n \t1 json = jsonWriter . writeValueAsString ( registry ) ; \n \n \t1 } catch ( JsonProcessingException e ) { \n \n <ect>
\t4 if ( value instanceof String && StringUtils . hasText ( ( String ) value ) ) { \n \n \t5 headers . put ( jsonHeader , value ) ; } } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t1 VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironment ( extent . getTableId ( ) ) ; \n \n \t1 Path newDir = new Path ( vm . choose ( chooserEnv , ServerConstants . getBaseUris ( ) ) + Path . SEPARATOR \n \n \t2 + ServerConstants . TABLE_DIR + Path . SEPARATOR + dir . getParent ( ) . getName ( ) + Path . SEPARATOR \n \n \t2 + dir . getName ( ) ) ; \n \n <ect>
\t4 . done ( ) , \n \n \t3 Result . class ) ; \n \n \t2 assertNotNull ( <string_literal> , createResult ) ; \n \n \t2 assertTrue ( createResult . isSuccess ( ) ) ; \n \n <ect>
\t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n \t7 _log . warn ( <string_literal> + _dest , new Exception ( <string_literal> ) ) ; \n \n \t5 } else { \n \n \t6 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 int fetchSize = SDBConstants . jdbcFetchSizeOff ; \n \n \t2 if ( str != null ) \n \n \t3 try { fetchSize = Integer . parseInt ( str ) ; } \n \n \t3 catch ( NumberFormatException ex ) \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t6 s_logger . debug ( <string_literal> , pe ) ; \n \n \t6 return false ; } } \n \n \t4 final Date now = new Date ( System . currentTimeMillis ( ) ) ; \n \n \t4 if ( expiresTS . before ( now ) ) { \n \n <ect>
\t4 m_rootLocale = locale ; } \n \n \t3 updateLocaleWidgets ( ) ; \n \n \t3 initTree ( parentFolder ) ; \n \n \t2 } else { \n \n <ect>
\t3 final Credentials credentials = clientCredentials . getCredentials ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> , clientCredentials . getClientName ( ) ) ; \n \n \t3 <comment> \n \n \t3 final Client client = this . clients . findClient ( clientCredentials . getClientName ( ) ) ; \n \n <ect>
\t1 uploadPartRequest . setPartSize ( Long . valueOf ( request . getContentLength ( ) ) ) ; \n \n \t1 try { \n \n \t2 result = s3Client . uploadPart ( uploadPartRequest ) ; \n \n \t1 } catch ( AmazonServiceException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 for ( final Folder subfolder : folder . getFolders ( ) ) { \n \n \t3 parseFolder ( subfolder , depth + 1 , folder ) ; } } \n \n \t1 private void analyzeFolder ( final Folder folder , final int depth , final Folder parentFolder ) { \n \n <ect>
<comment> \n \n \t1 <comment> \n \n \t1 public static boolean kill ( Integer pid , int signal ) { \n \n \t2 boolean killed = false ; \n \n <ect>
\t4 log . warn ( <string_literal> , \n \n \t6 local_addr , time_service . interval ( ) , timeout ) ; \n \n \t4 use_time_service = false ; } } \n \n \t2 if ( interval > timeout ) \n \n <ect>
\t8 gobbler . exception . get ( ) ) ; } \n \n \t4 } catch ( InterruptedException ie ) { \n \n \t5 <comment> \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t7 <string_literal> + sock . getRemoteSocketAddress ( ) ) ; \n \n \t5 try { \n \n \t6 sendPackets ( ) ; \n \n \t5 } catch ( InterruptedException e ) { \n \n <ect>
@ Override \n \n final public void onReceive ( Object message ) throws Exception { \n \n \t1 HiveMessage hiveMessage = new HiveMessage ( message ) ; \n \n <ect>
\t3 imgBits = getFrameBufferJpeg ( ) ; \n \n \t2 else \n \n \t3 imgBits = getTilesMergedJpeg ( tiles , tracker . getTileWidth ( ) , tracker . getTileHeight ( ) ) ; \n \n \t2 if ( imgBits == null ) { \n \n <ect>
\t4 catch ( HResultException hre ) \n \n \t4 { \n \n \t5 hresult = hre . getHResult ( ) ; \n \n \t5 if ( hresult != DMO_E_NOTACCEPTING ) \n \n <ect>
\t6 if ( answer == null ) { \n \n \t7 s_logger . debug ( <string_literal> + cmd . toString ( ) ) ; \n \n \t7 answer = Answer . createUnsupportedCommandAnswer ( cmd ) ; } } \n \n \t4 } catch ( final Throwable th ) { \n \n <ect>
\t3 if ( data != null ) { \n \n \t4 try { \n \n \t5 return deserialize ( data ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 try { \n \n \t1 bucketWriter . append ( e ) ; \n \n \t1 Assert . fail ( <string_literal> ) ; \n \n \t1 } catch ( BucketClosedException ex ) { \n \n <ect>
\t2 if ( result ) { \n \n \t3 SuccessResponse response = new SuccessResponse ( getCommandName ( ) ) ; \n \n \t3 setResponseObject ( response ) ; \n \n \t2 } else { \n \n <ect>
\t3 return null ; } \n \n \t2 Context context = ( Context ) getManager ( ) . getContainer ( ) ; \n \n \t2 Log containerLog = context . getLogger ( ) ; \n \n <ect>
\t2 FileRandomAccessBuffer raf ; \n \n \t2 try { \n \n \t3 raf = new FileRandomAccessBuffer ( temp , length , false ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n <ect>
\t3 try { \n \n \t4 outputBuffer . put ( output . getBytes ( <string_literal> ) ) ; \n \n \t4 response = writeBuffer ( outputBuffer , sChannel , true , timeOut ) ; \n \n \t3 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t1 { \n \n \t2 log . debug ( <string_literal> , obj . getClass ( ) . getName ( ) ) ; \n \n \t2 LifeCycleMethods methods = methodsMap . get ( obj . getClass ( ) ) ; \n \n \t2 for ( Method postConstruct : methods . methodsFor ( PostConstruct . class ) ) { \n \n <ect>
\t1 Prepare for a NameNode rolling upgrade in order to not lose any data . \n \n \t1 hdfs dfsadmin - rollingUpgrade prepare \n \n \t1 <string_literal> <string_literal> <ect>
\t3 contents . add ( new Image ( region , architecture , this . name , description , imageId , imageLocation , \n \n \t6 imageOwnerId , imageState , rawState , imageType , isPublic , productCodes , kernelId , platform , \n \n \t6 ramdiskId , rootDeviceType , rootDeviceName , ebsBlockDevices , virtualizationType , hypervisor ) ) ; \n \n \t3 } catch ( NullPointerException e ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , attribute . getName ( ) , attribute . getNameFormat ( ) ) ; \n \n \t2 } else { \n \n \t3 LOGGER . debug ( <string_literal> , attribute . getName ( ) ) ; \n \n \t3 configureAttributeNameFormat ( attribute , defaultNameFormat ) ; } \n \n <ect>
\t3 log . info ( <string_literal> + testMethod . getName ( ) + <string_literal> ) ; \n \n \t3 testMethod . invoke ( caller , ( Object [ ] ) new Class [ ] { } ) ; \n \n \t3 fail ( testMethod . getName ( ) + <string_literal> ) ; } \n \n \t2 catch ( final Exception e ) { \n \n <ect>
\t2 this . currentWriteFilePath = getStoredFile ( ) ; \n \n \t2 this . currentReadFilePath = getStoredFile ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 if ( logMINOR ) Logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offerReply + <string_literal> + local + <string_literal> + localMap . size ( ) , new Exception ( <string_literal> ) ) ; \n \n \t4 oldTag = localMap . get ( uid ) ; \n \n \t4 if ( oldTag != null ) { \n \n \t5 if ( oldTag == tag ) { \n \n <ect>
\t4 log . errorf ( e , <string_literal> , tokenString ) ; } } \n \n \t2 try { \n \n \t3 token = AdapterRSATokenVerifier . verifyToken ( tokenString , deployment ) ; \n \n \t2 } catch ( VerificationException e ) { \n \n <ect>
\t2 return HighlightDisplayLevel . WEAK_WARNING ; \n \n \t1 case IGNORE : \n \n \t2 return null ; \n \n \t1 default : \n \n <ect>
\t1 private boolean notifyProgress ( double prog , double lastProg ) { \n \n \t2 if ( prog >= ( lastProg + 0 . <number_literal> ) ) { \n \n \t3 int perCom = ( int ) ( prog * <number_literal> ) ; \n \n \t3 if ( perCom != <number_literal> ) { \n \n <ect>
\t4 mshost . setAlertCount ( 0 ) ; \n \n \t4 mshost . setState ( ManagementServerHost . State . Up ) ; \n \n \t4 _mshostDao . persist ( mshost ) ; \n \n <ect>
\t2 ProxyLoadTemp temp ; \n \n \t2 public ShutdownThread ( ProxyLoadTemp temp ) { \n \n \t3 this . temp = temp ; } \n \n \t2 public void run ( ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void writeLine ( short line , short position , String text ) { \n \n \t2 if ( position < 0 || position > maxColumn ) { \n \n <ect>
\t3 while ( true ) { \n \n \t4 if ( targetName . isEmpty ( ) ) throw new IllegalArgumentException ( <string_literal> <string_literal> \\ <string_literal> ) ; \n \n \t4 if ( targetName . charAt ( 0 ) == ' / ' ) { \n \n \t5 targetName = targetName . substring ( 1 ) ; \n \n <ect>
\t1 commandline . addArgument ( customSelendroidServer . getAbsolutePath ( ) , false ) ; \n \n \t1 commandline . addArgument ( alias , false ) ; \n \n \t1 String output = ShellCommand . exec ( commandline , <number_literal> ) ; \n \n \t1 if ( log . isLoggable ( Level . INFO ) ) { \n \n <ect>
\t2 @ Override \n \n \t2 public String toString ( ) { \n \n \t3 return <string_literal> + id + <string_literal> ; } \n \n \t2 public int read ( @ Body String body ) { \n \n <ect>
\t9 size += compStreamMetrics . get_metrics_size ( ) ; \n \n \t9 sendMetricInfo ( topologyId , compStreamMetrics , MetaType . COMPONENT_STREAM , time ) ; } } \n \n \t7 cost = ticker . stop ( ) ; \n \n \t6 } catch ( Throwable ex ) { \n \n <ect>
\t1 Class < ? > classType = Class . forName ( readerType ) ; \n \n \t1 classType . getConstructor ( FileSystem . class , Path . class , Map . class ) ; \n \n \t1 return ; \n \n \t1 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t5 if ( command instanceof DecimalType ) { \n \n \t6 float hours = ( ( DecimalType ) command ) . floatValue ( ) ; \n \n \t6 int value = ( int ) ( hours * <number_literal> . ) ; \n \n \t6 if ( sendParamToHeatpump ( PARAM_COOLING_STOP , value ) ) { \n \n <ect>
\t3 writer . println ( <string_literal> \n \n \t5 + <string_literal> \n \n \t5 + <string_literal> ) \n \n \t3 writer . println ( <string_literal> ) \n \n <ect>
\t5 else \n \n \t6 statusDone ( <string_literal> + _t ( <string_literal> , appName + ' ' + version ) + <string_literal> ) ; \n \n \t4 } catch ( Throwable e ) { \n \n \t5 statusDone ( <string_literal> + _t ( <string_literal> , appName + ' ' + version ) + <string_literal> + e + <string_literal> ) ; \n \n <ect>
\t5 } catch ( IOException e ) { \n \n \t6 log . error ( <string_literal> + dbZone . getName ( ) , e ) ; } } \n \n \t4 return zones ; } \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
public String summary ( ) { \n \n \t1 return ( String ) storedValueForKey ( _PlotSummary . SUMMARY_KEY ) ; } \n \n public void setSummary ( String value ) { \n \n <ect>
\t2 keyInfoProviderList . add ( new RSAKeyValueProvider ( ) ) ; \n \n \t2 keyInfoProviderList . add ( new DSAKeyValueProvider ( ) ) ; \n \n \t2 keyInfoProviderList . add ( new DEREncodedKeyValueProvider ( ) ) ; \n \n \t2 keyInfoProviderList . add ( new InlineX509DataProvider ( ) ) ; \n \n <ect>
\t5 Optional < SettableFuture < Integer > > opt = cache . put ( ID_PREFIX + seed , f ) ; \n \n \t5 LOG . info ( <string_literal> ) ; \n \n \t5 future . set ( opt ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 public static void main ( String [ ] argv ) throws Exception { \n \n \t2 new MultiConnectTest ( ) . startMultiGames ( ) ; } \n \n \t1 public void startMultiGames ( ) throws Exception { \n \n \t2 for ( int i = 0 ; i < USER_CONNECT_COUNT ; i ++ ) { \n \n <ect>
\t1 @ Override \n \n \t1 public AuthenticationBuilder addSuccess ( final String key , final AuthenticationHandlerExecutionResult value ) { \n \n \t2 LOGGER . debug ( <string_literal> , key ) ; \n \n \t2 if ( this . successes . containsKey ( key ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( fullyExpanded ) { \n \n <ect>
\t2 List < HostVO > hosts = _hostDao . findAndUpdateDirectAgentToLoad ( cutSeconds , _loadSize , _nodeId ) ; \n \n \t2 List < HostVO > appliances = _hostDao . findAndUpdateApplianceToLoad ( cutSeconds , _nodeId ) ; \n \n \t2 hosts . addAll ( appliances ) ; \n \n \t2 if ( hosts != null && hosts . size ( ) > 0 ) { \n \n <ect>
\t6 break ; } } \n \n \t4 skipping . dec ( ) ; \n \n \t4 localBundleSkip . set ( localBundleSkip . get ( ) + bundlesSkipped ) ; \n \n \t4 globalBundleSkip . inc ( bundlesSkipped ) ; \n \n <ect>
\t1 try { \n \n \t1 api = new HdfsApi ( configurationBuilder , getHdfsUsername ( context ) ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 if ( ! config . contains ( TaskManagerOptions . MANAGED_MEMORY_SIZE ) ) { \n \n \t5 config . setLong ( TaskManagerOptions . MANAGED_MEMORY_SIZE , 4L ) ; } \n \n \t4 if ( ! config . contains ( TaskManagerOptions . NETWORK_NUM_BUFFERS ) ) { \n \n \t5 config . setInteger ( TaskManagerOptions . NETWORK_NUM_BUFFERS , <number_literal> ) ; } \n \n <ect>
\t1 LOG . warn ( <string_literal> ) ; } \n \n \t1 if ( memoryThreshold / <number_literal> < dataSize ) { <comment> \n \n \t1 while ( dataSize / numPartitions > memoryThreshold / <number_literal> ) { \n \n \t2 numPartitions *= <number_literal> ; } } \n \n <ect>
\t4 Status determinedState = investigate ( attache ) ; \n \n \t4 <comment> \n \n \t4 if ( determinedState == null ) { \n \n \t5 if ( ( System . currentTimeMillis ( ) > > <number_literal> ) - host . getLastPinged ( ) > AlertWait . value ( ) ) { \n \n <ect>
\t6 if ( messagesRecvd1 % <number_literal> == 0 ) { \n \n \t7 LOG . info ( <string_literal> + messagesRecvd1 ) ; } \n \n \t6 <comment> \n \n \t5 LOG . info ( <string_literal> + messagesRecvd1 ) ; \n \n <ect>
\t1 public void writeDevicesBackToResource ( final List < U2FDeviceRegistration > list ) throws Exception { \n \n \t2 final Map < String , List < U2FDeviceRegistration > > newDevices = new HashMap < > ( ) ; \n \n \t2 newDevices . put ( MAP_KEY_SERVICES , list ) ; \n \n \t2 mapper . writerWithDefaultPrettyPrinter ( ) . writeValue ( jsonResource . getFile ( ) , newDevices ) ; \n \n <ect>
\t4 logger . error ( <string_literal> ) \n \n \t4 node . startLog . eachLine { line - > logger . error ( <string_literal> ) } } \n \n \t3 if ( node . pidFile . exists ( ) && node . failedMarker . exists ( ) == false && \n \n \t4 ( node . httpPortsFile . exists ( ) == false || node . transportPortsFile . exists ( ) == false ) ) { \n \n <ect>
\t4 { \n \n \t5 thread . stop ( ) ; } \n \n \t4 catch ( ThreadDeath e ) \n \n \t4 { \n \n <ect>
\t1 typeInfos . add ( DECIMAL ) ; \n \n \t1 typeInfos . add ( DATE ) ; \n \n \t1 typeInfos . add ( VOID ) ; \n \n \t1 structTypeInfo . setAllStructFieldTypeInfos ( typeInfos ) ; \n \n <ect>
\t2 if ( start == null || end == null ) { \n \n \t3 return null ; } \n \n \t2 <comment> \n \n \t2 if ( start < 0 ) \t1 { valid = false ; logger . warn ( <string_literal> ) ; } \n \n <ect>
\t3 logger . error ( <string_literal> , ExceptionUtils . getStackTrace ( e ) ) ; \n \n \t2 } catch ( DataPackageException e ) { \n \n \t3 logger . error ( <string_literal> , ExceptionUtils . getStackTrace ( e ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 Message < ? > replyMessage = this . gatewayDelegate . sendAndReceiveMessage ( requestMessage ) ; \n \n \t4 if ( replyMessage != null ) { \n \n \t5 Destination destination = this . getReplyDestination ( jmsMessage , session ) ; \n \n <ect>
\t5 . map ( member - > URI . create ( <string_literal> + resolvePortOnlyHost ( member ) ) ) \n \n \t5 . toArray ( URI [ ] : : new ) ; \n \n \t3 while ( true ) \n \n \t3 { \n \n <ect>
\t2 <comment> \n \n \t1 @ Override \n \n \t1 public void close ( ) { \n \n \t2 <comment> \n \n <ect>
\t2 return ( Flow ) registry . getFlowDefinition ( id ) ; } \n \n \t1 @ Override \n \n \t1 public Flow getLoginFlow ( ) { \n \n \t2 if ( this . loginFlowDefinitionRegistry == null ) { \n \n <ect>
\t3 setInputAvroSchema ( s ) ; \n \n \t3 setOutputAvroSchema ( s ) ; \n \n \t2 } catch ( ClassNotFoundException | IllegalAccessException cnfe ) { \n \n \t3 System . err . printf ( <string_literal> ) ; \n \n <ect>
\t6 new UsageEventVO ( EventTypes . EVENT_TEMPLATE_CREATE , privateTemplate . getAccountId ( ) , zoneId , privateTemplate . getId ( ) , privateTemplate . getName ( ) , null , \n \n \t8 privateTemplate . getSourceTemplateId ( ) , srcTmpltStore . getPhysicalSize ( ) , privateTemplate . getSize ( ) ) ; \n \n \t4 _usageEventDao . persist ( usageEvent ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t3 } else { \n \n \t4 log . error ( <string_literal> , e ) ; } } \n \n \t2 long t2 = System . nanoTime ( ) ; \n \n <ect>
\t1 public void testInvokingSimpleServerWithParams ( ) throws Exception { \n \n \t2 Exchange exchange = sendSimpleMessage ( ) ; \n \n \t2 org . apache . camel . Message out = exchange . getOut ( ) ; \n \n \t2 String result = out . getBody ( String . class ) ; \n \n <ect>
\t4 for ( RoleType roleType : RoleType . values ( ) ) { \n \n \t5 if ( ( cmdPermissions & roleType . getMask ( ) ) != 0 ) \n \n \t6 commandsPropertiesRoleBasedApisMap . get ( roleType ) . add ( apiName ) ; } \n \n \t3 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t7 else if ( <string_literal> . equals ( name ) ) { \n \n \t8 result . setUserAgentACL ( hdr . getValue ( ) ) ; } } \n \n \t6 return result ; } \n \n \t5 else if ( response . getStatusCode ( ) == HttpStatus . SC_UNAUTHORIZED ) { \n \n <ect>
\t2 logger . warn ( <string_literal> , attempt ) ; \n \n \t2 throw originException ; } \n \n \t1 protected boolean isCausedByOptimisticLockingFailure ( Throwable throwable ) { \n \n \t2 if ( targetExceptionClass == null ) { \n \n <ect>
\t3 ) \n \n \t3 . highlighter ( new HighlightBuilder ( ) . field ( <string_literal> ) ) \n \n \t3 . addSort ( <string_literal> , SortOrder . ASC ) \n \n \t3 . get ( ) ; \n \n <ect>
\t1 @ Test \n \n \t1 public void gcCheckDeletedSize ( ) throws Exception { \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 BlobStoreState state = setUp ( <number_literal> , <number_literal> , <number_literal> ) ; \n \n <ect>
\t1 @ AfterClass \n \n \t1 public static void tearDownAfterClass ( ) throws Exception { \n \n \t2 CamelTestSupport . tearDownAfterClass ( ) ; \n \n \t2 <comment> \n \n <ect>
\t4 } else { <comment> \n \n \t5 OakSolrConfiguration configuration = oakSolrConfigurationProvider . getConfiguration ( ) ; \n \n \t5 editor = getEditor ( configuration , solrServerProvider . getIndexingSolrServer ( ) , callback ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 } else if ( StringUtils . startsWith ( userHome , <string_literal> + File . separator ) ) { \n \n \t3 userHome = System . getProperty ( <string_literal> ) + File . separator + userHome . substring ( <number_literal> ) ; } \n \n \t2 userHome = FilenameUtils . normalize ( userHome ) ; \n \n \t2 File exHomeDirectory = new File ( userHome ) ; \n \n <ect>
\t3 if ( throwable != null ) { \n \n \t4 Throwable error = ExceptionUtils . stripCompletionException ( throwable ) ; \n \n \t4 if ( error instanceof RestHandlerException ) { \n \n \t5 final RestHandlerException rhe = ( RestHandlerException ) error ; \n \n <ect>
\t3 BufferedWriter out = new BufferedWriter ( fstream ) ; ) \n \n \t2 { \n \n \t3 out . write ( <string_literal> ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t1 public void processHL7InQueue ( ) throws HL7Exception { \n \n \t2 synchronized ( lock ) { \n \n \t3 if ( isRunning ) { \n \n <ect>
\t1 if ( ! kafkaOffsets . isEmpty ( ) ) { \n \n \t2 logger . info ( <string_literal> , topicStr ) ; \n \n \t2 logger . debug ( <string_literal> , kafkaOffsets ) ; \n \n \t2 return ; } \n \n <ect>
\t2 keysToRemove . add ( RUNTIME_REFERENCES_STRICT ) ; \n \n \t2 <comment> \n \n \t2 for ( String key : keysToRemove ) { \n \n \t3 if ( properties . containsKey ( key ) ) { \n \n <ect>
\t3 Assert . assertEquals ( i . doubleValue ( ) / <number_literal> , hasTen . get ( i . toString ( ) ) ) ; } \n \n \t2 Assert . assertEquals ( initialDefault , hasTen . get ( <string_literal> ) ) ; } \n \n \t1 @ Test \n \n \t1 public void testClear ( ) { \n \n <ect>
\t3 Promise . asPromise ( loadbalancer ) , updatedZones ) ; } \n \n \t1 @ Override \n \n \t1 protected void doCatch ( Throwable e ) throws Throwable { \n \n \t2 if ( e instanceof CancellationException ) { \n \n <ect>
public void execute ( ) { \n \n \t1 for ( String sourceFileId : getSourceFileIds ( ) ) { \n \n \t1 RepositoryFile sourceFile = getRepository ( ) . getFileById ( sourceFileId ) ; \n \n \t1 if ( sourceFile == null ) { \n \n <ect>
\t3 if ( headersFound && line != null && StringUtils . isBlank ( line ) ) { \n \n \t4 line = input . readLine ( ) ; \n \n \t3 } else { \n \n \t4 if ( headersFound ) { \n \n <ect>
\t4 ( SOAPObjectBuilder < Body > ) builderFactory . getBuilder ( Body . DEFAULT_ELEMENT_NAME ) ; \n \n \t2 final Body body = bodyBuilder . buildObject ( \n \n \t4 SOAPConstants . SOAP11_NS , Body . DEFAULT_ELEMENT_LOCAL_NAME , OPENSAML_11_SOAP_NS_PREFIX ) ; \n \n \t2 if ( ! body . getUnknownXMLObjects ( ) . isEmpty ( ) ) { \n \n <ect>
\t1 public void init ( ServletConfig config ) throws ServletException { \n \n \t2 super . init ( config ) ; \n \n \t2 <comment> \n \n \t2 if ( UpdateFilter . updatesRequired ( ) && ! DatabaseUpdater . allowAutoUpdate ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 createBroker ( false ) ; \n \n \t3 brokerService . start ( ) ; \n \n \t3 brokerService . waitUntilStarted ( ) ; \n \n <ect>
\t5 } else { \n \n \t6 logger . warn ( new StringBuilder ( this . getName ( ) ) . append ( <string_literal> ) . append ( cardId . getName ( ) ) . append ( ' : ' ) . append ( cardId . extension ) ) ; \n \n \t6 notValid ++ ; } \n \n \t4 } else { \n \n <ect>
\t7 value = eo . valueForKey ( key ) ; \n \n \t6 } else { \n \n \t7 if ( eo . isNewObject ( ) ) { \n \n \t8 if ( ! _warned . containsObject ( entityName ) ) { \n \n <ect>
\t1 end = System . currentTimeMillis ( ) ; \n \n \t1 duration = ( end - start ) / <number_literal> . 0 ; \n \n \t1 log . info ( <string_literal> , duration ) ; \n \n \t1 double errorRate = ( double ) errorCount / totalCount ; \n \n <ect>
\t6 if ( th . transport != null ) { \n \n \t7 try { \n \n \t8 th . transport . oneway ( command ) ; \n \n \t7 } catch ( IOException e ) { \n \n <ect>
\t2 Log . info ( Log . FAC_TEST , <string_literal> + rfos . getBaseName ( ) ) ; \n \n \t2 CCNFileInputStream fis = new CCNFileInputStream ( fileName , getHandle ) ; \n \n \t2 TestUtils . checkFile ( getHandle , fis ) ; \n \n \t2 CountAndDigest readDigest = readRandomFile ( fis ) ; \n \n <ect>
<number_literal> if ( ! levelMatch . group ( <number_literal> ) . isEmpty ( ) ) { \n \n <number_literal> levelTo = TextboxLevelRule . AND_HIGHER ; } \n \n <number_literal> isLeveler = true ; \n \n \t10 } catch ( Exception e ) { \n \n <ect>
\t5 log . error ( getLogStartInfo ( ) + <string_literal> + message . toString ( ) ) ; } \n \n \t4 break ; } \n \n \t3 case GAME_SELECT : { \n \n \t4 GameClientMessage message = ( GameClientMessage ) callback . getData ( ) ; \n \n <ect>
\t2 MessageConsumer c1 = session . createConsumer ( consumeDestination ) ; \n \n \t2 c1 . setMessageListener ( messageList ) ; \n \n \t2 <comment> \n \n \t2 ActiveMQQueue sendDestination = new ActiveMQQueue ( getQueueName ( ) ) ; \n \n <ect>
\t5 } else { \n \n \t6 LOG . warn ( <string_literal> , revision ) ; } \n \n \t5 return new JournalEntry ( revision , timestamp ) ; \n \n \t4 } else { \n \n <ect>
\t3 AbstractThreadGroup [ ] tg = keepOnlyThreadGroups ( nodes ) ; \n \n \t3 if ( nodes . length > 0 ) { \n \n \t4 startEngine ( noTimers , isValidation , tg ) ; } \n \n \t3 else { \n \n <ect>
\t3 { \n \n \t4 unsubscribe ( srcContact ) ; \n \n \t3 } catch ( OperationFailedException ex ) \n \n \t3 { \n \n <ect>
\t1 IZooReaderWriter zoo = ZooReaderWriter . getInstance ( ) ; \n \n \t1 try { \n \n \t1 zoo . recursiveDelete ( path + <string_literal> + server , NodeMissingPolicy . SKIP ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t6 : desktopH - y ) ; \n \n \t5 sf . setBounds ( x , y , sfwidth , sfheight ) ; \n \n \t5 x += sfwidth ; } } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 try { \n \n \t4 reader . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<number_literal> HttpResponseStatus . BAD_REQUEST , \n \n <number_literal> <string_literal> \n \n <number_literal> + originTime ) ; } \n \n \t2 } else { \n \n <ect>
\t4 + <string_literal> \n \n \t4 + <string_literal> ) ; \n \n \t2 Iterator < Tuple > it = pig . openIterator ( <string_literal> ) ; \n \n \t2 int count = 0 ; \n \n <ect>
private void removeTempLogs ( Path tablePath ) throws IOException { \n \n \t1 FileSystem fs = tablePath . getFileSystem ( configuration ) ; \n \n \t1 Path logsPath = new Path ( tablePath , <string_literal> ) ; \n \n \t1 if ( fs . exists ( logsPath ) ) { \n \n <ect>
\t4 Answer [ ] answer = sendRebalanceCommand ( futureOwnerId , hostId , currentOwnerId , futureOwnerId , Event . StartAgentRebalance ) ; \n \n \t4 if ( answer == null || ! answer [ 0 ] . getResult ( ) ) { \n \n \t5 result = false ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
<comment> \n \n \t1 protected Authentication authenticateEcpRequest ( final Credential credential , \n \n <number_literal> final Pair < AuthnRequest , MessageContext > authnRequest ) { \n \n \t2 final String issuer = SamlIdPUtils . getIssuerFromSamlRequest ( authnRequest . getKey ( ) ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public void forwardPortStatus ( byte [ ] ip , int port , int externalPort , boolean success , String reason ) { \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) { \n \n \t3 if ( success ) \n \n <ect>
\t2 if ( StringUtils . isNotBlank ( source ) ) { \n \n \t3 try { \n \n \t4 setValue ( Integer . parseInt ( source ) ) ; \n \n \t3 } catch ( NumberFormatException nex ) { \n \n <ect>
\t1 public boolean canHandle ( PhysicalNetwork physicalNetwork ) { \n \n \t2 if ( physicalNetwork != null ) { \n \n \t3 if ( fetchSspClients ( physicalNetwork . getId ( ) , physicalNetwork . getDataCenterId ( ) , true ) . size ( ) > 0 ) { \n \n \t4 return true ; } \n \n <ect>
\t3 log . debug ( configInfo ( <string_literal> , minBufferedMsgCnt ) ) ; \n \n \t3 log . debug ( configInfo ( <string_literal> , bufSizeRatio ) ) ; \n \n \t3 log . debug ( configInfo ( <string_literal> , connTimeout ) ) ; \n \n \t3 log . debug ( configInfo ( <string_literal> , maxConnTimeout ) ) ; \n \n <ect>
\t3 final UserProfile profile = this . profileCreator . create ( credentials , getWebContext ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , profile ) ; \n \n \t3 return createResult ( new ClientCredential ( credentials , authenticator . getClass ( ) . getSimpleName ( ) ) , profile ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t2 Response response = base . request ( ) . get ( ) ; \n \n \t2 log . info ( <string_literal> + response . getStatus ( ) ) ; \n \n \t2 String result = response . readEntity ( String . class ) ; \n \n \t2 log . info ( <string_literal> + result ) ; \n \n <ect>
\t6 pstmt . executeUpdate ( ) ; \n \n \t6 pstmt . close ( ) ; \n \n \t6 s_logger . debug ( <string_literal> + routerId + <string_literal> + directNetworkId ) ; \n \n \t6 upgradeUserVms ( conn , routerId , directNetworkId , gateway , vnet , <string_literal> , <string_literal> ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 ssh_command = <string_literal> \n \n \t3 self . logger . debug ( <string_literal> % nat_rule . ipaddress ) \n \n \t3 ssh = vm . get_ssh_client ( ipaddress = nat_rule . ipaddress , port = self . services [ rule_label ] [ <string_literal> ] , retries = <number_literal> ) \n \n \t3 result = str ( ssh . execute ( ssh_command ) ) \n \n <ect>
\t1 @ Override \n \n \t1 public void setup ( ManagementClient managementClient , String containerId ) throws Exception { \n \n \t2 categories = getCategories ( managementClient , containerId ) ; \n \n \t2 if ( categories == null || categories . isEmpty ( ) ) { \n \n <ect>
\t2 String titles = <string_literal> ; \n \n \t2 Iterator < XxeJaxbFavoriteMovieXmlRootElement > it = set . iterator ( ) ; \n \n \t2 while ( it . hasNext ( ) ) { \n \n \t3 String title = it . next ( ) . getTitle ( ) ; \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 if ( clusterDetails . get ( <string_literal> ) != null ) { \n \n \t4 URI uriFromCluster = new URI ( UriUtils . encodeURIComponent ( clusterDetails . get ( <string_literal> ) ) ) ; \n \n \t4 morCluster = context . getHostMorByPath ( URLDecoder . decode ( uriFromCluster . getPath ( ) ) ) ; \n \n \t4 if ( morCluster == null || ! morCluster . getType ( ) . equalsIgnoreCase ( <string_literal> ) ) { \n \n <ect>
\t1 if ( provider . getName ( ) != null ) { \n \n \t1 beanProviders . put ( provider . getName ( ) , provider ) ; } } \n \n @ Override \n \n public void addSuperTypeAlias ( final String superTypeName , final String typeName ) { \n \n <ect>
\t2 this . responseHeaders = requireNonNull ( responseHeaders ) ; } \n \n \t1 @ Override \n \n \t1 protected void channelRead0 ( ChannelHandlerContext ctx , HttpRequest message ) { \n \n \t2 <comment> \n \n <ect>
\t2 < p > Reload this page with open console , enter text and hit the log button . . . < / p > \n \n \t2 Message : \n \n \t2 < input type = <string_literal> ng - model = <string_literal> / > \n \n \t2 < button ng - click = <string_literal> > log < / button > \n \n <ect>
\t4 break ; \n \n \t3 case DEPOSED : \n \n \t3 case SHUTDOWN : \n \n \t3 default : \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t4 if ( TransportActions . isShardNotAvailableException ( e ) ) { \n \n \t5 throw ( ElasticsearchException ) e ; \n \n \t4 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 final Cluster cluster ; \n \n \t1 try { \n \n \t1 cluster = clusters . getCluster ( clusterId ) ; \n \n \t1 if ( null == cluster ) { \n \n <ect>
\t5 LOGGER . warn ( <string_literal> , clientIp ) ; \n \n \t5 return false ; } \n \n \t3 } else { \n \n \t4 LOGGER . info ( <string_literal> , clientIp ) ; } } \n \n <ect>
\t3 BufferedWriter out = new BufferedWriter ( fstream ) ; \n \n \t3 out . write ( <string_literal> ) ; \n \n \t3 out . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 break ; } \n \n \t3 if ( assigned != null ) \n \n \t4 assigned . returnWorkPermit ( ) ; \n \n \t3 if ( task != null ) \n \n <ect>
<comment> \n \n \t1 private boolean verifyAccessTokenRequest ( final HttpServletRequest request , final HttpServletResponse response ) { \n \n \t2 final String grantType = request . getParameter ( OAuth20Constants . GRANT_TYPE ) ; \n \n \t2 if ( ! isGrantTypeSupported ( grantType , OAuth20GrantTypes . values ( ) ) ) { \n \n <ect>
\t4 if ( status . isDebug ( ) ) { \n \n \t5 logger . debug ( <string_literal> , ex ) ; } \n \n \t4 doSetRollbackOnly ( status ) ; } } \n \n \t2 catch ( RuntimeException | Error rbex ) { \n \n <ect>
\t3 return <string_literal> ; } \n \n \t2 return song . getArtist ( ) . toString ( ) ; } \n \n \t1 private void songChanged ( String playerId , MPDSong newSong ) { \n \n \t2 String title = getTitle ( newSong ) ; \n \n <ect>
\t4 con . close ( ) ; } } \n \n \t2 catch ( javax . jms . IllegalStateException ex ) { \n \n \t3 logger . debug ( <string_literal> + ex ) ; } \n \n \t2 catch ( Throwable ex ) { \n \n <ect>
\t4 isGroup = true ; \n \n \t4 break ; } } \n \n \t2 if ( ! isGroup ) { \n \n \t3 if ( Log . isLoggable ( Log . FAC_ACCESSCONTROL , Level . INFO ) ) { \n \n <ect>
\t1 for ( Property sslProtocolProperty : Arrays . asList ( Property . RPC_SSL_CLIENT_PROTOCOL , \n \n \t2 Property . RPC_SSL_ENABLED_PROTOCOLS , Property . MONITOR_SSL_INCLUDE_PROTOCOLS ) ) { \n \n \t1 String value = conf . get ( sslProtocolProperty ) ; \n \n \t1 if ( value . contains ( SSL ) ) { \n \n <ect>
\t2 logger . warn ( msg ) ; \n \n \t2 throw new ErrorResponseException ( msg ) ; } \n \n \t1 private byte sendCommand ( PifaceNode node , byte command , byte commandAck , int pinNumber , int pinValue , int attempt ) \n \n \t3 throws ErrorResponseException { \n \n <ect>
\t5 DictionaryInfo dictInfo = dictMgr . getDictionaryInfo ( segment . getDictResPath ( col ) ) ; \n \n \t5 if ( dictInfo != null && ! dictInfos . contains ( dictInfo ) ) { \n \n \t6 dictInfos . add ( dictInfo ) ; \n \n \t5 } else { \n \n <ect>
\t1 <comment> \n \n \t1 public void stop ( ) { \n \n \t2 try { \n \n \t3 stopAsync ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 log . error ( <string_literal> , e ) ; \n \n \t2 } catch ( ParseException e ) { \n \n \t3 log . error ( <string_literal> , e ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 if ( StringUtils . isBlank ( this . spnegoAttributeName ) ) { \n \n \t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( this . connectionFactory == null ) { \n \n <ect>
\t3 if ( ( this . auth_value != null ) && ( serverToken . auth_value != null ) \n \n \t7 && ( this . auth_value . equalsIgnoreCase ( serverToken . auth_value ) ) ) { \n \n \t4 <comment> \n \n <ect>
\t1 <comment> \n \n \t1 for ( runner < - runners . filterNot ( _ . jobId < 0 ) ) { \n \n \t2 try { \n \n \t2 if ( LibBat . lsb_signaljob ( runner . jobId , SIGTERM ) < 0 ) \n \n <ect>
\t2 logger . debug ( <string_literal> , node . getNodeId ( ) , \n \n \t4 commandClass . getCommandClass ( ) . getLabel ( ) , endpointId ) ; \n \n \t2 String parmNumber = arguments . get ( <string_literal> ) ; \n \n \t2 if ( parmNumber == null ) { \n \n <ect>
\t3 final LoggerContext loggerContext = Configurator . initialize ( <string_literal> , null , logConfigurationFile . getURI ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 loggerContext . getConfiguration ( ) . addListener ( reconfigurable - > loggerContext . updateLoggers ( reconfigurable . reconfigure ( ) ) ) ; \n \n \t3 return Optional . of ( Pair . of ( logConfigurationFile , loggerContext ) ) ; } \n \n <ect>
\t5 break ; } } } \n \n \t2 return ressr ; } \n \n \t1 private long getStaticMax ( final String os , final boolean b , final long dynamicMinRam , final long dynamicMaxRam , final long recommendedValue ) { \n \n \t2 if ( recommendedValue == 0 ) { \n \n <ect>
\t2 public void run ( ) { \n \n \t3 try { \n \n \t3 MiniAccumuloClusterImpl . this . stop ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 finished = true ; \n \n \t3 } catch ( InterruptedException e ) { \n \n \t4 log . error ( <string_literal> , e ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
public void cancel ( OperationState stateAfterCancel ) throws HiveSQLException { \n \n \t1 String queryId = null ; \n \n \t1 if ( stateAfterCancel == OperationState . CANCELED ) { \n \n \t1 queryId = queryState . getQueryId ( ) ; \n \n <ect>
\t3 return new CheckNetworkAnswer ( cmd , true , <string_literal> ) ; } } \n \n \t1 private boolean isNetworkSetupByName ( String nameTag ) { \n \n \t2 if ( nameTag != null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 params . add ( <string_literal> ) ; \n \n \t2 Sink output = new MockSink ( ) { \n \n \t3 @ Override \n \n \t3 public void index ( IndexableObject object , boolean create ) throws IOException { \n \n <ect>
<comment> \n \n \t1 private void init ( ) throws GridException { \n \n \t2 if ( initGuard . compareAndSet ( false , true ) ) { \n \n <ect>
\t5 if ( _callMonitor == null ) { <comment> \n \n \t6 logger . debug ( \n \n \t8 <string_literal> ) ; \n \n \t6 if ( _pbm == null ) { \n \n <ect>
\t2 } catch ( IllegalBlockSizeException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( BadPaddingException e ) { \n \n <ect>
\t6 log . info ( <string_literal> + rsrc4 ) ; \n \n \t6 log . info ( <string_literal> + rsrc5 ) ; \n \n \t6 log . info ( <string_literal> + rsrc6 ) ; \n \n \t6 log . info ( <string_literal> + rsrc7 ) ; \n \n <ect>
\t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 counters . get ( OnRevisitStatePlugin . class ) . inc ( ) ; \n \n \t2 for ( Plugin plugin : plugins . get ( OnRevisitStatePlugin . class ) ) { \n \n \t3 if ( plugin instanceof OnRevisitStatePlugin ) { \n \n <ect>
\t2 File statsFile = new File ( _repositoryRoot , DEBUG_STATS_FILE ) ; \n \n \t2 PrintStream statsOut = null ; \n \n \t2 try { \n \n \t3 if ( Log . isLoggable ( Log . FAC_REPO , Level . INFO ) ) { \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName + <string_literal> + replDumpId + <string_literal> + lastDumpIdWithoutDrop , driver ) ; \n \n \t1 String incrementalDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String incrementalDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t6 _privateNic = nic ; \n \n \t6 s_logger . info ( <string_literal> + nicName ) ; \n \n \t6 break ; } } \n \n \t4 <comment> \n \n <ect>
\t5 logger . error ( <string_literal> + key , e ) ; } } } } \n \n \t1 protected void delayRead ( Selector selector , long now , final SelectionKey key ) { \n \n \t2 TcpNioConnection connection = ( TcpNioConnection ) key . attachment ( ) ; \n \n \t2 if ( ! this . delayedReads . add ( new PendingIO ( now , key ) ) ) { <comment> \n \n <ect>
\t3 @ RequestParam ( <string_literal> ) String error , \n \n \t3 @ RequestParam ( value = <string_literal> , required = false ) String errorDescription , \n \n \t3 @ RequestParam ( value = <string_literal> , required = false ) String errorUri , \n \n \t3 NativeWebRequest request ) { \n \n <ect>
\t2 try { \n \n \t3 jmDNSClass = Class . forName ( <string_literal> ) ; \n \n \t3 serviceInfoClass = Class . forName ( <string_literal> ) ; \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t1 msg . setContent ( mp ) ; \n \n \t1 msg . setSentDate ( new Date ( ) ) ; \n \n \t1 Transport . send ( msg ) ; \n \n \t1 } catch ( MessagingException e ) { \n \n <ect>
\t1 public void mkdir ( String path ) { \n \n \t2 try { \n \n \t3 cluster_state . mkdirs ( path ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 LOG . warn ( <string_literal> ) ; } } \n \n \t1 public void processDialogTerminated ( \n \n \t3 DialogTerminatedEvent dialogTerminatedEvent ) { \n \n <ect>
\t1 public Object intercept ( InvocationContext ctx ) throws Exception { \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 InterceptorVisitList . add ( this ) ; \n \n \t2 Object result = ctx . proceed ( ) ; \n \n <ect>
\t2 DBObject root = collection . findOne ( new BasicDBObject ( Document . ID , <string_literal> ) ) ; \n \n \t2 long end = clock . getTime ( ) ; \n \n \t2 long mid = ( start + end ) / <number_literal> ; \n \n \t2 if ( root == null ) { \n \n <ect>
\t3 this . prometheusExporter = prometheusExporter ; } \n \n \t2 @ Override \n \n \t2 public void handle ( final HttpExchange httpExchange ) throws IOException { \n \n \t3 final String remoteClientAddress = httpExchange . getRemoteAddress ( ) . getAddress ( ) . toString ( ) . replace ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t3 testKafkaServerPrincipal = testKafkaServerPrincipal + <string_literal> + kdc . getRealm ( ) ; \n \n \t3 hadoopServicePrincipal = hadoopServicePrincipal + <string_literal> + kdc . getRealm ( ) ; \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 LOG . info ( <string_literal> , testPrincipal ) ; \n \n <ect>
\t4 log . info ( <string_literal> , path ) ; \n \n \t4 @ Syntax ( <string_literal> ) String content = new String ( Files . readAllBytes ( path ) ) ; \n \n \t4 manager = Configs . decodeObject ( AuthenticationManagerStatic . class , content ) ; } \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t3 LOG . info ( <string_literal> , new Object [ ] { configuration . getHost ( ) , configuration . getPort ( ) , multicastNetworkInterface . getName ( ) } ) ; \n \n \t3 datagramChannel . joinGroup ( hostAddress , multicastNetworkInterface ) . syncUninterruptibly ( ) ; \n \n \t3 allChannels . add ( datagramChannel ) ; \n \n \t2 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 try { \n \n \t2 VolumeManager vm = VolumeManagerImpl . get ( SiteConfiguration . getInstance ( ) ) ; \n \n \t2 FileSystem destFs = vm . getVolumeByPath ( dest ) . getFileSystem ( ) ; \n \n \t2 destFs . create ( dest ) . close ( ) ; \n \n <ect>
\t4 userCons . setAccessible ( true ) ; \n \n \t4 Object user = userCons . newInstance ( name , kerbAuthMethod , null ) ; \n \n \t4 subject . getPrincipals ( ) . add ( ( Principal ) user ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 else \n \n \t5 logger . debug ( <string_literal> + sstable . getFilename ( ) ) ; } \n \n \t3 catch ( IOException e ) \n \n \t3 { \n \n <ect>
\t3 pstmtUpdate . setString ( <number_literal> , broadcastDomainRange ) ; \n \n \t3 pstmtUpdate . setString ( <number_literal> , <string_literal> ) ; \n \n \t3 zoneName = zoneName + <string_literal> ; \n \n \t3 pstmtUpdate . setString ( <number_literal> , zoneName ) ; \n \n <ect>
\t3 s_logger . warn ( <string_literal> + vpc + <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 <comment> \n \n \t2 if ( ! cleanupVpcResources ( vpc . getId ( ) , caller , callerUserId ) ) { \n \n <ect>
\t2 if ( event instanceof ZWaveBarrierOperatorValueEvent ) { \n \n \t3 barrierOperatorState = ( ( ZWaveBarrierOperatorValueEvent ) event ) . getBarrierState ( ) ; \n \n \t3 if ( converter == null ) { \n \n \t4 converter = this . getStateConverter ( item , barrierOperatorState . getLabel ( ) ) ; } } \n \n <ect>
\t2 producer . send ( outbound [ 0 ] ) ; \n \n \t2 producer . send ( outbound [ 1 ] ) ; \n \n \t2 commitTx ( ) ; \n \n \t2 LOG . info ( <string_literal> + outbound [ 0 ] ) ; \n \n <ect>
\t4 _log . error ( e , e ) ; \n \n \t4 portletRequestDispatcher = portletContext . getRequestDispatcher ( \n \n \t5 <string_literal> ) ; \n \n \t4 if ( portletRequestDispatcher == null ) { \n \n <ect>
\t1 public static interface MyCustomValidationGroup { } \n \n \t1 @ PermitAll \n \n \t1 @ POST ( <string_literal> ) \n \n \t1 public void createPOJOWithoutAnnotation ( POJO myPojo ) { \n \n <ect>
\t3 { \n \n \t4 cleanupAndRollOver ( ) ; } \n \n \t3 catch ( IOException ioe ) \n \n \t3 { \n \n <ect>
\t3 in = new BufferedReader ( new InputStreamReader ( client . getInputStream ( ) ) ) ; \n \n \t3 out = new DataOutputStream ( client . getOutputStream ( ) ) ; \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t2 } catch ( UnknownHostException e ) { \n \n <ect>
\t2 state = MergeState . COMPLETE ; \n \n \t1 } else if ( hosted == total ) { \n \n \t2 if ( info . isDelete ( ) ) { \n \n \t2 if ( ! lowerSplit ) \n \n <ect>
\t3 fileExtracted . append ( entry . getMetadata ( ) . getName ( ) ) . append ( <string_literal> ) . append ( entry . getMetadata ( ) . getPathDisplay ( ) ) . append ( <string_literal> ) ; } \n \n \t2 exchange . getIn ( ) . setHeader ( DropboxResultHeader . FOUND_FILES . name ( ) , fileExtracted . toString ( ) ) ; \n \n \t2 exchange . getIn ( ) . setBody ( result . getFound ( ) ) ; \n \n <ect>
\t2 if ( server != null ) { \n \n \t3 try { \n \n \t4 server . stop ( ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t2 sendSpans ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 return Collections . emptyList ( ) ; } \n \n \t3 return properties . getObjects ( ) ; } \n \n \t2 <comment> \n \n \t2 final String objectId = getConfiguration ( ) . getContentObjectId ( ) ; \n \n <ect>
\t2 if ( isInbound ) { \n \n \t3 Hash h = tunnel . get ( tunnel . size ( ) - 1 ) ; \n \n \t3 if ( ! allowAsIBGW ( h ) ) { \n \n \t4 if ( log . shouldWarn ( ) ) \n \n <ect>
\t3 return true ; \n \n \t2 } catch ( ConfigurationException e ) { \n \n \t3 throw new ConfigurationException ( e . getMessage ( ) ) ; \n \n \t2 } catch ( ExecutionException e ) { \n \n <ect>
\t3 } else { \n \n \t4 for ( String text : descriptionText ) { \n \n \t5 s_logger . info ( <string_literal> + text ) ; } } \n \n \t2 } else { \n \n <ect>
\t3 default : \n \n \t4 buffered = false ; \n \n \t4 break ; } \n \n \t2 if ( buffered ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 result . setMostActiveStreams ( mostActiveStreamsMapper . execute ( null ) ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 result . setMostViewedStreams ( mostViewedStreamsMapper . execute ( null ) ) ; \n \n <ect>
\t4 for ( EventHandler < T > h : reverseHandler ) { \n \n \t5 try { \n \n \t6 h . rollback ( ) ; \n \n \t5 } catch ( Exception ex ) { \n \n <ect>
\t2 Logger . warning ( <string_literal> + curr_mount_point + <string_literal> ) \n \n \t2 else : \n \n \t2 Logger . warning ( <string_literal> + str ( curr_mount_point ) ) \n \n \t1 if may_manage_this_dir : \n \n <ect>
\t3 final ServiceOfferingVO off = _serviceOfferingDao . findByUuid ( offUUID ) ; \n \n \t3 if ( off != null ) { \n \n \t4 _internalLbVmOfferingId = off . getId ( ) ; \n \n \t3 } else { \n \n <ect>
\t2 if ( resultConfig != null ) { \n \n \t3 try { \n \n \t4 return objectFactory . buildResult ( resultConfig , invocationContext . getContextMap ( ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testResolveDepth1 ( ) { \n \n \t2 Document doc = getAsDOM ( <string_literal> ) ; \n \n <ect>
\t2 node_direct_memory = druid_env_config [ \n \n \t3 format ( 'druid . { node_type_lowercase } . jvm . direct . memory' ) ] , \n \n \t2 node_jvm_opts = druid_env_config [ format ( 'druid . { node_type_lowercase } . jvm . opts' ) ] ) \n \n \t2 ) \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName , driver ) ; \n \n \t1 String replDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String replDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t5 @ SuppressWarnings ( <string_literal> ) \n \n \t5 Message < String > item = ( Message < String > ) queue . poll ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t5 result & = item != null ; \n \n \t5 if ( ! result ) { \n \n <ect>
\t7 String path = files [ i ] . getCanonicalPath ( ) ; \n \n \t7 WebAppStarter . startWebApp ( ctx , server , warName , path ) ; \n \n \t7 pluginWars . get ( appName ) . add ( warName ) ; } \n \n \t5 } catch ( IOException ioe ) { \n \n <ect>
\t2 LOG . debug ( <string_literal> + CSV_JOINER . join ( entityIDs ) ) ; } \n \n \t1 return store . put ( entities ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 execute ( <string_literal> , 1 , 0 , <number_literal> , 1 ) ; \n \n \t3 execute ( <string_literal> , 1 , <number_literal> , <number_literal> , <number_literal> ) ; \n \n \t3 execute ( <string_literal> , <number_literal> , 1 , <number_literal> , 1 ) ; \n \n \t3 execute ( <string_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> ) ; \n \n <ect>
\t2 if ( closable != null ) { \n \n \t3 try { \n \n \t4 closable . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 return null ; \n \n \t3 DestEntry rv = sl . get ( key ) ; \n \n \t3 return rv ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
<comment> \n \n \t1 protected boolean enoughRequiredAttributesAvailableToProcess ( final Map < String , Object > principalAttributes , final Map < String , Set < String > > requiredAttributes ) { \n \n \t2 if ( principalAttributes . isEmpty ( ) && ! requiredAttributes . isEmpty ( ) ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 for ( final AWSCredentialsProvider p : this . chain ) { \n \n \t3 AWSCredentials c ; \n \n \t3 try { \n \n <ect>
\t6 + <string_literal> ) ; } \n \n \t3 else if ( osType != MAC ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t3 { \n \n \t4 presence . publishPresenceStatus ( status , <string_literal> ) ; } \n \n \t3 catch ( IllegalArgumentException e1 ) \n \n \t3 { \n \n <ect>
\t5 <string_literal> ) ; \n \n \t4 paths . add ( pathFromYarnURL ) ; \n \n \t4 classPathBuilder . append ( <string_literal> ) . append ( File . pathSeparator ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 final PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec ( bytes ) ; \n \n \t3 final KeyFactory factory = KeyFactory . getInstance ( this . algorithm ) ; \n \n \t3 return factory . generatePrivate ( privSpec ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t4 <comment> \n \n \t4 coordAction . setStatus ( CoordinatorAction . Status . RUNNING ) ; \n \n \t4 coordAction . decrementAndGetPending ( ) ; } \n \n \t3 else { \n \n <ect>
\t1 authResult = getSecurityManager ( ) . authenticate ( authentication ) ; \n \n \t1 } catch ( UnauthorisedException e ) { \n \n \t1 <comment> \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 break ; } \n \n \t3 catch ( ConcurrentModificationException e ) { \n \n \t4 LOG . warn ( <string_literal> ) ; } } \n \n \t2 int numberOfInitialCheckpoints = initialCheckpoints . size ( ) ; \n \n <ect>
\t4 { \n \n \t5 if ( e instanceof ObjectCheckException ) \n \n \t5 { \n \n \t6 throw ( ObjectCheckException ) e ; } \n \n <ect>
\t5 <comment> \n \n \t5 boolean force = this . fullReload || ( errorCount != 0 ) && ( failures != 0 ) && ( ( failures % errorCount ) == 0 ) ; \n \n \t5 boolean incremental = ( ! force && loadTime != null && dataVersion != null ) ; \n \n \t5 String uri = getUri ( incremental ) ; \n \n <ect>
\t4 clientId = webContext . getRequestParameter ( <string_literal> ) ; } \n \n \t3 if ( client instanceof OAuth20Client || client instanceof OidcClient ) { \n \n \t4 LOGGER . debug ( <string_literal> ) ; \n \n \t4 clientId = webContext . getRequestParameter ( OAuth20Configuration . STATE_REQUEST_PARAMETER ) ; } } \n \n <ect>
\t2 File binaryFile = new File ( bundle , prefix + <string_literal> ) ; \n \n \t2 File sourceFile = new File ( bundle , prefix + <string_literal> ) ; \n \n \t2 File javadocFile = new File ( bundle , prefix + <string_literal> ) ; \n \n \t2 File pomFile = new File ( bundle , <string_literal> ) . getAbsoluteFile ( ) ; \n \n <ect>
\t3 setupColNameMaps ( ) ; \n \n \t3 FilterExtractor filterFinder = new PartitionFilterExtractor ( loFilter . getFilterPlan ( ) , \n \n \t5 getMappedKeys ( partitionKeys ) ) ; \n \n \t3 filterFinder . visit ( ) ; \n \n <ect>
\t4 future . get ( ) ; \n \n \t3 } catch ( InterruptedException e1 ) { \n \n \t4 logger . warn ( <string_literal> , e1 ) ; \n \n \t3 } catch ( ExecutionException e1 ) { \n \n <ect>
\t2 Revision r ; \n \n \t2 try { \n \n \t3 r = Revision . fromString ( checkNotNull ( checkpoint ) ) ; \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t2 ConfigurePortCommand cmd = new ConfigurePortCommand ( UUID . fromString ( nic . getUuid ( ) ) , UUID . fromString ( BroadcastDomainType . getValue ( network . getBroadcastUri ( ) ) ) , context \n \n \t4 . getAccount ( ) . getAccountName ( ) , nic . getMacAddress ( ) ) ; \n \n \t2 ConfigurePortAnswer answer = ( ConfigurePortAnswer ) agentManager . easySend ( controller . getHostId ( ) , cmd ) ; \n \n \t2 if ( answer == null || ! answer . getResult ( ) ) { \n \n <ect>
\t2 String sinkName = iter . next ( ) ; \n \n \t2 Context sinkContext = sinkContextMap . get ( sinkName . trim ( ) ) ; \n \n \t2 if ( sinkContext == null ) { \n \n \t2 iter . remove ( ) ; \n \n <ect>
\t1 clientPortString = os . getenv ( <string_literal> ) \n \n \t1 if ( clientPortString is None ) : \n \n \t2 raise Exception ( <string_literal> ) \n \n \t1 clientPort = int ( clientPortString ) \n \n <ect>
\t6 throw new RuntimeException ( e ) ; } } \n \n \t3 } ) ; \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 broker . stop ( ) ; \n \n <ect>
\t2 if ( log ) { \n \n \t3 options . logger ( new org . iq80 . leveldb . Logger ( ) { \n \n \t4 @ Override \n \n \t4 public void log ( String message ) { \n \n <ect>
\t2 } catch ( CloudRuntimeException ex ) { \n \n \t3 return false ; } } \n \n \t1 @ Override \n \n \t1 public boolean deletePhysicalDisk ( String uuid , KVMStoragePool pool , Storage . ImageFormat format ) { \n \n <ect>
\t1 if ( deallocOneSecond ) { \n \n \t1 a . deallocate ( initial [ <number_literal> ] ) ; } \n \n \t1 a . deallocate ( initial [ 0 ] ) ; \n \n \t1 a . deallocate ( initial [ <number_literal> ] ) ; \n \n <ect>
\t3 if ( ! modified ) { \n \n \t4 for ( TypeVariable var : unsolved ) { \n \n \t5 if ( var . type ( ) == null && var . approx ( ) == ClassHierarchy . v ( ) . R0_127 ) { \n \n \t6 if ( DEBUG ) { \n \n <ect>
\t6 pstmt . setLong ( 1 , accountId ) ; \n \n \t6 pstmt . setLong ( <number_literal> , dataCenterId ) ; \n \n \t6 ResultSet userVmSet = pstmt . executeQuery ( ) ; \n \n \t6 if ( ! userVmSet . next ( ) ) { \n \n <ect>
<comment> \n \n \t1 public static EnumeratedNameList exists ( ContentName childName , ContentName prefixKnownToExist , CCNHandle handle ) throws IOException { \n \n \t2 if ( Log . isLoggable ( Log . FAC_SEARCH , Level . INFO ) ) \n \n <ect>
\t5 break ; \n \n \t4 return j ; \n \n \t3 } catch ( InterruptedException ie ) { } } \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 IRealization realization = registry . getRealization ( entry . getType ( ) , entry . getRealization ( ) ) ; \n \n \t3 if ( realization != null ) { \n \n \t4 projectCache . realizations . add ( realization ) ; \n \n \t3 } else { \n \n <ect>
\t4 throw new RuntimeException ( <string_literal> ) ; } \n \n \t3 properties . setProperty ( <string_literal> + smtpProtocol + <string_literal> , user ) ; \n \n \t3 String password = ERXProperties . stringForKeyWithDefault ( <string_literal> + contextSuffix , ERXProperties . stringForKey ( <string_literal> ) ) ; \n \n \t3 if ( password == null || password . length ( ) == 0 ) { \n \n <ect>
\t5 FileStore . appendTaskToFile ( doneFileName , tasksToDelete . map { it . text } , eol ) \n \n \t5 removeAll ( tasksToDelete ) \n \n \t5 notifyTasklistChanged ( todoFilename , null , true ) \n \n \t4 } catch ( e : Exception ) { \n \n <ect>
\t1 protected void startInternal ( ) { } \n \n \t1 @ Override \n \n \t1 public void stop ( ) { \n \n \t2 synchronized ( this . lifecycleMonitor ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 ActiveMQDestination destination = control . getDestination ( ) ; \n \n \t2 try { \n \n \t3 getRegion ( destination ) . processConsumerControl ( consumerExchange , control ) ; \n \n \t2 } catch ( JMSException jmse ) { \n \n <ect>
\t3 machinePiece = sb . toString ( ) . hashCode ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n \t3 <comment> \n \n \t3 machinePiece = ( new SecureRandom ( ) . nextInt ( ) ) ; \n \n <ect>
\t5 declarationWithoutCommentBuffer . setLength ( 0 ) ; } \n \n \t4 else { \n \n \t5 declarationWithoutCommentBuffer . append ( token ) ; } } } \n \n \t2 catch ( NoSuchElementException e ) { \n \n <ect>
\t2 dbConn . commit ( ) ; \n \n \t1 } catch ( SQLException e ) { \n \n \t2 LOG . error ( <string_literal> + \n \n \t2 e . getMessage ( ) ) ; \n \n <ect>
\t1 LOGGER . info ( <string_literal> ) ; \n \n \t1 executorService . shutdown ( ) ; \n \n \t1 try { \n \n \t1 if ( ! executorService . awaitTermination ( <number_literal> , TimeUnit . MILLISECONDS ) ) { \n \n <ect>
\t2 if ( objectToSyncToRepository . hasListener ( backupListener ) ) { \n \n \t3 return ; } \n \n \t2 if ( objectToSyncToRepository . isSaved ( ) ) { \n \n \t3 if ( Log . isLoggable ( Log . FAC_IO , Level . INFO ) ) { \n \n <ect>
\t4 shouldNeverHappen ( info . txnId , info . extLockId , info . intLockId ) ; } \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t4 dbConn . commit ( ) ; \n \n \t4 response . setState ( LockState . WAITING ) ; \n \n <ect>
\t7 + prettyString ( doc ) ) ; } \n \n \t2 testConsistantSchema ( doc ) ; \n \n \t2 <comment> \n \n \t2 doc = getAsDOM ( <string_literal> ) ; \n \n <ect>
\t3 } else { \n \n \t4 result = method . invoke ( resource , params ) ; } \n \n \t2 } catch ( InvocationTargetException e ) { \n \n \t3 Throwable t = e . getTargetException ( ) ; \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , service ) ; \n \n \t2 final String renewParam = casProperties . getSso ( ) . isRenewAuthnEnabled ( ) \n \n \t3 ? context . getRequestParameters ( ) . get ( CasProtocolConstants . PARAMETER_RENEW ) \n \n \t3 : StringUtils . EMPTY ; \n \n <ect>
\t3 writer . close ( ) ; } \n \n \t2 catch ( FileNotFoundException e ) { \n \n \t3 log . warn ( <string_literal> , e ) ; } \n \n \t2 catch ( IOException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public VirtualMachineMO findVmOnHyperHost ( String name ) throws Exception { \n \n \t2 int key = getCustomFieldKey ( <string_literal> , CustomFieldConstants . CLOUD_VM_INTERNAL_NAME ) ; \n \n \t2 if ( key == 0 ) { \n \n <ect>
\t4 String preSharedKey = resultSet . getString ( <number_literal> ) ; \n \n \t4 try { \n \n \t5 preSharedKey = DBEncryptionUtil . decrypt ( preSharedKey ) ; \n \n \t4 } catch ( EncryptionOperationNotPossibleException ignored ) { \n \n <ect>
\t1 String service = report . getServiceName ( ) ; \n \n \t1 if ( service == null || service . isEmpty ( ) ) { \n \n \t2 throw new AmbariException ( <string_literal> + service ) ; } \n \n \t1 if ( actionMetadata . getActions ( service . toLowerCase ( ) ) . contains ( report . getRole ( ) ) ) { \n \n <ect>
\t3 ComponentRepresentation rep = null ; \n \n \t3 try { \n \n \t4 rep = ModelToRepresentation . toRepresentation ( session , component , false ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 log . error ( <string_literal> , e ) ; \n \n \t4 err = new GridGgfsHadoopCommunicationException ( e ) ; } \n \n \t3 catch ( GridException e ) { \n \n \t4 if ( ! stopping ) \n \n <ect>
\t1 <comment> \n \n \t1 scheduleRequest . setJobName ( <string_literal> + System . currentTimeMillis ( ) ) ; <comment> \n \n \t1 if ( hasInputFile ) { \n \n \t1 if ( file == null ) { \n \n <ect>
\t1 address = InetAddress . getByName ( url2 ) ; \n \n \t1 turl = isPerformNameResolution ( ) ? address . getHostName ( ) : url2 ; \n \n \t1 tip = address . getHostAddress ( ) ; \n \n \t1 } catch ( UnknownHostException e ) { \n \n <ect>
\t4 String errorString = jopenvr . JOpenVRLibrary . VR_GetVRInitErrorAsEnglishDescription ( hmdErrorStore . get ( 0 ) ) . getString ( 0 ) ; \n \n \t4 logger . info ( <string_literal> + errorString ) ; \n \n \t4 return false ; } } \n \n \t2 if ( vrCompositor == null ) { \n \n <ect>
\t4 file = new File ( path ) ; \n \n \t4 length = ( int ) file . length ( ) ; \n \n \t4 is = new FileInputStream ( file ) ; \n \n \t4 contentType = rm . contentTypeForResourceNamed ( path ) ; \n \n <ect>
\t2 try { \n \n \t3 if ( CLibrary . INSTANCE . uname ( uname ) == 0 ) { \n \n \t4 ver = new VersionHelper ( uname . getRealeaseVersion ( ) ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 val couldSetProperty = tryAppendProcessorPathProperty ( path ) \n \n \t2 if ( ! couldSetProperty ) { \n \n \t3 javaTask . addCompilerArgument ( <string_literal> ) { prevValue - > \n \n \t4 if ( prevValue != null ) \n \n <ect>
public void shouldAllowEmptyGroup ( ) { \n \n \t1 final WroModel model = loadModelFromLocation ( <string_literal> ) ; \n \n \t1 assertEquals ( 1 , new WroModelInspector ( model ) . getGroupNames ( ) . size ( ) ) ; \n \n \t1 assertTrue ( model . getGroups ( ) . iterator ( ) . next ( ) . getResources ( ) . isEmpty ( ) ) ; \n \n <ect>
\t5 final Duration delta = Duration . between ( messageTimeEnd , messageTimeStart ) ; \n \n \t5 if ( delta . toNanos ( ) / <number_literal> > readLagTime . toNanos ( ) ) { \n \n \t6 log . warn ( <string_literal> , messageTimeStart , currentTime ) ; \n \n \t5 } else { \n \n <ect>
\t4 _desiredOffset = offsetMs ; } \n \n \t2 } else { \n \n \t3 Log log = getLog ( ) ; \n \n \t3 if ( log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 <comment> \n \n \t2 if ( bean . isThreadContentionMonitoringSupported ( ) ) \n \n \t3 bean . setThreadContentionMonitoringEnabled ( true ) ; \n \n \t2 else \n \n <ect>
\t3 new StringEntity ( searchRequestBody , ContentType . APPLICATION_JSON ) ) ) ; \n \n \t2 assertNoFailures ( response ) ; \n \n \t2 numDocs = ( int ) XContentMapValues . extractValue ( <string_literal> , response ) ; \n \n \t2 assertEquals ( count , numDocs ) ; \n \n <ect>
\t10 final Collection < CasEvent > events ) { \n \n \t2 final String agent = HttpRequestUtils . getHttpServletRequestUserAgent ( request ) ; \n \n \t2 LOGGER . debug ( <string_literal> , agent ) ; \n \n \t2 final long count = events . stream ( ) . filter ( e - > e . getAgent ( ) . equalsIgnoreCase ( agent ) ) . count ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 <comment> \n \n \t4 s = root . getProperty ( ALT_URL ) ; \n \n \t4 if ( s != null ) addAltEntry ( publicURI , s . getResource ( ) . getURI ( ) ) ; } \n \n \t3 else { \n \n <ect>
logger . info ( '' ) \n \n logger . info ( 'Operation info' ) \n \n logger . info ( <string_literal> . format ( options . operation ) ) \n \n logger . info ( <string_literal> . format ( options . log ) ) \n \n <ect>
\t4 log . trace ( <string_literal> ) ; \n \n \t3 clear ( ) ; \n \n \t3 break ; \n \n \t3 default : \n \n <ect>
\t7 . createMinExpiresHeader ( SUBSCRIBE_MIN_EXPIRE ) ; } \n \n \t3 catch ( InvalidArgumentException e ) \n \n \t3 { \n \n \t4 <comment> \n \n <ect>
\t3 } catch ( InsufficientCapacityException e ) { \n \n \t4 s_logger . warn ( String . format ( <string_literal> , sourceIp . addr ( ) , getName ( ) ) , e ) ; \n \n \t4 return false ; \n \n \t3 } catch ( ConcurrentOperationException e ) { \n \n <ect>
<number_literal> final boolean credentialsProvided ) { \n \n \t2 if ( ! registeredService . getAccessStrategy ( ) . isServiceAccessAllowedForSso ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , service . getId ( ) ) ; \n \n \t3 if ( ticketGrantingTicket . getProxiedBy ( ) != null ) { \n \n <ect>
\t5 } else { \n \n \t6 logger . error ( <string_literal> ) ; \n \n \t6 state = PairingInitialisationState . FINISHED ; } \n \n \t4 } else { \n \n <ect>
\t2 url = <string_literal> + port ; \n \n \t2 LOG . info ( <string_literal> , url ) ; \n \n \t2 isRunningLatch . countDown ( ) ; \n \n \t2 if ( join ) { \n \n <ect>
\t1 public WordpressPostProducer ( WordpressEndpoint endpoint ) { \n \n \t2 super ( endpoint ) ; \n \n \t2 this . servicePosts = WordpressServiceProvider . getInstance ( ) . getService ( WordpressServicePosts . class ) ; } \n \n \t1 protected Post processInsert ( Exchange exchange ) { \n \n <ect>
\t2 int counter = 0 ; \n \n \t2 for ( final List < GenomeLoc > split : splits ) { \n \n \t3 long splitSize = IntervalUtils . intervalSize ( split ) ; \n \n \t3 double sigma = ( splitSize - idealSplitSize ) / ( 1 . 0 * idealSplitSize ) ; \n \n <ect>
\t3 long bytesPerTask = PigMapReduce . sJobConfInternal . get ( ) . getLong ( InputSizeReducerEstimator . BYTES_PER_REDUCER_PARAM , \n \n \t5 InputSizeReducerEstimator . DEFAULT_BYTES_PER_REDUCER ) ; \n \n \t3 estimatedNumReducers = ( int ) Math . ceil ( ( double ) estimatedInputSize / bytesPerTask ) ; \n \n \t3 estimatedNumReducers = Math . min ( estimatedNumReducers , InputSizeReducerEstimator . DEFAULT_MAX_REDUCER_COUNT_PARAM ) ; \n \n <ect>
\t2 if ( this . endingDateTime != null ) { \n \n \t3 final ZonedDateTime et = DateTimeUtils . zonedDateTimeOf ( this . endingDateTime ) ; \n \n \t3 if ( et != null ) { \n \n \t4 if ( ZonedDateTime . now ( ) . isAfter ( et ) ) { \n \n <ect>
<comment> \n \n \t1 private String getRemoteIp ( final RequestContext context ) { \n \n \t2 final HttpServletRequest request = WebUtils . getHttpServletRequestFromExternalWebflowContext ( context ) ; \n \n \t2 String userAddress = request . getRemoteAddr ( ) ; \n \n <ect>
private Boolean getBooleanValue ( Map < String , ? extends Object > properties , String propertyKey ) \n \n { \n \n \t1 if ( properties == null ) \n \n \t1 { \n \n <ect>
\t3 serverRandom = helloMessage . getRandom ( ) . toByteArray ( ) ; \n \n \t3 NetData . Certificate cert = helloMessage . getCertificate ( ) ; \n \n \t3 serverCertificate = NetMessageUtil . convert ( cert ) ; \n \n \t3 if ( ! serverCertificate . verifySelfSigned ( ) ) { \n \n <ect>
\t4 job . setCmd ( <string_literal> ) ; \n \n \t4 job . setDispatcher ( <string_literal> ) ; \n \n \t4 job . setCmdInfo ( <string_literal> ) ; \n \n \t4 _jobMgr . submitAsyncJob ( job , <string_literal> , i ) ; \n \n <ect>
\t1 File path = destinationFile . getParentFile ( ) ; \n \n \t1 path . mkdirs ( ) ; \n \n \t1 if ( ! path . exists ( ) || ! path . canWrite ( ) ) \n \n \t1 { \n \n <ect>
\t3 if ( numObjects < 1 ) { \n \n \t4 log . error ( <string_literal> ) ; \n \n \t4 return false ; } \n \n \t3 if ( offsetTableOffset < <number_literal> ) { \n \n <ect>
\t4 for ( InetAddress resolvedAddress : resolvedAddresses ) { \n \n \t5 InetAddress taddr = InetAddress . getByAddress ( address . getHostString ( ) , resolvedAddress . getAddress ( ) ) ; \n \n \t5 tmpList . add ( new InetSocketAddress ( taddr , address . getPort ( ) ) ) ; } \n \n \t3 } catch ( UnknownHostException ex ) { \n \n <ect>
\t3 . setCheckpoint ( true ) ; \n \n \t2 try { \n \n \t3 Option < Protos . FrameworkID > frameworkID = workerStore . getFrameworkID ( ) ; \n \n \t3 if ( frameworkID . isEmpty ( ) ) { \n \n <ect>
\t2 try { \n \n \t2 executeTests ( parallelWorkQueue , isolatedWorkQueue , failedTestResults ) ; \n \n \t2 } finally { \n \n \t2 stopwatch . stop ( ) ; \n \n <ect>
\t3 ProgressiveFuture future , GenericProgressiveFutureListener l , long progress , long total ) { \n \n \t2 try { \n \n \t3 l . operationProgressed ( future , progress , total ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t2 for ( int i = 1 ; i < = <number_literal> ; i ++ ) { \n \n \t3 Calendar nextTimeout = calendarTimeout . getNextTimeout ( previousTimeout ) ; \n \n \t3 Assert . assertNotNull ( timeZoneDisplayName , nextTimeout ) ; \n \n \t3 Assert . assertNotNull ( timeZoneDisplayName , nextTimeout . after ( previousTimeout ) ) ; \n \n <ect>
\t3 LOGGER . trace ( <string_literal> ) ; } \n \n \t2 systemProperties = getSystemProperties ( ) ; \n \n \t2 if ( systemProperties == null || systemProperties . length == 0 ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 @ Test \n \n \t1 public void test ( ) throws Exception { \n \n \t2 I2PAppContext context = I2PAppContext . getGlobalContext ( ) ; \n \n \t2 _log = context . logManager ( ) . getLog ( ConnectIT . class ) ; \n \n <ect>
\t1 protected abstract String testAlertActiveForJob ( @ Nullable MeshyClient meshClient , Job job , String previousErrorMessage ) ; \n \n \t1 @ VisibleForTesting \n \n \t1 @ Nullable \n \n \t1 protected String handleCanaryException ( Exception ex , @ Nullable String previousErrorMessage ) { \n \n <ect>
\t3 throw new RepositoryException ( e ) ; \n \n \t2 } finally { \n \n \t3 session . logout ( ) ; } \n \n \t2 if ( longNameFound ) { \n \n <ect>
\t3 d . put ( <string_literal> , _guestNetworkName ) ; \n \n \t3 cmd . setHostDetails ( d ) ; \n \n \t3 s_logger . debug ( String . format ( <string_literal> , hostDetails . toJson ( ) ) ) ; \n \n \t2 } catch ( XmlRpcException e ) { \n \n <ect>
\t4 if ( dfa . printDebug ( ) ) \n \n \t4 { \n \n \t5 if ( isLocal ) \n \n \t5 { \n \n <ect>
<comment> \n \n public class RequestTest extends TestCase { \n \n \t1 private static final Logger s_logger = Logger . getLogger ( RequestTest . class ) ; \n \n \t1 public void testSerDeser ( ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
private void removeAllRedundantNodes ( ) { \n \n \t1 try { \n \n \t1 checkRedundantNode ( <string_literal> + parent ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 final String clientId = request . getParameter ( OAuth20Constants . CLIENT_ID ) ; \n \n \t2 final Set < String > scopes = OAuth20Utils . parseRequestScopes ( request ) ; \n \n \t2 LOGGER . debug ( <string_literal> , clientId ) ; \n \n \t2 final OAuthRegisteredService registeredService = OAuth20Utils . getRegisteredOAuthServiceByClientId ( this . servicesManager , clientId ) ; \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , adaptor . getEntityId ( ) ) ; \n \n \t3 this . samlObjectSigner . encode ( assertion , service , adaptor , \n \n \t4 response , request , binding ) ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 final DaemonContext daemonContext = daemon . getDaemonContext ( ) ; \n \n \t3 final File daemonRegistryDir = daemonContext . getDaemonRegistryDir ( ) ; \n \n \t3 if ( ! new DaemonDir ( daemonRegistryDir ) . getRegistry ( ) . canRead ( ) ) { \n \n <ect>
\t1 LOG . error ( <string_literal> ) ; \n \n \t1 return ; } \n \n \t1 HashMap < String , String > contextParam = buildContextParam ( ) ; \n \n \t1 hdfsOutDir = PlaceholderUtil . replaceVariables ( hdfsOutDir , contextParam ) ; \n \n <ect>
\t1 public void setValues ( String name , Value [ ] values ) { \n \n \t2 try { \n \n \t3 tree . setProperty ( PropertyStates . createProperty ( name , Arrays . asList ( values ) ) ) ; \n \n \t2 } catch ( RepositoryException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 String configuredConnection = ( String ) config . get ( <string_literal> ) ; \n \n \t3 if ( StringUtils . isNotBlank ( configuredConnection ) ) { \n \n \t4 connectionString = configuredConnection ; \n \n <ect>
\t6 String data = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( String . class , body ) ; \n \n \t7 log . debug ( <string_literal> ) ; \n \n \t7 log . debug ( <string_literal> ) ; \n \n <ect>
\t3 try { \n \n \t4 sink . shutdown ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 logger . error ( <string_literal> + e . getMessage ( ) , e ) ; } } \n \n <ect>
\t5 con . getConnection ( ) . setTransactionIsolation ( poolProperties . getDefaultTransactionIsolation ( ) ) ; \n \n \t5 transactionIsolation = Integer . valueOf ( poolProperties . getDefaultTransactionIsolation ( ) ) ; } \n \n \t3 } catch ( SQLException x ) { \n \n \t4 transactionIsolation = null ; \n \n <ect>
\t2 return udfMap ; } \n \n \t1 public int getQueryTimeoutSeconds ( ) { \n \n \t2 int time = Integer . parseInt ( this . getOptional ( <string_literal> , <string_literal> ) ) ; \n \n \t2 if ( time != 0 && time < = <number_literal> ) { \n \n <ect>
\t2 future . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } \n \n \t1 if ( future . size ( ) > 0 && assigned . size ( ) > 0 ) { \n \n \t2 Master . log . warn ( <string_literal> ) ; \n \n \t1 } else if ( future . size ( ) > 1 && assigned . size ( ) == 0 ) { \n \n <ect>
public void setEmployee ( er . erxtest . model . Employee value ) { \n \n \t1 takeStoredValueForKey ( value , _Paycheck . EMPLOYEE_KEY ) ; } \n \n public void setEmployeeRelationship ( er . erxtest . model . Employee value ) { \n \n <ect>
\t2 if ( session == null ) { \n \n \t3 try { \n \n \t4 resp . sendRedirect ( SAML2AuthManager . SAMLCloudStackRedirectionUrl . value ( ) ) ; \n \n \t3 } catch ( IOException ignored ) { \n \n <ect>
\t5 Query pathQuery = new TermQuery ( newAncestorTerm ( path ) ) ; \n \n \t5 compositeQuery . add ( pathQuery , BooleanClause . Occur . MUST ) ; \n \n \t5 query = compositeQuery ; \n \n \t4 } else { \n \n <ect>
\t2 FMLInterModComms . sendMessage ( <string_literal> , <string_literal> , TileEngineBase . class . getCanonicalName ( ) ) ; } \n \n \t1 @ Mod . EventHandler \n \n \t1 public void remap ( FMLMissingMappingsEvent event ) { \n \n \t2 Throwable error = null ; \n \n <ect>
\t2 this . sendMessages ( <string_literal> , new ActiveMQTopic ( <string_literal> ) , 1 ) ; \n \n \t2 MessageIdList messagesA = getConsumerMessages ( <string_literal> , consumerA ) ; \n \n \t2 MessageIdList messagesB = getConsumerMessages ( <string_literal> , consumerB ) ; \n \n \t2 LOG . info ( <string_literal> + messagesA ) ; \n \n <ect>
\t2 setAlternateResponseData ( ) ; \n \n \t2 assertion . setXPathString ( <string_literal> ) ; \n \n \t2 AssertionResult res = assertion . getResult ( jmctx . getPreviousResult ( ) ) ; \n \n \t2 log . debug ( <string_literal> , res . isError ( ) ) ; \n \n <ect>
\t3 address = HostAndPort . fromParts ( url . getHost ( ) , url . getPort ( ) ) ; } \n \n \t2 catch ( MalformedURLException e ) { \n \n \t3 <comment> \n \n \t3 throw new AssertionError ( e ) ; } \n \n <ect>
\t6 } catch ( InterruptedException e ) { \n \n \t7 <comment> \n \n \t6 continue ; \n \n \t5 } else { \n \n <ect>
\t2 LOG . error ( String . format ( <string_literal> , t ) ) ; } } \n \n \t1 for ( String shard : shardsList ) { \n \n \t2 if ( ! existingShards . contains ( shard ) ) { \n \n \t2 try { \n \n <ect>
\t2 <comment> \n \n \t2 logger . debug ( GraphUtil . labeledGraphToString ( tree ) ) ; \n \n \t2 long steinerTreeElapsedTimeMillis = System . currentTimeMillis ( ) - start ; \n \n \t2 logger . debug ( <string_literal> + tree . vertexSet ( ) . size ( ) ) ; \n \n <ect>
\t4 Answer ans = ep . sendMessage ( cmd ) ; \n \n \t4 if ( ans != null && ans . getResult ( ) ) { \n \n \t5 _uploadDao . remove ( extractJob . getId ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t1 public void processTimeout ( javax . sip . TimeoutEvent timeoutEvent ) { \n \n <ect>
\t2 if ( otherClusterStateVersion > localClusterState . version ( ) ) { \n \n \t3 rejoin ( <string_literal> + otherMaster + <string_literal> + reason + <string_literal> ) ; \n \n \t2 } else { \n \n \t3 <comment> \n \n <ect>
\t2 addRequest ( request ) ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 doNotifyAll ( ) ; \n \n <ect>
\t2 { \n \n \t2 synchronized ( ZooKeeperAnnouncer . this ) \n \n \t2 { \n \n \t3 _pendingMarkUp . add ( callback ) ; } \n \n <ect>
\t4 handler . onSuccess ( getMetadata ( ) ) ; } } \n \n \t2 catch ( Throwable e ) \n \n \t2 { \n \n \t3 connection . stop ( ) ; \n \n <ect>
\t3 return null ; } \n \n \t2 if ( expression . size ( ) != 1 ) \n \n \t3 throw new IllegalStateException ( <string_literal> ) ; \n \n \t2 Expression result = expression . pop ( ) ; \n \n <ect>
\t2 String input = <string_literal> ; \n \n \t2 mc . set ( <string_literal> , input ) ; \n \n \t2 String s = ( String ) mc . get ( <string_literal> ) ; \n \n \t2 assertTrue ( s . equals ( input ) ) ; \n \n <ect>
\t3 if ( httpRequestRemoteAddressPattern . matcher ( request . getRemoteAddr ( ) ) . find ( ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , bypassProperties . getHttpRequestRemoteAddress ( ) , request . getRemoteAddr ( ) ) ; \n \n \t4 return true ; } \n \n \t3 if ( httpRequestRemoteAddressPattern . matcher ( request . getRemoteHost ( ) ) . find ( ) ) { \n \n <ect>
private int showFunctions ( Hive db , ShowFunctionsDesc showFuncs ) throws HiveException { \n \n \t1 <comment> \n \n \t1 Set < String > funcs = null ; \n \n \t1 if ( showFuncs . getPattern ( ) != null ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 int fetchLimit = HiveConf . getIntVar ( conf , HiveConf . ConfVars . HIVELIMITOPTMAXFETCH ) ; \n \n \t1 if ( globalLimitCtx . isEnable ( ) && globalLimitCtx . getGlobalLimit ( ) > fetchLimit ) { \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 private void rewireStdStreams ( ) \n \n \t1 { \n \n \t2 logConsole ( new NonCloseableOutputStream ( System . err ) ) ; \n \n <ect>
\t6 <comment> \n \n \t6 Object faultHeader = response . removeHeader ( JmsConstants . JMS_TRANSFER_FAULT ) ; \n \n \t6 if ( faultHeader != null ) { \n \n \t7 boolean isFault = exchange . getContext ( ) . getTypeConverter ( ) . tryConvertTo ( boolean . class , faultHeader ) ; \n \n <ect>
\t3 return false ; \n \n \t2 return true ; } \n \n \t1 public int [ ] positionToSegmentLocation ( long position ) { \n \n \t2 int [ ] blockLocation = new int [ <number_literal> ] ; \n \n <ect>
\t2 public void reasonerTaskStopped ( ) { \n \n \t3 logger . info ( <string_literal> ) ; } \n \n \t2 @ Override \n \n \t2 public void reasonerTaskProgressChanged ( int value , int max ) { \n \n <ect>
\t4 { \n \n \t5 logger . error ( <string_literal> + phone ) ; } } } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t2 tags . add ( new NiciraNvpTag ( <string_literal> , command . getOwnerName ( ) ) ) ; \n \n \t2 final long networkId = command . getNetworkId ( ) ; \n \n \t2 s_logger . debug ( <string_literal> + logicalSwitchUuid + <string_literal> + l2GatewayServiceUuid + <string_literal> + vlanId + <string_literal> + networkId ) ; \n \n \t2 final NiciraNvpApi niciraNvpApi = niciraNvpResource . getNiciraNvpApi ( ) ; \n \n <ect>
\t6 sub . setStaticallyIncluded ( true ) ; \n \n \t6 try { \n \n \t7 addSubscription ( sub ) ; \n \n \t6 } catch ( IOException e ) { \n \n <ect>
\t1 for ( Runnable hook : shutdownHooksByStage . get ( stage ) ) { \n \n \t2 try { \n \n \t2 hook . run ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t4 dlna = renderer . getRootFolder ( ) ; \n \n \t3 } else { \n \n \t4 dlna = PMS . getGlobalRepo ( ) . get ( searchId ) ; } \n \n \t3 if ( dlna == null ) { \n \n <ect>
\t7 break ; \n \n \t6 case <number_literal> : \n \n \t7 <comment> \n \n \t7 if ( p_protocol_read . getProperty ( <string_literal> ) . equals ( <string_literal> ) ) { \n \n <ect>
\t2 final Service service = wsFederationCookieManager . retrieve ( context ) ; \n \n \t2 LOGGER . debug ( <string_literal> , service ) ; \n \n \t2 final HttpServletRequest request = WebUtils . getHttpServletRequestFromExternalWebflowContext ( context ) ; \n \n \t2 final String wResult = request . getParameter ( WRESULT ) ; \n \n <ect>
\t2 try { \n \n \t3 niciraNvpApi . deleteLogicalSwitchPort ( logicalSwitchUuid , lSwitchPort . getUuid ( ) ) ; \n \n \t2 } catch ( NiciraNvpApiException exceptionDeleteLSwitchPort ) { \n \n \t3 s_logger . error ( <string_literal> + lSwitchPort . getUuid ( ) + <string_literal> + lSwitchPort . getDisplayName ( ) + <string_literal> + logicalSwitchUuid + <string_literal> + exceptionDeleteLSwitchPort . getMessage ( ) ) ; } \n \n <ect>
\t4 wantedMetadata . put ( <string_literal> , null ) ; \n \n \t4 Map receivedMetadata = stores . get ( bitstream . getStoreNumber ( ) ) . about ( bitstream , wantedMetadata ) ; \n \n \t4 <comment> \n \n \t4 if ( MapUtils . isEmpty ( receivedMetadata ) ) { \n \n <ect>
\t3 TimeUnit . SECONDS . sleep ( 1 ) ; \n \n \t3 consumerMap . get ( <string_literal> + 1 + <string_literal> + i ) . close ( ) ; \n \n \t3 TimeUnit . SECONDS . sleep ( 1 ) ; \n \n \t3 consumerMap . get ( <string_literal> + 0 + <string_literal> + i ) . close ( ) ; } \n \n <ect>
\t3 try { \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t4 executeSQL ( dropViewSql ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t2 val correctErrorTypes = configuration . get ( Kapt3ConfigurationKeys . CORRECT_ERROR_TYPES ) == <string_literal> \n \n \t2 val mapDiagnosticLocations = configuration . get ( Kapt3ConfigurationKeys . MAP_DIAGNOSTIC_LOCATIONS ) == <string_literal> \n \n \t2 if ( isVerbose ) { \n \n \t3 logger . info ( <string_literal> ) \n \n <ect>
\t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . CLIENT_ID ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , grantType ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . SECRET ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 Object implementor = new GreeterImpl ( ) ; \n \n \t2 String address = <string_literal> + port + <string_literal> ; \n \n \t2 endpoint = Endpoint . publish ( address , implementor ) ; \n \n <ect>
\t5 throw ex ; \t5 } } } \n \n \t2 <comment> \n \n \t2 s_logger . debug ( <string_literal> + network + <string_literal> ) ; \n \n \t2 if ( ! reprogramNetworkRules ( network . getId ( ) , UserContext . current ( ) . getCaller ( ) , network ) ) { \n \n <ect>
\t1 public boolean databaseContextShouldHandleDatabaseException ( EODatabaseContext databaseContext , Throwable throwable ) { \n \n \t2 if ( ! reportingError . canEnter ( databaseContext ) ) return true ; \n \n \t2 try { \n \n <ect>
\t3 <comment> \n \n \t3 CallContext . current ( ) . putContextParameter ( SnapshotPolicy . class , policy . getUuid ( ) ) ; \n \n \t3 return policy ; \n \n \t2 } else { \n \n <ect>
\t4 if ( sipProvider . registerUsingNextAddress ( ) ) \n \n \t5 return ; } \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t3 @ Override \n \n \t3 public void failed ( final Exception ex ) { \n \n \t4 if ( ex instanceof ResourceIOException ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 int errorCode = - 1 ; \n \n \t3 try { \n \n \t4 errorCode = Integer . parseInt ( parse ? TextParseUtil . translateVariables ( error , stack ) : error ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 holeCheck ++ ; } } } } \n \n \t1 private void attemptHoleFilling ( long hole ) { \n \n \t2 <comment> \n \n \t2 if ( Log . isLoggable ( Log . FAC_PIPELINE , Level . INFO ) ) \n \n <ect>
\t2 } catch ( IOException ioException ) { \n \n \t3 logger . error ( <string_literal> , ioException ) ; \n \n \t3 connected = false ; \n \n \t2 } catch ( Exception exception ) { \n \n <ect>
\t3 buf . append ( <string_literal> ) ; } \n \n \t2 buf . append ( <string_literal> ) ; \n \n \t2 end = System . currentTimeMillis ( ) ; \n \n \t2 if ( log . shouldWarn ( ) ) \n \n <ect>
\t4 if ( ! _disconLogged ) { \n \n \t5 _log . logAlways ( Log . WARN , <string_literal> ) ; \n \n \t5 _disconLogged = true ; } \n \n \t3 } else { \n \n <ect>
\t4 datastoreDiskPath = dsMo . getDatastorePath ( vmdkPath + <string_literal> ) ; } \n \n \t2 } else { \n \n \t3 datastoreDiskPath = VmwareStorageLayoutHelper . syncVolumeToVmDefaultFolder ( dcMo , vmMo . getName ( ) , dsMo , volumeTO . getPath ( ) , VmwareManager . s_vmwareSearchExcludeFolder . value ( ) ) ; } \n \n \t2 if ( ! dsMo . fileExists ( datastoreDiskPath ) ) { \n \n <ect>
\t2 this . context = context ; \n \n \t2 this . dataset = dataset ; \t1 <comment> \n \n \t2 if ( input == null ) \n \n \t2 { \n \n <ect>
\t1 public long getVersion ( ) \t6 { return version ; } \n \n \t1 <comment> void setActiveDataset ( DatasetGraphTxn activedsg ) { \n \n \t2 this . activedsg = activedsg ; \n \n \t2 if ( activedsg . getTransaction ( ) != this ) \n \n <ect>
\t4 reportMethod . invoke ( ConsoleProxy . context , gsonLoadInfo ) ; \n \n \t3 } catch ( IllegalAccessException e ) { \n \n \t4 s_logger . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t3 } catch ( InvocationTargetException e ) { \n \n <ect>
def receive ( self ) : \n \n \t1 try : \n \n \t1 msg = self . ws . receive ( ) \n \n \t1 msg = str ( msg ) if msg is not None else msg \n \n <ect>
\t5 result = newEnTranscription + gerundEndingTrans ; \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t4 } else { <comment> \n \n \t5 result = otherLanguageTranscription ; \n \n <ect>
\t3 return found ; \n \n \t2 if ( found . tag < = DOUBLE && req . tag < = DOUBLE ) \n \n \t3 return typeError ( pos , diags . fragment ( <string_literal> ) , found , req ) ; \n \n \t2 if ( found . isSuperBound ( ) ) { \n \n <ect>
\t2 if ( mDevice instanceof OLEDBricklet ) { \n \n \t3 ( ( OLEDBricklet ) mDevice ) . simpleGauge ( min , max , value ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 return downloadImage ( attachment , width , height , quality , context ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 m_listeners . add ( l ) ; } } } \n \n \t1 public void removeListener ( MsgListener l ) { \n \n \t2 synchronized ( m_listeners ) { \n \n \t3 if ( m_listeners . remove ( l ) ) { \n \n <ect>
\t3 ActionInvocation invocation = new ActionInvocation ( action ) ; \n \n \t3 try { \n \n \t4 invocation . setInput ( <string_literal> , <string_literal> ) ; \n \n \t3 } catch ( InvalidValueException ex ) { \n \n <ect>
protected Table resolveTable ( CompactionInfo ci ) throws MetaException { \n \n \t1 try { \n \n \t1 return rs . getTable ( ci . dbname , ci . tableName ) ; \n \n \t1 } catch ( MetaException e ) { \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 transportService . connectToNode ( masterNode ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 assertThat ( client ( master ) . admin ( ) . cluster ( ) . prepareReroute ( ) . get ( ) . getState ( ) . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <number_literal> ) ) ; } \n \n \t1 public void testDoNotAllowStaleReplicasToBePromotedToPrimary ( ) throws Exception { \n \n \t2 createStaleReplicaScenario ( ) ; \n \n <ect>
\t2 Thread . sleep ( <number_literal> ) ; \n \n \t2 for ( CountDownFuture start : pending_starts ) { \n \n \t3 assertFalse ( start . completed ( ) ) ; } \n \n \t2 <comment> \n \n <ect>
\t3 return Response . status ( Response . Status . BAD_REQUEST ) . entity ( e . getMessage ( ) ) . build ( ) ; \n \n \t2 } catch ( InsufficientPrivilegesException e ) { \n \n \t3 return Response . status ( Response . Status . UNAUTHORIZED ) . entity ( e . getMessage ( ) ) . build ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 final JsonSchema jsonSchema = StructrSchema . createFromDatabase ( StructrApp . getInstance ( ) ) ; \n \n \t3 schema . setProperty ( new StringProperty ( <string_literal> ) , jsonSchema . toString ( ) ) ; \n \n \t3 resultCount = 1 ; \n \n \t2 } catch ( URISyntaxException ex ) { \n \n <ect>
private var collector : TableFunctionCollector [ _ ] = _ \n \n override def open ( parameters : Configuration ) : Unit = { \n \n \t1 LOG . debug ( s <string_literal> ) \n \n \t1 val clazz = compile ( getRuntimeContext . getUserCodeClassLoader , collectorName , collectorCode ) \n \n <ect>
<comment> \n \n \t1 public String executeApiCommand ( String command ) { \n \n \t2 logger . debug ( <string_literal> , command ) ; \n \n \t2 if ( ! clientValid ( ) && StringUtils . isBlank ( command ) ) { \n \n <ect>
\t3 result . setSuccessIsSet ( true ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t1 dir_path = HdfsResourceProvider . parse_path ( dir_path ) \n \n \t1 if dir_path in ignored_dfs_dirs : \n \n \t2 Logger . info ( <string_literal> + dir_path + <string_literal> ) \n \n \t2 return \n \n <ect>
\t2 values . add ( deserialize ( valueAsByte ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t2 logger . warn ( <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t2 for ( String part : parts ) { \n \n \t3 log . info ( <string_literal> + part + <string_literal> ) ; \n \n \t3 int pos = traceOutput . indexOf ( part ) ; \n \n \t3 if ( - 1 == pos ) { \n \n <ect>
\t2 } catch ( final XmlRpcException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return new FenceAnswer ( command , false , e . getMessage ( ) ) ; \n \n \t2 } catch ( final XenAPIException e ) { \n \n <ect>
\t3 if ( ! dicts . get ( 0 ) . getDictionaryObject ( ) . equals ( dicts . get ( i ) . getDictionaryObject ( ) ) ) { \n \n \t4 identicalSourceDicts = false ; \n \n \t4 break ; } } \n \n \t2 if ( identicalSourceDicts ) { \n \n <ect>
\t2 try { \n \n \t3 rowService . delete ( key ) ; \n \n \t3 rowService = null ; \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t2 String result = <string_literal> ; \n \n \t2 try { \n \n \t3 result = creativeCommonsService . fetchLicenseRDF ( license_doc ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 m_Socket = new DatagramSocket ( ) ; \n \n \t5 m_LocalPort = m_Socket . getLocalPort ( ) ; \n \n \t5 m_LocalAddress = m_Socket . getLocalAddress ( ) ; } } \n \n <ect>
\t6 log . info ( <string_literal> + rsrc4 ) ; \n \n \t6 log . info ( <string_literal> + rsrc5 ) ; \n \n \t6 log . info ( <string_literal> + rsrc6 ) ; \n \n \t6 log . info ( <string_literal> + rsrc7 ) ; \n \n <ect>
\t5 logException ( caller , iex , sources ) ; \n \n \t4 } finally { \n \n \t5 executorService . shutdown ( ) ; } \n \n \t3 } else { \n \n <ect>
public String review ( ) { \n \n \t1 return ( String ) storedValueForKey ( _Review . REVIEW_KEY ) ; } \n \n public void setReview ( String value ) { \n \n <ect>
@ Test \n \n public void testPackUnPackAgainstLemire ( ) throws IOException { \n \n \t1 for ( Packer pack : Packer . values ( ) ) { \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n <ect>
\t1 public < T > T forwardTo ( final Class < T > type ) { \n \n \t2 return proxifier . proxify ( type , new MethodInvocation < T > ( ) { \n \n \t3 public Object intercept ( T proxy , Method method , Object [ ] args , SuperMethod superMethod ) { \n \n \t4 try { \n \n <ect>
<comment> \n \n public class V20150401_2__Insert_Default_Values implements SpringJdbcMigration { \n \n \t1 private static final Logger LOG = LoggerFactory . getLogger ( V20150401_2__Insert_Default_Values . class ) ; \n \n \t1 public void migrate ( JdbcTemplate jdbcTemplate ) throws Exception { \n \n <ect>
\t5 if ( keepAlive ( ) ) { \n \n \t6 break ; } } \n \n \t4 reportLeasOwnerShipAndDuration ( connection ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 SnapshotInfo snapshot = null ; \n \n \t2 try { \n \n \t3 snapshot = snapshotMgr . takeSnapshot ( volume ) ; \n \n \t2 } catch ( CloudRuntimeException cre ) { \n \n <ect>
\t1 public void start ( BundleContext bundleContext ) \n \n \t2 throws Exception \n \n \t1 { \n \n <ect>
\t3 msg . append ( <string_literal> ) . append ( checksumBeforeCorruption ) . append ( <string_literal> ) ; \n \n \t3 msg . append ( <string_literal> ) . append ( checksumAfterCorruption ) . append ( <string_literal> ) ; \n \n \t3 msg . append ( <string_literal> ) . append ( actualChecksumAfterCorruption ) . append ( <string_literal> ) ; \n \n \t3 msg . append ( <string_literal> ) . append ( fileToCorrupt . getFileName ( ) ) . append ( <string_literal> ) . append ( dir . fileLength ( fileToCorrupt . getFileName ( ) . toString ( ) ) ) ; \n \n <ect>
\t2 while ( shouldRun . get ( ) ) { \n \n \t2 try { \n \n \t3 operation . run ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t2 assertHits ( searchResponse . getHits ( ) , <string_literal> , <string_literal> , <string_literal> , <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 searchResponse = client ( ) . prepareSearch ( <string_literal> , <string_literal> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) ; \n \n \t2 assertHits ( searchResponse . getHits ( ) , <string_literal> , <string_literal> , <string_literal> , <string_literal> ) ; \n \n <ect>
\t4 return Optional . of ( fromJson ( expectedType , responseStream ) ) ; } \n \n \t3 <comment> \n \n \t3 return Optional . of ( fromXml ( xstream , responseStream ) ) ; \n \n \t2 } catch ( XStreamException | IOException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 private static DB db ; \n \n \t1 private static Map < String , MapDBItem > map ; \n \n \t1 public void activate ( final BundleContext bundleContext , final Map < String , Object > config ) { \n \n <ect>
\t2 if ( this . refreshHomeOnConnectFailure ) { \n \n \t4 logger . debug ( <string_literal> + getJndiName ( ) + <string_literal> , ex ) ; } \n \n <ect>
\t3 <comment> \n \n \t3 UserVmVO tmpVm = _vmDao . findById ( vm . getId ( ) ) ; \n \n \t3 if ( ! tmpVm . getState ( ) . equals ( State . Running ) ) { \n \n \t4 <comment> \n \n <ect>
\t1 public void execute ( Tuple tuple ) { \n \n \t2 <comment> \n \n \t2 MetaTuple metaTuple = ( MetaTuple ) tuple . getValue ( 0 ) ; \n \n \t2 try { \n \n <ect>
\t2 boolean result = super . configure ( name , params ) ; \n \n \t2 PublicSearch = createSearchBuilder ( ) ; \n \n \t2 PublicSearch . and ( <string_literal> , PublicSearch . entity ( ) . isPublicTemplate ( ) , SearchCriteria . Op . EQ ) ; \n \n \t2 routerTmpltName = ( String ) params . get ( <string_literal> ) ; \n \n <ect>
\t3 return getDefaultEditModeInternal ( context ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t3 String prefix = m . group ( 1 ) ; \n \n \t3 String index = m . group ( <number_literal> ) ; \n \n \t3 toBeRenamed . put ( name , createNewName ( parentNode , prefix , index ) ) ; } \n \n \t2 for ( Entry < String , String > e : toBeRenamed . entrySet ( ) ) { \n \n <ect>
\t3 dbName ) ; \n \n \t1 pm . retrieveAll ( mPrivs ) ; \n \n \t1 success = commitTransaction ( ) ; \n \n \t1 mSecurityDBList . addAll ( mPrivs ) ; \n \n <ect>
\t3 network = ip4ToIp6 ( network ) ; \n \n \t3 netmask = ip4MaskToIp6 ( netmask ) ; \n \n \t4 for ( int i = 0 ; i < network . length ; i ++ ) { \n \n <ect>
\t2 load ( event ) ; } } \n \n \t1 float secs = ( System . currentTimeMillis ( ) - startTime ) / <number_literal> . 0f ; \n \n \t1 long numDocs = queryResultSetSize ( <string_literal> ) ; \n \n \t1 LOGGER . info ( <string_literal> + secs + <string_literal> + ( iters / secs ) ) ; \n \n <ect>
\t5 LOGGER . trace ( <string_literal> , Platform . isLinux ( ) ? <string_literal> : <string_literal> ) ; \n \n \t5 isAdmin = false ; \n \n \t5 return false ; \n \n \t4 } catch ( IOException | InterruptedException e ) { \n \n <ect>
\t3 serviceAction ( request , response , \n \n \t5 getRequestMap ( request ) , getParameterMap ( request ) , \n \n \t5 getSessionMap ( request ) , getApplicationMap ( ) , \n \n \t5 portletNamespace , PortletPhase . EVENT_PHASE ) ; \n \n <ect>
\t2 <comment> \n \n \t2 final TestOlingo2ResponseHandler < ODataEntry > entryHandler = new TestOlingo2ResponseHandler < ODataEntry > ( ) ; \n \n \t2 olingoApp . create ( edm , MANUFACTURERS , null , getEntityData ( ) , entryHandler ) ; \n \n \t2 ODataEntry createdEntry = entryHandler . await ( ) ; \n \n <ect>
\t3 final FolderInfo info = watchedRoots . get ( uuid ) ; \n \n \t3 if ( info == null ) { \n \n \t4 <comment> \n \n \t4 if ( mountTarget != null ) { \n \n <ect>
\t2 String charsetString = Objects . toString ( config . get ( <string_literal> ) , null ) ; \n \n \t2 if ( isNotBlank ( charsetString ) ) { \n \n \t3 charset = charsetString ; \n \n \t2 } else { \n \n <ect>
\t3 closeConnection ( ) ; \n \n \t3 this . target = getConnectionFromDriver ( getUsername ( ) , getPassword ( ) ) ; \n \n \t3 prepareConnection ( this . target ) ; \n \n <ect>
\t2 eucaS3Client . refreshEndpoint ( ) ; \n \n \t2 return eucaS3Client . getObjectMetadata ( arg0 ) ; } \n \n \t1 } , new GetObjectMetadataRequest ( bucketName , keyName ) , REFRESH_TOKEN_RETRIES ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 public void process ( Exchange exchange ) throws Exception { \n \n \t6 Message out = exchange . getOut ( ) ; \n \n \t6 out . copyFrom ( exchange . getIn ( ) ) ; \n \n \t6 log . info ( <string_literal> + exchange . getIn ( ) . getBody ( ) ) ; \n \n <ect>
\t7 writer . key ( <string_literal> ) . value ( show_rdfs_label_first ) ; \n \n \t7 writer . endObject ( ) ; \n \n \t7 pw . print ( writer . toString ( ) ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t6 final byte upper = StringUtil . toUpperCase ( b ) ; \n \n \t6 if ( upper != 'A' && upper != 'C' && upper != 'G' && upper != 'T' ) { \n \n \t7 log . warn ( <string_literal> + bait ) ; } } \n \n \t4 } else { \n \n <ect>
\t3 mntPoint = _mountParent + File . separator + Integer . toHexString ( _random . nextInt ( Integer . MAX_VALUE ) ) ; \n \n \t3 file = new File ( mntPoint ) ; \n \n \t2 } while ( file . exists ( ) ) ; \n \n \t2 if ( ! file . mkdirs ( ) ) { \n \n <ect>
\t1 default : \n \n \t2 LOG . warn ( <string_literal> + incrementalMode ) ; \n \n \t2 break ; } \n \n \t1 LOG . info ( <string_literal> + options . getIncrementalTestColumn ( ) ) ; \n \n <ect>
\t2 int i = extForm . indexOf ( <string_literal> ) ; \n \n \t2 String jarPath = extForm . substring ( 0 , i ) ; \n \n \t2 String filePath = extForm . substring ( i + <number_literal> ) ; <comment> \n \n <ect>
\t4 _context . statManager ( ) . addRateData ( <string_literal> , handleTime , packet . getLifetime ( ) ) ; \n \n \t4 _context . statManager ( ) . addRateData ( <string_literal> , queueTime , packet . getLifetime ( ) ) ; \n \n \t4 _state = <number_literal> ; \n \n \t4 <comment> \n \n <ect>
\t1 <comment> \n \n \t1 public void flush ( ) \n \n \t1 { \n \n <ect>
\t2 if ( clientId != null ) { \n \n \t3 cf . setClientID ( clientId ) ; \n \n \t2 } else { \n \n \t3 if ( activationSpec . isDurableSubscription ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t5 return answer ; \n \n \t4 } catch ( GitAPIException e ) { \n \n \t5 if ( exception == null ) { \n \n \t6 exception = e ; } \n \n <ect>
\t3 SecurityDomainsSetupTask . INSTANCE . tearDown ( managementClient , null ) ; } } \n \n \t1 try { \n \n \t2 controller . stop ( getJoiningNodeName ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 is . close ( ) ; \n \n \t3 } catch ( IOException ex ) { \n \n \t4 Log logger = log == null ? defaultLog : log ; \n \n <ect>
\t2 try { \n \n \t3 data = new HiveLockObjectData ( new String ( curatorFramework . getData ( ) . watched ( ) . forPath ( curChild ) ) ) ; \n \n \t3 data . setClientIp ( clientIp ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 nodeWithoutPrimary = <string_literal> ; \n \n \t2 } else { \n \n \t3 nodeWithPrimary = <string_literal> ; \n \n \t3 nodeWithoutPrimary = <string_literal> ; } \n \n <ect>
public void stopBlocking ( ) { \n \n \t1 if ( exception != null ) { \n \n \t2 throw exception ; } \n \n \t1 if ( ! queuedTopologies . isEmpty ( ) ) { \n \n <ect>
\t7 try ( PreparedStatement pstmt = conn . prepareStatement ( <string_literal> ) ; ) { \n \n \t8 pstmt . setLong ( 1 , id ) ; \n \n \t8 pstmt . executeUpdate ( ) ; \n \n \t8 s_logger . debug ( <string_literal> + id + <string_literal> ) ; } } } } } \n \n <ect>
\t4 newSnapshot . setParentSnapshotPath ( null ) ; \n \n \t3 } else { \n \n \t4 newSnapshot . setParentSnapshotPath ( prevBackupUuid ) ; } \n \n \t3 s_logger . info ( <string_literal> + newSnapshot . toString ( ) ) ; \n \n <ect>
\t7 Element itemNameElement = ( Element ) itemName . item ( 0 ) ; \n \n \t7 if ( itemNameElement . getChildNodes ( ) . getLength ( ) < = 1 ) { \n \n \t8 param . put ( key , itemNameElement . getTextContent ( ) ) ; } \n \n \t6 } else { \n \n <ect>
\t2 response . close ( ) ; \n \n \t2 response = target . request ( ) . post ( Entity . entity ( baos . toByteArray ( ) , MediaType . APPLICATION_OCTET_STREAM ) ) ; \n \n \t2 response . close ( ) ; \n \n \t2 int updated = countTempFiles ( ) ; \n \n <ect>
\t2 SelectionKey key = null ; \n \n \t2 @ Override \n \n \t2 public void finalize ( ) throws Throwable { \n \n \t3 if ( key != null && key . isValid ( ) ) { \n \n <ect>
\t2 if ( clusterState . nodes ( ) . getSize ( ) < maxNumReplicas ) { \n \n \t3 ClusterState . Builder stateBuilder = ClusterState . builder ( clusterState ) ; \n \n \t3 DiscoveryNodes . Builder newNodesBuilder = DiscoveryNodes . builder ( clusterState . nodes ( ) ) ; \n \n \t3 for ( int j = 0 ; j < ( maxNumReplicas - clusterState . nodes ( ) . getSize ( ) ) ; j ++ ) { \n \n <ect>
\t3 jira_auth = requests . auth . HTTPBasicAuth ( creds [ 'jira_username' ] , creds [ 'jira_password' ] ) \n \n \t3 r = requests . post ( issue_url + <string_literal> , data = remote_link , auth = jira_auth , \n \n \t7 headers = { 'Content - Type' : 'application / json' } ) \n \n \t2 else : \n \n <ect>
\t1 for ( SpiEbeanServer server : servers ) { \n \n \t2 try { \n \n \t2 server . shutdownManaged ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 CmsImport cmsImport = new CmsImport ( importCms , report ) ; \n \n \t2 cmsImport . importData ( parameters ) ; \n \n \t2 String importScript = importedModule . getImportScript ( ) ; \n \n \t2 if ( ! CmsStringUtil . isEmptyOrWhitespaceOnly ( importScript ) ) { \n \n <ect>
\t1 private static final String CONSOLE_VIEW_ID = <string_literal> ; \n \n \t1 public static final String PROJECT_NAME_SEPARATOR = <string_literal> ; \n \n \t1 @ Override \n \n \t1 public void launch ( final ISelection selection , final String mode ) { \n \n <ect>
\t1 catalogBinder . addBinding ( ) . to ( UpdateAlertScriptPaths . class ) ; \n \n \t1 catalogBinder . addBinding ( ) . to ( FinalUpgradeCatalog . class ) ; \n \n \t1 EventBusSynchronizer . synchronizeAmbariEventPublisher ( binder ( ) ) ; } } \n \n public void executeUpgrade ( List < UpgradeCatalog > upgradeCatalogs ) throws AmbariException { \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 if ( jobExecution . getExecutionContext ( ) . get ( <string_literal> ) != null ) { \n \n \t1 String jobOutputLocation = ( String ) jobExecution . getExecutionContext ( ) . get ( <string_literal> ) ; \n \n \t1 String exitDescription = <string_literal> + jobOutputLocation ; \n \n <ect>
\t5 VmwareStorageLayoutHelper . syncVolumeToRootFolder ( dsMo . getOwnerDatacenter ( ) . first ( ) , dsMo , volumeTO . getPath ( ) , vmName , VmwareManager . s_vmwareSearchExcludeFolder . value ( ) ) ; } } \n \n \t3 return answer ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 assertEquals ( expected_list , getMessages ( ms ) ) ; \n \n \t2 LOG . info ( <string_literal> + node1 . node_id ( ) ) ; \n \n \t2 node1 . stop ( ) ; \n \n <ect>
\t3 log . debug ( <string_literal> ) ; } \n \n \t1 <comment> \n \n \t1 @ Override public void stop ( boolean cancel ) { \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public void setKeyUsed ( SessionKey key ) { \n \n \t2 if ( key != null ) \n \n <ect>
\t2 } catch ( StorageUnavailableException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( InsufficientCapacityException e ) { \n \n <ect>
\t2 if ( streamId . equals ( BatchMetaRebalance . REBALANCE_STREAM_ID ) ) { \n \n \t3 try { \n \n \t4 metaClient . rebalanceMqList ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 throw new Exception ( <string_literal> ) ; } \n \n \t2 } else { \n \n \t3 LOG . info ( <string_literal> + tokenInfo . getToken ( ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 are not correct \n \n \t1 <string_literal> <string_literal> <ect>
<comment> \n \n <ect>
\t2 String pid = null ; \n \n \t2 try { \n \n \t3 pid = LessBytes . toString ( LessFiles . read ( pidFile ) ) . trim ( ) ; \n \n \t2 } catch ( FileNotFoundException ex ) { \n \n <ect>
\t4 LOG . debug ( <string_literal> , getEndpoint ( ) . getConfiguration ( ) . getMailStoreLogInformation ( ) ) ; } \n \n \t3 try { \n \n \t4 store . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t3 mc = new MemcachedClient ( <string_literal> , server1 . getMemcachedEndpoint ( ) . getInetAddress ( ) \n \n \t5 . getHostName ( ) , server1 . getMemcachedEndpoint ( ) . getPort ( ) , server1 . getMemcachedEndpoint ( ) . getPort ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 LOG . info ( <string_literal> , managementStrategy ) ; \n \n \t3 camelContext . setManagementStrategy ( managementStrategy ) ; } \n \n \t2 ManagementNamingStrategy managementNamingStrategy = getSingleBeanOfType ( applicationContext , ManagementNamingStrategy . class ) ; \n \n \t2 if ( managementNamingStrategy != null ) { \n \n <ect>
\t7 data = client . getCompressionProvider ( ) . decompress ( path , data ) ; } \n \n \t6 catch ( Exception e ) \n \n \t6 { \n \n \t7 ThreadUtils . checkInterrupted ( e ) ; \n \n <ect>
\t3 String json = fetchArtifactVersion ( groupId , artifactId , currentVersion ) ; \n \n \t3 String latestVersion = extractVersion ( json ) ; \n \n \t3 Boolean isLatest = extractIsLatest ( json ) ; \n \n \t3 if ( isLatest ) { \n \n <ect>
\t3 String message = <string_literal> \n \n \t5 + fdCount + <string_literal> + initialFdCount ; \n \n \t3 LOG . info ( message ) ; \n \n \t3 if ( fdCount > initialFdCount ) { \n \n <ect>
\t5 } else { \n \n \t6 <comment> \n \n \t6 ConsumerId consumerWithPendingTransaction ; \n \n \t6 if ( redeliveryExpectedInCurrentTransaction ( md , true ) ) { \n \n <ect>
public static String idToPath ( String pathId ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 if ( pathId . contains ( PATH_SEPARATOR ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 dropLocalUser_result result = new dropLocalUser_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t4 query = genObj . get_query ( mappingGen . getKR2RMLMapping ( ) , graphUrl ) ; } \n \n \t3 retVal . put ( <string_literal> , query ) ; \n \n \t3 logger . info ( <string_literal> + query ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 try { \n \n \t5 KieScannerFactoryService scannerFactoryService = ServiceRegistry . getInstance ( ) . get ( KieScannerFactoryService . class ) ; \n \n \t5 return ( InternalKieScanner ) scannerFactoryService . newKieScanner ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t7 checkedElements . getEventableConditionChecker ( ) ) ; \n \n \t3 for ( Element sourceElement : nodeListForCrawlElement ) { \n \n \t4 evaluateElement ( results , relatedFrame , crawl , sourceElement ) ; } \n \n \t2 } catch ( CrawljaxException e ) { \n \n <ect>
\t2 logger . error ( RecordType . RELATIONSHIP_GROUP , new RelationshipGroupRecord ( relationshipGroupId ) , \n \n \t4 <string_literal> , <string_literal> ) ; \n \n \t2 logger . error ( RecordType . PROPERTY , new PropertyRecord ( propertyId ) , \n \n \t4 <string_literal> , <string_literal> ) ; \n \n <ect>
\t4 Logger . error ( this , <string_literal> ) ; \n \n \t4 System . err . println ( <string_literal> ) ; \n \n \t3 } catch ( Throwable t ) { \n \n \t4 <comment> \n \n <ect>
\t2 try { \n \n \t3 <comment> \n \n \t3 if ( needsCommit || needsBegin ) { \n \n \t4 if ( this . autoCommit ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( ! OSUtils . IS_WINDOWS ) \n \n \t3 return ; \n \n <ect>
\t2 command . add ( <string_literal> ) ; \n \n \t2 command . add ( <string_literal> ) ; \n \n \t2 String result = command . execute ( ) ; \n \n \t2 if ( result != null ) { \n \n <ect>
\t3 protectedPassword = encryptText ( protectedPassword ) ; \n \n \t3 if ( protectedUsername == null || protectedPassword == null ) { \n \n \t4 LOGGER . error ( <string_literal> ) ; \n \n \t4 LOGGER . error ( <string_literal> ) ; \n \n <ect>
\t1 @ Nullable \n \n \t1 private static WebApplicationContext getWebApplicationContext ( ) { \n \n \t2 RequestAttributes requestAttributes = RequestContextHolder . getRequestAttributes ( ) ; \n \n \t2 if ( requestAttributes == null ) { \n \n <ect>
\t3 fieldName , propName ) ; \n \n \t2 sql . execute ( query ) ; } \n \n \t1 return true ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 terminate ( ) ; } \n \n \t2 } else { \n \n <ect>
\t3 } catch ( InterruptedIOException iie ) { \n \n \t4 _log . error ( <string_literal> , iie ) ; \n \n \t4 <comment> \n \n \t3 } catch ( NoRouteToHostException nrthe ) { \n \n <ect>
\t3 if ( vm . getPowerState ( conn ) == VmPowerState . HALTED ) { \n \n \t4 try { \n \n \t5 vm . destroy ( conn ) ; \n \n \t4 } catch ( final Exception e ) { \n \n <ect>
\t2 clusterState = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 assertThat ( strategy . reroute ( clusterState , <string_literal> ) . routingTable ( ) , sameInstance ( clusterState . routingTable ( ) ) ) ; \n \n <ect>
return } \n \n if ( ( db_user == null || db_user . length ( ) < = 0 ) || \n \n ( db_host == null || db_host . length ( ) < = 0 ) || \n \n ( db_pass == null || db_pass . length ( ) < = 0 ) ) { \n \n <ect>
\t1 @ GridLoggerResource private GridLogger log ; \n \n \t1 <comment> \n \n \t1 @ Override public Collection < ? extends GridComputeJob > split ( int gridSize , Object arg ) { \n \n <ect>
\t3 <comment> \n \n \t3 profile . getTunnelCreateResponseTime ( ) . load ( props , <string_literal> , true ) ; \n \n \t3 profile . getTunnelTestResponseTime ( ) . load ( props , <string_literal> , true ) ; \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t1 success = false ; \n \n \t1 LOG . warn ( <string_literal> + e . toString ( ) ) ; \n \n \t1 } catch ( IOException e ) { \n \n \t1 success = false ; \n \n <ect>
\t4 if ( procs != null ) { \n \n \t5 procs . close ( ) ; } } \n \n \t3 catch ( SQLException ex ) { \n \n <ect>
<comment> \n \n \t3 HostVO host = _hostDao . findById ( agentId ) ; \n \n \t3 if ( host != null ) { \n \n \t4 if ( ( host . getManagementServerId ( ) == null ) || ( mgmtSrvrId != host . getManagementServerId ( ) ) ) { \n \n <ect>
\t2 Future < String > futureErr = executorService . submit ( new CallableStreamReader ( p . getErrorStream ( ) ) ) ; \n \n \t2 try { \n \n \t3 streamData = futureOut . get ( ) ; \n \n \t3 streamError = futureErr . get ( ) ; \n \n <ect>
\t1 bais . close ( ) ; \n \n \t1 byte [ ] uncompressedByteArray = baos . toByteArray ( ) ; \n \n \t1 baos . close ( ) ; \n \n <ect>
\t4 vifName = config . get ( <string_literal> ) ; \n \n \t4 v . destroy ( conn ) ; \n \n \t4 s_logger . debug ( <string_literal> + vifName + <string_literal> ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 oclC . close ( ) \n \n \t1 mxC } } \n \n <comment> \n \n private def gpuSparseRowRWRW ( a : Matrix , b : Matrix , r : Option [ Matrix ] = None ) : Matrix = { \n \n <ect>
\t2 private A a ; \n \n \t2 @ WarmUp \n \n \t2 public void connect ( ) \n \n \t2 { \n \n <ect>
\t4 writer . key ( <string_literal> ) ; \n \n \t4 writer . value ( jsonStr ) ; \n \n \t4 writer . endObject ( ) ; \n \n \t3 } catch ( DatabaseServiceException e ) { \n \n <ect>
\t1 throws HiveException { \n \n \t1 if ( si . skipPruning . get ( ) ) { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t4 s_logger . warn ( String . format ( <string_literal> , service . getName ( ) ) ) ; \n \n \t4 return false ; } \n \n \t3 Network . Provider provider = Network . Provider . getProvider ( vpcOfferingService . getProvider ( ) ) ; \n \n \t3 if ( ! supportedVpcServices . containsEntry ( service , provider ) ) { \n \n <ect>
\t3 } catch ( NoTransitionException e1 ) { \n \n \t4 throw new ConcurrentOperationException ( <string_literal> + e1 . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t4 if ( ! checkVmOnHost ( vm , dstHostId ) ) { \n \n <ect>
\t2 String rsrcVal = new String ( bytes ) . trim ( ) ; \n \n \t3 log . info ( <string_literal> + rsrcVal ) ; \n \n \t2 if ( ! <string_literal> . equals ( rsrcVal ) ) { \n \n <ect>
\t3 final long count = events . stream ( ) . filter ( e - > e . getGeoLocation ( ) . equals ( \n \n \t5 new GeoLocationRequest ( response . getLatitude ( ) , response . getLongitude ( ) ) ) ) . count ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> , remoteAddr , count ) ; \n \n \t3 if ( count == events . size ( ) ) { \n \n <ect>
\t4 hTableId = workspace . getFactory ( ) . getHNode ( hNodeId ) . getHTableId ( ) ; } \n \n \t3 HTable hTable = workspace . getFactory ( ) . getHTable ( hTableId ) ; \n \n \t3 if ( hTable == null ) \n \n \t3 { \n \n <ect>
\t2 <comment> \n \n \t2 synchronized ( this ) { \n \n \t3 pendingStop . set ( true ) ; \n \n \t3 if ( starting . get ( ) ) { \n \n <ect>
\t2 for ( ServiceComponentHostRequest r : requests ) { \n \n \t3 if ( r . getHostname ( ) == null ) { \n \n \t3 <comment> \n \n \t3 throwException = false ; \n \n <ect>
\t2 return tempDirFile ; } \n \n \t1 @ Override \n \n \t1 public void cleanupZipTemp ( ) { \n \n \t2 System . out . println ( <string_literal> + tempWorkDir ) ; \n \n <ect>
\t4 AccessControlProfile . accessRoot ( effectiveACL . getBaseName ( ) ) ) ; \n \n \t2 if ( null == nodeKey ) { \n \n \t3 throw new AccessDeniedException ( <string_literal> + nodeName + <string_literal> ) ; } \n \n \t2 if ( Log . isLoggable ( Log . FAC_ACCESSCONTROL , Level . INFO ) ) { \n \n <ect>
\t5 deployment = new DeploymentBuilder ( ) . build ( is , loader ) ; \n \n \t4 } catch ( ParsingException e ) { \n \n \t5 throw new RuntimeException ( e ) ; } } \n \n \t3 deploymentContext = new SamlDeploymentContext ( deployment ) ; \n \n <ect>
<comment> \n \n \t1 public void createCollection ( final MongoOperations mongoTemplate , final String collectionName , final boolean dropCollection ) { \n \n \t2 if ( dropCollection ) { \n \n <ect>
\t2 <comment> \n \n \t2 throw new Exception ( <string_literal> ) ; } \n \n \t1 LOG . info ( <string_literal> + instanceURI ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 s_logger . warn ( <string_literal> + jobId + <string_literal> + status + <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 TemplateDownloader td = dj . getTemplateDownloader ( ) ; \n \n \t2 s_logger . info ( <string_literal> + jobId + <string_literal> + status ) ; \n \n <ect>
\t5 } finally { \n \n \t6 closeQuietly ( inputStream ) ; } \n \n \t5 return null ; } \n \n \t3 } ) ) ; \n \n <ect>
\t9 Iterator < RFXComEventListener > iterator = _listeners . iterator ( ) ; \n \n \t9 while ( iterator . hasNext ( ) ) { \n \n \t10 iterator . next ( ) . packetReceived ( event , msg ) ; } \n \n \t8 } catch ( Exception e ) { \n \n <ect>
\t4 LOG . warn ( <string_literal> , e ) ; \n \n \t3 } catch ( NoSuchMethodException e ) { \n \n \t4 LOG . warn ( <string_literal> , e ) ; \n \n \t3 } catch ( NoClassDefFoundError e ) { \n \n <ect>
\t2 InputStream in = null ; \n \n \t2 try { \n \n \t3 in = FileUtil . open ( SSLContextFactory . class , keyStoreName ) ; \n \n \t3 if ( in == null ) { \n \n <ect>
\t1 } else if ( fileType == FileType . AVRO_DATA_FILE ) { \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n \t1 configureGenericRecordExportInputFormat ( job , tableName ) ; \n \n \t1 } else if ( fileType == FileType . PARQUET_FILE ) { \n \n <ect>
\t6 _vmDataServer . handleVmStarted ( cmd . getVirtualMachine ( ) ) ; } } } \n \n \t3 state = State . Running ; \n \n \t3 return new StartAnswer ( cmd ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t7 item . write ( uploadedFile ) ; } \n \n \t5 else \n \n \t6 item . write ( uploadedFile ) ; } } \n \n \t2 } catch ( FileUploadException ex ) { \n \n <ect>
\t5 CommPortIdentifier portId = ( CommPortIdentifier ) portList . nextElement ( ) ; \n \n \t5 sb . append ( String . format ( <string_literal> , portId . getName ( ) ) ) ; } \n \n \t4 logger . error ( <string_literal> , sb . toString ( ) . trim ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t4 String mixinName = Util . getMixinName ( oakPath ) ; \n \n \t4 if ( ntMgr . isNodeType ( tree , mixinName ) || ntMgr . getEffectiveNodeType ( tree ) . supportsMixin ( mixinName ) ) { \n \n \t5 policy = new NodeACL ( oakPath ) ; \n \n \t4 } else { \n \n <ect>
\t3 if ( response instanceof AccessAccept ) { \n \n \t4 final List < RadiusAttribute > attributes = response . getAttributes ( ) . getAttributeList ( ) ; \n \n \t4 LOGGER . debug ( <string_literal> , response . getCode ( ) , attributes , response . getIdentifier ( ) ) ; \n \n \t4 return new RadiusResponse ( response . getCode ( ) , response . getIdentifier ( ) , attributes ) ; } \n \n <ect>
\t1 private void sendBatchResponse ( BatchResult batchResult ) { <comment> \n \n \t2 final String clientId = batchResult . clientId ( ) ; \n \n \t2 if ( ! storeServer . clientExistsStill ( clientId ) ) { \n \n \t3 return ; } \n \n <ect>
\t1 @ Override \n \n \t1 public Map < ? extends ServerResource , Map < String , String > > find ( long dcId , Long podId , Long clusterId , URI url , \n \n \t2 String username , String password , List < String > hostTags ) throws DiscoveryException { \n \n <ect>
\t7 Answer answer = null ; \n \n \t7 try { \n \n \t8 answer = ep . sendMessage ( cmd ) ; \n \n \t7 } catch ( CloudRuntimeException e ) { \n \n <ect>
\t2 while ( cassandraClient == null && active . get ( ) ) { \n \n \t2 try { \n \n \t3 cassandraClient = availableClientQueue . poll ( <number_literal> , TimeUnit . MILLISECONDS ) ; \n \n \t2 } catch ( InterruptedException ie ) { \n \n <ect>
\t2 final String lockFilePath = LockCheck . toFile ( al . cpuId ( ) ) . getAbsolutePath ( ) ; \n \n \t2 try { \n \n \t3 Files . delete ( Paths . get ( lockFilePath ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t2 } finally { \n \n \t3 if ( ! success ) { \n \n \t4 s_logger . warn ( <string_literal> + id ) ; \n \n \t4 return null ; } \n \n <ect>
\t3 if ( shellMsg . areTaskIdsNeeded ( ) ) { \n \n \t4 try { \n \n \t5 _process . writeTaskIds ( outTasks ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t5 log . warn ( String . format ( <string_literal> , hadoopLogDir , tmpDir ) ) ; } } \n \n \t2 if ( fallbackToTmp ) { \n \n \t3 hadoopLogDir = tmpDir ; } \n \n \t2 log . debug ( <string_literal> + jobId ) ; \n \n <ect>
\t1 @ Test \n \n \t1 public void testQueryCluster ( ) throws IOException { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 runWithArgs ( new String [ ] { <string_literal> } , <string_literal> , null , RunTypes . YARN_SESSION , 0 ) ; <comment> \n \n <ect>
\t2 break ; } } \n \n \t1 return preemptedTaskList ; } \n \n <comment> \n \n private int distributeGuaranteed ( int count , TaskInfo failedUpdate , List < TaskInfo > toUpdate ) { \n \n <ect>
\t2 try { \n \n \t3 if ( context . isDefined ( SysRIOT . sysStreamManager ) ) \n \n \t4 return ( StreamManager ) context . get ( SysRIOT . sysStreamManager ) ; } \n \n \t2 catch ( ClassCastException ex ) { \n \n <ect>
\t2 int maxDelay = <number_literal> ; <comment> \n \n \t2 try { \n \n \t3 if ( delayThresholdStr != null && delayThresholdStr . length ( ) != 0 ) { \n \n \t4 delayThreshold = Double . parseDouble ( delayThresholdStr ) ; \n \n <ect>
\t3 this . offlineTimestamp . set ( - 1 ) ; \n \n \t3 dispatchPending ( ) ; \n \n \t3 this . usageManager . getMemoryUsage ( ) . addUsageListener ( this ) ; } } \n \n \t1 public void deactivate ( boolean keepDurableSubsActive , long lastDeliveredSequenceId ) throws Exception { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t5 } else { \n \n \t6 break ; } \n \n \t5 method . releaseConnection ( ) ; \n \n \t4 } else { \n \n <ect>
\t3 commandSB . append ( LOGBACK_CONF_TAG_CMD + DEFAULT_LOG_CONF ) ; } \n \n \t2 final String LOG4J_CONF_TAG = <string_literal> ; \n \n \t2 String userDefLog4jConf = ConfigExtension . getUserDefinedLog4jConf ( conf ) ; \n \n \t2 if ( ! StringUtils . isBlank ( userDefLog4jConf ) ) { \n \n <ect>
\t4 inp = inp . substring ( 0 , inp . length ( ) - <number_literal> ) ; \n \n \t4 FileSystem fs = HadoopUtil . getWorkingFileSystem ( job . getConfiguration ( ) ) ; \n \n \t4 Path path = new Path ( inp ) ; \n \n \t4 if ( ! exists ( fs , path ) ) { \n \n <ect>
\t2 private void uncheckedSleep ( long milliseconds ) { \n \n \t3 try { \n \n \t4 Thread . sleep ( milliseconds ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t4 return null ; } \n \n \t3 <comment> \n \n \t3 boolean isSameCidr = NetUtils . sameSubnetCIDR ( requestedIp . ip4 ( ) , cidr [ 0 ] , Integer . parseInt ( cidr [ 1 ] ) ) ; \n \n \t3 if ( ! isSameCidr ) { \n \n <ect>
\t3 logger . info ( xmlOutput . getWriter ( ) . toString ( ) ) ; \n \n \t2 } catch ( TransformerConfigurationException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( TransformerException e ) { \n \n <ect>
\t2 try { \n \n \t3 if ( ! _firewallMgr . applyRules ( rules , continueOnError , true ) ) { \n \n \t4 return false ; } \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t2 _accountMgr . checkAccess ( CallContext . current ( ) . getCallingAccount ( ) , null , true , volume ) ; \n \n \t2 SnapshotInfo snapshot = snapshotFactory . getSnapshot ( snapshotId , DataStoreRole . Primary ) ; \n \n \t2 if ( snapshot == null ) \n \n \t2 { \n \n <ect>
\t1 LOG . debug ( <string_literal> + he . getMessage ( ) ) ; \n \n \t1 return false ; } \n \n \t1 <comment> \n \n \t1 hmsConn = getConnectionToMetastore ( false ) ; \n \n <ect>
\t3 db . store ( historicItem ) ; \n \n \t3 logger . debug ( <string_literal> , historicItem . getName ( ) , historicItem . getState ( ) . toString ( ) ) ; \n \n \t2 } catch ( Db4oException e ) { \n \n \t3 db . rollback ( ) ; \n \n <ect>
\t4 SecurityUtils . class . getClassLoader ( ) ) ; \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( ! ( installedContext instanceof NoOpSecurityContext ) ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void execute ( DigitalSTROMAPI digitalSTROM , String token ) { \n \n \t2 int value = digitalSTROM . getDeviceOutputValue ( token , this . device . getDSID ( ) , null , this . index ) ; \n \n <ect>
\t3 log . debug ( <string_literal> , reg ) ; \n \n \t3 reg . rebind ( JMETER_ENGINE_RMI_NAME , this ) ; \n \n \t3 log . info ( <string_literal> , this . rmiRegistryPort ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 log . info ( <string_literal> , maxThreads . getKey ( ) , max ) ; \n \n \t3 tp . setCorePoolSize ( max ) ; \n \n \t3 tp . setMaximumPoolSize ( max ) ; } \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t1 public boolean finalizeCommandsOnStart ( final Commands cmds , final VirtualMachineProfile profile ) { \n \n \t2 final DomainRouterVO router = _routerDao . findById ( profile . getId ( ) ) ; \n \n \t2 final NicProfile controlNic = getControlNic ( profile ) ; \n \n \t2 if ( controlNic == null ) { \n \n <ect>
\t2 return null ; } \n \n \t1 if ( ! readStartData ) { \n \n \t2 LOG . warn ( <string_literal> + containerId ) ; } \n \n \t1 if ( ! readFinishData ) { \n \n <ect>
\t1 private static String hadoopServicePrincipal = null ; \n \n \t1 public static void prepare ( TemporaryFolder tempFolder ) { \n \n \t2 try { \n \n \t3 File baseDirForSecureRun = tempFolder . newFolder ( ) ; \n \n <ect>
\t2 for ( String mediaTypeStr : extras ) { \n \n \t3 MediaType mediaType = parseMediaType ( mediaTypeStr ) ; \n \n \t3 addSupportedMimeType ( mediaTypeStr ) ; \n \n \t3 this . mediaTypeToParserMap . put ( mediaType , parser ) ; \t3 } } } \n \n <ect>
\t4 log . warn ( <string_literal> + jobId \n \n \t6 + <string_literal> ) ; } } \n \n \t2 catch ( InterruptedException e ) { \n \n \t3 queueCallable ( new CoordJobMatLookupCommand ( jobId , materializationWindow ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t1 private final static Logger LOGGER = Logger . getLogger ( DemoDataGenerator . class . getName ( ) ) ; \n \n \t1 public void createUsers ( ProcessEngine engine ) { \n \n \t1 final IdentityService identityService = engine . getIdentityService ( ) ; \n \n \t1 if ( identityService . isReadOnly ( ) ) { \n \n <ect>
\t1 } ; } \n \n private InjectorObjectFactory < WroConfiguration > createConfigProxy ( ) { \n \n \t1 return new InjectorObjectFactory < WroConfiguration > ( ) { \n \n \t1 public WroConfiguration create ( ) { \n \n <ect>
\t5 s_linuxVmId . set ( values . get ( <string_literal> ) ) ; \n \n \t5 s_linuxIP . set ( values . get ( <string_literal> ) ) ; \n \n \t5 s_linuxPassword . set ( <string_literal> ) ; } \n \n \t3 } else { \n \n <ect>
\t3 assert qe != null ; <comment> \n \n \t3 try { \n \n \t4 qe . closeWhenIdle ( ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 result . setResponseData ( baos . toByteArray ( ) ) ; \n \n \t2 assertion . setXsdFileName ( findTestPath ( <string_literal> ) ) ; \n \n \t2 AssertionResult res = assertion . getResult ( jmctx . getPreviousResult ( ) ) ; \n \n \t2 testLog . debug ( <string_literal> + res . isError ( ) + <string_literal> + res . isFailure ( ) ) ; \n \n <ect>
\t1 for ( String sql : sqlStmts ) { \n \n \t2 st . executeUpdate ( sql ) ; } \n \n \t1 connection . commit ( ) ; \n \n \t1 } catch ( SQLException sqlE ) { \n \n <ect>
\t4 in = new BufferedInputStream ( instream ) ; } \n \n \t2 } catch ( IOException e ) { \n \n \t3 if ( ! ( e . getCause ( ) instanceof FileNotFoundException ) ) \n \n \t3 { \n \n <ect>
<number_literal> <comment> \n \n <number_literal> <comment> \n \n \t2 SOAPMessage response = readSoapResponse ( soapActionHeader , smTr064Request , _url + tr064service . getControlUrl ( ) ) ; \n \n \t2 if ( response == null ) { \n \n <ect>
\t2 String productVersion = resultSet . getString ( <string_literal> ) . toLowerCase ( ) ; \n \n \t2 if ( productVersion . contains ( <string_literal> ) ) { \n \n \t2 return new CockroachPlatform ( ) ; } } \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 invoke ( baseHandler , baseHandler . getClass ( ) . getDeclaredMethod ( <string_literal> , ( Class < ? > [ ] ) null ) , \n \n \t2 null ) ; \n \n \t1 } catch ( Throwable e ) { \n \n <ect>
\t1 try { \n \n \t1 HdfsAdmin hdfsAdmin = new HdfsAdmin ( fsUri , conf ) ; \n \n \t1 return ( hdfsAdmin . getEncryptionZoneForPath ( fullPath ) != null ) ; \n \n \t1 } catch ( FileNotFoundException fnfe ) { \n \n <ect>
\t1 public void receiveCommand ( Item item , Command command , ZWaveNode node , ZWaveBinarySwitchCommandClass commandClass , \n \n \t3 int endpointId , Map < String , String > arguments ) { \n \n \t2 ZWaveCommandConverter < ? , ? > converter = this . getCommandConverter ( command . getClass ( ) ) ; \n \n \t2 if ( converter == null ) { \n \n <ect>
\t8 try { \n \n \t9 node . unlockSystemPropertiesOnce ( ) ; \n \n \t9 node . setProperty ( propertyKey , val ) ; \n \n \t8 } catch ( FrameworkException fex ) { \n \n <ect>
\t4 subSystems . add ( new SubSystem ( type , Integer . valueOf ( split [ 1 ] ) , Integer . valueOf ( split [ <number_literal> ] ) , \n \n \t6 Integer . valueOf ( split [ <number_literal> ] ) == 1 ) ) ; } \n \n \t3 return subSystems ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 Connection conn = getConnection ( ) ; \n \n \t1 try { \n \n \t1 Statement st = conn . createStatement ( ) ; \n \n \t1 st . executeUpdate ( createTableSql ) ; \n \n <ect>
\t2 val cache = getCache ( group ) \n \n \t2 return cache [ key ] } \n \n \t1 override fun removeCacheItem ( group : String , prefixKey : String ) { \n \n \t2 val cache = instance . getCache < String , Any > ( group ) \n \n <ect>
\t4 str = queryMap . get ( <string_literal> ) ; \n \n \t4 try { \n \n \t5 code = Integer . parseInt ( str ) ; \n \n \t4 } catch ( NumberFormatException e ) { \n \n <ect>
\t6 LOG . warn ( <string_literal> + locSegment + <string_literal> , jsonEx ) ; } } \n \n \t3 } catch ( SocketException sex ) { \n \n \t4 LOG . info ( <string_literal> ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
private void safelyResetData ( Long hostId ) { \n \n \t1 try { \n \n \t1 resetData ( hostId ) ; \n \n \t1 } catch ( AmbariException e ) { \n \n <ect>
\t3 replicationFactor += storeDefinition . getReplicationFactor ( ) ; \n \n \t3 <comment> \n \n \t3 requiredWrites += storeDefinition . getRequiredWrites ( ) ; } \n \n \t2 if ( replicationFactor != clusterNodeList . size ( ) ) { \n \n <ect>
\t4 MappedContainerTypeHandler < ? > mappedHandler = new MappedContainerTypeHandler ( typeClass , getFieldHandlerMap ( metadata ) ) ; \n \n \t4 typeHandlers . put ( typeClass , mappedHandler ) ; \n \n \t4 return mappedHandler ; \n \n \t3 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t1 configureNetworking ( group , templateOptions , template . getLocation ( ) ) ; \n \n \t1 templateOptions . userMetadata ( ComputeServiceConstants . NODE_GROUP_KEY , group ) ; \n \n \t1 <comment> \n \n \t1 if ( templateOptions . autoCreateKeyPair ( ) && Strings . isNullOrEmpty ( templateOptions . getPublicKey ( ) ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 return new CheckNetworkAnswer ( cmd , true , <string_literal> ) ; } \n \n \t1 protected Answer execute ( NetworkUsageCommand cmd ) { \n \n <ect>
\t5 s_logger . debug ( <string_literal> ) ; \n \n \t5 rbd . close ( image ) ; \n \n \t5 r . ioCtxDestroy ( io ) ; } \n \n \t3 } catch ( RadosException e ) { \n \n <ect>
\t2 public void run ( ) throws SuspendExecution { \n \n \t3 try { \n \n \t4 results [ order ] = handler . call ( ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t1 start ( ) ; } \n \n public void start ( ) { \n \n \t1 if ( settings . getBoolean ( CREATE_TEMP_FILES ) ) { \n \n \t1 LOG . info ( <string_literal> + tempFolder . newDir ( <string_literal> ) . getAbsolutePath ( ) ) ; \n \n <ect>
\t1 @ ConditionalOnMissingBean ( name = <string_literal> ) \n \n \t1 public YubiKeyAccountRegistry yubiKeyAccountRegistry ( ) { \n \n \t2 final YubiKeyMultifactorProperties yubi = casProperties . getAuthn ( ) . getMfa ( ) . getYubikey ( ) ; \n \n \t2 if ( yubi . getJsonFile ( ) != null ) { \n \n <ect>
\t6 LOG . debug ( <string_literal> + tx ) ; } \n \n \t5 inflightTransactions . remove ( tx ) ; } } \n \n \t3 synchronized ( preparedTransactions ) { \n \n \t4 for ( TransactionId txId : preparedTransactions . keySet ( ) ) { \n \n <ect>
\t7 mapping . remap ( oil . block ) ; \n \n \t6 } else if ( mapping . type == GameRegistry . Type . ITEM ) { \n \n \t7 if ( path . contains ( <string_literal> ) && oil . bucket != null ) mapping . remap ( oil . bucket ) ; \n \n \t7 else if ( path . contains ( <string_literal> ) ) mapping . ignore ( ) ; } \n \n <ect>
\t2 try { \n \n \t3 super . setUp ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 System . err . println ( <string_literal> + e . getMessage ( ) ) ; \n \n <ect>
\t6 send10000messages ( latch ) ; } \n \n \t4 } ) ; } \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 latch . await ( <number_literal> , TimeUnit . MINUTES ) ; \n \n <ect>
\t4 <comment> \n \n <ect>
\t4 logger . info ( <string_literal> + entry . getMappingKey ( ) ) ; \n \n \t4 logger . info ( <string_literal> + entry . getKeyPattern ( ) ) ; } } \n \n \t2 if ( showWhen ) { \n \n \t3 for ( DSLMappingEntry entry : this . condition ) { \n \n <ect>
\t1 WALRUS_URL = ServiceUris . remote ( walrusConfig ) . toASCIIString ( ) ; \n \n \t1 StorageProperties . enableSnapshots = true ; \n \n \t1 LOG . debug ( <string_literal> + WALRUS_URL ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 Connection conn = getConnection ( ) ; \n \n \t3 s_logger . trace ( <string_literal> + _host . ip ) ; } \n \n \t2 if ( ! _canBridgeFirewall ) { \n \n <ect>
\t2 sendMessage ( null ) ; \n \n \t2 frame = stompConnection . receiveFrame ( ) ; \n \n \t2 assertNotNull ( <string_literal> , frame ) ; } \n \n \t1 private void doTestActiveMQReplyToTempDestination ( String type ) throws Exception { \n \n <ect>
\t2 Iterator < JournalEntry > iter = journal . entries ( ) ; \n \n \t2 if ( ! iter . hasNext ( ) ) { \n \n \t3 components . forEachComponent ( c - > c . cleanStart ( ) ) ; \n \n \t3 return ; } \n \n <ect>
\t2 if ( _creationDate == null ) return null ; \n \n \t2 ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \n \n \t2 try { \n \n \t3 <comment> \n \n <ect>
\t1 public void removeLockToken ( String lt ) { \n \n \t2 try { \n \n \t3 getWorkspace ( ) . getLockManager ( ) . removeLockToken ( checkNotNull ( lt ) ) ; \n \n \t2 } catch ( RepositoryException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 result = this . getProtectedPlugin ( ) . addTagToDocument ( tag , document , this . context ) ; \n \n \t3 } else { \n \n \t4 result = TagOperationResult . NOT_ALLOWED ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 for ( Entry < String , LogicalInput > entry : inputs . entrySet ( ) ) { \n \n \t3 if ( inputsToSkip . contains ( entry . getKey ( ) ) ) { \n \n \t4 LOG . info ( <string_literal> + entry . getValue ( ) + <string_literal> + entry . getKey ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 try { \n \n \t3 module = classObj . newInstance ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 String className = uri . substring ( ARQConstants . javaClassURIScheme . length ( ) ) ; \n \n <ect>
\t3 s_logger . error ( <string_literal> + network + <string_literal> ) ; \n \n \t3 return routers ; } \n \n \t2 final Vpc vpc = _vpcMgr . getActiveVpc ( vpcId ) ; \n \n \t2 if ( vpc == null ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + actualExitCode ) \n \n \t3 context . testingContext ? . buildLogger ? . buildFinished ( actualExitCode ) \n \n \t3 return actualExitCode } \n \n \t2 catch ( e : StopBuildException ) { \n \n <ect>
\t3 + <string_literal> \n \n \t3 + input . getInstanceType ( ) . getVirtualBootRecord ( ) ) ; \n \n \t2 Logs . extreme ( ) . error ( ex , ex ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t1 int numDesiredPoints = entry . getValue ( ) ; \n \n \t1 List < Point < T > > tPoints = getPointList ( t , numDesiredPoints ) ; \n \n \t1 <comment> \n \n \t1 newRingPoints . addAll ( tPoints . subList ( 0 , numDesiredPoints ) ) ; } \n \n <ect>
\t10 newMessages ++ ; } } \n \n \t8 value = Integer . toString ( newMessages ) ; \n \n \t8 logger . debug ( <string_literal> , value ) ; \n \n \t7 } else { \n \n <ect>
\t3 Log . warning ( Log . FAC_TEST , <string_literal> + e1 . getMessage ( ) ) ; \n \n \t3 Assert . fail ( ) ; } \n \n \t2 while ( ! istream . eof ( ) ) { \n \n \t3 try { \n \n <ect>
\t2 Path path = file . getPath ( ) ; \n \n \t2 Utilities . FILE_OP_LOGGER . trace ( <string_literal> + path + <string_literal> ) ; } \n \n \t2 if ( ! file . isDirectory ( ) ) { \n \n <ect>
\t2 profile . addDefaults ( getDefaultThreadPoolProfile ( ) ) ; \n \n \t2 ScheduledExecutorService answer = threadPoolFactory . newScheduledThreadPool ( profile , createThreadFactory ( sanitizedName , true ) ) ; \n \n \t2 onThreadPoolCreated ( answer , source , null ) ; \n \n <ect>
\t3 statement . setString ( 1 , null ) ; \n \n \t3 statement . setLong ( <number_literal> , 0l ) ; \n \n \t3 statement . setString ( <number_literal> , getLeaseHolderId ( ) ) ; \n \n \t3 if ( statement . executeUpdate ( ) == 1 ) { \n \n <ect>
\t1 int size = ( 1 < < sizeLog2 ) - 1 ; \n \n \t1 try { \n \n \t1 a . allocateMultiple ( allocs [ index ] , size ) ; \n \n \t1 } catch ( AllocatorOutOfMemoryException ex ) { \n \n <ect>
\t4 ILaunch launch = ( ( TestRunSession ) runSession ) . getLaunch ( ) ; \n \n \t4 if ( launch != null && launch . getLaunchConfiguration ( ) != null ) { \n \n \t5 mainType = launch . getLaunchConfiguration ( ) . getAttribute ( <string_literal> , ( String ) null ) ; } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 for ( int id = 0 ; id < MULTIPLE_RUN_TEST_COUNT ; id ++ ) { \n \n \t3 PingRequest pingRequest = PingRequest . newBuilder ( ) . setPingName ( GRPC_TEST_PING_VALUE + id ) . setPingId ( id ) . build ( ) ; \n \n \t3 Object pongResponse = template . requestBody ( <string_literal> , pingRequest ) ; \n \n \t3 assertEquals ( ( ( PongResponse ) pongResponse ) . getPongId ( ) , id ) ; } \n \n <ect>
\t2 log . info ( <string_literal> ) <comment> \n \n \t2 CompileService . CallResult . Good ( daemonJVMOptions ) } \n \n \t1 override fun registerClient ( aliveFlagPath : String ? ) : CompileService . CallResult < Nothing > = ifAlive ( minAliveness = Aliveness . Alive ) { \n \n \t2 state . addClient ( aliveFlagPath ) \n \n <ect>
<comment> \n \n \t1 @ EventListener \n \n \t1 public void handleConfigurationModifiedEvent ( final CasConfigurationModifiedEvent event ) { \n \n \t2 if ( this . contextRefresher == null ) { \n \n <ect>
\t2 Locale locale = null ; \n \n \t2 if ( languageCode != null && ! languageCode . isEmpty ( ) ) { \n \n \t3 locale = Languages . toLocale ( Locale . forLanguageTag ( languageCode ) ) ; \n \n \t3 if ( log && locale == null ) { \n \n <ect>
\t3 } catch ( DOMException dex ) { \n \n \t4 logger . warn ( <string_literal> , dex ) ; \n \n \t4 getWebSocket ( ) . send ( MessageBuilder . status ( ) . code ( <number_literal> ) . message ( dex . getMessage ( ) ) . build ( ) , true ) ; } \n \n \t2 } else { \n \n <ect>
\t5 Iterator < SimpleConsumerThread < T > > bttIterator = brokerToThread . values ( ) . iterator ( ) ; \n \n \t5 while ( bttIterator . hasNext ( ) ) { \n \n \t6 SimpleConsumerThread < T > thread = bttIterator . next ( ) ; \n \n \t6 if ( ! thread . getNewPartitionsQueue ( ) . isOpen ( ) ) { \n \n <ect>
\t2 List < HTMLFilter > filters = new ArrayList < HTMLFilter > ( config . getFilters ( ) ) ; \n \n \t2 filters . add ( Utils . getComponent ( HTMLFilter . class , <string_literal> ) ) ; \n \n \t2 config . setFilters ( filters ) ; \n \n \t2 String result = HTMLUtils . toString ( cleaner . clean ( new StringReader ( input ) , config ) ) ; \n \n <ect>
\t2 LOGGER . info ( message , event . getResource ( ) . getResourceName ( ) , <string_literal> , event . getResource ( ) . getRepositoryUrl ( ) ) ; } \n \n \t1 public void transferStarted ( TransferEvent event ) { \n \n \t2 long contentLength = event . getResource ( ) . getContentLength ( ) ; \n \n \t2 if ( contentLength > 0 ) { \n \n <ect>
\t3 ( ( SettableUDF ) clonedUDF ) . setTypeInfo ( typeInfo ) ; } \n \n \t2 } catch ( UDFArgumentException err ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t4 Object valueToSet = preparedValue == null ? null : converter . convert ( preparedValue ) ; \n \n \t4 if ( valueToSet != null ) { \n \n \t5 FieldUtils . writeField ( target , objectProperty , valueToSet , true ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 File sortedFileDir = new File ( storeDir , <string_literal> ) ; \n \n \t2 FileUtils . forceMkdir ( sortedFileDir ) ; \n \n \t2 return sortedFileDir ; } \n \n \t1 private void logFlags ( ) { \n \n <ect>
\t3 try { \n \n \t4 modules . add ( moduleRegistry . getModule ( pluginModule ) ) ; \n \n \t3 } catch ( UnknownModuleException e ) { \n \n \t4 <comment> \n \n <ect>
\t3 sys . exit ( 1 ) \n \n \t1 logger . debug ( <string_literal> . format ( messages_file ) ) \n \n \t1 config = read_config ( logger , args . config ) \n \n \t1 if config is None : \n \n <ect>
\t3 if ( ! FailureDetector . instance . isAlive ( address ) ) \n \n \t4 iter . remove ( ) ; } \n \n \t2 if ( candidates . isEmpty ( ) ) \n \n \t2 { \n \n <ect>
\t4 curDelay = 0 ; \n \n \t4 while ( _running && ( _socket != null ) ) { \n \n \t5 try { \n \n \t6 Socket socket = _socket . accept ( ) ; \n \n <ect>
\t6 Constructor testConstructor , \n \n \t6 Method testMethod ) \n \n \t1 { \n \n \t2 if ( annotation . getTimeOut ( ) == 0 ) { \n \n <ect>
\t3 if ( theme == null ) \n \n \t3 { \n \n \t4 throw new RuntimeException ( <string_literal> ) ; } \n \n \t3 Person person = personMapper . findById ( userId ) ; \n \n <ect>
\t3 for ( MembershipAction . JoinCallback callback : callbacks ) { \n \n \t4 try { \n \n \t5 callback . onFailure ( e ) ; \n \n \t4 } catch ( Exception inner ) { \n \n <ect>
\t1 public void tearDown ( ) throws Exception { \n \n \t2 long time = watch . stop ( ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + getTestMethodName ( ) + <string_literal> + getClass ( ) . getName ( ) + <string_literal> ) ; \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , jsonResource ) ; } } } \n \n \t1 @ Override \n \n \t1 public Map < String , List < U2FDeviceRegistration > > readDevicesFromResource ( ) throws Exception { \n \n \t2 if ( ! this . jsonResource . getFile ( ) . exists ( ) || this . jsonResource . getFile ( ) . length ( ) < = 0 ) { \n \n <ect>
\t4 HiveInsertExchange4JoinRule . EXCHANGE_BELOW_MULTIJOIN ) ; \n \n \t2 perfLogger . PerfLogEnd ( this . getClass ( ) . getName ( ) , PerfLogger . OPTIMIZER , <string_literal> ) ; } \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n <ect>
\t2 field . set ( object , value ) ; } \n \n \t1 @ Override \n \n \t1 public Object methodValue ( Object object , Method method ) throws IllegalArgumentException , IllegalAccessException , \n \n \t1 InvocationTargetException { \n \n <ect>
\t1 @ Produces ( <string_literal> ) \n \n \t1 @ GET \n \n \t1 public JsonCollectionFoo [ ] get ( ) throws Exception { \n \n \t2 JsonCollectionFoo [ ] foo = { new JsonCollectionFoo ( <string_literal> ) , new JsonCollectionFoo ( <string_literal> } <string_literal> <ect>
\t7 <comment> \n \n \t7 if ( localAssignmentTS != null ) \n \n \t8 workerData . setAssignmentTs ( localAssignmentTS ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t3 HostVO host = _hostDao . findById ( agentId ) ; \n \n \t3 if ( host . getType ( ) == Type . ConsoleProxy ) { \n \n \t4 String name = host . getName ( ) ; \n \n <ect>
\t3 _executor = Executors . newCachedThreadPool ( new NamedThreadFactory ( <string_literal> ) ) ; \n \n \t3 try { \n \n \t4 _serverSocket = new ServerSocket ( port ) ; \n \n \t3 } catch ( IOException ioex ) { \n \n <ect>
\t6 LOG . info ( <string_literal> + id + <string_literal> + removeCount ) ; \n \n \t6 break ; \n \n \t5 default : } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( upgradePack . isAllTarget ( ) && upgradePack . getType ( ) == base . getType ( ) ) { \n \n \t2 return upgradePack ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 final Status status = newStatus ( StatusCode . SUCCESS , null ) ; \n \n \t2 samlResponse . setStatus ( status ) ; \n \n \t2 SamlUtils . logSamlObject ( this . configBean , samlResponse ) ; \n \n \t2 if ( service . isSignResponses ( ) ) { \n \n <ect>
\t3 return ; } \n \n \t2 CalDavType type = config . getType ( ) ; \n \n \t2 logger . trace ( <string_literal> , type ) ; \n \n \t2 if ( type == CalDavType . VALUE ) { \n \n <ect>
\t1 SqoopOptions options = context . getOptions ( ) ; \n \n \t1 LOG . info ( <string_literal> ) ; \n \n \t1 if ( options . getFileLayout ( ) != SqoopOptions . FileLayout . TextFile ) { \n \n \t1 <comment> \n \n <ect>
\t3 dirExists = true ; } \n \n \t2 if ( dirExists ) { \n \n \t3 s_logger . info ( dirName + <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 result . assertIsSatisfied ( ) ; \n \n \t3 fail ( <string_literal> ) ; \n \n \t2 } catch ( AssertionError e ) { \n \n <ect>
\t3 for ( Module module : modules ) { \n \n \t4 if ( module . has ( name ) ) { \n \n \t5 pi = module . getProviderInfo ( name ) ; \n \n \t5 break ; } } \n \n <ect>
\t2 } catch ( SocketException e ) { \n \n \t3 ctx . forceDisconnect ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n \t3 ctx . forceDisconnect ( ) ; \n \n <ect>
\t6 log . info ( <string_literal> + rsrc4 ) ; \n \n \t6 log . info ( <string_literal> + rsrc5 ) ; \n \n \t6 log . info ( <string_literal> + rsrc6 ) ; \n \n \t6 log . info ( <string_literal> + rsrc7 ) ; \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName , driver ) ; \n \n \t1 String replDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String replDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t2 <comment> \n \n \t2 return true ; } \n \n \t1 @ Override \n \n \t1 protected void debugBefore ( Exchange exchange , org . apache . camel . Processor processor , ProcessorDefinition < ? > definition , String id , String label ) { \n \n <ect>
\t3 userAddress = request . getHeader ( this . alternativeRemoteHostAttribute ) ; \n \n \t3 LOGGER . debug ( <string_literal> , this . alternativeRemoteHostAttribute , userAddress ) ; \n \n \t3 if ( StringUtils . isBlank ( userAddress ) ) { \n \n \t4 userAddress = request . getRemoteAddr ( ) ; \n \n <ect>
\t2 return targetHostUUID + <string_literal> + taskKey ; } \n \n \t1 public boolean execute ( ) { \n \n \t2 targetHost = hostManager . getHostState ( targetHostUUID ) ; \n \n \t2 if ( taskKey == null || ! spawn . checkStatusForMove ( targetHostUUID ) || ! spawn . checkStatusForMove ( sourceHostUUID ) ) { \n \n <ect>
\t2 } catch ( XmlRpcException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return new FenceAnswer ( cmd , false , e . getMessage ( ) ) ; \n \n \t2 } catch ( XenAPIException e ) { \n \n <ect>
\t1 if ( plan == null ) { \n \n \t1 return ; } \n \n \t1 List < TezTask > rootTasks = Utilities . getTezTasks ( plan . getRootTasks ( ) ) ; \n \n \t1 for ( TezTask tezTask : rootTasks ) { \n \n <ect>
\t6 File convertedSubtitles = new File ( configuration . getTempFolder ( ) , <string_literal> + params . sid . getExternalFile ( ) . getName ( ) ) ; \n \n \t6 FileUtil . convertFileFromUtf16ToUtf8 ( params . sid . getExternalFile ( ) , convertedSubtitles ) ; \n \n \t6 externalSubtitlesFileName = ProcessUtil . getShortFileNameIfWideChars ( convertedSubtitles . getAbsolutePath ( ) ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t3 if ( useOriginalWeights ) \n \n \t4 this . addLink ( source , target , l , link . getWeight ( ) ) ; \n \n \t3 else \n \n \t4 this . addLink ( source , target , l ) ; } \n \n <ect>
\t3 String security = hadoopConfig . get ( CommonConfigurationKeys . HADOOP_SECURITY_AUTHENTICATION ) ; \n \n \t3 if ( security != null && security . equals ( <string_literal> ) ) { \n \n \t4 logger . info ( <string_literal> ) ; \n \n \t3 } else if ( security != null && security . equals ( <string_literal> ) ) { \n \n <ect>
\t1 @ POST \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public Response test3 ( ) { \n \n \t2 int currentSecret3 = oo3 . getSecret ( ) ; \n \n <ect>
\t1 throws AccumuloException , AccumuloSecurityException { \n \n \t1 try { \n \n \t1 AccumuloVFSClassLoader . loadClass ( className , Class . forName ( asTypeName ) ) ; \n \n \t1 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t5 } catch ( IOException e ) { \n \n \t6 log . error ( <string_literal> , e ) ; } } \n \n \t3 } ; \n \n \t3 Runtime . getRuntime ( ) . addShutdownHook ( shutdownHookThread ) ; } \n \n <ect>
\t4 if ( context . getCurrentUser ( ) != null ) { \n \n \t5 log . error ( \n \n \t6 <string_literal> + context . getCurrentUser ( ) . getEmail ( ) + <string_literal> ) ; \n \n \t4 } else { \n \n <ect>
\t3 Manifest manifest = original . getManifest ( ) ; \n \n \t3 if ( manifest == null ) \n \n \t4 project . error ( <string_literal> , original ) ; \n \n \t3 else { \n \n <ect>
\t2 <comment> \n \n \t2 Thread . sleep ( <number_literal> ) ; \n \n \t2 MessageConsumer consumer = session . createConsumer ( tempQueue ) ; \n \n \t2 Message replyMsg = consumer . receive ( ) ; \n \n <ect>
\t2 int numberOfFilesAfterDeletion = numberOfFiles ( repo ) ; \n \n \t2 assertThat ( numberOfFilesAfterDeletion , lessThan ( numberOfFilesBeforeDeletion ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 cluster ( ) . wipeIndices ( <string_literal> ) ; \n \n <ect>
\t4 backoffHandler . imposeBackoffExponentialDelay ( 100L , <number_literal> , retryCountLimit , command \n \n \t6 . getFailureCount ( ) , command . toString ( ) ) ; \n \n \t4 return true ; } \n \n \t3 } catch ( HttpException e ) { \n \n <ect>
\t2 if ( dataout != null ) { \n \n \t3 try { \n \n \t4 dataout . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 return ; } \n \n \t3 case FAILED : \n \n \t4 this . deadCount ++ ; \n \n \t4 this . deadTime = Calendar . getInstance ( ) . getTime ( ) ; \n \n <ect>
\t1 RequestStatusResponse response = null ; \n \n \t1 try { \n \n \t1 response = controller . createAction ( actionRequest , requestProperties ) ; \n \n \t1 } catch ( Exception ae ) { \n \n <ect>
\t5 cfg . setAuthorizer ( new IsAuthenticatedAuthorizer ( ) ) ; \n \n \t4 } else { \n \n \t5 final Resource file = ResourceUtils . prepareClasspathResourceIfNeeded ( adminProps . getUsers ( ) ) ; \n \n \t5 if ( file != null && file . exists ( ) ) { \n \n <ect>
\t2 if ( server != null ) { \n \n \t2 try { \n \n \t3 server . stop ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t1 public TypedExpressionResult toTypedExpression ( Expression drlxExpr ) { \n \n \t2 logger . debug ( <string_literal> , PrintUtil . toDrlx ( drlxExpr ) , patternType , context . getUsedDeclarations ( ) ) ; \n \n \t2 final Optional < TypedExpression > typedExpression = toTypedExpressionRec ( drlxExpr ) ; \n \n \t2 final TypedExpressionResult typedExpressionResult = new TypedExpressionResult ( typedExpression , context ) ; \n \n <ect>
\t8 logger . info ( <string_literal> , \n \n \t10 remoteHost , remotePort ) ; \n \n \t7 } else { \n \n \t8 logger . info ( <string_literal> , remoteAddress ) ; } \n \n <ect>
\t3 Predicate predicate = getCompletionPredicate ( ) . createPredicate ( routeContext ) ; \n \n \t3 answer . setCompletionPredicate ( predicate ) ; \n \n \t2 } else if ( strategy instanceof Predicate ) { \n \n \t3 <comment> \n \n <ect>
\t3 <comment> \n \n \t3 if ( ( ( time - client . lastSeen ) > CLIENT_DROP_TIME_MILLIS ) || queueTooLarge ) { \n \n \t4 ClientEventListener listener = listeners . remove ( ev . getKey ( ) ) ; \n \n \t4 if ( systemManager . debug ( <string_literal> ) ) { \n \n <ect>
\t3 LogLog . debug ( <string_literal> + serviceInfo ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n \t3 LogLog . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t3 mapper . registerModule ( module ) ; \n \n \t3 return mapper . readValue ( query , new TypeReference < List < SearchFieldInfo < S > > > ( ) { \n \n \t3 } ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 TServerConnection conn ; \n \n \t1 try { \n \n \t2 conn = this . master . tserverSet . getConnection ( tls . current ) ; \n \n \t2 if ( conn != null ) { \n \n <ect>
\t4 GuiActivator . getResources ( ) \n \n \t5 . getI18NString ( <string_literal> ) ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t2 final boolean fail = authentication . getFailures ( ) . values ( ) \n \n \t3 . stream ( ) \n \n \t3 . anyMatch ( failure - > failure . getClass ( ) . isAssignableFrom ( PreventedException . class ) ) ; \n \n \t2 if ( fail ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 final String [ ] allowedNetBlocks = { <string_literal> , <string_literal> , <string_literal> , <string_literal> } ; \n \n \t2 if ( ! isValidIp4Cidr ( cidr ) ) { \n \n <ect>
\t3 checkTooManyError ( cumulativeStatistics ) ; \n \n \t3 lastSamplingPeriod = lastSamplingPeriod + ( interval * gap ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n \t3 LOGGER . error ( <string_literal> , e . getMessage ( ) ) ; \n \n <ect>
\t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t2 LOGGER . debug ( <string_literal> , CertUtils . toString ( cert ) ) ; \n \n \t2 final Collection < X509CRL > crls = getCRLs ( cert ) ; \n \n \t2 if ( crls == null || crls . isEmpty ( ) ) { \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t4 logger . warn ( <string_literal> , e ) ; \n \n \t4 return ; } \n \n \t3 if ( isBodyEmpty ( o ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 coordJob . setPending ( ) ; \n \n \t4 LOG . info ( <string_literal> + coordJob . getId ( ) + <string_literal> ) ; } \n \n \t3 else { \n \n \t4 coordJob . resetPending ( ) ; \n \n <ect>
\t6 } catch ( Exception e ) { \n \n \t7 onApplyError ( <string_literal> + sourceName + <string_literal> + e + <string_literal> + entity , e ) ; } } } \n \n \t3 } else { \n \n \t4 if ( ! isAllowCreate ( ) ) { \n \n <ect>
<comment> \n \n <comment> \n \n private def gpuDRWAAt ( a : Matrix , b : Matrix , r : Option [ Matrix ] = None ) = { \n \n \t1 <comment> \n \n <ect>
\t3 return defaultValue ; } } \n \n \t1 static boolean getBoolean ( String key , boolean defaultValue ) { \n \n \t2 String stringValue = System . getProperty ( key ) ; \n \n \t2 if ( stringValue == null ) { \n \n <ect>
\t5 owner ) ; \n \n \t3 return cube ; } } \n \n \t1 public CubeInstance createCube ( CubeInstance cube , String projectName , String owner ) throws IOException { \n \n \t2 try ( AutoLock lock = cubeMapLock . lockForWrite ( ) ) { \n \n <ect>
\t3 return new CopyCmdAnswer ( newTemplate ) ; \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n \t4 hostService . invalidateServiceContext ( context ) ; } \n \n <ect>
\t3 log . error ( prefix + blocker . getLogName ( ) + <string_literal> + attacker . getLogName ( ) ) ; } \n \n \t2 log . error ( prefix ) ; \n \n \t2 log . error ( prefix + <string_literal> ) ; \n \n \t2 for ( Ability ability : attacker . getAbilities ( ) ) { \n \n <ect>
\t3 String body ; \n \n \t3 try { \n \n \t4 body = objectWriter . writeValueAsString ( batch ) ; \n \n \t3 } catch ( JsonProcessingException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 STreeProperty p = desc . findPropertyWithDynamic ( propName ) ; \n \n \t1 if ( p == null ) { \n \n <ect>
\t4 addRequired ( KafkaConfig . concatResourcePath ( streamingConfig . getName ( ) ) ) ; } } } \n \n \t1 private void retrieveResourcePath ( IRealization realization ) throws IOException { \n \n \t2 if ( realization == null ) { \n \n \t3 return ; } \n \n <ect>
\t2 if ( debug ) logger . info ( <string_literal> , request ) ; \n \n \t2 if ( ! masterDataStore . exists ( request . key ( ) ) ) { \n \n \t3 masterDataStore . set ( ( SetRequest ) request ) ; } } \n \n \t1 private void handleSetAndBroadCastVerb ( DataStoreRequest request ) { \n \n <ect>
\t2 try { \n \n \t3 Method getBeanMethod = beanFactory . getClass ( ) . getMethod ( <string_literal> , String . class ) ; \n \n \t3 return ( Boolean ) getBeanMethod . invoke ( beanFactory , beanId ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 public void getRecordNotAvailable ( ) throws DataStoreException { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 DataRecord rec = dataStore . getRecordIfStored ( new DataIdentifier ( ID_PREFIX + 0 ) ) ; \n \n \t2 assertNull ( rec ) ; \n \n <ect>
\t2 ObjectName onContext = ObjectName . getInstance ( mBeanServerDefaultDomain + <string_literal> + managementName + <string_literal> + context . getName ( ) + <string_literal> ) ; \n \n \t2 TestCase . assertTrue ( <string_literal> , mBeanServer . isRegistered ( onContext ) ) ; \n \n \t2 <comment> \n \n \t2 ObjectName onManagedBean = ObjectName . getInstance ( mBeanServerDefaultDomain + <string_literal> + managementName + <string_literal> <string_literal> <ect>
\t3 config . setString ( <string_literal> , origin , <string_literal> , <string_literal> + origin + <string_literal> ) ; \n \n \t3 try { \n \n \t4 config . save ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 Map < String , Node > record = new HashMap < > ( ) ; \n \n \t3 Node entity = NodeFactory . createURI ( uriStr ) ; \n \n \t3 record . put ( docDef . getEntityField ( ) , entity ) ; \n \n \t3 for ( String f : docDef . fields ( ) ) { \n \n <ect>
\t2 if ( this . tokenRepository . exists ( uid , otp ) ) { \n \n \t3 throw new AccountExpiredException ( uid + <string_literal> + otp + <string_literal> ) ; } \n \n \t2 boolean isCodeValid = this . googleAuthenticatorInstance . authorize ( acct . getSecretKey ( ) , otp ) ; \n \n \t2 if ( ! isCodeValid && acct . getScratchCodes ( ) . contains ( otp ) ) { \n \n <ect>
\t2 for ( int i = 0 ; i < listeners . size ( ) ; ++ i ) { \n \n \t3 try { \n \n \t4 listeners . get ( i ) . onGoAwayReceived ( lastKnownStream , errorCode , debugData ) ; \n \n \t3 } catch ( Throwable cause ) { \n \n <ect>
\t5 ret . add ( layer ) ; \n \n \t4 } else { \n \n \t5 LOGGER . info ( <string_literal> + covName ) ; } \n \n \t3 } else { \n \n <ect>
\t3 if ( httpClient != null && getComponent ( ) . getConfig ( ) . getHttpClient ( ) != httpClient ) { \n \n \t4 final String endpointUri = getEndpointUri ( ) ; \n \n \t4 LOG . debug ( <string_literal> , endpointUri ) ; \n \n \t4 httpClient . stop ( ) ; \n \n <ect>
\t5 fileSystem . delete ( tempDir , true ) ; } } } } \n \n \t1 @ Override \n \n \t1 void prepareForWrite ( String workingDir , boolean isGlobal ) throws IOException { \n \n \t2 if ( ! fileSystem . exists ( basePath ) ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t3 upload ( user , path , description , file ) ; \n \n \t3 model . clear ( ) ; \n \n \t3 return <string_literal> + encodePathWithUTF8 ( path ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 try { \n \n \t3 for ( Relationship r : rels ) { \n \n \t4 result . add ( factory . instantiate ( r ) ) ; } \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t2 if ( logging ) \n \n \t2 { \n \n \t3 log . debug ( <string_literal> + this ) ; \n \n \t3 log . debug ( <string_literal> + y ) ; \n \n <ect>
\t3 CompositeStoppable . stoppable ( inputStream , outputStream ) . stop ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n \t3 if ( wasInterrupted ( t ) ) { \n \n \t4 return ; } \n \n <ect>
\t2 return new String ( encoded , <string_literal> ) ; } \n \n \t1 private InputStream getGraphizPdf ( String dotContents ) throws ClientProtocolException , IOException { \n \n \t2 HttpClient httpClient = new DefaultHttpClient ( ) ; \n \n \t2 String url = this . graphvizServer + <string_literal> ; \n \n <ect>
\t5 log . debug ( <string_literal> + message . getClass ( ) . getName ( ) ) ; } \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t5 @ Override \n \n \t5 public void postPayload ( AtmosphereResponse response , byte [ ] data , int offset , int length ) { } \n \n \t4 } ) ; \n \n \t3 } else { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t8 return replyData ; } \n \n \t7 logger . warn ( <string_literal> ) ; \n \n \t6 } else { \n \n \t7 logger . warn ( <string_literal> ) ; } \n \n <ect>
\t3 public Long getValue ( ) { \n \n \t4 try { \n \n \t5 return metrics . getCumulativeCount ( eventThunk . call ( ) ) ; \n \n \t4 } catch ( NoSuchFieldError error ) { \n \n <ect>
\t1 lb = LoadBalancers . getLoadbalancer ( accountNumber , lbName ) ; \n \n \t1 } catch ( NoSuchElementException ex ) { \n \n \t1 return ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t1 private static void createUsageRecord ( int usageType , long runningTime , Date startDate , Date endDate , AccountVO account , long vmId , String name , long zoneId , long virtualSize , \n \n \t3 long physicalSize ) { \n \n \t2 <comment> \n \n <ect>
\t1 @ Before \n \n \t1 @ Override \n \n \t1 public void setUp ( ) throws Exception { \n \n \t2 super . setUp ( ) ; \n \n <ect>
\t4 hasItem ( GatewayService . STATE_NOT_RECOVERED_BLOCK ) ) ; \n \n \t2 assertThat ( data2 . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) \n \n \t4 . getState ( ) . blocks ( ) . global ( ClusterBlockLevel . METADATA_WRITE ) , \n \n \t4 hasItem ( GatewayService . STATE_NOT_RECOVERED_BLOCK ) ) ; \n \n <ect>
\t2 long start = System . currentTimeMillis ( ) ; \n \n \t2 updateStats ( ) ; \n \n \t2 long elapsed = System . currentTimeMillis ( ) - start ; \n \n \t2 if ( elapsed > maxUpdateTime ) { \n \n <ect>
\t6 continue ; } \n \n \t5 AbstractExecutable executable = executableManager . getJob ( id ) ; \n \n \t5 if ( ! executable . isReady ( ) ) { \n \n \t6 final Output output = executableManager . getOutput ( id ) ; \n \n <ect>
<comment> \n \n \t1 byte [ ] decryptAESBlock ( byte encrypted [ ] , int offset , int encryptedLen , SessionKey key , byte iv [ ] , \n \n \t6 byte sentTag [ ] , Set < SessionTag > foundTags , SessionKey foundKey ) throws DataFormatException { \n \n <ect>
\t4 throw new IOException ( <string_literal> + f . getCanonicalPath ( ) ) ; } \n \n \t3 if ( this . serviceMap . containsKey ( service . getId ( ) ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , service . getId ( ) ) ; } \n \n \t3 this . serviceMap . put ( service . getId ( ) , service ) ; \n \n <ect>
\t4 broker . getManagementContext ( ) . newProxyInstance ( slowConsumerPolicyMBeanName , AbortSlowConsumerStrategyViewMBean . class , true ) ; \n \n \t2 TimeUnit . SECONDS . sleep ( <number_literal> ) ; \n \n \t2 TabularData slowOnes = abortPolicy . getSlowConsumers ( ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , slowOnes . size ( ) ) ; \n \n <ect>
\t1 LogLog . debug ( <string_literal> ) ; \n \n \t1 if ( loggers != null ) { \n \n \t2 for ( int i = 0 ; i < loggers . size ( ) ; i ++ ) { \n \n \t3 Logger l = ( Logger ) loggers . elementAt ( i ) ; \n \n <ect>
\t1 public void testNewApplication ( ) throws MalformedURLException \n \n \t1 { \n \n \t2 setWicketTester ( new WicketTester ( new TestWicketJavaEEApplication ( ) ) ) ; \n \n \t2 assertNotNull ( getWicketTester ( ) . getApplication ( ) ) ; \n \n <ect>
\t1 public void shutdown ( ) { \n \n \t2 this . shutdown ( false ) ; } \n \n \t1 private void shutdown ( boolean silent ) { \n \n \t2 if ( this == MondrianServerRegistry . INSTANCE . staticServer ) { \n \n <ect>
<comment> \n \n \t1 private void convertIsBlank ( E_IsBlank expr ) \n \n \t1 { \n \n <ect>
\t5 attachmentDocument = \n \n \t6 context . getWiki ( ) . getDocument ( attachmentReference . getDocumentReference ( ) , context ) ; \n \n \t5 valid = attachmentDocument . getAttachment ( attachmentReference . getName ( ) ) != null ; \n \n \t4 } catch ( XWikiException e ) { \n \n <ect>
\t2 noJdkZlibDecoder = SystemPropertyUtil . getBoolean ( <string_literal> , \n \n \t4 PlatformDependent . javaVersion ( ) < <number_literal> ) ; \n \n \t2 logger . debug ( <string_literal> , noJdkZlibDecoder ) ; \n \n \t2 noJdkZlibEncoder = SystemPropertyUtil . getBoolean ( <string_literal> , false ) ; \n \n <ect>
\t5 MyHomeSocketFactory . disconnect ( monitorSk ) ; \n \n \t4 } catch ( IOException e1 ) { } \n \n \t4 retry ++ ; \n \n \t4 Thread . sleep ( <number_literal> ) ; \n \n <ect>
\t1 public Set < Event > resolveInternal ( final RequestContext context ) { \n \n \t2 final RegisteredService service = resolveRegisteredServiceInRequestContext ( context ) ; \n \n \t2 final Authentication authentication = WebUtils . getAuthentication ( context ) ; \n \n \t2 if ( authentication == null ) { \n \n <ect>
\t2 assertEquals ( <string_literal> , reply ) ; \n \n \t2 assertMockEndpointsSatisfied ( ) ; \n \n \t2 assertTrue ( <string_literal> , latch . await ( <number_literal> , TimeUnit . SECONDS ) ) ; \n \n \t2 long delta = time . get ( ) ; \n \n <ect>
\t1 public Connection rollback ( boolean closeConnection ) { \n \n \t2 try { \n \n \t3 jdbcConnection . rollback ( ) ; } \n \n \t2 catch ( SQLException e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> ) ; \n \n \t3 try { \n \n \t4 socketTransportStarted . await ( ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t3 throws GridException { \n \n \t3 if ( result . getException ( ) != null ) \n \n \t4 throw result . getException ( ) ; \n \n \t3 if ( received . size ( ) == 1 ) { \n \n <ect>
\t2 super ( arg ) ; } \n \n \t1 <comment> \n \n \t1 @ Override public Serializable execute ( ) throws GridException { \n \n <ect>
\t2 reset ( ) ; \n \n \t2 Response response = client . target ( generateURL ( <string_literal> ) ) . request ( ) . get ( ) ; \n \n \t2 logger . info ( <string_literal> + response . getStatus ( ) ) ; \n \n \t2 Assert . assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n <ect>
\t4 zkClient = BlobStoreUtils . createZKClient ( conf ) ; \n \n \t4 nimbusInfos = Lists . newArrayList ( BlobStoreUtils . getNimbodesWithLatestSequenceNumberOfBlob ( zkClient , key ) ) ; \n \n \t4 Collections . shuffle ( nimbusInfos ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 logger . info ( <string_literal> + numOfMappings ) ; \n \n \t2 return candidateSteinerSets ; } \n \n \t1 private Set < SemanticTypeMapping > findSemanticTypeInGraph ( ColumnNode sourceColumn , SemanticType semanticType , \n \n \t3 HashMap < String , Integer > semanticTypesCount , Set < Node > addedNodes ) { \n \n <ect>
\t5 <comment> \n \n \t5 <comment> \n \n \t5 <comment> \n \n \t5 receivedShardExistsRequestLatch . countDown ( ) ; \n \n <ect>
\t2 isLogFilteredOut = ! inputLruCache . isEntryReplaceable ( logMessage , timestamp ) ; \n \n \t2 if ( ! isLogFilteredOut ) { \n \n \t2 inputLruCache . put ( logMessage , timestamp ) ; \n \n \t2 } else { \n \n <ect>
\t7 <string_literal> , name , softTimeOutSecs ) ; \n \n \t5 forcedStopFlag . set ( true ) ; \n \n \t5 if ( ! runPermit . tryAcquire ( hardTimeOut , TimeUnit . SECONDS ) ) { \n \n \t6 <comment> \n \n <ect>
\t3 if ( lineNum < 0 || lineNum > maxLine ) { \n \n \t4 logger . error ( <string_literal> , maxLine ) ; \n \n \t4 throw new LinePositionParseException ( <string_literal> + maxLine ) ; } \n \n \t3 if ( position < 0 || position > maxPostion ) { \n \n <ect>
\t2 public void processMessage ( Message message ) { \n \n \t3 StaticBuffer content = message . getContent ( ) ; \n \n \t3 assertEquals ( <number_literal> , content . length ( ) ) ; \n \n \t3 long value = content . getLong ( 0 ) ; \n \n <ect>
\t1 @ Override \n \n \t1 protected String extractPrincipalId ( final Credential credentials , final Principal currentPrincipal ) { \n \n \t2 final WsFederationCredential wsFedCredentials = ( WsFederationCredential ) credentials ; \n \n \t2 final Map < String , List < Object > > attributes = wsFedCredentials . getAttributes ( ) ; \n \n <ect>
\t5 future . get ( <number_literal> , TimeUnit . MILLISECONDS ) ; \n \n \t4 } catch ( ExecutionException e1 ) { \n \n \t5 <comment> \n \n \t4 } catch ( TimeoutException e1 ) { \n \n <ect>
\t4 catch ( IOException e ) { \n \n \t5 ioex = e ; } \n \n \t4 catch ( Throwable t ) { \n \n \t5 ioex = new IOException ( <string_literal> + t . getMessage ( ) , t ) ; \n \n <ect>
\t5 if ( System . getProperty ( <string_literal> ) != null && \n \n \t6 authorizationID . equals ( System . getProperty ( <string_literal> ) ) ) { \n \n \t6 cnxn . addAuthInfo ( new Id ( <string_literal> , <string_literal> ) ) ; } } } \n \n \t3 catch ( SaslException e ) { \n \n <ect>
\t1 final MemoryMonitorInfo memoryMonitorInfo ; \n \n \t1 if ( llapInfo != null ) { \n \n \t1 final int executorsPerNode ; \n \n \t1 if ( ! llapInfo . hasClusterInfo ( ) ) { \n \n <ect>
\t4 LOG . error ( <string_literal> , e ) ; } \n \n \t3 try { \n \n \t4 defaultQueryTimeout = stmt . getQueryTimeout ( ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t7 long before = System . currentTimeMillis ( ) ; \n \n \t7 _sessionListener . messageAvailable ( I2PSessionImpl . this , msgId . intValue ( ) , size . intValue ( ) ) ; \n \n \t7 long duration = System . currentTimeMillis ( ) - before ; \n \n \t7 if ( ( duration > <number_literal> ) && _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 try { \n \n \t3 MessageProducer messageProducer = getEndpoint ( ) . getJmsObjectFactory ( ) . createMessageProducer ( session , getEndpoint ( ) ) ; \n \n \t3 answer = new MessageProducerResources ( session , messageProducer , getCommitStrategy ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 socket = new DatagramSocket ( port , _bindAddress ) ; \n \n \t4 break ; \n \n \t3 } catch ( SocketException se ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t9 LOG . debug ( <string_literal> , mappingParameterEntry . getKey ( ) , Arrays . toString ( ( String [ ] ) paramValue ) ) ; \n \n \t8 } else if ( paramValue instanceof String ) { \n \n \t9 LOG . debug ( <string_literal> , mappingParameterEntry . getKey ( ) , paramValue . toString ( ) ) ; \n \n \t8 } else { \n \n <ect>
\t5 if ( waitingEvents . isEmpty ( ) ) { \n \n \t6 isRunning = false ; \n \n \t6 break ; } } } \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t2 Config config = configGroup . getConfigurations ( ) . get ( type ) ; \n \n \t2 if ( config != null ) { \n \n \t3 return true ; } } } \n \n \t1 } catch ( AmbariException ambariException ) { \n \n <ect>
\t4 s_logger . debug ( <string_literal> + templateVol . getVirtualSize ( ) + <string_literal> + size ) ; } \n \n \t3 final KVMPhysicalDisk primaryVol = storagePoolMgr . copyPhysicalDisk ( templateVol , volUuid , primaryPool , timeout ) ; \n \n \t3 return primaryVol ; \n \n \t2 } catch ( final CloudRuntimeException e ) { \n \n <ect>
\t1 public boolean upload ( final int idx ) { \n \n \t2 final String clusterName = context . getClusterName ( ) ; \n \n \t2 final TopologyMetricDataInfo summary = context . getMetricDataInfoFromCache ( idx ) ; \n \n \t2 if ( summary == null ) { \n \n <ect>
\t2 int cur = offset ; \n \n \t2 int flags = data [ cur ] & 0xff ; \n \n \t2 cur ++ ; \n \n \t2 <comment> \n \n <ect>
\t2 if ( posEstimate [ j ] != posExpected [ j ] ) { \n \n \t2 errorCount ++ ; } } } \n \n \t1 end = System . currentTimeMillis ( ) ; \n \n \t1 duration = ( end - start ) / <number_literal> . 0 ; \n \n <ect>
\t3 try { \n \n \t4 Thread . sleep ( <number_literal> ) ; \t1 \n \n \t3 } catch ( InterruptedException e ) { } } \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 final IBackend backend = createBackend ( data ) ; \n \n \t2 return backend ; } \n \n \t1 @ Override \n \n \t1 public synchronized IBackend createBuildBackend ( final RuntimeInfo info ) { \n \n <ect>
\t3 try { \n \n \t4 final PermanentBlobKey permanentBlobKey = blobWriter . putPermanent ( jobId , serializedValue . getByteArray ( ) ) ; \n \n \t4 return Either . Right ( permanentBlobKey ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 public InvalidateSnapshotProcessor ( ) { } \n \n \t3 @ Override \n \n \t3 public void processSnapshots ( EODatabaseContext dbc , EODatabase database , NSDictionary snapshots , SynchronizerSettings settings ) { \n \n <ect>
\t4 <comment> \n \n \t4 if ( length > <number_literal> ) \n \n \t5 ctx . profileOrganizer ( ) . selectHighCapacityPeers ( length - <number_literal> , exclude , matches ) ; \n \n \t4 if ( log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 BlockFamilyFactory newBlockFamilyFactory = ( BlockFamilyFactory ) blockFamilyFactory . newInstance ( ) ; \n \n \t4 registry . setBlockFamilyFactory ( id , newBlockFamilyFactory ) ; \n \n \t4 logger . debug ( <string_literal> , id ) ; \n \n \t3 } catch ( InstantiationException | IllegalAccessException e ) { \n \n <ect>
\t8 type = schemaManager . getAttributeType ( attr . getUpId ( ) ) ; \n \n \t8 oid = type . getOid ( ) ; } \n \n \t7 newChild . createAttribute ( oid , attr . getUpId ( ) , attr ) ; } \n \n \t5 } else { \n \n <ect>
<comment> \n \n public SchedulerHelper scheduleWithPeriod ( final long period , final TimeUnit timeUnit ) { \n \n \t1 notNull ( timeUnit ) ; \n \n <ect>
\t2 logger . info ( <string_literal> , filename ) ; \n \n \t2 try { \n \n \t3 hotspotMXBeanDumpHeap . invoke ( hotspotMXBean , filename , true ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 GenTezUtils . processDynamicSemiJoinPushDownOperator ( \n \n \t4 procCtx , pCtx . getRsToRuntimeValuesInfoMap ( ) . get ( rs ) , rs ) ; } } \n \n \t1 <comment> \n \n <ect>
\t2 if ( stateTypeCodec . accepts ( initCond ) ) { \n \n \t3 try { \n \n \t4 return stateTypeCodec . format ( initCond ) ; \n \n \t3 } catch ( RuntimeException e ) { \n \n <ect>
\t4 if ( ! ipmiPing ( ) ) { \n \n \t5 s_logger . warn ( <string_literal> + _ip ) ; \n \n \t5 return null ; } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 final int toReceive = toSend * numIterations * consumerCount * <number_literal> ; \n \n \t2 Wait . waitFor ( new Wait . Condition ( ) { \n \n \t3 @ Override \n \n \t3 public boolean isSatisified ( ) throws Exception { \n \n <ect>
\t4 execution . setAccumulators ( userAccumulators ) ; \n \n \t3 } else { \n \n \t4 LOG . debug ( <string_literal> , execID ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 log . debug ( <string_literal> ) ; \n \n \t2 beforeCompletionCount ++ ; } \n \n \t1 @ Override \n \n \t1 public void afterTransactionCompletion ( boolean successful , boolean delayed ) { \n \n <ect>
\t1 } else { \n \n \t2 if ( webUIPort < = 0 ) { \n \n \t2 LOG . info ( <string_literal> + webUIPort ) ; \n \n \t2 } else { \n \n <ect>
\t3 try { \n \n \t4 SmartLifecycle lifecycle = this . applicationContext . getBean ( lifecycleBeanName , SmartLifecycle . class ) ; \n \n \t4 addLifecycleToRole ( role , lifecycle ) ; } \n \n \t3 catch ( NoSuchBeanDefinitionException e ) { \n \n <ect>
\t5 next ++ ; } } } \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 printLevels ( ) ; \n \n \t2 printSpans ( ) ; \n \n <ect>
\t1 return ; } \n \n \t1 try { \n \n \t1 EucalyptusActivityTasks . getInstance ( ) . removeRoleFromInstanceProfile ( instanceProfileName , roleName , lb . useSystemAccount ( ) ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t3 cf . setBlocksize ( kylinConfig . getHbaseSmallFamilyBlockSize ( ) ) ; } \n \n \t2 String hbaseDefaultCC = kylinConfig . getHbaseDefaultCompressionCodec ( ) . toLowerCase ( ) ; \n \n \t2 switch ( hbaseDefaultCC ) { \n \n \t2 case <string_literal> : { \n \n <ect>
\t5 } catch ( IllegalArgumentException e ) { \n \n \t6 assertThat ( e . getMessage ( ) , containsString ( <string_literal> ) ) ; } } } \n \n \t2 } finally { \n \n \t3 if ( initBlocking ) { \n \n <ect>
\t1 Class . forName ( <string_literal> ) ; \n \n \t1 } catch ( ClassNotFoundException e ) { \n \n \t1 <comment> \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t1 private void deleteDirectory ( File dir ) { \n \n \t2 try { \n \n \t3 FileUtils . deleteDirectory ( dir ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 long startCssPathGen = System . currentTimeMillis ( ) ; \n \n \t2 result . setThemeCssFile ( personPagePropertiesDTOToCssUrlTransformer . transform ( result ) ) ; \n \n \t2 long end = System . currentTimeMillis ( ) ; \n \n \t2 log . debug ( <string_literal> + ( end - startCssPathGen ) + <string_literal> ) ; \n \n <ect>
\t2 importLdif ( ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 this . ldapServer = createLdapServer ( ) ; } \n \n \t1 public void start ( ) throws Exception { \n \n <ect>
\t3 out . closeEntry ( ) ; \n \n \t3 in . close ( ) ; } \n \n \t2 catch ( FileNotFoundException ex ) \n \n \t2 { \n \n <ect>
\t3 if ( fis != null ) { \n \n \t4 try { \n \n \t5 fis . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t1 LOG . error ( <string_literal> + snap . getSnapshotId ( ) + <string_literal> + diffPath , e ) ; \n \n \t1 try { \n \n \t2 boolean existed = Files . deleteIfExists ( diffPath ) ; \n \n \t2 if ( ! existed ) { \n \n <ect>
\t2 TitanBlueprintsTransaction tx = txs . get ( ) ; \n \n \t2 if ( tx != null && tx . isOpen ( ) ) throw Transaction . Exceptions . transactionAlreadyOpen ( ) ; \n \n \t2 tx = ( TitanBlueprintsTransaction ) newThreadBoundTransaction ( ) ; \n \n \t2 txs . set ( tx ) ; \n \n <ect>
\t1 public void doVerb ( MessageIn message , int id ) \n \n \t1 { \n \n \t2 if ( ! Gossiper . instance . isEnabled ( ) ) \n \n \t2 { \n \n <ect>
\t8 final Integer value = ( Integer ) field . get ( null ) ; \n \n \t8 mProjectResources . put ( value , Pair . of ( resType , field . getName ( ) ) ) ; \n \n \t8 resName2Id . put ( field . getName ( ) , value ) ; \n \n \t7 } else { \n \n <ect>
\t3 } else { \n \n \t4 final LocalDateTime etLocal = DateTimeUtils . localDateTimeOf ( this . endingDateTime ) ; \n \n \t4 if ( etLocal != null ) { \n \n \t5 if ( LocalDateTime . now ( ) . isAfter ( etLocal ) ) { \n \n <ect>
\t2 output = ssh . execute ( <string_literal> Virtio SCSI \\ <string_literal> ) \n \n \t2 self . assertTrue ( len ( output ) > 0 , <string_literal> ) \n \n \t2 output = ssh . execute ( <string_literal> ) \n \n \t2 for disk in output : \n \n <ect>
\t4 properties . setProperty ( <string_literal> , DateTimeUtils . formatDateToW3C ( GregorianCalendar ( ) . time ) ) \n \n \t4 properties . setProperty ( <string_literal> , edition ) \n \n \t4 properties . store ( FileOutputStream ( sysFile ) , <string_literal> ) } \n \n \t2 } catch ( e : IOException ) { \n \n <ect>
\t8 OUTPUT . getName ( ) . substring ( 0 , OUTPUT . getName ( ) . length ( ) - <number_literal> ) + <string_literal> ) ; \n \n \t6 final File oldIndex = new File ( soleInput . getParent ( ) , \n \n \t8 soleInput . getName ( ) . substring ( 0 , soleInput . getName ( ) . length ( ) - <number_literal> ) + <string_literal> ) ; \n \n \t6 if ( ! newIndex . renameTo ( oldIndex ) ) { \n \n <ect>
\t5 c = new Connection ( host , port , key ) ; \n \n \t5 connected = true ; \n \n \t5 logger . debug ( <string_literal> ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t6 if ( storagePool == null ) { \n \n \t7 s_logger . debug ( <string_literal> ) ; \n \n \t7 throw new UnableDeleteHostException ( <string_literal> ) ; } \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t1 saved += VALUE_LENGTH_LIMIT ; \n \n \t1 page += 1 ; \n \n \t1 LOG . debug ( <string_literal> + modelPropName + <string_literal> + page + <string_literal> + substring ) ; } \n \n \t1 getConfig ( ) . setProperty ( modelPropName , page - 1 ) ; \n \n <ect>
\t6 req . setTwoWay ( true ) ; \n \n \t6 req . setEvent ( Request . HEARTBEAT_EVENT ) ; \n \n \t6 channel . send ( req ) ; \n \n <ect>
\t5 { \n \n \t6 client . login ( new AuthenticationRequest ( credentials ) ) ; } \n \n \t5 catch ( AuthenticationException e ) \n \n \t5 { \n \n <ect>
\t5 throw new RuntimeException ( <string_literal> , ( Throwable ) jobException ) ; } } } } \n \n \t1 private void orchestrateMigrateAway ( final String vmUuid , final long srcHostId , final DeploymentPlanner planner ) throws InsufficientServerCapacityException { \n \n \t2 final VMInstanceVO vm = _vmDao . findByUuid ( vmUuid ) ; \n \n \t2 if ( vm == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 Integer timeout = localSessionsWithTimeouts . remove ( sessionId ) ; \n \n \t2 if ( timeout != null ) { \n \n <ect>
\t1 if ( principalEntity != null ) { \n \n \t1 principalEntity . removePrivilege ( privilegeEntity ) ; } \n \n \t1 privilegeDAO . remove ( privilegeEntity ) ; } \n \n public void uninstallViewInstance ( ViewInstanceEntity instanceEntity ) { \n \n <ect>
\t3 throw new InvalidParameterValueException ( <string_literal> + routerId + <string_literal> ) ; } \n \n \t2 _accountMgr . checkAccess ( caller , null , true , router ) ; \n \n \t2 <comment> \n \n \t2 if ( router == null || router . getState ( ) != VirtualMachine . State . Running ) { \n \n <ect>
<number_literal> if ( destB64 != null && ! destB64 . equals ( ahelperKey ) ) { \n \n <number_literal> <comment> \n \n <number_literal> ahelperConflict = true ; \n \n <number_literal> if ( _log . shouldLog ( Log . WARN ) ) { \n \n <ect>
\t2 return False \n \n \t1 def check_llap_app_status_in_llap_ga ( self , llap_app_name , num_retries , return_immediately_if_stopped = False ) : \n \n \t1 curr_time = time . time ( ) \n \n \t1 total_timeout = int ( num_retries ) * <number_literal> ; # Total wait time while checking the status via llapstatus command \n \n <ect>
\t5 Boolean . toString ( this . thread != null && this . thread . isAlive ( ) ) ) ; \n \n \t3 if ( this . thread != null && this . thread . isAlive ( ) ) { \n \n \t4 long timePassed = ( this . lastActivity == 0 ) ? 0 : System . currentTimeMillis ( ) - this . lastActivity ; \n \n \t4 if ( timePassed > SatelModule . this . timeout ) { \n \n <ect>
<comment> \n \n \t1 private static boolean containsAddress ( final InetAddress network , final InetAddress netmask , final InetAddress ip ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t4 log . info ( <string_literal> + cmd + <string_literal> + line + <string_literal> ) ; \n \n \t3 if ( STORED . equals ( line ) ) { \n \n <ect>
\t1 private ThreadPoolExecutor concurrentExecutor = null ; \n \n \t1 private ResourcesDownloader ( ) { \n \n \t2 init ( ) ; } \n \n \t1 private void init ( ) { \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 throw new BlockStoreException ( e ) ; } \n \n \t2 try { \n \n <ect>
<comment> \n \n \t1 @ JmxOperation ( description = <string_literal> ) \n \n \t1 public void swapFiles ( String newStoreDirectory ) { \n \n <ect>
\t2 return resource ; } \n \n \t1 private void validateVswitchType ( String inputVswitchType ) { \n \n \t2 VirtualSwitchType vSwitchType = VirtualSwitchType . getType ( inputVswitchType ) ; \n \n \t2 if ( vSwitchType == VirtualSwitchType . None ) { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t2 if ( sourceNode == null ) { \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t3 return Collections . EMPTY_LIST ; } \n \n \t2 if ( modifiedNode == null ) { \n \n <ect>
\t4 synchronized ( _activeCheckers ) { \n \n \t5 UpdateTask t = r . checker . check ( type , r . method , id , current , DEFAULT_CHECK_TIME ) ; \n \n \t5 if ( t != null ) { \n \n \t6 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
<comment> \n \n \t1 startup ( ) ; } \n \n private void doTest ( ) throws Exception { \n \n \t1 TaskRunner runner = new TaskRunner ( NUM_THREADS ) ; \n \n <ect>
\t3 builder . setPeerPublicValue ( Y ) ; \n \n \t3 return builder ; \n \n \t2 } catch ( InvalidPublicParameterException ippe ) { \n \n \t3 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t4 s_logger . debug ( <string_literal> + allMS . size ( ) + <string_literal> + allManagedAgents . size ( ) ) ; } \n \n \t3 return ; } \n \n \t2 if ( avLoad == 0L ) { \n \n <ect>
\t5 ps . setClob ( paramIndex , ( Clob ) null ) ; } } \n \n \t3 else { \n \n \t4 ps . setString ( paramIndex , content ) ; } \n \n <ect>
\t6 throw new RuntimeException ( e ) ; <comment> \n \n \t4 notifyNewBestBlock ( block ) ; } \n \n \t3 isConsistentOrThrow ( ) ; \n \n \t3 final Coin balance = getBalance ( ) ; \n \n <ect>
\t5 InputStream is = getClass ( ) . getResourceAsStream ( <string_literal> ) ; \n \n \t5 StreamUtil . io ( is , os , true , true ) ; \n \n \t5 log . warn ( <string_literal> + configLocation . getAbsolutePath ( ) ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 exceptions . put ( exception , instance ) ; \n \n \t2 return proxifier . proxify ( Result . class , instance ) ; } \n \n \t1 @ Override \n \n \t1 public ExceptionRecorder < Result > findByException ( Exception e ) { \n \n <ect>
\t1 else \n \n \t1 { \n \n \t2 if ( DEBUG ) \n \n \t2 { \n \n <ect>
\t6 if ( notAcceptedBuckets . contains ( partitionReplicaTuple ) ) { \n \n \t7 throw new VoldemortException ( <string_literal> \n \n <number_literal> + fileEntry . getFileName ( ) \n \n <number_literal> + <string_literal> ) ; } } \n \n <ect>
\t3 s_logger . warn ( <string_literal> + userVm . getInstanceName ( ) + <string_literal> + host . getName ( ) , e ) ; \n \n \t3 return ; } \n \n \t2 if ( diskStatsAnswer != null ) { \n \n \t3 if ( ! diskStatsAnswer . getResult ( ) ) { \n \n <ect>
\t3 implemented . setBroadcastUri ( new URI ( <string_literal> , answer . getLogicalSwitchUuid ( ) , null ) ) ; \n \n \t3 implemented . setBroadcastDomainType ( BroadcastDomainType . Lswitch ) ; \n \n \t3 s_logger . info ( <string_literal> + implemented . getBroadcastUri ( ) . toString ( ) ) ; \n \n \t2 } catch ( final URISyntaxException e ) { \n \n <ect>
\t5 s_logger . info ( <string_literal> ) ; \n \n \t5 context . registerStockObject ( <string_literal> , vsmCredentials ) ; } } \n \n \t3 List < ManagedObjectReference > morHosts = _vmwareMgr . addHostToPodCluster ( context , dcId , podId , clusterId , URLDecoder . decode ( url . getPath ( ) , <string_literal> ) ) ; \n \n \t3 if ( morHosts == null ) \n \n <ect>
\t3 if ( useByteArrayStdConsumer ) { \n \n \t4 stdoutConsumer = new ByteArrayOutputStreamConsumer ( process . getInputStream ( ) , params ) ; \n \n \t4 bo = stdoutConsumer . getBuffer ( ) ; \n \n \t3 } else if ( params . input_pipes [ 0 ] != null ) { \n \n <ect>
\t4 StringBuffer destinations = new StringBuffer ( ) ; \n \n \t4 for ( ActiveMQDestination dest : result ) { \n \n \t5 destinations . append ( destinations . length ( ) > 0 ? <string_literal> : <string_literal> ) ; \n \n \t5 destinations . append ( dest . getPhysicalName ( ) ) ; } \n \n <ect>
\t3 LOGGER . error ( e . getMessage ( ) , e ) ; \n \n \t3 return new ResponseEntity < > ( e . getMessage ( ) , HttpStatus . BAD_REQUEST ) ; } } \n \n \t1 private boolean isAuthenticatedPrincipalAuthorized ( final Authentication auth ) { \n \n \t2 final Map < String , Object > attributes = auth . getPrincipal ( ) . getAttributes ( ) ; \n \n <ect>
\t3 public void removedService ( ServiceReference webContainerServiceReference , Object service ) { \n \n \t4 WebContainer ourWebContainer = ( WebContainer ) bundleContext . getService ( webContainerServiceReference ) ; \n \n \t4 String alias = getAlias ( ) ; \n \n \t4 ourWebContainer . unregister ( alias ) ; \n \n <ect>
\t6 PeerProfile profile = _context . profileOrganizer ( ) . getProfile ( cur ) ; \n \n \t6 if ( profile != null ) { \n \n \t7 RateStat invalidReplyRateStat = profile . getDBHistory ( ) . getInvalidReplyRate ( ) ; \n \n \t7 Rate invalidReplyRate = invalidReplyRateStat . getRate ( <number_literal> * <number_literal> * 1000l ) ; \n \n <ect>
\t4 ProvisioningActivator . getConfigurationService ( ) . \n \n \t5 reloadConfiguration ( ) ; } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n <ect>
\t5 conf = FileUtils . readFileToString ( file ) ; \n \n \t4 } catch ( IOException ex ) { \n \n \t5 return null ; } \n \n \t3 } else { \n \n <ect>
\t5 logger . warn ( <string_literal> + line ) ; } \n \n \t3 } else { \n \n \t4 logger . warn ( <string_literal> + line ) ; } \n \n \t2 } else { \n \n <ect>
\t4 selectedVol = _netappAllocator . chooseLeastFullVolumeFromPool ( poolName , lunSize ) ; } \n \n \t3 if ( selectedVol == null ) { \n \n \t4 throw new ServerException ( <string_literal> ) ; } \n \n <ect>
\t1 if ( ! ( KerberosToken . class . isAssignableFrom ( traceTokenType ) ) ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t4 if ( changesWerePending ) { \n \n \t5 <comment> \n \n \t5 broadcastRefreshUI ( TodoApplication . app . localBroadCastManager ) } \n \n \t3 } catch ( e : Exception ) { \n \n <ect>
\t1 private byte [ ] copyFileWithCheckSum ( HdfsFile source , File dest , CheckSumType checkSumType ) \n \n \t3 throws IOException { \n \n \t2 byte [ ] checkSum = null ; \n \n \t2 CheckSum bufferCheckSumGenerator = null ; \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , ticketId ) ; \n \n \t3 final Ticket ticket = this . dbTableService . get ( ticketId , encTicketId ) ; \n \n \t3 final Ticket decodedTicket = decodeTicket ( ticket ) ; \n \n \t3 if ( decodedTicket == null || decodedTicket . isExpired ( ) ) { \n \n <ect>
\t3 return ; } \n \n \t2 if ( timeDiff < 0 - MAX_REQUEST_FUTURE ) { \n \n \t3 _context . statManager ( ) . addRateData ( <string_literal> , 1 ) ; \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 results = ( NSArray < er . neo4jadaptor . test . eo . FirstEntity > ) EOSortOrdering . sortedArrayUsingKeyOrderArray ( results , sortOrderings ) ; } \n \n \t1 return results ; } \n \n public void addToJoins_firstEntityRelationship ( er . neo4jadaptor . test . eo . FirstEntity object ) { \n \n <ect>
\t3 if ( ResponseParser . isSuccessfulLoginResponse ( line ) ) { \n \n \t4 logger . debug ( <string_literal> , line ) ; \n \n \t4 return ; } \n \n \t3 if ( ResponseParser . isDeviceState ( line ) ) { \n \n <ect>
\t2 try { \n \n \t3 q = Double . parseDouble ( qStr ) ; \n \n \t2 } catch ( NumberFormatException ex ) \n \n \t2 { \n \n <ect>
\t3 return DateTimeUtils . zonedDateTimeOf ( file . lastModified ( ) ) ; } \n \n \t2 if ( <string_literal> . equals ( resource . getProtocol ( ) ) ) { \n \n \t3 final File file = new VfsResource ( resource . openConnection ( ) . getContent ( ) ) . getFile ( ) ; \n \n \t3 return DateTimeUtils . zonedDateTimeOf ( file . lastModified ( ) ) ; } \n \n <ect>
\t4 HttpCatClient . sendMetric ( topology . get_name ( ) , topology . get_name ( ) + <string_literal> , <string_literal> , String . valueOf ( topologyTPS ) ) ; } \n \n \t3 HttpCatClient . sendMetric ( <string_literal> , <string_literal> , <string_literal> , String . valueOf ( clusterTPS ) ) ; \n \n \t2 } catch ( TException e ) { \n \n \t3 initClient ( configMap ) ; \n \n <ect>
\t2 return true ; } \n \n \t1 @ Override \n \n \t1 public boolean applyPFRules ( Network network , List < PortForwardingRule > rules ) throws ResourceUnavailableException { \n \n \t2 if ( ! _networkModel . isProviderSupportServiceInNetwork ( network . getId ( ) , Service . PortForwarding , Provider . CiscoVnmc ) ) { \n \n <ect>
\t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( 0 ) . currentNodeId ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 clusterState = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n <ect>
class AuthenticationManagerAllowAll extends AuthenticationManager { \n \n \t1 private static final Logger log = LoggerFactory . getLogger ( AuthenticationManagerAllowAll . class ) ; \n \n \t1 @ JsonCreator \n \n \t1 public AuthenticationManagerAllowAll ( ) { \n \n <ect>
\t5 added = true ; \n \n \t5 tasks . addTask ( UUIDs . base64UUID ( ) , TestPersistentTasksExecutor . NAME , new TestParams ( <string_literal> ) , \n \n \t7 new Assignment ( <string_literal> , <string_literal> ) ) ; } } } \n \n \t2 if ( added == false ) { \n \n <ect>
\t4 FileSystem fs = p . getFileSystem ( conf ) ; \n \n \t4 addInputPathRecursively ( result , fs , p , hiddenFileFilter ) ; \n \n \t3 } else { \n \n \t4 result . add ( file ) ; } } \n \n <ect>
\t3 diagonalMatrix . set ( i + 1 , i , norms . get ( i ) ) ; \n \n \t3 i ++ ; } \n \n \t2 diagonalMatrix . set ( i , i , projections . get ( i ) ) ; } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t5 messageToSend = ( converted instanceof Message < ? > ) ? ( Message < ? > ) converted \n \n \t7 : this . messageBuilderFactory . withPayload ( converted ) . build ( ) ; \n \n \t5 this . dispatcher . dispatch ( messageToSend ) ; } \n \n <ect>
\t5 visitRevNode ( g , s , currentComponent ) ; } } } \n \n \t2 componentList = Collections . unmodifiableList ( componentList ) ; \n \n \t2 if ( Options . v ( ) . verbose ( ) ) \n \n \t2 { \n \n <ect>
\t2 awaitOnClose ( CloseCodes . CLOSED_ABNORMALLY , CloseCodes . NORMAL_CLOSURE ) ; } \n \n \t1 public static class TestEndpoint { \n \n \t2 @ OnOpen \n \n \t2 public void onOpen ( ) { \n \n <ect>
\t1 void observeLeader ( ) throws Exception { \n \n \t2 zk . registerJMX ( new ObserverBean ( this , zk ) , self . jmxLocalPeerBean ) ; \n \n \t2 try { \n \n \t3 QuorumServer leaderServer = findLeader ( ) ; \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 @ Override \n \n \t1 public boolean login ( ) throws LoginException { \n \n \t2 if ( super . login ( ) ) { \n \n <ect>
\t7 SamlRegisteredServiceCachingMetadataResolver . class ) ; \n \n \t3 final Optional < SamlRegisteredServiceServiceProviderMetadataFacade > facade = \n \n \t5 SamlRegisteredServiceServiceProviderMetadataFacade . get ( resolver , saml , entityId ) ; \n \n \t3 if ( facade == null || ! facade . isPresent ( ) ) { \n \n <ect>
\t6 queued ++ ; \n \n \t5 <comment> \n \n \t3 if ( queued == 0 && _state . getPending ( ) . isEmpty ( ) ) { \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t5 TranslateOption . targetLanguage ( targetLanguage ) \n \n \t4 ) ; \n \n \t4 return translation . translatedText ( ) ; \n \n \t3 } catch ( TranslateException te ) { \n \n <ect>
\t2 Whiteboard whiteboard = null ; \n \n \t2 if ( provider instanceof WhiteboardAware ) { \n \n \t3 whiteboard = ( ( WhiteboardAware ) provider ) . getWhiteboard ( ) ; \n \n \t2 } else { \n \n <ect>
\t4 s_logger . warn ( <string_literal> + agentId + <string_literal> + ( ( answer != null ) ? answer . getDetails ( ) : <string_literal> ) ) ; } \n \n \t2 } catch ( AgentUnavailableException e ) { \n \n \t3 s_logger . warn ( <string_literal> + agentId + <string_literal> , e ) ; \n \n \t2 } catch ( OperationTimedoutException e ) { \n \n <ect>
\t2 webhcatPort = MetaStoreTestUtils . findFreePort ( ) ; } \n \n \t2 templetonBaseUrl = templetonBaseUrl . replace ( <string_literal> , Integer . toString ( webhcatPort ) ) ; \n \n \t2 templetonServer = new Main ( new String [ ] { <string_literal> + AppConfig . UNIT_TEST_MODE + <string_literal> , \n \n \t3 <string_literal> + AppConfig . PORT + <string_literal> + webhcatPort } ) ; \n \n <ect>
\t5 <comment> \n \n \t5 while ( state == State . INITIAL ) { \n \n \t6 wait ( <number_literal> ) ; } \n \n \t4 } catch ( InterruptedException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 for ( File file : getFiles ( ) ) { \n \n \t4 if ( file . exists ( ) ) { \n \n <ect>
\t4 { \n \n \t5 logger . error ( <string_literal> , e ) ; } \n \n \t4 catch ( ConfigurationException e ) \n \n \t4 { \n \n <ect>
\t4 if ( isNotBlank ( e . getMessage ( ) ) ) { \n \n \t5 LOGGER . debug ( <string_literal> , e . bytesTransferred , e . getMessage ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t1 public void testGenericType ( ) throws Exception { \n \n \t2 GenericType < List < String > > stringListType = new GenericType < List < String > > ( ) { \n \n \t2 } ; \n \n \t2 logger . info ( <string_literal> + stringListType . getType ( ) ) ; \n \n <ect>
\t3 read . start ( ) ; \n \n \t3 <comment> \n \n \t3 write . start ( ) ; } \n \n \t2 _beginTest = true ; \n \n <ect>
\t2 service . registerRequestInterceptor ( this ) ; } \n \n \t1 @ Override \n \n \t1 public void onEnd ( String requestId , boolean succeeded , \n \n \t5 Exception failure ) { \n \n <ect>
\t5 sendPing ( ) ; \n \n \t4 } catch ( InterruptedException ix ) { \n \n \t5 interrupted ( ) ; \n \n \t4 } catch ( Exception x ) { \n \n <ect>
\t2 clusterState = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 routingNodes = clusterState . getRoutingNodes ( ) ; \n \n \t2 clusterState = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) ; \n \n <ect>
\t5 Properties tmp = new Properties ( ) ; \n \n \t5 tmp . load ( fis ) ; \n \n \t5 jmeterProps . putAll ( tmp ) ; \n \n \t4 } catch ( FileNotFoundException e ) { <comment> \n \n <ect>
\t2 for ( Callback c : callbacks ) { \n \n \t3 if ( c instanceof NameCallback ) { \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t3 } else if ( c instanceof PasswordCallback ) { \n \n <ect>
\t3 Collection < User > users = getRecipients ( alerts ) ; \n \n \t3 <comment> \n \n \t3 Context . getMessageService ( ) . sendMessage ( message , users ) ; } \n \n \t2 catch ( MessageException e ) { \n \n <ect>
\t1 this . roundUnit = Calendar . MINUTE ; \n \n \t1 } else if ( unit . equalsIgnoreCase ( Config . SECOND ) ) { \n \n \t1 this . roundUnit = Calendar . SECOND ; \n \n \t1 } else { \n \n <ect>
\t4 processedLatch . release ( children . size ( ) ) ; \n \n \t4 break ; } \n \n \t3 if ( ! itemNode . startsWith ( QUEUE_ITEM_NAME ) ) \n \n \t3 { \n \n <ect>
\t2 <comment> \n \n \t2 validateMethod = ReflectionUtils . findMethod ( model . getClass ( ) , <string_literal> , Errors . class ) ; \n \n \t2 if ( validateMethod != null ) { \n \n <ect>
\t4 if ( ! exec . awaitTermination ( 1 , TimeUnit . MINUTES ) ) \n \n \t5 logger . warn ( <string_literal> ) ; } \n \n \t3 catch ( InterruptedException e ) \n \n \t3 { \n \n <ect>
\t2 if ( namespaces != null || schemaLocation != null ) { \n \n \t3 return ; } \n \n \t2 String myAlias = getPluginInstanceName ( ) ; \n \n \t2 if ( myAlias == null ) { \n \n <ect>
<comment> \n \n \t1 public synchronized void releaseRebalancingPermit ( int nodeId ) { \n \n \t2 boolean removed = rebalancePermits . remove ( nodeId ) ; \n \n <ect>
<comment> \n \n \t1 protected boolean doRequiredAttributesAllowPrincipalAccess ( final Map < String , Object > principalAttributes , final Map < String , Set < String > > requiredAttributes ) { \n \n <ect>
\t3 modelLearner = new ModelLearner ( ontologyManager , alignment . getLinksByStatus ( LinkStatus . ForcedByUser ) , steinerNodes ) ; \n \n <comment> \n \n \t2 SemanticModel model = modelLearner . getModel ( ) ; \n \n \t2 if ( model == null ) { \n \n <ect>
\t5 task . getLink ( ) . send ( response . toBytes ( ) ) ; \n \n \t4 } catch ( final ClosedChannelException e ) { \n \n \t5 s_logger . warn ( <string_literal> + response . toString ( ) ) ; } } \n \n \t2 } else { \n \n <ect>
\t3 fc . put ( segments [ <number_literal> ] ) ; \n \n \t3 Assert . fail ( <string_literal> ) ; \n \n \t2 } catch ( IOException ioe ) { } \n \n \t2 tar . join ( ) ; \n \n <ect>
\t3 Logger . error ( this , <string_literal> + e + <string_literal> + raf , e ) ; \n \n \t3 throw new FetchException ( FetchExceptionMode . BUCKET_ERROR , e ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 raf . free ( ) ; \n \n <ect>
\t2 if ( TestCaseEngine . s_printUrl == true ) { \n \n \t3 s_logger . info ( <string_literal> + this . command ) ; } \n \n \t2 if ( this . getCommandType ( ) == CommandType . SCRIPT ) { \n \n \t3 try { \n \n <ect>
\t1 return policy ; } \n \n private String fetchResponseFromRanger ( String rangerUrl , String username , String password , String database , String table ) { \n \n \t1 String serviceName = context . getProperties ( ) . get ( <string_literal> ) ; \n \n \t1 if ( StringUtils . isEmpty ( serviceName ) ) { \n \n <ect>
\t2 try { \n \n \t3 PropertyUtils . storeToFile ( properties , str , metaFilename ) ; } \n \n \t2 catch ( IOException ex ) \n \n \t2 { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t4 log . info ( <string_literal> ) ; } \n \n \t3 if ( options . length == 0 ) { \n \n \t4 log . info ( <string_literal> ) ; } \n \n \t3 else { \n \n <ect>
\t3 } else { \n \n \t4 externalLoadBalancer = _hostDao . findById ( lbDeviceVO . getHostId ( ) ) ; } } \n \n \t2 boolean externalLoadBalancerIsInline = _networkMgr . isNetworkInlineMode ( network ) ; \n \n \t2 if ( network . getState ( ) == Network . State . Allocated ) { \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
public DeleteStorageVolumeResponseType DeleteStorageVolume ( DeleteStorageVolumeType request ) throws EucalyptusCloudException { \n \n \t1 final long startTime = System . currentTimeMillis ( ) ; \n \n \t1 DeleteStorageVolumeResponseType reply = ( DeleteStorageVolumeResponseType ) request . getReply ( ) ; \n \n \t1 if ( ! StorageProperties . enableStorage ) { \n \n <ect>
\t2 String result = CmsStringUtil . substitute ( PATTERN , key , this ) ; \n \n \t2 if ( result . equals ( key ) ) { \n \n \t3 return Optional . absent ( ) ; \n \n \t2 } else { \n \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onUnblock ( JSONObject source , JSONObject target , StreamListener [ ] listeners ) throws TwitterException { \n \n \t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onRetweetedRetweet ( JSONObject source , JSONObject target , JSONObject targetObject , StreamListener [ ] listeners ) throws TwitterException { \n \n <ect>
\t1 Map < String , Collection < DependencyInfo > > missingDependencies = new HashMap < > ( ) ; \n \n \t1 for ( String component : new HashSet < > ( group . getComponentNames ( ) ) ) { \n \n \t1 LOGGER . debug ( <string_literal> , component ) ; \n \n \t1 for ( DependencyInfo dependency : stack . getDependenciesForComponent ( component ) ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <string_literal> ) \n \n \t3 . execute ( ) . actionGet ( ) ; \n \n \t2 assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; \n \n <ect>
\t2 eventList . add ( event ) ; \n \n \t2 log . info ( <string_literal> + event ) ; } \n \n \t1 public void processWrite ( @ Observes @ EventsProcess @ EventsWrite ( context = <string_literal> ) String event ) { \n \n \t2 eventList . add ( event ) ; \n \n <ect>
\t1 nettyChannel = serverBootstrap . bind ( new InetSocketAddress ( host , port ) ) ; } \n \n \t1 super . start ( ) ; } \n \n @ Override \n \n public void stop ( ) { \n \n <ect>
\t2 KylinLogExtractor logExtractor = new KylinLogExtractor ( ) ; \n \n \t2 logger . info ( <string_literal> + Arrays . toString ( logsArgs ) ) ; \n \n \t2 logExtractor . execute ( logsArgs ) ; } \n \n \t1 private void extractResources ( File destDir ) { \n \n <ect>
\t4 if ( succ ) { \n \n \t5 LOG . debug ( <string_literal> + file . toString ( ) + <string_literal> ) ; } \n \n \t4 } else { \n \n <ect>
\t2 <string_literal> <string_literal> <string_literal> \n \n \t2 # Validate the following \n \n \t2 # 1 . Creating VPC Offering with services NOT supported by VPC \n \n \t2 # \t1 like Firewall should not be allowed \n \n <ect>
\t2 if ( getSampleFrequency ( ) != null && getSampleFrequency ( ) . length ( ) > 0 ) { \n \n \t3 try { \n \n \t4 sr = Integer . parseInt ( getSampleFrequency ( ) ) ; \n \n \t3 } catch ( NumberFormatException e ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 session . enableFilter ( <string_literal> ) . setParameter ( <string_literal> , <string_literal> ) ; \n \n \t2 departments = departmentsQuery . list ( ) ; \n \n \t2 assertEquals ( <string_literal> , 0 , departments . size ( ) ) ; \n \n <ect>
\t2 String path = \n \n \t3 URI . create ( DELIMITER + SKINS_DIRECTORY + DELIMITER + skin + DELIMITER + filename ) . normalize ( ) . toString ( ) ; \n \n \t2 <comment> \n \n \t2 if ( ! path . startsWith ( DELIMITER + SKINS_DIRECTORY ) ) { \n \n <ect>
<comment> \n \n \t1 public final void enter ( RequestControlContext context ) throws FlowExecutionException { \n \n <ect>
\t1 public void tearDown ( ) { \n \n \t2 CallContext . unregister ( ) ; } \n \n \t1 @ Test \n \n \t1 public void testDedicatePublicIpRange ( ) throws Exception { \n \n <ect>
\t8 warn ( <string_literal> , PigWarning . UNABLE_TO_CLOSE_SPILL_FILE , e ) ; } } } } \n \n \t4 <comment> \n \n \t4 for ( File f : filesToDelete ) { \n \n \t5 if ( f . delete ( ) == false ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t4 public void handleResponse ( Version0Response response ) { \n \n \t5 assertThat ( response . value1 , equalTo ( 1 ) ) ; } \n \n \t4 @ Override \n \n \t4 public void handleException ( TransportException exp ) { \n \n <ect>
public boolean updateConfigIfNeeded ( SolrPropsConfig solrPropsConfig , SolrZkClient zkClient , File file , \n \n \t9 String separator , String downloadFolderLocation ) throws IOException { \n \n \t1 boolean result = false ; \n \n \t1 if ( ! FileUtils . contentEquals ( file , new File ( String . format ( <string_literal> , downloadFolderLocation , separator , file . getName ( ) ) ) ) ) { \n \n <ect>
\t2 private int sent ; \n \n \t2 @ Override \n \n \t2 public void notify ( EventObject event ) throws Exception { \n \n \t3 if ( event instanceof ExchangeSendingEvent ) { \n \n <ect>
\t2 assertThrows ( client . admin ( ) . cluster ( ) . prepareGetRepositories ( <string_literal> ) , RepositoryMissingException . class ) ; \n \n \t2 assertThat ( client . admin ( ) . cluster ( ) . prepareGetRepositories ( <string_literal> ) . get ( ) . repositories ( ) . size ( ) , equalTo ( 1 ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 ClusterState clusterState = client . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testBeforeAfterTimestamp ( ) { \n \n <ect>
\t8 _storagePoolDao . update ( pool . getId ( ) , pool ) ; } } \n \n \t5 } catch ( StorageUnavailableException e ) { \n \n \t6 s_logger . info ( <string_literal> + pool , e ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t4 from ( <string_literal> ) . \n \n \t6 marshal ( ) . xstream ( PurchaseOrder . class ) . \n \n \t6 process ( new Processor ( ) { \n \n \t7 public void process ( Exchange exchange ) throws Exception { \n \n <ect>
\t2 connected = false ; \n \n \t2 logger . debug ( <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void deactivate ( ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 b . connect ( a , trust , visibility ) ; \n \n \t2 } catch ( FSParseException e ) { \n \n \t3 Logger . error ( RealNodeTest . class , <string_literal> , e ) ; \n \n \t2 } catch ( PeerParseException e ) { \n \n <ect>
\t2 abortIfNeeded ( ) ; \n \n \t2 this . markPoint += bytesReadPastMarkPoint ; \n \n \t2 this . bytesReadPastMarkPoint = 0 ; \n \n <ect>
\t2 if ( finished ) \n \n \t3 return ; \n \n \t2 try { closeIterator ( ) ; } \n \n \t2 catch ( QueryException ex ) \n \n <ect>
\t4 log . error ( <string_literal> , vex ) ; \n \n \t4 for ( Entry < String , String > validationError : vex . getErrors ( ) . entrySet ( ) ) \n \n \t4 { \n \n \t5 valEx . addError ( validationError . getKey ( ) , validationError . getValue ( ) ) ; \n \n <ect>
\t3 return new Answer ( cmd , false , msg ) ; } \n \n \t2 return new Answer ( cmd ) ; } \n \n \t1 protected Answer execute ( final DhcpEntryCommand cmd ) { \n \n <ect>
\t3 try { \n \n \t4 if ( frameRateNumber != null ) { \n \n \t5 interpreter . set ( <string_literal> , Double . parseDouble ( frameRateNumber ) ) ; } \n \n \t3 } catch ( NumberFormatException e ) { \n \n <ect>
\t3 result . success = o ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 jndi . getContext ( ) ; \n \n \t3 return jndi ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t2 this . scoringFunction = new DefaultScorer ( vehicleRoutingProblem ) ; \n \n \t2 this . insertionCostsCalculator = jobInsertionCalculator ; \n \n \t2 this . vrp = vehicleRoutingProblem ; \n \n \t2 completionService = new ExecutorCompletionService < ScoredJob > ( executorService ) ; \n \n <ect>
\t6 <string_literal> + queueNames ) ; } \n \n \t3 } else { \n \n \t4 LOG . debug ( <string_literal> ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
<comment> \n \n \t1 private boolean checkResetPassword ( final Authenticator auth , final HttpServletRequest request , final HttpServletResponse response , final String path ) throws FrameworkException , IOException { \n \n <ect>
\t1 LOG . info ( <string_literal> + cmd + <string_literal> + output ) ; \n \n \t1 exitCode = 0 ; \n \n \t1 } catch ( Shell . ExitCodeException e ) { \n \n \t1 exitCode = e . getExitCode ( ) ; \n \n <ect>
\t3 pullThreads = new DataPuller [ numQueries ] ; \n \n \t3 for ( int pos = 0 ; pos < numQueries ; pos ++ ) { \n \n \t4 pullThreads [ pos ] = addDataPuller ( queries . get ( pos ) , storeTx ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t5 LOG . debug ( <string_literal> + stats ) ; \n \n \t5 <comment> \n \n \t5 Thread . sleep ( <number_literal> * <number_literal> ) ; } \n \n \t4 catch ( Throwable ex ) { \n \n <ect>
\t3 if ( pStmt != null ) { \n \n \t4 try { \n \n \t5 pStmt . close ( ) ; } \n \n \t4 catch ( SQLException e ) { \n \n <ect>
\t3 } else { \n \n \t4 int ok = decryptRecord ( reply , cfg , i , hop ) ; \n \n \t4 if ( ok == - 1 ) { \n \n \t5 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
<comment> \n \n \t1 public static Tidy getParser ( ) { \n \n <ect>
\t2 this . name = name ; } \n \n \t1 @ Override \n \n \t1 protected boolean hideChild ( @ Nonnull final String name , @ Nonnull final NodeState delegateChild ) { \n \n \t2 if ( isNameTooLong ( name ) ) { \n \n <ect>
\t2 if ( response . getCommand ( ) != COMMAND_RESULT_CODE ) { \n \n \t3 logger . error ( <string_literal> , response . getCommand ( ) ) ; \n \n \t3 return false ; } \n \n \t2 if ( response . getPayload ( ) . length != 1 ) { \n \n <ect>
\t1 private String getPattern ( DateFormat format ) { \n \n \t2 if ( format instanceof SimpleDateFormat ) { \n \n \t3 return ( ( SimpleDateFormat ) format ) . toPattern ( ) ; \n \n \t2 } else { \n \n <ect>
\t1 private static void initWorkers ( int n ) { \n \n \t2 if ( JavaAgent . db != null ) { \n \n \t3 if ( JavaAgent . db . isDoNothing ( ) ) { \n \n \t4 coroutineEnabled = false ; \n \n <ect>
\t5 try { \n \n \t6 Thread . sleep ( delayMs ) ; \n \n \t5 } catch ( InterruptedException ie ) { } } \n \n \t4 else \n \n <ect>
\t2 try \n \n \t2 { \n \n \t3 serverTransaction . sendResponse ( ok ) ; \n \n <ect>
\t3 NodeRegistrationContext regContext = new NodeRegistrationContext ( Time . currentTime ( ) , deployment ) ; \n \n \t3 nodeRegistrations . put ( deployment . getRegisterNodeUrl ( ) , regContext ) ; \n \n \t3 log . debugf ( <string_literal> , host ) ; \n \n \t2 } catch ( ServerRequest . HttpFailure failure ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( final BundleContext bc ) throws Exception { \n \n \t2 context = null ; \n \n <ect>
\t2 } else { \n \n \t3 try { \n \n \t4 tabSize = Integer . parseInt ( ( String ) propValue ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public void runJob ( ) { \n \n \t2 if ( _startedOn < = 0 ) \n \n \t3 _startedOn = getContext ( ) . clock ( ) . now ( ) ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t3 else { \n \n \t4 try { \n \n \t5 txn . rollback ( ) ; } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t2 assertEquals ( 1 , cache . getCacheStats ( ) . getLoadCount ( ) ) ; \n \n \t2 assertEquals ( 1 , cache . getCacheStats ( ) . getLoadSuccessCount ( ) ) ; \n \n \t2 <comment> \n \n \t2 assertEquals ( 0 , cache . getCacheStats ( ) . getEvictionCount ( ) ) ; \n \n <ect>
\t2 return true ; } \n \n \t1 @ Override \n \n \t1 public boolean configure ( String name , Map < String , Object > params ) throws ConfigurationException { \n \n <ect>
\t4 if ( packets != null ) { \n \n \t5 for ( int i = 0 ; i < packets . size ( ) ; i ++ ) { \n \n \t6 send ( packets . get ( i ) ) ; } } \n \n \t3 } catch ( RuntimeException e ) { \n \n <ect>
\t5 _log . info ( <string_literal> + valid + <string_literal> + PUBLIC_RELAY_COUNT + ' ) ' ) ; \n \n \t4 return true ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t5 logger . debug ( <string_literal> , addr ) ; \n \n \t5 TestUtils . waitUntilPortIsUp ( addr ) ; \n \n \t5 n ++ ; } } \n \n \t2 } catch ( CCMException e ) { \n \n <ect>
\t3 for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { \n \n \t4 try { \n \n \t5 listeners . get ( i ) . onStreamRemoved ( stream ) ; \n \n \t4 } catch ( Throwable cause ) { \n \n <ect>
\t2 try { \n \n \t3 if ( closeable != null ) { \n \n \t4 closeable . close ( ) ; } \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
\t6 LOGGER . debug ( <string_literal> , id ) ; \n \n \t6 final FlowDefinitionRegistry registry = applicationContext . getBean ( id , FlowDefinitionRegistry . class ) ; \n \n \t6 registerMultifactorTrustedAuthentication ( registry ) ; \n \n \t5 } catch ( final Exception e ) { \n \n <ect>
\t5 <comment> \n \n \t5 for ( int i = 0 ; i < idList . size ( ) ; i ++ ) { \n \n \t6 IdentityProxy id = idList . get ( i ) ; \n \n \t6 ex . addProxyObject ( id . getTableName ( ) , id . getValue ( ) , id . getidFieldName ( ) ) ; \n \n <ect>
\t2 log . warn ( <string_literal> ) ; <comment> \n \n \t2 listener = null ; } \n \n \t1 DiskStoreSampleSender ( RemoteSampleListener listener ) { \n \n \t2 this . listener = listener ; \n \n <ect>
\t1 Metrics replicationMetrics = factory . createReplicationMetrics ( ) ; \n \n \t1 try { \n \n \t1 replicationMetrics . register ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 while ( en . hasMoreElements ( ) ) { \n \n \t3 _backoff = ( BackoffAlgorithm ) en . nextElement ( ) ; \n \n \t3 break ; } \n \n \t2 if ( en . hasMoreElements ( ) ) { \n \n <ect>
\t3 this . managementContext = new ManagementContext ( ) ; \n \n \t3 this . managementContext . setConnectorPort ( port ) ; \n \n \t3 this . managementContext . start ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 String cookie = getCookie ( ucsMgrId ) ; \n \n \t2 String cmd = UcsCommands . configResolveDn ( cookie , dn ) ; \n \n \t2 String res = client . call ( cmd ) ; \n \n \t2 XmlObject xo = XmlObjectParser . parseFromString ( res ) ; \n \n <ect>
\t7 ( ( SchematicBlock ) getSchematic ( ) ) . state . getBlock ( ) ) ) { \n \n \t6 BCLog . logger . warn ( \n \n \t8 <string_literal> ) ; \n \n \t6 IBlockState state = context . world ( ) . getBlockState ( pos ) ; \n \n <ect>
\t5 + <string_literal> + StringUtils . right ( matcher . group ( <number_literal> ) , <number_literal> ) ; \n \n \t3 firmwareVersion = Integer . parseInt ( matcher . group ( <number_literal> ) , <number_literal> ) ; \n \n \t3 deviceType = intToDeviceType ( Integer . parseInt ( matcher . group ( <number_literal> ) , <number_literal> ) ) ; \n \n \t2 } else { \n \n <ect>
\t5 String columnName = columnNamesWithoutQuotes [ i ] ; \n \n \t5 int type = rows . getMetaData ( ) . getColumnType ( i + 1 ) ; \n \n \t5 Object o = rows . getObject ( columnName ) ; \n \n \t5 if ( o != null ) { \n \n <ect>
\t1 <comment> <ect>
\t1 public SampleResource ( LifecycleShutdownSignal event ) { \n \n \t2 this . event = event ; } \n \n \t1 @ GET \n \n \t1 public String getHello ( ) { \n \n <ect>
\t6 { \n \n \t7 message += <string_literal> + relocation . getMessage ( ) + <string_literal> ; } \n \n \t6 if ( artifact . getDependencyTrail ( ) != null && artifact . getDependencyTrail ( ) . size ( ) == 1 ) \n \n \t6 { \n \n <ect>
\t3 if ( nextPeer . equals ( from ) ) { \n \n \t4 <comment> \n \n \t4 _context . statManager ( ) . addRateData ( <string_literal> , 1 ) ; \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( isMyDirectAck ( msg ) ) { \n \n <ect>
\t3 while ( line != null ) { \n \n \t4 sb . append ( line ) . append ( <string_literal> ) ; \n \n \t4 line = reader . readLine ( ) ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t6 MessageProducer producer = session . createProducer ( queue ) ; \n \n \t6 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t7 Message msg = session . createTextMessage ( <string_literal> + i ) ; \n \n \t7 producer . send ( msg ) ; } \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , ticketId ) ; \n \n \t3 final Ticket ticket = this . dbTableService . get ( ticketId , encTicketId ) ; \n \n \t3 final Ticket decodedTicket = decodeTicket ( ticket ) ; \n \n \t3 if ( decodedTicket == null || decodedTicket . isExpired ( ) ) { \n \n <ect>
\t3 JOrphanUtils . write ( s . getResponseData ( ) , bos ) ; <comment> \n \n \t2 } catch ( FileNotFoundException e ) { \n \n \t3 log . error ( <string_literal> , s . getSampleLabel ( ) , e ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 Set < ContentName > subNamespaces = _subInterests . get ( namespace ) ; \n \n \t3 if ( null == subNamespaces ) { \n \n \t4 subNamespaces = new HashSet < ContentName > ( ) ; \n \n \t4 _subInterests . put ( namespace , subNamespaces ) ; \n \n <ect>
\t1 long elapsedMillis = TimeUnit . MILLISECONDS . convert ( \n \n \t2 System . nanoTime ( ) - startNanos , TimeUnit . NANOSECONDS ) ; \n \n \t1 long elapsedSeconds = elapsedMillis / 1000L ; \n \n \t1 logger . info ( <string_literal> , elapsedMillis ) ; \n \n <ect>
\t5 sb . append ( id . getName ( ) + <string_literal> ) ; } } \n \n \t3 throw new EHealthException ( \n \n \t5 <string_literal> + portName + <string_literal> + sb . toString ( ) ) ; } } \n \n \t1 public void disconnect ( ) { \n \n <ect>
\t1 ExprNodeDesc key = ctx . generator . getConf ( ) . getKeyCols ( ) . get ( ctx . desc . getKeyIndex ( ) ) ; \n \n \t1 <comment> \n \n \t1 ExprNodeDesc partKey = ctx . parent . getChildren ( ) . get ( 0 ) ; \n \n <ect>
\t6 api . getUrl ( ) ) ; \n \n \t5 return false ; } \n \n \t4 <comment> \n \n \t4 if ( api . verifyParam ( ) == false ) { \n \n <ect>
\t2 <comment> \n \n \t2 final int setupType = payload [ <number_literal> ] ; \n \n \t2 if ( logMINOR ) Logger . minor ( this , <string_literal> + packetType + <string_literal> + version + <string_literal> + negType + <string_literal> + setupType + <string_literal> + replyTo + <string_literal> ) ; \n \n \t2 if ( version != 1 ) { \n \n <ect>
\t5 pos = new BlockPos ( x , y , z ) ; \n \n \t4 } else if ( nbt . hasKey ( <string_literal> ) ) { \n \n \t5 return readBlockPos ( nbt . getTag ( <string_literal> ) ) ; \n \n \t4 } else { \n \n <ect>
\t1 addIterators ( conf , iterators ) ; \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 if ( null != ranges ) { \n \n <ect>
\t3 super ( AgentControllerState . UNKNOWN , null , 0 , null ) ; \n \n \t3 try { \n \n \t4 setAddress ( address ) ; \n \n \t3 } catch ( CommunicationException e ) { \n \n <ect>
\t3 String cl = response . getHeaderString ( <string_literal> ) ; \n \n \t3 if ( cl != null ) { \n \n \t4 <comment> \n \n \t4 int integerCl = Integer . parseInt ( cl ) ; \n \n <ect>
\t2 testStarted ( <string_literal> ) ; <comment> \n \n \t1 @ Override \n \n \t1 public void testStarted ( String host ) { \n \n <ect>
\t2 this . systemConfWatchDog = new FileWatchdog ( getHome ( ) . getSubFile ( <string_literal> ) . getAbsolutePath ( ) ) { \n \n \t3 @ Override \n \n \t3 protected void doOnChange ( ) { \n \n \t4 try { \n \n <ect>
\t1 checkForHostsWithoutState ( ) ; \n \n \t1 checkHostComponentStates ( ) ; \n \n \t1 checkServiceConfigs ( ) ; \n \n \t1 checkForLargeTables ( ) ; \n \n <ect>
\t3 try { \n \n \t4 <comment> \n \n \t4 new SimpleExec ( <string_literal> + file . getAbsolutePath ( ) ) . join ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 m . put ( logEntry . getColumnFamily ( ) , logEntry . getColumnQualifier ( ) , logEntry . getValue ( ) ) ; \n \n \t1 BatchWriter bw = conn . createBatchWriter ( MetadataTable . NAME , new BatchWriterConfig ( ) ) ; \n \n \t1 bw . addMutation ( m ) ; \n \n \t1 bw . close ( ) ; \n \n <ect>
\t2 try { \n \n \t3 ControllerMethod method = router . parse ( referer , HttpMethod . GET , request ) ; \n \n \t3 executeMethod ( method , result . use ( logic ( ) ) . redirectTo ( method . getController ( ) . getType ( ) ) ) ; \n \n \t2 } catch ( ControllerNotFoundException | MethodNotAllowedException e ) { \n \n <ect>
\t7 try { \n \n \t8 fsAe . delete ( user , group , path ) ; \n \n \t8 LOG . debug ( <string_literal> + path ) ; } \n \n \t7 catch ( ActionExecutorException ae ) { \n \n <ect>
\t1 } catch ( KeeperException e ) { \n \n \t2 switch ( e . code ( ) ) { \n \n \t2 case CONNECTIONLOSS : \n \n \t2 case OPERATIONTIMEOUT : \n \n <ect>
\t2 CmsElementView elementView , \n \n \t2 I_CmsResourceTypeEnabledCheck checkEnabled ) \n \n \t1 throws CmsException { \n \n \t2 if ( elementView == null ) { \n \n <ect>
\t3 Iterator iter = childErrorLog . iterator ( ) ; \n \n \t3 while ( iter . hasNext ( ) ) { \n \n \t4 errStr . append ( iter . next ( ) ) ; \n \n \t4 errStr . append ( ' \\ n' ) ; } } \n \n <ect>
\t4 try { \n \n \t5 while ( this . result . next ( ) ) { \n \n \t6 itemName = this . result . getString ( key ) ; } \n \n \t4 } catch ( Exception ex ) { \n \n <ect>
\t4 ApplicationStatus . FAILED , \n \n \t4 s <string_literal> ) \n \n \t3 ) } \n \n \t2 } else { \n \n <ect>
\t4 refreshInterval = Integer . parseInt ( ( String ) config . get ( <string_literal> ) ) ; \n \n \t4 logger . info ( <string_literal> , refreshInterval ) ; \n \n \t3 } catch ( NumberFormatException e ) { \n \n \t4 refreshInterval = <number_literal> ; \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( msg . getByte ( <string_literal> ) == 0x15 ) { \n \n <ect>
\t3 s_logger . info ( <string_literal> + encodedUsername + <string_literal> + networkIdStr ) ; \n \n \t3 if ( networkIdStr != null ) { \n \n \t4 _networkId . set ( networkIdStr ) ; } \n \n \t2 } else { \n \n <ect>
\t2 final long stddev = ( long ) ( Math . sqrt ( sumOfSquares . subtract ( sum . pow ( <number_literal> ) . divide ( BigInteger . valueOf ( numberOfShards ) ) ) . divide ( BigInteger . valueOf ( numberOfShards ) ) . doubleValue ( ) ) ) ; \n \n \t2 logger . info ( String . format ( <string_literal> , numberOfShards , mean , stddev ) ) ; \n \n \t2 <comment> \n \n \t2 final long threshold = mean + stddev * <number_literal> ; \n \n <ect>
<number_literal> <string_literal> , consistency_level . name ( ) ) ; \n \n \t3 Tracing . instance . begin ( <string_literal> , traceParameters ) ; } \n \n \t2 else \n \n \t2 { \n \n <ect>
\t4 log . info ( <string_literal> + rsrc3 ) ; \n \n \t4 log . info ( <string_literal> + rsrc4 ) ; \n \n \t4 log . info ( <string_literal> + rsrc5 ) ; \n \n \t4 log . info ( <string_literal> + rsrc6 ) ; \n \n <ect>
\t2 public boolean apply ( VolumeExportRecord rec ) { \n \n \t2 return rec . getIsActive ( ) ; } \n \n \t1 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 return null ; } \n \n \t2 return Strings . split ( test ) ; } \n \n \t1 private void testing ( File runFile , FileSetRepository fileSetRepository ) throws Exception { \n \n \t2 if ( ! runFile . exists ( ) ) { \n \n <ect>
\t7 } else { \n \n \t8 block . setId ( UNKNOWN_ID ) ; } } } \n \n \t5 registerFamily ( family . get ( ) ) ; } \n \n \t3 } catch ( BlockUriParseException e ) { \n \n <ect>
\t3 if ( result . getResultCode ( ) == ResultCode . SUCCESS ) { \n \n \t4 final LdapEntry entry = result . getResult ( ) . getEntry ( ) ; \n \n \t4 final LdapAttribute attribute = entry . getAttribute ( this . certificateAttribute ) ; \n \n \t4 if ( attribute . isBinary ( ) ) { \n \n <ect>
\t4 <string_literal> , <string_literal> ) , updateClause . toString ( ) , insertClause \n \n \t4 . toString ( ) , sourceClause , \n \n \t3 parallelizationEnabled ? <string_literal> : <string_literal> , \n \n \t3 parallelizationEnabled ? <string_literal> : <string_literal> ) ; \n \n <ect>
\t3 LOG . warn ( <string_literal> , e ) ; } \n \n \t2 try { \n \n \t3 StateUtil . bestEffortDiscardAllStateObjects ( privateState . values ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 final LdapEntry entry = response . getLdapEntry ( ) ; \n \n \t4 final CommonProfile profile = new CommonProfile ( ) ; \n \n \t4 profile . setId ( username ) ; \n \n \t4 entry . getAttributes ( ) . forEach ( a - > profile . addAttribute ( a . getName ( ) , a . getStringValues ( ) ) ) ; \n \n <ect>
\t4 log . error ( Util . getMessage ( <string_literal> ) + msg . getSrc ( ) ) ; \n \n \t4 return false ; } \n \n \t3 return isInMembersList ( ( IpAddress ) src ) ; } \n \n <ect>
\t2 } catch ( IllegalArgumentException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 t . sendResponseHeaders ( <number_literal> , - 1 ) ; \t2 <comment> \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t7 ( Optional < String > optRedirectAddress , Throwable throwable ) - > { \n \n \t8 HttpResponse response ; \n \n \t8 try { \n \n \t9 if ( throwable != null ) { \n \n <ect>
\t2 if ( ! RSCRIPT_EXISTS ) { \n \n \t3 if ( exceptOnError ) { \n \n \t4 throw new UserException . CannotExecuteRScript ( RSCRIPT_MISSING_MESSAGE ) ; \n \n \t3 } else { \n \n <ect>
\t1 readLock . lock ( ) ; \n \n \t1 try { \n \n \t1 for ( IPentahoObjectFactory fact : factories ) { \n \n \t2 if ( fact . objectDefined ( clazz ) ) { \n \n <ect>
\t1 public void connectionClosed ( ConnectionEvent event ) { \n \n \t2 try { \n \n \t3 ( ( ManagedConnection ) event . getSource ( ) ) . cleanup ( ) ; \n \n \t2 } catch ( ResourceException e ) { \n \n <ect>
<comment> \n \n public synchronized SignCertResponse signAgentCrt ( String agentHostname , String agentCrtReqContent , String passphraseAgent ) { \n \n \t1 SignCertResponse response = new SignCertResponse ( ) ; \n \n <ect>
\t1 File targetDir = new File ( System . getProperty ( <string_literal> ) + <string_literal> ) ; \n \n \t1 File keystoreFile = new File ( targetDir , <string_literal> ) ; \n \n \t1 if ( keystoreFile . exists ( ) ) { \n \n \t1 if ( ! keystoreFile . delete ( ) ) { \n \n <ect>
\t3 log . error ( <string_literal> , e ) ; \n \n \t3 RpcConnectionException rpcException = new RpcConnectionException ( <string_literal> , e ) ; \n \n \t3 getSender ( ) . tell ( new Status . Failure ( rpcException ) , getSelf ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 final Collection < MetaClass > allMetaClasses = findRelevantClasses ( processingContext ) ; \n \n \t1 log . debug ( <string_literal> , allMetaClasses . size ( ) ) ; \n \n \t1 final DependencyGraphBuilder graphBuilder = new DependencyGraphBuilderImpl ( qualFactory , injectionContext . isAsync ( ) ) ; \n \n \t1 runExtensionCallbacks ( allMetaClasses ) ; \n \n <ect>
\t5 <comment> \n \n \t5 LOG . info ( <string_literal> + received ) ; \n \n \t5 consumerSession . rollback ( ) ; \n \n \t4 } else { \n \n <ect>
\t3 if ( statement != null ) { \n \n \t4 try { \n \n \t5 statement . close ( ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t7 if ( ! UTF8Encoder . canEncode ( value ) ) { \n \n \t8 throw new IOException ( <string_literal> ) ; } \n \n \t7 stmt . setString ( startIndex ++ , value ) ; } \n \n \t5 } catch ( IOException ex ) { \n \n <ect>
\t3 cp = new CONSTANT_Fieldref_info ( ) ; \n \n \t3 ( ( CONSTANT_Fieldref_info ) cp ) . class_index = d . readUnsignedShort ( ) ; \n \n \t3 ( ( CONSTANT_Fieldref_info ) cp ) . name_and_type_index = \n \n \t4 d . readUnsignedShort ( ) ; \n \n <ect>
\t1 private boolean isIdleConnectionTimeoutExceeded ( ) { \n \n \t2 if ( idleConnectionTimeoutNs > 0 ) { \n \n \t3 long elapsedTime = System . nanoTime ( ) - startTime ; \n \n \t3 if ( elapsedTime > idleConnectionTimeoutNs ) { \n \n <ect>
\t1 Text first = KeyExtent . getMetadataEntry ( tableId , start ) ; \n \n \t1 Range range = new Range ( first , false , null , true ) ; \n \n \t1 scanner . setRange ( range . clip ( MetadataSchema . TabletsSection . getRange ( ) ) ) ; \n \n \t1 KeyExtent prevExtent = null ; \n \n <ect>
\t3 _idpMetaDataProvider . setParserPool ( new BasicParserPool ( ) ) ; \n \n \t3 _idpMetaDataProvider . initialize ( ) ; \n \n \t3 _timer . scheduleAtFixedRate ( new MetadataRefreshTask ( ) , 0 , _refreshInterval * <number_literal> ) ; \n \n \t2 } catch ( MetadataProviderException e ) { \n \n <ect>
\t3 if ( FBUtilities . isWindows ) \n \n \t4 return ; \n \n \t3 String jemalloc = System . getProperty ( <string_literal> ) ; \n \n \t3 if ( jemalloc == null ) \n \n <ect>
\t1 private static boolean shutDown ( EventLoopGroup group ) { \n \n \t2 return group . shutdownGracefully ( 0 , <number_literal> , TimeUnit . SECONDS ) . awaitUninterruptibly ( <number_literal> , TimeUnit . SECONDS ) ; } \n \n \t1 private void onTimelyConnect ( ) { \n \n \t2 if ( channelFuture . isSuccess ( ) ) { \n \n <ect>
\t2 } else { \n \n \t4 s_logger . debug ( <string_literal> ) ; } } \n \n <ect>
\t6 . getMessage ( ) ; \n \n \t5 log . warn ( message ) ; \n \n \t5 throw new RequestInterruptionException ( message , e ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t4 KnapsackState state = new KnapsackState ( ) ; \n \n \t4 builder . add ( state . fromXContent ( parser ) ) ; } \n \n \t3 return builder . build ( ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t5 if ( prop != null ) { \n \n \t6 log . debug ( <string_literal> + action . getId ( ) ) ; \n \n \t6 for ( String property : prop . getProperties ( ) . keySet ( ) ) { \n \n \t7 actionConf . set ( property , prop . getProperties ( ) . get ( property ) ) ; \n \n <ect>
\t2 searchCriteria . setEndDate ( new DateTimeSearchField ( SearchField . AND , DateTimeSearchField . LESS_THAN_EQUAL , endDate , null ) ) ; \n \n \t2 LOG . debug ( <string_literal> + startDate + <string_literal> + endDate ) ; \n \n \t2 List < SimpleMeeting > crmEvents = ( List < SimpleMeeting > ) meetingService . findPageableListByCriteria ( new BasicSearchRequest < > ( \n \n \t4 searchCriteria , 0 , Integer . MAX_VALUE ) ) ; \n \n <ect>
\t2 _config = config ; \n \n \t2 _processor = new OutboundGatewayProcessor ( ctx , config ) ; } \n \n \t1 public long sendPreprocessed ( byte [ ] preprocessed , TunnelGateway . Receiver receiver ) { \n \n \t2 <comment> \n \n <ect>
\t3 messageTaskExecutorService . execute ( new CommandCreateNewTask ( Minion . this , message ) ) ; \n \n \t2 } else if ( message instanceof CommandTaskUpdateReplicas ) { \n \n \t3 promoteDemoteTaskExecutorService . execute ( new CommandTaskUpdateReplicasRunner ( Minion . this , message ) ) ; \n \n \t2 } else { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t2 } catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t5 i2ps . close ( ) ; \n \n \t4 } catch ( IOException ioe ) { } \n \n \t3 } else if ( sockReset ) { \n \n \t4 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t1 if ( ! connectionManager . snapshotExists ( sanSnapshotId , iqn ) ) { \n \n \t2 LOG . debug ( <string_literal> + sanSnapshotId + <string_literal> + snapshotId ) ; \n \n \t2 deleteEntity = true ; \n \n \t1 } else { \n \n <ect>
\t4 try { \n \n \t5 setName ( job . name + <string_literal> + threadNo + <string_literal> ) ; \n \n \t5 job . runnable . run ( ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t5 <comment> \n \n \t5 ExternalListener instance = ( ExternalListener ) clazz . newInstance ( ) ; \n \n \t5 registerListener ( instance ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 Location l = Context . getLocationService ( ) . getLocation ( facility ) ; \n \n \t3 if ( l == null ) { \n \n <ect>
\t2 assert _vn != null : <string_literal> ; \n \n \t2 try { \n \n \t3 latest = ( VirtualNetworkModel ) o ; \n \n \t2 } catch ( ClassCastException ex ) { \n \n <ect>
\t2 if ( tupleFilter instanceof CompareTupleFilter ) { \n \n \t3 <comment> \n \n \t3 translated = translateCompareTupleFilter ( ( CompareTupleFilter ) tupleFilter ) ; \n \n \t3 if ( translated != null ) { \n \n <ect>
\t6 bufferPool . dispose ( vboUVBuffer ) ; \n \n \t6 vboUVBuffer = 0 ; } \n \n \t4 } ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 runStatementOnDriver ( <string_literal> + Table . NONACIDNONBUCKET + <string_literal> , confForTez ) ; \n \n \t1 TestTxnCommands2 . runWorker ( hiveConf ) ; \n \n \t1 rs = runStatementOnDriver ( <string_literal> + Table . NONACIDNONBUCKET + <string_literal> , confForTez ) ; \n \n <ect>
\t10 { \n \n <number_literal> break ; } } \n \n \t9 catch ( Throwable e ) \n \n \t9 { \n \n <ect>
\t3 long endTime = System . currentTimeMillis ( ) ; \n \n \t3 long seconds = ( endTime - startTime ) / <number_literal> ; \n \n \t3 LOG . info ( <string_literal> , numThreads . intValue ( ) , seconds ) ; \n \n \t3 results . put ( numThreads , seconds ) ; \n \n <ect>
\t2 this . staleAddressDetector = staleAddressDetector ; } \n \n \t1 public DaemonConnectDetails getDaemon ( ) { \n \n \t2 return daemon ; } \n \n \t1 public void dispatch ( Message message ) throws DaemonConnectionException { \n \n <ect>
\t8 <string_literal> , \n \n \t8 nodeConflictHandler , conflictType , resolution , \n \n \t8 name , diff ) ; } } } \n \n \t3 else { \n \n <ect>
\t5 hostcmd . memory = host . memory \n \n \t5 hostcmd . hosttags = host . hosttags \n \n \t4 ret = self . __apiClient . addHost ( hostcmd ) \n \n \t4 if ret : \n \n <ect>
\t3 Throwable cause = exception ; \n \n \t3 while ( cause != null && cause instanceof IOException ) { \n \n \t4 String message = cause . getMessage ( ) ; \n \n \t4 if ( message != null && message . contains ( noSpaceMessage ) ) { \n \n <ect>
@ Override \n \n public RegionAndId apply ( RegionAndId id ) { \n \n \t1 if ( isNeutronLinked ( ) ) { \n \n \t2 for ( FloatingIpForServer floatingIpForServer : floatingIpCache . getUnchecked ( id ) ) { \n \n <ect>
\t3 throw re ; } \n \n \t2 logger . debug ( <string_literal> , count ) ; \n \n \t2 assertIdle ( ) ; } \n \n \t1 protected void assertIdle ( ) throws InterruptedException { \n \n <ect>
\t5 holdabilityUnsupported = true ; \n \n \t5 LOG . warn ( <string_literal> , e ) ; \n \n \t4 } catch ( SQLFeatureNotSupportedException e ) { \n \n \t5 holdabilityUnsupported = true ; \n \n <ect>
\t1 begin \n \n \t1 admin . move ( Bytes . toBytes ( r . getEncodedName ( ) ) , Bytes . toBytes ( newServer ) ) \n \n \t1 rescue java . lang . reflect . UndeclaredThrowableException , \n \n \t2 org . apache . hadoop . hbase . UnknownRegionException = > e \n \n <ect>
\t2 for ( String metadataString : mappingString ) { \n \n \t3 metadataString = metadataString . trim ( ) ; \n \n \t3 String [ ] metadataParts = metadataString . split ( <string_literal> ) ; \n \n \t3 if ( metadataParts . length != <number_literal> ) { \n \n <ect>
public void test ( ) throws Exception { \n \n \t1 String user = testName . getMethodName ( ) ; \n \n \t1 File userKeytab = new File ( kdc . getKeytabDir ( ) , user + <string_literal> ) ; \n \n \t1 if ( userKeytab . exists ( ) && ! userKeytab . delete ( ) ) { \n \n <ect>
\t5 } else { \n \n \t6 logger . trace ( <string_literal> , \n \n \t8 itemName , command ) ; } } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void handleNack ( long seq , boolean multiple ) \n \n \t3 throws IOException { \n \n <ect>
\t2 _id = network . getId ( ) ; \n \n \t2 try { \n \n \t3 _projectId = manager . getProjectId ( network . getDomainId ( ) , network . getAccountId ( ) ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t3 if ( proxyAuthExchange . getState ( ) == AuthExchange . State . UNCHALLENGED ) { \n \n \t4 final AuthScheme authScheme = authCache . get ( proxy ) ; \n \n \t4 if ( authScheme != null ) { \n \n <ect>
\t2 public void transmissionAborted ( ) { \n \n \t3 logger . info ( <string_literal> ) ; } \n \n \t2 @ Override \n \n \t2 public void transmissionProgress ( final String message ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , model . keySet ( ) . toArray ( ) ) ; \n \n \t2 if ( this . view != null ) { \n \n \t3 this . view . render ( model , request , response ) ; \n \n \t2 } else { \n \n <ect>
\t7 Thread . sleep ( ERJavaMail . sharedInstance ( ) . milliSecondsWaitIfSenderOverflowed ( ) ) ; } \n \n \t6 catch ( InterruptedException ie ) { \n \n \t7 log . warn ( <string_literal> , ie ) ; } } } } } \n \n \t2 catch ( MessagingException e ) { \n \n <ect>
\t3 OutputStream os = response . getOutputStream ( ) ; \n \n \t3 os . write ( data ) ; \n \n \t3 os . close ( ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t7 s_logger . error ( String . format ( <string_literal> , secondaryStore . getName ( ) ) ) ; \n \n \t7 return false ; } \n \n \t6 Answer answer = endpoint . sendMessage ( deleteCommand ) ; \n \n \t6 if ( ! answer . getResult ( ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 log . debug ( <string_literal> + this . getAddressAndPort ( ) + <string_literal> + e ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 log . info ( <string_literal> + this . getAddressAndPort ( ) + <string_literal> + e ) ; } } \n \n <ect>
\t5 volume . setLoDevName ( null ) ; \n \n \t5 LOG . info ( <string_literal> + volume . getVolumeId ( ) ) ; \n \n \t5 volume . setCleanup ( false ) ; \n \n \t5 } else { \n \n <ect>
\t4 # Enable offeringq \n \n \t4 offering . update ( self . apiclient , state = <string_literal> ) \n \n \t4 self . assertEqual ( self . get_networkoffering_state ( \n \n \t5 offering ) , <string_literal> , <string_literal> ) \n \n <ect>
\t1 public String getName ( ) { \n \n \t2 if ( getPerson ( ) != null && getPerson ( ) . getPersonName ( ) != null ) { \n \n \t3 return getPerson ( ) . getPersonName ( ) . getFullName ( ) ; \n \n \t2 } else { \n \n <ect>
\t3 ShardId shardId = shardStats . getShardRouting ( ) . shardId ( ) ; \n \n \t3 assertThat ( shardStats . getShardRouting ( ) + <string_literal> , historyUUID , notNullValue ( ) ) ; \n \n \t3 assertThat ( shardStats . getShardRouting ( ) + <string_literal> , historyUUID , not ( equalTo ( historyUUIDs . get ( shardId ) ) ) ) ; } \n \n \t2 <comment> \n \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 JMeterTreeNode root = ( JMeterTreeNode ) treeModel . getRoot ( ) ; \n \n \t2 if ( root . getChildCount ( ) < 1 ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void setUp ( ) { \n \n <ect>
\t2 String response = connection . sendMessage ( query , timeout ) ; \n \n \t2 if ( response == null || response . length ( ) == 0 ) { \n \n \t3 throw new EpsonProjectorException ( <string_literal> ) ; } \n \n \t2 response = response . replace ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t3 final HttpEntity < Principal > entity = new HttpEntity < > ( authentication . getPrincipal ( ) , acceptHeaders ) ; \n \n \t3 LOGGER . warn ( <string_literal> , authentication . getPrincipal ( ) , this . endpoint ) ; \n \n \t3 final ResponseEntity < String > resp = restTemplate . exchange ( this . endpoint , HttpMethod . POST , entity , String . class ) ; \n \n \t3 if ( resp == null ) { \n \n <ect>
\t6 return new UpdateContainer ( new TrivialErrorUpdate ( <string_literal> + commandName + <string_literal> ) ) ; } \n \n \t4 } catch ( UnsupportedOperationException ignored ) { } } \n \n \t3 return uc ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 return <number_literal> ; } \n \n \t4 else { \n \n \t5 s_logger . info ( <string_literal> + responseCode ) ; } \n \n \t3 } else { \n \n <ect>
\t3 Thread . sleep ( _time ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t2 f . setAccessible ( true ) ; \n \n \t2 CONSOLE_VIEW_IN_EDITOR_VIEW = ( Key ) f . get ( null ) ; \n \n \t2 break ; } } } \n \n \t1 catch ( ClassNotFoundException e ) { \n \n <ect>
\t4 logger . info ( <string_literal> , desc . getTableName ( ) , host ) ; \n \n \t4 <comment> \n \n \t4 allTablesNeedToBeDropped . add ( desc . getTableName ( ) . getNameAsString ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 { \n \n \t3 logger . debug ( <string_literal> , sourceName ) ; \n \n \t3 Worksheet worksheet = generateWorksheet ( sourceName , new BufferedInputStream ( data ) , dataType , inputTypeParameters , \n \n \t5 workspace ) ; \n \n <ect>
\t2 TimeUnit . MILLISECONDS . sleep ( retryInterval ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n \t2 logger . info ( <string_literal> ) ; } \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t3 transMgr . commit ( transStatus ) ; } \n \n \t2 catch ( ValidationException vex ) \n \n \t2 { \n \n \t3 onException ( transStatus ) ; \n \n <ect>
\t4 logger . info ( <string_literal> , testingSelect ) ; \n \n \t4 testing ( testingSelect , fileSetRepository ) ; \n \n \t3 } else { \n \n \t4 Glob g = new Glob ( testing == null ? <string_literal> : testing ) ; \n \n <ect>
\t3 boolean useTicketCache = flinkConfiguration . getBoolean ( SecurityOptions . KERBEROS_LOGIN_USETICKETCACHE ) ; \n \n \t3 UserGroupInformation loginUser = UserGroupInformation . getCurrentUser ( ) ; \n \n \t3 if ( loginUser . getAuthenticationMethod ( ) == UserGroupInformation . AuthenticationMethod . KERBEROS \n \n \t4 && useTicketCache && ! loginUser . hasKerberosCredentials ( ) ) { \n \n <ect>
\t3 this . sslContext = createSSLContext ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 throw ObjectHelper . wrapRuntimeCamelException ( e ) ; } \n \n \t2 if ( sslContext != null ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + user + <string_literal> + group ) ; \n \n \t3 dbGroup . addUserByName ( user ) ; } } \n \n \t2 } catch ( AuthException e ) { \n \n \t2 LOG . error ( e , e ) ; \n \n <ect>
\t3 Thread thread = ( Thread ) iter . next ( ) ; \n \n \t3 if ( thread . getName ( ) . startsWith ( AMQ_CONN_EXECUTOR_THREAD_NAME ) ) { \n \n \t4 LOG . error ( <string_literal> , thread . getName ( ) ) ; \n \n \t3 return true ; } } \n \n <ect>
\t3 if ( this == requestContext . getRequest ( ) . getAttribute ( REQUEST_CONTEXT_OWNER_KEY ) ) { \n \n \t4 requestContext . getRequest ( ) . removeAttribute ( REQUEST_CONTEXT_OWNER_KEY ) ; \n \n \t4 requestContexts . commitRequestContext ( requestContext ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 Message incomingMessage = consumer . receive ( <number_literal> ) ; \n \n \t5 if ( incomingMessage instanceof TextMessage ) { \n \n \t6 ActiveMQTextMessage textMessage = ( ActiveMQTextMessage ) incomingMessage ; \n \n \t6 try { \n \n <ect>
\t4 s_logger . warn ( <string_literal> , naf ) ; \n \n \t4 throw new ServerException ( <string_literal> , naf ) ; } \n \n \t2 } catch ( NaException nae ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t2 for ( LocalPortForwarder forwarder : forwarders ) { \n \n \t3 try { \n \n \t4 forwarder . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 } catch ( InterruptedIOException e ) { \n \n \t4 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t4 logger . error ( <string_literal> ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t4 cms . getRequestContext ( ) . setSiteRoot ( <string_literal> ) ; \n \n \t4 CmsResource element = cms . readResource ( m_resourceSearch . getValue ( ) ) ; \n \n \t4 settings . setElementResource ( element ) ; \n \n \t3 } catch ( CmsException e ) { \n \n <ect>
\t2 final List < Row > rows = new ArrayList < Row > ( ) ; \n \n \t2 for ( final int rg : Arrays . asList ( 0 , 1 ) ) { \n \n \t3 for ( final int qual : Arrays . asList ( 0 , 1 ) ) { \n \n \t4 rows . add ( new Row ( rg , qual , 1 , <number_literal> ) ) ; } } \n \n <ect>
\t2 } catch ( MBeanRegistrationException ex ) { \n \n \t3 log . warn ( <string_literal> + objName . getCanonicalName ( ) + <string_literal> + ex . getMessage ( ) ) ; \n \n \t3 throw new ARQException ( <string_literal> + objName . getCanonicalName ( ) + <string_literal> + ex . getMessage ( ) , ex ) ; } } \n \n \t1 private static void unregister ( ObjectName objName ) { \n \n <ect>
\t3 txn . commit ( ) ; \n \n \t3 if ( _host != null ) { \n \n \t4 return _host ; \n \n \t3 } else { \n \n <ect>
\t5 initialized = false ; \n \n \t5 getConnection ( ) ; } \n \n \t4 logger . info ( <string_literal> ) ; \n \n \t3 } catch ( NotInitializedException nie ) { \n \n <ect>
\t3 this . group = groupService . create ( context ) ; \n \n \t3 groupService . addMember ( context , group , member ) ; \n \n \t3 groupService . update ( context , group ) ; \n \n \t2 } catch ( AuthorizeException ex ) { \n \n <ect>
\t2 if ( obs != null && path == obs . path ) { \n \n \t3 Logger . warn ( TAG , <string_literal> ) \n \n \t3 return \n \n \t2 } else if ( obs != null ) { \n \n <ect>
\t6 logger . info ( <string_literal> , indexNames ) ; } \n \n \t5 @ Override \n \n \t5 public void onSuccess ( Object ignored ) \n \n \t5 { \n \n <ect>
\t4 txSync . listenAsync ( new CI1 < GridFuture < ? > > ( ) { \n \n \t5 @ Override public void apply ( GridFuture < ? > t ) { \n \n \t6 try { \n \n <ect>
\t2 byte [ ] handshakeHash ; \n \n \t2 try { \n \n \t3 handshakeHash = md5 . digest ( handshake . getBytes ( <string_literal> ) ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 String [ ] mounts = _storage . listFiles ( parent + File . separator + String . valueOf ( mshostId ) + <string_literal> ) ; \n \n \t2 if ( mounts != null && mounts . length > 0 ) { \n \n \t3 for ( String mountPoint : mounts ) { \n \n <ect>
\t5 <comment> \n \n \t5 return file . delete ( ) \n \n \t6 && new File ( getVersionDirectory ( ) , file . getName ( ) ) . delete ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t4 for ( AcquireResult result : results ) \n \n \t4 { \n \n \t5 if ( result != null ) \n \n \t5 { \n \n <ect>
\t4 queueCallable ( new CoordKillCommand ( jobId ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n \t4 log . warn ( <string_literal> + <string_literal> + jobId + <string_literal> ) ; } } \n \n \t2 catch ( InterruptedException e ) { \n \n \t3 queueCallable ( new CoordKillCommand ( jobId ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t2 else : \n \n \t2 Logger . info ( <string_literal> \n \n \t5 <string_literal> . format ( str ( existing_json_map ) ) ) \n \n \t1 except Exception , e : \n \n <ect>
\t4 LOGGER . log ( WARNING , <string_literal> , x ) ; \n \n \t4 System . setProperty ( TransformerFactory . class . getName ( ) , <string_literal> ) ; \n \n \t4 try { \n \n \t5 TransformerFactory . newInstance ( ) ; \n \n <ect>
\t2 } catch ( SearchPhaseExecutionException e ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 return commandTransformationService ; } \n \n \t2 BundleContext context = MiosActivator . getContext ( ) ; \n \n \t2 commandTransformationService = TransformationHelper . getTransformationService ( context , name ) ; \n \n \t2 if ( commandTransformationService == null ) { \n \n <ect>
\t2 String defaultJSON = <string_literal> ; \n \n \t2 try { \n \n \t3 s = FileUtils . readFileToString ( getFile ( ) , <string_literal> ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t1 createRoleAuthorizations ( ) ; \n \n \t1 addUserAuthenticationSequence ( ) ; \n \n \t1 updateSolrConfigurations ( ) ; } \n \n protected void renameAmbariInfra ( ) throws SQLException { \n \n <ect>
\t1 Path lockFile = new Path ( lockDirPath , fileToLock . getName ( ) ) ; \n \n \t1 try { \n \n \t1 FSDataOutputStream ostream = HdfsUtils . tryCreateFile ( fs , lockFile ) ; \n \n \t1 if ( ostream != null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 if ( val . state ( ) != State . OPEN ) <comment> \n \n \t4 continue ; \n \n \t3 long age = val . age ( ) ; \n \n \t3 if ( age >= conn_expiry_timeout ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t2 LOG . error ( <string_literal> , e ) ; \n \n \t2 throw new AmbariException ( e . getMessage ( ) , e ) ; } } } } \n \n public void executePreDMLUpdates ( List < UpgradeCatalog > upgradeCatalogs ) throws AmbariException { \n \n <ect>
<comment> \n \n \t1 protected AuthChallenge resolveCode ( String code ) { \n \n \t2 <comment> \n \n \t2 if ( ! isRequestSecure ( ) && deployment . getSslRequired ( ) . isRequired ( facade . getRequest ( ) . getRemoteAddr ( ) ) ) { \n \n <ect>
\t5 if ( ( paramValues . get ( index ) != null ) \n \n \t7 && ( ( ( String ) paramValues . get ( index ) ) . length ( ) > 0 ) ) { \n \n \t6 value = CRS . parseWKT ( ( String ) paramValues . get ( index ) ) ; } \n \n \t4 } else { \n \n <ect>
\t7 getChildren ( ) ; } \n \n \t6 catch ( Exception ex ) \n \n \t6 { \n \n \t7 ThreadUtils . checkInterrupted ( ex ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bc ) throws Exception { \n \n <ect>
\t4 { <comment> \n \n \t3 } ; \n \n \t3 MoveAfterCopy moveAfterCopyWithLogging = ( moves , fromDirectory , toDirectory ) - > \n \n \t3 { \n \n <ect>
\t2 <comment> \n \n \t2 client = new HttpClient ( ) ; \n \n \t2 method = new GetMethod ( url ) ; \n \n \t2 responseCode = client . executeMethod ( method ) ; \n \n <ect>
\t5 } catch ( Throwable t ) { \n \n \t6 logger . warn ( <string_literal> , thisFile . getUuid ( ) , content , t . getMessage ( ) ) ; } } } \n \n \t3 return fis ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t3 DaemonClientConnection connection = connector . maybeConnect ( daemon ) ; \n \n \t3 if ( connection == null ) { \n \n \t4 continue ; } \n \n \t3 try { \n \n <ect>
\t2 final MultifactorAuthenticationProvider restProvider = providers . stream ( ) . filter ( p - > p . matches ( results ) ) . findFirst ( ) . orElse ( null ) ; \n \n \t2 if ( restProvider != null ) { \n \n \t3 LOGGER . debug ( <string_literal> , restProvider . getId ( ) ) ; \n \n \t3 return CollectionUtils . wrapSet ( new Event ( this , restProvider . getId ( ) ) ) ; } \n \n <ect>
\t1 topic . set ( topicStr ) ; \n \n \t1 groupId = ctx . getString ( KAFKA_CONSUMER_PREFIX + ConsumerConfig . GROUP_ID_CONFIG ) ; \n \n \t1 if ( groupId == null || groupId . isEmpty ( ) ) { \n \n \t1 groupId = DEFAULT_GROUP_ID ; \n \n <ect>
\t2 final List < DomainRouterVO > routers = _vpcRouterMgr . getVpcRouters ( gateway . getVpcId ( ) ) ; \n \n \t2 if ( routers == null || routers . isEmpty ( ) ) { \n \n \t3 s_logger . debug ( getName ( ) + <string_literal> + <string_literal> + gateway . getVpcId ( ) ) ; \n \n \t3 return true ; } \n \n <ect>
<number_literal> Collection < Node > nodes , \n \n <number_literal> String clusterXml , \n \n <number_literal> String storesXml ) { \n \n \t2 boolean success = true ; \n \n <ect>
<comment> \n \n \t1 static void toto ( org . slf4j . Logger logger , int i ) { \n \n <ect>
\t3 if ( components . contains ( Component . DATA ) && dataFile . length ( ) > 0 ) \n \n \t4 <comment> \n \n \t4 continue ; \n \n \t3 <comment> \n \n <ect>
\t4 if ( anyTimedOut ) { \n \n \t5 CHKInsertSender . this . setTransferTimedOut ( ) ; } \n \n \t4 receivedNotice ( ! anyTimedOut , false , false ) ; \n \n \t3 } else { \n \n <ect>
\t3 if ( connection != null && ! forceNewConnection ) { \n \n \t3 <comment> \n \n \t4 if ( ! connection . isClosed ( ) ) { \n \n <ect>
\t2 Logger . normal ( this , <string_literal> + file + <string_literal> + newFile ) ; \n \n \t2 if ( FileUtil . moveTo ( file , newFile , false ) ) \n \n \t3 return newFile ; \n \n \t2 else { \n \n <ect>
\t1 @ Override \n \n \t1 public Aggregator copy ( ExprList expr ) \n \n \t1 { \n \n \t2 if ( expr != null ) \n \n <ect>
\t4 continue ; } \n \n \t3 partitionRanges . add ( new PartitionIDRange ( lowerID , upperID , partitionIdBound ) ) ; } \n \n \t2 return partitionRanges ; } \n \n \t1 private static void discardRange ( KeyRange local ) { \n \n <ect>
\t1 tagSet . setBucketTags ( bucketTagList ) ; \n \n \t1 tagging . setBucketTagSet ( tagSet ) ; \n \n \t1 reply . setTaggingConfiguration ( tagging ) ; \n \n \t1 } catch ( S3Exception ex ) { \n \n <ect>
\t2 if ( ! wildcardHierarchy . getTypeArgument ( ) . equals ( Primate . class ) ) { \n \n \t3 log . info ( <string_literal> + wildcardHierarchy . getTypeArgument ( ) ) ; \n \n \t3 result = false ; } \n \n \t2 if ( ! primateHierarchy . getTypeArgument ( ) . equals ( Primate . class ) ) { \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public BatchSampleSender ( ) { \n \n \t2 this ( null ) ; \n \n <ect>
\t2 if ( response . getCommand ( ) != COMMAND_CODE ) { \n \n \t3 logger . error ( <string_literal> , response . getCommand ( ) ) ; \n \n \t3 return false ; } \n \n \t2 if ( response . getPayload ( ) . length != <number_literal> ) { \n \n <ect>
\t4 for ( Iterator < EntryWrapper < K , V > > it = pendingEntries . iterator ( ) ; it . hasNext ( ) ; ) { \n \n \t5 EntryWrapper < K , V > wrapper = it . next ( ) ; \n \n \t5 if ( wrapper . expireTime < = now ) { \n \n <ect>
\t1 workflow . aggregateHourly ( ) ; \n \n \t1 } catch ( final WorkflowExecutionAlreadyStartedException ex ) { \n \n \t1 ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t4 LOG . error ( <string_literal> , ex ) ; \n \n \t3 } catch ( IllegalAccessException ex ) { \n \n \t4 LOG . error ( <string_literal> , ex ) ; \n \n \t3 } catch ( InvocationTargetException ex ) { \n \n <ect>
\t2 if ( jc . isValid ( ) && jc . enabled ( ) ) { \n \n \t3 try { \n \n \t4 jndiContext = new InitialContext ( jc . getJndiEnv ( ) ) ; \n \n \t4 jndiContext . bind ( jc . getJndiName ( ) , repository ) ; \n \n <ect>
\t4 this . reservedCacheSize = newReservedCacheSize ; \n \n \t4 adjustCacheSizes ( ) ; \n \n \t4 mConfig . setCacheSize ( newCacheSize ) ; \n \n \t4 environment . setMutableConfig ( mConfig ) ; \n \n <ect>
\t2 servos . addAll ( zone . getServoInstances ( ) ) ; } } \n \n \t1 } catch ( NoSuchElementException ex ) { \n \n \t1 return ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t3 connector = brokerService . addConnector ( \n \n \t4 <string_literal> + amqpSslPort + <string_literal> + getAmqpTransformer ( ) + getAdditionalConfig ( ) ) ; \n \n \t3 amqpSslPort = connector . getConnectUri ( ) . getPort ( ) ; \n \n \t3 amqpSslURI = connector . getPublishableConnectURI ( ) ; \n \n <ect>
\t6 int status = ise . getStatus ( ) ; \n \n \t6 i2pReset = status == I2PSocketException . STATUS_CONNECTION_RESET ; \n \n \t6 if ( i2pReset ) { \n \n \t7 if ( _log . shouldWarn ( ) ) \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void concurrentGetCached ( ) throws Exception { \n \n <ect>
\t2 Interest interest = new Interest ( new ContentName ( name , digest ) ) ; \n \n \t2 Assert . assertTrue ( interest . matches ( co ) ) ; \n \n \t2 interest = new Interest ( new ContentName ( name , <string_literal> ) ) ; \n \n \t2 Assert . assertFalse ( interest . matches ( co ) ) ; \n \n <ect>
\t4 session . refresh ( false ) ; \n \n \t4 JcrUtils . readFile ( \n \n \t6 session . getNode ( path ) , new NullOutputStream ( ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
{ \n \n \t1 private static final Logger logger = LoggerFactory . getLogger ( ConversationCounter . class ) ; \n \n \t1 void onDetach ( @ Observes ( notifyObserver = Reception . IF_EXISTS ) DetachEvent detach ) \n \n \t1 { \n \n <ect>
\t3 if ( SYS_ENV_INSTANCE == null ) { \n \n \t4 try { \n \n \t5 KylinConfig config = new KylinConfig ( ) ; \n \n \t5 config . reloadKylinConfig ( prop ) ; \n \n <ect>
\t4 if ( this . messagesPerAck > 1 ) { \n \n \t5 consumer . ackIfNecessary ( 0L ) ; } } \n \n \t3 consumer . getChannel ( ) . basicCancel ( consumer . getConsumerTag ( ) ) ; } \n \n \t2 catch ( IOException e ) { \n \n <ect>
\t4 jobLatch . countDown ( ) ; \n \n \t4 log . info ( <string_literal> ) ; \n \n \t4 <comment> \n \n \t4 latch . await ( ) ; \n \n <ect>
\t1 public void run ( ) { \n \n \t1 try { \n \n \t2 HiveMetaStore . main ( new String [ ] { <string_literal> , <string_literal> , String . valueOf ( MS_PORT ) } ) ; \n \n \t1 } catch ( Throwable t ) { \n \n <ect>
\t2 int available = 0 ; \n \n \t2 ActiveMQMessage message = null ; \n \n \t2 while ( ( message = ( ActiveMQMessage ) advisoryConsumer . receive ( <number_literal> ) ) != null ) { \n \n \t3 available ++ ; \n \n <ect>
\t3 char fieldSeparator = mshSegment . charAt ( <number_literal> ) ; \n \n \t3 String fieldSeparatorPattern = Pattern . quote ( <string_literal> + fieldSeparator ) ; \n \n \t3 String [ ] mshFields = mshSegment . split ( fieldSeparatorPattern ) ; \n \n \t3 if ( mshFields . length == 0 ) { \n \n <ect>
\t4 s_lockLogger . trace ( <string_literal> + time . first ( ) + <string_literal> + ( System . currentTimeMillis ( ) - time . second ( ) ) ) ; } \n \n \t3 _lockTimes . clear ( ) ; } } \n \n \t1 public boolean commit ( ) { \n \n \t2 if ( ! _txn ) { \n \n <ect>
\t2 assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; \n \n \t2 assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <string_literal> ) . setSnapshots ( <string_literal> ) . get ( ) . getSnapshots ( ) . get ( 0 ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 cluster ( ) . wipeIndices ( <string_literal> ) ; \n \n <ect>
\t5 if ( setToNull ) \n \n \t6 con = null ; } \n \n \t3 } <comment> \n \n \t2 } catch ( ConcurrentModificationException e ) { \n \n <ect>
\t2 new GarbageCollectionAlgorithm ( ) . collect ( new GCEnv ( MetadataTable . NAME ) ) ; \n \n \t2 log . info ( <string_literal> , status . current . candidates ) ; \n \n \t2 log . info ( <string_literal> , status . current . inUse ) ; \n \n \t2 log . info ( <string_literal> , status . current . deleted ) ; \n \n <ect>
\t4 TupleImplExt tp = new TupleImplExt ( topologyContext , values , taskId , out_stream_id , msgId ) ; \n \n \t4 tp . setTargetTaskId ( t ) ; \n \n \t4 transferCtr ( tp ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 this . identityPath = null ; } } \n \n \t1 public void scpFileToRemote ( String localFile , String remoteTargetDirectory ) throws Exception { \n \n \t2 FileInputStream fis = null ; \n \n \t2 try { \n \n <ect>
\t2 else if ( LockMode . OPTIMISTIC . equals ( lockMode ) ) { \n \n \t3 final EntityVerifyVersionProcess verifyVersion = new EntityVerifyVersionProcess ( entity , entry ) ; \n \n \t3 event . getSession ( ) . getActionQueue ( ) . registerProcess ( verifyVersion ) ; } \n \n \t2 if ( event . getPersister ( ) . implementsLifecycle ( ) ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testCutTerminalVersion ( ) { \n \n <ect>
\t3 try { \n \n \t4 if ( session != null ) { \n \n \t5 session . close ( ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 <comment> \n \n \t1 private void handleResponseError ( HttpMethod method , URI url , ClientHttpResponse response ) throws IOException { \n \n \t3 try { \n \n <ect>
\t6 this . useFast = true ; \n \n \t6 messageHandler . sendMessage ( reTxMsg ) ; \n \n \t6 state = reTxState ; <comment> \n \n \t5 } else { \n \n <ect>
\t3 File newBase = new File ( basedir ) ; \n \n \t3 if ( ! newBase . isDirectory ( ) ) { \n \n \t4 newBase = newBase . getParentFile ( ) ; } \n \n \t3 base = newBase ; \n \n <ect>
\t2 Version v2 = createVersion ( 1 , <number_literal> ) ; \n \n \t2 Version v3 = createVersion ( 1 , <number_literal> ) ; \n \n \t2 logger . info ( <string_literal> + v1 ) ; \n \n \t2 logger . info ( <string_literal> + v2 ) ; \n \n <ect>
<comment> \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 private void checkTransform ( ) throws Exception { \n \n <ect>
\t3 else \n \n \t4 log . info ( <string_literal> ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n \t3 <comment> \n \n <ect>
\t7 false , \n \n \t7 CmsResourceFilter . ALL ) ) { \n \n \t6 inActiveKey = Messages . GUI_CONTEXTMENU_TITLE_INACTIVE_PERM_WRITE_0 ; } \n \n \t4 } catch ( CmsException e ) { \n \n <ect>
\t2 logger . info ( <string_literal> + ( end2 - end1 ) + <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 if ( modelFilename != null && ! modelFilename . trim ( ) . isEmpty ( ) ) \n \n \t3 writeModel ( workspace , workspace . getOntologyManager ( ) , alignmentMappingGenerator , worksheet , modelFilename ) ; \n \n <ect>
\t4 s_logger . warn ( <string_literal> + primaryPool . getType ( ) . toString ( ) ) ; \n \n \t4 throw new InternalErrorException ( <string_literal> + primaryPool . getType ( ) . toString ( ) ) ; } \n \n \t3 return new Answer ( cmd , true , <string_literal> + snap_full_name + <string_literal> ) ; \n \n \t2 } catch ( RadosException e ) { \n \n <ect>
\t4 } , delay ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 logger . error ( <string_literal> , nm ( ) , e ) ; \n \n \t3 } catch ( FieldException e ) { \n \n <ect>
\t4 copReq . setNewObjectMetadata ( objectMetaData ) ; \n \n \t4 Copy copy = tmx . copy ( s3ReqDecorator . decorate ( copReq ) ) ; \n \n \t4 try { \n \n \t5 copy . waitForCopyResult ( ) ; \n \n <ect>
\t2 File ( pid_file , action = <string_literal> ) \n \n \t2 except OSError as exc : \n \n \t2 # OSError : [ Errno <number_literal> ] No such file or directory \n \n \t2 if exc . errno == errno . ENOENT : \n \n <ect>
\t1 } catch ( NoSuchElementException e ) { \n \n \t1 <comment> \n \n \t1 return new ArrayList ( 0 ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
public class AccessLogSamplerBeanInfo extends BeanInfoSupport { \n \n \t1 private static final Logger log = LoggerFactory . getLogger ( AccessLogSamplerBeanInfo . class ) ; \n \n \t1 public AccessLogSamplerBeanInfo ( ) { \n \n \t2 super ( AccessLogSampler . class ) ; \n \n <ect>
<comment> \n \n public RESPONSE post ( WebResource resource , MultivaluedMapImpl data ) throws IOException { \n \n <ect>
\t3 + convertToJsArgs ( args , ke ) + <string_literal> ; \n \n \t1 return executeJavascriptInWebView ( <string_literal> \n \n \t2 + wrappedScript + <string_literal> ) ; \n \n \t1 } catch ( JSONException e ) { \n \n <ect>
\t10 _vmDiskStatsDao . update ( stat . getId ( ) , stat ) ; } } \n \n \t8 s_logger . debug ( <string_literal> ) ; } \n \n \t6 } ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t2 if ( artDownloadLocation != null ) { \n \n \t3 LOG . info ( <string_literal> + artDownloadLocation ) ; \n \n \t3 System . setProperty ( <string_literal> , artDownloadLocation ) ; \n \n \t2 } else if ( System . getProperty ( <string_literal> ) != null ) { \n \n <ect>
\t4 false ) ) ; } \n \n \t1 } catch ( JMException e ) { \n \n \t1 log . error ( <string_literal> + name + <string_literal> , e ) ; \n \n \t1 } catch ( RuntimeException e ) { \n \n <ect>
\t5 if ( prevNetDb == null ) { \n \n \t6 if ( ( ! getContext ( ) . banlist ( ) . isBanlistedForever ( key ) ) && \n \n \t7 getContext ( ) . blocklist ( ) . isBlocklisted ( ri ) && \n \n \t7 _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 if ( krb5Conf != null && krb5Principal != null && krb5Keytab != null ) { \n \n \t5 LOG . info ( <string_literal> ) ; \n \n \t5 LOG . info ( <string_literal> + krb5Conf ) ; \n \n \t5 LOG . info ( <string_literal> + krb5Principal ) ; \n \n <ect>
\t3 logger . info ( <string_literal> + line ) ; \n \n \t3 if ( ! line . startsWith ( preFix ) ) \n \n \t4 continue ; \n \n \t3 if ( force == true ) { \n \n <ect>
\t2 ExecutorService executorService = camelContext . getExecutorServiceManager ( ) . newSingleThreadExecutor ( this , <string_literal> ) ; \n \n \t2 Runnable task = ( ) - > { \n \n \t3 try { \n \n \t4 latch . await ( ) ; \n \n <ect>
\t1 @ Override public boolean cancel ( ) throws GridException { \n \n \t2 if ( ! onCancelled ( ) ) \n \n \t3 return false ; \n \n <ect>
\t4 } else if ( action == Action . SUSPEND_ROUTE ) { \n \n \t5 log . info ( <string_literal> , routeId , tail ) ; \n \n \t5 camelContext . suspendRoute ( routeId ) ; \n \n \t4 } else if ( action == Action . SUSPEND_ALL_ROUTES ) { \n \n <ect>
\t2 return alreadyExists ; } \n \n \t1 private void executeStatement ( TransactionContext transactionContext , String createStatement , boolean ignoreStatementExecutionFailure ) throws IOException { \n \n \t2 Statement statement = null ; \n \n \t2 try { \n \n <ect>
\t4 { \n \n \t5 pos = responseBuffer . indexOf ( <string_literal> ) ; } } } \n \n \t2 if ( pos >= 0 ) \n \n \t2 { \n \n <ect>
\t3 String message ; \n \n \t3 boolean currentState = ERXExtensions . adaptorLogging ( ) ; \n \n \t3 int instance = request ( ) . applicationNumber ( ) ; \n \n \t3 if ( instance == - 1 ) { \n \n <ect>
\t3 if ( is == null && ! externalProcess . isDestroyed ( ) ) { \n \n \t4 Runnable r = new Runnable ( ) { \n \n \t5 @ Override \n \n \t5 public void run ( ) { \n \n <ect>
<comment> ; \n \n @ SuppressWarnings ( <string_literal> ) \n \n void init ( ) { \n \n <ect>
<comment> \n \n \t1 public static void main ( String [ ] argv ) { \n \n \t2 try { \n \n <ect>
\t3 if ( ! _firewallMgr . applyRules ( lbRules , true , false ) ) { \n \n \t4 s_logger . warn ( <string_literal> ) ; \n \n \t4 success = false ; } \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t4 LOGGER . warn ( <string_literal> , e ) ; } \n \n \t3 try { \n \n \t4 storagePoolManager . disconnectPhysicalDisk ( srcPrimaryDataStore . getPoolType ( ) , srcPrimaryDataStore . getUuid ( ) , srcPath ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t2 for ( File file : testPoolDir . listFiles ( vhdsFilt ) ) { \n \n \t3 if ( file . getName ( ) . equals ( testVolWorks . getName ( ) ) ) { \n \n \t4 continue ; } \n \n \t3 Assert . assertTrue ( <string_literal> + file . getPath ( ) , file . delete ( ) ) ; \n \n <ect>
\t1 private GLSLMaterial defaultShaderProgram ; \n \n \t1 private GLSLMaterial defaultTexturedShaderProgram ; \n \n \t1 private Set < GLSLMaterial > progamaticShaders = Sets . newHashSet ( ) ; \n \n \t1 public ShaderManagerLwjgl ( ) { \n \n <ect>
@ Override \n \n public void dispatch ( Notification notification ) { \n \n \t1 LOG . info ( <string_literal> , notification ) ; \n \n \t1 if ( null == notification . DispatchProperties ) { \n \n <ect>
\t3 String hostname , int portnumber , String username , String password , \n \n \t3 String tableName , String dBorSIDName , int rowCount ) throws SQLException , ClassNotFoundException { \n \n \t2 Connection conn = getConnection ( hostname , portnumber , username , password , dBorSIDName ) ; \n \n \t2 String query = <string_literal> + rowCount + <string_literal> + tableName ; \n \n <ect>
\t7 + <string_literal> ) ; <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 if ( maxConcurrentDownloads == 1 ) { \n \n <ect>
\t2 } ) ) ; \n \n \t2 <comment> \n \n \t2 brokerService . stop ( ) ; \n \n \t2 brokerService . waitUntilStopped ( ) ; \n \n <ect>
\t1 <comment> \n \n \t1 LOG . debug ( <string_literal> + name + <string_literal> ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t1 <comment> \n \n <ect>
\t2 NaServer s = null ; \n \n \t2 try { \n \n \t3 s = getServer ( vol . getIpAddress ( ) , vol . getUsername ( ) , vol . getPassword ( ) ) ; \n \n <ect>
\t2 if ( results . stream ( ) \n \n \t4 . noneMatch ( entry - > entry . getDeviceFingerprint ( ) . equals ( fingerprint ) ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , principal ) ; \n \n \t3 return no ( ) ; } \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t3 succes = true ; \n \n \t2 } catch ( PebbleException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 public void close ( ) { \n \n \t2 try { \n \n \t3 endpoint . release ( ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t4 m . setQuietTime ( 500L ) ; \n \n \t3 } catch ( FieldException e ) { \n \n \t4 logger . warn ( <string_literal> , e ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 if ( result . equals ( <string_literal> ) ) { \n \n \t3 _context . waitForTaskProgressDone ( morTask ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t1 JobClient . startJobClientActorSystem ( originalConfiguration , hostname ) } } \n \n def start ( ) : Unit = { \n \n \t1 start ( true ) } \n \n def start ( waitForTaskManagerRegistration : Boolean ) : Unit = { \n \n <ect>
\t2 public void receive ( final org . jgroups . Message message ) { \n \n \t3 try { \n \n \t4 Serializable payload = fromByteArray ( message . getBuffer ( ) , getClass ( ) . getClassLoader ( ) ) ; \n \n <ect>
\t2 if ( StringUtils . isEmpty ( hostId ) ) { \n \n \t3 logger . error ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( StringUtils . isEmpty ( dateString ) ) { \n \n <ect>
<comment> \n \n \t1 public final T create ( @ SuppressWarnings ( <string_literal> ) CreationalContext < T > creationalContext ) { \n \n \t2 T repoInstance = this . repoInstance ; \n \n \t2 if ( repoInstance != null ) { \n \n <ect>
\t1 initializeSerProperties ( taskContext , tableProperties ) ; \n \n \t1 LOG . info ( <string_literal> + name ) ; \n \n \t1 realWriter = \n \n \t3 ( ( ParquetOutputFormat ) realOutputFormat ) . getRecordWriter ( taskContext , new Path ( name ) ) ; \n \n <ect>
\t4 errorCount ++ ; \n \n \t4 continue ; } \n \n \t3 byte [ ] actual = perNodeSlopMap . get ( key ) ; \n \n \t3 if ( actual == null ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t1 public void timeRun ( final int reps ) throws Exception { \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 TrafficControl . delay ( latency ) ; \n \n \t2 TrafficControl . delay ( 0 ) ; \n \n <ect>
\t3 logger . warn ( <string_literal> , itemName ) ; } } \n \n \t1 private void sendDataToDevice ( String deviceId , EpsonProjectorCommandType commmandType , Command command ) { \n \n \t2 DeviceConfig device = deviceConfigCache . get ( deviceId ) ; \n \n \t2 if ( device == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( EXTRACT_CONTAMINATED ) CONTAMINATION = 1 - CONTAMINATION ; \n \n \t2 final Map < String , Fingerprint > fingerprintMap = checker . identifyContaminant ( INPUT . toPath ( ) , CONTAMINATION , LOCUS_MAX_READS ) ; \n \n \t2 if ( fingerprintMap . size ( ) != 1 ) { \n \n <ect>
\t5 bindings , NO_MAPPINGS ) ; \n \n \t3 String path = null ; \n \n \t3 for ( ResultRow rr : result . getRows ( ) ) { \n \n \t4 if ( path != null ) { \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t4 <comment> \n \n \t4 LOG . info ( <string_literal> , hp , e ) ; \n \n \t3 } catch ( SSLContextException e ) { \n \n <ect>
<comment> \n \n \t1 protected Float extractIEVersion ( String userAgent ) { \n \n \t2 if ( StringUtils . isEmpty ( userAgent ) ) { \n \n <ect>
\t3 attemptItemAdvanceFinal ( ROLE . STEP2 , false ) ; \n \n \t3 contextReload ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 e . printStackTrace ( ) ; \n \n <ect>
\t5 endResult = false ; \n \n \t4 } else { \n \n \t5 results [ i ++ ] = null ; } \n \n \t3 } catch ( final Throwable e ) { \n \n <ect>
\t2 if ( camelContext != null ) { \n \n \t3 try { \n \n \t4 camelContext . stop ( ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
\t4 builder . append ( <string_literal> ) . append ( exception . getColumnNumber ( ) ) ; \n \n \t4 builder . append ( <string_literal> ) . append ( exception . getPublicId ( ) ) ; \n \n \t4 builder . append ( <string_literal> ) . append ( exception . getSystemId ( ) ) ; \n \n \t4 builder . append ( <string_literal> ) . append ( exception . getLocalizedMessage ( ) ) ; \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( ErrorHandlerBuilderRef . isErrorHandlerBuilderConfigured ( ref ) ) { \n \n <ect>
\t2 try { \n \n \t2 JWSVerifier verifier = new RSASSAVerifier ( publicKey ) ; \n \n \t2 if ( jwtToken . verify ( verifier ) ) { \n \n \t3 valid = true ; \n \n <ect>
\t2 public void failed ( Throwable throwable ) { \n \n \t3 if ( throwable instanceof TimeoutException ) { \n \n \t4 logger . info ( throwable . toString ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 s_logger . error ( <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 String username = cmd . getContextParam ( <string_literal> ) ; \n \n \t2 if ( username == null || username . isEmpty ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 String key = SEQUENCE_PREFIX + iname ; \n \n \t3 classname = configurationService . getArrayProperty ( key ) ; \n \n \t3 if ( classname == null || classname . length == 0 ) { \n \n <ect>
\t3 _interrupted = true ; \n \n \t3 if ( _socket != null ) { \n \n \t4 try { \n \n \t5 _socket . close ( ) ; \n \n <ect>
\t2 final Optional < SamlRegisteredServiceServiceProviderMetadataFacade > adaptor = \n \n \t4 SamlRegisteredServiceServiceProviderMetadataFacade . get ( this . samlRegisteredServiceCachingMetadataResolver , \n \n \t6 SamlRegisteredService . class . cast ( registeredService ) , entityID ) ; \n \n \t2 if ( ! adaptor . isPresent ( ) ) { \n \n <ect>
\t7 if ( is != null ) { \n \n \t8 LOGGER . debug ( <string_literal> , fileName ) ; \n \n \t7 } else { \n \n <ect>
\t2 try { \n \n \t3 LOG . info ( <string_literal> , webRootDir ) ; \n \n \t3 FileUtils . deleteDirectory ( webRootDir ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t3 byte [ ] response = receiveData ( ) ; \n \n \t3 logger . info ( <string_literal> , DataParser . bytesToHex ( response ) ) ; \n \n \t3 return ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 initHTableCoprocessor ( tableDesc ) ; \n \n \t3 logger . info ( <string_literal> + tableDesc . getTableName ( ) + <string_literal> ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 logger . error ( <string_literal> + tableDesc . getTableName ( ) , ex ) ; \n \n <ect>
\t2 throws UnsupportedEncodingException { \n \n \t2 String [ ] engineURLs = configurationService \n \n \t3 . getArrayProperty ( <string_literal> ) ; \n \n \t2 if ( ArrayUtils . isEmpty ( engineURLs ) ) { \n \n <ect>
\t1 LOG . info ( <string_literal> , hostId , \n \n \t2 clusterDesiredConfigs . toString ( ) ) ; \n \n \t1 Map < String , Map < String , String > > configTags = \n \n \t2 getEffectiveDesiredTags ( cl , host . getHostName ( ) , clusterDesiredConfigs ) ; \n \n <ect>
\t1 public void savePageInPermanentCache ( WOComponent wocomponent ) { \n \n \t2 if ( overridePrivateCache ) { \n \n \t3 WOContext wocontext = context ( ) ; \n \n \t3 String contextID = wocontext . contextID ( ) ; \n \n <ect>
\t4 scheduler . scheduleAtFixedRate ( commiter , minutes , minutes , TimeUnit . MINUTES ) ; \n \n \t4 GroupManager . logger . info ( <string_literal> + minutes + <string_literal> ) ; \n \n \t3 } else \n \n \t4 GroupManager . logger . info ( <string_literal> ) ; \n \n <ect>
\t2 LOG . info ( getName ( ) + <string_literal> ) ; \n \n \t2 connectionsEstablished . acquire ( ) ; \n \n \t2 LOG . info ( <string_literal> + ( SAMPLE_DELAY / <number_literal> . 0f ) + <string_literal> ) ; \n \n \t2 Thread . sleep ( <number_literal> * <number_literal> ) ; \n \n <ect>
\t2 String eventId = getEventId ( ) ; \n \n \t2 if ( eventId == null ) { \n \n \t3 return ; } \n \n <ect>
\t1 public void remove ( T entity ) throws PersistenceException { \n \n \t2 K id = null ; \n \n \t2 try { \n \n \t3 if ( verbose ) \n \n <ect>
\t3 s_logger . warn ( <string_literal> + networkId + <string_literal> ) ; \n \n \t3 success = false ; } \n \n \t2 <comment> \n \n \t2 if ( ! _rulesMgr . applyPortForwardingRulesForNetwork ( networkId , false , caller ) ) { \n \n <ect>
\t1 SaslMechanism mechanism ; \n \n \t1 try { \n \n \t1 mechanism = SaslMechanism . get ( saslServer . getMechanismName ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 protected < C extends T > ClassMetadata < C , ? > createMetadata ( Class < C > type , ReflectFactory factory , CopyStrategyLibrary copyStrategies , SimpleUri uri ) { \n \n \t2 try { \n \n \t3 return new DefaultClassMetadata < > ( uri , type , factory , copyStrategies ) ; \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , message ) ; } \n \n \t2 try { \n \n \t3 signal = getIntFromText ( SIGNAL_REG_EXP , message ) ; \n \n \t2 } catch ( LightwaveRfMessageException le ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
\t3 store . deleteArchive ( attachment , context , false ) ; \n \n \t3 try { \n \n \t4 session . delete ( attachment ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<number_literal> synchronized ( brokerService . getVmConnectorURI ( ) ) { \n \n <number_literal> addConsumerInfo ( consumerInfo ) ; } } \n \n \t9 } else { \n \n \t10 <comment> \n \n <ect>
\t2 } ; } \n \n \t1 public static class MyPredicate implements Predicate { \n \n \t2 public String body ; \n \n \t2 public boolean matches ( Exchange exchange ) { \n \n <ect>
\t6 + <string_literal> + ( count > 0 ) ) ; } \n \n \t3 return count > 0 ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t1 public void run ( ) { \n \n \t2 try { \n \n \t3 commandRun ( ) ; \n \n \t2 } catch ( IOException ie ) { \n \n <ect>
\t3 registerNodeStoreIfPossible ( ) ; } } \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 protected void unbindBlobDataSource ( DataSource dataSource ) { \n \n \t2 if ( this . blobDataSource != dataSource ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected Event doExecute ( final RequestContext requestContext ) { \n \n \t2 final Authentication c = WebUtils . getAuthentication ( requestContext ) ; \n \n \t2 if ( c == null ) { \n \n <ect>
\t5 logger . info ( <string_literal> + adviceBean ) ; } } \n \n \t3 if ( ResponseBodyAdvice . class . isAssignableFrom ( beanType ) ) { \n \n \t4 this . responseBodyAdvice . add ( adviceBean ) ; \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t1 long tb1 = query ( c , tables [ 0 ] , 1 , 0 , <number_literal> , <number_literal> , <number_literal> ) ; \n \n \t1 long tb2 = query ( c , tables [ 1 ] , <number_literal> , 0 , <number_literal> , <number_literal> , <number_literal> ) ; \n \n \t1 long tb3 = query ( c , tables [ <number_literal> ] , <number_literal> , 0 , <number_literal> , <number_literal> , <number_literal> ) ; \n \n <ect>
\t2 obj = KeyGenerator . getInstance ( ) . generateSigningKeypair ( ) ; \n \n \t2 signingPubKey = ( SigningPublicKey ) obj [ 0 ] ; \n \n \t2 signingPrivKey = ( SigningPrivateKey ) obj [ 1 ] ; \n \n \t2 _log . debug ( <string_literal> + signingPubKey ) ; \n \n <ect>
\t4 Reference reference = findAnnotation ( bridgedMethod , Reference . class ) ; \n \n \t4 if ( reference != null && method . equals ( ClassUtils . getMostSpecificMethod ( method , beanClass ) ) ) { \n \n \t5 if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { \n \n <ect>
private static final Logger LOG = LoggerFactory . getLogger ( AbstractLogSearchSteps . class ) ; \n \n protected void initDockerContainer ( ) throws Exception { \n \n \t1 boolean logsearchStarted = StoryDataRegistry . INSTANCE . isLogsearchContainerStarted ( ) ; \n \n \t1 if ( ! logsearchStarted ) { \n \n <ect>
\t2 final String aName ; \n \n \t2 try { \n \n \t3 aName = ( String ) ( ActionNames . class . getField ( this . actionName ) . get ( null ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 for ( int i = 0 ; i < aComps . length ; i ++ ) { \n \n \t5 String aComp = aComps [ i ] ; \n \n \t5 aHardwareAddress [ i ] = ( byte ) Short . valueOf ( aComp , <number_literal> ) . shortValue ( ) ; } } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 HttpServletResponseTracker response = action . response ; \n \n \t2 if ( action . verbose ) \n \n \t2 { \n \n \t3 if ( action . contentType != null ) \n \n <ect>
\t1 public void writeDevicesBackToResource ( final List < U2FDeviceRegistration > list ) throws Exception { \n \n \t2 final Map < String , List < U2FDeviceRegistration > > newDevices = new HashMap < > ( ) ; \n \n \t2 newDevices . put ( MAP_KEY_SERVICES , list ) ; \n \n \t2 mapper . writerWithDefaultPrettyPrinter ( ) . writeValue ( jsonResource . getFile ( ) , newDevices ) ; \n \n <ect>
public Swagger read ( Set < Class < ? > > classes ) { \n \n \t1 <comment> \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 for ( Class < ? > cls : classes ) { \n \n <ect>
\t3 return ; } \n \n \t2 if ( channelFuture . channel ( ) . disconnect ( ) . awaitUninterruptibly ( 1 , TimeUnit . SECONDS ) ) { \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t1 log . info ( \n \n \t2 String . format ( <string_literal> , ( System . currentTimeMillis ( ) - now ) / <number_literal> . ) ) ; \n \n \t1 sleepUninterruptibly ( <number_literal> , TimeUnit . SECONDS ) ; \n \n \t1 long getFileInfoOpts = getOpts ( ) - startOps ; \n \n <ect>
\t4 else { \n \n \t5 tableMeta . put ( tmd . getSchemaName ( ) . toUpperCase ( ) , tmd ) ; } } } \n \n \t2 catch ( SQLException ex ) { \n \n <ect>
\t1 public void testUnfoldTop ( ) { \n \n \t2 try { \n \n \t3 executeBasicJSONTest ( <string_literal> , <string_literal> , false , <number_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 log . info ( <string_literal> + rsrc2 ) ; \n \n \t6 log . info ( <string_literal> + rsrc3 ) ; \n \n \t6 log . info ( <string_literal> + rsrc4 ) ; \n \n \t6 log . info ( <string_literal> + rsrc5 ) ; \n \n <ect>
\t4 if ( ! tournamentPlayer . hasQuit ( ) ) { \n \n \t5 if ( tournamentPlayer . getPlayer ( ) . isHuman ( ) ) { \n \n \t6 Optional < User > user = UserManager . instance . getUser ( entry . getKey ( ) ) ; \n \n \t6 if ( ! user . isPresent ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 greeterImpl = new GreeterImpl ( ) ; \n \n \t2 String address = <string_literal> + port + <string_literal> ; \n \n \t2 endpoint = Endpoint . publish ( address , greeterImpl ) ; \n \n <ect>
\t2 NginxClojureRT . ngx_http_hijack_send_header ( request . nativeRequest ( ) , flag ) ; } \n \n \t1 protected int sendHeader ( byte [ ] message , long off , int len , int flag ) { \n \n \t2 int rc = ( int ) NginxClojureRT . ngx_http_hijack_send_header ( request . nativeRequest ( ) , message , MiniConstants . BYTE_ARRAY_OFFSET + off , len , flag ) ; \n \n \t2 if ( rc < 0 ) { \n \n <ect>
\t3 } catch ( IllegalAccessException e ) { \n \n \t4 s_logger . error ( e . getMessage ( ) , e ) ; \n \n \t4 return null ; } \n \n \t2 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t4 inputSource . setByteStream ( inputStream ) ; \n \n \t4 digester . push ( this ) ; \n \n \t4 digester . parse ( inputSource ) ; \n \n \t3 } catch ( SAXParseException spe ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 if ( registeredMBeans . remove ( key ) ) { \n \n \t3 try { \n \n \t4 managementContext . unregisterMBean ( key ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t3 switch ( message . payload . messageType ) \n \n \t3 { \n \n \t4 case PREPARE_MESSAGE : \n \n \t5 PrepareMessage prepareMessage = ( PrepareMessage ) message . payload ; \n \n <ect>
\t1 throw new ServiceFormattedException ( <string_literal> , e ) ; } } \n \n @ Override \n \n public synchronized < T extends Indexed > List < T > loadAll ( Class < T > model , FilteringStrategy filter ) { \n \n \t1 LinkedList < T > list = new LinkedList < T > ( ) ; \n \n <ect>
\t8 ? hiveToMongo . get ( fieldName ) \n \n \t8 : fieldName ; } \n \n \t4 value = deserializeField ( getValue ( doc , mongoMapping ) , fieldTypeInfo , fieldName ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t7 ChannelListener < Object > l = en . getValue ( ) ; \n \n \t7 if ( l instanceof MessageListener ) { \n \n \t8 ( ( MessageListener ) l ) . onClose ( en . getKey ( ) , status , txt ) ; } \n \n \t6 } catch ( Throwable e ) { \n \n <ect>
\t2 Marshaller marshaller = jaxbContext . createMarshaller ( ) ; \n \n \t2 marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; \n \n \t2 StringWriter buffer = new StringWriter ( ) ; \n \n \t2 marshaller . marshal ( context , buffer ) ; \n \n <ect>
\t2 if ( this . contextRefresher == null ) { \n \n \t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 if ( event . isEligibleForContextRefresh ( ) ) { \n \n <ect>
def getUptimeSeconds ( self ) : \n \n \t1 try : \n \n \t1 return int ( self . data_return_first ( <string_literal> , self . DATA_UPTIME_OUTPUT ) ) \n \n \t1 except ValueError : \n \n <ect>
\t6 batch . replace ( msg , tmpMsg ) ; \n \n \t5 else \n \n \t6 batch . remove ( msg ) ; } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t4 try { \n \n \t5 int value = Integer . parseInt ( property ) ; \n \n \t5 this . setInitialSize ( value ) ; \n \n \t4 } catch ( NumberFormatException e ) { \n \n <ect>
\t3 if ( InteractionHandler . v ( ) . getInteractionListener ( ) == null ) { \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t4 Options . v ( ) . set_interactive_mode ( false ) ; \n \n \t3 } else { \n \n <ect>
\t2 LOG . debug ( <string_literal> , e ) ; \n \n \t2 throw new EucalyptusCloudException ( e ) ; } \n \n \t1 memObj . eTag = DigestUtils . md5Hex ( new String ( memObj . content ) ) ; \n \n \t1 if ( ! Strings . isNullOrEmpty ( request . getContentMD5 ( ) ) && ! memObj . eTag . equals ( request . getContentMD5 ( ) ) ) { \n \n <ect>
\t5 deletedDate = DateUtil . parseDateString ( s_gmtTimeZone , deletedTS ) ; } \n \n \t4 usageRecords . add ( new UsagePortForwardingRuleVO ( pfId , zoneId , acctId , dId , createdDate , deletedDate ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t1 PublicIPAddressProperties properties = PublicIPAddressProperties . builder ( ) \n \n \t3 . publicIPAllocationMethod ( <string_literal> ) \n \n \t3 . idleTimeoutInMinutes ( <number_literal> ) \n \n \t3 . build ( ) ; \n \n <ect>
\t3 logger . info ( <string_literal> + bar ) ; \n \n \t3 return bar . toUpperCase ( ) ; } \n \n \t2 @ EventListener ( condition = <string_literal> ) \n \n \t2 public void onApplicationEventBar ( ListenerContainerIdleEvent event ) { \n \n <ect>
\t1 logFile . logUpdateOperation ( createUpdateJournalEntry ( txId , AbstractQueueTxJournalEntry . Operation . ADD . getByteRepresentation ( ) , \n \n <number_literal> queue . getName ( ) , value ) ) ; } \n \n public void logAddFirst ( T txId , QueueStore queue , Serializable item ) { \n \n <ect>
\t2 status = Status . KILLED ; } \n \n \t1 public synchronized void suspend ( ) throws WorkflowException { \n \n \t2 if ( status != Status . RUNNING ) { \n \n \t3 throw new WorkflowException ( ErrorCode . E0716 ) ; } \n \n <ect>
\t3 PlayApplicationRunner playApplicationRunner = playToolProvider . get ( PlayApplicationRunner . class ) ; \n \n \t3 deploymentHandle = deploymentRegistry . start ( deploymentId , DeploymentRegistry . ChangeBehavior . BLOCK , PlayApplicationDeploymentHandle . class , spec , playApplicationRunner ) ; \n \n \t3 InetSocketAddress playAppAddress = deploymentHandle . getPlayAppAddress ( ) ; \n \n \t3 String playUrl = <string_literal> + playAppAddress . getPort ( ) + <string_literal> ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t2 LOG . warn ( <string_literal> ) ; \n \n \t2 } else if ( ex instanceof CancellationException ) { \n \n \t2 ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t3 bitsField = BloomFilter . class . getDeclaredField ( <string_literal> ) ; \n \n \t3 bitsField . setAccessible ( true ) ; \n \n \t2 } catch ( SecurityException | NoSuchFieldException e ) { \n \n <ect>
\t3 generator . writeEndArray ( ) ; \n \n \t3 generator . writeObjectField ( <string_literal> , getMacroSearchResults ( macroSearches ) ) ; \n \n \t3 generator . writeEndObject ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 File javaTmpdir = new File ( System . getProperty ( <string_literal> ) ) ; \n \n \t2 if ( ! FileUtil . isDirectoryWritable ( javaTmpdir ) ) { \n \n \t3 logger . error ( <string_literal> { } \\ <string_literal> , javaTmpdir . getAbsolutePath ( ) ) ; \n \n <ect>
\t1 if roleResult [ 'stdout' ] != '' : \n \n \t2 logger . info ( <string_literal> + str ( command [ 'taskId' ] ) + <string_literal> \n \n \t5 + command [ 'role' ] + <string_literal> + command [ 'roleCommand' ] ) \n \n \t2 self . log_command_output ( roleResult [ 'stdout' ] , str ( command [ 'taskId' ] ) ) \n \n <ect>
\t2 } else if ( this . payload . length == WALL_THERMOSTAT_CONTROL_SET_POINT_ONLY_PAYLOAD_LEN ) { \n \n \t3 desiredTemperature = ( this . payload [ 0 ] & 0x7F ) / <number_literal> . 0 ; \n \n \t3 measuredTemperature = null ; \n \n \t2 } else { \n \n <ect>
\t3 } catch ( QueryException e ) { \n \n \t4 log . warn ( <string_literal> + query . uuid ( ) + <string_literal> + e + <string_literal> + consumer ) ; \n \n \t4 consumer . sourceError ( e ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 SSLContext . getDefault ( ) . getSupportedSSLParameters ( ) . getProtocols ( ) , <string_literal> ) ; \n \n \t4 logger . info ( <string_literal> , allProtocols ) ; \n \n \t4 props . setProperty ( <string_literal> + protocol + <string_literal> , allProtocols ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 for ( Object [ ] group : groups ) { \n \n \t4 String groupName = ( String ) group [ 0 ] ; \n \n \t4 Long accountId = ( Long ) group [ 1 ] ; \n \n \t4 if ( ! checkInstanceGroup ( conn , groupName , accountId ) ) { \n \n <ect>
<comment> \n \n private void putKeyStore ( KeyStore keyStore , File keyStoreFile ) throws AmbariException { \n \n <ect>
\t2 int httpCompressedSize = httpContent . getLength ( ) ; \n \n \t2 assertEquals ( tcpContent . getLength ( ) , httpContent . getLength ( ) ) ; \n \n \t2 assertEquals ( tcpMessage . readUTF ( ) , httpMessage . readUTF ( ) ) ; \n \n \t2 LOG . info ( <string_literal> + tcpMessage . toString ( ) ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 { \n \n \t3 logger . error ( <string_literal> , ex ) ; } \n \n \t2 catch ( IOException ex ) \n \n \t2 { \n \n <ect>
\t2 if ( password == null ) { \n \n \t3 s_logger . info ( <string_literal> ) ; \n \n \t3 System . exit ( <number_literal> ) ; } \n \n \t2 try { \n \n <ect>
\t1 JSONObject response = new JSONObject ( ) ; \n \n \t1 response . put ( <string_literal> , job ) ; \n \n \t1 return Response . status ( Response . Status . ACCEPTED ) . entity ( response ) . build ( ) ; \n \n \t1 } catch ( ServiceException e ) { \n \n <ect>
\t1 private R wrapWithOnFallbackEmitHook ( R r ) { \n \n \t2 try { \n \n \t3 return executionHook . onFallbackEmit ( this , r ) ; \n \n \t2 } catch ( Throwable hookEx ) { \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 assertTrue ( localBroker . removeNetworkConnector ( nc ) ) ; \n \n \t2 nc1 = localBroker . getNetworkConnectorByName ( <string_literal> ) ; \n \n \t2 assertNull ( <string_literal> , nc1 ) ; \n \n <ect>
\t3 LOGGER . error ( e . getLocalizedMessage ( ) , e ) ; } } \n \n \t1 private Context getInitialContext ( ) throws NamingException { \n \n \t2 Hashtable < String , String > table = new Hashtable < > ( ) ; \n \n \t2 if ( getInitialContextFactory ( ) != null && getInitialContextFactory ( ) . trim ( ) . length ( ) > 0 ) { \n \n <ect>
\t3 s_logger . warn ( <string_literal> + vmId + <string_literal> ) ; \n \n \t3 return new ConsoleAccessAuthenticationAnswer ( cmd , false ) ; } \n \n \t2 HostVO host = _hostDao . findById ( vm . getHostId ( ) ) ; \n \n \t2 if ( host == null ) { \n \n <ect>
\t1 if not queue . empty ( ) : \n \n \t1 responce = queue . get ( ) \n \n \t1 else : \n \n \t1 responce = responces [ - 1 ] \n \n <ect>
\t1 } ; \n \n \t1 FileStatus [ ] statuses = fs . listStatus ( path , filter ) ; \n \n \t1 assertEquals ( 0 , statuses . length ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 } else { \n \n \t5 batteryLow = false ; } \n \n \t4 <comment> \n \n \t4 if ( batteryLevel < 0 || batteryLevel > <number_literal> ) { \n \n <ect>
\t3 wh . renameDir ( srcPath , destPath , true ) ; \n \n \t3 LOG . info ( <string_literal> + srcPath + <string_literal> + destPath + <string_literal> ) ; \n \n \t3 dataWasMoved = true ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t7 <comment> \n \n \t7 Person p = Context . getPersonService ( ) . getPersonByUuid ( hl7PersonId ) ; \n \n \t7 if ( p != null ) { \n \n \t8 return p ; } \n \n <ect>
\t2 try { \n \n \t3 client ( ) . admin ( ) . indices ( ) . prepareDelete ( <string_literal> ) . execute ( ) . actionGet ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t3 int code = HttpServletResponse . SC_BAD_REQUEST ; \n \n \t3 response . setStatus ( code ) ; \n \n \t3 response . getWriter ( ) . append ( RestMethodResult . jsonError ( code , <string_literal> + uoe . getMessage ( ) ) ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t4 <comment> \n \n \t4 voice = Voice . getDefaultVoice ( locale ) ; \n \n \t4 logger . debug ( <string_literal> + voice ) ; } \n \n \t3 if ( style == null ) { \n \n <ect>
\t1 <string_literal> <string_literal> <string_literal> \n \n \t1 if self . alert_reports_interval == 0 : \n \n <ect>
\t5 final String error = e . toString ( ) ; \n \n \t5 if ( error . contains ( <string_literal> ) ) { \n \n \t6 s_logger . debug ( <string_literal> + vmName ) ; \n \n \t5 } else { \n \n <ect>
\t4 for ( ConsumerState tally : consumerStates ) { \n \n \t5 final int expected = numMessages * ( tally . destination . isComposite ( ) ? tally . destination . getCompositeDestinations ( ) . length : 1 ) ; \n \n \t5 LOG . info ( <string_literal> + tally . brokerName + <string_literal> + tally . destination + <string_literal> + tally . accumulator . get ( ) ) ; \n \n \t5 if ( tally . accumulator . get ( ) != expected ) { \n \n <ect>
\t5 s_logger . debug ( <string_literal> + hostId + <string_literal> ) ; } \n \n \t4 return false ; } \n \n \t2 } else { \n \n <ect>
\t2 <comment> \n \n \t2 int offset = signature . indexOf ( <string_literal> ) ; \n \n \t2 if ( - 1 != offset ) signature = URLDecoder . decode ( signature , <string_literal> ) ; \n \n \t2 boolean match = signature . equals ( calSig ) ; \n \n <ect>
public void removeBlob ( final String container , final String blobKey ) { \n \n \t1 filesystemContainerNameValidator . validate ( container ) ; \n \n \t1 filesystemBlobKeyValidator . validate ( blobKey ) ; \n \n \t1 String fileName = buildPathStartingFromBaseDir ( container , blobKey ) ; \n \n <ect>
\t3 EmbeddedTransactionManager . getInstance ( ) . begin ( ) ; \n \n \t3 cache . remove ( fqn , <string_literal> ) ; \n \n \t3 EmbeddedTransactionManager . getInstance ( ) . commit ( ) ; } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t1 context . setConnManager ( this ) ; \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 private < T > void startInstance ( T obj , Binding < T > binding , LifecycleMethods methods ) throws Exception \n \n \t1 { \n \n \t2 final Class < ? > instanceType = obj . getClass ( ) ; \n \n <ect>
<comment> \n \n private static void handleParamDeprecation ( Map < String , String > fromMap , Map < String , String > toMap , \n \n \t1 String deprecatedName , String newName , String newUsage ) { \n \n \t1 if ( fromMap . containsKey ( deprecatedName ) ) { \n \n <ect>
\t3 while ( s . length ( ) > 1 && s . startsWith ( <string_literal> ) ) \n \n \t4 s = s . substring ( 1 ) ; \n \n \t3 value = Long . parseLong ( s ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t2 for ( VimExtension extension : Extensions . getExtensions ( VimExtension . EP_NAME ) ) { \n \n \t3 if ( name . equals ( extension . getName ( ) ) ) { \n \n \t3 if ( Options . getInstance ( ) . isSet ( name ) ) { \n \n \t4 extension . init ( ) ; \n \n <ect>
\t3 client . shutdown ( ) ; } \n \n \t1 @ Override \n \n \t1 public void onClientConnected ( ) { } \n \n \t1 public void onClientClose ( ) { \n \n <ect>
\t1 synchronized void stopBuild ( ) \n \n \t1 { \n \n \t2 if ( builder != null ) \n \n \t2 { \n \n <ect>
\t2 editor . queue ( buf , new RunLater < Buf > ( ) { \n \n \t3 @ Override \n \n \t3 public void run ( Buf b ) { \n \n \t4 if ( b . buf == null ) { \n \n <ect>
\t4 PropertyChangedNotification , context ) ; \n \n \t2 log . debug ( <string_literal> , context ) ; \n \n \t2 super . setD2wContext ( context ) ; } \n \n \t1 public NSMutableArray < String > updateContainerIDs ( ) { \n \n <ect>
\t8 version = response . buffer . getInt ( ) ; \n \n \t7 } else { \n \n \t8 LOG . info ( <string_literal> , response . sid ) ; } \n \n \t6 } else { \n \n <ect>
\t3 Map cols_b = ( Map ) t2 . get ( <number_literal> ) ; \n \n \t3 Assert . assertEquals ( cols_a . size ( ) , cols_b . size ( ) ) ; \n \n \t3 count ++ ; } \n \n \t2 Assert . assertEquals ( TEST_ROW_COUNT , count ) ; \n \n <ect>
\t3 LOGGER . info ( <string_literal> + name \n \n \t5 + <string_literal> ) ; \n \n \t3 LOGGER . info ( <string_literal> + name ) ; \n \n \t3 LOGGER . info ( <string_literal> + input ) ; \n \n <ect>
<comment> \n \n \t1 public void start ( ) throws InterruptedException { \n \n <ect>
\t3 networkNeedsMigration ( network , newPhysicalNetworkId , oldNtwkOff , newNtwkOff ) ; } } \n \n \t1 private void verifyAlreadyMigratedTiers ( long migratedVpcId , long vpcOfferingId , Map < String , String > networkToOffering ) { \n \n \t2 Vpc migratedVpc = _vpcDao . findById ( migratedVpcId ) ; \n \n \t2 if ( migratedVpc . getVpcOfferingId ( ) != vpcOfferingId ) { \n \n <ect>
\t2 Exception cause = exchange . getException ( ) ; \n \n \t2 if ( cause != null ) { \n \n \t3 LOG . warn ( <string_literal> + exchange , cause ) ; \n \n \t2 } else { \n \n <ect>
\t6 if ( ips != null ) { \n \n \t7 for ( byte [ ] ip : ips ) { \n \n \t8 if ( ! isValid ( ip ) ) { \n \n \t9 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t3 if ( dscAlarmBindingConfig . getDSCAlarmItemType ( ) . equals ( DSCAlarmItemType . PANEL_COMMAND ) ) { \n \n \t4 dscAlarmItemUpdate . updateDeviceItem ( item , dscAlarmBindingConfig , eventPublisher , null , - 1 , <string_literal> ) ; \n \n \t3 } else { \n \n \t4 dscAlarmItemUpdate . updateDeviceItem ( item , dscAlarmBindingConfig , eventPublisher , null , 0 , <string_literal> ) ; } \n \n <ect>
\t1 val clazz = compile ( \n \n \t1 getRuntimeContext . getUserCodeClassLoader , \n \n \t1 genJoinFuncName , \n \n \t1 genJoinFuncCode ) \n \n <ect>
\t1 log . error ( <string_literal> , e ) ; \n \n \t1 return null ; } \n \n \t1 <comment> \n \n \t1 HostAndPort coordinatorAddr = HostAndPort . fromString ( replCoordinatorAddr ) ; \n \n <ect>
\t4 <comment> \n \n \t4 log . warn ( <string_literal> , clazz . getName ( ) , str ) ; \n \n \t4 throw new IllegalArgumentException ( <string_literal> + str + <string_literal> + clazz . getName ( ) ) ; } \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t5 } else { \n \n \t6 if ( _log . shouldLog ( Log . INFO ) ) \n \n \t7 _log . info ( getJobId ( ) + <string_literal> + _toString ) ; } } } \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 } catch ( NoSuchMethodException nsme ) { \n \n \t5 getter = targetClass . getMethod ( <string_literal> + getterSuffix ) ; } \n \n \t4 value = getter . invoke ( target ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 throw new LoginException ( <string_literal> + principalAttr ) ; } \n \n \t3 if ( principalAttr . size ( ) > 1 ) { \n \n \t4 if ( ! this . allowMultiplePrincipalAttributeValues ) { \n \n \t5 throw new LoginException ( <string_literal> + principalAttr ) ; } \n \n <ect>
\t1 throw new IllegalStateException ( <string_literal> + desc + <string_literal> ) ; } \n \n \t1 Object queryResult = queryCache . get ( id ) ; \n \n \t1 if ( queryResult == null ) { \n \n <ect>
\t5 Map . Entry < ? , ? > me = ( Map . Entry < ? , ? > ) it . next ( ) ; \n \n \t5 String key = ( String ) me . getKey ( ) ; \n \n \t5 String value = ( String ) me . getValue ( ) ; \n \n \t5 if ( value == null ) { \n \n <ect>
\t2 for ( Map . Entry < String , ExporterConfiguration > entry : configuration . getExportConfigurations ( ) . entrySet ( ) ) { \n \n \t3 key = entry . getKey ( ) ; \n \n \t3 value = entry . getValue ( ) ; \n \n <ect>
\t3 if ( filePath . isFile ( ) && filePath . exists ( ) && filePath . canRead ( ) && filePath . length ( ) > 0 ) { \n \n \t4 final RegisteredService svc = validator . from ( filePath ) ; \n \n \t4 LOGGER . info ( <string_literal> , svc . getName ( ) , filePath . getCanonicalPath ( ) ) ; \n \n \t3 } else { \n \n <ect>
def install ( self , env ) : \n \n \t1 self . install_packages ( env ) \n \n \t1 self . configure ( env ) \n \n def pre_upgrade_restart ( self , env , upgrade_type = None ) : \n \n <ect>
\t1 if ( path == null ) { \n \n \t2 log . warn ( <string_literal> + clazz + <string_literal> ) ; \n \n \t2 continue ; } \n \n \t1 if ( ! localFs . exists ( path ) ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 if ( current != null ) { \n \n \t4 log . error ( <string_literal> , current . getName ( ) , e ) ; \n \n \t3 } else { \n \n <ect>
\t4 . setProjection ( Property . forName ( <string_literal> ) ) ; \n \n \t2 Criteria departmentsQuery = session . createCriteria ( Department . class ) . add ( Subqueries . propertyIn ( <string_literal> , salespersonSubquery ) ) ; \n \n \t2 List departments = departmentsQuery . list ( ) ; \n \n \t2 assertEquals ( <string_literal> , 1 , departments . size ( ) ) ; \n \n <ect>
\t5 try { \n \n \t6 p = new Peer ( phys , true , true ) ; \n \n \t5 } catch ( HostnameSyntaxException e ) { \n \n \t6 if ( fromLocal ) \n \n <ect>
\t3 res = cmd . execute ( ) ; \n \n \t3 } else { \n \n \t4 res = cmd . execute ( interpreter ) ; } \n \n \t3 if ( res != null && res . startsWith ( <string_literal> ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 try { \n \n \t4 modelControllerClient . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 return 1 ; \n \n \t4 <comment> \n \n \t4 if ( pn1 . hashCode > pn2 . hashCode ) return 1 ; \n \n \t4 else if ( pn1 . hashCode < pn2 . hashCode ) return - 1 ; \n \n <ect>
\t3 header = header + <string_literal> utf - <number_literal> \\ <string_literal> ; \n \n \t3 header = header + <string_literal> <ect>
\t10 entry . getPrimary ( ) , \n \n \t10 entry . getBackupNodes ( ) ) ; \n \n \t5 rentry . resetDiff ( ) ; \n \n \t4 } catch ( IOException x ) { \n \n <ect>
\t4 if ( out . contains ( <string_literal> ) == false ) { \n \n \t5 logger . error ( 'jps - l' ) \n \n \t5 logger . error ( out ) \n \n \t5 logger . error ( <string_literal> ) \n \n <ect>
\t1 <comment> \n \n \t1 public void activateObject ( LdapConnection connection ) { \n \n <ect>
protected void configure ( ) { \n \n \t1 Multibinder < Cleanable > multiBinder = Multibinder . newSetBinder ( binder ( ) , Cleanable . class ) ; \n \n \t1 Set < Class < ? > > bindingSet = ClasspathScannerUtils . findOnClassPath ( getPackageToScan ( ) , getExclusions ( ) , getSelectors ( ) ) ; \n \n \t1 for ( Class clazz : bindingSet ) { \n \n <ect>
\t2 job . setStartTime ( null ) ; \n \n \t2 job . setEndTime ( null ) ; \n \n \t2 job . incrementRunCount ( ) ; \n \n \t2 Job . logJobEvent ( job , JobEvent . SCHEDULED , eventLog ) ; \n \n <ect>
\t6 <comment> \n \n \t6 { \n \n \t7 <comment> \n \n <ect>
\t3 log . debug ( <string_literal> + jspUri ) ; \n \n \t3 log . debug ( <string_literal> <ect>
\t3 template . requestBody ( <string_literal> + PORT + <string_literal> , <string_literal> , String . class ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 assertStringContains ( e . getCause ( ) . getMessage ( ) , <string_literal> ) ; } \n \n \t2 String response2 = template . requestBody ( <string_literal> + PORT + <string_literal> , <string_literal> , String . class ) ; \n \n <ect>
\t6 <comment> \n \n \t6 doInit ( ) ; } \n \n \t4 } catch ( Throwable e ) { \n \n \t5 <comment> \n \n <ect>
\t4 || driver . getCurrentUrl ( ) . matches ( <string_literal> ) ) ) { \n \n \t3 log . info ( <string_literal> ) ; \n \n \t3 navigateToUri ( uri , waitForMatch , false ) ; } \n \n \t2 else { \n \n <ect>
\t4 s_logger . error ( <string_literal> ) ; \n \n \t3 } else if ( rs . getString ( 1 ) != null || rs . getString ( <number_literal> ) != null ) { \n \n \t4 s_logger . error ( <string_literal> + rs . getString ( 1 ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 Socket socket = new Socket ( <string_literal> , <number_literal> ) ; \n \n \t3 socket . close ( ) ; \n \n \t3 return true ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 sendRequest ( db . getName ( ) , null , nodes , statusTask , getNextMessageIdCounter ( ) , ODistributedRequest . EXECUTION_MODE . RESPONSE , \n \n \t2 null , null , null ) ; } } \n \n protected boolean requestFullDatabase ( final ODistributedDatabaseImpl distrDatabase , final String databaseName , \n \n \t1 final boolean backupDatabase , final OModifiableDistributedConfiguration cfg ) { \n \n <ect>
\t5 val contactLink = CrmLinkGenerator . generateContactPreviewFullLink ( context . siteUrl , contact . id ) \n \n \t5 val link = newA ( contactLink , contact . displayName ) \n \n \t5 return newLink ( img , link ) . write ( ) } \n \n \t3 } catch ( e : Exception ) { \n \n <ect>
\t2 WebSocketSessionHolder holder = this . sessions . get ( sessionId ) ; \n \n \t2 if ( holder == null ) { \n \n \t4 <comment> \n \n <ect>
\t1 protected boolean registerProvider ( DataStoreProvider provider ) { \n \n \t2 Map < String , Object > copyParams = new HashMap < String , Object > ( ) ; \n \n \t2 String providerName = provider . getName ( ) ; \n \n \t2 if ( providerMap . get ( providerName ) != null ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public Serializable execute ( final PrincipalActionContext inActionContext ) throws ExecutionException \n \n \t1 { \n \n <ect>
\t4 ProtocolProviderService . class . getName ( ) , \n \n \t4 null ) ; } \n \n \t2 catch ( InvalidSyntaxException e ) \n \n \t2 { \n \n <ect>
\t1 else { \n \n \t1 this . conf = new HiveConf ( conf , getClass ( ) ) ; } } \n \n HiveConf getConf ( ) { \n \n \t1 if ( conf == null ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testDest1Deletion ( ) throws Exception { \n \n \t2 LOG . info ( <string_literal> , dest1 , dest2 ) ; \n \n <ect>
\t4 pluginFile . delete ( ) ; \n \n \t4 if ( ! downloaded ) continue ; \n \n \t4 throw new PluginNotFoundException ( <string_literal> , je1 ) ; \n \n \t3 } catch ( ZipException ze1 ) { \n \n <ect>
\t3 try { \n \n \t3 <comment> \n \n \t3 volumeManager . exportVolume ( lvmVolumeInfo , volumeGroup , lvName ) ; \n \n \t3 } catch ( EucalyptusCloudException ex ) { \n \n <ect>
\t3 assert rsrc3 == rsrc7 ; \n \n \t3 assert rsrc4 == rsrc8 ; \n \n \t3 log . info ( <string_literal> + rsrc1 ) ; \n \n \t3 log . info ( <string_literal> + rsrc2 ) ; \n \n <ect>
\t2 _session . removeSubsession ( session ) ; \n \n \t2 boolean removed = _subsessions . remove ( session ) ; \n \n \t2 if ( removed ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 public boolean sfaiTest ( ) { \n \n \t2 return sfai . test ( SFAI ) ; } \n \n \t1 @ Override \n \n \t1 public boolean theSame ( ReverseInjectionEJBHolderLocal that ) { \n \n <ect>
\t2 final Subject subject = newSamlObject ( Subject . class ) ; \n \n \t2 if ( nameId != null ) { \n \n \t3 subject . setNameID ( nameId ) ; } \n \n \t2 subject . getSubjectConfirmations ( ) . add ( confirmation ) ; \n \n <ect>
\t1 self . check_llap ( env , kinit_cmd , params . hive_interactive_hosts , int ( format ( <string_literal> ) ) , \n \n \t5 params . hive_llap_principal , params . hive_server2_authentication , params . hive_transport_mode , \n \n \t5 params . hive_http_endpoint ) \n \n \t1 Logger . info ( <string_literal> ) \n \n <ect>
\t3 if ( null == secretKey || 0 == secretKey . length ) { \n \n \t4 response . sendError ( <number_literal> , <string_literal> ) ; \n \n \t4 return ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 return new EventLine ( itemName , stateString , scope , time ) ; } } \n \n \t2 } else if ( defaultItemOnBegin != null && ! COMMAND_PATTERN . matcher ( line ) . matches ( ) ) { \n \n \t3 <comment> \n \n \t3 return new EventLine ( defaultItemOnBegin , line , SCOPE_BEGIN , event . getStart ( ) ) ; } \n \n <ect>
\t2 self . logger . debug ( <string_literal> % no_of_vms ) \n \n \t3 # \n \n \t2 hostUp = wait_until ( <number_literal> , <number_literal> , self . checkHostUp , other_host . ipaddress , ha_host . ipaddress ) \n \n \t2 if not ( hostUp ) : \n \n <ect>
\t3 if ( DEBUGGING ) { \n \n \t4 LOG . debug ( <string_literal> ) ; } \n \n \t3 return null ; } \n \n \t2 if ( DEBUGGING ) { \n \n <ect>
\t1 List < ToolPlugin > plugins = \n \n \t2 org . apache . sqoop . config . ConfigurationHelper . getInstances ( \n \n \t3 conf , TOOL_PLUGINS_KEY , ToolPlugin . class ) ; \n \n \t1 for ( ToolPlugin plugin : plugins ) { \n \n <ect>
\t3 if ( updateDataModel == null ) { \n \n \t4 return ; } \n \n \t3 OAuthCredentials oauthCredentials = getOAuthCredentials ( DEFAULT_USER_ID ) ; \n \n \t3 if ( oauthCredentials == null ) { \n \n <ect>
\t5 if ( ex instanceof InterruptedException ) { \n \n \t6 if ( stop . get ( ) ) { \n \n \t7 return ; } \n \n \t6 Thread . interrupted ( ) ; } \n \n <ect>
\t4 try { \n \n \t5 _runner . doSend ( status ) ; \n \n \t4 } catch ( I2CPMessageException ime ) { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 response . add ( info ) ; } \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 dbConn . rollback ( ) ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t2 startEmbeddedLdapServer = p . getBoolean ( <string_literal> , true ) ; \n \n \t2 sleepTime = p . getInteger ( <string_literal> , <number_literal> ) ; \n \n \t2 caseSensitiveLogin = p . getBoolean ( <string_literal> , true ) ; \n \n \t2 log . info ( <string_literal> + startEmbeddedLdapServer ) ; \n \n <ect>
\t6 LOG . warn ( <string_literal> ) ; } \n \n \t4 } else { \n \n \t5 LOG . info ( <string_literal> ) ; } \n \n \t3 } catch ( InterruptedException int_exc ) { \n \n <ect>
\t5 if ( serverSocket . isBound ( ) ) { \n \n \t6 try { \n \n \t7 serverSocket . close ( ) ; \n \n \t6 } catch ( Exception ex ) { \n \n <ect>
\t3 this . projectorWriter . close ( ) ; \n \n \t3 this . projectorReader = null ; \n \n \t3 this . projectorSocket . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
public void testGetDelegationTokenDenied ( ) throws Exception { \n \n \t1 String newUser = testName . getMethodName ( ) ; \n \n \t1 final File newUserKeytab = new File ( kdc . getKeytabDir ( ) , newUser + <string_literal> ) ; \n \n \t1 if ( newUserKeytab . exists ( ) && ! newUserKeytab . delete ( ) ) { \n \n <ect>
\t2 params [ 0 ] = String . class ; \n \n \t2 executeM = findMethod ( c , <string_literal> , params ) ; \n \n \t2 if ( executeM == null ) { \n \n <ect>
\t3 logger . warn ( <string_literal> , errorCode , message ) ; } \n \n \t2 return this ; } \n \n \t1 @ Override \n \n \t1 public WebSocket redirect ( AtmosphereResponse r , String location ) throws IOException { \n \n <ect>
\t3 } else { \n \n \t3 stateChange . add ( f ) ; \n \n \t3 subject += <string_literal> + f . getServiceConfiguration ( ) . getName ( ) + <string_literal> + f . getFinalState ( ) ; } } \n \n \t2 if ( stateChange . isEmpty ( ) ) { \n \n <ect>
\t2 case Leader . PROPOSAL : \n \n \t3 LOG . warn ( <string_literal> ) ; \n \n \t3 break ; \n \n \t2 case Leader . COMMIT : \n \n <ect>
\t2 Answer answer = null ; \n \n \t2 try { \n \n \t3 answer = _agentMgr . send ( hostId , cmd ) ; \n \n \t2 } catch ( OperationTimedoutException e ) { \n \n <ect>
\t1 WriteBuffers . Position readPos ) { \n \n \t1 int storedKeyLengthLength = \n \n \t2 ( int ) ( ( keyRefWord & SmallKeyLength . bitMask ) > > SmallKeyLength . bitShift ) ; \n \n \t1 boolean isKeyLengthSmall = ( storedKeyLengthLength != SmallKeyLength . allBitsOn ) ; \n \n <ect>
\t2 continue ; } \n \n \t1 StackId stackId = service . getDesiredStackId ( ) ; \n \n \t1 boolean isServiceWitNoConfigs = ambariMetaInfo . get ( ) . isServiceWithNoConfigs ( stackId . getStackName ( ) , stackId . getStackVersion ( ) , service . getName ( ) ) ; \n \n \t1 if ( isServiceWitNoConfigs ) { \n \n <ect>
\t1 for ( String uninstallKey : uninstallKeys ) { \n \n \t1 PluginInfo info = getPluginInfo ( uninstallKey ) ; \n \n \t1 try { \n \n \t2 if ( ! getPluginFile ( info ) . exists ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 send ( <string_literal> , <number_literal> ) ; \n \n \t2 StopWatch watch = new StopWatch ( ) ; \n \n \t2 send ( <string_literal> , count ) ; \n \n <ect>
\t3 pstmt . execute ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n \t3 s_logger . warn ( <string_literal> + msid , e ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t5 ConceptAnswer ca = getConceptAnswerFromOriginal ( id ) ; \n \n \t5 ca . setSortWeight ( lastWeightSeen ++ ) ; } } \n \n \t3 log . debug ( <string_literal> ) ; \n \n \t3 for ( ConceptAnswer a : originalConceptAnswers ) { \n \n <ect>
\t2 for ( String needCode : allMageSymbols ) { \n \n \t3 String searchCode = needCode . replace ( <string_literal> , <string_literal> ) ; \n \n \t3 if ( ! foundedData . containsKey ( searchCode ) ) \n \n \t3 { \n \n <ect>
\t4 queueCallable ( new CoordResumeCommand ( jobId ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n \t4 log . warn ( <string_literal> + <string_literal> + jobId + <string_literal> ) ; } } \n \n \t2 catch ( InterruptedException e ) { \n \n \t3 queueCallable ( new CoordResumeCommand ( jobId ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n <ect>
\t3 LOG . info ( <string_literal> , methodName ) ; \n \n \t3 try { \n \n \t4 list = Arrays . asList ( new FrameworkMethod ( klass . getMethod ( methodName ) ) ) ; \n \n \t3 } catch ( NoSuchMethodException nsme ) { \n \n <ect>
\t3 deleteTable_result result = new deleteTable_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t6 LOG . trace ( <string_literal> ) ; \n \n \t6 try { \n \n \t7 scheduler . execute ( new AckCompactionRunner ( ) ) ; \n \n \t6 } catch ( Exception ex ) { \n \n <ect>
\t4 if ( player . getDeck ( ) != null ) { \n \n \t5 player . setSideboarding ( ) ; \n \n \t5 player . getPlayer ( ) . sideboard ( this , player . getDeck ( ) ) ; \n \n \t4 } else { \n \n <ect>
public class StructrFilesystemProvider extends FileSystemProvider { \n \n \t1 private static final Logger logger = LoggerFactory . getLogger ( StructrFilesystemProvider . class . getName ( ) ) ; \n \n \t1 @ Override \n \n \t1 public synchronized String getScheme ( ) { \n \n <ect>
\t4 throw new CloudRuntimeException ( <string_literal> + vm + <string_literal> + destHost + <string_literal> + migrateWithStorageAnswer . getDetails ( ) ) ; \n \n \t3 } else { \n \n \t4 <comment> \n \n \t4 updateVolumesAfterMigration ( volumeToPool , migrateWithStorageAnswer . getVolumeTos ( ) ) ; } \n \n <ect>
\t1 List < Task < ? > > rootTasks = sem . getAllRootTasks ( ) ; \n \n \t1 task . getJSONPlan ( ps , rootTasks , sem . getFetchTask ( ) , false , true , true ) ; \n \n \t1 ret = baos . toString ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 this . dataSourcesConfig = dataSourcesConfig ; } \n \n @ Override \n \n public List < MondrianCatalog > listCatalogs ( final IPentahoSession pentahoSession , final boolean jndiOnly ) { \n \n <ect>
\t6 config . update ( props ) ; \n \n \t5 } catch ( IOException ioe ) { \n \n \t6 logger . error ( <string_literal> , bindingConfig . normalizedPid , \n \n \t8 command . toString ( ) ) ; } \n \n <ect>
\t2 if ( taskSlot != null ) { \n \n \t4 LOG . debug ( <string_literal> , taskSlot , cause ) ; \n \n \t3 } else { \n \n <ect>
\t2 UpdateRequest u = null ; \n \n \t2 try { \n \n \t3 u = UpdateFactory . create ( sql ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 reconnect ( client ) ; \n \n \t5 LOG . error ( <string_literal> , aze ) ; \n \n \t4 } catch ( TException e ) { \n \n \t5 reconnect ( client ) ; \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 cache2 . get ( <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 cache2 . replace ( <string_literal> , wrappedSession ) ; \n \n <ect>
\t1 public static void tearDownAfterClass ( ) throws Exception { \n \n \t2 cua . closeAll ( ) ; } \n \n \t1 @ Test \n \n \t1 public void performanceTest ( ) throws Exception { \n \n <ect>
\t3 } else { \n \n \t4 debug ( <string_literal> , idp . getName ( ) , logId . toString ( ) ) ; \n \n \t4 if ( sId != null ) { \n \n \t5 <comment> \n \n <ect>
\t3 StringBuilder fileList = new StringBuilder ( ) ; \n \n \t3 for ( String fileName : kylinDependency . split ( <string_literal> ) ) { \n \n \t4 Path p = new Path ( fileName ) ; \n \n \t4 if ( p . isAbsolute ( ) == false ) { \n \n <ect>
\t2 LZ4Compressor instance = instances . get ( compressorTypeAndLevel ) ; \n \n \t2 if ( instance == null ) \n \n \t2 { \n \n \t3 if ( compressorType . equals ( LZ4_FAST_COMPRESSOR ) && args . get ( LZ4_HIGH_COMPRESSION_LEVEL ) != null ) \n \n <ect>
\t3 throw new InvalidParameterValueException ( <string_literal> + vmId ) ; } \n \n \t2 <comment> \n \n \t2 if ( vm . getState ( ) != State . Running ) { \n \n <ect>
\t2 AccelerometerDirection z = factory . createAccelerometerDirection ( ) ; \n \n \t2 z . setDirection ( AccelerometerCoordinate . Z ) ; \n \n \t2 z . setUid ( getUid ( ) ) ; \n \n \t2 String subIdZ = <string_literal> ; \n \n <ect>
\t2 try { \n \n \t3 String path = getCommitPath ( ( BatchId ) id ) ; \n \n \t3 return zkClient . get_data ( path , false ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 private static int handleArgException ( CliArgsException e ) { \n \n <ect>
\t5 try { \n \n \t6 activeWaiter . wait ( TimeUnit . SECONDS . toMillis ( <number_literal> ) ) ; \n \n \t5 } catch ( InterruptedException ignored ) { } } \n \n \t4 if ( this . dispatched . get ( ) > 0 ) { \n \n <ect>
\t3 return ; } \n \n \t2 try { \n \n \t3 dirContext . close ( ) ; \n \n \t2 } catch ( NamingException e ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t7 ( ( DynamicEndpointSnitch ) newSnitch ) . subsnitch . getClass ( ) . getName ( ) , DatabaseDescriptor . getDynamicUpdateInterval ( ) , \n \n \t7 DatabaseDescriptor . getDynamicResetInterval ( ) , DatabaseDescriptor . getDynamicBadnessThreshold ( ) ) ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t4 suspendAutoLoading = true ; } } \n \n \t2 List < SecondaryStorageVmVO > alreadyRunning = _secStorageVmDao . getSecStorageVmListInStates ( SecondaryStorageVm . Role . templateProcessor , dataCenterId , State . Running , \n \n \t4 State . Migrating , State . Starting ) ; \n \n \t2 if ( alreadyRunning . size ( ) == 0 ) { \n \n <ect>
\t4 try { \n \n \t5 Scheduler sched = StdSchedulerFactory . getDefaultScheduler ( ) ; \n \n \t5 sched . scheduleJob ( job , trigger ) ; \n \n \t4 } catch ( SchedulerException e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void after ( ) { \n \n <ect>
\t1 @ GET \n \n \t1 @ Produces ( <string_literal> ) \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public String getDecodedSegmentPathParam ( @ PathParam ( <string_literal> ) PathSegment segment ) { \n \n <ect>
\t2 String clusterName = clusterStackInfoEntry . getKey ( ) ; \n \n \t2 Map < String , String > stackInfo = clusterStackInfoEntry . getValue ( ) ; \n \n \t2 String stackName = stackInfo . keySet ( ) . iterator ( ) . next ( ) ; \n \n \t2 String stackVersion = stackInfo . get ( stackName ) ; \n \n <ect>
\t3 return null ; } \n \n \t2 return key ; } \n \n \t1 private Optional < JsonWebKeySet > buildJsonWebKeySet ( final OidcRegisteredService service ) { \n \n \t2 try { \n \n <ect>
\t1 } catch ( S3Exception e ) { \n \n \t1 LOG . warn ( <string_literal> + Contexts . lookup ( ) . getCorrelationId ( ) + <string_literal> , e ) ; \n \n \t1 throw e ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 if ( oldmodcount != null ) { \n \n \t4 stmt . setObject ( si ++ , oldmodcount , Types . BIGINT ) ; } \n \n \t3 int result = stmt . executeUpdate ( ) ; \n \n \t3 if ( result != 1 ) { \n \n <ect>
\t5 s_logger . warn ( <string_literal> + ip + <string_literal> + vm + <string_literal> ) ; \n \n \t5 _networkMgr . handleSystemIpRelease ( ip ) ; \n \n \t5 throw new CloudRuntimeException ( <string_literal> + vm ) ; \n \n \t4 } else { \n \n <ect>
\t3 <comment> \n \n \t3 if ( isInternalEvent ( type ) || userRecordable ) \n \n \t4 recordableEvts [ type ] = true ; \n \n <ect>
\t2 facade . getResponse ( ) . sendError ( <number_literal> , <string_literal> ) ; \n \n \t2 return null ; } \n \n \t1 protected boolean validateAction ( AdminAction action ) { \n \n \t2 if ( ! action . validate ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 Block b4 = b1 . createNextBlock ( someOtherGuy ) ; \n \n \t2 Block b5 = b4 . createNextBlock ( someOtherGuy ) ; \n \n \t2 Block b6 = b5 . createNextBlock ( someOtherGuy ) ; \n \n <ect>
\t3 runMayThrow ( ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public static void copy ( KylinConfig srcConfig , KylinConfig dstConfig , List < String > paths , \n \n \t3 boolean copyImmutableResource ) throws IOException { \n \n \t2 ResourceStore src = ResourceStore . getStore ( srcConfig ) ; \n \n \t2 ResourceStore dst = ResourceStore . getStore ( dstConfig ) ; \n \n <ect>
\t1 private final DynamoDbTicketRegistryFacilitator dbTableService ; \n \n \t1 public DynamoDbTicketRegistry ( final CipherExecutor cipher , final DynamoDbTicketRegistryFacilitator dbTableService ) { \n \n \t2 setCipherExecutor ( cipher ) ; \n \n \t2 this . dbTableService = dbTableService ; \n \n <ect>
\t6 latch . countDown ( ) ; } \n \n \t4 } ) ; } \n \n \t3 latch . await ( ) ; } \n \n \t2 finally { \n \n <ect>
\t3 if ( _context != null ) { \n \n \t4 contextDescription = <string_literal> + _context . contextID ( ) + <string_literal> + _context . request ( ) ; } \n \n \t3 else { \n \n \t4 contextDescription = <string_literal> ; } \n \n <ect>
\t2 String encoding = con . getHeaderField ( <string_literal> ) ; \n \n \t2 if ( encoding != null ) { \n \n \t3 if ( encoding . equalsIgnoreCase ( <string_literal> ) ) { \n \n \t4 in = new InflaterInputStream ( in ) ; \n \n <ect>
\t8 new IndirectMessageReference ( \n \n \t10 getMessage ( removeIndex ) ) , ack ) ; \n \n \t6 queue . wakeup ( ) ; } \n \n \t5 if ( removeIndex % <number_literal> == 0 ) { \n \n <ect>
\t5 s_logger . debug ( <string_literal> + vm + <string_literal> + network + <string_literal> ) ; } \n \n \t4 return true ; } \n \n \t3 throw new ConcurrentOperationException ( <string_literal> + nic . getId ( ) ) ; } \n \n <ect>
\t3 try { \n \n \t4 fos . close ( ) ; \n \n \t3 } catch ( IOException e1 ) { \n \n \t4 Logger . error ( this , <string_literal> + e , e ) ; } \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 assertThat ( client ( ) . prepareSearch ( <string_literal> , <string_literal> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 2L ) ) ; \n \n \t3 assertThat ( client ( ) . prepareSearch ( <string_literal> , <string_literal> ) . setSize ( 0 ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 2L ) ) ; } \n \n <ect>
\t3 token . release ( ) ; \n \n \t2 } catch ( final ResourceState . NoSuchTokenException e ) { \n \n \t3 Logs . extreme ( ) . error ( e , e ) ; } } \n \n \t1 } ) ; \n \n <ect>
\t4 catch ( Exception e ) { \n \n \t5 try { \n \n \t6 fileSystem . delete ( metadataFilePath , false ) ; } \n \n \t5 catch ( Exception deleteException ) { \n \n <ect>
def getLogPane : LogPane = _logText \n \n private def _handleApiEvent ( changed : AnyRef ) = changed . toString match { \n \n \t1 case <string_literal> = > \n \n \t1 _notify ( <string_literal> , API . message ) \n \n <ect>
\t4 KafkaServer kafkaServer = getKafkaServer ( i , tmpKafkaDirs . get ( i ) ) ; \n \n \t4 brokers . add ( kafkaServer ) ; \n \n \t4 brokerConnectionString += hostAndPortToUrlString ( KAFKA_HOST , kafkaServer . socketServer ( ) . boundPort ( listenerName ) ) ; \n \n \t4 brokerConnectionString += <string_literal> ; } \n \n <ect>
\t3 if ( format == Options . output_format_class ) { \n \n \t4 if ( ! Options . v ( ) . asm_backend ( ) ) { \n \n \t5 streamOut = new JasminOutputStream ( streamOut ) ; } } \n \n \t3 writerOut = new PrintWriter ( new OutputStreamWriter ( streamOut ) ) ; \n \n <ect>
\t2 Response response = base . request ( ) . post ( Entity . entity ( book1 , Constants . MEDIA_TYPE_TEST_XML ) ) ; \n \n \t2 log . info ( <string_literal> + response . getStatus ( ) ) ; \n \n \t2 assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n \t2 int id1 = response . readEntity ( int . class ) ; \n \n <ect>
\t5 try { \n \n \t6 val compileServiceReporter = DaemonMessageReporterPrintStreamAdapter ( serviceOutputStream ) \n \n \t6 if ( args . none ( ) ) \n \n \t7 throw IllegalArgumentException ( <string_literal> ) \n \n <ect>
\t3 Observer o = new Observer ( ) ; \n \n \t3 _retainerArray . add ( o ) ; \n \n \t3 NSNotificationCenter . defaultCenter ( ) . addObserver ( o , new NSSelector ( <string_literal> , new Class [ ] { com . webobjects . foundation . NSNotification . class } ) , WOApplication . ApplicationWillFinishLaunchingNotification , null ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t1 return startProxy ( cfg ) ; } \n \n @ After \n \n public void stopMac ( ) throws Exception { \n \n \t1 if ( null != proxyProcess ) { \n \n <ect>
\t3 for ( int i = 0 ; i < NUM_NODES ; i ++ ) { \n \n \t4 initBuilder . child ( <string_literal> + i ) ; } \n \n \t3 ns . merge ( initBuilder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; } \n \n \t2 <comment> \n \n <ect>
\t2 PyCode code = null ; \n \n \t2 try { \n \n \t3 code = getCompiledCode ( pythonCode , interpreter , transformId ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 @ Override \n \n \t2 public void initState ( Object state ) { \n \n \t3 if ( state != null ) { \n \n \t4 counts = ( HashMap < String , Integer > ) state ; } \n \n <ect>
\t4 if ( b != null ) { \n \n \t5 LOG . debug ( <string_literal> + sid ) ; \n \n \t5 send ( b ) ; } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 try ( DataInputStream is = new DataInputStream ( new ByteBufferBackedInputStream ( buffer ) ) ) { \n \n \t6 String dictClassName = is . readUTF ( ) ; \n \n \t6 Dictionary < String > dict = ( Dictionary < String > ) ClassUtil . newInstance ( dictClassName ) ; \n \n \t6 dict . readFields ( is ) ; \n \n <ect>
\t2 final long firstDataPage = block . getColumns ( ) . get ( 0 ) . getFirstDataPageOffset ( ) ; \n \n \t2 if ( firstDataPage >= splitStart && firstDataPage < splitStart + splitLength ) { \n \n \t2 splitGroup . add ( block ) ; } } \n \n \t1 if ( splitGroup . isEmpty ( ) ) { \n \n <ect>
\t2 String nick = null ; \n \n \t2 SessionRecord rec = null ; \n \n \t2 if ( session != null ) \n \n \t2 { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void validate ( Object object , Errors errors ) { \n \n <ect>
\t2 throw new HiveJdbcDatabaseAccessException ( <string_literal> ) ; } } \n \n \t1 catch ( HiveJdbcDatabaseAccessException he ) { \n \n \t1 throw he ; } \n \n \t1 catch ( Exception e ) { \n \n <ect>
\t5 if ( ! validateFile ( file , RepositoryType . JAR ) ) { \n \n \t6 continue ; } \n \n \t5 URL url = buildClassLoaderUrl ( file ) ; \n \n <ect>
\t3 final SSLBufferManagement sslBufferManagement , \n \n \t3 final SSLSessionInitializer initializer , \n \n \t3 final SSLSessionVerifier verifier ) throws UnsupportedOperationException { \n \n <ect>
\t3 List < ManagedObjectReference > tasks = context . getVimClient ( ) . getDynamicProperty ( taskmgr , <string_literal> ) ; \n \n \t3 for ( ManagedObjectReference taskMor : tasks ) { \n \n \t4 TaskInfo info = ( TaskInfo ) ( context . getVimClient ( ) . getDynamicProperty ( taskMor , <string_literal> ) ) ; \n \n \t4 if ( info . getEntityName ( ) . equals ( cmd . getVmName ( ) ) && StringUtils . isNotBlank ( info . getName ( ) ) && info . getName ( ) . equalsIgnoreCase ( <string_literal> ) ) { \n \n <ect>
\t2 for ( int i = 0 ; i < data . length ; i ++ ) { \n \n \t3 Message message = createMessage ( i ) ; \n \n \t3 configureMessage ( message ) ; \n \n \t3 if ( verbose ) { \n \n <ect>
\t1 channelSet . retainAll ( tempchannelSet ) ; \n \n \t1 return channelSet ; } \n \n \t1 private Set < String > validateConfigFilterSet ( ) { \n \n \t1 if ( configFilters == null || configFilters . isEmpty ( ) ) { \n \n <ect>
\t9 @ QueryParam ( <string_literal> ) String user_ip , @ QueryParam ( <string_literal> ) String user_agent , \n \n \t9 @ QueryParam ( <string_literal> ) String xforwardedfor , @ Context HttpHeaders headers , \n \n \t9 @ Context HttpServletRequest request ) \n \n \t2 throws WebApplicationException { \n \n <ect>
\t1 private void writeOutEnhancedClass ( byte [ ] enhancedBytecode , File file ) { \n \n \t2 try { \n \n \t3 if ( file . delete ( ) ) { \n \n \t4 if ( ! file . createNewFile ( ) ) { \n \n <ect>
\t3 throw new NoSuchElementException ( ) ; } \n \n \t2 cntRemainingBlocks -- ; \n \n \t2 if ( buffer == null || buffer . length < = offNextBlockHeader ) \n \n \t2 { \n \n <ect>
\t2 if ( reasonForExit != null ) { \n \n \t3 List < Obs > obssExit = Context . getObsService ( ) . getObservationsByPersonAndConcept ( patient , reasonForExit ) ; \n \n \t3 if ( obssExit != null ) { \n \n \t4 if ( obssExit . size ( ) > 1 ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 executors . execute ( ( ) - > { \n \n \t3 try { \n \n \t4 future . get ( ) ; \n \n <ect>
\t3 return false ; } } \n \n \t1 public static boolean verifyInstanceName ( String instanceName ) { \n \n \t2 <comment> \n \n \t2 if ( instanceName . contains ( <string_literal> ) || instanceName . contains ( <string_literal> ) || instanceName . contains ( <string_literal> ) ) { \n \n <ect>
\t1 private void killTxns ( Set < Transaction > txnsToKill , @ Nullable Transaction overridingTx ) { \n \n \t2 LinkedList < Transaction > work = new LinkedList < > ( txnsToKill ) ; \n \n \t2 while ( ! work . isEmpty ( ) ) { \n \n \t3 final Transaction tx = work . poll ( ) ; \n \n <ect>
\t3 } catch ( IllegalArgumentException ex ) { \n \n \t4 <comment> \n \n \t4 log . error ( <string_literal> + id ) ; \n \n \t4 log . error ( <string_literal> + seg ) ; \n \n <ect>
\t2 return params . toArray ( new Object [ ] [ ] { } ) ; } \n \n \t1 @ Test ( dataProvider = <string_literal> , enabled = true && ! DEBUG , timeOut = <number_literal> ) \n \n \t1 public void testCachingIndexedFastaReaderParallel ( final File fasta , final int cacheSize , final int querySize , final int nt ) throws FileNotFoundException , InterruptedException { \n \n \t2 final CachingIndexedFastaSequenceFile caching = new CachingIndexedFastaSequenceFile ( fasta , getCacheSize ( cacheSize ) , true , false ) ; \n \n <ect>
\t7 Tools . writeAll ( outFile , attachment . getInputStream ( ) ) ; \n \n \t7 outFile . close ( ) ; } } } \n \n \t4 exportCount ++ ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 s_logger . debug ( <string_literal> + hostId ) ; } \n \n \t4 rebalanceHost ( hostId , currentOwnerId , futureOwnerId ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , serviceLogoutUrl , singleLogoutService ) ; \n \n \t3 return serviceLogoutUrl ; } \n \n \t2 final String originalUrl = singleLogoutService . getOriginalUrl ( ) ; \n \n \t2 if ( this . urlValidator . isValid ( originalUrl ) ) { \n \n <ect>
@ Override \n \n public int getNumUsersWithPreferenceFor ( long itemID1 , long itemID2 ) throws TasteException { \n \n \t1 return getNumThings ( <string_literal> , getNumPreferenceForItemsSQL , itemID1 , itemID2 ) ; } \n \n private int getNumThings ( String name , String sql , long . . . args ) throws TasteException { \n \n <ect>
\t1 public void contextInitialized ( ServletContextEvent sce ) { \n \n \t2 try { \n \n \t3 init ( ) ; \n \n \t2 } catch ( ServletException e ) { \n \n <ect>
<comment> \n \n \t1 protected void processCheckCommittedTxRequest ( final UUID nodeId , \n \n \t2 final GridCachePessimisticCheckCommittedTxRequest < K , V > req ) { \n \n <ect>
\t3 try { \n \n \t4 generateReport ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 System . err . println ( <string_literal> + e ) ; <comment> \n \n <ect>
\t7 morDsAtSource = srcHyperHost . mountDatastore ( false , tgtDsHost , tgtDsPort , tgtDsPath , tgtDsName ) ; \n \n \t7 if ( morDsAtSource == null ) { \n \n \t8 throw new Exception ( <string_literal> + tgtDsHost + <string_literal> + tgtDsPath + <string_literal> + _hostName ) ; } \n \n \t7 mountedDatastoresAtSource . add ( tgtDsName ) ; \n \n <ect>
\t3 inputStateRefernceArray [ handIndex ] . setAutoWrite ( false ) ; \n \n \t3 inputStateRefernceArray [ handIndex ] . setAutoSynch ( false ) ; \n \n \t3 texType [ handIndex ] = new Texture_t ( ) ; } \n \n \t2 if ( ! initializeOpenVRLibrary ( ) ) { \n \n <ect>
\t3 definition . getType ( ) ) ; } \n \n \t1 <comment> \n \n \t1 return PropertyProvider . class . cast ( clz . newInstance ( ) ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t5 } else { \n \n \t6 sink . received ( buf , 0 , len ) ; } } \n \n \t4 sink . closed ( ) ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t3 responseObj . put ( JsonKeys . commandId . name ( ) , commandId ) ; \n \n \t3 responseObj . put ( GenericJsonKeys . updateType . name ( ) , <string_literal> ) ; \n \n \t3 pw . print ( responseObj . toString ( <number_literal> ) ) ; \n \n \t2 } catch ( JSONException e ) { \n \n <ect>
\t2 } else { \n \n \t3 <comment> \n \n \t3 markCompleted = true ; } \n \n \t2 } catch ( SchedulerException e ) { \n \n <ect>
\t4 logger . debug ( <string_literal> , processId ) ; } } \n \n \t2 if ( processId < 0 ) { \n \n \t3 processId = defaultProcessId ( ) ; \n \n <ect>
\t4 <comment> \n \n \t4 td . setDownloadError ( <string_literal> ) ; \n \n \t4 String result = postRemoteDownload ( jobId ) ; \n \n \t4 if ( result != null ) { \n \n <ect>
\t6 log . debug ( <string_literal> , ax ) ; \n \n \t4 } catch ( Exception x ) { \n \n \t5 if ( x instanceof InterruptedException ) interrupted ( ) ; \n \n \t5 else { \n \n <ect>
\t1 if ( f . exists ( ) ) { \n \n \t2 try { \n \n \t3 f . delete ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 try { \n \n \t1 SANVolumeInfo snapInfo = Transactions . find ( new SANVolumeInfo ( snapshotId ) ) ; \n \n \t1 return snapInfo . getSize ( ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t5 return new UpdateContainer ( new ErrorUpdate ( <string_literal> + \n \n \t7 <string_literal> ) ) ; } \n \n \t4 Label linkLabel = ontMgr . getUriLabel ( edgeUri ) ; \n \n \t4 if ( linkLabel == null ) { \n \n <ect>
<comment> \n \n \t1 protected void addTicketToRegistry ( final OAuthToken ticket , final TicketGrantingTicket ticketGrantingTicket ) { \n \n <ect>
\t2 <string_literal> + release . getVersion , \n \n \t2 <string_literal> + release . getOsxAsset . getId , \n \n \t2 <string_literal> + bundlePath . getAbsolutePath , \n \n \t2 <string_literal> + extractionFolder + <string_literal> + release . getVersion + <string_literal> ) \n \n <ect>
\t6 s_logger . debug ( <string_literal> + e . toString ( ) ) ; \n \n \t6 CallContext . unregister ( ) ; \n \n \t6 return ; } \n \n \t4 } catch ( ConfigurationException e ) { \n \n <ect>
\t1 File dst = new File ( confFolder ) ; \n \n \t1 if ( ! dst . isDirectory ( ) ) { \n \n \t2 throw new Exception ( <string_literal> + dst . getAbsolutePath ( ) + <string_literal> ) ; } \n \n \t1 org . crsh . vfs . File f = confBuilder . build ( ) . get ( Path . get ( <string_literal> ) ) ; \n \n <ect>
\t2 } catch ( JsonParseException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t3 updateRequest ( streamingRequest , false , e . getMessage ( ) ) ; \n \n \t2 } catch ( JsonMappingException e ) { \n \n <ect>
\t3 queueCallable ( new CoordActionTimeOut ( actionBean ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n \t3 log . warn ( <string_literal> + <string_literal> + e . getMessage ( ) \n \n \t5 + <string_literal> + jobId + <string_literal> ) ; } \n \n \t2 finally { \n \n <ect>
\t3 stopRunning ( ) ; \n \n \t2 } catch ( EOFException eofe ) { \n \n \t3 <comment> \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 parameters . put ( WSFederationConstants . WTREALM , fedRequest . getWtrealm ( ) ) ; \n \n \t2 if ( StringUtils . isNotBlank ( fedRequest . getWctx ( ) ) ) { \n \n \t3 parameters . put ( WSFederationConstants . WCTX , fedRequest . getWctx ( ) ) ; } \n \n \t2 model . put ( <string_literal> , parameters ) ; \n \n <ect>
\t3 try ( InputStream stream = bundle . inputStreamForResourcePath ( path ) ) { \n \n \t4 byte bytes [ ] = ERXFileUtilities . bytesFromInputStream ( stream ) ; \n \n \t4 return new String ( bytes ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 assertTrue ( trickFile . createNewFile ( ) ) ; \n \n \t2 sleepUninterruptibly ( seconds , TimeUnit . SECONDS ) ; \n \n \t1 } finally { \n \n \t2 if ( ! trickFile . delete ( ) ) { \n \n <ect>
\t5 KylinLogExtractor logExtractor = new KylinLogExtractor ( ) ; \n \n \t5 logger . info ( <string_literal> + Arrays . toString ( logsArgs ) ) ; \n \n \t5 logExtractor . execute ( logsArgs ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 catch ( IOException ex ) { \n \n \t3 Log . error ( TransInteger . class , <string_literal> + ex . getMessage ( ) , ex ) ; \n \n \t3 IO . exception ( ex ) ; } \n \n \t2 catch ( NumberFormatException ex ) { \n \n <ect>
\t1 } else if ( nodeName . startsWith ( SLOT_PREFIX ) ) { \n \n \t2 slotByWorker . put ( extractWorkerIdFromSlot ( childData ) , \n \n \t3 Long . parseLong ( nodeName . substring ( SLOT_PREFIX . length ( ) ) ) ) ; \n \n \t1 } else { \n \n <ect>
\t4 <comment> \n \n \t4 logger . debug ( <string_literal> , healing . nodeId , healing . state ) ; \n \n \t4 if ( healing . routeList != null && healing . routeList . size ( ) != 0 ) { \n \n \t5 <comment> \n \n <ect>
\t3 ss = idleSessions . remove ( idleSessions . size ( ) - 1 ) ; } \n \n \t2 if ( ss != null ) { \n \n \t3 activeSessions . add ( ss ) ; \n \n <ect>
\t3 + ioe . toString ( ) ) ; } \n \n \t1 try { \n \n \t2 r . close ( ) ; \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t4 return new StringElement ( <string_literal> ) ; } \n \n \t2 } else if ( tokenizer . hasParameter ( ) ) { \n \n \t3 String parameter = tokenizer . getParameter ( ) ; \n \n \t3 if ( parameter == null ) { \n \n <ect>
\t1 ClassLoader sessionCL = state . getConf ( ) . getClassLoader ( ) ; \n \n \t1 if ( sessionCL != null ) { \n \n \t1 LOG . trace ( <string_literal> ) ; <comment> \n \n \t1 return sessionCL ; } \n \n <ect>
\t3 result . setSuccessIsSet ( true ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 return new ArrayList < > ( ) ; } \n \n \t1 public boolean updateGroup ( final CloudianGroup group ) { \n \n \t2 if ( group == null ) { \n \n \t3 return false ; } \n \n <ect>
\t2 logger . debug ( <string_literal> , ModbusUtil . toHex ( echoBuf , 0 , echoLen ) ) ; \n \n \t2 m_CommPort . disableReceiveThreshold ( ) ; \n \n \t2 if ( echoLen != len ) { \n \n \t3 final String errMsg = <string_literal> ; \n \n <ect>
\t1 } finally { \n \n \t2 try { \n \n \t2 reader . close ( ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t3 return false ; } \n \n \t2 try { \n \n \t3 return login ( ) ; \n \n \t2 } catch ( ExecutionException e ) { \n \n <ect>
\t2 try { \n \n \t3 final JAXBContext jaxbContext = JAXBContext . newInstance ( Session . class ) ; \n \n \t3 this . marshaller = jaxbContext . createMarshaller ( ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , request , ticketId ) ; \n \n \t3 final Map < String , AttributeValue > returnItem = amazonDynamoDBClient . getItem ( request ) . getItem ( ) ; \n \n \t3 if ( returnItem != null ) { \n \n \t4 final Ticket ticket = deserializeTicket ( returnItem ) ; \n \n <ect>
\t1 try { \n \n \t2 lockFile . release ( ) ; \n \n \t2 lockFile = null ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 configuration . getPort ( ) ) ) ; } } \n \n \t2 } else { \n \n \t2 logger . info ( <string_literal> ) ; } \n \n \t1 } catch ( final Exception e ) { \n \n <ect>
\t2 log . info ( <string_literal> + collection ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 processEvent . fire ( <string_literal> ) ; \n \n \t2 EJBBook book = collection . get ( id ) ; \n \n <ect>
\t4 this . watcher . close ( ) ; \n \n \t4 this . watcher = null ; \n \n \t4 this . pathKeys . clear ( ) ; } \n \n \t3 catch ( IOException e ) { \n \n <ect>
\t3 up = false ; } } \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 public void disconnected ( I2PSession session ) { \n \n <ect>
\t3 if ( getState ( ) . isAvailable ( ) && ( oldBasic instanceof Lifecycle ) ) { \n \n \t4 try { \n \n \t5 ( ( Lifecycle ) oldBasic ) . stop ( ) ; \n \n \t4 } catch ( LifecycleException e ) { \n \n <ect>
\t3 catch ( ex : Throwable ) { \n \n \t4 if ( reportError ) { \n \n \t5 log . error ( <string_literal> + template . qualifiedName , ex ) } \n \n \t4 else { \n \n <ect>
\t2 } else { \n \n \t3 spout . fail ( msgId ) ; } \n \n \t2 taskStats . spout_failed_tuple ( tupleInfo . getStream ( ) ) ; \n \n \t2 if ( JStormDebugger . isDebug ( id ) ) { \n \n <ect>
\t2 } catch ( Throwable th ) { \n \n \t3 StringWriter sw = new StringWriter ( ) ; \n \n \t3 th . printStackTrace ( new PrintWriter ( sw ) ) ; \n \n \t3 String msg = sw . getBuffer ( ) . toString ( ) ; \n \n <ect>
\t4 logger . trace ( <string_literal> , this . getNode ( ) . getNodeId ( ) ) ; \n \n \t4 processThermostatModeReport ( serialMessage , offset , endpoint ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t4 if ( dt < 0 ) { \n \n \t5 logger . debug ( <string_literal> , m_address , - dt ) ; \n \n \t5 return ( timeNow + 2000L ) ; <comment> \n \n \t4 } else { \n \n <ect>
\t3 feedbackParam = MageFrame . getPreferences ( ) . get ( KEY_BATTLEFIELD_FEEDBACK_COLORIZING_MODE , <string_literal> ) ; \n \n \t3 int feedbackMode = Integer . parseInt ( feedbackParam ) ; \n \n \t3 dialog . cbBattlefieldFeedbackColorizingMode . setSelectedIndex ( feedbackMode ) ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t5 uid = callback . getName ( ) ; \n \n \t4 } catch ( UnsupportedCallbackException e ) { \n \n \t5 log . warn ( <string_literal> ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t4 if ( ! cleanupCalled && format instanceof CleanupWhenUnsuccessful ) { \n \n \t5 cleanupCalled = true ; \n \n \t5 ( ( CleanupWhenUnsuccessful ) format ) . tryCleanupOnError ( ) ; } } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t1 <comment> \n \n \t1 LazyHCatRecord s5 = new LazyHCatRecord ( o3 , testSD . getObjectInspector ( ) ) ; \n \n \t1 LOG . info ( <string_literal> , s5 ) ; \n \n \t1 LazyHCatRecord s6 = new LazyHCatRecord ( s4 , hrsd . getObjectInspector ( ) ) ; \n \n <ect>
\t5 url = developerServer + <string_literal> + encodedApiKey + <string_literal> + ipAddress + <string_literal> + encodedSignature ; \n \n \t5 client = new HttpClient ( ) ; \n \n \t5 method = new GetMethod ( url ) ; \n \n \t5 responseCode = client . executeMethod ( method ) ; \n \n <ect>
\t3 WalrusMonitor monitor = messenger . getMonitor ( key ) ; \n \n \t3 md5 = monitor . getMd5 ( ) ; \n \n \t3 lastModified = monitor . getLastModified ( ) ; \n \n \t3 if ( md5 == null ) { \n \n <ect>
\t4 . prepareQuery ( CF_STANDARD1 ) \n \n \t4 . withCql ( <string_literal> ) \n \n \t4 . execute ( ) ; \n \n \t2 long count = result . getResult ( ) . getNumber ( ) ; \n \n <ect>
\t2 <comment> \n \n \t2 for ( String key : context . getIgnoreEventList ( ) . keySet ( ) ) { \n \n \t3 if ( ( System . currentTimeMillis ( ) - context . getIgnoreEventList ( ) . get ( key ) ) > <number_literal> ) { \n \n \t4 context . getIgnoreEventList ( ) . remove ( key ) ; \n \n <ect>
\t2 Long volTemplateId = existingVolume . getTemplateId ( ) ; \n \n \t2 long vmTemplateId = vm . getTemplateId ( ) ; \n \n \t2 if ( volTemplateId != null && volTemplateId . longValue ( ) != vmTemplateId ) { \n \n <ect>
\t3 <comment> \n \n \t3 LOGGER . debug ( <string_literal> \n \n \t4 + <string_literal> ) ; \n \n \t3 return ; } \n \n <ect>
\t2 super ( arg ) ; } \n \n \t1 <comment> \n \n \t1 @ Override public String execute ( ) throws GridException { \n \n <ect>
\t3 buf . decRef ( ) ; \n \n \t2 } catch ( AllocatorOutOfMemoryException ex ) { \n \n \t3 ++ result . ooms ; \n \n \t2 } catch ( Throwable ex ) { \n \n <ect>
\t1 writer . append ( new Stringy ( <string_literal> ) , new Stringy ( <string_literal> ) ) ; \n \n \t1 writer . append ( new Stringy ( <string_literal> ) , new Stringy ( <string_literal> ) ) ; \n \n \t1 } finally { \n \n \t1 writer . close ( ) ; } \n \n <ect>
\t2 String evaluateMRR = contextParameters . getParameterValue ( ContextParameter . EVALUATE_MRR ) + sm . getName ( ) + <string_literal> + index + <string_literal> ; \n \n \t2 try { \n \n \t3 sm . writeJson ( modelJson ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t4 logger . trace ( <string_literal> , listener , clusterChangedEvent . state ( ) . version ( ) ) ; \n \n \t4 listener . clusterChanged ( clusterChangedEvent ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 broker . setSslContext ( sslContext ) ; \n \n \t2 String connectorURI = getConnectorURI ( ) ; \n \n \t2 TransportConnector connector = broker . addConnector ( connectorURI ) ; \n \n \t2 port = connector . getConnectUri ( ) . getPort ( ) ; \n \n <ect>
\t2 final Histogram < Short > opticalDupesByLibraryId = iterator . getOpticalDupesByLibraryId ( ) ; \n \n \t2 <comment> \n \n \t2 log . info ( <string_literal> + progress . getCount ( ) + <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + iterator . getNumRecordsWithNoMateCigar ( ) + <string_literal> ) ; \n \n <ect>
\t3 this . logger . debug ( <string_literal> + item + <string_literal> ) ; } \n \n \t2 if ( item == null ) { \n \n \t3 item = this . callback . createForPool ( ) ; \n \n <ect>
public void tearDown ( ) throws IOException { \n \n \t1 temp . delete ( ) ; } \n \n @ Test \n \n public void testSslLogging ( ) throws Exception { \n \n <ect>
\t5 try { \n \n \t6 String encoding = EncodingDetector . detect ( ontology ) ; \n \n \t6 mgr . doImport ( ontology , encoding ) ; \n \n \t5 } catch ( Exception t ) { \n \n <ect>
\t3 if ( pstmt != null ) { \n \n \t4 try { \n \n \t5 pstmt . close ( ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t2 if ( settings != null ) { \n \n \t3 if ( settings . getStartSite ( ) . length ( ) >= 1 ) { \n \n \t4 m_site . select ( settings . getStartSite ( ) . substring ( 0 , settings . getStartSite ( ) . length ( ) - 1 ) ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 @ EventListener \n \n \t1 public void handleConfigurationModifiedEvent ( final CasConfigurationModifiedEvent event ) { \n \n \t2 if ( this . contextRefresher == null ) { \n \n <ect>
\t5 } catch ( Exception e ) { \n \n \t6 s_logger . debug ( <string_literal> + host . getId ( ) ) ; \n \n \t6 continue ; } } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t4 logger . debug ( <string_literal> + \n \n \t6 <string_literal> + \n \n \t6 <string_literal> , ex ) ; } \n \n \t3 catch ( Throwable ex ) { \n \n <ect>
\t3 securityApi . authorizeSecurityGroupIngressInRegion ( region , id , perms ) ; \n \n \t3 logger . debug ( <string_literal> , name ) ; } \n \n \t2 return id ; \n \n \t1 } catch ( IllegalStateException e ) { \n \n <ect>
\t6 if ( ! eventHandler . awaitStopped ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n \t7 <comment> \n \n \t7 <comment> \n \n \t7 <comment> \n \n <ect>
\t5 return ; } \n \n \t4 getController ( ) . pollNode ( getNode ( ) ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t2 Response response = client . target ( PortProviderUtil . generateURL ( <string_literal> , T_FALSE ) ) . request ( ) \n \n \t4 . post ( Entity . entity ( big , <string_literal> ) ) ; \n \n \t2 Assert . assertEquals ( <number_literal> , response . getStatus ( ) ) ; \n \n \t2 String entity = response . readEntity ( String . class ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t4 request , \n \n \t4 response , \n \n \t4 formatter , \n \n \t4 content ) ; \n \n <ect>
\t5 cnt ++ ; \n \n \t5 TaskInfo taskInfo = new TaskInfo ( entry . getKey ( ) , <string_literal> ) ; \n \n \t5 taskInfoMap . put ( cnt , taskInfo ) ; \n \n \t5 newTasks . add ( cnt ) ; \n \n <ect>
\t2 try { \n \n \t3 createNode ( zk , normPath , JStormUtils . barr ( ( byte ) <number_literal> ) , org . apache . zookeeper . CreateMode . PERSISTENT ) ; \n \n \t2 } catch ( KeeperException e ) { \n \n \t3 <comment> \n \n <ect>
\t4 <comment> \n \n \t4 char payload [ ] = new char [ payloadSize ] ; \n \n \t4 int read = _reader . read ( payload ) ; \n \n \t4 if ( read != payloadSize ) { \n \n <ect>
\t2 return result ; } \n \n \t1 @ Override \n \n \t1 public boolean deletePrivateGateway ( final PrivateGateway gateway ) throws ConcurrentOperationException , ResourceUnavailableException { \n \n \t2 if ( gateway . getType ( ) != VpcGateway . Type . Private ) { \n \n <ect>
\t1 callback . onResponse ( TransportResponseImpl . < RestResponse > error ( \n \n \t2 HttpNettyClient . toException ( cause ) , Collections . < String , String > emptyMap ( ) ) ) ; } \n \n \t1 else \n \n \t1 { \n \n <ect>
\t2 existsResponse = admin ( ) . indices ( ) . prepareAliasesExist ( <string_literal> ) \n \n \t4 . addIndices ( <string_literal> ) . get ( ) ; \n \n \t2 assertThat ( existsResponse . exists ( ) , equalTo ( true ) ) ; \n \n \t2 <comment> \n \n <ect>
\t3 LOGGER . warn ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 final String grantType = context . getRequestParameter ( OAuth20Constants . GRANT_TYPE ) ; \n \n \t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . CLIENT_ID ) ) { \n \n <ect>
\t6 timelineClient . init ( conf ) ; \n \n \t6 timelineClient . start ( ) ; \n \n \t5 } else { \n \n \t6 timelineClient = null ; \n \n <ect>
\t1 # something happens ; Knox is interesting in that they re - generate missing files like \n \n \t1 # keystores which can cause side effects if the upgrade goes wrong \n \n \t1 if params . upgrade_direction and params . upgrade_direction == Direction . UPGRADE : \n \n \t1 absolute_backup_dir = upgrade . backup_data ( ) \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t4 eventReader . close ( ) ; \n \n \t3 } catch ( XMLStreamException e ) { \n \n <ect>
\t4 suspendAutoLoading = true ; } } \n \n \t2 List < SecondaryStorageVmVO > alreadyRunning = \n \n \t4 _secStorageVmDao . getSecStorageVmListInStates ( SecondaryStorageVm . Role . templateProcessor , dataCenterId , State . Running , State . Migrating , State . Starting ) ; \n \n \t2 if ( alreadyRunning . size ( ) == 0 ) { \n \n <ect>
\t3 and not sudo . path_exists ( <string_literal> ) and sudo . path_exists ( <string_literal> ) : \n \n \t1 Link ( <string_literal> , to = <string_literal> ) \n \n \t1 restricted_packages = conf_select . get_restricted_packages ( ) \n \n \t1 if 0 == len ( restricted_packages ) : \n \n <ect>
\t4 if ( tempMetaFile . exists ( ) ) { \n \n \t5 try { \n \n \t6 FileUtils . forceDelete ( tempMetaFile . getParentFile ( ) ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t1 dos . writeUTF ( <string_literal> ) ; } \n \n \t1 dos . close ( ) ; \n \n \t1 } catch ( InterruptedIOException e ) { \n \n \t1 Thread . currentThread ( ) . interrupt ( ) ; \n \n <ect>
\t1 basicTest ( c , REG_TABLE_NAME , 0 ) ; \n \n \t1 c . tableOperations ( ) . setProperty ( REG_TABLE_NAME , Property . TABLE_SPLIT_THRESHOLD . getKey ( ) , \n \n \t2 <string_literal> + SPLIT_THRESH ) ; \n \n \t1 sleepUninterruptibly ( timeoutFactor * <number_literal> , TimeUnit . SECONDS ) ; \n \n <ect>
\t3 connectListener = new ClientSessionChannel . MessageListener ( ) { \n \n \t4 public void onMessage ( ClientSessionChannel channel , Message message ) { \n \n \t5 LOG . debug ( <string_literal> , message ) ; \n \n \t5 if ( ! message . isSuccessful ( ) ) { \n \n <ect>
\t3 final List < MetadataResolver > resolvers = new ArrayList < > ( ) ; \n \n \t3 resolvers . add ( metadataProvider ) ; \n \n \t3 return resolvers ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t6 <comment> \n \n \t6 SearchResponse searchResponse = bulkClient . client ( ) \n \n \t8 . execute ( SearchAction . INSTANCE , new SearchRequest ( mapIndex ( request , index ) ) ) \n \n \t8 . actionGet ( ) ; \n \n <ect>
\t1 final SecurityTokenAWSCredentialsProvider roleCredentialProvider = \n \n \t3 SecurityTokenAWSCredentialsProvider . forUserOrRole ( Accounts . lookupPrincipalByRoleId ( lbRole . getRoleId ( ) ) ) ; \n \n \t1 return EucaS3ClientFactory . getEucaS3Client ( roleCredentialProvider ) ; \n \n \t1 } catch ( AuthException ex ) { \n \n <ect>
\t4 } ) ; \n \n \t3 } catch ( Throwable t ) { \n \n \t5 logger . warn ( <string_literal> , t ) ; \n \n <ect>
\t4 idpMetadata . setSigningCertificate ( unspecifiedKey ) ; } \n \n \t3 if ( idpMetadata . getEncryptionCertificate ( ) == null && unspecifiedKey != null ) { \n \n \t4 idpMetadata . setEncryptionCertificate ( unspecifiedKey ) ; } \n \n \t3 if ( idpMap . containsKey ( idpMetadata . getEntityId ( ) ) ) { \n \n <ect>
\t3 for ( int i = 0 ; i < sz ; i ++ ) { \n \n \t4 OutboundMessageState state = new OutboundMessageState ( _context , msgs . get ( i ) , peer ) ; \n \n \t4 states . add ( state ) ; } \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 <comment> \n \n \t2 RestoreSnapshotResponse restoreSnapshotResponse = restoreSnapshotResponseFuture . actionGet ( TimeValue . timeValueSeconds ( <number_literal> ) ) ; \n \n \t2 assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . failedShards ( ) , greaterThan ( 0 ) ) ; \n \n \t2 assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , equalTo ( restoreSnapshotResponse . getRestoreInfo ( ) . failedShards ( ) ) ) ; \n \n <ect>
\t5 if ( directoryToFetch . validateCheckSum ( fileCheckSumMap ) ) { \n \n \t6 logger . info ( <string_literal> + sourceFileUrl ) ; \n \n \t5 } else { \n \n \t6 stats . checkSumFailed ( ) ; \n \n <ect>
\t3 if ( val && ! tol ) { \n \n \t4 throw new SAXException ( ex ) ; } } \n \n \t2 @ Override \n \n \t2 public void fatalError ( SAXParseException ex ) throws SAXException { \n \n <ect>
\t1 private boolean _nothing ; \n \n \t1 public SolrFilterResult ( ) { \n \n \t2 _nothing = true ; } \n \n \t1 public SolrFilterResult ( String query ) { \n \n <ect>
\t2 LOG . info ( <string_literal> + session ) ; \n \n \t2 LOG . info ( <string_literal> + consumeSession ) ; \n \n \t2 producer = session . createProducer ( null ) ; \n \n \t2 producer . setDeliveryMode ( deliveryMode ) ; \n \n <ect>
public SaslSocketTransceiver ( SocketChannel channel , SaslServer saslServer ) \n \n \t1 throws IOException { \n \n \t1 this . sasl = new SaslParticipant ( saslServer ) ; \n \n \t1 this . channel = channel ; \n \n <ect>
\t1 public static void writeConfigToFile ( RuntimeEnvironment env , String filename ) throws IOException { \n \n \t2 if ( filename != null ) { \n \n \t3 LOGGER . log ( Level . INFO , <string_literal> , filename ) ; \n \n \t3 env . writeConfiguration ( new File ( filename ) ) ; \n \n <ect>
\t3 dlm . setMessageExpiration ( getContext ( ) . clock ( ) . now ( ) + <number_literal> * <number_literal> ) ; \n \n \t3 dlm . setReplyTunnel ( replyTunnel . getReceiveTunnelId ( 0 ) ) ; \n \n \t3 dlm . setSearchKey ( _key ) ; \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onUserSuspension ( long target , StreamListener [ ] listeners ) throws TwitterException { \n \n \t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onBlock ( JSONObject source , JSONObject target , StreamListener [ ] listeners ) throws TwitterException { \n \n <ect>
\t3 if ( networks != null ) { \n \n \t4 for ( NetworkVO network : networks ) { \n \n \t5 ReservationContext context = new ReservationContextImpl ( null , null , getActiveUser ( callerUserId ) , caller ) ; \n \n \t5 if ( ! _networkMgr . destroyNetwork ( network . getId ( ) , context , false ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 response = target . request ( ) . get ( ) ; \n \n \t2 InputStream inputStream = response . readEntity ( InputStream . class ) ; \n \n \t2 dataSource = DataSourceProvider . readDataSource ( inputStream , MediaType . TEXT_PLAIN_TYPE ) ; \n \n \t2 length = TestUtil . readString ( dataSource . getInputStream ( ) ) . length ( ) ; \n \n <ect>
\t2 EntityRef camera = GazeAuthoritySystem . getGazeEntityForCharacter ( character ) ; \n \n \t2 LocationComponent location = camera . getComponent ( LocationComponent . class ) ; \n \n \t2 Vector3f direction = location . getWorldDirection ( ) ; \n \n \t2 if ( ! ( vectorsAreAboutEqual ( event . getDirection ( ) , direction ) ) ) { \n \n <ect>
\t4 FieldMetadata < T , Float > fieldMetadata = ( FieldMetadata < T , Float > ) classMetadata . getField ( field . getName ( ) ) ; \n \n \t4 Property property = new FloatProperty ( target , fieldMetadata , range . min ( ) , range . max ( ) ) ; \n \n \t4 properties . add ( property ) ; } \n \n \t2 } catch ( NoSuchMethodException e ) { \n \n <ect>
\t3 try { \n \n \t4 if ( ! stopped . get ( ) ) { \n \n \t5 stop ( ) ; } \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 return <string_literal> ; } \n \n \t1 @ Override \n \n \t1 public void jobToBeExecuted ( JobExecutionContext context ) \n \n \t1 { \n \n <ect>
\t5 _pumper . registerConnect ( con ) ; \n \n \t5 con . getEstablishState ( ) . prepareOutbound ( ) ; \n \n \t4 } catch ( IOException ioe ) { \n \n \t5 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onLimit ( JSONObject json , StreamListener [ ] listeners ) throws TwitterException , JSONException { \n \n \t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onStallWarning ( JSONObject json , StreamListener [ ] listeners ) throws TwitterException , JSONException { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t2 LOG . trace ( <string_literal> , userName ) ; \n \n \t2 try { \n \n \t2 addLdapAuthentication ( userEntity , user . getDn ( ) , false ) ; \n \n \t2 } catch ( AmbariException e ) { \n \n <ect>
\t8 && ( deviceIndex == defaultOutputDeviceIndex ) ) ) \n \n \t4 { \n \n \t5 devices . add ( 0 , cdi ) ; \n \n \t5 if ( loggerIsDebugEnabled ) \n \n <ect>
\t2 if ( state != null ) { \n \n \t3 if ( state == PhysicalNetworkServiceProvider . State . Shutdown ) { \n \n \t4 throw new InvalidParameterValueException ( <string_literal> ) ; } \n \n <ect>
\t6 final long currentBytesSent = userStats . getCurrentBytesSent ( ) ; \n \n \t6 userStats . setCurrentBytesSent ( 0 ) ; \n \n \t6 userStats . setNetBytesSent ( userStats . getNetBytesSent ( ) + currentBytesSent ) ; \n \n \t6 _userStatsDao . update ( userStats . getId ( ) , userStats ) ; \n \n <ect>
\t5 if ( bundles != null && bundles . length > 0 ) { \n \n \t6 <comment> \n \n \t6 for ( File bundle : bundles ) { \n \n \t7 String externalForm = bundle . toURI ( ) . toURL ( ) . toExternalForm ( ) ; \n \n <ect>
\t4 connectionDriver = <string_literal> ; \n \n \t3 } else if ( connectionUrl . contains ( <string_literal> ) ) { \n \n \t4 Class . forName ( <string_literal> ) ; \n \n \t4 connectionDriver = <string_literal> ; } } \n \n <ect>
\t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t2 LOGGER . debug ( <string_literal> , CertUtils . toString ( cert ) ) ; \n \n \t2 final Collection < X509CRL > crls = getCRLs ( cert ) ; \n \n \t2 if ( crls == null || crls . isEmpty ( ) ) { \n \n <ect>
\t1 if ( fs != null ) { \n \n \t2 try { \n \n \t2 fs . close ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bc ) throws Exception { \n \n <ect>
\t4 continue ; } \n \n \t3 if ( isIgnoreIdleConsumers ( ) && subscriber . getDispatchedQueueSize ( ) == 0 ) { \n \n \t4 <comment> \n \n \t4 if ( slowConsumers . remove ( subscriber ) != null ) { \n \n <ect>
\t3 return false ; } } \n \n \t1 @ Override \n \n \t1 public boolean tfOLEDClear ( String uid ) { \n \n \t2 if ( ecosystem == null ) { \n \n <ect>
\t1 ) { \n \n \t1 ComponentNameAndConfigKey parsed = parseConfigKey ( key , configPrefix ) ; \n \n \t1 if ( parsed != null ) { \n \n \t2 String name = parsed . getComponentName ( ) . trim ( ) ; \n \n <ect>
<comment> \n \n \t1 public void analyzeSourceTree ( final Folder rootFolder ) { \n \n <ect>
\t2 byte [ ] base = { 1 , <number_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> , <number_literal> , 0 } ; \n \n \t2 StringBuilder builder = new StringBuilder ( ) ; \n \n \t2 for ( int i = 0 ; i < sizeInBytes ; i ++ ) { \n \n \t3 builder . append ( base [ i % base . length ] ) ; } \n \n <ect>
\t2 scanner . addListener ( new Scanner . BulkListener ( ) { \n \n \t3 @ Override \n \n \t3 public void filesChanged ( @ SuppressWarnings ( <string_literal> ) List changedFiles ) { \n \n \t4 try { \n \n <ect>
\t2 return receiveCounter ; } \n \n \t1 <comment> \n \n \t1 protected void processStompFrame ( String data ) { \n \n \t2 if ( ! transportStartedAtLeastOnce ( ) ) { \n \n <ect>
\t3 if ( ! removed ) { \n \n \t4 return ; <comment> \n \n <ect>
\t3 batchControlConsumer = new RabbitMessageConsumer < CoreMessage > ( channel , <string_literal> , uuid + batchControlQueueSuffix , \n \n <number_literal> Minion . this , routingKeys , closeUnbindKeys , CoreMessage . class ) ; \n \n \t3 return true ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 log . error ( e . getMessage ( ) , e ) ; \n \n \t4 try { \n \n \t5 sock . trueClose ( ) ; } \n \n \t4 catch ( IOException ioe ) { \n \n <ect>
\t4 ProtobufUtil . toString ( status ) ) ; \n \n \t3 ReplicationTableUtil . updateFiles ( tabletServer , extent , logEntry . filename , status ) ; } } \n \n \t1 } catch ( Throwable t ) { \n \n \t2 if ( tableConfiguration . getBoolean ( Property . TABLE_FAILURES_IGNORE ) ) { \n \n <ect>
\t1 ColumnList < String > cols = result . getResult ( ) ; \n \n \t1 logger . debug ( <string_literal> + cols . isEmpty ( ) ) ; \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t5 return answers ; } \n \n \t4 final Long current = _currentSequence ; \n \n \t4 if ( current != null && seq != current ) { \n \n <ect>
\t5 <comment> \n \n \t5 if ( connectionHook != null ) { \n \n \t6 tryAgain = connectionHook . onAcquireFail ( t , acquireConfig ) ; \n \n \t5 } else { \n \n <ect>
\t1 logger . info ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> + startDate ) ; \n \n <ect>
\t1 public void waitForMessagesToArrive ( int messageCount ) { \n \n \t2 waitForMessagesToArrive ( messageCount , <number_literal> * <number_literal> ) ; } \n \n \t1 public void waitForMessagesToArrive ( int messageCount , long maxWaitTime ) { \n \n \t2 long maxRemainingMessageCount = Math . max ( 0 , messageCount - messages . size ( ) ) ; \n \n <ect>
\t3 res . addHeader ( X_ATMOSPHERE_ERROR , <string_literal> ) ; \n \n \t3 res . flushBuffer ( ) ; \n \n \t3 return new Action ( ) ; } \n \n \t2 if ( Utils . webSocketEnabled ( req ) && ! supportWebSocket ( ) ) { \n \n <ect>
\t1 Stack Upgrade . \n \n \t1 <string_literal> <string_literal> <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 attributesToReturn . putAll ( getPrincipalAttributesAsMultiValuedAttributes ( model ) ) ; \n \n \t2 attributesToReturn . putAll ( authnAttributes ) ; \n \n \t2 decideIfCredentialPasswordShouldBeReleasedAsAttribute ( attributesToReturn , model , registeredService ) ; \n \n \t2 decideIfProxyGrantingTicketShouldBeReleasedAsAttribute ( attributesToReturn , model , registeredService ) ; \n \n <ect>
\t4 return false ; } \n \n \t3 int numberOfBytes = ( int ) offsetIntSize ; \n \n \t3 int expectedLength = ( int ) ( offsetTableOffset + ( numObjects * numberOfBytes ) + <number_literal> ) ; \n \n \t3 if ( theBytes . length != expectedLength ) { \n \n <ect>
\t3 return null ; } \n \n \t2 final Map < String , MultifactorAuthenticationProvider > providerMap = \n \n \t4 MultifactorAuthenticationUtils . getAvailableMultifactorAuthenticationProviders ( this . applicationContext ) ; \n \n \t2 if ( providerMap == null || providerMap . isEmpty ( ) ) { \n \n <ect>
\t4 catch ( Throwable t ) \n \n \t4 { \n \n \t5 JVMStabilityInspector . inspectThrowable ( t ) ; \n \n \t5 <comment> \n \n <ect>
\t2 var didKill = false \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 forEachLeakingJavaProcess { \n \n <ect>
\t5 int rv = flb . page ; \n \n \t5 flb = null ; \n \n \t5 return rv ; } \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 String deviceId = provider . getDeviceId ( itemName ) ; \n \n \t3 if ( commmandType != null ) { \n \n \t4 sendDataToDevice ( deviceId , commmandType , command ) ; } \n \n \t2 } else { \n \n <ect>
\t2 return new XmlCdiBeanFactory ( manager , environment , extension ) ; } \n \n \t1 Set < SyntheticBean < ? > > beansFrom ( String path ) throws JAXBException , IOException { \n \n \t2 URL url = getResource ( path ) ; \n \n \t2 if ( url == null ) { \n \n <ect>
\t5 pass \n \n \t2 except ClientDisconnected : \n \n \t3 self . log . debug ( <string_literal> ) \n \n \t2 except Exception as e : # pragma : no cover \n \n <ect>
\t1 LOG . error ( <string_literal> + batch , e ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t1 final Tag error = new BasicTag ( <string_literal> , e . getClass ( ) . getSimpleName ( ) ) ; \n \n \t1 DynamicCounter . increment ( ERRORS_COUNTER_ID . withAdditionalTag ( error ) ) ; \n \n <ect>
\t2 jobManagerClass , \n \n \t2 archiveClass ) \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
\t2 result = _call ( command , ** kwargs_copy ) \n \n \t2 break \n \n \t1 except ExecuteTimeoutException as ex : \t1 \n \n \t2 if on_timeout : \n \n <ect>
\t7 exclusion = true ; \n \n \t7 zController . requestRemoveNodesStart ( ) ; \n \n \t7 setInclusionTimer ( ) ; } \n \n \t5 } else { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
<number_literal> + <string_literal> \n \n <number_literal> + metadataStore . getCluster ( ) \n \n <number_literal> . getNumberOfNodes ( ) \n \n <number_literal> + <string_literal> ) ; } \n \n <ect>
\t5 device . serviceMap . put ( id , newObject ) ; \n \n \t5 <comment> \n \n \t5 break ; \n \n \t4 default : <comment> \n \n <ect>
\t2 <comment> \n \n \t2 Account caller = UserContext . current ( ) . getCaller ( ) ; \n \n \t2 if ( caller . getType ( ) != Account . ACCOUNT_TYPE_ADMIN ) { \n \n <ect>
\t2 executor . comment ( <string_literal> + StreamUtil . getLineSeparator ( ) ) ; \n \n \t2 ExecutorService . getInstance ( ) . setExecutor ( database , oldTemplate ) ; } \n \n \t1 @ Override \n \n \t1 public Status validate ( Connection connection , String defaultSchema ) { \n \n <ect>
\t4 try { \n \n \t5 consumeBatch ( MultipleThreadSpoutExecutors . this ) ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 if ( ! shutdown . get ( ) ) { \n \n <ect>
\t5 <comment> \n \n \t5 case 1 : { \n \n \t6 if ( command instanceof IncreaseDecreaseType ) { \n \n \t7 if ( IncreaseDecreaseType . INCREASE . equals ( command ) ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 @ Override \n \n \t1 public void grantLeadership ( final UUID leaderSessionID ) { \n \n <ect>
\t2 return routesRules . accept ( _advancedVisitor , router ) ; } \n \n \t1 @ Override \n \n \t1 public boolean applyUserData ( final Network network , final NicProfile nic , final VirtualMachineProfile profile , final DeployDestination dest , final DomainRouterVO router ) \n \n \t3 throws ResourceUnavailableException { \n \n <ect>
\t3 case Error : \n \n \t3 case Expunging : \n \n \t4 return false ; \n \n \t3 default : \n \n <ect>
\t3 ServiceActionContext currentContext = new ServiceActionContext ( entry . getToken ( ) , null ) ; \n \n \t3 actionController . execute ( currentContext , removeOAuthTokenAction ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t5 return FAILURE ; } } \n \n \t3 <comment> \n \n \t3 if ( aContext == STORE_LOAD_ELIMINATION ) { \t4 \n \n \t4 if ( stackHeight == 0 && minStackHeightAttained == 0 ) { \n \n <ect>
\t5 for ( NamingServiceListener nsl : _listeners ) { \n \n \t6 nsl . entryRemoved ( this , key ) ; } } \n \n \t4 return rv ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t6 routers . add ( router ) ; } \n \n \t5 rs . close ( ) ; \n \n \t5 pstmt . close ( ) ; \n \n \t5 for ( Object [ ] router : routers ) { \n \n <ect>
\t1 public void run ( ) \n \n \t1 { \n \n \t2 <comment> \n \n \t2 if ( ! initiator . equals ( FBUtilities . getBroadcastAddress ( ) ) ) \n \n <ect>
\t2 if ( exchangeCharsetName != null && ! exchangeCharsetName . isEmpty ( ) ) { \n \n \t3 try { \n \n \t4 if ( Charset . isSupported ( exchangeCharsetName ) ) { \n \n \t5 return Charset . forName ( exchangeCharsetName ) ; } \n \n <ect>
\t2 val connection = \n \n \t4 try { \n \n \t5 getDaemonConnection ( environment ) } \n \n \t4 catch ( e : Throwable ) { \n \n <ect>
\t6 LOG . debug ( <string_literal> , backoff ) ; \n \n \t6 try { \n \n \t7 Thread . sleep ( backoff ) ; \n \n \t6 } catch ( InterruptedException e ) { \n \n <ect>
\t2 public void localDeviceRemoved ( Registry registry , LocalDevice device ) { \n \n \t3 logger . trace ( <string_literal> + device . getDisplayString ( ) ) ; } \n \n \t2 @ Override \n \n \t2 public void beforeShutdown ( Registry registry ) { \n \n <ect>
\t3 log . trace ( <string_literal> + inKey + <string_literal> + inValue ) ; } \n \n \t2 if ( inValue == null ) \n \n \t2 { \n \n \t3 <comment> \n \n <ect>
\t4 <comment> \n \n \t4 try { \n \n \t5 HystrixRequestVariableDefault . remove ( this , v ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t2 LOGGER . info ( <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void addTicket ( final Ticket ticket ) { \n \n \t2 try { \n \n <ect>
\t6 } catch ( InitializationException e ) { \n \n \t7 logger . error ( <string_literal> + serialPort + <string_literal> + e . getMessage ( ) ) ; \n \n \t7 serialDeviceReady = false ; \n \n \t6 } catch ( Throwable e ) { \n \n <ect>
\t7 Client . SUBSCRIPTION_NAME ) ; \n \n \t5 sweeped . add ( clientId ) ; \n \n \t5 closed ++ ; } \n \n \t3 } catch ( Exception ignored ) { \n \n <ect>
\t3 if ( pool != null ) { \n \n \t4 if ( pool . getStatus ( ) == StoragePoolStatus . Up && pool . getDataCenterId ( ) == zoneId ) { \n \n \t5 prepareTemplateInOneStoragePool ( vmTemplate , pool ) ; \n \n \t4 } else { \n \n <ect>
\t1 for ( final ComputeAccountInitializer initializer : initializers ) { \n \n \t1 try { \n \n \t2 initializer . initialize ( accountNumber ) ; \n \n \t1 } catch ( final Exception e ) { \n \n <ect>
\t4 data = br . readLine ( ) ; } \n \n \t3 if ( reportData . charAt ( reportData . length ( ) - 1 ) == ' , ' ) { \n \n \t4 reportData . deleteCharAt ( reportData . length ( ) - 1 ) ; } \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 long duration = System . currentTimeMillis ( ) - startTime ; \n \n \t1 log . warn ( <string_literal> + printDuration ( duration ) ) ; } \n \n protected void startup ( ) { \n \n \t1 long startTime = System . currentTimeMillis ( ) ; \n \n <ect>
\t3 if ( StringUtils . isNotBlank ( this . loginConf ) ) { \n \n \t4 LOGGER . warn ( <string_literal> , this . loginConf ) ; } \n \n \t2 } else { \n \n \t3 final String loginConf = StringUtils . isBlank ( this . loginConf ) ? DEFAULT_LOGIN_CONFIG : this . loginConf ; \n \n <ect>
\t2 <comment> \n \n \t2 DateFormat dateFormat = new SimpleDateFormat ( <string_literal> ) ; \n \n \t2 Date currentDate = new Date ( ) ; \n \n \t2 String endDate = dateFormat . format ( currentDate ) ; \n \n <ect>
# Check if name directories have been marked as formatted \n \n for mark_dir in mark_dirs : \n \n \t1 if os . path . isdir ( mark_dir ) : \n \n \t1 marked = True \n \n <ect>
\t2 this . reader = reader ; } \n \n \t1 @ Override \n \n \t1 public void run ( ) { \n \n \t2 try { \n \n <ect>
\t2 final Properties props = new Properties ( ) ; \n \n \t2 try ( FileInputStream inStream = new FileInputStream ( file ) ) { \n \n \t3 props . load ( inStream ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 zipResult = 0 ; \n \n \t4 latch . countDown ( ) ; } \n \n \t3 @ Override \n \n \t3 public void onError ( Exception exception ) { \n \n <ect>
\t1 private void setFollowState ( FlooHandler flooHandler , String msg ) { \n \n \t2 flooHandler . state . setFollowedUsers ( flooHandler . state . followedUsers ) ; \n \n \t2 flooHandler . context . statusMessage ( msg ) ; } \n \n \t1 private void kickClient ( int userId ) { \n \n <ect>
\t2 TxnUtils . buildQueryWithINClause ( conf , queries , prefix , suffix , txnids , <string_literal> , false , false ) ; \n \n \t2 for ( String query : queries ) { \n \n \t2 LOG . debug ( <string_literal> + query + <string_literal> ) ; \n \n \t2 int rc = stmt . executeUpdate ( query ) ; \n \n <ect>
\t4 parameters . setPath ( accesspath ) ; } \n \n \t3 s_logger . info ( <string_literal> ) ; \n \n \t3 return parameters ; \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t3 assert this . workUnit == null ; \n \n \t3 this . workUnit = p ; \n \n \t3 assert executor . isParking ( ) ; \n \n \t3 executor . start ( workUnit ) ; \n \n <ect>
\t2 if ( request . getSkippedEntities ( ) . contains ( newDocumentReference ) ) { \n \n \t3 this . logger . debug ( <string_literal> , newDocumentReference ) ; \n \n \t2 } else if ( this . modelBridge . exists ( newDocumentReference ) ) { \n \n \t3 <comment> \n \n <ect>
\t1 if ( rs != null ) { \n \n \t2 try { \n \n \t2 rs . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t4 Pool < V > resourcePool = getResourcePoolForExistingKey ( key ) ; \n \n \t4 return resourcePool . size . get ( ) ; \n \n \t3 } catch ( IllegalArgumentException iae ) { \n \n <ect>
\t5 c . setProperty ( <string_literal> + i , <string_literal> + i ) ; } } \n \n \t3 nodeStore . merge ( extra , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; \n \n \t3 fileStore . flush ( ) ; \n \n \t3 long size1 = fileStore . getStats ( ) . getApproximateSize ( ) ; \n \n <ect>
\t3 InUse = true ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 InUse = false ; } \n \n \t1 if ( ! InUse ) { \n \n <ect>
\t1 public RepositoryLock lockRepository ( ) throws IOException { \n \n \t2 return new AzureRepositoryLock ( getBlockBlob ( <string_literal> ) , new Runnable ( ) { \n \n \t3 @ Override \n \n \t3 public void run ( ) { \n \n <ect>
\t3 signatureValidationFilter . setRequireSignedRoot ( false ) ; \n \n \t3 metadataFilterList . add ( signatureValidationFilter ) ; \n \n \t3 LOGGER . debug ( <string_literal> , signatureValidationFilter , service . getServiceId ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t5 <comment> \n \n \t5 continue ; } \n \n \t4 if ( collection . wasInitialized ( ) ) { \n \n \t5 <comment> \n \n <ect>
\t1 public ExternalBuilder ( Configuration envConf ) { \n \n \t1 this . envConf = envConf ; } \n \n \t1 @ Override \n \n \t1 public DatasetRepository getFromOptions ( Map < String , String > match ) { \n \n <ect>
\t4 req . getID ( ) \n \n \t3 } ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t1 futures . add ( pool . submit ( new Callable < Long > ( ) { \n \n \t2 @ Override \n \n \t2 public Long call ( ) throws Exception { \n \n \t2 try { \n \n <ect>
\t5 state = State . HANDSHAKE_FAIL ; \n \n \t5 ctx . close ( ) ; } } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t3 } else if ( ! StringUtils . isEmpty ( defaultUrl ) ) { \n \n \t4 if ( defaultUrl . length ( ) < = API_MAX_URL_LENGTH ) { \n \n \t5 parts . add ( new StringPart ( MESSAGE_KEY_URL , defaultUrl , UTF_8_ENCODING ) ) ; \n \n \t4 } else { \n \n <ect>
\t4 Node r \t2 = makeNode ( lex , datatype , lang , vType ) ; \n \n \t4 b . add ( v , r ) ; \n \n \t3 } catch ( SQLException ex ) \n \n \t3 { <comment> \n \n <ect>
\t2 while ( true ) { \n \n \t3 if ( semaphore . tryWriteLock ( remaining , TimeUnit . NANOSECONDS ) == 0 ) { \n \n \t4 lateFileRefFinds = ConcurrentHashMultiset . create ( ) ; \n \n \t4 shortCircuited = true ; \n \n <ect>
\t3 for ( HammerThread h : threads ) { \n \n \t4 LOG . warn ( h . getName ( ) + <string_literal> \n \n \t6 + h . current ) ; } \n \n \t2 } else { \n \n <ect>
\t5 log . warn ( <string_literal> , getDetails ( pd ) ) ; } } } \n \n \t2 if ( ! pd . attributeNames ( ) . hasMoreElements ( ) ) { \n \n <ect>
\t3 if ( ! promise . trySuccess ( completedFuture . getNow ( ) ) ) { \n \n \t4 logger . warn ( <string_literal> , promise ) ; } \n \n \t2 } else if ( completedFuture . isCancelled ( ) ) { \n \n \t3 if ( ! promise . cancel ( false ) ) { \n \n <ect>
\t3 try { \n \n \t4 <comment> \n \n \t4 this . qe . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 getContext ( ) . tunnelDispatcher ( ) . dispatchOutbound ( msg , outTunnel . getSendTunnelId ( 0 ) , null , to ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 <comment> \n \n \t6 continuation . setAttribute ( EXCHANGE_ATTRIBUTE_NAME , exchange ) ; \n \n \t6 continuation . resume ( ) ; \n \n \t5 } else { \n \n <ect>
\t3 failure ( broker , request , response , OBTAIN_LOCK , <string_literal> , project , <string_literal> , user2 , <string_literal> , Integer . toString ( CELL ) , <string_literal> , <string_literal> ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 result = success ( broker , request , response , OBTAIN_LOCK , <string_literal> , project , <string_literal> , user2 , <string_literal> , Integer . toString ( COL ) , <string_literal> , <string_literal> ) ; \n \n \t3 String lock2 = result . getString ( <string_literal> ) ; \n \n <ect>
\t1 ByteBuffer currentHeader = writeHeader ; \n \n \t1 for ( ByteBuffer buffer : buffers ) { \t2 <comment> \n \n \t1 if ( buffer . remaining ( ) == 0 ) continue ; \t1 <comment> \n \n \t1 if ( dataIsWrapped ) { \n \n <ect>
\t1 case SessionLog . OFF : \n \n \t2 <comment> \n \n \t2 return ; \n \n \t1 default : \n \n <ect>
<comment> \n \n \t1 private boolean isValidKeyUsage ( final X509Certificate certificate ) { \n \n <ect>
\t4 decoder . setHeaderInitializer ( this . headerInitializer ) ; } \n \n \t3 ReactorNettyCodec < byte [ ] > codec = new StompReactorNettyCodec ( decoder ) ; \n \n \t3 this . tcpClient = new ReactorNettyTcpClient < > ( this . relayHost , this . relayPort , codec ) ; } \n \n <ect>
\t4 mark . setEnd ( wasEnd ) ; \n \n \t4 input . close ( ) ; \n \n \t4 mark . update ( stream ) ; \n \n \t4 markDB . put ( dbKey , mark ) ; \n \n <ect>
\t5 AuthorizableAction action = cl . newInstance ( ) ; \n \n \t5 action . init ( securityProvider , config ) ; \n \n \t5 actions . add ( action ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 ErrorReport errorReport = new ErrorReport ( ) ; \n \n \t3 if ( rootStrategy == null ) \n \n \t3 { \n \n \t4 rootStrategy = new SteinerTreeRootStrategy ( new WorksheetDepthRootStrategy ( ) ) ; } \n \n <ect>
\t2 try { \n \n \t3 p . load ( new FileInputStream ( propertiesPath ) ) ; \n \n \t2 } catch ( FileNotFoundException e ) { \n \n \t3 ok = false ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t2 this . context = context ; \n \n \t2 try { \n \n \t3 initialization ( context ) ; \n \n \t2 } catch ( KarmaException ke ) { \n \n <ect>
\t1 try { \n \n \t2 if ( in != null ) { \n \n \t2 in . close ( ) ; } \n \n \t1 } catch ( Throwable ex ) { \n \n <ect>
\t2 final MessageRecoverer messageRecoverer = getMessageRecoverer ( ) ; \n \n \t2 retryInterceptor . setRecoverer ( ( args , cause ) - > { \n \n \t3 Message message = ( Message ) args [ 1 ] ; \n \n \t3 if ( messageRecoverer == null ) { \n \n <ect>
\t2 RoutingTable routingTable = RoutingTable . builder ( ) \n \n \t4 . addAsNew ( metaData . index ( <string_literal> ) ) \n \n \t4 . build ( ) ; \n \n \t2 ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . CLUSTER_NAME_SETTING . getDefault ( Settings . EMPTY ) ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; \n \n <ect>
\t5 Commands cmds = new Commands ( cmd ) ; \n \n \t5 try { \n \n \t6 _agentMgr . send ( agentId , cmds , _answerListener ) ; \n \n \t5 } catch ( AgentUnavailableException e ) { \n \n <ect>
\t1 try { \n \n \t2 connectionAmbaridb . rollback ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t1 } catch ( SQLException e1 ) { \n \n <ect>
public class SingleShardOneReplicaRoutingTests extends ESAllocationTestCase { \n \n \t1 private final Logger logger = Loggers . getLogger ( SingleShardOneReplicaRoutingTests . class ) ; \n \n \t1 public void testSingleIndexFirstStartPrimaryThenBackups ( ) { \n \n \t2 AllocationService strategy = createAllocationService ( Settings . builder ( ) . put ( <string_literal> , <number_literal> ) . build ( ) ) ; \n \n <ect>
\t3 final ExecutableOutputPO jobOutput = executableDao . getJobOutput ( uuid ) ; \n \n \t3 Preconditions . checkArgument ( jobOutput != null , <string_literal> + uuid ) ; \n \n \t3 return parseOutput ( jobOutput ) ; \n \n \t2 } catch ( PersistentException e ) { \n \n <ect>
\t6 log . debug ( <string_literal> , cl ) ; \n \n \t6 foundLoader = true ; \n \n \t6 break ; \n \n \t5 } catch ( Throwable e ) { \n \n <ect>
<comment> \n \n private Piece wantPiece ( Peer peer , BitField havePieces , boolean record ) { \n \n \t1 if ( halted ) { \n \n \t1 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 try { \n \n \t2 webMonitor . stop ( ) \n \n \t2 } catch { \n \n \t2 case t : Throwable = > \n \n <ect>
\t1 try { \n \n \t1 current = Transaction . current ( ) ; \n \n \t1 assertThat ( current ) . as ( <string_literal> ) . isSameAs ( scopedTransaction ) ; \n \n \t1 Customer . find . byName ( <string_literal> ) ; \n \n <ect>
\t5 if ( framePayloadLength > maxFramePayloadLength ) { \n \n \t6 protocolViolation ( ctx , <string_literal> + maxFramePayloadLength + <string_literal> ) ; \n \n \t6 return ; } \n \n <ect>
\t4 received += istream . read ( bytes ) ; \n \n \t3 } catch ( IOException e ) { \n \n \t4 Log . warning ( Log . FAC_TEST , <string_literal> + e . getMessage ( ) ) ; \n \n \t4 Assert . fail ( ) ; } } \n \n <ect>
\t3 } else { \n \n \t4 s_logger . warn ( <string_literal> + alertType + <string_literal> + dataCenterId + <string_literal> + podId + \n \n \t6 <string_literal> + subject + <string_literal> + body ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t4 suppress_log_different_version . log ( SuppressLog . Level . warn , sender , \n \n \t6 suppress_time_different_version_warnings , \n \n \t6 sender , Version . print ( version ) , Version . printVersion ( ) ) ; \n \n \t3 else \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t4 if ( iterator != null ) \n \n \t5 iterator . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 void start ( ) throws IOException , InterruptedException { \n \n \t2 synchronized ( startupShutdownLock ) { \n \n <ect>
\t3 String path = vol . substring ( 0 , vol . lastIndexOf ( File . separator ) ) ; \n \n \t3 TemplateLocation loc = new TemplateLocation ( _storage , path ) ; \n \n \t3 try { \n \n \t4 if ( ! loc . load ( ) ) { \n \n <ect>
\t3 <comment> \n \n \t3 authorizeService . isAdmin ( ( Context ) any ) ; \n \n \t3 result = true ; \n \n \t2 } } ; \n \n <ect>
\t3 long elapsed = System . currentTimeMillis ( ) - start ; \n \n \t3 LOG . info ( <string_literal> , BATCHSIZE , NOTREFERENCEABLE ? <string_literal> : <string_literal> , \n \n \t5 elapsed , super . fixture ) ; \n \n \t3 total += BATCHSIZE ; } \n \n <ect>
\t1 private UserAccountDao _userAccountDao ; \n \n \t1 @ Override \n \n \t1 public boolean authenticate ( String username , String password , Long domainId , Map < String , Object [ ] > requestParameters ) { \n \n <ect>
\t3 <string_literal> , now ) , <string_literal> , <string_literal> , false , false ) ; \n \n \t1 stage . addHostRoleExecutionCommand ( <string_literal> , Role . HBASE_REGIONSERVER , \n \n \t2 RoleCommand . STOP , new ServiceComponentHostStartEvent ( <string_literal> , \n \n \t3 <string_literal> , now ) , <string_literal> , <string_literal> , false , false ) ; \n \n <ect>
\t3 if ( storageVOs . size ( ) > 1 ) { \n \n \t4 s_logger . warn ( <string_literal> + templateId + <string_literal> + event . getAccountId ( ) + <string_literal> ) ; } \n \n \t3 for ( UsageStorageVO storageVO : storageVOs ) { \n \n <ect>
\t2 if ( m_InputStream . available ( ) > 0 ) { \n \n \t3 int len = m_InputStream . available ( ) ; \n \n \t3 byte buf [ ] = new byte [ len ] ; \n \n \t3 m_InputStream . read ( buf , 0 , len ) ; \n \n <ect>
\t4 public void removed ( final MongoDBSink obj ) { \n \n \t5 try { \n \n \t6 closeWriter ( obj ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t4 _setRemote ( request , false ) ; \n \n \t4 break ; \n \n \t3 default : \n \n \t4 queueInvalidSource ( request ) ; \n \n <ect>
\t4 log . debug ( <string_literal> ) ; \n \n \t4 decodeGetReferencesResponse ( length , in , out ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t2 this . log = log ; } \n \n \t1 @ Override \n \n \t1 public void recoveryRequired ( LogPosition startPosition ) \n \n \t1 { \n \n <ect>
\t3 logger . debug ( <string_literal> + i + <string_literal> + cuboidHLLMap . get ( i ) . getCountEstimate ( ) ) ; } \n \n \t2 logger . debug ( <string_literal> + totalRowsBeforeMerge ) ; \n \n \t2 logger . debug ( <string_literal> + grantTotal ) ; \n \n \t2 if ( grantTotal > 0 ) { \n \n <ect>
\t5 = ( WarningHeader ) response . getHeader ( WarningHeader . NAME ) ; \n \n \t4 if ( warningHeader != null ) \n \n \t4 { \n \n \t5 reason = warningHeader . getText ( ) ; \n \n <ect>
\t4 try { \n \n \t5 targetDoc . addTermFrame ( f ) ; \n \n \t4 } catch ( FrameMergeException e ) { \n \n \t5 <comment> \n \n <ect>
\t2 if ( type == null ) { \n \n \t3 String command = actionConfig . getCommand ( ) ; \n \n \t3 if ( ( command == null ) && ( actionConfig . getForward ( ) == null ) \n \n \t4 && ( actionConfig . getInclude ( ) == null ) ) { \n \n <ect>
\t2 boolean success = _networkMgr . restartNetwork ( networkId , callerAccount , callerUser , cleanup ) ; \n \n \t2 if ( success ) { \n \n \t3 s_logger . debug ( <string_literal> + networkId + <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t3 return ; } \n \n \t2 logger . debug ( <string_literal> , summary ) ; \n \n \t2 final ClusterState previousClusterState = state ( ) ; \n \n \t2 if ( ! previousClusterState . nodes ( ) . isLocalNodeElectedMaster ( ) && taskInputs . runOnlyWhenMaster ( ) ) { \n \n <ect>
\t1 num_llap_nodes = hsi_env_properties [ 'num_llap_nodes' ] \n \n \t1 elif hsi_env and 'num_llap_nodes' in hsi_env : \n \n \t1 num_llap_nodes = hsi_env [ 'num_llap_nodes' ] \n \n \t1 else : \n \n <ect>
\t5 continue ; } \n \n \t4 if ( fields . length >= <number_literal> ) { \n \n \t5 try { \n \n \t6 if ( currPid . equals ( fields [ 1 ] ) ) { \n \n <ect>
\t6 . newInstance ( new Object [ ] { } ) ; \n \n \t4 Security . addProvider ( instance ) ; \n \n \t4 logger . info ( <string_literal> + PROVIDER_BC ) ; \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t4 for ( Ability ability : entry . getValue ( ) ) { \n \n \t5 log . error ( prefix + <string_literal> + ability ) ; \t4 } } } \n \n \t2 ContinuousEffectsList < RestrictionEffect > restrictionEffects = ( ContinuousEffectsList < RestrictionEffect > ) game . getContinuousEffects ( ) . getRestrictionEffects ( ) ; \n \n \t2 log . error ( prefix ) ; \n \n <ect>
\t6 s_logger . error ( <string_literal> , e ) ; \n \n \t5 } catch ( IOException e ) { \n \n \t6 s_logger . error ( <string_literal> , e ) ; \n \n \t5 } catch ( Throwable e ) { \n \n <ect>
\t1 if ( ! containedSet . isEmpty ( ) ) \n \n \t1 { \n \n \t1 for ( String paramValue : containedSet ) \n \n \t1 { \n \n <ect>
\t1 public void onPostUpdate ( final DomainGroup inUpdatedDomainGroup ) \n \n \t1 { \n \n \t2 { \n \n <ect>
\t3 for ( Object candidate : values ) \n \n \t3 { \n \n \t4 if ( ! ( candidate instanceof IPartModel ) ) \n \n \t4 { \n \n <ect>
\t3 internalRunBackgroundSweepOperation ( ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n \t3 if ( isDisposed . get ( ) ) { \n \n \t4 return ; } \n \n <ect>
\t2 NSDictionary switchDictionary = ( NSDictionary ) conditionAssignment . objectForKey ( <string_literal> ) ; \n \n \t2 NSArray args = ( NSArray ) conditionAssignment . objectForKey ( <string_literal> ) ; \n \n \t3 log . debug ( <string_literal> + c . entity ( ) . name ( ) ) ; \n \n <ect>
\t3 context . errorMessage ( <string_literal> ) ; \n \n \t3 return null ; } \n \n \t2 VirtualFile parent = LocalFileSystem . getInstance ( ) . findFileByPath ( parentPath ) ; \n \n \t2 if ( parent == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 try ( OutputStream statsOut = new BufferedOutputStream ( new FileOutputStream ( filename ) ) ) { \n \n \t3 write ( statsOut , predicateStats , typeStats , statsTotal ) ; \n \n \t2 } catch ( IOException ex ) \n \n <ect>
\t2 throw new LoginException ( Messages . getInstance ( ) . getString ( \n \n \t3 <string_literal> , KEY_PRE_AUTHENTICATION_TOKENS ) ) ; <comment> \n \n \t1 for ( String token : tokens ) { \n \n \t2 preAuthenticationTokens . add ( token . trim ( ) ) ; } \n \n <ect>
\t4 getJournal ( ) . start ( ) ; \n \n \t4 loadPageFile ( ) ; \n \n \t4 LOG . info ( <string_literal> ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t7 registerMBean ( cbsKey , mbean , mbean . getName ( ) ) ; \n \n \t7 mbeansRefs . put ( cbsKey , mbean ) ; \n \n \t7 return mbean ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t3 finishFateOperation_result result = new finishFateOperation_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t6 <comment> \n \n \t6 workerVm . detachAllDisks ( ) ; \n \n \t6 workerVm . destroy ( ) ; } \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t2 logger . info ( strMovieRootElement ) ; \n \n \t2 Response response = target . request ( ) . post ( Entity . entity ( strMovieRootElement , <string_literal> ) ) ; \n \n \t2 Assert . assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n \t2 String entity = response . readEntity ( String . class ) ; \n \n <ect>
\t3 new LinkedBlockingQueue < Runnable > ( ) ) ; \n \n \t1 topologyTaskExecutorServiceMap . put ( clusterId , topologyTaskExecutor ) ; } \n \n \t1 return topologyTaskExecutor ; } \n \n private void queueHostTasks ( ClusterTopology topology , HostOfferResponse response , String hostName ) { \n \n <ect>
\t1 private static void checkIfDefaultVoice ( Voice voice ) { \n \n \t2 Locale locale = voice . getLocale ( ) ; \n \n \t2 Voice currentDefault = defaultVoices . get ( locale ) ; \n \n \t2 if ( currentDefault == null || currentDefault . wantToBeDefault < voice . wantToBeDefault ) { \n \n <ect>
\t4 firstProcessor . processRequest ( si ) ; \n \n \t4 if ( si . cnxn != null ) { \n \n \t5 incInProcess ( ) ; } \n \n \t3 } else { \n \n <ect>
\t3 int flushPeriod = AWS_LOG_STREAM_FLUSH_PERIOD_IN_SECONDS ; \n \n \t3 if ( awsLogStreamFlushPeriodInSeconds != null ) { \n \n \t4 flushPeriod = Integer . parseInt ( awsLogStreamFlushPeriodInSeconds ) ; } \n \n \t3 flushPeriodMillis = flushPeriod * <number_literal> ; \n \n <ect>
\t5 try { \n \n \t6 lastSentMessage = sendQueue . take ( ) ; \n \n \t6 logger . debug ( <string_literal> , sendQueue . size ( ) ) ; \n \n \t5 } catch ( InterruptedException e1 ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 if ( volumeAttachmentTokenMap != null && ! volumeAttachmentTokenMap . isEmpty ( ) ) { \n \n \t1 try { \n \n \t2 Entities . asTransaction ( VmInstance . class , updateFunction , VmInstances . TX_RETRIES ) . apply ( volumeAttachmentTokenMap ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 if ( in == null ) \n \n \t4 Fuseki . serverLog . error ( <string_literal> + resourceName ) ; \n \n \t3 template = FileUtils . readWholeFileAsUTF8 ( in ) ; } \n \n \t2 catch ( IOException ex ) { \n \n <ect>
\t2 twitpicSource = new ReplacementServiceTwitpicImpl ( ) ; \n \n \t2 twitpicServReg = \n \n \t3 context . registerService ( ReplacementService . class . getName ( ) , \n \n \t4 twitpicSource , hashtable ) ; \n \n <ect>
\t4 case Status . STATUS_COMMITTING : \n \n \t5 log . debug ( <string_literal> ) ; \n \n \t5 break ; \n \n \t4 case Status . STATUS_MARKED_ROLLBACK : \n \n <ect>
\t4 setResponseObject ( response ) ; \n \n \t3 } else { \n \n \t4 throw new ServerApiException ( ApiErrorCode . INTERNAL_ERROR , <string_literal> ) ; } \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t1 @ Override \n \n \t1 public DnsServiceProvider getDnsServiceProvider ( final Network network ) { \n \n \t2 final String dnsProvider = _ntwkSrvcDao . getProviderForServiceInNetwork ( network . getId ( ) , Service . Dns ) ; \n \n \t2 if ( dnsProvider == null ) { \n \n <ect>
\t2 if ( paramListenerBeans != null ) { \n \n \t3 for ( ParameterCreationListener creationListenerBean : paramListenerBeans ) { \n \n \t4 webRequest . addParameterListener ( creationListenerBean ) ; } \n \n \t2 } else { \n \n <ect>
\t5 a = m . getAttributes ( <string_literal> ) ; \n \n \t5 if ( a != null ) { \n \n \t6 String ver = a . getValue ( key ) ; \n \n \t6 if ( ver != null ) return ver ; } } } \n \n <ect>
\t4 t . printStackTrace ( ) ; \n \n \t3 } catch ( Throwable tt ) { } \n \n \t2 } finally { \n \n \t3 System . err . println ( <string_literal> + _sock . getLocalPort ( ) ) ; \n \n <ect>
\t1 { \n \n \t2 _reader . onDataAvailable ( data ) ; } \n \n \t1 catch ( Throwable ex ) \n \n \t1 { \n \n <ect>
\t7 boolean success = trigger . call ( ) ; \n \n \t7 assert success ; \n \n \t6 } catch ( Throwable e ) { \n \n \t7 log . error ( <string_literal> + trigger . toString ( ) + <string_literal> + evictionId + <string_literal> , e ) ; } } \n \n <ect>
\t4 if ( pstmt != null ) { \n \n \t5 pstmt . close ( ) ; } \n \n \t4 txn . commit ( ) ; \n \n \t3 } catch ( SQLException sqle ) { \n \n <ect>
\t6 log . trace ( <string_literal> , notifier ) ; \n \n \t6 try { \n \n \t7 notifier . eventRemoved ( event ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t3 pathSpec = <string_literal> ; } \n \n \t2 if ( endpoint . isMatchOnUriPrefix ( ) ) { \n \n \t3 pathSpec = pathSpec . endsWith ( <string_literal> ) ? pathSpec + <string_literal> : pathSpec + <string_literal> ; } \n \n \t2 addFilter ( context , filterHolder , pathSpec ) ; \n \n <ect>
\t3 String path = tmplt . substring ( 0 , tmplt . lastIndexOf ( File . separator ) ) ; \n \n \t3 TemplateLocation loc = new TemplateLocation ( _storage , path ) ; \n \n \t3 try { \n \n \t4 if ( ! loc . load ( ) ) { \n \n <ect>
public void discardConnection ( boolean doClose ) { \n \n \t1 <comment> \n \n @ Override \n \n public String [ ] listDatabases ( ) { \n \n <ect>
\t2 sessionCache . invalidate ( key ) ; \n \n \t2 session = sessionCache . get ( key ) ; } \n \n \t2 session . refresh ( false ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 File jrnlFile = new File ( objFilename ) ; \n \n \t2 if ( jrnlFile . exists ( ) ) { \n \n \t3 if ( jrnlFile . length ( ) > 0 ) { \n \n \t4 syslog . info ( <string_literal> + fileRef . getFilename ( ) ) ; \n \n <ect>
<comment> \n \n \t1 synchronized void connectOne ( long sid ) { \n \n \t2 if ( senderWorkerMap . get ( sid ) != null ) { \n \n <ect>
\t4 int len = m_ByteOut . size ( ) ; \n \n \t4 <comment> \n \n \t4 m_OutputStream . write ( FRAME_START ) ; <comment> \n \n \t4 m_OutputStream . write ( buf , 0 , len ) ; <comment> \n \n <ect>
\t3 if ( concurrentRequests == 0 ) { \n \n \t4 latch . await ( ) ; } \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 Thread . currentThread ( ) . interrupt ( ) ; \n \n <ect>
\t3 case ERROR : \n \n \t4 LOG . error ( <string_literal> , message ) ; \n \n \t4 break ; \n \n \t3 case WARN : \n \n <ect>
\t2 <comment> \n \n \t2 throw new RuntimeException ( <string_literal> ) ; } \n \n \t1 public void initWrapper ( ) { \n \n \t2 try { \n \n <ect>
public void testUserPrivilegesThroughGrant ( ) throws Exception { \n \n \t1 String user1 = testName . getMethodName ( ) ; \n \n \t1 final File user1Keytab = new File ( kdc . getKeytabDir ( ) , user1 + <string_literal> ) ; \n \n \t1 if ( user1Keytab . exists ( ) && ! user1Keytab . delete ( ) ) { \n \n <ect>
\t2 NettyHttpConsumer answer = new NettyHttpConsumer ( this , processor , getConfiguration ( ) ) ; \n \n \t2 configureConsumer ( answer ) ; \n \n \t2 if ( nettySharedHttpServer != null ) { \n \n \t3 answer . setNettyServerBootstrapFactory ( nettySharedHttpServer . getServerBootstrapFactory ( ) ) ; \n \n <ect>
\t2 if ( this . applicationContext . equals ( applicationContext ) ) { \n \n \t3 CamelContext camelContext = event . getApplicationContext ( ) . getBean ( CamelContext . class ) ; \n \n \t3 <comment> \n \n \t3 if ( camelContext . getStatus ( ) . isStopped ( ) ) { \n \n <ect>
\t3 grpcServerWithJWT . shutdown ( ) ; \n \n \t3 LOG . info ( <string_literal> ) ; } } \n \n \t1 @ Test \n \n \t1 public void testWithEnableTLS ( ) throws Exception { \n \n <ect>
\t1 } catch ( FileNotFoundException ex ) { \n \n \t2 <comment> \n \n \t1 if ( files == null ) { \n \n \t2 if ( location . getName ( ) . startsWith ( Constants . CLONE_PREFIX ) ) \n \n <ect>
\t9 taskHbs . get ( topologyMasterId ) . get_uptime ( ) < launchTime ) { \n \n \t8 <comment> <ect>
\t1 <comment> \n \n \t1 try { \n \n \t1 Remote . connect ( remoteHost , basePort ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
# the data directory is always a symlink to the <string_literal> data directory in / var / lib / knox \n \n # such as / var / lib / knox / data or / var / lib / knox / data - <number_literal> . <number_literal> . 0 . 0 - <number_literal> \n \n knox_data_dir = STACK_ROOT_DEFAULT + ' / current / knox - server / data' \n \n directories = { knox_data_dir : BACKUP_DATA_ARCHIVE } \n \n <ect>
\t4 CronScheduleBuilder scheduleBuilder = CronScheduleBuilder . cronSchedule ( cronPattern ) ; \n \n \t4 JobDetail job = newJob ( ReconnectJob . class ) . withIdentity ( jobKey ) . build ( ) ; \n \n \t4 CronTrigger trigger = newTrigger ( ) . withIdentity ( triggerKey ) . withSchedule ( scheduleBuilder ) . build ( ) ; \n \n \t4 sched . scheduleJob ( job , trigger ) ; \n \n <ect>
<comment> \n \n \t3 addListener : function ( el , sType , fn , oScope , bOverride ) { \n \n \t4 if ( ! fn || ! fn . call ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , message ) ; } \n \n \t2 try { \n \n \t3 serial = getStringFromText ( SERIAL_ID_REG_EXP , message ) ; \n \n \t2 } catch ( LightwaveRfMessageException le ) { \n \n <ect>
\t2 smtpAppender . start ( ) ; \n \n \t2 Logger logger = loggerContext . getLogger ( <string_literal> ) ; \n \n \t2 logger . addAppender ( smtpAppender ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n <ect>
\t4 result . add ( convertHistoryRecordToMessageEvent ( recs . next ( ) , room ) ) ; } \n \n \t3 removeHistorySearchProgressListeners ( reader ) ; \n \n \t2 } catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t2 <comment> \n \n \t1 double computeDurationOfDisabledLog_NoParameters ( final long len ) { \n \n \t2 lbLogger . setLevel ( Level . OFF ) ; \n \n \t2 for ( long i = 0 ; i < len ; i ++ ) \n \n <ect>
\t8 <string_literal> , <string_literal> , Item . ANY ) ; \n \n \t2 for ( MetadataValue identifier : identifiers ) { \n \n \t3 if ( this . supports ( identifier . getValue ( ) ) ) { \n \n \t4 <comment> \n \n <ect>
\t2 } catch ( ServletException e ) { \n \n \t3 LOG . error ( <string_literal> + finalLocation , e ) ; \n \n \t3 throw e ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 return ; } \n \n \t2 try { \n \n \t3 context . stop ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 else if ( daemonJVMOptions memorywiseFitsInto fattestOpts && FileAgeComparator ( ) . compare ( bestDaemonWithMetadata . runFile , runFile ) > 0 ) { \n \n \t5 <comment> \n \n <ect>
\t3 try { \n \n \t4 connector . connect ( ) ; \n \n \t3 } catch ( SwegonVentilationException e ) { \n \n \t4 logger . error ( <string_literal> , e ) ; \n \n <ect>
\t4 } catch ( InterruptedException ex ) { \n \n \t5 logger . error ( <string_literal> + ex . getMessage ( ) ) ; } } \n \n \t2 } catch ( IOException ex ) { \n \n \t3 logger . error ( <string_literal> + ex . getMessage ( ) ) ; } \n \n <ect>
\t5 try { \n \n \t6 int ab = Integer . parseInt ( chapter_interval . getText ( ) ) ; \n \n \t6 configuration . setChapterInterval ( ab ) ; \n \n \t5 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t2 public void takeLeadership ( CuratorFramework client ) throws Exception \n \n \t2 { \n \n \t3 log . info ( <string_literal> , client . toString ( ) ) ; \n \n \t3 takeLeadership . countDown ( ) ; \n \n <ect>
\t3 subject = node ( triple . getSubject ( ) , vf ) ; } \n \n \t2 try { \n \n \t3 predicate = vf . createIRI ( triple . getPredicate ( ) . getIRI ( ) . toString ( ) ) ; \n \n \t2 } catch ( @ SuppressWarnings ( <string_literal> ) IllegalArgumentException iae ) { \n \n <ect>
\t6 user . setState ( State . disabled . toString ( ) ) ; } \n \n \t5 _userAccountDao . update ( id , user ) ; } \n \n \t3 } ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 MessageContentsList result = ( MessageContentsList ) out . getBody ( ) ; \n \n <ect>
\t3 ret . put ( <string_literal> , msg ) ; } \n \n \t2 void handleJstack ( StringBuilder sb , Integer pid ) { \n \n \t3 String cmd = <string_literal> + pid ; \n \n \t3 try { \n \n <ect>
\t1 queue . remove ( task , status , taskResult , error ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t1 String errorMessage = format ( <string_literal> , task . getUuid ( ) ) ; \n \n \t1 if ( error instanceof MessageException ) { \n \n <ect>
\t1 Iterator < Entry < KeyExtent , TServerInstance > > iter = migrations . entrySet ( ) . iterator ( ) ; \n \n \t1 while ( iter . hasNext ( ) ) { \n \n \t2 Entry < KeyExtent , TServerInstance > entry = iter . next ( ) ; \n \n \t2 if ( deleted . contains ( entry . getValue ( ) ) ) { \n \n <ect>
\t1 void sign ( @ SuppressWarnings ( <string_literal> ) Jar jar ) throws Exception { \n \n \t2 String signing = getProperty ( SIGN ) ; \n \n \t2 if ( signing == null ) \n \n \t3 return ; \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t3 <comment> \n \n <ect>
\t4 return j ; \n \n \t3 <comment> \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 for ( int x = 1 ; x < = columnCount ; x ++ ) { \n \n \t6 rowObjects . add ( resultSet . getObject ( x ) ) ; } \n \n \t5 results . add ( rowObjects ) ; } } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public boolean ping ( ) { \n \n \t2 try { \n \n \t3 final String url = buildUrlHttpScheme ( getApiHost ( ) . concat ( <string_literal> ) ) ; \n \n <ect>
\t1 public void setSampleFrequency ( String mediaInfoValue ) { \n \n \t2 this . sampleFrequency = getSampleFrequencyFromLibMediaInfo ( mediaInfoValue ) ; } \n \n \t1 public static int getChannelsNumberFromLibMediaInfo ( String mediaInfoValue ) { \n \n \t2 if ( isEmpty ( mediaInfoValue ) ) { \n \n <ect>
\t2 if ( ! x . isLiteral ( ) ) { \n \n \t3 log . warn ( <string_literal> + list ) ; \n \n \t3 return null ; } \n \n \t2 if ( ! SpatialValueUtil . isDecimal ( x ) ) { \n \n <ect>
\t3 snapshotObj . processEvent ( Snapshot . Event . OperationSucceeded ) ; \n \n \t3 UsageEventUtils . publishUsageEvent ( EventTypes . EVENT_SNAPSHOT_OFF_PRIMARY , snapshotObj . getAccountId ( ) , snapshotObj . getDataCenterId ( ) , snapshotId , \n \n \t5 snapshotObj . getName ( ) , null , null , 0L , snapshotObj . getClass ( ) . getName ( ) , snapshotObj . getUuid ( ) ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t6 public int write ( byte [ ] data ) throws SevenZipException { \n \n \t7 try { \n \n \t8 out . write ( data ) ; \n \n \t7 } catch ( IOException e ) { \n \n <ect>
\t3 line = reader . readLine ( ) ; \n \n \t3 Properties props = SAMUtils . parseParams ( line ) ; \n \n \t3 String value = props . getProperty ( <string_literal> ) ; \n \n \t3 if ( value == null ) { \n \n <ect>
public static void set ( Map < String , String > conf ) { \n \n \t1 Objects . requireNonNull ( conf ) ; \n \n \t1 config = conf ; } \n \n public static void print ( ) { \n \n <ect>
\t5 controlNic = nic ; \n \n \t4 } else if ( nic . getTrafficType ( ) == TrafficType . Guest ) { \n \n \t5 guestNetworkId = nic . getNetworkId ( ) ; } } } \n \n \t2 if ( controlNic == null ) { \n \n <ect>
\t2 if ( deliveryStreamNames != null && deliveryStreamNames . contains ( deliveryStreamName ) ) { \n \n \t3 deliveryStreamExists = true ; \n \n \t3 LOG . info ( <string_literal> + deliveryStreamName + <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t3 final boolean result = citrixResourceBase . cleanupHaltedVms ( conn ) ; \n \n \t3 if ( ! result ) { \n \n \t4 return new ReadyAnswer ( command , <string_literal> ) ; } \n \n \t2 } catch ( final XenAPIException e ) { \n \n <ect>
\t5 <string_literal> + message . getVersion ( ) ) ; } \n \n \t2 this . agentConfig = agentConfig ; \n \n \t2 this . download = new File ( agentConfig . getHome ( ) . getTempDirectory ( ) , <string_literal> ) ; \n \n \t2 this . agentOutputStream = new FileOutputStream ( download ) ; \n \n <ect>
\t3 String target = keyPath + targetBlobName ; \n \n \t3 logger . debug ( <string_literal> , source , target , blobStore ) ; \n \n \t3 blobStore . moveBlob ( source , target ) ; \n \n \t2 } catch ( URISyntaxException | StorageException e ) { \n \n <ect>
public class CachingOneTimeTokenRepository extends BaseOneTimeTokenRepository { \n \n \t1 private final LoadingCache < String , Collection < OneTimeToken > > storage ; \n \n \t1 @ Override \n \n \t1 public void cleanInternal ( ) { \n \n <ect>
\t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 private void doHandle ( HttpExchange t ) throws Exception { \n \n \t2 String path = t . getRequestURI ( ) . getPath ( ) ; \n \n <ect>
\t1 final String host = Iterables . getFirst ( hostSplitter . split ( fullHostHeader ) , fullHostHeader ) ; \n \n \t1 final Name hostDnsName = Name . fromString ( host , Name . root ) ; \n \n \t1 return OSGUtil . isBucketName ( hostDnsName , true ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 } catch ( SQLException e ) { \n \n \t3 throw new CloudRuntimeException ( <string_literal> , e ) ; } \n \n \t2 s_logger . debug ( <string_literal> ) ; } \n \n \t1 private void updateVlanUris ( Connection conn ) { \n \n <ect>
\t1 public List < Requirement > getAncestorRequirementsFor ( TestOutcome testOutcome ) { \n \n \t2 for ( RequirementsTagProvider tagProvider : getRequirementsTagProviders ( ) ) { \n \n \t3 Optional < Requirement > requirement = getParentRequirementOf ( testOutcome , tagProvider ) ; \n \n \t3 if ( requirement . isPresent ( ) ) { \n \n <ect>
\t1 bootstrap . add ( new DiscoverServices ( ) ) ; \n \n \t1 bootstrap . add ( new BusConfiguration ( ) ) ; \n \n \t1 bootstrap . add ( new FinishInit ( ) ) ; } \n \n public void execute ( final BootstrapContext context ) { \n \n <ect>
\t3 params . add ( new Pair < OperationType , String > ( OperationType . addvlanid , vlanId . toString ( ) ) ) ; \n \n \t3 try { \n \n \t4 s_logger . info ( <string_literal> + ethPortProfileName + <string_literal> + vlanId ) ; \n \n \t4 netconfClient . updatePortProfile ( ethPortProfileName , SwitchPortMode . trunk , params ) ; \n \n <ect>
\t2 synchronized ( matchedListMutex ) { \n \n \t3 try { \n \n \t4 matched . destroy ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 } catch ( AccessDeniedException e ) { \n \n \t1 LOG . debug ( <string_literal> + Contexts . lookup ( ) . getCorrelationId ( ) + <string_literal> ) ; \n \n \t1 throw e ; \n \n \t1 } catch ( S3Exception e ) { \n \n <ect>
\t3 assertEquals ( 1 , successfulShards ) ; \n \n \t3 totalHits = ( int ) XContentMapValues . extractValue ( <string_literal> , response ) ; \n \n \t3 assertEquals ( numDocs , totalHits ) ; } } \n \n \t1 void assertBasicSearchWorks ( int count ) throws IOException { \n \n <ect>
\t2 if ( jmsMessage != null ) { \n \n \t3 try { \n \n \t4 setMessageId ( jmsMessage . getJMSMessageID ( ) ) ; \n \n \t3 } catch ( JMSException e ) { \n \n <ect>
\t3 final SearchResult groupResult = response . getResult ( ) ; \n \n \t3 for ( final LdapEntry entry : groupResult . getEntries ( ) ) { \n \n \t4 final LdapAttribute groupAttribute = entry . getAttribute ( this . groupAttributeName ) ; \n \n \t4 if ( groupAttribute == null ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void externalAddressReceived ( AddressSource source , byte [ ] ip , int port ) { \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 s_logger . info ( <string_literal> ) ; } \n \n \t3 return false ; \n \n \t2 } else if ( burstSize != null && ! burstSize . equals ( shapingPolicy . getBurstSize ( ) ) ) { \n \n <ect>
\t1 private void maybeLogHeapDetails ( ) { \n \n \t2 JvmInfo jvmInfo = JvmInfo . jvmInfo ( ) ; \n \n \t2 ByteSizeValue maxHeapSize = jvmInfo . getMem ( ) . getHeapMax ( ) ; \n \n \t2 String useCompressedOops = jvmInfo . useCompressedOops ( ) ; \n \n <ect>
\t2 } else { \n \n \t3 Utils . sleep ( <number_literal> ) ; \n \n \t3 warnningStep ++ ; \n \n \t3 if ( warnningStep % <number_literal> == 0 ) { \n \n <ect>
\t2 public Response logoutResponse ( @ Context UriInfo uriInfo , \n \n \t9 @ QueryParam ( <string_literal> ) String state ) { \n \n \t3 UserSessionModel userSession = session . sessions ( ) . getUserSession ( realm , state ) ; \n \n \t3 if ( userSession == null ) { \n \n <ect>
\t2 } catch ( NoClassDefFoundError e ) { \n \n \t3 LOG . warn ( <string_literal> , logLevelUpper , loggerName , e ) ; \n \n \t3 return false ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t4 public void recover ( XATransactionId xid , Message [ ] addedMessages , MessageAck [ ] acks ) { \n \n \t5 try { \n \n \t6 getTx ( xid ) . trackStore ( adapter . createTransactionStore ( ) ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t2 DecoratedKey epkey = StorageService . getPartitioner ( ) . decorateKey ( hostIdBytes ) ; \n \n \t2 final AtomicInteger rowsReplayed = new AtomicInteger ( 0 ) ; \n \n \t2 Composite startColumn = Composites . EMPTY ; \n \n \t2 int pageSize = calculatePageSize ( ) ; \n \n <ect>
\t1 while ( readLen != - 1 ) { \n \n \t2 zip . write ( chunk , 0 , readLen ) ; \n \n \t2 readLen = in . read ( chunk ) ; } \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t8 newClusterXml , \n \n \t8 MetadataStore . STORES_KEY , \n \n \t8 newStoresXml ) ; \n \n \t2 } else { \n \n <ect>
\t4 return null ; } \n \n \t4 s_logger . debug ( <string_literal> + vm . toString ( ) + <string_literal> + _restartRetryInterval ) ; } \n \n \t2 } catch ( final InsufficientCapacityException e ) { \n \n <ect>
\t3 if ( editPage instanceof EditRelationshipPageInterface ) { \n \n \t4 ( ( EditRelationshipPageInterface ) editPage ) . setMasterObjectAndRelationshipKey ( object ( ) , propertyKey ( ) ) ; \n \n \t4 ( ( EditRelationshipPageInterface ) editPage ) . setNextPage ( context ( ) . page ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 if ( recurse ) { \n \n \t3 <comment> \n \n \t3 for ( LayerInfo l : layers ) { \n \n \t4 catalog . remove ( l ) ; \n \n <ect>
\t2 c . instanceOperations ( ) . waitForBalance ( ) ; \n \n \t2 return true ; } \n \n \t1 } ) ; \n \n \t1 wait . get ( <number_literal> , TimeUnit . SECONDS ) ; \n \n <ect>
\t2 if ( loginContext != null ) { \n \n \t3 try { \n \n \t4 loginContext . logout ( ) ; \n \n \t3 } catch ( LoginException le ) { \n \n <ect>
\t3 try { \n \n \t4 managementContext . unregisterMBean ( name ) ; \n \n \t3 } catch ( Throwable e ) { \n \n \t4 LOG . warn ( <string_literal> , name ) ; \n \n <ect>
\t2 <comment> \n \n \t2 List < CompletedCheckpoint > lastTryRetrievedCheckpoints = new ArrayList < > ( numberOfInitialCheckpoints ) ; \n \n \t2 List < CompletedCheckpoint > retrievedCheckpoints = new ArrayList < > ( numberOfInitialCheckpoints ) ; \n \n \t2 do { \n \n <ect>
<comment> \n \n \t1 public void stop ( ) { \n \n \t2 String now = DateTimeUtils . nowAsString ( ) ; \n \n <ect>
\t1 removeSourceField = BooleanUtils . toBooleanDefaultIfNull ( getFilterDescriptor ( ) . isRemoveSourceField ( ) , removeSourceField ) ; \n \n \t1 LOG . info ( <string_literal> + messagePattern + <string_literal> + multilinePattern + <string_literal> + \n \n \t1 getShortDescription ( ) ) ; \n \n \t1 if ( StringUtils . isEmpty ( messagePattern ) ) { \n \n <ect>
\t4 } else { \n \n \t5 try { \n \n \t6 endpoint = Integer . parseInt ( segments [ i ] ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t1 private static final Logger s_logger = Logger . getLogger ( ConsoleProxyAjaxImageHandler . class ) ; \n \n \t1 public void handle ( HttpExchange t ) throws IOException { \n \n \t2 try { \n \n <ect>
\t2 synchronized ( _stateLock ) { \n \n \t3 oldState = _state ; \n \n \t3 _state = state ; } \n \n \t2 if ( _log != null && oldState != state && state != State . STOPPED && _log . shouldLog ( Log . WARN ) ) { \n \n <ect>
\t2 defaultConfig . setThreadModel ( ExecutorThreadModel . getInstance ( <string_literal> ) ) ; \n \n \t2 acceptor . bind ( this . addr , new ServerSessionHandler ( cache , memcachedVersion , verbose , idleTime ) ) ; \n \n \t2 ProtocolCodecFactory codec = new MemcachedProtocolCodecFactory ( ) ; \n \n \t2 acceptor . getFilterChain ( ) . addFirst ( <string_literal> , new ProtocolCodecFilter ( codec ) ) ; \n \n <ect>
\t2 session = realmManager . getSession ( ) ; \n \n \t2 realm = session . realms ( ) . getRealmByName ( <string_literal> ) ; \n \n \t2 ClientModel clientFromCache = session . realms ( ) . getClientById ( clientDBId , realm ) ; \n \n \t2 ClientModel clientFromDB = session . getProvider ( RealmProvider . class ) . getClientById ( clientDBId , realm ) ; \n \n <ect>
\t4 throw new CloudRuntimeException ( <string_literal> + label + <string_literal> + citrixResourceBase . getHost ( ) . getIp ( ) ) ; } \n \n \t3 s_logger . debug ( <string_literal> + nw . getNetwork ( ) . getUuid ( conn ) ) ; \n \n \t3 final PIF pif = nw . getPif ( conn ) ; \n \n \t3 final PIF . Record pifRec = pif . getRecord ( conn ) ; \n \n <ect>
\t3 return double . class ; } \n \n \t2 try { \n \n \t3 return Class . forName ( arg ) ; \n \n \t2 } catch ( final ClassNotFoundException e ) { \n \n <ect>
\t2 } finally { \n \n \t3 ACTIVE_TX_ID . remove ( ) ; } } \n \n \t1 @ Override \n \n \t1 public void txRolledback ( String id ) { \n \n <ect>
\t3 String volumeid = snapshotTO . getVolume ( ) . getUuid ( ) ; \n \n \t3 String snapshotname = snapshotTO . getName ( ) ; \n \n \t3 Answer answer = ElastistorUtil . createElastistorVolumeSnapshot ( volumeid , snapshotname ) ; \n \n \t3 if ( answer . getResult ( ) == false ) { \n \n <ect>
\t2 ContentName name = new ContentName ( _testPrefix , _testNonRepo ) ; \n \n \t2 input = new CCNInputStream ( name , getHandle ) ; \n \n \t2 Assert . assertFalse ( RepositoryControl . localRepoSync ( getHandle , input ) ) ; \n \n \t2 Thread . sleep ( <number_literal> ) ; <comment> \n \n <ect>
\t8 body . getLocals ( ) . add ( newLocal ) ; \n \n \t8 body . getUnits ( ) . insertBefore ( Jimple . v ( ) . newAssignStmt ( newLocal , constant ) , u ) ; \n \n \t8 invokeExpr . setArg ( 0 , newLocal ) ; \n \n \t8 if ( verbose ) \n \n <ect>
\t3 <comment> \n \n \t3 if ( getType ( ) != Format . UNKNOWN && getMedia ( ) != null && ( getMedia ( ) . isEncrypted ( ) || getMedia ( ) . getContainer ( ) == null || getMedia ( ) . getContainer ( ) . equals ( DLNAMediaLang . UND ) ) ) { \n \n \t4 valid = false ; \n \n \t4 if ( getMedia ( ) . isEncrypted ( ) ) { \n \n <ect>
\t1 public CompletableFuture < Acknowledge > confirmCheckpoint ( \n \n \t3 ExecutionAttemptID executionAttemptID , \n \n \t3 long checkpointId , \n \n \t3 long checkpointTimestamp ) { \n \n <ect>
\t2 BoneCPDataSource newDS = new BoneCPDataSource ( newConfig ) ; \n \n \t2 newDS . getConnection ( ) . close ( ) ; <comment> \n \n \t2 <comment> \n \n \t2 setTargetDataSource ( newDS ) ; \n \n <ect>
\t1 for ( int i = 0 ; i < children . length ; i ++ ) { \n \n \t2 File f = new File ( dir , children [ i ] ) ; \n \n \t2 boolean success = deleteDir ( f ) ; \n \n \t2 if ( ! success ) { \n \n <ect>
\t4 callback . done ( doneSync ) ; \n \n \t3 } ) ; \n \n \t3 return false ; \n \n \t2 } else { \n \n <ect>
\t2 long keyTupleCount = ( long ) ( ( ( double ) count / totalSampleCount_ ) * totalTuples ) ; \n \n \t2 int redCount = ( int ) Math . round ( Math . ceil ( ( double ) keyTupleCount / tupleMCount ) ) ; \n \n \t2 { \n \n <ect>
\t3 if ( ! aws . getResult ( ) ) { \n \n \t4 s_logger . warn ( <string_literal> + dest . getHost ( ) . getId ( ) + <string_literal> + aws . getDetails ( ) ) ; } \n \n \t3 return aws . getResult ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 } else { \n \n \t3 log . trace ( <string_literal> ) ; } \n \n \t2 <comment> \n \n \t2 if ( this . boolean1 == null || this . boolean1 != true ) { \n \n <ect>
\t4 if ( debug ) { \n \n \t5 if ( iter > 1 ) \n \n \t6 logger . info ( <string_literal> + norm + <string_literal> + Math . abs ( obj - prev ) + <string_literal> ) ; \n \n \t5 else \n \n <ect>
\t3 s_logger . info ( ex ) ; \n \n \t3 s_logger . trace ( ex ) ; \n \n \t3 throw new ServerApiException ( BaseCmd . INSUFFICIENT_CAPACITY_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t3 getDefaultClusteredCacheConfig ( CacheMode . DIST_SYNC , false ) ) ; \n \n \t1 builder . clustering ( ) . hash ( ) . numOwners ( 1 ) ; \n \n \t1 return builder ; } \n \n public void testGet ( ) throws Exception { \n \n <ect>
\t4 <comment> \n \n \t4 throw new CloudRuntimeException ( <string_literal> + bridge + <string_literal> + res ) ; } \n \n \t3 return ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 } catch ( Exception ex ) { \n \n \t3 throw new RuntimeException ( ex ) ; } } \n \n \t2 } ) ; \n \n \t2 String traceOutput = finalBuffer . toString ( ) ; \n \n <ect>
\t5 countries . increment ( country ) ; \n \n \t4 transportCount [ classifyTransports ( ri ) ] ++ ; } } \n \n \t2 long end = System . currentTimeMillis ( ) ; \n \n \t2 if ( log . shouldWarn ( ) ) \n \n <ect>
\t5 _log . warn ( <string_literal> + file ) ; } \n \n \t3 return rv ; \n \n \t2 } catch ( IOException ioe ) { \n \n \t3 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t4 logger . warn ( <string_literal> , e ) ; } } } \n \n \t1 private boolean isJobPoolFull ( ) { \n \n \t2 Map < String , Executable > runningJobs = context . getRunningJobs ( ) ; \n \n \t2 if ( runningJobs . size ( ) >= jobEngineConfig . getMaxConcurrentJobLimit ( ) ) { \n \n <ect>
\t7 c . toPrevToken ( ) ; \n \n \t7 xmlGenerator . createSampleForType ( element . getType ( ) , c ) ; \n \n \t7 c . dispose ( ) ; \n \n \t6 } else { \n \n <ect>
\t4 LOGGER . warn ( <string_literal> ) ; \n \n \t4 numberOfShards = <string_literal> ; } \n \n \t3 String replicationFactor = GraphUtils . getAsStringValue ( root , pReplicas ) ; \n \n \t3 if ( replicationFactor == null || replicationFactor . isEmpty ( ) ) { \n \n <ect>
\t3 logger . warn ( <string_literal> , oe . getMessage ( ) , oe ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 logger . warn ( <string_literal> , e ) ; } \n \n \t2 while ( ! connected && retriesRemaining > 0 ) { \n \n <ect>
\t1 int [ ] ds = { 0 , 1 , <number_literal> , 0 , 1 , <number_literal> , 0 , 1 , <number_literal> } ; \n \n \t1 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t1 int r = rs [ i % rs . length ] ; \n \n \t1 int d = ds [ i % ds . length ] ; \n \n <ect>
\t3 DistributeRepositoriesStructuredOutput . class ) ; \n \n \t1 } catch ( JsonSyntaxException e ) { \n \n \t2 LOG . error ( <string_literal> , e ) ; } \n \n \t1 if ( null == structuredOutput || null == structuredOutput . repositoryVersionId ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 else { \n \n \t3 Path p = getIdSwapPath ( actionDir ) ; \n \n <ect>
\t3 if ( ! isThereEnoughThreadsForNextIteration ( LOAD_INCREASE ) ) { \n \n \t4 LOG . warn ( <string_literal> ) ; \n \n \t4 break ; } \n \n \t3 if ( ! isLatestMeasurementWithinLimits ( ) ) { \n \n <ect>
<comment> \n \n \t1 public void exceptionCaught ( IoSession session , Throwable cause ) throws CharacterCodingException { \n \n \t2 <comment> \n \n <ect>
\t3 String pnmasEnabled = ( String ) configuration . get ( CONFIG_KEY_PNMAS_ENABLED ) ; \n \n \t3 if ( pnmasEnabled != null ) { \n \n \t4 String [ ] pnmasIds = pnmasEnabled . split ( <string_literal> ) ; \n \n \t4 for ( String pnmasId : pnmasIds ) { \n \n <ect>
\t3 topFieldNames . add ( field . getName ( ) ) ; } \n \n \t2 topRel = HiveRelFactories . HIVE_PROJECT_FACTORY . createProject ( topRel , topFields , topFieldNames ) ; } \n \n \t2 topRR = new RowResolver ( ) ; \n \n \t2 if ( ! RowResolver . add ( topRR , leftRR ) ) { \n \n <ect>
\t3 } catch ( AssertionError e ) { \n \n \t4 failure = e ; \n \n \t3 } catch ( Throwable e ) { \n \n \t4 failure = new AssertionError ( e ) ; } \n \n <ect>
\t1 } catch ( Exception e ) { \n \n \t1 throw new InitialisationException ( e , this ) ; } } \n \n @ Override \n \n public void start ( ) throws MuleException { \n \n <ect>
\t2 Injector injector = Guice . createInjector ( new MyModule ( ) ) ; \n \n \t2 MyConfigurableRoute2 instance = injector . getInstance ( Key . get ( MyConfigurableRoute2 . class , \n \n <number_literal> Names . named ( <string_literal> ) ) ) ; \n \n \t2 assertNotNull ( <string_literal> , instance ) ; \n \n <ect>
\t5 int selected = selector . select ( SELECTOR_POLL_MS ) ; \n \n \t5 selectTimeMs = System . currentTimeMillis ( ) - selectTimeMs ; \n \n \t5 selectCount = selected ; \n \n \t5 if ( isClosed . get ( ) ) { \n \n <ect>
\t3 HostVO nuageVspHost = _nuageVspManager . getNuageVspHost ( network . getPhysicalNetworkId ( ) ) ; \n \n \t3 TrashNetworkVspCommand cmd = new TrashNetworkVspCommand ( vspNetwork ) ; \n \n \t3 Answer answer = _agentMgr . easySend ( nuageVspHost . getId ( ) , cmd ) ; \n \n \t3 if ( answer == null || ! answer . getResult ( ) ) { \n \n <ect>
\t4 case UDPPacket . PAYLOAD_TYPE_SESSION_DESTROY : \n \n \t5 _state = <number_literal> ; \n \n \t5 if ( auth == AuthType . BOBINTRO ) { \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 while ( true ) { \n \n \t5 receivedBytesMessage . readBoolean ( ) ; \n \n \t5 numElements ++ ; } \n \n \t3 } catch ( Exception ex ) { } \n \n <ect>
\t5 if ( fn != null ) { \n \n \t6 return fn ; } } \n \n \t3 } catch ( ParseException e ) { \n \n \t4 <comment> \n \n <ect>
\t6 <comment> \n \n \t6 <comment> \n \n \t6 <comment> \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 if ( cboCtx . type == PreCboCtx . Type . VIEW && ! materializedView ) { \n \n \t3 throw new SemanticException ( <string_literal> ) ; } \n \n \t3 sinkOp = getOptimizedHiveOPDag ( ) ; \n \n \t3 if ( oldHints . size ( ) > 0 ) { \n \n <ect>
\t2 RouteBuilderParser . parseRouteBuilderEndpoints ( clazz , <string_literal> , <string_literal> , details ) ; \n \n \t2 LOG . info ( <string_literal> , details ) ; \n \n \t2 List < ParserResult > list = CamelJavaParserHelper . parseCamelConsumerUris ( method , true , true ) ; \n \n \t2 for ( ParserResult result : list ) { \n \n <ect>
\t3 logger . info ( <string_literal> , truststore . getAbsolutePath ( ) ) ; \n \n \t3 if ( ! truststore . exists ( ) ) { \n \n \t4 logger . info ( <string_literal> , truststore . getAbsolutePath ( ) ) ; \n \n \t4 truststore = new File ( FileServer . getFileServer ( ) . getBaseDir ( ) , trustStoreToUse ) ; \n \n <ect>
\t4 jobPool . execute ( new JobRunner ( executable ) ) ; \n \n \t4 logger . info ( jobDesc + <string_literal> ) ; \n \n \t3 } catch ( Exception ex ) { \n \n \t4 context . removeRunningJob ( executable ) ; \n \n <ect>
\t1 LOG . debug ( <string_literal> ) ; \n \n \t1 pm . retrieveAll ( mSecurityTabPartList ) ; \n \n \t1 List < HiveObjectPrivilege > result = convertPartCols ( mSecurityTabPartList ) ; \n \n \t1 success = commitTransaction ( ) ; \n \n <ect>
\t2 ensureStableCluster ( nodeCount , TimeValue . timeValueSeconds ( <number_literal> ) , false , viaNode ) ; } \n \n \t1 protected void ensureStableCluster ( int nodeCount , TimeValue timeValue , boolean local , @ Nullable String viaNode ) { \n \n \t2 if ( viaNode == null ) { \n \n \t3 viaNode = randomFrom ( internalCluster ( ) . getNodeNames ( ) ) ; } \n \n <ect>
\t5 ( InstanceListener ) clazz . newInstance ( ) ; \n \n \t5 wrapper . addInstanceListener ( listener ) ; \n \n \t4 } catch ( Throwable t ) { \n \n \t5 ExceptionUtils . handleThrowable ( t ) ; \n \n <ect>
\t3 toDispose . addAll ( managedKeyedState ) ; \n \n \t3 toDispose . addAll ( rawKeyedState ) ; \n \n \t3 StateUtil . bestEffortDiscardAllStateObjects ( toDispose ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public NativizeSetFunDef ( FunDef dummyFunDef ) { \n \n \t2 super ( dummyFunDef ) ; \n \n \t2 LOGGER . debug ( <string_literal> ) ; } \n \n \t1 public Exp createCall ( Validator validator , Exp [ ] args ) { \n \n <ect>
\t4 eventPublisher . postUpdate ( itemName , new DecimalType ( getTVVolume ( ip + <string_literal> + port ) . volume ) ) ; } \n \n \t2 } else if ( tvCommand . contains ( <string_literal> ) ) { \n \n \t3 eventPublisher . postUpdate ( itemName , new StringType ( getSource ( ip + <string_literal> + port ) ) ) ; \n \n \t2 } else { \n \n <ect>
\t5 try { \n \n \t6 Thread . sleep ( <number_literal> ) ; \n \n \t5 } catch ( InterruptedException ie ) { \n \n \t6 <comment> \n \n <ect>
\t2 interceptor . retInterceptor = new InterceptorAdapter ( ) { \n \n \t3 @ Nullable @ Override public GridBiTuple onBeforeRemove ( Object key , @ Nullable Object val ) { \n \n \t4 return new GridBiTuple ( false , null ) ; } \n \n \t2 } ; \n \n <ect>
\t2 assertEquals ( THRIFT_TEST_NUM1 * THRIFT_TEST_NUM2 , responseBody ) ; } \n \n \t1 @ Test \n \n \t1 @ SuppressWarnings ( { <string_literal> , <string_literal> } ) \n \n \t1 public void testCalculateWithException ( ) throws Exception { \n \n <ect>
\t2 LOG . debug ( <string_literal> + stat [ i ] . getPath ( ) . getName ( ) ) ; } } \n \n \t1 Assert . assertTrue ( sawNewBase ) ; } \n \n @ Test \n \n public void majorTableLegacy ( ) throws Exception { \n \n <ect>
\t2 networkConnection . setupBasicAuthentication ( httpURLConnection , createEncodedCredentials ( principalKeyCredential ) ) ; \n \n \t1 } else { \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 if ( StringUtils . isEmpty ( externalAddress ) ) { \n \n <ect>
\t5 cacheItem = listeners [ index ] ; } \n \n \t4 if ( ! el || ! cacheItem ) { \n \n \t5 <comment> \n \n \t5 return false ; } \n \n <ect>
\t3 assertion = AssertionUtil . getAssertion ( responseType , deployment . getDecryptionKey ( ) ) ; \n \n \t3 if ( AssertionUtil . hasExpired ( assertion ) ) { \n \n \t4 return initiateLogin ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 if ( entry . getValue ( ) . equalsIgnoreCase ( ipAddr ) ) { \n \n \t5 macAddr = entry . getKey ( ) ; \n \n \t5 break ; } } \n \n \t3 ipAddr = _macIpMap . remove ( macAddr ) ; \n \n <ect>
\t4 nInfo = newInfo ; \n \n \t3 } else if ( ! repliable ) { \n \n \t4 <comment> \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 if ( values . length >= PARAM_START ) { \n \n \t3 log . info ( tn + <string_literal> + myStart + <string_literal> + myCurrent + <string_literal> + myEnd ) ; <comment> \n \n \t3 if ( myEnd != COUNT_UNUSED ) { \n \n \t4 if ( myCurrent > myEnd ) { \n \n <ect>
\t3 try { \n \n \t4 LOG . info ( <string_literal> + message ) ; \n \n \t4 counter ++ ; \n \n \t4 if ( counter < = <number_literal> ) { \n \n <ect>
\t3 if ( getReadFailureHandler ( ) != null ) { \n \n \t4 getReadFailureHandler ( ) . handleFailedRead ( uri , model , e ) ; } \n \n \t3 else { \n \n \t4 <comment> \n \n <ect>
\t4 sink = _remotePeers . get ( id ) ; } \n \n \t3 if ( sink != null ) { \n \n \t4 sink . received ( data , offset , length ) ; \n \n \t3 } else { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 return ; } \n \n <ect>
\t1 @ Override \n \n \t1 public void onClose ( WebSocket webSocket ) { } \n \n \t1 @ Override \n \n \t1 public void onError ( WebSocket webSocket , WebSocketProcessor . WebSocketException t ) { \n \n <ect>
\t3 BackdoorToggles . addToggles ( sqlRequest . getBackdoorToggles ( ) ) ; \n \n \t2 final QueryContext queryContext = QueryContextFacade . current ( ) ; \n \n \t2 TraceScope scope = null ; \n \n \t2 if ( kylinConfig . isHtraceTracingEveryQuery ( ) || BackdoorToggles . getHtraceEnabled ( ) ) { \n \n <ect>
\t1 } catch ( IOException ioe ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t1 private ProtocolProviderServiceSipImpl findTargetFor ( Request request ) \n \n \t1 { \n \n \t2 if ( request == null ) \n \n \t2 { \n \n <ect>
\t3 localTaskCleanupTimeouts . putAll ( taskCleanupTimeouts ) ; \n \n \t2 try { \n \n \t3 localState . put ( Common . LS_TASK_CLEANUP_TIMEOUT , localTaskCleanupTimeouts ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + volumeId ) ; \n \n \t3 File volFile = new File ( DirectStorageInfo . getStorageInfo ( ) . getVolumesDir ( ) + File . separator + volumeId ) ; \n \n \t3 if ( volFile . exists ( ) ) { \n \n \t4 if ( ! volFile . delete ( ) ) { \n \n <ect>
\t2 Iterable < ExternalIdentityRef > externalGroups ; \n \n \t2 try { \n \n \t3 externalGroups = external . getDeclaredGroups ( ) ; \n \n \t2 } catch ( ExternalIdentityException e ) { \n \n <ect>
\t3 try { \n \n \t4 int index = Integer . parseInt ( dataIndex ) ; \n \n \t4 setDataStartRowIndex ( index ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t1 public synchronized boolean addType ( String label , List < String > examples ) { \n \n \t2 boolean savingSuccessful = false ; \n \n \t2 <comment> \n \n \t2 if ( label == null || label . trim ( ) . length ( ) == 0 || examples . isEmpty ( ) ) { \n \n <ect>
\t3 result . add ( new WebSocketTransportHandler ( new DefaultHandshakeHandler ( ) ) ) ; } \n \n \t2 catch ( Exception ex ) { \n \n \t3 Log logger = LogFactory . getLog ( DefaultSockJsService . class ) ; \n \n <ect>
\t2 try ( Stream < String > lines = Files . lines ( unicastHostsFilePath ) ) { \n \n \t3 hostsList = lines . filter ( line - > line . startsWith ( <string_literal> ) == false ) <comment> \n \n \t7 . collect ( Collectors . toList ( ) ) ; \n \n \t2 } catch ( FileNotFoundException | NoSuchFileException e ) { \n \n <ect>
\t3 IOUtils . closeQuietly ( in ) ; } \n \n \t2 <comment> \n \n \t2 ConfigurationLint . Status stat = ConfigurationLint . validate ( outputFile . getAbsolutePath ( ) ) ; \n \n \t2 if ( 0 != stat . getErrorSettingCount ( ) ) \n \n <ect>
public static synchronized ClassLoader getClassLoader ( ) throws IOException { \n \n \t1 if ( classloader == null ) { \n \n \t1 ArrayList < URL > urls = findAccumuloURLs ( ) ; \n \n \t1 ClassLoader parentClassLoader = AccumuloClassLoader . class . getClassLoader ( ) ; \n \n <ect>
\t1 } else { \n \n \t2 accountingGroups = lic . getGroupsPartition ( ) ; } \n \n \t1 } catch ( Exception e ) { \n \n \t1 LOG . error ( e , e ) ; \n \n <ect>
\t6 . stream ( ) \n \n \t6 . map ( a - > { \n \n \t7 Object value = null ; \n \n \t7 final TypedAttributeValue attributeValue = a . getValue ( ) ; \n \n <ect>
<comment> \n \n \t1 protected void verifyRegisteredService ( final RequestContext requestContext , final RegisteredService registeredService ) { \n \n \t2 if ( registeredService == null || ! registeredService . getAccessStrategy ( ) . isServiceAccessAllowed ( ) ) { \n \n <ect>
\t2 pass \n \n \t1 pass \n \n \t1 pass \n \n else : \n \n <ect>
\t1 public void purgeOnReturn ( ) { \n \n \t2 try { \n \n \t3 createPool ( ) . purgeOnReturn ( ) ; \n \n \t2 } catch ( SQLException x ) { \n \n <ect>
\t8 onEBusSyncReceived ( isReceiveBufferEmpty ( ) ) ; \n \n \t7 } catch ( Exception e ) { \n \n \t8 logger . error ( <string_literal> , e ) ; } } } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 try { \n \n \t4 ds . connect ( InetAddress . getByName ( <string_literal> ) , <number_literal> ) ; \n \n \t3 } catch ( UnknownHostException ex ) { \n \n <ect>
\t3 if ( patient == null ) { \n \n \t4 throw new HL7Exception ( <string_literal> ) ; } \n \n \t3 Context . getPatientService ( ) . savePatient ( patient ) ; \n \n \t2 } else { \n \n <ect>
\t4 . expireAfterWrite ( getExpiration ( ) , TimeUnit . valueOf ( getTimeUnit ( ) ) ) . build ( this . cacheLoader ) ; } \n \n \t1 @ Override \n \n \t1 protected void addPrincipalAttributes ( final String id , final Map < String , Object > attributes ) { \n \n \t2 this . cache . put ( id , attributes ) ; \n \n <ect>
\t1 dontSkipInstallForComponents . addAll ( hostGroup . getComponentNames ( INSTALL_AND_START ) ) ; \n \n \t1 return ambariContext . installHost ( hostName , ambariContext . getClusterName ( getClusterId ( ) ) , \n \n \t2 skipInstallForComponents , dontSkipInstallForComponents , skipFailure ) ; \n \n \t1 } catch ( AmbariException e ) { \n \n <ect>
\t7 initDeviceOutputValue ( device , DeviceConstants . DEVICE_SENSOR_OUTPUT ) ; \n \n \t6 } else { \n \n \t7 device . increase ( ) ; } \n \n \t5 } else { \n \n <ect>
\t5 command = PATH . matcher ( command ) . replaceAll ( Matcher . quoteReplacement ( path ) ) ; \n \n \t5 exec ( command ) ; } \n \n \t4 catch ( IOException e ) \n \n \t4 { \n \n <ect>
\t2 Preconditions . checkArgument ( \n \n \t4 ! parentDocuments . contains ( thriftUri ) , \n \n \t4 <string_literal> , thriftUri , Joiner . on ( <string_literal> ) . join ( parentDocuments ) + <string_literal> + thriftUri ) ; \n \n \t2 if ( parsedDocuments . contains ( thriftUri ) ) { \n \n <ect>
\t3 log . info ( <string_literal> ) ; \n \n \t3 Thread . sleep ( <number_literal> ) ; \n \n \t3 log . warn ( <string_literal> ) ; \n \n \t3 Thread . sleep ( <number_literal> ) ; \n \n <ect>
\t1 public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { \n \n \t2 try { \n \n \t3 callback . onFailure ( cause ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t3 return doAdd ( camelContext , key , newExchange , false ) ; \n \n \t2 } catch ( OptimisticUpdateException e ) { \n \n \t3 throw new OptimisticLockingException ( ) ; } } \n \n \t1 protected Exchange doAdd ( final CamelContext camelContext , final String key , final Exchange exchange , final boolean handleOptimisticLockingException ) { \n \n <ect>
\t1 } else { \n \n \t2 LOG . trace ( <string_literal> ) ; } \n \n \t1 tr . commit ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n public void setClusterProp ( ) throws Exception { \n \n <ect>
\t3 log . debug ( <string_literal> , sortedTopology . size ( ) , jobName , jobId ) ; } \n \n \t2 executionGraph . attachJobGraph ( sortedTopology ) ; \n \n <ect>
\t2 out . writeShort ( ( short ) comparator . length ( ) ) ; \n \n \t2 out . write ( comparator . getBytes ( Charsets . UTF_8 ) ) ; } \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t5 n . executor . execute ( tmci , <string_literal> + s . getPort ( ) ) ; \n \n \t4 } catch ( SocketException e ) { \n \n \t5 Logger . error ( this , <string_literal> + e , e ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 for ( ProviderConfig pc : providerConfigs . values ( ) ) { \n \n \t3 if ( ! pc . isValid ( ) ) { \n \n \t4 parseCompleted = true ; \n \n <ect>
\t4 return ; } \n \n \t3 <comment> \n \n \t3 installedRepository . installExtension ( localExtension , namespace , false ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 securityLog . info ( subject , <string_literal> , roleName ) ; \n \n \t3 return wasDeleted ; } \n \n \t2 catch ( AuthorizationViolationException | IOException | InvalidArgumentsException e ) \n \n \t2 { \n \n <ect>
\t7 if ( val == null ) { \n \n \t8 return null ; } \n \n \t7 state = new StringType ( val ) ; \n \n \t6 } else { \n \n <ect>
\t4 public void onResult ( final WriteConcernResult result , final Throwable t ) { \n \n \t5 if ( t != null ) { \n \n \t6 callback . onResult ( null , t ) ; \n \n \t5 } else { \n \n <ect>
\t4 blockMgrs . put ( fileRef , blockMgr ) ; } \n \n \t2 @ Override \n \n \t2 public void record ( FileRef fileRef , ObjectFile objFile ) { \n \n \t3 if ( recording ) \n \n <ect>
\t3 ResultConfig resultConfig = invocation . getProxy ( ) . getConfig ( ) . getResults ( ) . get ( resultCode ) ; \n \n \t3 if ( resultConfig != null ) { \n \n \t4 isRedirect = Redirectable . class . isAssignableFrom ( Class . forName ( resultConfig . getClassName ( ) ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 TcpChannel . closeChannel ( channel , false ) ; } \n \n \t4 } ; \n \n \t4 internalSendMessage ( channel , message , closeChannel ) ; } \n \n \t2 } else { \n \n <ect>
\t4 _log . warn ( <string_literal> + signedFile + <string_literal> , ioe ) ; \n \n \t3 return false ; \n \n \t2 } catch ( DataFormatException dfe ) { \n \n \t3 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
public boolean check ( @ Nullable String key , String value ) { \n \n \t1 try { \n \n \t1 return key != null && Iso8601DateParser . parse ( key ) . compareTo ( Iso8601DateParser . parse ( value ) ) < 0 ; \n \n \t1 } catch ( ParseException e ) { \n \n <ect>
\t2 } catch ( JoranException je ) { \n \n \t3 je . printStackTrace ( ) ; } \n \n \t2 StatusPrinter . printInCaseOfErrorsOrWarnings ( lc ) ; \n \n \t2 Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; \n \n <ect>
\t1 static synchronized public Document parse ( InputStream in ) { \n \n \t2 try { \n \n \t3 return ensureDocumentBuilder ( ) . parse ( in ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 } else { \n \n \t4 LOGGER . debug ( <string_literal> , ex . getScopeName ( ) ) ; } \n \n \t2 } ) ) ; \n \n \t2 if ( ! userScopes . isEmpty ( ) ) { \n \n <ect>
\t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n \t5 _log . info ( <string_literal> + ip ) ; \n \n \t4 return _context . namingService ( ) . lookup ( ip ) ; } \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 for ( int i = <number_literal> ; i < testCount ; ++ i ) { \n \n \t3 f . put ( cos [ i ] ) ; \n \n \t3 Log . info ( Log . FAC_TEST , <string_literal> + cos [ i ] . name ( ) ) ; \n \n \t3 test . check ( VersioningProfile . getLatestVersion ( cos [ i - 1 ] . name ( ) , putHandle . getDefaultPublisher ( ) , <number_literal> , putVerifier , getHandle ) , i ) ; } \n \n <ect>
\t2 final Map < String , Object > allAttributes = new HashMap < > ( principalAttributes ) ; \n \n \t2 final List < String > grouperGroups = new ArrayList < > ( ) ; \n \n \t2 final Collection < WsGetGroupsResult > results = GrouperFacade . getGroupsForSubjectId ( principal ) ; \n \n \t2 if ( results . isEmpty ( ) ) { \n \n <ect>
\t3 bridgesEnd . addAll ( networkConnector . activeBridges ( ) ) ; } \n \n \t2 LOG . info ( <string_literal> + bridgesEnd ) ; \n \n \t2 assertEquals ( <string_literal> , bridgesStart , bridgesEnd ) ; \n \n \t2 <comment> \n \n <ect>
\t5 log . trace ( <string_literal> + filenameOrURI + thisDirLogStr ) ; \n \n \t4 return null ; } \n \n \t2 } catch ( AccessControlException e ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 cache1 . get ( <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 cache2 . get ( <string_literal> ) ; \n \n <ect>
\t1 throw new LlapStatusCliException ( \n \n \t2 ExitCode . SLIDER_CLIENT_ERROR_OTHER , \n \n \t2 <string_literal> , e ) ; } \n \n \t1 if ( appDiagnostics == null ) { \n \n <ect>
\t1 password = StringEscapeUtils . unescapeHtml ( password ) ; \n \n \t1 username = StringEscapeUtils . unescapeHtml ( username ) ; \n \n \t1 UserDetails user = userDetailsService . loadUserByUsername ( username ) ; \n \n \t1 if ( user == null ) { \n \n <ect>
\t5 this . latestLeaderInfo . getMembers ( ) ) ; \n \n \t3 rescheduleAfterDelay ( ) ; \n \n \t3 return ; \n \n \t2 } else { \n \n <ect>
<comment> \n \n public void install ( ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . RELOCATING ) . get ( 0 ) . relocatingNodeId ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 clusterState = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; \n \n \t2 assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( <number_literal> ) ) ; \n \n <ect>
<comment> \n \n \t2 @ Override \n \n \t2 public void onFatalTimeout ( PeerContext receivingFrom ) { \n \n <ect>
\t4 s_logger . warn ( <string_literal> + networkOfferingId + <string_literal> + vmId + <string_literal> + \n \n \t6 event . getAccountId ( ) + <string_literal> ) ; } \n \n \t3 for ( UsageNetworkOfferingVO noVO : noVOs ) { \n \n <ect>
\t2 file = new File ( url . toURI ( ) ) ; \n \n \t2 if ( file . exists ( ) ) \n \n \t3 return file . getAbsolutePath ( ) ; } } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 myThread = null ; } \n \n \t3 results . setSuccessful ( success ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 Thread . currentThread ( ) . interrupt ( ) ; \n \n <ect>
\t3 tokens = inventoryPath . substring ( 1 ) . split ( <string_literal> ) ; \n \n \t2 else \n \n \t3 tokens = inventoryPath . split ( <string_literal> ) ; \n \n \t2 if ( tokens == null || tokens . length != <number_literal> ) { \n \n <ect>
\t1 public String getAddress ( ) { \n \n \t2 return jobMaster . getAddress ( ) ; } \n \n \t1 @ Override \n \n \t1 public void handleError ( Exception exception ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 Device device = Device . create ( rfAddress , configurations ) ; \n \n \t2 if ( device == null ) { \n \n <ect>
\t3 new String [ ] { <string_literal> } ) ) ; \n \n \t2 if ( ! configProperties . isEmpty ( ) ) { \n \n \t2 clusterMetricServerVipPort = configProperties . get ( <string_literal> ) ; } } \n \n \t1 } catch ( NoSuchParentResourceException | UnsupportedPropertyException e ) { \n \n <ect>
\t2 try { \n \n \t3 PreparedStatement pstmt = conn . prepareStatement ( <string_literal> ) ; \n \n \t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 if ( ! rs . next ( ) ) { \n \n <ect>
\t1 if ( ! isProperlyConfigured ) { \n \n \t1 logger . warn ( <string_literal> ) ; \n \n \t1 return ; } \n \n \t1 if ( ! isConnected ( ) ) { \n \n <ect>
\t4 this . selector = selector ; \n \n \t4 doSelect ( this . serverChannel , selector ) ; } } \n \n \t2 catch ( IOException e ) { \n \n \t3 if ( isActive ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( ! isDiscovered ( ) ) { \n \n \t3 if ( configurationSpecificToRenderer . getFolderLimit ( ) && depthLimit ( ) ) { \n \n \t4 if ( renderer . isPS3 ( ) || renderer . isXbox360 ( ) ) { \n \n <ect>
\t2 } catch ( NaException nae ) { \n \n \t3 s_logger . warn ( <string_literal> , nae ) ; \n \n \t3 throw new ServerException ( <string_literal> , nae ) ; \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
\t5 String deviceName = new String ( data , <string_literal> ) ; \n \n \t5 int roomId = bytes [ byteOffset ++ ] & 0xff ; \n \n \t5 devices . add ( new DeviceInformation ( deviceType , serialNumber , rfAddress , deviceName , roomId ) ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 public boolean remove ( Object id ) { \n \n \t2 if ( trackPooledBroadcaster ) { \n \n \t3 super . remove ( id ) ; \n \n \t2 } else { \n \n <ect>
\t3 ruleVO . setState ( FirewallRule . State . Revoke ) ; \n \n \t3 staticNatRules . add ( new StaticNatRuleImpl ( ruleVO , dstIp ) ) ; } \n \n \t2 try { \n \n \t3 if ( ! _firewallMgr . applyRules ( staticNatRules , true , false ) ) { \n \n <ect>
\t5 return true ; } } \n \n \t2 } catch ( UnknownHostException e ) { \n \n \t3 logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 return newState . name ( ) . getBytes ( UTF_8 ) ; } \n \n \t2 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t1 <comment> \n \n <ect>
\t2 if ( trackAttachDetach ) \n \n \t3 Log . info ( this , <string_literal> + txn ) ; \n \n \t2 theTxn . remove ( ) ; <comment> \n \n \t2 if ( trackAttachDetach ) \n \n <ect>
\t3 SimpleDateFormat sdf = new SimpleDateFormat ( ) ; \n \n \t3 try { \n \n \t4 return sdf . parse ( values [ 0 ] ) ; \n \n \t3 } catch ( ParseException e ) { \n \n <ect>
\t3 CmsUserSettings userSettings = new CmsUserSettings ( A_CmsUI . getCmsObject ( ) ) ; \n \n \t3 userSettings . setSynchronizeSettings ( m_synchronizeSettings ) ; \n \n \t3 userSettings . save ( A_CmsUI . getCmsObject ( ) ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t3 for ( Iterator < String > i = availPool . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { \n \n \t4 String host \t3 = i . next ( ) ; \n \n \t4 Map < SockIO , Long > sockets = availPool . get ( host ) ; \n \n <ect>
\t2 client ( ) . admin ( ) . indices ( ) . prepareCreate ( <string_literal> ) . execute ( ) . actionGet ( ) ; \n \n \t2 client ( ) . prepareIndex ( <string_literal> , <string_literal> ) . setSource ( <string_literal> , <string_literal> ) . setTimeout ( <string_literal> ) . execute ( ) . actionGet ( ) ; } \n \n \t1 public void testTwoNodesSingleDoc ( ) throws Exception { \n \n \t2 logger . info ( <string_literal> ) ; \n \n <ect>
\t4 if ( destVdi != null ) { \n \n \t5 try { \n \n \t6 destVdi . destroy ( conn ) ; \n \n \t5 } catch ( final Exception e ) { \n \n <ect>
\t4 InputStream input = method . getResponseBodyAsStream ( ) ; \n \n \t4 Element el = queryAsyncJobResult ( server , input ) ; \n \n \t4 Map < String , String > values = getSingleValueFromXML ( el , new String [ ] { <string_literal> } ) ; \n \n \t4 if ( values . get ( <string_literal> ) == null ) { \n \n <ect>
\t3 if ( testEntityOnSurvivorNode == null ) { \n \n \t4 log . info ( String . format ( <string_literal> , getEntityType ( testEntityOnFailNode ) , survivorNode ) ) ; \n \n \t3 } else { \n \n \t4 entityExists = true ; \n \n <ect>
\t3 nodesWithSameUri . remove ( node ) ; \n \n \t2 Set < Node > nodesWithSameType = typeToNodesMap . get ( node . getType ( ) ) ; \n \n \t2 if ( nodesWithSameType != null ) \n \n \t3 nodesWithSameType . remove ( node ) ; \n \n <ect>
\t1 oclC . close ( ) \n \n \t1 mxC } } \n \n @ inline \n \n private def jvmRWRW ( a : Matrix , b : Matrix , r : Option [ Matrix ] = None ) : Matrix = { \n \n <ect>
\t2 if ( vlanId == null ) { \n \n \t3 s_logger . info ( <string_literal> + ethPortProfileName + <string_literal> ) ; \n \n \t3 if ( netconfClient != null ) { \n \n \t4 netconfClient . disconnect ( ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public Collection < MetadataResolver > resolve ( final SamlRegisteredService service ) { \n \n \t2 try { \n \n \t3 final String metadataLocation = service . getMetadataLocation ( ) ; \n \n <ect>
\t3 fos . write ( <string_literal> . getBytes ( ) ) ; \n \n \t3 fos . write ( <string_literal> . getBytes ( ) ) ; } \n \n \t2 fos . write ( <string_literal> . getBytes ( ) ) ; \n \n \t2 fos . close ( ) ; \n \n <ect>
\t2 return getPropertyAsString ( TIMEOUT ) ; } \n \n \t1 @ Override \n \n \t1 public void sampleStarting ( Sampler sampler ) { \n \n <ect>
\t3 if ( DateUtil . currentGMTTime ( ) . getTime ( ) - vm . getProxyAssignTime ( ) . getTime ( ) < _proxySessionTimeoutValue ) { \n \n \t4 return true ; } \n \n \t3 return false ; \n \n \t2 } else { \n \n <ect>
\t5 int autoRefreshTimeInSecs = knxProvider . getAutoRefreshTime ( datapoint ) ; \n \n \t5 if ( autoRefreshTimeInSecs > 0 ) { \n \n \t6 if ( ! mKNXBusReaderScheduler . scheduleRead ( datapoint , \n \n \t8 knxProvider . getAutoRefreshTime ( datapoint ) ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 fs . mkdirs ( new Path ( destPath ) ) ; \n \n \t2 fs . create ( SortedLogState . getFailedMarkerPath ( destPath ) ) . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t2 private void execute ( GridLogger log ) { \n \n \t3 try { \n \n <ect>
\t2 tserver . getLocation ( ) , context ) ; \n \n \t1 try { \n \n \t1 return client . getTabletStats ( Tracer . traceInfo ( ) , context . rpcCreds ( ) , tableId . canonicalID ( ) ) ; \n \n \t1 } catch ( TTransportException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 logger . error ( <string_literal> , e . getMessage ( ) ) ; } } \n \n \t1 @ Override \n \n \t1 public Iterable < HistoricItem > query ( FilterCriteria filter ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void removeBindingProvider ( BindingProvider provider ) { \n \n \t2 super . removeBindingProvider ( provider ) ; \n \n \t2 <comment> \n \n <ect>
\t5 LOG . info ( <string_literal> ) ; \n \n \t5 tryExecute ( see , <string_literal> ) ; \n \n \t5 LOG . info ( <string_literal> ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t3 throw new TableDeletedException ( tableIdStr ) ; \n \n \t3 if ( Tables . getTableState ( instance , tableId ) == TableState . OFFLINE ) \n \n \t3 throw new TableOfflineException ( instance , tableIdStr ) ; \n \n \t3 binnedRanges . clear ( ) ; \n \n <ect>
\t5 if not isMyVmDirLink ( vmDir ) : \n \n \t6 logger . debug ( OvmHost . getAllVms , <string_literal> %vmDir ) \n \n \t6 continue \n \n \t5 if vms . has_key ( dir ) : \n \n <ect>
\t3 initContent ( source ) ; \n \n \t2 } finally { \n \n \t3 getSourceContainer ( ) . close ( ) ; } \n \n \t2 String [ ] args = getArgs ( ) ; \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t3 return CertificateHelper . buildAndSaveKeystore ( certs , storePassword ) ; \n \n \t2 } catch ( KeyStoreException e ) { \n \n \t3 s_logger . warn ( <string_literal> + name + <string_literal> ) ; \n \n \t2 } catch ( CertificateException e ) { \n \n <ect>
\t3 s_logger . error ( msg ) ; \n \n \t3 throw new ConfigurationException ( msg ) ; } \n \n \t2 String enabled = _configDao . getValue ( Config . ElasticLoadBalancerEnabled . key ( ) ) ; \n \n \t2 _enabled = ( enabled == null ) ? false : Boolean . parseBoolean ( enabled ) ; \n \n <ect>
\t2 eventEntity . setError ( event . getError ( ) ) ; \n \n \t2 try { \n \n \t3 eventEntity . setDetailsJson ( mapper . writeValueAsString ( event . getDetails ( ) ) ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t2 final PrintWriter pwriter = new PrintWriter ( \n \n \t4 new BufferedWriter ( new SendBufferWriter ( ) ) ) ; \n \n \t2 <comment> \n \n \t2 if ( ! FourLetterCommands . isEnabled ( cmd ) ) { \n \n <ect>
<comment> \n \n \t1 public void runOnBrowserCreatedPlugins ( EmbeddedBrowser newBrowser ) { \n \n <ect>
\t9 <comment> \n \n \t9 <comment> \n \n \t9 _context . statManager ( ) . addRateData ( <string_literal> , 1 , \n \n <number_literal> DatabaseStoreMessage . MESSAGE_TYPE ) ; \n \n <ect>
\t2 ! stdOutAndErr . stdErr . contains ( <string_literal> ) } \n \n \t1 @ TargetGradleVersion ( <string_literal> ) \n \n \t1 def <string_literal> ( ) { \n \n \t2 file ( <string_literal> ) < < <string_literal> <string_literal> <ect>
\t2 } catch ( NetworkRuleConflictException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . NETWORK_RULE_CONFLICT_ERROR , e . getMessage ( ) ) ; \n \n \t2 } catch ( InsufficientAddressCapacityException e ) { \n \n <ect>
\t6 LOG . debug ( <string_literal> , e . getMessage ( ) ) ; } } \n \n \t4 serializer . shutdownNow ( ) ; \n \n \t4 try { \n \n \t5 if ( ! serializer . awaitTermination ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n <ect>
\t2 if ( returnCode == ReturnCode . UNKNOWN ) { \n \n \t3 LOG . warn ( <string_literal> ) ; \n \n \t3 return <string_literal> ; } \n \n \t2 if ( pigContext == null ) { \n \n <ect>
\t3 return ; } \n \n \t2 <comment> \n \n \t2 final RouteInfo route = clientContext . getHttpRoute ( ) ; \n \n \t2 if ( route == null ) { \n \n <ect>
\t1 public static final IMessageHandler < MessageMarker , IMessage > HANDLER = ( message , ctx ) - > { \n \n \t2 World world = BCLibProxy . getProxy ( ) . getClientWorld ( ) ; \n \n \t2 if ( world == null ) { \n \n \t3 if ( DEBUG ) { \n \n <ect>
\t1 private void checkArgGraph ( Graph g ) { \n \n \t2 if ( JenaParameters . enableOWLRuleOverOWLRuleWarnings ) { \n \n \t3 if ( g instanceof InfGraph ) { \n \n \t4 if ( ( ( InfGraph ) g ) . getReasoner ( ) instanceof OWLFBRuleReasoner ) { \n \n <ect>
\t3 public boolean isSatisified ( ) throws Exception { \n \n \t4 LOG . info ( <string_literal> + broker . getBrokerName ( ) + <string_literal> + regionBroker . getPeerBrokerInfos ( ) . length ) ; \n \n \t4 return max == regionBroker . getPeerBrokerInfos ( ) . length ; } \n \n \t2 } , <number_literal> * <number_literal> ) ; \n \n <ect>
\t2 clusterState = ClusterState . builder ( clusterState ) \n \n \t4 . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . add ( newNode ( <string_literal> ) ) ) . build ( ) ; \n \n \t2 newState = strategy . reroute ( clusterState , <string_literal> ) ; \n \n \t2 assertThat ( newState , equalTo ( clusterState ) ) ; \n \n <ect>
\t2 if ( consoleCommunication != null ) { \n \n \t3 try { \n \n \t4 consoleCommunication . sendCurrentState ( ) ; \n \n \t3 } catch ( CommunicationException e ) { \n \n <ect>
\t3 StringWriter writer = new StringWriter ( ) ; \n \n \t3 toXML ( new DefaultWriterOutputTarget ( writer ) , bWithAttachmentContent , bWithVersions , true , context ) ; \n \n \t3 return writer . toString ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 return false ; } \n \n \t2 final Set < Map . Entry < String , Object > > names = attributes . entrySet ( ) \n \n \t4 . stream ( ) \n \n \t4 . filter ( e - > { \n \n <ect>
\t3 container . buf = new byte [ inPayloadLength ] ; \n \n \t2 if ( data . get ( inSeq ) != null ) \n \n \t2 { \n \n <ect>
\t4 return ; } \n \n \t3 <comment> \n \n \t3 byte [ ] rehash = md . digest ( hisBuf ) ; \n \n \t3 if ( ! java . util . Arrays . equals ( rehash , hisHash ) ) { \n \n <ect>
\t1 protected void doTest ( ) throws Exception { \n \n \t2 connection . start ( ) ; \n \n \t2 ActiveMQConnection amqConnection = ( ActiveMQConnection ) connection ; \n \n \t2 rollbackCount = amqConnection . getRedeliveryPolicy ( ) . getMaximumRedeliveries ( ) + 1 ; \n \n <ect>
\t2 } catch ( Throwable t ) { \n \n \t3 logger . error ( <string_literal> , t ) ; } } \n \n \t1 private void remove ( final String name ) { \n \n \t2 try { \n \n <ect>
\t2 cache . remove ( location ) ; \n \n \t2 <comment> \n \n \t2 if ( SystemTDB . DiskLocationMultiJvmUsagePrevention && ! location . isMem ( ) ) { \n \n \t3 if ( ! dbConn . lock . isLockedHere ( ) ) \n \n <ect>
\t1 public static void testJar ( String id ) { \n \n \t2 try { \n \n \t3 PathUtils . local_mkdirs ( pidDir ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 continue ; } \n \n \t4 boolean result = put ( physicalConnection ) ; \n \n \t4 if ( ! result ) { \n \n \t5 JdbcUtils . close ( physicalConnection . getPhysicalConnection ( ) ) ; \n \n <ect>
\t5 _log . info ( getPrefix ( ) + <string_literal> + i ) ; \n \n \t4 return true ; \n \n \t3 } catch ( I2PSessionException ise ) { \n \n \t4 if ( _log . shouldLog ( Log . ERROR ) ) \n \n <ect>
\t2 try { \n \n \t3 Map < Long , Condition > lockMap = lockDigestedKey ( digestedKey , true ) ; \n \n \t3 if ( lockMap == null ) { \n \n \t4 if ( logDEBUG ) \n \n <ect>
\t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n \t4 _log . info ( <string_literal> + state ) ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t1 int len = 0 ; \n \n \t1 try { \n \n \t1 return split . getLength ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 if ( sock != null ) { \n \n \t4 try { \n \n \t5 sock . close ( ) ; } \n \n \t4 catch ( IOException ioe ) { \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public CSSParseExceptionCallback ( ) { \n \n \t2 this . baseUrl = null ; \n \n <ect>
import params \n \n if params . has_ranger_admin : \n \n \t1 from resource_management . libraries . functions . setup_ranger_plugin_xml import setup_ranger_plugin \n \n \t1 if params . retryAble : \n \n <ect>
\t3 s_logger . info ( <string_literal> + ethPortProfileName \n \n \t5 + <string_literal> ) ; \n \n \t3 if ( netconfClient != null ) { \n \n \t4 netconfClient . disconnect ( ) ; \n \n <ect>
\t2 CreateMode . PERSISTENT , true ) ; \n \n \t1 } else { \n \n \t1 AmbariSolrState stateOnSecure = getStateFromJson ( client , stateFile ) ; \n \n \t1 if ( stateToUpdate . equals ( stateOnSecure ) ) { \n \n <ect>
\t4 } else if ( set . size ( ) > 1 ) { \n \n \t5 LOG . debug ( <string_literal> , set . size ( ) ) ; } } \n \n \t3 if ( objectMapper == null ) { \n \n \t4 objectMapper = new ObjectMapper ( ) ; \n \n <ect>
\t3 if ( ! isCoordinator ( ) ) { \n \n \t4 try { \n \n \t5 Thread . sleep ( <number_literal> ) ; \n \n \t4 } catch ( InterruptedException ie ) { \n \n <ect>
\t2 checkState ( directory . exists ( ) && directory . isDirectory ( ) , \n \n \t4 <string_literal> , directory ) ; \n \n \t2 built = true ; \n \n \t2 ReadOnlyRevisions revisions = new ReadOnlyRevisions ( persistence ) ; \n \n <ect>
\t3 Integer networkRate = getNetworkRate ( config . getId ( ) , vm . getId ( ) ) ; \n \n \t3 vm . addNic ( new NicProfile ( vo , network . first ( ) , vo . getBroadcastUri ( ) , vo . getIsolationUri ( ) , networkRate , isSecurityGroupSupportedInNetwork ( network . first ( ) ) , getNetworkTag ( vm . getHypervisorType ( ) , \n \n \t5 network . first ( ) ) ) ) ; } \n \n \t2 if ( nics . size ( ) != networks . size ( ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void invalidateIAMCache ( ) { \n \n \t2 <comment> \n \n \t2 if ( _iamCache != null ) { \n \n <ect>
\t3 <comment> \n \n \t3 MessagingService . instance ( ) . sendOneWay ( new SyncComplete ( desc , r1 . endpoint , r2 . endpoint , true ) . createMessage ( ) , FBUtilities . getLocalAddress ( ) ) ; \n \n \t3 return ; } \n \n \t2 <comment> \n \n <ect>
\t3 return ; } \n \n \t2 Set < SubSystemType > subsystems = hierarchy . getSubSystems ( ) ; \n \n \t2 for ( SubSystemType type : subsystems ) { \n \n \t3 if ( this . busy ( type ) != null ) { \n \n <ect>
\t3 attemptItemAdvanceFinal ( ROLE . STEP3 , false ) ; \n \n \t3 contextReload ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 e . printStackTrace ( ) ; \n \n <ect>
\t2 final String nextMasterEligibleNodeName = internalCluster ( ) . startNode ( Settings . builder ( ) . put ( Node . NODE_DATA_SETTING . getKey ( ) , false ) . put ( Node . NODE_MASTER_SETTING . getKey ( ) , true ) ) ; \n \n \t2 assertThat ( internalCluster ( ) . nonMasterClient ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) . nodes ( ) . getMasterNode ( ) . getName ( ) , equalTo ( nextMasterEligibleNodeName ) ) ; \n \n \t2 assertThat ( internalCluster ( ) . masterClient ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) . nodes ( ) . getMasterNode ( ) . getName ( ) , equalTo ( nextMasterEligibleNodeName ) ) ; } \n \n \t1 public void testElectOnlyBetweenMasterNodes ( ) throws IOException { \n \n <ect>
\t2 out . write ( profile . getData ( ) ) ; } \n \n \t1 out . write ( ' \\ n' ) ; \n \n \t1 if ( profileCounter % profilesPerFile == 0 ) { \n \n \t2 incrementFile ( ) ; \n \n <ect>
\t2 if ( f10 . exists ( ) ) { \n \n \t3 assertCacheIfPresent ( <number_literal> , cache , f10 ) ; } \n \n \t2 if ( f4 . exists ( ) ) { \n \n \t3 assertCacheIfPresent ( <number_literal> , cache , f4 ) ; } \n \n <ect>
<number_literal> '' ) . replace ( \n \n \t2 ' \\ r' , '' ) \n \n \t1 return result \n \n \t1 except : \n \n <ect>
\t2 ConnectionWrapper wrapper = wrapperForConnection ( conn ) ; \n \n \t2 if ( wrapper != null ) { \n \n \t3 wrapper . unlock ( ) ; \n \n \t2 } else { \n \n <ect>
\t2 this . mode = mode ; \n \n \t2 newURI = uri ; \n \n \t2 expectedSize = - 1 ; \n \n \t2 if ( mode == FetchExceptionMode . INTERNAL_ERROR ) \n \n <ect>
\t3 f . append ( <string_literal> ) ; \n \n \t3 indent -- ; } \n \n \t2 BCLog . logger . info ( f + <string_literal> + mod + <string_literal> ) ; \n \n \t2 BCLog . logger . info ( f + <string_literal> + subMod + <string_literal> ) ; \n \n <ect>
\t3 result . ouch2 = ( AccumuloSecurityException ) e ; \n \n \t3 result . setOuch2IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t5 _sspUuidDao . removeUuid ( tenantPortUuid ) ; \n \n \t5 processed = true ; \n \n \t5 break ; } } \n \n \t3 if ( ! processed ) { \n \n <ect>
@ Override \n \n public < T > T retrieve ( String key , Callable < T > fn ) throws HiveException { \n \n \t1 try { \n \n <ect>
\t4 } else { \n \n \t5 ipId = existingLbs . get ( 0 ) . getSourceIpAddressId ( ) ; \n \n \t5 s_logger . debug ( <string_literal> + ipId ) ; } \n \n \t3 } else { \n \n <ect>
\t2 try { \n \n \t3 final String username = authentication . getPrincipal ( ) . toString ( ) ; \n \n \t3 final Object credentials = authentication . getCredentials ( ) ; \n \n \t3 final String password = credentials == null ? null : credentials . toString ( ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t3 s_logger . warn ( <string_literal> ) ; \n \n \t3 throw new InvalidParameterValueException ( <string_literal> + ipAddress + <string_literal> + aggrName + <string_literal> + volName + <string_literal> ) ; } \n \n \t2 List < LunVO > lunsOnVol = _lunDao . listLunsByVolId ( volume . getId ( ) ) ; \n \n \t2 if ( lunsOnVol != null && lunsOnVol . size ( ) > 0 ) { \n \n <ect>
\t1 debug ( <string_literal> ) } \n \n internal fun exitCodeFromProcessExitCode ( log : KotlinLogger , code : Int ) : ExitCode { \n \n \t1 val exitCode = ExitCode . values ( ) . find { it . code == code } \n \n \t1 if ( exitCode != null ) return exitCode \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 GetSnapshotsResponse getSnapshotsResponse = client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <string_literal> ) . get ( ) ; \n \n \t2 assertThat ( getSnapshotsResponse . getSnapshots ( ) , notNullValue ( ) ) ; \n \n \t2 assertThat ( getSnapshotsResponse . getSnapshots ( ) . size ( ) , equalTo ( 1 ) ) ; \n \n <ect>
\t4 <comment> \n \n \t4 if ( shutdownHook != null ) { \n \n \t5 Runtime . getRuntime ( ) . removeShutdownHook ( shutdownHook ) ; \n \n \t4 } else { \n \n <ect>
\t3 try { \n \n \t4 cur . connectionPoolOpened ( event ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 <comment> \n \n \t1 log . info ( <string_literal> , table2 ) ; \n \n \t1 c . tableOperations ( ) . offline ( table2 , true ) ; \n \n \t1 log . info ( <string_literal> , table2 ) ; \n \n <ect>
\t4 CmsResourceFilter . DEFAULT ) ; \n \n \t3 <comment> \n \n \t3 readDependencies ( cms , folderContent ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t2 } else { \n \n \t3 try { \n \n \t4 myRepository = ( SWORDServer ) Class . forName ( className ) \n \n <number_literal> . newInstance ( ) ; \n \n <ect>
\t3 KeyCrypterScrypt scrypt = new KeyCrypterScrypt ( SCRYPT_PARAMETERS ) ; \n \n \t3 long start = System . currentTimeMillis ( ) ; \n \n \t3 scrypt . deriveKey ( <string_literal> ) ; \n \n \t3 long msec = System . currentTimeMillis ( ) - start ; \n \n <ect>
\t1 protected void testConnectionOnStartup ( ) throws FailedToCreateProducerException { \n \n \t2 try { \n \n \t3 CamelJmsTemplate template = ( CamelJmsTemplate ) getInOnlyTemplate ( ) ; \n \n <ect>
\t3 } catch ( SecurityException e ) { \n \n \t4 s_logger . error ( <string_literal> , e ) ; \n \n \t4 System . exit ( ExitStatus . Error . value ( ) ) ; \n \n \t3 } catch ( NoSuchMethodException e ) { \n \n <ect>
<number_literal> portNumber = nodePort ; \n \n <number_literal> break ; } } } } } } \n \n \t4 } catch ( Exception e ) { \n \n \t5 <comment> \n \n <ect>
<number_literal> selectNetworkType . setLong ( 1 , accountId ) ; \n \n <number_literal> selectNetworkType . setLong ( <number_literal> , dataCenterId ) ; \n \n <number_literal> try ( ResultSet userVmSet = selectNetworkType . executeQuery ( ) ; ) { \n \n <number_literal> if ( ! userVmSet . next ( ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 int dataVolumeGb = getTaskConfiguration ( ) . getInteger ( NetworkStackThroughputITCase . DATA_VOLUME_GB_CONFIG_KEY , 1 ) ; \n \n \t4 long dataMbPerSubtask = ( dataVolumeGb * <number_literal> ) / getCurrentNumberOfSubtasks ( ) ; \n \n \t4 long numRecordsToEmit = ( dataMbPerSubtask * <number_literal> * <number_literal> ) / SpeedTestRecord . RECORD_SIZE ; \n \n <ect>
\t1 isOpen = false ; \n \n \t1 if ( hiveSparkClient != null ) { \n \n \t1 try { \n \n \t2 hiveSparkClient . close ( ) ; \n \n <ect>
\t3 this . log = log ; } \n \n \t2 @ Override \n \n \t2 public void startReceivingStoreFiles ( ) \n \n \t2 { \n \n <ect>
\t4 LdapUser ldapUser = null ; \n \n \t4 try { \n \n \t5 ldapUser = _ldapManager . getUser ( admin , type , getLdapDomain ( ) , domainId ) ; \n \n \t4 } catch ( NoLdapUserMatchingQueryException e ) { \n \n <ect>
\t3 result . ouch3 = ( TableNotFoundException ) e ; \n \n \t3 result . setOuch3IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t1 try { \n \n \t1 if ( cxnResetExecutor . awaitTermination ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n \t2 cxnResetExecutor . shutdownNow ( ) ; } \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t6 try { \n \n \t7 channel . sendResponse ( e ) ; \n \n \t6 } catch ( Exception channelException ) { \n \n \t7 channelException . addSuppressed ( e ) ; \n \n <ect>
\t2 } catch ( FileNotFoundException ex ) { \n \n \t3 log . warn ( <string_literal> , task . getName ( ) ) ; } \n \n \t2 if ( waited > <number_literal> ) { \n \n \t3 log . warn ( <string_literal> , task . getName ( ) , pid , waited ) ; } \n \n <ect>
\t3 names [ i ] = <string_literal> + i ; \n \n \t3 ids [ i ] = i ; \n \n \t3 nodes [ i ] = tx . addVertex ( <string_literal> , names [ i ] , <string_literal> , ids [ i ] ) ; \n \n \t3 if ( ( i + 1 ) % <number_literal> == 0 ) log . debug ( <string_literal> ) ; } \n \n <ect>
\t4 if ( descriptor . propertyType . genericSuperclass == = SearchField : : class . java && PropertyUtils . getProperty ( criteria , propName ) != null ) { \n \n \t5 isValid = true \n \n \t5 break } } \n \n \t2 } catch ( e : Exception ) { \n \n <ect>
\t2 byte [ ] data = new byte [ len ] ; \n \n \t2 System . arraycopy ( buffer , 0 , data , 0 , len ) ; \n \n \t2 fis . close ( ) ; \n \n \t2 for ( byte b : data ) { \n \n <ect>
\t6 snapshot . setBuildNumber ( Integer . parseInt ( matcher . group ( <number_literal> ) ) ) ; \n \n \t6 artifact . addMetadata ( new SnapshotArtifactRepositoryMetadata ( artifact , snapshot ) ) ; } \n \n \t5 catch ( NumberFormatException e ) \n \n \t5 { \n \n <ect>
\t4 i . set ( available . toBuilder ( ) . setRanges ( Protos . Value . Ranges . newBuilder ( ) . addAllRange ( remainingRanges ) ) . build ( ) ) ; } \n \n \t3 else { \n \n \t4 i . remove ( ) ; } } \n \n <ect>
\t2 { \n \n \t3 e . printStackTrace ( ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t6 assertEquals ( <string_literal> , 0L , serverStats [ i ] . getNumConnections ( ) ) ; \n \n \t6 success = true ; \n \n \t5 } catch ( Throwable t ) { \n \n \t6 if ( numRetries < <number_literal> ) { \n \n <ect>
\t3 this . cipher = cipher ; } \n \n \t2 public void accept ( Message msg , MessageBatch batch ) { \n \n \t3 EncryptHeader hdr ; \n \n \t3 if ( ( hdr = msg . getHeader ( id ) ) == null ) { \n \n <ect>
\t3 totalBlocks += num ; \n \n \t3 wasFinalized = blockSetFinalized ; } \n \n \t2 if ( wasFinalized ) { \n \n \t3 if ( LogLevel . MINOR . matchesThreshold ( Logger . globalGetThresholdNew ( ) ) ) \n \n <ect>
\t3 if not self . transport . is_connected ( ) : \n \n \t4 time . sleep ( self . send_sleep ) \n \n \t4 continue \n \n \t3 if self . send_sleep != 0 and now > self . next_outbound_heartbeat : \n \n <ect>
\t2 try { \n \n \t3 camelContext . createProducerTemplate ( ) . sendBody ( destination . toString ( ) , message ) ; \n \n \t2 } catch ( CamelExecutionException e ) { \n \n \t3 <comment> \n \n <ect>
\t2 } else { \n \n \t3 LOG . warn ( <string_literal> + prevSnapId + <string_literal> + prevSnap . getStatus ( ) \n \n \t4 + <string_literal> + snapshotId ) ; } \n \n \t2 } catch ( TransactionException | NoSuchElementException e ) { \n \n <ect>
\t2 RandomAccessFile access = new RandomAccessFile ( file , <string_literal> ) ; \n \n \t2 try { \n \n \t3 Index index = SegmentTarReader . loadAndValidateIndex ( access , name ) ; \n \n \t3 if ( index == null ) { \n \n <ect>
\t4 logger . debug ( <string_literal> + delimiters ) ; \n \n \t4 textProcessor . setCustomSentenceDelimiters ( delimiters ) ; } \n \n \t3 String configTranslateUrl = ( String ) properties . get ( TRANSLATE_URL_PROPERTY ) ; \n \n \t3 if ( ! StringUtils . isBlank ( configTranslateUrl ) ) { \n \n <ect>
\t8 if ( exchange . getIn ( ) . getHeader ( <string_literal> , Boolean . class ) ) { \n \n \t9 log . info ( <string_literal> ) ; \n \n \t9 exchange . getOut ( ) . setFault ( true ) ; \n \n \t8 } else { \n \n <ect>
\t3 getRpcService ( ) . execute ( ( ) - > { \n \n \t4 try { \n \n \t5 checkpointCoordinator . receiveAcknowledgeMessage ( ackMessage ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t6 break ; } } \n \n \t3 } catch ( Exception e ) { \n \n \t4 throw new RuntimeException ( <string_literal> + e ) ; } \n \n \t3 if ( manifestIS == null ) { \n \n <ect>
\t1 r = new BufferedReader ( new InputStreamReader ( new FileInputStream ( f ) ) ) ; \n \n \t1 for ( String expectedLine : expectedResults ) { \n \n \t2 assertEquals ( expectedLine , r . readLine ( ) ) ; } \n \n \t1 } catch ( IOException ioe ) { \n \n <ect>
\t2 float usage = runningTime / 1000f / 60f / 60f ; \n \n \t2 DecimalFormat dFormat = new DecimalFormat ( <string_literal> ) ; \n \n \t2 String usageDisplay = dFormat . format ( usage ) ; \n \n <ect>
\t3 result . ouch2 = ( AccumuloSecurityException ) e ; \n \n \t3 result . setOuch2IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t2 Log . info ( <string_literal> , ourExistingGroup . publicKeyName ( ) , aSeparateGroupCopy . publicKeyName ( ) ) ; \n \n \t2 System . out . println ( <string_literal> + ourExistingGroup . publicKeyVersion ( ) ) ; \n \n \t2 System . out . println ( <string_literal> + aSeparateGroupCopy . publicKeyVersion ( ) ) ; \n \n \t2 Thread . sleep ( <number_literal> ) ; \n \n <ect>
<comment> \n \n \t3 int newSourceIndex = i ; \n \n \t3 SemanticModel newSource = semanticModels . get ( newSourceIndex ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n <ect>
<comment> \n \n \t1 private void appendToStore ( String key , String value ) { \n \n <ect>
\t3 <string_literal> + getClass ( ) . getSimpleName ( ) + <string_literal> ) ; \n \n \t2 try { \n \n \t3 initFileSystem ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 logger . debug ( <string_literal> , LoggerConstants . TFINIT ) ; \n \n \t4 mDevice = factory . createMBrickServo ( ) ; \n \n \t4 mDevice . setDeviceIdentifier ( BrickServo . DEVICE_IDENTIFIER ) ; \n \n \t3 } else if ( deviceIdentifier == BrickletDualRelay . DEVICE_IDENTIFIER ) { \n \n <ect>
\t3 IDBlock block ; \n \n \t3 try { \n \n \t4 block = authority . getIDBlock ( partitionIndex , partitionIndex , GET_ID_BLOCK_TIMEOUT ) ; \n \n \t3 } catch ( BackendException e ) { \n \n <ect>
\t5 arr [ 1 ] = third ; \n \n \t5 third . sendMessageToEnforcedRoute ( <string_literal> , 0 ) ; \n \n \t5 waitForNonActiveRoutesLatch . countDown ( ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 try ( PreparedStatement pstmt = conn . prepareStatement ( <string_literal> + columnName + <string_literal> + tableName ) ; ) { \n \n \t3 pstmt . executeQuery ( ) ; \n \n \t3 columnExists = true ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t4 newAddressMatchers . add ( new Inet6AddressMatcher ( allowedHost ) ) ; \n \n \t3 } else if ( allowedHost . equals ( <string_literal> ) ) { \n \n \t4 newAddressMatchers . add ( new EverythingMatcher ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t3 cron . stop ( ) ; \n \n \t3 addActionCron ( wfAction . getType ( ) , cron ) ; \n \n \t3 if ( wfAction . isExecutionComplete ( ) ) { \n \n \t4 if ( ! context . isExecuted ( ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 bis = new BufferedInputStream ( is ) ; \n \n \t3 try { \n \n \t4 isr = new InputStreamReader ( bis , <string_literal> ) ; \n \n \t3 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t1 private static final Logger logger = LoggerFactory . getLogger ( SystemProperties . class ) ; \n \n \t1 static int getInt ( String key , int defaultValue ) { \n \n \t2 String stringValue = System . getProperty ( key ) ; \n \n \t2 if ( stringValue == null ) { \n \n <ect>
\t8 <comment> \n \n \t8 final Date cutTime = DateUtil . currentGMTTime ( ) ; \n \n \t8 final HostTransferMapVO transferMap = _hostTransferDao . findActiveHostTransferMapByHostId ( hostId , new Date ( cutTime . getTime ( ) - rebalanceTimeOut ) ) ; \n \n \t8 if ( transferMap == null ) { \n \n <ect>
\t2 Long numFound = eventHistorySolrDao . process ( solrQuery ) . getResults ( ) . getNumFound ( ) ; \n \n \t2 if ( numFound > 0 ) { \n \n \t2 return true ; } \n \n \t1 } catch ( SolrException e ) { \n \n <ect>
\t2 if ( segmentCount < = 0 ) { \n \n \t3 throw new AssertionError ( <string_literal> ) ; } \n \n \t2 if ( splitfileType == SplitfileAlgorithm . NONREDUNDANT ) { \n \n \t3 if ( splitfileCheckBlocks > 0 ) { \n \n <ect>
\t2 conn = new Connection ( this ) ; \n \n \t2 conn . start ( ) ; } \n \n \t1 @ Override \n \n \t1 public void _on_data ( String name , JsonObject obj ) { \n \n <ect>
\t2 configure ( <string_literal> ) ; \n \n \t2 Logger logger = Logger . getLogger ( RewriteAppenderTest . class ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 MDC . put ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
<comment> \n \n protected void notifyChosen ( RelNode rel ) { \n \n <ect>
\t3 Vector2f max = new Vector2f ( ( float ) freeform . getMax ( ) . x / size . x , ( float ) freeform . getMax ( ) . y / size . y ) ; \n \n \t3 out . put ( new Name ( freeform . getName ( ) ) , new SubtextureData ( texture , Rect2f . createFromMinAndMax ( min , max ) ) ) ; } } \n \n \t1 private void process ( GridDefinition grid , Texture texture , Vector2i size , Map < Name , SubtextureData > out ) { \n \n \t2 if ( grid . getTileSize ( ) == null ) { \n \n <ect>
\t2 while ( ! this . threadTreminate ) { \n \n \t3 try { \n \n \t4 this . callback . execute ( ) ; \n \n \t3 } catch ( RuntimeException ex ) { \n \n <ect>
\t3 if ( game . getCombat ( ) . getGroups ( ) . get ( i ) . canBlock ( blocker , game ) ) { \n \n \t4 Game sim = game . copy ( ) ; \n \n \t4 sim . getCombat ( ) . getGroups ( ) . get ( i ) . addBlocker ( blocker . getId ( ) , playerId , sim ) ; \n \n \t4 if ( engagements . put ( sim . getCombat ( ) . getValue ( ) . hashCode ( ) , sim . getCombat ( ) ) != null ) { \n \n <ect>
\t1 private void resetTellstick ( ) { \n \n \t2 logger . warn ( <string_literal> + restartTimeout / <number_literal> + <string_literal> ) ; \n \n \t2 try { \n \n \t3 deRegisterListeners ( ) ; \n \n <ect>
\t5 isNewUpgrade = true ; } \n \n \t3 } else if ( upgradeConfig . isCompleted ( ) ) { \n \n \t4 <comment> \n \n \t4 if ( uploadedLocation == null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 hostDead \t1 = new HashMap < String , Date > ( ) ; \n \n \t3 maxCreate = ( poolMultiplier > minConn ) ? minConn : minConn / poolMultiplier ; \t2 <comment> \n \n \t4 log . debug ( <string_literal> ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void init ( FilterConfig filterConfig ) throws ServletException { \n \n <ect>
\t4 scpFrom . getRemoteFile ( remoteFile , dataPath ) ; \n \n \t4 LOG . info ( <string_literal> + remoteFile ) ; \n \n \t3 } catch ( Exception eex ) { \n \n \t4 LOG . error ( eex ) ; \n \n <ect>
\t2 InetSocketAddress addr = null ; \n \n \t2 try { \n \n \t3 sch = SocketChannel . open ( ) ; \n \n \t3 sch . configureBlocking ( true ) ; \n \n <ect>
\t1 static SimpleFieldSet load ( File filename , File tempFilename ) throws IOException { \n \n \t2 boolean filenameExists = filename . exists ( ) ; \n \n \t2 boolean tempFilenameExists = tempFilename . exists ( ) ; \n \n \t2 if ( filenameExists && ! filename . canWrite ( ) ) { \n \n <ect>
\t4 int availWindows = ( int ) Math . ceil ( ( double ) lines / ( double ) m_windowSize ) ; \n \n \t4 <comment> \n \n \t4 m_windowPos = availWindows - 1 ; \n \n \t3 } catch ( IOException ioex ) { \n \n <ect>
\t2 GridTestUtils . runMultiThreaded ( new Callable < Void > ( ) { \n \n \t3 @ Override public Void call ( ) throws Exception { \n \n \t4 for ( int i = 0 ; i < ITERATIONS_PER_THREAD && ! failed ; i ++ ) { \n \n \t5 if ( i % <number_literal> == 0 ) \n \n <ect>
\t1 if ( ! executorService . awaitTermination ( <number_literal> , TimeUnit . MILLISECONDS ) ) { \n \n \t2 LOGGER . debug ( <string_literal> ) ; \n \n \t2 executorService . shutdownNow ( ) ; \n \n \t2 while ( ! executorService . awaitTermination ( <number_literal> , TimeUnit . MILLISECONDS ) ) { \n \n <ect>
\t2 val references = referenceData . map { it to findReference ( it , file , blockStart ) } \n \n \t2 val bindingContext = try { \n \n \t3 file . getResolutionFacade ( ) . analyze ( references . mapNotNull { it . second ? . element } , BodyResolveMode . PARTIAL ) } \n \n \t2 catch ( e : Throwable ) { \n \n <ect>
\t2 } catch ( Exception ex ) { \n \n \t3 try { \n \n \t4 volumeInfo . getDataStore ( ) . getDriver ( ) . deleteAsync ( volumeInfo . getDataStore ( ) , volumeInfo , null ) ; } \n \n \t3 catch ( Exception exc ) { \n \n <ect>
\t4 _log . info ( <string_literal> + howMany + <string_literal> + matches . size ( ) + <string_literal> ) ; \n \n \t3 selectNotFailingPeers ( howMany , exclude , matches , mask ) ; \n \n \t2 } else { \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 LOGGER . log ( Level . FINE , <string_literal> , e ) ; } } \n \n \t2 catalog . validate ( dataStore , true ) . throwIfInvalid ( ) ; \n \n \t2 catalog . add ( dataStore ) ; \n \n \t2 String storeName = dataStore . getName ( ) ; \n \n <ect>
\t2 RoutingTable routingTable = RoutingTable . builder ( ) \n \n \t4 . addAsNew ( metaData . index ( <string_literal> ) ) \n \n \t4 . build ( ) ; \n \n \t2 ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . CLUSTER_NAME_SETTING . getDefault ( Settings . EMPTY ) ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; \n \n <ect>
\t1 if ( serviceDiscovery && ! activePassiveHA ) { \n \n \t1 try { \n \n \t2 removeServerInstanceFromZooKeeper ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 <comment> \n \n \t4 url = new URL ( StringUtils . substringBefore ( externalForm , <string_literal> ) ) ; \n \n \t4 list . add ( url ) ; \n \n \t3 } else { \n \n <ect>
\t2 long start = System . currentTimeMillis ( ) ; \n \n \t2 try { \n \n \t3 <comment> \n \n \t3 worker1 . run ( ) ; \n \n <ect>
\t6 <comment> \n \n \t6 <comment> \n \n \t6 LOG . info ( <string_literal> + result . getJMSType ( ) + <string_literal> + counterReceived ) ; \n \n \t5 } else { \n \n <ect>
\t4 } else if ( inp . returnStatus == POStatus . STATUS_EOP ) { \n \n \t5 if ( parentPlan . endOfAllInput ) { \n \n \t6 <comment> \n \n \t6 inputsExhausted = true ; \n \n <ect>
\t4 sendpairkey ( ) ; \n \n \t3 } else if ( pairkey . length ( ) == 0 ) { \n \n \t4 logger . error ( <string_literal> ) ; } } } \n \n \t1 public String sendpairkey ( ) { \n \n <ect>
\t1 stmt . setFetchSize ( getFetchSize ( ) ) ; \n \n \t1 for ( int i = 0 ; i < itemID2s . length ; i ++ ) { \n \n \t2 result [ i ] = doItemSimilarity ( stmt , itemID1 , itemID2s [ i ] ) ; } \n \n \t1 } catch ( SQLException sqle ) { \n \n <ect>
\t2 PropertyIterator iterator = property . iterator ( ) ; \n \n \t2 while ( iterator . hasNext ( ) ) { \n \n \t3 TestElementProperty possibleEntry = ( TestElementProperty ) iterator . next ( ) ; \n \n <ect>
\t4 log . info ( <string_literal> ) } } \n \n \t2 if ( ! state . alive . compareAndSet ( Aliveness . Alive . ordinal , Aliveness . LastSession . ordinal ) ) { \n \n \t3 log . info ( <string_literal> ) \n \n \t3 return false } \n \n <ect>
\t4 } else { \n \n \t5 MapDifference < ? , ? > diff = Maps . difference ( this . supervisorConf , nimbusConf ) ; \n \n \t5 LOG . debug ( <string_literal> , \n \n \t7 diff . entriesOnlyOnLeft ( ) , diff . entriesOnlyOnRight ( ) ) ; \n \n <ect>
\t2 @ Override \n \n \t2 public synchronized void onMessage ( Message message ) { \n \n \t3 receivedMessageCounter ++ ; \n \n \t3 latch . countDown ( ) ; \n \n <ect>
\t2 WebTarget target = client . target ( PortProviderUtil . generateURL ( <string_literal> , deploymentName ) ) ; \n \n \t2 Response response = target . request ( ) . post ( Entity . entity ( m , <string_literal> ) ) ; \n \n \t2 Assert . assertEquals ( HttpResponseCodes . SC_OK , response . getStatus ( ) ) ; \n \n \t2 String entity = response . readEntity ( String . class ) ; \n \n <ect>
\t4 iterator . remove ( ) ; \n \n \t4 try { \n \n \t5 entry . getValue ( ) . onAudioEnd ( interrupted ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 ) ; \n \n \t2 for ( DraftPlayer player : draft . getPlayers ( ) ) { \n \n \t3 if ( ! player . getPlayer ( ) . isHuman ( ) ) { \n \n \t4 player . setJoined ( ) ; \n \n <ect>
\t5 Object [ ] array = ( Object [ ] ) value ; \n \n \t5 if ( array . length == 1 ) { \n \n \t6 value = array [ 0 ] ; \n \n \t5 } else { \n \n <ect>
\t3 sendResponse ( resp , <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 HostVO host = _ms . getHostBy ( vm . getHostId ( ) ) ; \n \n \t2 if ( host == null ) { \n \n <ect>
\t2 insertHere . appendChild ( root . getOwnerDocument ( ) . createTextNode ( text ) ) ; \n \n \t2 <comment> \n \n \t2 Text textNode = ( Text ) insertHere . getFirstChild ( ) ; \n \n \t2 String textNodeString = textNode . getData ( ) ; \n \n <ect>
\t4 input . verify ( ) ; <comment> \n \n \t2 } catch ( InsufficientMoneyException e ) { \n \n \t3 throw e ; <comment> \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 logger . error ( <string_literal> , e . getMessage ( ) . toString ( ) ) ; \n \n \t3 response = null ; \n \n \t3 exceptionOccurred = true ; \n \n \t2 } catch ( SOAPException e ) { \n \n <ect>
\t2 try { \n \n \t3 store = new SimpleStringKeyValueStoreMySQL ( url , user , password , table , dataStoreConfig . sqlBatchWrite ( ) ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 store = StringKeyValueStoreNoOp . SINGLETON ; \n \n <ect>
\t2 String filterName = param . getName ( ) ; \n \n \t2 String value = ( String ) filterTypes . get ( filterName ) ; \n \n \t2 if ( null == value ) { \n \n \t3 <comment> \n \n <ect>
\t5 try { \n \n \t6 VirtualMachineRuntimeInfo runtimeInfo = vmMo . getRuntimeInfo ( ) ; \n \n \t6 VirtualMachineQuestionInfo question = runtimeInfo . getQuestion ( ) ; \n \n \t6 if ( question != null ) { \n \n <ect>
\t1 ICacheManager cacheManager = aggObjectFactory . get ( ICacheManager . class , session ) ; \n \n \t1 return cacheManager ; \n \n \t1 } catch ( ObjectFactoryException e ) { \n \n \t1 ICacheManager cacheManager = SimpleMapCacheManager . getInstance ( ) ; \n \n <ect>
@ Override \n \n public void contextDestroyed ( ServletContextEvent servletContextEvent ) { \n \n \t1 Repository jcrRepository = PentahoSystem . get ( Repository . class , <string_literal> , null ) ; \n \n \t1 if ( jcrRepository == null ) { \n \n <ect>
\t4 final InetAddress inetAddress = InetAddress . getByName ( c . getRemoteAddress ( ) . trim ( ) ) ; \n \n \t4 if ( containsAddress ( this . inetNetworkRange , this . inetNetmask , inetAddress ) ) { \n \n \t5 return new DefaultAuthenticationHandlerExecutionResult ( this , c , this . principalFactory . createPrincipal ( c . getId ( ) ) ) ; } \n \n \t3 } catch ( final UnknownHostException e ) { \n \n <ect>
\t3 LOG . warn ( <string_literal> , e ) ; \n \n \t3 return ; } } \n \n \t2 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t4 case UDPPacket . PAYLOAD_TYPE_TEST : \n \n \t5 _state = <number_literal> ; \n \n \t5 if ( auth == AuthType . BOBINTRO ) { \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t4 firstDictInfo = info ; \n \n \t3 } else { \n \n \t4 if ( ! firstDictInfo . isDictOnSameColumn ( info ) ) { \n \n \t5 <comment> \n \n <ect>
\t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; \n \n \t2 wkpp = WrappedKey . wrapKey ( wrappedDHKeyPair . getPrivate ( ) , null , aLabel , wrappingKeyPair . getPublic ( ) ) ; \n \n \t2 unwrappedKey = wkpp . unwrapKey ( wrappingKeyPair . getPrivate ( ) ) ; \n \n \t2 Assert . assertArrayEquals ( wrappedDHKeyPair . getPrivate ( ) . getEncoded ( ) , unwrappedKey . getEncoded ( ) ) ; \n \n <ect>
\t2 for ( String block : allowedNetBlocks ) { \n \n \t3 if ( isNetworkAWithinNetworkB ( cidr , block ) ) { \n \n \t4 return true ; } } \n \n \t2 <comment> \n \n <ect>
\t2 response . close ( ) ; \n \n \t2 <comment> \n \n \t2 base = client . target ( generateURL ( <string_literal> ) ) ; \n \n \t2 response = base . request ( ) . get ( ) ; \n \n <ect>
\t4 JobManager . runJobManager ( config , JobManagerMode . CLUSTER , <string_literal> , 0 ) ; \n \n \t4 <comment> \n \n \t4 new CountDownLatch ( 1 ) . await ( ) ; } \n \n \t3 catch ( Throwable t ) { \n \n <ect>
\t1 LOG . error ( <string_literal> ) \n \n \t1 throw ex \n \n \t1 } finally { \n \n \t1 new File ( databaseDumpFile ) . delete ( ) } \n \n <ect>
\t3 } catch ( Exception ex ) { \n \n \t4 gotFailures . compareAndSet ( false , true ) ; \n \n \t4 log . error ( <string_literal> , ex ) ; } } } \n \n \t1 private static void importJobData ( String jobId , SpawnDataStore sourceDataStore , SpawnDataStore targetDataStore , boolean checkAllWrites ) throws Exception { \n \n <ect>
\t2 if ( this . firstKey == null ) { \n \n \t3 bf . log . error ( <string_literal> + curPage ) ; \n \n \t3 repair ( 1 ) ; } \n \n \t2 if ( bf . log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
<comment> \n \n \t1 @ Deprecated \n \n \t1 public void setMaxConnectionAge ( long maxConnectionAgeInSeconds ) { \n \n <ect>
\t2 currentHref = currentHref . substring ( 0 , currentHash ) ; } \n \n \t1 var originalHash = originalHref . indexOf ( ' # ' ) ; \n \n \t1 if ( originalHash > 0 ) { \n \n \t2 originalHref = originalHref . substring ( 0 , originalHash ) ; } \n \n <ect>
\t3 . getApplicationAttemptId ( ) . getApplicationId ( ) . toString ( ) ; \n \n \t1 } else { \n \n \t2 daemonConf . unset ( ConfVars . LLAP_DAEMON_CONTAINER_ID . varname ) ; \n \n \t2 <comment> \n \n <ect>
\t3 { \n \n \t4 _zk . getData ( path + <string_literal> + child , false , collector , null ) ; } } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t2 long startTime = System . currentTimeMillis ( ) ; \n \n \t2 <comment> \n \n \t2 while ( _elapsedTime < DURATION && ! _isStopped ) { \n \n \t3 if ( Utilities . isPrime ( _numberToCheck ) ) { \n \n <ect>
\t4 return new Answer ( command , true , result ) ; \n \n \t3 } else { \n \n \t4 return new Answer ( command , false , result ) ; } \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t5 . < DistributionStep > getInstance ( DistributionStep . class , ReportDistributionStep . ID ) ; \n \n \t4 welcomeStep . setState ( State . COMPLETED ) ; \n \n \t4 steps . add ( welcomeStep ) ; \n \n \t3 } catch ( ComponentLookupException e1 ) { \n \n <ect>
\t2 if ( it . opts . extendRefs == 'fail' ) { \n \n \t2 throw new Error ( '$ref : validation keywords used in schema at path <string_literal> ( see option extendRefs ) ' ) ; \n \n \t2 } else if ( it . opts . extendRefs != = true ) { \n \n \t2 $refKeywords = false ; \n \n <ect>
\t2 if ( configuration == null ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return new ArrayList < > ( 0 ) ; } \n \n \t2 final LdapAccountStateHandler accountStateHandler = configuration . getAccountStateHandler ( ) ; \n \n <ect>
\t5 <comment> \n \n \t5 for ( int i = 0 ; i < firstBatch ; i ++ ) { \n \n \t6 Message msg = consumer . receive ( RECEIVE_TIMEOUT ) ; \n \n \t6 if ( msg != null ) { \n \n <ect>
\t2 resultEndpoint . expectedMessageCount ( 1 ) ; \n \n \t2 cacheExceptionEndpoint . expectedMessageCount ( 0 ) ; \n \n \t2 resultEndpoint . expectedBodiesReceived ( POETRY ) ; \n \n \t2 context . start ( ) ; \n \n <ect>
\t2 if ( HypervisorGuru . VmwareFullClone . value ( ) ) { <comment> \n \n \t3 try { \n \n \t4 queryAllPools ( ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t1 private boolean isImplicitPlannerUsedByOffering ( long offeringId ) { \n \n \t2 boolean implicitPlannerUsed = false ; \n \n \t2 ServiceOfferingVO offering = serviceOfferingDao . findByIdIncludingRemoved ( offeringId ) ; \n \n \t2 if ( offering == null ) { \n \n <ect>
\t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onFriends ( JSONObject json , StreamListener [ ] listeners ) throws TwitterException , JSONException { \n \n \t2 logger . warn ( <string_literal> ) ; } \n \n \t1 void onFavorite ( JSONObject source , JSONObject target , JSONObject targetObject , StreamListener [ ] listeners ) throws TwitterException { \n \n <ect>
\t6 pw . println ( outputObject . toString ( <number_literal> ) ) ; \n \n \t6 pw . println ( <string_literal> ) ; \n \n \t6 new InfoUpdate ( <string_literal> ) . generateJson ( prefix , pw , vWorkspace ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t2 srcUris . add ( ResourceDownloader . createURI ( resource . getUri ( ) ) ) ; } } \n \n \t1 for ( URI srcUri : srcUris ) { \n \n \t1 List < URI > localUris = resourceDownloader . downloadExternal ( srcUri , null , false ) ; \n \n \t1 for ( URI dst : localUris ) { \n \n <ect>
\t4 throw e ; \n \n \t3 } catch ( KeyManagementException e ) { \n \n \t4 s_logger . error ( <string_literal> + e . getMessage ( ) , e ) ; \n \n \t3 } catch ( NoSuchAlgorithmException e ) { \n \n <ect>
\t2 if ( removeBouncyCastle ) { \n \n \t3 try { \n \n \t4 Security . removeProvider ( BouncyCastleProvider . PROVIDER_NAME ) ; \n \n \t3 } catch ( SecurityException ex ) { \n \n <ect>
\t2 if ( server_obj == null ) { \n \n \t3 log . error ( Util . getMessage ( <string_literal> ) ) ; \n \n \t3 return null ; } \n \n \t2 if ( req == null || req . getLength ( ) == 0 ) { \n \n <ect>
\t4 String . format ( <string_literal> , \n \n \t6 sinkhandle . total_count . getValue ( ) , \n \n \t6 expected ) , b ) ; \n \n \t2 vim . stop ( ) ; \n \n <ect>
\t2 realm = realm . toUpperCase ( ) ; \n \n \t2 if ( StringUtils . isBlank ( realm ) || ! realmMap . containsKey ( realm ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , realm ) ; \n \n \t3 throw new STSException ( <string_literal> + realm ) ; } \n \n <ect>
\t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t4 _log . debug ( <string_literal> + clove . getCloveId ( ) \n \n \t6 + <string_literal> + howLongAgo + <string_literal> , new Exception ( <string_literal> ) ) ; \n \n \t3 else if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 buildCubeWithEngine . build ( ) ; \n \n \t3 buildCubeWithEngine . after ( ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 afterClass ( ) ; \n \n <ect>
<comment> \n \n \t1 private DomainGrouping computeDomainGrouping ( Collection < CmsSite > sites , Collection < String > workplaceUrls ) { \n \n \t2 DomainGrouping result = new DomainGrouping ( ) ; \n \n <ect>
\t3 return true ; \n \n \t2 } else if ( file . delete ( ) ) { \n \n \t3 obs . setComplexData ( null ) ; \n \n \t3 return true ; } \n \n <ect>
\t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t4 _log . debug ( <string_literal> + _timedEvent ) ; \n \n \t3 long before = System . currentTimeMillis ( ) ; \n \n \t3 if ( _log . shouldLog ( Log . WARN ) && before < _scheduled - <number_literal> ) \n \n <ect>
\t6 . stream ( ) \n \n \t6 . map ( a - > { \n \n \t7 Object value = null ; \n \n \t7 final TypedAttributeValue attributeValue = a . getValue ( ) ; \n \n <ect>
\t9 final List < String > supportedNameFormats , \n \n \t9 final SamlRegisteredService service , \n \n \t9 final SamlRegisteredServiceServiceProviderMetadataFacade adaptor ) { \n \n \t2 for ( final String nameFormat : supportedNameFormats ) { \n \n <ect>
\t4 try { \n \n \t5 reader . close ( ) ; \n \n \t4 } catch ( Exception any ) { \n \n <ect>
\t1 scheduledMonitoring = executor . scheduleWithFixedDelay ( ( ) - > expire ( ) , frequency , frequency , timeUnit ) ; } \n \n private void expire ( ) { \n \n \t1 if ( stopChecking ( ) ) { \n \n \t1 return ; } \n \n <ect>
\t2 } catch ( ParserConfigurationException e ) { \n \n \t3 s_logger . error ( <string_literal> + vlanId + <string_literal> + e . getMessage ( ) ) ; \n \n \t3 return null ; \n \n \t2 } catch ( DOMException e ) { \n \n <ect>
\t7 <comment> \n \n \t7 try { \n \n \t8 sendAllowed . acquire ( ) ; \n \n \t7 } catch ( InterruptedException e ) { \n \n <ect>
\t1 public TopologyInfo getTopologyInfo ( String id ) { \n \n \t2 try { \n \n \t3 return state . getNimbus ( ) . getTopologyInfo ( id ) ; \n \n \t2 } catch ( TException e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public boolean updateCredential ( RealmModel realm , UserModel user , CredentialInput input ) { \n \n \t2 if ( ! supportsCredentialType ( input . getType ( ) ) ) return false ; \n \n \t2 if ( ! ( input instanceof UserCredentialModel ) ) { \n \n <ect>
\t2 LOG . warn ( <string_literal> ) ; \n \n \t2 try { \n \n \t3 StormBase stormBase = data . getStormClusterState ( ) . storm_base ( topologyId , null ) ; \n \n \t3 if ( stormBase . getStatus ( ) . getStatusType ( ) == StatusType . rollback ) { \n \n <ect>
\t1 } finally { \n \n \t1 try { \n \n \t2 in . close ( ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 log . info ( <string_literal> , alreadyExists ) ; } \n \n \t2 try { \n \n \t3 conn . createStatement ( ) . execute ( <string_literal> ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t3 String jobName = jobKey . getJobName ( ) ; \n \n \t3 jobParams . put ( QuartzScheduler . RESERVEDMAPKEY_RESTART_FLAG , Boolean . TRUE ) ; \n \n \t3 WorkItemLifecycleEventUtil . publish ( workItemUid , params , WorkItemLifecyclePhase . RESTARTED ) ; \n \n \t3 scheduler . createJob ( jobName , iaction , jobParams , trigger , streamProvider ) ; \n \n <ect>
\t3 s_logger . trace ( <string_literal> + clusterIdsVmCountInfo . first ( ) ) ; } \n \n \t2 return clusterIdsVmCountInfo ; } \n \n \t1 protected Pair < List < Long > , Map < Long , Double > > listPodsByUserDispersion ( long dataCenterId , long accountId ) { \n \n <ect>
\t5 int memoryLimit = Integer . parseInt ( line . substring ( <string_literal> . length ( ) ) ) ; \n \n \t5 int newMemoryLimit = memoryLimit + extraMemoryMB ; \n \n \t5 <comment> \n \n \t5 if ( NodeStarter . isSomething32bits ( ) && newMemoryLimit > <number_literal> ) { \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 Timer clock = Time . startTimer ( ) ; \n \n \t2 AllTestResults model = loadModelFromProvider ( resultsProvider ) ; \n \n \t2 generateFiles ( model , resultsProvider , reportDir ) ; \n \n <ect>
\t3 } else { \n \n \t4 logger . info ( <string_literal> ) ; } \n \n \t3 if ( SoapUI . getSoapUICore ( ) == null ) { \n \n \t4 if ( StringUtils . hasContent ( getInitParameter ( <string_literal> ) ) ) { \n \n <ect>
\t4 PreparedStatement stmt1 = txn . prepareAutoCloseStatement ( insertSql1 ) ; \n \n \t4 stmt1 . executeUpdate ( ) ; \n \n \t4 s_logger . debug ( <string_literal> ) ; \n \n \t3 } catch ( SQLException ex ) { \n \n <ect>
\t5 committed ( property , rev , op ) ; \n \n \t4 } else { \n \n \t5 committedBranch ( doc , property , rev , cRev , op ) ; } } } \n \n \t2 if ( ++ documentCount % <number_literal> == 0 ) { \n \n <ect>
\t5 } else { \n \n \t6 line = ERR_IND ; \n \n \t6 if ( myEnd != COUNT_UNUSED ) { <comment> \n \n <number_literal> <comment> \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 if ( ! NetezzaManager . directModeWarningPrinted ) { \n \n \t1 LOG . warn ( <string_literal> ) ; \n \n <ect>
\t3 result . setItem ( installedItem ) ; \n \n \t3 result . setTreatment ( this . getTreatment ( ) ) ; \n \n \t3 return result ; \n \n \t2 } catch ( RuntimeException re ) { \n \n <ect>
\t1 public Set < Event > resolveInternal ( final RequestContext context ) { \n \n \t2 final RegisteredService service = resolveRegisteredServiceInRequestContext ( context ) ; \n \n \t2 final Authentication authentication = WebUtils . getAuthentication ( context ) ; \n \n \t2 if ( service == null || authentication == null ) { \n \n <ect>
\t3 try { \n \n \t4 tmp = File . createTempFile ( saveTo . getName ( ) , NodeUpdateManager . TEMP_BLOB_SUFFIX , saveTo . getParentFile ( ) ) ; \n \n \t4 tmp . deleteOnExit ( ) ; <comment> \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 } else { \n \n \t4 _resourceLimitMgr . decrementResourceCount ( volume . getAccountId ( ) , ResourceType . primary_storage , volume . isDisplayVolume ( ) , new Long ( currentSize - newSize ) ) ; } \n \n \t3 return volume ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t4 URL url = new URL ( <string_literal> + telemetryConfig . getErrorReportingDestination ( ) ) ; \n \n \t4 serverInfo = new ServerInfo ( telemetryConfig . getErrorReportingServerName ( ) , url . getHost ( ) , url . getPort ( ) ) ; \n \n \t4 serverInfo . setOwner ( telemetryConfig . getErrorReportingServerOwner ( ) ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 if ( null == gfs ) \n \n \t4 return response ; \n \n \t3 else return gfs . evaluate ( response ) ; \t1 \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 try ( CloseableHttpResponse response = this . wrappedHttpClient . execute ( new HttpGet ( url . toURI ( ) ) ) ) { \n \n \t3 final int responseCode = response . getStatusLine ( ) . getStatusCode ( ) ; \n \n \t3 final int idx = Collections . binarySearch ( this . acceptableCodes , responseCode ) ; \n \n \t3 if ( idx >= 0 ) { \n \n <ect>
\t2 self . check_ssh_into_vm ( ) \n \n \t1 @ attr ( tags = [ <string_literal> , <string_literal> ] , required_hardware = <string_literal> ) \n \n \t1 def test_02_VPC_default_routes ( self ) : \n \n \t2 <string_literal> <string_literal> <string_literal> \n \n <ect>
\t8 break ; } } } } \n \n \t3 } finally { \n \n \t4 cursor . close ( ) ; } \n \n \t3 if ( blocker != null ) { \n \n <ect>
\t2 bss . nextPage = bf . file . readUnsignedInt ( ) ; \n \n \t2 bss . spanSize = bf . file . readUnsignedShort ( ) ; \n \n \t2 bss . nKeys = bf . file . readUnsignedShort ( ) ; \n \n \t2 if ( bss . spanSize < 1 || bss . spanSize > SkipSpan . MAX_SIZE || bss . nKeys > bss . spanSize ) { \n \n <ect>
\t6 BarrierOperatorStateType . getBarrierOperatorStateType ( value ) ) ; \n \n \t4 this . getController ( ) . notifyEventListeners ( zEvent ) ; \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
\t1 public void destroyQueue ( ) { \n \n \t2 try { \n \n \t3 Broker broker = this . broker . getBroker ( ) ; \n \n \t3 if ( ! broker . isStopped ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 Queue queue = ( Queue ) brokerService . getDestination ( new ActiveMQQueue ( <string_literal> ) ) ; \n \n \t2 LOG . info ( <string_literal> + queue . getMessages ( ) . \n \n \t4 getSystemUsage ( ) . getMemoryUsage ( ) . getUsage ( ) ) ; \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t1 public synchronized void abort ( ) \n \n \t1 { \n \n \t2 if ( ! inTransaction ) \n \n \t2 { \n \n <ect>
\t7 <comment> \n \n \t7 RedeliveryData data = redeliveryState . get ( exchange . getExchangeId ( ) ) ; \n \n \t7 <comment> \n \n \t7 if ( data != null && recoverable . getMaximumRedeliveries ( ) > 0 && data . redeliveryCounter >= recoverable . getMaximumRedeliveries ( ) ) { \n \n <ect>
\t1 if ( null == handlerClassForTable ) { \n \n \t1 if ( ! replicationHandlers . isEmpty ( ) ) { \n \n \t2 log . debug ( <string_literal> , tableId ) ; } \n \n \t1 handlerClassForTable = conf . get ( Property . TSERV_REPLICATION_DEFAULT_HANDLER ) ; } \n \n <ect>
\t3 final Task task = _factory . create ( Task . Type . DATA , link , data ) ; \n \n \t3 try { \n \n \t4 _executor . submit ( task ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
\t2 eventList . add ( event ) ; \n \n \t2 log . info ( <string_literal> + event ) ; } \n \n \t1 public void processRead ( @ Observes @ EventsProcess @ EventsRead ( context = <string_literal> ) String event ) { \n \n \t2 eventList . add ( event ) ; \n \n <ect>
\t2 for ( AugmentedStmt au : get_TryBody ( ) ) \n \n \t3 logger . debug ( <string_literal> + au ) ; \n \n \t2 logger . debug ( <string_literal> ) ; \n \n \t2 for ( IterableSet < AugmentedStmt > catchBody : get_CatchList ( ) ) { \n \n <ect>
\t3 m_cms = getCmsObject ( ) ; \n \n \t3 List < CmsRole > roles = OpenCms . getRoleManager ( ) . getRoles ( m_cms , ou , false ) ; \n \n \t3 init ( roles ) ; \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t2 try { \n \n \t2 try { \n \n \t3 currBlock . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 Interval indexedInterval = JodaUtils \n \n \t6 . umbrellaInterval ( Iterables . transform ( segments , \n \n \t8 input - > input . getInterval ( ) \n \n \t6 ) ) ; \n \n <ect>
\t3 <comment> \n \n \t3 ErlLogger . error ( <string_literal> + moduleName + <string_literal> + r ) ; \n \n \t3 return false ; } \n \n \t2 <comment> \n \n <ect>
\t2 return remoteAddr ; } \n \n \t1 public String name ( ) { \n \n \t2 return name ; } \n \n \t1 public void handleResponse ( Channel channel , Object msg ) { \n \n <ect>
\t1 { \n \n \t2 Syntax syntax = Utils . getComponent ( CoreConfiguration . class ) . getDefaultDocumentSyntax ( ) ; \n \n \t2 if ( syntax == null || ( ! Utils . getComponentManager ( ) . hasComponent ( Parser . class , syntax . toIdString ( ) ) \n \n \t3 && ! Syntax . XWIKI_2_1 . equals ( syntax ) ) ) { \n \n <ect>
\t1 final = properties . find ( 'final' ) \n \n \t1 if name != None : \n \n \t2 name_text = name . text if name . text else <string_literal> \n \n \t1 else : \n \n <ect>
\t5 _executor . execute ( new WorkerTask ( _httpService , conn , _workerCount ++ ) ) ; \n \n \t4 } catch ( InterruptedIOException ex ) { \n \n \t5 break ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 } else { \n \n \t3 if ( ! kylinConfig . getServerMode ( ) . equals ( <string_literal> ) ) { \n \n \t4 throw new IllegalStateException ( \n \n \t6 <string_literal> ) ; } \n \n <ect>
\t3 } else if ( initializing . contains ( aId ) ) { \n \n \t4 type = <string_literal> ; \n \n \t3 } else { \n \n \t4 throw new IllegalStateException ( aId + <string_literal> ) ; } \n \n <ect>
\t1 private void doTurnOnRequestLogging ( ) { \n \n \t2 for ( Bucket bucket : config . buckets ( ) ) { \n \n \t3 serverProxy ( bucket ) . admin ( ) . turnOnRequestLogging ( ) ; } } \n \n \t1 private boolean turnOnRequestLogging ( final Bucket bucket , String key ) { \n \n <ect>
<comment> \n \n \t1 public void setScope ( Integer scope ) throws IOException { \n \n \t2 if ( this == _handle ) { \n \n <ect>
\t3 return false ; } \n \n \t2 long freeSpace = host . getAvailDiskBytes ( ) ; \n \n \t2 boolean full = freeSpace < = config . getMinFreeDiskSpaceToRunJobs ( ) ; \n \n \t2 if ( full ) { \n \n <ect>
\t2 Properties props = new Properties ( ) ; \n \n \t2 try { \n \n \t3 if ( resource . getFilename ( ) . endsWith ( XML_SUFFIX ) ) { \n \n <ect>
\t7 InputStream fileInputStream = new BufferedInputStream ( fis ) ) { \n \n \t6 this . trustStore . load ( fileInputStream , null ) ; \n \n \t6 log . info ( <string_literal> ) ; } \n \n \t4 } else { \n \n <ect>
\t3 throw new UnsupportedOperationException ( <string_literal> ) ; } } \n \n \t1 private File fullPath ; \n \n \t1 private TimerTask cleanup = null ; \n \n \t1 public FileBlobStoreImpl ( File path , Map < String , Object > conf ) throws IOException { \n \n <ect>
\t2 exchange . getIn ( ) . setBody ( email ) ; \n \n \t2 producer . process ( exchange ) ; \t3 \n \n \t2 if ( ! receivedMessageLatch . await ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n \t3 throw new IllegalStateException ( <string_literal> ) ; } \n \n <ect>
\t3 sendtohandlers ( event , remoteaddr , set ) ; \n \n \t2 } else if ( eventname . equals ( <string_literal> ) ) { \n \n \t3 sendtohandlers ( event , remoteaddr , <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t2 try { \n \n \t2 attrs = ldap . getContext ( ) . getAttributes ( dn , attrNames ) ; \n \n \t2 processor . processLdapEntry ( dn . toLowerCase ( ) , attrs ) ; \n \n \t2 } catch ( NamingException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 book = sendFindBookRequest ( template , routeboxUri , <string_literal> , <string_literal> ) ; \n \n <ect>
\t4 return ; } \n \n \t3 byte [ ] ip = chan . socket ( ) . getInetAddress ( ) . getAddress ( ) ; \n \n \t3 if ( _context . blocklist ( ) . isBlocklisted ( ip ) ) { \n \n \t4 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 executor . shutdown ( ) ; \n \n \t1 try { \n \n \t1 executor . awaitTermination ( 10L , TimeUnit . SECONDS ) ; \n \n \t1 } catch ( InterruptedException ex ) { \n \n <ect>
\t1 @ Override \n \n \t1 public synchronized void concede ( UUID playerId ) { \n \n \t2 Player player = state . getPlayer ( playerId ) ; \n \n \t2 if ( player != null && ! player . hasLost ( ) ) { \n \n <ect>
\t1 if ( ( current - lastActivityTimestamp ) > actorConfiguration . getTerminationTimeout ( MAX_TERMINATION_INACTIVITY_INTERVAL ) ) { \n \n \t1 cleanUpWithTermination ( ) ; } } \n \n private void cleanUp ( ) { \n \n \t1 if ( jobId . isPresent ( ) ) { \n \n <ect>
\t3 Object [ ] applicationComponents ; \n \n \t3 try { \n \n \t4 applicationComponents = parseApplicationName ( application ) ; \n \n \t3 } catch ( ExecutionException e ) { \n \n <ect>
\t4 } else { \n \n \t5 LOG . error ( msg ) ; \n \n \t5 throw new ServletException ( msg ) ; } } \n \n \t3 httpRegistry . register ( this ) ; } \n \n <ect>
\t5 if ( object == null ) { \n \n \t6 continue ; } \n \n \t5 serialize ( serializer , object ) ; } \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 Map < String , String > tags = new HashMap < String , String > ( ) ; \n \n \t3 if ( options . getAvailabilitySet ( ) . tags ( ) != null ) { \n \n \t3 tags . putAll ( options . getAvailabilitySet ( ) . tags ( ) ) ; } \n \n \t3 tags . put ( <string_literal> , options . getAvailabilitySet ( ) . name ( ) ) ; \n \n <ect>
\t4 s_logger . debug ( <string_literal> + parsed + <string_literal> + account . getAccountName ( ) + <string_literal> + account . getId ( ) + <string_literal> ) ; } } \n \n \t2 parsed = VPNUserUsageParser . parse ( account , currentStartDate , currentEndDate ) ; \n \n \t3 if ( ! parsed ) { \n \n <ect>
\t2 Properties prop = new Properties ( ) ; \n \n \t2 try { \n \n \t3 prop . load ( new FileInputStream ( <string_literal> ) ) ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t1 @ Override \n \n \t1 public long sendUnimplemented ( ) \n \n \t3 throws TransportException { \n \n \t2 final long seq = decoder . getSequenceNumber ( ) ; \n \n <ect>
\t6 log . debug ( <string_literal> + id + <string_literal> + hi \n \n \t7 . getOaiID ( ) + <string_literal> ) ; \n \n \t6 harvestedItemService . delete ( context , hi ) ; \n \n \t5 } else { \n \n <ect>
\t2 if ( ! receivedMessageLatch . await ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n \t3 throw new IllegalStateException ( <string_literal> ) ; } \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 context . stop ( ) ; \n \n <ect>
\t2 startLevel = ( startLevel | level ) ; } \n \n \t1 private void waitForMembers ( int level ) { \n \n \t2 long memberwait = sendFrequency * <number_literal> ; \n \n <ect>
\t2 this . conn = new ThreadLocal < > ( ) ; \n \n \t2 this . allConnections = new LinkedList < > ( ) ; \n \n \t2 try { \n \n \t3 Class . forName ( getDatabaseDriverClass ( ) ) ; \n \n <ect>
\t3 offset += numPadBytes ; } \n \n \t2 fragments [ offset ] = 0x0 ; <comment> \n \n \t2 offset ++ ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t6 logger . error ( <string_literal> , e ) ; \n \n \t5 } catch ( OmniUnknownMessageTypeException e ) { \n \n \t6 logger . error ( <string_literal> , e ) ; } } } \n \n \t2 } else { \n \n <ect>
\t5 <comment> \n \n \t5 ( ( BytesMessage ) message ) . reset ( ) ; } \n \n \t4 catch ( JMSException ex ) { \n \n \t5 <comment> \n \n <ect>
\t3 e , ErrorCode . FILE_OPEN_FAILURE ) ; } \n \n \t1 } else { \n \n \t1 <comment> \n \n \t1 LogLog . warn ( <string_literal> + name + <string_literal> ) ; \n \n <ect>
\t2 ) \n \n \t2 self . logger . debug ( <string_literal> % ( self . vm_1 . id , self . vm_2 . id ) ) \n \n \t2 self . test_ssh_command ( self . vm_1 , nat_rule1 , <string_literal> ) \n \n \t2 self . test_ssh_command ( self . vm_2 , nat_rule2 , <string_literal> ) \n \n <ect>
\t6 x = ws . once ( ) \n \n \t5 # Treat the error as if once ( ) had returned None \n \n \t5 except Exception as e : \n \n \t6 x = None \n \n <ect>
\t1 int cache2ListenerSize = cache2 . getAdvancedCache ( ) . getListeners ( ) . size ( ) ; \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 TestingUtil . killCacheManagers ( manager ( 0 ) ) ; \n \n \t1 cacheManagers . remove ( 0 ) ; \n \n <ect>
\t3 . index ( <string_literal> ) . mapping ( <string_literal> ) ; \n \n \t2 assertThat ( mappingMd . routing ( ) . required ( ) , equalTo ( true ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 internalCluster ( ) . fullRestart ( ) ; \n \n <ect>
\t3 Class < ? > clazz = loader . loadClass ( <string_literal> ) ; \n \n \t3 Provider bouncycastle = ( Provider ) clazz . newInstance ( ) ; \n \n \t3 Security . insertProviderAt ( bouncycastle , \n \n \t4 Integer . getInteger ( <string_literal> , <number_literal> ) ) ; \n \n <ect>
\t3 ready . await ( ) ; \n \n \t3 Response jaxrs = Response . ok ( <string_literal> ) . type ( MediaType . TEXT_PLAIN ) . build ( ) ; \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 cancelled = ! response . resume ( jaxrs ) ; \n \n <ect>
\t5 assertResultsAndLogOnFailure ( expectedResults , searchResponse ) ; } \n \n \t4 <comment> \n \n \t4 searchResponse = client ( ) . prepareSearch ( ) . setTypes ( <string_literal> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) \n \n \t5 . setSize ( numCreated + numInitialDocs ) . addSort ( <string_literal> , SortOrder . ASC ) . get ( ) ; \n \n <ect>
\t4 String propname = <string_literal> + actionEvent . getActionCommand ( ) ; \n \n \t4 String comp = JMeterUtils . getProperty ( propname ) ; \n \n \t4 log . debug ( <string_literal> , propname , comp ) ; \n \n \t4 if ( comp == null ) { \n \n <ect>
\t3 return false ; } \n \n \t2 if ( ! xmlResponse . contains ( <string_literal> ) ) { \n \n \t3 s_logger . debug ( <string_literal> + xmlResponse ) ; \n \n \t2 } else { \n \n <ect>
\t2 log . info ( <string_literal> , generateTables ( ) \n \n \t3 + ( ( ! generateTables && generateRecords ) ? <string_literal> : \n \n \t4 ( ( ! generateTables && generateDaos ) ? <string_literal> : <string_literal> ) ) ) ; \n \n \t2 log . info ( <string_literal> , generateUDTs ( ) ) ; \n \n <ect>
\t2 assertFalse ( <string_literal> , recentReports . isEmpty ( ) ) ; \n \n \t2 LOG . debug ( <string_literal> , recentReports ) ; } \n \n \t1 @ Theory \n \n \t1 public void testReport ( String reportName ) throws Exception { \n \n <ect>
\t3 String z [ ] = WebLib . split ( x [ i ] , <string_literal> ) ; \n \n \t3 if ( z . length == <number_literal> ) \n \n \t4 mt . params . put ( z [ 0 ] , z [ 1 ] ) ; \n \n \t3 else \n \n <ect>
\t2 @ Override \n \n \t2 public void acceptRecord ( final GcBiasCollectorArgs args ) { \n \n \t3 final SAMRecord rec = args . getRec ( ) ; \n \n \t3 if ( logCounter < <number_literal> && rec . getReadBases ( ) . length == 0 ) { \n \n <ect>
\t3 s_logger . error ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 List < NiciraNvpDeviceVO > devices = niciraNvpDao . listByPhysicalNetwork ( network . getPhysicalNetworkId ( ) ) ; \n \n \t2 if ( devices . isEmpty ( ) ) { \n \n <ect>
\t2 try { \n \n \t3 assertEquals ( <string_literal> , <string_literal> , broker . getBrokerName ( ) ) ; \n \n \t3 assertEquals ( <string_literal> , false , broker . isPopulateJMSXUserID ( ) ) ; \n \n \t3 assertEquals ( <string_literal> , true , broker . isPersistent ( ) ) ; \n \n <ect>
\t3 cctx . time ( ) . addTimeoutObject ( tx ) ; \n \n \t4 log . debug ( <string_literal> + tx ) ; } \n \n <ect>
\t3 if ( ip . getState ( ) == IpAddress . State . Releasing ) { \n \n \t4 Nic nic = nicDao . findByIp4AddressAndNetworkIdAndInstanceId ( publicNtwkId , _router . getId ( ) , ip . getAddress ( ) . addr ( ) ) ; \n \n \t4 if ( nic != null ) { \n \n \t5 nicsToUnplug . put ( ip . getVlanTag ( ) , ip ) ; \n \n <ect>
\t4 logger . debug ( <string_literal> , nm ( ) , msg ) ; \n \n \t4 return ; } \n \n \t3 if ( msg . isAckOfDirect ( ) && ( f . getQueryStatus ( ) == DeviceFeature . QueryStatus . QUERY_PENDING ) && cmd == 0x50 ) { \n \n \t4 OpenClosedType oc = ( cmd2 == 0 ) ? OpenClosedType . OPEN : OpenClosedType . CLOSED ; \n \n <ect>
\t5 log . debug ( <string_literal> ) ; \n \n \t4 } catch ( DataAccessException e ) { \n \n \t5 if ( createTableIfNotExists ) { \n \n \t6 try { \n \n <ect>
\t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( 0 ) . state ( ) , equalTo ( UNASSIGNED ) ) ; \n \n \t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( 1 ) . state ( ) , equalTo ( UNASSIGNED ) ) ; \n \n \t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( 0 ) . currentNodeId ( ) , nullValue ( ) ) ; \n \n \t3 assertThat ( clusterState . routingTable ( ) . index ( <string_literal> ) . shard ( i ) . shards ( ) . get ( 1 ) . currentNodeId ( ) , nullValue ( ) ) ; } \n \n <ect>
\t3 return new CSVFileImport ( headerRowIndex , dataStartRowIndex , \n \n \t5 delimiter , quoteCharacter , encoding , sampleSize , getFile ( ) , \n \n \t5 workspace , null ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 aggregateData . setNumDVs ( estimation ) ; } \n \n \t1 columnStatisticsData . setDecimalStats ( aggregateData ) ; \n \n \t1 } else { \n \n \t1 <comment> \n \n <ect>
\t2 super . onCreate ( savedInstanceState ) \n \n \t2 addPreferencesFromResource ( R . xml . flavourpreferences ) \n \n \t2 val nextcloudPref = findPreference ( <string_literal> ) \n \n \t2 nextcloudPref . setOnPreferenceClickListener { \n \n <ect>
\t5 U . releaseQuiet ( lock ) ; \n \n \t5 U . closeQuiet ( lockFile ) ; } \n \n \t4 <comment> \n \n <ect>
\t6 + File . separator + <string_literal> <comment> \n \n \t6 + File . separator + initFile ; \n \n \t4 in = new File ( fileToUse ) ; \n \n \t4 if ( ! in . exists ( ) ) { \n \n <ect>
\t2 { \n \n \t3 image = ImageIO . read ( in ) ; } \n \n \t2 catch ( IOException e ) \n \n \t2 { \n \n <ect>
\t4 logger . debug ( <string_literal> + session + <string_literal> ) ; } \n \n \t3 <comment> \n \n \t3 SessionFactoryUtils . closeSession ( session ) ; \n \n \t2 } else { \n \n <ect>
\t3 else { \n \n \t4 handleReadError ( response , <string_literal> , sockJsSession . getId ( ) ) ; } \n \n \t3 return ; } \n \n \t2 catch ( Throwable ex ) { \n \n <ect>
\t5 return true ; } \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t4 startCommunication ( ) ; } \n \n \t3 if ( ! dataAvailable ) { \n \n <ect>
\t2 LOG . warn ( <string_literal> + sanSnapshotId + <string_literal> , attEx ) ; \n \n \t2 throw new EucalyptusCloudException ( \n \n \t3 <string_literal> + snapshotId + <string_literal> + sanSnapshotId + <string_literal> , attEx ) ; } \n \n \t2 if ( lun == null ) { \n \n <ect>
\t1 throws IOException \n \n { \n \n \t1 if ( args . length < <number_literal> ) \n \n \t1 { \n \n <ect>
\t1 return Collections . emptySet ( ) ; } \n \n private String getRawKerberosDescriptorFromRequest ( Request request ) throws UnsupportedPropertyException { \n \n \t1 if ( request . getRequestInfoProperties ( ) == null || \n \n \t2 ! request . getRequestInfoProperties ( ) . containsKey ( Request . REQUEST_INFO_BODY_PROPERTY ) ) { \n \n <ect>
\t2 @ Override \n \n \t2 public void processConnect ( HostVO agent , StartupCommand cmd , boolean forRebalance ) { \n \n \t3 if ( cmd instanceof StartupTrafficMonitorCommand ) { \n \n \t4 long agentId = agent . getId ( ) ; \n \n <ect>
public void doSomething ( ) { \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 Transaction txn = Ebean . currentTransaction ( ) ; \n \n \t1 if ( txn == null ) { \n \n <ect>
\t2 for ( NodeTypeDefinitionProvider nodeTypeDefinitionProvider : nodeTypeDefinitionProviders ) { \n \n \t2 ntds . add ( nodeTypeDefinitionProvider . getNodeTypeDefinition ( ntMgr , vFac ) ) ; } \n \n \t2 ntMgr . registerNodeTypes ( ntds . toArray ( new NodeTypeDefinition [ 0 ] ) , true ) ; \n \n \t1 } catch ( RepositoryException ex ) { \n \n <ect>
\t2 if ( ! brokerService . isStopped ( ) ) { \n \n \t3 try { \n \n \t4 brokerService . stop ( ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t1 public URI getServiceEndpoint ( ) { \n \n \t2 String serviceEndpoint = region . getServiceEndpoint ( serviceName ) ; \n \n \t2 if ( serviceEndpoint == null ) { \n \n \t3 serviceEndpoint = String . format ( <string_literal> , serviceName , region . getName ( ) , region . getDomain ( ) ) ; \n \n <ect>
\t1 @ Override \n \n \t1 public Event doExecute ( final RequestContext requestContext ) { \n \n \t2 final Authentication c = WebUtils . getAuthentication ( requestContext ) ; \n \n \t2 if ( c == null ) { \n \n <ect>
\t4 } else { \n \n \t5 returnValues . put ( tagNames [ i ] , targetNodes . item ( 0 ) \n \n \t7 . getTextContent ( ) ) ; } } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 protected void execute ( ) { \n \n \t2 long now = System . currentTimeMillis ( ) ; \n \n \t2 <comment> \n \n \t2 if ( cachePeriod > 0 && lastCachePurge + ( cachePeriod * <number_literal> ) < now ) { \n \n <ect>
\t10 s_logger . trace ( <string_literal> + info . getKey ( ) ) ; \n \n \t10 s_logger . trace ( <string_literal> + info . getLabel ( ) ) ; } } } } \n \n \t5 } catch ( Throwable e ) { \n \n <ect>
\t2 <comment> \n \n \t2 testGetCallbackNoResponse ( ) ; \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 public void testRegisterName ( ) throws IOException { \n \n <ect>
\t2 assertThat ( client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) . setIndices ( ) . setWaitForCompletion ( true ) . get ( ) . getSnapshotInfo ( ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 cluster ( ) . wipeIndices ( <string_literal> , <string_literal> , <string_literal> ) ; \n \n \t2 assertAliasesMissing ( client . admin ( ) . indices ( ) . prepareAliasesExist ( <string_literal> , <string_literal> ) . get ( ) ) ; \n \n <ect>
\t3 return ClientAuthUtil . errorResponse ( Response . Status . BAD_REQUEST . getStatusCode ( ) , <string_literal> , <string_literal> + failure . getMessage ( ) ) ; } } \n \n \t1 public AuthenticationFlow createFlowExecution ( String flowId , AuthenticationExecutionModel execution ) { \n \n \t2 AuthenticationFlowModel flow = realm . getAuthenticationFlowById ( flowId ) ; \n \n \t2 if ( flow == null ) { \n \n <ect>
\t3 case CONNECTED : \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t4 break ; \n \n \t3 case SUSPENDED : \n \n <ect>
\t6 } catch ( Exception ignored ) { \n \n \t7 LOG . error ( <string_literal> , ignored ) ; \n \n \t7 exceptions . add ( ignored ) ; } } \n \n \t4 } ) ; } } \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( children == null ) { \n \n <ect>
\t2 if ( task != null ) { \n \n \t3 if ( task . jobDir == null ) { \n \n \t4 task . jobDir = task . getLiveDir ( ) ; } \n \n \t3 if ( ! task . jobDir . exists ( ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 try ( TransactionResource tran = Entities . transactionFor ( VolumeInfo . class ) ) { \n \n \t3 vol = Entities . uniqueResult ( vol ) ; \n \n \t3 final String volumeId = vol . getVolumeId ( ) ; \n \n <ect>
\t3 } catch ( InterruptedException ex ) { \n \n \t4 LOG . error ( <string_literal> , ex ) ; \n \n \t4 throw new FailedException ( ex ) ; \n \n \t3 } catch ( ExecutionException ex ) { \n \n <ect>
\t1 @ Override \n \n \t1 protected Event doExecute ( final RequestContext requestContext ) { \n \n \t2 final Authentication c = WebUtils . getAuthentication ( requestContext ) ; \n \n \t2 if ( c == null ) { \n \n <ect>
\t2 stmt2 = conn . prepareStatement ( setPreferenceSQL ) ; \n \n \t2 setLongParameter ( stmt2 , 1 , userID ) ; \n \n \t2 setLongParameter ( stmt2 , <number_literal> , itemID ) ; \n \n \t2 stmt2 . setDouble ( <number_literal> , value ) ; \n \n <ect>
\t1 value } \n \n def recordAndStopOnFailure ( client : DataWriterClient with Chainable , session : Session , name : String ) : Validation [ T ] = { \n \n \t1 val validation = record ( client , session , name ) \n \n \t1 validation . onFailure ( message = > { \n \n <ect>
\t5 workRequest . cleanup ( ) ; \n \n \t5 return ; } \n \n \t4 workRequest . doWork ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 catch ( CancelledKeyException cke ) { \n \n \t4 logger . debug ( <string_literal> ) ; } \n \n \t3 catch ( ClosedSelectorException cse ) { \n \n \t4 if ( isActive ( ) ) { \n \n <ect>
\t5 logger . info ( <string_literal> ) ; \n \n \t5 continue ; } \n \n \t4 String service_uri = s . toString ( ) ; \n \n \t4 service_id = service_uri . substring ( service_uri . lastIndexOf ( <string_literal> ) + 1 , service_uri . length ( ) - 1 ) ; \n \n <ect>
\t2 List < ServiceOfferingVO > serviceOfferingsForThisDomain = _offeringsDao . findServiceOfferingByDomainId ( domainId ) ; \n \n \t2 for ( ServiceOfferingVO serviceOffering : serviceOfferingsForThisDomain ) { \n \n \t3 _offeringsDao . remove ( serviceOffering . getId ( ) ) ; } } \n \n \t1 private boolean cleanupDomain ( Long domainId , Long ownerId ) throws ConcurrentOperationException , ResourceUnavailableException { \n \n <ect>
\t2 if ( totalBuckets < = 0 ) { \n \n \t2 throw new ConnectionException ( <string_literal> \n \n \t3 + acidTable . getQualifiedName ( ) + <string_literal> ) ; } \n \n \t2 String outputFormat = metaStoreTable . getSd ( ) . getOutputFormat ( ) ; \n \n <ect>
\t1 if ( partitionAccessors == null || partitionAccessors . isEmpty ( ) ) \n \n \t1 { \n \n \t1 <comment> \n \n \t1 <comment> \n \n <ect>
public long runFrequency ( TimeUnit unit ) { \n \n \t1 return HiveConf . getTimeVar ( conf , ConfVars . REPL_DUMPDIR_CLEAN_FREQ , unit ) ; } \n \n @ Override \n \n public void run ( ) { \n \n <ect>
\t6 } catch ( InterruptedException e ) { \n \n \t7 <comment> \n \n \t6 } catch ( Throwable t ) { \n \n \t7 try { \n \n <ect>
\t3 logger . info ( <string_literal> ) ; \n \n \t3 logger . info ( <string_literal> + ( i + 1 ) ) ; \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 logger . info ( <string_literal> + dbpojoHiveHistoryQuery . get ( i ) . getQuery ( ) ) ; \n \n <ect>
\t1 if ( response . getPayload ( ) != null ) { \n \n \t2 try { \n \n \t3 return Strings2 . toString ( response . getPayload ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 logger . info ( <string_literal> , volume ) ; \n \n \t1 AsyncCreateResponse job = client . getSnapshotApi ( ) . createSnapshot ( volume . getId ( ) ) ; \n \n \t1 assertTrue ( jobComplete . apply ( job . getJobId ( ) ) ) ; \n \n \t1 Snapshot snapshot = findSnapshotWithId ( job . getId ( ) ) ; \n \n <ect>
\t2 client ( ) . admin ( ) . indices ( ) . prepareCreate ( <string_literal> ) \n \n \t4 . addMapping ( <string_literal> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <string_literal> ) . startObject ( <string_literal> ) \n \n \t5 . field ( <string_literal> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ) \n \n \t4 . execute ( ) . actionGet ( ) ; \n \n <ect>
\t4 LOG . debug ( <string_literal> , exchange . getExchangeId ( ) ) ; \n \n \t4 if ( session != null && session . getTransacted ( ) ) { \n \n \t5 session . commit ( ) ; } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 break ; } \n \n \t3 case DELETE : { \n \n \t4 break ; } \n \n \t3 default : \n \n <ect>
\t2 long tEnd = System . currentTimeMillis ( ) ; \n \n \t2 long dT = tEnd - tStart ; \n \n \t2 if ( dT > <number_literal> ) { \n \n \t3 if ( dT > <number_literal> ) \n \n <ect>
\t5 s_logger . debug ( <string_literal> + hostId ) ; } \n \n \t4 rebalanceHost ( hostId , currentOwnerId , futureOwnerId ) ; \n \n \t3 } catch ( final Exception e ) { \n \n <ect>
<comment> \n \n \t1 public CmsResource findLocalizationRoot ( CmsResource resource ) throws CmsException { \n \n \t2 String rootPath = resource . getRootPath ( ) ; \n \n <ect>
\t2 SolrInputDocument doc = value . getSolrInputDocument ( ) ; \n \n \t2 try { \n \n \t3 writeDocument ( doc ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 <comment> \n \n \t3 return ( false ) ; } \n \n \t2 @ Override \n \n \t2 public void handleMessage ( int group , byte cmd1 , Msg msg , DeviceFeature f , String fromPort ) { \n \n <ect>
\t2 if ( initialState == State . CLOSED ) \n \n \t3 return true ; \n \n \t2 if ( initialState != State . READY ) \n \n \t2 { \n \n <ect>
\t2 this . facade = facade ; } \n \n \t1 protected boolean resolveDeployment ( ) { \n \n \t2 deployment = deploymentContext . resolveDeployment ( facade ) ; \n \n \t2 if ( ! deployment . isConfigured ( ) ) { \n \n <ect>
\t2 for ( byte [ ] keyHash : _keyMap . keySet ( ) ) { \n \n \t3 Log . info ( Log . FAC_ACCESSCONTROL , <string_literal> , DataUtils . printHexBytes ( keyHash ) ) ; } \n \n \t2 Log . info ( Log . FAC_ACCESSCONTROL , <string_literal> ) ; \n \n \t2 for ( byte [ ] keyHash : _myKeyMap . keySet ( ) ) { \n \n <ect>
\t2 { \n \n \t3 timeoutSecs = 1 ; } \n \n \t2 else if ( timeoutSecs > <number_literal> ) \n \n \t2 { \n \n <ect>
\t1 try { \n \n \t2 lockRandomAccessFile . close ( ) ; \n \n \t2 lockRandomAccessFile = null ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t3 Logger . debug ( this , <string_literal> ) ; \n \n \t3 iterate ( ) ; \n \n \t3 sleepTime = getSleepTime ( ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t5 if ( ! useRAManagedTx ) { \n \n \t6 <comment> \n \n \t6 <comment> \n \n \t6 <comment> \n \n <ect>
\t1 for ( int i = 1 ; i < constant_pool_count ; i ++ ) redirect [ i ] = ( short ) 0 ; \n \n \t1 for ( int i = 1 ; i < constant_pool_count ; i ++ ) { \n \n \t2 for ( smallest = 1 ; smallest < constant_pool_count ; smallest ++ ) \n \n \t3 if ( redirect [ smallest ] == ( short ) 0 ) break ; \n \n <ect>
\t2 LOG . info ( msg ( <string_literal> ) + <string_literal> + bitstream . getID ( ) ) ; \n \n \t2 LOG . info ( msg ( <string_literal> ) + <string_literal> + info . isInfoFound ( ) ) ; \n \n \t2 LOG . info ( msg ( <string_literal> ) + <string_literal> + bitstream . isDeleted ( ) ) ; \n \n \t2 LOG . info ( msg ( <string_literal> ) + <string_literal> + info . isBitstreamFound ( ) ) ; \n \n <ect>
\t1 Set < Long > runningRequestIds = new HashSet < > ( ) ; \n \n \t1 List < Stage > firstStageInProgressPerRequest = db . getFirstStageInProgressPerRequest ( ) ; \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n <ect>
\t1 try { \n \n \t2 account . deleteUser ( user , true <comment> , true <comment> ) ; \n \n \t1 } catch ( AuthException e ) { \n \n \t2 LOG . error ( e , e ) ; \n \n <ect>
\t1 try { \n \n \t1 final HttpHeaders headers = httpResponse . headers ( ) ; \n \n \t1 manager . put ( uri , Maps . asMap ( headers . names ( ) , input - > headers . getAll ( input ) ) ) ; } \n \n \t1 catch ( IOException e ) { \n \n <ect>
\t2 boolean updateResult = _projectDao . update ( project . getId ( ) , project ) ; \n \n \t2 if ( updateResult ) { \n \n \t3 long projectAccountId = project . getProjectAccountId ( ) ; \n \n \t3 if ( ! _accountMgr . disableAccount ( projectAccountId ) ) { \n \n <ect>
\t7 . build ( ) ; \n \n \t4 } else { \n \n \t5 return new ArrayList < MessageContainer > ( ) ; } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 } catch ( SwfMetadataException e ) { \n \n \t4 logger . info ( <string_literal> + domain + <string_literal> + taskList + <string_literal> ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 if ( PersistenceExceptions . isStaleUpdate ( e ) ) { \n \n <ect>
\t1 if ( timeoutStr != null && timeoutStr . length ( ) > 0 ) { \n \n \t2 try { \n \n \t2 timeoutVar = Integer . parseInt ( timeoutStr ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t3 return ; } \n \n \t2 long delay = Math . max ( MIN_VIRTUAL_UPDATE_DELAY , \n \n \t4 ( currentTimestamp - lastTimestamp ) * VIRTUAL_UPDATE_MULTIPLIER_DELAY ) ; \n \n \t2 logger . debug ( <string_literal> , delay ) ; \n \n <ect>
\t4 StringWriter writer = new StringWriter ( ) ; \n \n \t4 velocityEngine . evaluate ( velocityContext , writer , xcontext . getDoc ( ) . getPrefixedFullName ( ) , content ) ; \n \n \t4 return writer . toString ( ) ; } \n \n \t2 } catch ( XWikiVelocityException e ) { \n \n <ect>
end \n \n if movedRegions . size ( ) > 0 \n \n \t1 # Write out file of regions moved \n \n \t1 writeFile ( filename , movedRegions ) \n \n <ect>
<comment> \n \n \t2 void onResult ( GridTopologyException e ) { \n \n <ect>
\t3 s_logger . info ( <string_literal> ) ; \n \n \t3 if ( ! lock . lock ( <number_literal> * <number_literal> ) ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> ) ; } \n \n \t3 try { \n \n <ect>
\t2 @ Override \n \n \t2 public void run ( ) { \n \n \t3 int shutdownChecks = 0 ; \n \n \t3 while ( ! Bootstrap . isShuttingDown ( ) && shutdownChecks ++ < <number_literal> ) { \n \n <ect>
\t2 if ( user != null ) { \n \n \t3 account = accountMgr . getAccount ( user . getAccountId ( ) ) ; } \n \n \t2 if ( ( user == null ) || ( user . getRemoved ( ) != null ) || ! user . getState ( ) . equals ( Account . State . enabled ) || ( account == null ) || \n \n \t4 ! account . getState ( ) . equals ( Account . State . enabled ) ) { \n \n <ect>
\t2 if ( ! file . exists ( ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , file . getName ( ) ) ; \n \n \t3 return new ArrayList < > ( 0 ) ; } \n \n \t2 if ( file . length ( ) == 0 ) { \n \n <ect>
\t2 AllocationService strategy = createAllocationService ( Settings . builder ( ) \n \n \t4 . put ( <string_literal> , <number_literal> ) \n \n \t4 . put ( ShardsLimitAllocationDecider . CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING . getKey ( ) , 1 ) \n \n \t4 . build ( ) ) ; \n \n <ect>
\t2 <comment> \n \n \t2 client . createStream ( streamName , 1 ) ; \n \n \t2 <comment> \n \n \t2 DescribeStreamResult status = client . describeStream ( streamName ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlIDPSettingCanonicalizationMethod ( String canonicalizationMethod ) { \n \n <ect>
\t3 Method method = jmDNSClass . getMethod ( <string_literal> , new Class [ ] { serviceInfoClass } ) ; \n \n \t3 method . invoke ( jmDNS , new Object [ ] { serviceInfo } ) ; \n \n \t3 LogLog . debug ( <string_literal> + serviceInfo ) ; \n \n \t2 } catch ( IllegalAccessException e ) { \n \n <ect>
\t3 try { \n \n \t3 Thread . sleep ( sleepStep * <number_literal> ) ; \n \n \t3 sleepStep = Math . min ( sleepStep * <number_literal> , <number_literal> ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t9 _IPToCountry . put ( search [ i ] , cached ) ; \n \n \t8 } else { \n \n \t9 _notFound . add ( search [ i ] ) ; } } \n \n \t6 } catch ( IOException ioe ) { \n \n <ect>
\t2 LOG . debug ( <string_literal> , originEntity . getKey ( ) ) ; \n \n \t2 dataMigrator . migrateEntity ( originEntity . getValue ( ) , null ) ; } } \n \n \t1 LOG . debug ( <string_literal> ) ; \n \n \t1 dataMigrator . migrateInstanceData ( ) ; \n \n <ect>
\t2 try ( InputStream resource = getClass ( ) . getResourceAsStream ( <string_literal> + environment + <string_literal> ) ) { \n \n \t3 properties . load ( resource ) ; \n \n \t3 LOG . debug ( <string_literal> , environment ) ; \n \n \t2 } catch ( NullPointerException | IOException whenNotFound ) { \n \n <ect>
\t2 { \n \n \t3 String jobName = jobexecutioncontext . getJobDetail ( ) . getKey ( ) . getName ( ) ; \n \n \t3 String jobGroup = jobexecutioncontext . getJobDetail ( ) . getKey ( ) . getGroup ( ) ; \n \n \t3 log . debug ( <string_literal> + jobGroup + <string_literal> + jobName ) ; \n \n <ect>
\t2 dlqconsumer . setMessageListener ( new MessageListener ( ) { \n \n \t3 @ Override \n \n \t3 public void onMessage ( Message message ) { \n \n \t4 try { \n \n <ect>
\t3 NoSuchAlgorithmException nsae = ObjectHelper . getException ( NoSuchAlgorithmException . class , e ) ; \n \n \t3 if ( nsae != null ) { \n \n \t4 String name = System . getProperty ( <string_literal> ) ; \n \n \t4 String message = nsae . getMessage ( ) ; \n \n <ect>
import org . apache . log4j . Logger ; \n \n public class Main { \n \n \t1 private static final Logger LOGGER = Logger . getLogger ( Main . class ) ; \n \n \t1 public static void main ( String args [ ] ) { \n \n <ect>
\t2 logHttp ( connector ) ; \n \n \t1 } else { \n \n \t2 throw new IllegalArgumentException ( <string_literal> + connector ) ; } } } \n \n private void logHttp ( Connector connector ) { \n \n <ect>
\t1 Set < URI > srcUris = new HashSet < > ( ) ; \n \n \t1 for ( Function fn : fns ) { \n \n \t1 String fqfn = fn . getDbName ( ) + <string_literal> + fn . getFunctionName ( ) ; \n \n \t1 if ( udfs . containsKey ( fn . getClassName ( ) ) ) { \n \n <ect>
\t2 if ( onStartup ) { \n \n \t3 log . info ( <string_literal> , new Object [ ] { config . getHostName ( ) , config . getPort ( ) , actualPath . toString ( ) } ) ; \n \n \t2 } else { \n \n <ect>
\t8 . map ( BaseBclReader . TileData : : getTileNum ) \n \n \t8 . map ( Object : : toString ) \n \n \t8 . collect ( Collectors . joining ( <string_literal> ) ) ; \n \n \t6 if ( emptyCycleString . length ( ) > 0 ) { \n \n <ect>
\t5 page . appendToResponse ( new ERXResponse ( ) , context ) ; \n \n \t4 } finally { \n \n \t5 ec . unlock ( ) ; } \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t2 if ( storagePool . getPoolType ( ) . supportsOverProvisioning ( ) ) { \n \n \t3 <comment> \n \n \t3 BigDecimal overProvFactor = getStorageOverProvisioningFactor ( storagePool . getId ( ) ) ; \n \n \t3 totalOverProvCapacity = overProvFactor . multiply ( new BigDecimal ( storagePool . getCapacityBytes ( ) ) ) . longValue ( ) ; \n \n <ect>
\t2 <comment> \n \n \t2 camelContext . getManagementStrategy ( ) . removeEventNotifier ( eventNotifier ) ; \n \n \t2 ServiceHelper . stopAndShutdownService ( eventNotifier ) ; \n \n \t2 camelContext . getRoutePolicyFactories ( ) . remove ( this ) ; \n \n <ect>
\t3 { \n \n \t4 try \n \n \t4 { \n \n \t5 AdvertisedSocketAddress from = addressProvider . primary ( ) ; \n \n <ect>
\t2 if ( this . testBean1 == null ) { \n \n \t3 LOG . error ( <string_literal> ) ; \n \n \t3 currentState = false ; } \n \n \t2 if ( ! <string_literal> . equals ( testBean1 . printString ( ) ) ) { \n \n <ect>
\t3 tHandle . close ( ) ; } \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testVersionOrdering ( ) throws Exception { \n \n <ect>
public class YubiKeyRestHttpRequestCredentialFactory implements RestHttpRequestCredentialFactory { \n \n \t1 @ Override \n \n \t1 public List < Credential > fromRequestBody ( final MultiValueMap < String , String > requestBody ) { \n \n \t2 final String otp = requestBody . getFirst ( <string_literal> ) ; \n \n <ect>
\t4 int readCount = 0 ; \n \n \t4 count ++ ; \n \n \t4 GenomeLoc firstLocus = sh . getGenomeLocs ( ) . get ( 0 ) , lastLocus = sh . getGenomeLocs ( ) . get ( sh . getGenomeLocs ( ) . size ( ) - 1 ) ; \n \n \t4 logger . debug ( <string_literal> + firstLocus . getStart ( ) + <string_literal> + lastLocus . getStop ( ) + <string_literal> + firstLocus . getContig ( ) ) ; \n \n <ect>
\t2 private static final Function < X509Certificate [ ] , X500Name > subject = certs - > { \n \n \t3 try { \n \n \t4 return new JcaX509CertificateHolder ( certs [ 0 ] ) . getSubject ( ) ; \n \n \t3 } catch ( CertificateEncodingException e ) { \n \n <ect>
\t9 transactionCompleted . availablePermits ( ) ) ; \n \n \t7 break ; \n \n \t6 case CAN : \n \n \t7 CANCount ++ ; \n \n <ect>
\t3 return null ; } \n \n \t2 final String entityIds = org . springframework . util . StringUtils . collectionToDelimitedString ( entityIDList , <string_literal> ) ; \n \n \t2 service . setMetadataCriteriaDirection ( PredicateFilter . Direction . INCLUDE . name ( ) ) ; \n \n \t2 service . setMetadataCriteriaPattern ( entityIds ) ; \n \n <ect>
\t5 } else { \n \n \t6 s_logger . warn ( <string_literal> ) ; } } \n \n \t3 } catch ( SQLException e ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> , e ) ; } \n \n <ect>
\t8 s_logger . info ( <string_literal> + api . getTestCaseInfo ( ) + <string_literal> + api . getUrl ( ) ) ; } } } } \n \n \t4 else if ( ( api . getResponseType ( ) != ResponseType . ERROR ) && ( api . getResponseCode ( ) != <number_literal> ) ) { \n \n \t5 s_logger . error ( <string_literal> + api . getName ( ) + <string_literal> + api . getResponseCode ( ) + <string_literal> + api . getUrl ( ) ) ; \n \n \t5 if ( api . getRequired ( ) == true ) { \n \n <ect>
\t4 work . setStep ( Step . Error ) ; \n \n \t4 _workDao . update ( work . getId ( ) , work ) ; } \n \n \t3 scheduleRulesetUpdateToHosts ( affectedVms , false , null ) ; \n \n \t2 } else { \n \n <ect>
public boolean isRegistered ( Expirable expirable ) { \n \n \t1 return monitors . containsKey ( expirable ) ; } \n \n public void removeExpirable ( Expirable expirable ) { \n \n <ect>
\t3 WebUtils . putService ( context , service ) ; \n \n \t3 if ( registeredService != null ) { \n \n \t4 final URI url = registeredService . getAccessStrategy ( ) . getUnauthorizedRedirectUrl ( ) ; \n \n \t4 if ( url != null ) { \n \n <ect>
\t1 LOGGER . info ( msg ) ; \n \n \t1 throw new IOException ( msg ) ; } \n \n \t1 FileLock secondLock = tryLock ( dir ) ; \n \n \t1 if ( secondLock != null ) { \n \n <ect>
\t3 } catch ( Throwable e ) { \n \n \t4 throw new CloudRuntimeException ( <string_literal> , e ) ; } \n \n \t2 } else if ( Config . SystemVMUseLocalStorage . key ( ) . equalsIgnoreCase ( name ) ) { \n \n <ect>
\t7 log . debug ( <string_literal> + classString \n \n \t9 + <string_literal> ) ; } } } \n \n \t4 Daemon . runStartupForService ( openmrsService ) ; } \n \n \t3 catch ( InterruptedException e ) { \n \n <ect>
\t5 } else { \n \n \t6 s_logger . debug ( <string_literal> ) ; \n \n \t6 return ( System . currentTimeMillis ( ) > > <number_literal> ) + _investigateRetryInterval ; } } \n \n \t4 if ( ! fenced ) { \n \n <ect>
\t1 String propertyName = override . name ( ) ; \n \n \t1 Column column = override . column ( ) ; \n \n \t1 DeployBeanProperty beanProperty = descriptor . getBeanProperty ( propertyName ) ; \n \n \t1 if ( beanProperty == null ) { \n \n <ect>
\t3 this . delegate = delegate ; } \n \n \t2 @ Override \n \n \t2 public void onException ( JMSException exception ) { \n \n \t3 <comment> \n \n <ect>
\t2 final AuditableExecutionResult result = delegatedAuthenticationPolicyEnforcer . execute ( context ) ; \n \n \t2 if ( ! result . isExecutionFailure ( ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , registeredService , client ) ; \n \n \t3 return true ; } \n \n <ect>
\t1 public void cleanup ( Xen . Vm vm ) { \n \n \t2 try { \n \n \t3 cleanupNetwork ( vm . getVmVifs ( ) ) ; \n \n \t2 } catch ( XmlRpcException e ) { \n \n <ect>
\t3 exposedHeadersConfig = <string_literal> ; \n \n \t2 exposedHeaders . addAll ( Arrays . asList ( exposedHeadersConfig . split ( <string_literal> ) ) ) ; \n \n \t2 String chainPreflightConfig = config . getInitParameter ( OLD_CHAIN_PREFLIGHT_PARAM ) ; \n \n \t2 if ( chainPreflightConfig != null ) \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
\t5 if ( isCheckpoint ) { \n \n \t6 cp . createCheckpoint ( cpPath + <string_literal> + i ) ; } \n \n \t5 flushWaitTime = System . currentTimeMillis ( ) + flushInterval ; } } \n \n \t2 } catch ( RocksDBException e ) { \n \n <ect>
<number_literal> state = comm . getProvidersState ( tmpProvider , tmpItem ) ; \n \n <number_literal> if ( state != null ) { \n \n <number_literal> eventPublisher . postUpdate ( tmpItem , state ) ; } \n \n \t10 } catch ( Exception e ) { \n \n <ect>
\t2 Iterator < Tuple > it = pig . openIterator ( <string_literal> ) ; \n \n \t2 int [ ] expectedValues = { <number_literal> , <number_literal> , <number_literal> , <number_literal> } ; \n \n \t2 int count = 0 ; \n \n \t2 int countExpected = <number_literal> ; \n \n <ect>
\t5 connected = true ; \n \n \t5 <comment> \n \n \t5 <comment> \n \n \t5 lastDigitalInputs = - 1 ; \n \n <ect>
<comment> \n \n public void destroy ( ) throws Exception { \n \n <ect>
\t3 logger . warn ( <string_literal> , e ) ; \n \n \t2 } finally { \n \n \t3 detector . destroy ( ) ; } } \n \n \t1 private static void fallbackToManualAnnotatedClasses ( Class < ? > mainClass , AtmosphereFramework f , AnnotationHandler handler ) { \n \n <ect>
\t4 FunctionUtils . closeFunction ( combineStub ) ; } \n \n \t3 catch ( Throwable t ) { \n \n \t4 throw new IOException ( <string_literal> , t ) ; } \n \n <ect>
\t3 X509Certificate [ ] keyCertChain ; \n \n \t3 File keyCertChainFile = config . get ( policyConfig . public_certificate ) ; \n \n \t3 if ( allowKeyGeneration && ! privateKeyFile . exists ( ) && ! keyCertChainFile . exists ( ) ) \n \n \t3 { \n \n <ect>
\t3 return ; } \n \n \t2 requestCompliance . makeRequestCompliant ( request ) ; \n \n \t2 request . addHeader ( <string_literal> , via ) ; \n \n \t2 if ( ! cacheableRequestPolicy . isServableFromCache ( request ) ) { \n \n <ect>
\t2 val dbUrl = <string_literal> \n \n \t2 try { \n \n \t3 Class . forName ( <string_literal> ) \n \n \t2 } catch ( e : ClassNotFoundException ) { \n \n <ect>
\t2 Collection < Token > tokens = create ( tokenMetadata , strategy ) . addUnit ( endpoint , numTokens ) ; \n \n \t2 tokens = adjustForCrossDatacenterClashes ( tokenMetadata , strategy , tokens ) ; \n \n \t2 { \n \n <ect>
\t6 MessageConsumer con2 = session . createConsumer ( queue ) ; \n \n \t6 while ( true ) { \n \n \t7 Message message = con2 . receive ( <number_literal> ) ; \n \n \t7 if ( message == null ) break ; \n \n <ect>
\t1 try { \n \n \t1 <comment> \n \n \t1 return isLocalFile ( conf , new URI ( fileName ) ) ; \n \n \t1 } catch ( URISyntaxException e ) { \n \n <ect>
\t4 System . setProperty ( SYS_PROP_LOGIN_CONF , urlPath ) ; \n \n \t3 } else { \n \n \t4 final URL url = getClass ( ) . getResource ( <string_literal> ) ; \n \n \t4 if ( url != null ) { \n \n <ect>
\t3 { \n \n \t4 newDocument = new ConferenceInfoDocument ( ourDocument ) ; } \n \n \t3 catch ( XMLException e ) \n \n \t3 { \n \n <ect>
\t2 Object obj ; \n \n \t2 try { \n \n \t3 obj = instantiateContributionImplementation ( contrib ) ; \n \n \t2 } catch ( FatalBeanException e ) { \n \n <ect>
\t4 FragHeader hdr = new FragHeader ( frag_id , i , num_frags ) ; \n \n \t4 frag_msg . putHeader ( this . id , hdr ) ; \n \n \t4 down_prot . down ( frag_msg ) ; } } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 protected void runInContext ( ) { \n \n \t3 long seq = _req . getSequence ( ) ; \n \n \t3 try { \n \n \t4 if ( _outstandingCronTaskCount . incrementAndGet ( ) >= _agentMgr . getDirectAgentThreadCap ( ) ) { \n \n <ect>
\t2 boolean success = true ; \n \n \t2 if ( schedule != null ) { \n \n \t3 success = _snapshotScheduleDao . remove ( schedule . getId ( ) ) ; } \n \n \t2 if ( ! success ) { \n \n <ect>
\t4 if ( expire > MAX_RETRY_DELAY ) \n \n \t5 expire = MAX_RETRY_DELAY ; \n \n \t4 hostDeadDur . put ( host , Long . valueOf ( expire ) ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t6 this . logger . debug ( MessageFormat . format ( <string_literal> , \n \n \t8 headerName , pattern ) ) ; } \n \n \t5 return true ; } } } \n \n <ect>
\t1 @ Override \n \n \t1 public boolean removeAllLoadBalanacersForNetwork ( long networkId , Account caller , long callerUserId ) { \n \n \t2 List < FirewallRuleVO > rules = _firewallDao . listByNetworkAndPurposeAndNotRevoked ( networkId , Purpose . LoadBalancing ) ; \n \n \t2 if ( rules != null ) \n \n <ect>
\t3 String peerListenerProperty = String . format ( <string_literal> , \n \n \t5 currentListener . getFormattedIP ( ) , currentListener . getPort ( ) ) ; \n \n \t3 peerListenerConfig . setProperties ( peerListenerProperty ) ; \n \n \t3 cacheManagerConfig . addCacheManagerPeerListenerFactory ( peerListenerConfig ) ; \n \n <ect>
\t5 lastLoaded = lastModified ; } } \n \n \t3 catch ( Throwable t ) \n \n \t3 { \n \n \t4 JVMStabilityInspector . inspectThrowable ( t ) ; \n \n <ect>
\t4 + <string_literal> , \n \n \t4 new HashMap < > ( 0 ) , new HashMap < > ( 0 ) ) ; } \n \n \t2 final String principalId = principal != null ? principal . getId ( ) : principals . get ( 0 ) . getId ( ) ; \n \n \t2 final Principal finalPrincipal = this . principalFactory . createPrincipal ( principalId , attributes ) ; \n \n <ect>
\t2 return MatchStatus . FORBIDDEN ; } \n \n \t2 if ( userRoles != null && userRoles . contains ( role ) ) return MatchStatus . PERMITTED ; } \n \n \t1 log . info ( <string_literal> , permission , principal ) ; \n \n \t1 return InfraRuleBasedAuthorizationPlugin . MatchStatus . FORBIDDEN ; } \n \n <ect>
\t1 this . opts = opts ; \n \n \t1 this . fs = fs ; \n \n \t1 long gcDelay = getConfiguration ( ) . getTimeInMillis ( Property . GC_CYCLE_DELAY ) ; \n \n \t1 log . info ( <string_literal> , getStartDelay ( ) ) ; \n \n <ect>
\t5 <string_literal> \n \n \t5 + <string_literal> ) ; \n \n \t4 ) { \n \n \t3 pstmt1 . executeUpdate ( ) ; \n \n <ect>
\t6 } catch ( FrameworkException fex ) { \n \n \t7 logger . warn ( <string_literal> , new Object [ ] { node . getUuid ( ) , fex . getMessage ( ) } ) ; } } } \n \n \t4 @ Override \n \n \t4 public void handleThrowable ( SecurityContext securityContext , Throwable t , NodeInterface node ) { \n \n <ect>
<comment> \n \n \t2 public boolean recursiveParserExpressionVerifier ( String expression , ParsedWord [ ] words , FilterCallback cb ) \n \n \t2 { \n \n <ect>
\t3 pw = new PrintWriter ( fos ) ; \n \n \t3 for ( ActiveMQDestination destination : destinations ) { \n \n \t4 pw . println ( destination ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 } finally { \n \n \t2 bw . close ( ) ; } \n \n \t1 } else { \n \n \t2 <comment> \n \n <ect>
\t3 if ( handler != null ) { \n \n \t4 this . provider . destroy ( handler ) ; } } \n \n \t2 catch ( Throwable ex ) { \n \n <ect>
\t2 parentDir = FileUtils . createLocalDirsTempFile ( spillLocalDirs , <string_literal> , <string_literal> , true ) ; \n \n \t2 parentDir . deleteOnExit ( ) ; } \n \n \t1 if ( tmpFile == null || input != null ) { \n \n \t2 tmpFile = File . createTempFile ( <string_literal> , <string_literal> , parentDir ) ; \n \n <ect>
\t2 } catch ( NiciraNvpApiException exceptionDeleteLSwitchPort ) { \n \n \t3 s_logger . error ( <string_literal> + lSwitchPort . getUuid ( ) + <string_literal> + lSwitchPort . getDisplayName ( ) + <string_literal> + logicalSwitchUuid + <string_literal> + exceptionDeleteLSwitchPort . getMessage ( ) ) ; } \n \n \t2 s_logger . warn ( <string_literal> + lSwitchPort . getUuid ( ) + <string_literal> + lSwitchPort . getDisplayName ( ) + <string_literal> ) ; } \n \n \t1 private void cleanupLRouterPort ( String logicalRouterUuid , LogicalRouterPort lRouterPort , NiciraNvpApi niciraNvpApi ) { \n \n <ect>
\t3 final LoggerContext loggerContext = Configurator . initialize ( <string_literal> , null , logConfigurationFile . getURI ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 loggerContext . getConfiguration ( ) . addListener ( reconfigurable - > loggerContext . updateLoggers ( reconfigurable . reconfigure ( ) ) ) ; \n \n \t3 return Optional . of ( Pair . of ( logConfigurationFile , loggerContext ) ) ; } \n \n <ect>
\t3 metric . merge ( locusData ) ; \n \n \t3 log . debug ( <string_literal> + metric . nSites ) ; \n \n \t2 } else { \n \n \t3 metric . nThreeAllelesSites ++ ; \n \n <ect>
\t4 with dest_fileobj : \n \n \t5 bytes = self . _download_parts_to_fileobj ( \n \n \t6 manifest = manifest , dest_fileobj = dest_fileobj ) \n \n \t3 # Done with the download , now check the resulting image size . \n \n <ect>
\t1 @ Override \n \n \t1 public void clearStorage ( ) throws BackendException { \n \n \t2 try { \n \n \t3 if ( mode != Mode . CLOUD ) throw new UnsupportedOperationException ( <string_literal> ) ; \n \n <ect>
\t4 return transformer . apply ( iterator . next ( ) ) ; } \n \n \t3 try { \n \n \t4 close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 String name = getClassname ( ) . trim ( ) ; \n \n \t2 try { \n \n \t3 return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 configDir = getConfigurationDirectory ( ) ; \n \n \t2 configFile = System . getProperty ( OOZIE_CONFIG_FILE , SITE_CONFIG_FILE ) ; \n \n \t2 if ( configFile . contains ( <string_literal> ) ) { \n \n \t3 throw new ServiceException ( ErrorCode . E0022 , configFile ) ; } \n \n <ect>
\t3 mimeType = outputField ; \n \n \t2 String writerMimeType = mimeType ; \n \n \t2 if ( mimeType == null ) \n \n \t2 { \n \n <ect>
\t2 for ( GroovyPackageDoc packageDoc : rootDoc . specifiedPackages ( ) ) { \n \n \t3 sb . append ( packageDoc . nameWithDots ( ) ) ; \n \n \t3 sb . append ( <string_literal> ) ; } \n \n \t2 String destFileName = destdir + FS + <string_literal> ; \n \n <ect>
\t3 if ( connection . isMarkedCandidate ( ) ) { \n \n \t4 connection . doMark ( ) ; \n \n \t4 collectionCandidates . add ( connection ) ; } } } \n \n \t1 protected void doCollection ( TransportConnection tc ) { \n \n <ect>
\t3 pwdInfo . setConfirmation ( m_pw . getPassword2 ( ) ) ; \n \n \t3 pwdInfo . validate ( ) ; \n \n \t3 return true ; \n \n \t2 } catch ( CmsIllegalArgumentException | CmsIllegalStateException e ) { \n \n <ect>
\t4 url . append ( HELP_COMPONENTS ) . append ( ' # ' ) . append ( GuiPackage . getInstance ( ) . getTreeListener ( ) . getCurrentNode ( ) . getDocAnchor ( ) ) ; } \n \n \t3 try { \n \n \t4 helpDoc . setPage ( url . toString ( ) ) ; <comment> \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
<comment> \n \n \t1 private ReplyWaiter sendPing ( NodeInfo nInfo ) { \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t6 final OvsSetTagAndFlowAnswer r = ( OvsSetTagAndFlowAnswer ) citrixRequestWrapper . execute ( flowCmd , citrixResourceBase ) ; \n \n \t6 if ( ! r . getResult ( ) ) { \n \n \t7 s_logger . warn ( <string_literal> + r . getVmId ( ) ) ; \n \n \t6 } else { \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 if ( deliveryStreamNames . isEmpty ( ) ) { \n \n \t3 LOG . info ( <string_literal> + accountId ) ; \n \n \t2 } else { \n \n <ect>
\t1 conf . set ( HiveConf . ConfVars . METASTORE_FILTER_HOOK . varname , \n \n \t2 DefaultMetaStoreFilterHookImpl . class . getName ( ) ) ; \n \n \t1 init ( Hive . get ( conf ) ) ; \n \n \t1 } catch ( HiveException e ) { \n \n <ect>
\t2 } catch ( InterruptedException e ) { \n \n \t3 Log . error ( e , <string_literal> ) ; \n \n \t3 throw new RuntimeException ( e ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public Tree getTree ( String path ) { \n \n \t2 if ( NodeStateUtils . isHiddenPath ( path ) ) { \n \n \t3 if ( ! warnedHidden ) { \n \n \t4 warnedHidden = true ; \n \n <ect>
\t4 @ Override \n \n \t4 public void handleTransactionFailure ( SecurityContext securityContext , Throwable t ) { \n \n \t5 logger . warn ( <string_literal> , t . getMessage ( ) ) ; } \n \n \t3 } ) ; \n \n <ect>
\t1 if ( doomed . size ( ) > 0 ) \n \n \t2 removingLogs = true ; } \n \n \t1 <comment> \n \n \t1 for ( String logger : otherLogsCopy ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 restartListening ( newAddr , isIPv6 ) ; \n \n \t2 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 if ( this . negotiated && ! this . pendingSend ) { \n \n \t3 super . close ( ) ; \n \n \t3 return ; } \n \n \t2 closeReceived = true ; \n \n <ect>
\t3 final Unit unit = unitIterator . next ( ) ; \n \n \t3 if ( unit instanceof IdentityStmt ) { \n \n \t4 continue ; } \n \n \t3 return unit ; } \n \n <ect>
\t2 final String newName = <string_literal> + network . getNetworkRecord ( conn ) . uuid + <string_literal> + tag ; \n \n \t2 XsLocalNetwork vlanNic = getNetworkByName ( conn , newName ) ; \n \n \t2 if ( vlanNic == null ) { \n \n <ect>
\t3 principalType . toString ( ) , tableName , dbName , partitionName , columnName ) ; \n \n \t1 pm . retrieveAll ( mPrivs ) ; \n \n \t1 success = commitTransaction ( ) ; \n \n \t1 mSecurityColList . addAll ( mPrivs ) ; \n \n <ect>
\t4 pluggable . readPayload ( buffer , netSide , ctx ) ; \n \n \t3 } else if ( id == ID_CREATE_PLUG ) { \n \n \t4 readCreateInternal ( buffer ) ; \n \n \t3 } else { \n \n <ect>
\t1 public java . io . File toFile ( ) { \n \n \t2 logger . info ( <string_literal> ) ; return null ; } \n \n \t1 @ Override \n \n \t1 public WatchKey register ( WatchService ws , WatchEvent . Kind < ? > [ ] kinds , WatchEvent . Modifier . . . mdfrs ) throws IOException { \n \n <ect>
\t7 @ Override \n \n \t7 public void process ( Exchange exchange ) throws Exception { \n \n \t8 String replyTo = exchange . getIn ( ) . getHeader ( <string_literal> , String . class ) ; \n \n \t8 String cid = exchange . getIn ( ) . getHeader ( <string_literal> , String . class ) ; \n \n <ect>
\t5 <comment> \n \n \t5 return false ; } \n \n \t4 else if ( / ^Access is denied / . test ( de . message ) ) { \n \n \t5 <comment> \n \n <ect>
\t6 break ; } \n \n \t5 buffer . append ( line ) ; } \n \n \t4 newUris = buffer . toString ( ) ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t1 } ) \n \n \t1 readyJobs = getReadyJobs } } \n \n private def logEdge ( edge : FunctionEdge ) { \n \n \t1 logger . info ( <string_literal> ) \n \n <ect>
\t1 protected BlockingQueueTransport getTransportChannel ( HttpServletRequest request , HttpServletResponse response ) throws IOException { \n \n \t2 String clientID = request . getHeader ( <string_literal> ) ; \n \n \t2 if ( clientID == null ) { \n \n \t3 response . sendError ( HttpServletResponse . SC_BAD_REQUEST , <string_literal> ) ; \n \n <ect>
\t5 logger . warn ( <string_literal> , itemName ) ; \n \n \t4 } else { \n \n \t5 sendCommand ( c , command ) ; } } } \n \n \t2 if ( ! commandHandled ) { \n \n <ect>
\t5 continue ; <comment> \n \n \t4 VMTemplateVO template = new VMTemplateVO ( id , uniqueName , name , format , isPublic , featured , TemplateType . valueOf ( tmpltType ) , url , createdDate , requiresHVM , bits , templateAccountId , checksum , displayText , enablePassword , guestOSId , true , null ) ; \n \n \t4 permittedTemplates . add ( template ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 power . setSubId ( subIdPower ) ; \n \n \t2 power . setUid ( getUid ( ) ) ; \n \n \t2 power . init ( ) ; \n \n \t2 power . setMbrick ( this ) ; \n \n <ect>
public SolrDAO solrDAO ( @ Value ( <string_literal> ) DocumentArchivingProperties properties ) { \n \n \t1 return new SolrDAO ( properties . getSolr ( ) ) ; } \n \n private File outFile ( String collection , File directoryPath , String suffix ) { \n \n \t1 File file = new File ( directoryPath , String . format ( <string_literal> , collection , suffix ) ) ; \n \n <ect>
\t3 <comment> \n \n \t3 fireMessageDeliveryFailed ( original , to , e . getErrorCode ( ) ) ; } \n \n \t2 catch ( RuntimeException e ) \n \n \t2 { \n \n <ect>
\t4 lineNumber ++ ; } \n \n \t3 String s = sql . toString ( ) . trim ( ) ; \n \n \t3 if ( ! <string_literal> . equals ( s ) ) { \n \n \t4 stmt . execute ( s ) ; } \n \n <ect>
public void testUserPrivilegesForTable ( ) throws Exception { \n \n \t1 String user1 = testName . getMethodName ( ) ; \n \n \t1 final File user1Keytab = new File ( kdc . getKeytabDir ( ) , user1 + <string_literal> ) ; \n \n \t1 if ( user1Keytab . exists ( ) && ! user1Keytab . delete ( ) ) { \n \n <ect>
\t1 return false ; } } \n \n public static boolean renameFile ( File srcFile , File destFile ) { \n \n \t1 boolean isRenamed = false ; \n \n \t1 if ( srcFile != null && destFile != null ) { \n \n <ect>
\t1 try { \n \n \t1 config . createLogLevelFilter ( logFeederProps . getClusterName ( ) , logId , defaultFilter ) ; \n \n \t1 filters . put ( logId , defaultFilter ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 parameters . put ( <string_literal> , Boolean . TRUE ) ; \n \n \t2 } else { \n \n \t3 parameters . put ( <string_literal> , Boolean . FALSE ) ; } \n \n \t2 reportFile = null ; \n \n <ect>
\t2 URI fakeUri ; \n \n \t2 try { \n \n \t3 fakeUri = new URI ( <string_literal> ) ; \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
\t3 protected void runInContext ( ) { \n \n \t4 try { \n \n \t5 reallyRun ( ) ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t2 return mkDir ( getFile ( <string_literal> ) ) ; } \n \n \t1 public File mkDir ( File file ) { \n \n \t2 if ( ! file . exists ( ) ) { \n \n \t3 if ( file . mkdirs ( ) ) { \n \n <ect>
\t2 Assert . assertEquals ( portClient5 , s5 . getClientPort ( ) ) ; \n \n \t2 if ( withObservers ) { \n \n \t3 s4 . setLearnerType ( LearnerType . OBSERVER ) ; \n \n \t3 s5 . setLearnerType ( LearnerType . OBSERVER ) ; } \n \n <ect>
\t2 } catch { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 case e : Exception = > \n \n <ect>
\t3 activeEnv = <string_literal> ; } \n \n \t2 String file = <string_literal> + activeEnv + <string_literal> ; \n \n \t2 URL url = AppConfig . class . getResource ( file ) ; \n \n \t2 if ( url == null ) { \n \n <ect>
\t8 RebalanceTaskInfo stealInfo , \n \n \t8 boolean isReadOnlyStore ) { \n \n \t2 <comment> \n \n \t2 if ( stealInfo . getPartitionIds ( storeName ) != null && stealInfo . getPartitionIds ( storeName ) . size ( ) > 0 ) { \n \n <ect>
\t1 } catch ( KeeperException e ) { \n \n \t2 switch ( e . code ( ) ) { \n \n \t2 case CONNECTIONLOSS : \n \n \t2 case OPERATIONTIMEOUT : \n \n <ect>
\t5 } else if ( entry . getKey ( ) . equalsIgnoreCase ( <string_literal> ) ) { \n \n \t6 try { \n \n \t7 info . setTimeout ( Integer . valueOf ( entry . getValue ( ) ) ) ; \n \n \t6 } catch ( final NumberFormatException e ) { \n \n <ect>
\t4 try { \n \n \t5 logger . trace ( <string_literal> , time , timeUnit ) ; \n \n \t5 awaitBarrier . wait ( translateTimeUnit ( time , timeUnit ) ) ; \n \n \t4 } catch ( Throwable e ) { \n \n <ect>
\t3 if ( ObjectHelper . isNotEmpty ( endpoint . getBranchName ( ) ) ) { \n \n \t4 git . checkout ( ) . setCreateBranch ( false ) . setName ( endpoint . getBranchName ( ) ) . call ( ) ; } \n \n \t3 status = git . status ( ) . call ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 test . check ( VersioningProfile . getLatestVersion ( cos [ i - 1 ] . name ( ) , putHandle . getDefaultPublisher ( ) , <number_literal> , putVerifier , getHandle ) , i ) ; } \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void testRecall ( ) { \n \n <ect>
\t10 final SamlRegisteredServiceServiceProviderMetadataFacade adaptor , \n \n \t10 final HttpServletResponse response , \n \n \t10 final HttpServletRequest request , \n \n \t10 final String binding ) throws SamlException { \n \n <ect>
\t4 } else if ( logMINOR && validCache && ! likelyMatch ) \n \n \t5 Logger . minor ( this , <string_literal> ) ; \n \n \t4 return null ; } \n \n \t3 if ( validCache && ! likelyMatch ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n \t2 try { \n \n <ect>
\t3 signalError ( ) ; \n \n \t2 } catch ( ExecutionException e ) { \n \n \t3 <comment> \n \n \t3 if ( ! isShutdown ) \n \n <ect>
\t2 throw new MuleRuntimeException ( e ) ; } } } \n \n private void doOnTransition ( String phaseName , T object ) throws MuleException { \n \n \t1 LifecyclePhase phase = registryLifecycleManager . phases . get ( phaseName ) ; \n \n <ect>
\t2 } catch ( IOException ex ) { \n \n \t3 log . error ( <string_literal> , ex ) ; \n \n \t3 fail ( <string_literal> + ex . getMessage ( ) ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t3 value . put ( new Text ( entry . getKey ( ) ) , \n \n \t4 entry . getValue ( ) == null ? NullWritable . get ( ) : new ObjectWritable ( entry . getValue ( ) ) ) ; } \n \n \t2 return true ; } \n \n \t2 else { \n \n <ect>
\t2 Configuration runConf = null ; \n \n \t2 try { \n \n \t3 runConf = new XConfiguration ( new StringReader ( jobConf ) ) ; } \n \n \t2 catch ( IOException e1 ) { \n \n <ect>
\t4 ( Integer ) converter . convertFromCommandToValue ( item , command ) , dbParameter . Size ) ; \n \n \t2 <comment> \n \n \t2 SerialMessage serialMessage = commandClass . setConfigMessage ( configurationParameter ) ; \n \n \t2 if ( serialMessage == null ) { \n \n <ect>
\t1 @ Nullable public JobQueryConfig getJobQueryConfig ( String jobId ) { \n \n \t2 try { \n \n \t3 return configCache . get ( jobId ) ; \n \n \t2 } catch ( ExecutionException e ) { \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t3 log . error ( <string_literal> , e . getMessage ( ) , e ) ; } \n \n \t3 fs . deleteRecursively ( outputFile . path ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 LOG . debug ( <string_literal> + url ) ; \n \n \t1 try { \n \n \t1 return DriverManager . getConnection ( url ) ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t5 is . close ( ) ; } } \n \n \t3 catch ( DataStorageException e ) { \n \n \t4 throw new IOException ( <string_literal> + path , e ) ; } \n \n \t2 } else { \n \n <ect>
\t2 final String maxAsString = getMaximumValue ( ) ; \n \n \t2 long maximum = NumberUtils . toLong ( maxAsString ) ; \n \n \t2 long rangeL = maximum - minimum + 1 ; <comment> \n \n \t2 if ( minimum > maximum ) { \n \n <ect>
\t2 if ( inputStream != null ) { \n \n \t2 try { \n \n \t3 inputStream . close ( ) ; \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
\t1 return propDesc . getPropertyType ( ) ; } \n \n private static PropertyDescriptor getPropertyDescriptor ( Class targetClass , String propertyName ) { \n \n \t1 PropertyDescriptor result = null ; \n \n \t1 if ( targetClass == null ) { \n \n <ect>
@ Override \n \n public void dropPartitions ( String dbName , String tableName , \n \n \t4 Map < String , String > partitionSpec , boolean ifExists , boolean deleteData ) \n \n \t1 throws HCatException { \n \n <ect>
\t6 throw new GridSpiException ( <string_literal> + \n \n \t7 <string_literal> + locPort + <string_literal> + ( locPort + locPortRange - 1 ) + \n \n \t7 <string_literal> + locHost + ' ] ' , e ) ; } } } \n \n <ect>
\t2 log . debug ( <string_literal> , <string_literal> ) ; \n \n \t2 return null ; } \n \n \t1 @ Override \n \n \t1 protected Package [ ] getPackages ( ) { \n \n <ect>
\t5 int ord = Integer . parseInt ( c2 . substring ( 0 , 1 ) , <number_literal> ) ; \n \n \t5 text = c2 . substring ( <number_literal> ) ; \n \n \t5 color = ColourUtil . getLightHex ( EnumDyeColor . byMetadata ( ord ) ) ; \n \n \t4 } catch ( NumberFormatException nfe ) { \n \n <ect>
private static final long MIN_SHMMAX = 536870912L <comment> \n \n private PostgresCommands newCommands <comment> \n \n private PostgresCommands oldCommands <comment> \n \n private CommandResult runProcess ( List < String > args , Map < String , String > environment = [ : ] ) { \n \n <ect>
\t3 prevWindowEvents . addAll ( windowEvents ) ; \n \n \t3 LOG . debug ( <string_literal> , events . size ( ) ) ; \n \n \t3 windowLifecycleListener . onActivation ( events , newEvents , expired ) ; \n \n \t2 } else { \n \n <ect>
\t3 ) \n \n \t2 ) . list ( ) ; \n \n \t2 for ( final CertificateEntity entity : entities ) { \n \n \t2 if ( entity . revoked ) { \n \n <ect>
\t6 @ Override \n \n \t6 public void uncaughtException ( Thread t , Throwable e ) { \n \n \t7 exceptionCount ++ ; \n \n \t7 LOG . debug ( <string_literal> , e ) ; \n \n <ect>
\t3 try { \n \n \t4 s_logger . trace ( <string_literal> ) ; \n \n \t4 _conn . setAutoCommit ( false ) ; \n \n \t3 } catch ( final SQLException e ) { \n \n <ect>
\t3 } catch ( Exception e ) { \n \n \t3 LOG . error ( <string_literal> , e ) } } \n \n \t2 } ) \n \n \t1 if ( isRunning ( ) ) { \n \n <ect>
\t3 if ( ! _networkMgr . releasePublicIpAddress ( lb . getSourceIpAddressId ( ) , UserContext . current ( ) . getCallerUserId ( ) , UserContext . current ( ) . getCaller ( ) ) ) { \n \n \t4 s_logger . warn ( <string_literal> + lb . getSourceIpAddressId ( ) + <string_literal> ) ; \n \n \t4 success = false ; \n \n \t3 } else { \n \n <ect>
\t1 @ Override \n \n \t1 public boolean startEmbeddedBroker ( final Properties configuration ) \n \n \t3 throws Exception { \n \n \t2 if ( LOGGER . isLoggable ( Level . INFO ) ) { \n \n <ect>
\t1 if ( context . getCluster ( ) != null ) { \n \n \t2 auth = getConfigurationFromAmbari ( ) ; \n \n \t1 } else { \n \n \t2 auth = <string_literal> ; \n \n <ect>
\t4 disconnectedClientLogger . debug ( <string_literal> + ex + \n \n \t6 <string_literal> + DISCONNECTED_CLIENT_LOG_CATEGORY + \n \n \t6 <string_literal> ) ; } } \n \n \t2 else { \n \n <ect>
\t4 if ( ! _outOfSync ) \n \n \t5 _log . error ( <string_literal> + value + <string_literal> + ( _lastReceived + 1 ) + <string_literal> \n \n \t7 + _connectionId + <string_literal> + _remoteDestination . substring ( 0 , <number_literal> ) ) ; \n \n \t4 else \n \n <ect>
\t3 return Response . ok ( randomInstance ) . build ( ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n \t3 ThreadUtils . checkInterrupted ( e ) ; \n \n <ect>
\t5 MessageProducer producer = session . createProducer ( new ActiveMQQueue ( getDestinationName ( ) ) ) ; \n \n \t5 for ( int idx = 0 ; idx < MESSAGES_COUNT ; ++ idx ) { \n \n \t6 Message message = session . createTextMessage ( <string_literal> + idx ) ; \n \n \t6 producer . send ( message ) ; \n \n <ect>
\t4 result = new DefaultPrincipal ( pmv . getAccountId ( ) , pmv . getOpenSocialId ( ) , pmv . getId ( ) ) ; } \n \n \t3 <comment> \n \n \t3 else \n \n \t3 { \n \n <ect>
\t4 log . info ( <string_literal> + hadoopVersionString ) ; \n \n \t3 } else { \n \n \t4 log . info ( <string_literal> ) ; } \n \n \t3 if ( options . length == 0 ) { \n \n <ect>
public void testSimple ( ) { \n \n \t1 BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; \n \n \t1 Logger logger = Logger . getLogger ( <string_literal> ) ; \n \n \t1 int i = 0 ; \n \n <ect>
\t4 jobOutput . setContent ( output ) ; } \n \n \t3 executableDao . updateJobOutput ( jobOutput ) ; \n \n \t3 logger . info ( <string_literal> + jobId + <string_literal> + oldStatus + <string_literal> + newStatus ) ; \n \n \t2 } catch ( PersistentException e ) { \n \n <ect>
\t2 PojoListener ( int failFrequency ) { \n \n \t3 this . failFrequency = failFrequency ; } \n \n \t2 @ SuppressWarnings ( <string_literal> ) \n \n \t2 public void handleMessage ( int value ) throws Exception { \n \n <ect>
\t1 public void warnNonexistentPhase ( ) { \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
\t3 List < Page > pages = this . createTestNodes ( Page . class , 1 ) ; \n \n \t3 if ( ! pages . isEmpty ( ) ) { \n \n \t4 return pages . get ( 0 ) ; } \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t1 HeartBeatResponse heartBeatResponse ; \n \n \t1 try { \n \n \t2 if ( ! agentSessionManager . isRegistered ( simpSessionId ) ) { \n \n \t2 <comment> \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t5 if ( rs != null && rs . first ( ) ) { \n \n \t6 return rs . getInt ( 1 ) > 0 ; } \n \n \t5 s_logger . error ( <string_literal> ) ; } } \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t5 sim . getPlayer ( currentPlayer . getId ( ) ) . pass ( game ) ; \n \n \t5 sim . getPlayerList ( ) . getNext ( ) ; } \n \n \t4 SimulationNode newNode = new SimulationNode ( node , sim , action , currentPlayer . getId ( ) ) ; \n \n <ect>
\t2 return result ; } \n \n \t1 public synchronized void purge ( ) throws Exception { \n \n \t2 final long originalMessageCount = destination . getDestinationStatistics ( ) . getMessages ( ) . getCount ( ) ; \n \n \t2 ( ( Queue ) destination ) . purge ( ) ; \n \n <ect>
\t4 ? param : Constants . PATH_INTERNAL ; } \n \n \t1 private void handleSendSystemAudioModeRequestTimeout ( ) { \n \n \t2 if ( ! mTargetAudioStatus <comment> \n \n \t4 || mSendRetryCount ++ >= MAX_SEND_RETRY_COUNT ) { \n \n <ect>
\t2 try { \n \n \t3 CloudStackUserVm vm = client . call ( command , API_KEY , SECRET_KEY , true , <string_literal> , <string_literal> , CloudStackUserVm . class ) ; \n \n \t3 Assert . assertTrue ( vm . getId ( ) == <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 LOGGER . debug ( <string_literal> , key , s ) ; \n \n \t6 attributes . put ( s , CollectionUtils . wrap ( attribute . toString ( ) ) ) ; \n \n \t5 } ) ; \n \n \t4 } else { \n \n <ect>
\t2 if ( timeSinceReceived > ( BuildRequestor . REQUEST_TIMEOUT * <number_literal> ) ) { \n \n \t3 <comment> \n \n \t3 _context . throttle ( ) . setTunnelStatus ( _x ( <string_literal> ) ) ; \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 if ( ! fs . getConf ( ) . getBoolean ( DFS_SUPPORT_APPEND , true ) ) { \n \n \t2 String msg = <string_literal> + DFS_SUPPORT_APPEND \n \n \t3 + <string_literal> + ticketMessage ; \n \n \t2 <comment> \n \n <ect>
\t5 _log . debug ( <string_literal> + t . getStyle ( ) + <string_literal> + bid + <string_literal> + ( rv == bid ) \n \n \t7 + <string_literal> + rv . getLatencyMs ( ) + <string_literal> + rv + <string_literal> ) ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t2 { \n \n \t3 endTime = System . currentTimeMillis ( ) ; \n \n \t3 log . debug ( <string_literal> + ( endTime - startTime ) ) ; \n \n <ect>
\t2 CustomButtonAction abortAction = new CustomButtonAction ( <string_literal> , new Runnable ( ) { \n \n \t3 @ Override \n \n \t3 public void run ( ) { \n \n \t4 context . errorMessage ( <string_literal> ) ; \n \n <ect>
\t2 String keyStr = <string_literal> ; \n \n \t2 try { \n \n \t2 authStr = new String ( authData , <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 WebSocketServerHandler . SESSION_ATTR_WS_STATUS ) ) ) { \n \n \t2 <comment> \n \n \t2 final MessageQueue queue = service . getBus ( ) . getQueueBySession ( sessionKey ) ; \n \n \t2 queue . setDeliveryHandler ( DirectDeliveryHandler . createFor ( queueChannel ) ) ; \n \n <ect>
\t3 TunnelPool pool = cfg . getTunnelPool ( ) ; \n \n \t3 if ( pool == null ) { \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t9 part . rent ( false ) ; \n \n \t9 updateLocal ( part . id ( ) , locId , part . state ( ) , updateSeq ) ; \n \n \t9 changed = true ; \n \n <ect>
private void warnIfTopologyNameContainsWarnString ( String name ) { \n \n \t1 for ( String warn : WARN_STRINGS_FOR_TOPOLOGY_OR_COMPONENT_NAME ) { \n \n \t1 if ( name . contains ( warn ) ) { \n \n \t2 LOG . warn ( <string_literal> <string_literal> \\ <string_literal> <string_literal> \\ <string_literal> ) ; \n \n <ect>
\t1 <string_literal> <string_literal> <string_literal> \n \n <ect>
\t3 getContext ( ) . profileManager ( ) . dbLookupFailed ( h ) ; } \n \n \t2 long time = System . currentTimeMillis ( ) - _created ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) { \n \n \t3 long timeRemaining = _expiration - getContext ( ) . clock ( ) . now ( ) ; \n \n <ect>
\t4 log . info ( <string_literal> + fn ) ; \n \n \t4 Model m = readAssemblerFile ( fn ) ; \n \n \t4 readConfiguration ( m , dsDescMap , dataServiceRef ) ; } \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void testVanilla ( ) throws Exception { \n \n \t2 Client client = ClientBuilder . newClient ( ) ; \n \n <ect>
<comment> \n \n \t1 runStatementOnDriver ( <string_literal> + Table . ACIDTBL + <string_literal> + Table . ACIDTBL + <string_literal> + Table . ACIDTBL + <string_literal> , confForTez ) ; \n \n \t1 List < String > rs = runStatementOnDriver ( <string_literal> , confForTez ) ; \n \n <ect>
\t4 _log . warn ( <string_literal> + state ) ; \n \n \t3 return ; } \n \n \t2 if ( state . incrementPacketsRelayed ( ) > MAX_RELAYED_PER_TEST_BOB ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t6 answer = ( DestroyLoadBalancerApplianceAnswer ) _agentMgr . easySend ( lbDevice . getParentHostId ( ) , lbDeleteCmd ) ; \n \n \t6 if ( answer == null || ! answer . getResult ( ) ) { \n \n \t7 s_logger . warn ( <string_literal> + guestConfig . getId ( ) + <string_literal> + answer . getDetails ( ) ) ; } \n \n \t5 } catch ( Exception e ) { \n \n <ect>
private final Stopwatch stopwatch = Stopwatch . createUnstarted ( ) ; \n \n public LocalCommand ( Logger logger , OutputPolicy outputPolicy , String command ) throws IOException { \n \n \t1 this . commandId = localCommandCounter . incrementAndGet ( ) ; \n \n \t1 this . logger = logger ; \n \n <ect>
\t2 s_logger . info ( <string_literal> + url ) ; \n \n \t2 client = new HttpClient ( ) ; \n \n \t2 method = new GetMethod ( url ) ; \n \n \t2 responseCode = client . executeMethod ( method ) ; \n \n <ect>
\t1 @ Test \n \n \t1 public void testWithEncoder ( ) { \n \n \t2 this . applicationContext . getBean ( SingleConnectionFactory . class ) . createConnection ( ) . close ( ) ; \n \n \t2 Logger log = ( Logger ) LoggerFactory . getLogger ( <string_literal> ) ; \n \n <ect>
\t5 throw new LowLevelPutException ( LowLevelPutException . INTERNAL_ERROR , e . toString ( ) + <string_literal> + e . getMessage ( ) , e ) ; \n \n \t4 } catch ( InvalidCompressionCodecException e ) { \n \n \t5 throw new LowLevelPutException ( LowLevelPutException . INTERNAL_ERROR , e . toString ( ) + <string_literal> + e . getMessage ( ) , e ) ; } \n \n \t4 if ( b == null ) { \n \n <ect>
\t3 for ( String element : elements ) { \n \n \t4 String path = PathUtils . normalize_path ( parent + Cluster . ZK_SEPERATOR + element ) ; \n \n \t4 nodes . add ( new ZookeeperNode ( parent , element , hasChildren ( clusterState , path ) ) ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 user . setIsCustomerService ( false ) ; \n \n \t2 user . setIsEngineering ( true ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 ec . saveChanges ( ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 try { \n \n \t5 if ( statement != null ) { \n \n \t6 statement . close ( ) ; } } \n \n \t4 catch ( SQLException e ) { \n \n <ect>
\t2 else if ( extraPeerDataType == Node . EXTRA_PEER_DATA_TYPE_DOWNLOAD ) { \n \n \t3 Logger . normal ( this , <string_literal> + fs . toString ( ) ) ; \n \n \t3 handleFproxyDownloadFeed ( fs , fileNumber ) ; \n \n \t3 return true ; } \n \n <ect>
\t2 for ( String oldPrefix : old2newPrefix . keySet ( ) ) { \n \n \t3 if ( key . startsWith ( oldPrefix ) ) { \n \n \t4 String newPrefix = old2newPrefix . get ( oldPrefix ) ; \n \n \t4 newKey = newPrefix + key . substring ( oldPrefix . length ( ) ) ; \n \n <ect>
\t2 final String mapName = metadata . getProperties ( ) . getStorageName ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , mapName , metadata ) ; \n \n \t2 return getIgniteCacheInstanceByName ( mapName ) ; } \n \n \t1 private IgniteCache < String , Ticket > getIgniteCacheInstanceByName ( final String name ) { \n \n <ect>
\t3 try { \n \n \t4 dm = conn . domainLookupByID ( ids [ i ] ) ; \n \n \t4 la . add ( dm . getName ( ) ) ; \n \n \t3 } catch ( final LibvirtException e ) { \n \n <ect>
\t2 _transport . getPumper ( ) . wantsWrite ( this , buf . encrypted ) ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
import org . slf4j . LoggerFactory ; \n \n public class LoggingUncaughtExceptionHandler implements Thread . UncaughtExceptionHandler { \n \n protected transient Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; \n \n public void uncaughtException ( Thread thread , Throwable throwable ) { \n \n <ect>
\t4 Flog . warn ( <string_literal> , b . path ) ; } } \n \n \t2 b . cancelTimeout ( ) ; \n \n \t2 String md5Before = DigestUtils . md5Hex ( viewText ) ; \n \n \t2 if ( ! md5Before . equals ( res . md5_before ) ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected EntityManagerFactory createNativeEntityManagerFactory ( ) throws PersistenceException { \n \n <ect>
\t4 zController . notifyEventListeners ( new ZWaveInclusionEvent ( ZWaveInclusionEvent . Type . IncludeSlaveFound , \n \n \t6 incomingMessage . getMessagePayloadByte ( <number_literal> ) ) ) ; \n \n \t4 break ; \n \n \t3 case ADD_NODE_STATUS_ADDING_CONTROLLER : \n \n <ect>
\t5 ClusterState state = clusterService . state ( ) ; \n \n \t6 logger . error ( ( ) - > new ParameterizedMessage ( <string_literal> , source , state ) , e ) ; \n \n \t5 } else { \n \n <ect>
\t4 try { \n \n \t5 long newCount = insertCount . get ( ) ; \n \n <comment> \n \n <comment> \n \n <ect>
\t5 } else { \n \n \t6 toDiscard . add ( id ) ; } } \n \n \t4 for ( TransactionId tx : toRollback ) { \n \n <ect>
\t2 sendRequest ( requestDocument , SoapAction . SIGNAL ) ; \n \n \t2 logger . debug ( <string_literal> , commandId , shellId ) ; } \n \n \t1 public void deleteShell ( ) { \n \n \t2 if ( shellId == null ) { \n \n <ect>
\t2 { \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t4 if ( commit ) { \n \n \t5 session . commit ( ) ; \n \n \t4 } else { \n \n \t5 session . rollback ( ) ; } } \n \n <ect>
\t1 try { \n \n \t1 String [ ] databases = manager . listDatabases ( ) ; \n \n \t1 if ( null == databases ) { \n \n \t2 System . err . println ( <string_literal> ) ; \n \n <ect>
\t2 partNames . add ( p . getName ( ) ) ; } \n \n \t2 getMSC ( ) . addDynamicPartitions ( parentSession . getTxnMgr ( ) . getCurrentTxnId ( ) , writeId , \n \n \t4 tbl . getDbName ( ) , tbl . getTableName ( ) , partNames , \n \n \t4 AcidUtils . toDataOperationType ( operation ) ) ; } \n \n <ect>
\t3 return emptyOptional ( ) ; } \n \n \t2 try { \n \n \t3 return optional ( new XZInputStream ( new ByteArrayInputStream ( buffer ) ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 } catch ( ConcurrentOperationException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . INTERNAL_ERROR , e . getMessage ( ) ) ; \n \n \t2 } catch ( ManagementServerException e ) { \n \n <ect>
\t2 case ADD_INTO_PROJECT : { \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 break ; } \n \n \t2 case PURGE_AND_DISABLE : { \n \n <ect>
\t1 protected void importUser ( long userId , String password ) throws Exception { \n \n \t2 Connection connection = connect ( ) ; \n \n \t2 AccountManager accountManager = connection . getAccountManager ( ) ; \n \n \t2 if ( ! accountManager . supportsAccountCreation ( ) ) { \n \n <ect>
\t3 final String msg = <string_literal> ; \n \n \t3 s_logger . warn ( msg ) ; \n \n \t3 return new PlugNicAnswer ( cmd , false , msg ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t1 if ( hiveConfig . getBoolVar ( HiveConf . ConfVars . METASTORE_CLIENT_DROP_PARTITIONS_WITH_EXPRESSIONS ) ) { \n \n \t2 try { \n \n \t2 dropPartitionsUsingExpressions ( table , partitionSpec , ifExists , deleteData ) ; } \n \n \t2 catch ( SemanticException parseFailure ) { \n \n <ect>
\t1 logger . debug ( <string_literal> ) ; \n \n \t1 super . start ( ) ; } \n \n @ Override \n \n public void stop ( ) { \n \n <ect>
\t2 String methodName = System . getProperty ( <string_literal> ) ; \n \n \t2 if ( methodName == null ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t9 && ( host . getType ( ) == Host . Type . ConsoleProxy || host . getType ( ) == Host . Type . SecondaryStorageVM || host . getType ( ) == Host . Type . SecondaryStorageCmdExecutor ) ) { \n \n \t8 s_logger . warn ( <string_literal> + host . getId ( ) ) ; \n \n \t8 disconnectWithoutInvestigation ( agentId , Event . ShutdownRequested ) ; \n \n \t7 } else { \n \n <ect>
\t2 if ( doExport ) { \n \n \t3 try { \n \n \t4 Files . copy ( src , targetPath , StandardCopyOption . REPLACE_EXISTING ) ; \n \n \t3 } catch ( IOException ioex ) { \n \n <ect>
\t2 <comment> \n \n \t2 headers . put ( <string_literal> , null ) ; \n \n \t2 final Person result = requestBodyAndHeaders ( <string_literal> , null , headers ) ; \n \n \t2 assertNotNull ( <string_literal> , result ) ; \n \n <ect>
\t4 VMTemplateStoragePoolVO destTmpltPool = templatePoolDao . findByPoolTemplate ( dataStore . getId ( ) , objId ) ; \n \n \t4 if ( destTmpltPool != null ) { \n \n \t5 return templatePoolDao . remove ( destTmpltPool . getId ( ) ) ; \n \n \t4 } else { \n \n <ect>
\t5 lastUpdateTimeStamp = 0L ; } \n \n \t4 long age = System . currentTimeMillis ( ) - lastUpdateTimeStamp ; \n \n \t4 boolean needsUpdate = age >= refreshInterval ; \n \n \t4 if ( needsUpdate ) { \n \n <ect>
\t3 } catch ( ClassNotFoundException e ) { \n \n \t4 Log . warning ( <string_literal> + keyCacheFile . getAbsolutePath ( ) , e ) ; } \n \n \t2 } else { \n \n \t3 if ( Log . isLoggable ( Log . FAC_KEYS , Level . INFO ) ) { \n \n <ect>
\t7 ) { \n \n \t6 boolean validate = testConnectionInternal ( poolableConnection . holder , poolableConnection . conn ) ; \n \n \t6 if ( ! validate ) { \n \n <ect>
\t2 if ( this . readerHintMap . containsKey ( hintType ) ) { \n \n \t3 this . readerHintMap . remove ( hintType ) ; \n \n \t3 LOG . info ( String . format ( <string_literal> , hintType . toString ( ) ) ) ; \n \n \t2 } else { \n \n <ect>
\t3 s . createQuery ( <string_literal> ) . executeUpdate ( ) ; \n \n \t3 s . createQuery ( <string_literal> ) . executeUpdate ( ) ; \n \n \t3 s . getTransaction ( ) . commit ( ) ; } \n \n \t2 catch ( Throwable t ) { \n \n <ect>
\t3 command . add ( <string_literal> , pName ) ; \n \n \t3 command . add ( <string_literal> , brName ) ; \n \n \t3 final String result = command . execute ( ) ; \n \n \t3 if ( result != null ) { \n \n <ect>
\t4 . collect ( Collectors . toSet ( ) ) ; } \n \n \t1 @ Override \n \n \t1 public Ticket updateTicket ( final Ticket ticket ) { \n \n \t2 try { \n \n <ect>
\t2 <comment> \n \n \t2 ILock lock = clusterInstance . getLock ( path ) ; \n \n \t2 lock . lock ( ) ; \n \n \t2 <comment> \n \n <ect>
\t6 m_feature . publish ( new DecimalType ( batteryLevel ) , StateChangeType . CHANGED , <string_literal> , \n \n \t8 <string_literal> ) ; \n \n \t6 break ; \n \n \t5 default : \n \n <ect>
\t2 if ( _log . shouldLog ( Log . WARN ) ) { \n \n \t3 if ( success ) \n \n \t4 _log . warn ( <string_literal> + port + <string_literal> + Addresses . toString ( ip , externalPort ) ) ; \n \n \t3 else \n \n <ect>
\t1 public Set < Event > resolveInternal ( final RequestContext context ) { \n \n \t2 final RegisteredService service = resolveRegisteredServiceInRequestContext ( context ) ; \n \n \t2 final Authentication authentication = WebUtils . getAuthentication ( context ) ; \n \n \t2 if ( authentication == null ) { \n \n <ect>
\t6 } else { \n \n \t7 toolBar . add ( makeButtonItemRes ( iconToolbarBean ) ) ; } \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t3 log . debug ( <string_literal> ) \n \n \t3 <comment> \n \n \t3 type . declaredMethods . each { Method m - > \n \n \t4 if ( ! ( m . name in [ 'main' , 'run' ] || m . name . startsWith ( 'super$' ) || m . name . startsWith ( 'class$' ) || m . name . startsWith ( '$' ) ) ) { \n \n <ect>
\t1 assertTrue ( <string_literal> , false ) ; \n \n \t1 mLog . error ( <string_literal> ) ; } } \n \n @ Test \n \n public void testGetCheckedoutDocs ( ) { \n \n <ect>
\t2 <comment> \n \n \t2 TabletLocator . getLocator ( context , tableId ) . invalidateCache ( tabLoc . tablet_extent ) ; \n \n \t2 throw cve ; \n \n \t1 } catch ( TException e ) { \n \n <ect>
\t6 LOG . warn ( <string_literal> , answer ) ; } \n \n \t4 } else { \n \n \t5 LOG . warn ( <string_literal> , type . getName ( ) ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
<number_literal> + storeDefinition . getName ( ) + <string_literal> , \n \n \t9 nodeSampleResult . exception ) ; } \n \n \t4 } catch ( ExecutionException ee ) { \n \n \t5 success = false ; \n \n <ect>
\t4 try { \n \n \t5 value = fileItem . getString ( partEncoding ) ; } \n \n \t4 catch ( UnsupportedEncodingException ex ) { \n \n <ect>
\t5 EOSortOrdering sortOrdering = new EOSortOrdering ( sortKey , ERXArrayUtilities . sortSelectorWithKey ( sortSelectorKey ) ) ; \n \n \t5 validatedSortOrderings . addObject ( sortOrdering ) ; } } \n \n \t4 sortOrderings = validatedSortOrderings ; \n \n <ect>
\t3 { \n \n \t4 executeExceptionRequestHandler ( exception , retryCount - 1 ) ; } \n \n \t3 else \n \n \t3 { \n \n <ect>
\t2 try { \n \n \t3 dest . dispose ( context ) ; \n \n \t3 dest . stop ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 DecoratorsVisitList . add ( DecoratorsVisitList . WRITER_INTERCEPTOR_ENTER ) ; \n \n \t2 context . proceed ( ) ; \n \n \t2 DecoratorsVisitList . add ( DecoratorsVisitList . WRITER_INTERCEPTOR_LEAVE ) ; \n \n <ect>
\t1 try { \n \n \t2 decodeWritable ( key , keyStr ) ; \n \n \t2 keys . put ( key . getKeyId ( ) , key ) ; \n \n \t1 } catch ( IOException ex ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 int availBps = Math . min ( ( maxKBpsIn * <number_literal> * <number_literal> / <number_literal> ) - usedIn , ( maxKBpsOut * <number_literal> * <number_literal> / <number_literal> ) - usedOut ) ; \n \n \t2 if ( availBps < MIN_AVAILABLE_BPS ) { \n \n <ect>
\t2 String [ ] command = null ; \n \n \t2 try { \n \n \t3 command = ( String [ ] ) params . get ( <string_literal> ) ; \n \n \t3 if ( command == null ) { \n \n <ect>
\t4 } else { \n \n \t5 setPropertyMethodVoid . invoke ( o , params ) ; \n \n \t5 return true ; } } \n \n \t2 } catch ( IllegalArgumentException ex2 ) { \n \n <ect>
\t3 if ( rs != null ) { \n \n \t4 try { \n \n \t5 rs . close ( ) ; \n \n \t4 } catch ( SQLException e ) { \n \n <ect>
\t1 public void clear ( ) { \n \n \t2 super . clear ( ) ; \n \n \t2 clearCache ( ) ; } \n \n \t1 private void clearCache ( ) { \n \n <ect>
\t2 getController ( ) . updateClusters ( Collections . singleton ( clusterRequest ) , null ) ; \n \n \t2 return null ; } \n \n \t1 } ) ; \n \n \t1 } catch ( AmbariException e ) { \n \n <ect>
\t1 private final AtomicInteger numAddedNodes = new AtomicInteger ( 0 ) ; \n \n \t1 private final AtomicInteger numObservedNodes = new AtomicInteger ( 0 ) ; \n \n \t1 public ObservationQueueFullWarnTest ( NodeStoreFixture fixture ) { \n \n \t2 super ( fixture ) ; \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 log . warn ( <string_literal> , message , e . toString ( ) ) ; } } \n \n \t1 @ OnClose \n \n \t1 public void onWebSocketClose ( Session session , CloseReason reason ) { \n \n <ect>
\t4 context . setInForm ( wasInForm ) ; } } \n \n \t2 else { \n \n \t3 if ( ! _disabled ( context ) ) { \n \n \t4 log . warn ( <string_literal> , this ) ; \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , service . getName ( ) ) ; \n \n \t2 if ( StringUtils . isNotBlank ( service . getMetadataExpirationDuration ( ) ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , service . getName ( ) , service . getMetadataExpirationDuration ( ) ) ; \n \n \t3 return Beans . newDuration ( service . getMetadataExpirationDuration ( ) ) . toNanos ( ) ; } \n \n <ect>
\t3 byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; \n \n \t3 org . apache . thrift . TSerializable msg ; \n \n \t3 defaultNamespace_result result = new defaultNamespace_result ( ) ; \n \n \t3 if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t1 public static void errorMissingQueryParameter ( HttpResponse response , String param ) { \n \n \t2 int status = HttpStatus . SC_BAD_REQUEST ; \n \n \t2 response . setStatusCode ( status ) ; \n \n \t2 String message = <string_literal> + param ; \n \n <ect>
\t5 try { \n \n \t6 instream = clientSocket . getInputStream ( ) ; \n \n \t5 } catch ( IOException ioEx ) { \n \n \t6 if ( clientSocket . isClosed ( ) ) { \n \n <ect>
\t1 LOG . debug ( <string_literal> , ctx . channel ( ) . remoteAddress ( ) ) ; \n \n \t1 callback . onResponse ( TransportResponseImpl . success ( newResponse , wireAttrs ) ) ; } \n \n \t1 else \n \n \t1 { \n \n <ect>
\t2 return ticket ; } \n \n \t1 @ Override \n \n \t1 public void addTicket ( final Ticket ticket ) { \n \n \t2 this . entityManager . persist ( ticket ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( beta != 0 . 0 ) \n \n <ect>
\t5 return reply ; } \n \n \t3 } ) ; \n \n \t3 responses . put ( index , out ) ; } \n \n \t2 notify . matches ( <number_literal> , TimeUnit . MINUTES ) ; \n \n <ect>
\t9 self . services [ <string_literal> ] \n \n \t9 ) \n \n \t2 self . cleanup . append ( vpc_off ) \n \n \t2 self . validate_vpc_offering ( vpc_off ) \n \n <ect>
\t3 String [ ] kv = params [ i ] . split ( <string_literal> ) ; \n \n \t3 if ( kv . length == <number_literal> ) { \n \n \t4 args . put ( kv [ 0 ] , kv [ 1 ] ) ; \n \n \t3 } else { \n \n <ect>
\t4 LOG . info ( EntityUtils . toString ( entity ) ) ; } \n \n \t3 EntityUtils . consume ( entity ) ; \n \n \t3 ret = true ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 Object result = createJSONObject ( new JSONTokener ( jsonString ) ) ; \n \n \t2 if ( result == null ) { \n \n \t3 result = createJSONArray ( new JSONTokener ( jsonString ) ) ; } \n \n \t2 if ( result == null ) { \n \n <ect>
\t2 _currentState = OutboundState . OB_STATE_CONFIRMED_COMPLETELY ; } \n \n \t1 private void packetReceived ( ) { \n \n \t2 _nextSend = _context . clock ( ) . now ( ) ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t4 log . warn ( localAddress + <string_literal> + end_flush_timeout + <string_literal> ) ; } } \n \n \t1 private void onFlushReconcileOK ( Message msg ) { \n \n <ect>
\t2 enable_diagnostics = true ; \n \n \t2 try { \n \n \t3 startDiagnostics ( ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t4 } else { \n \n \t5 s_logger . warn ( <string_literal> + ip + <string_literal> + network ) ; \n \n \t5 return false ; } \n \n \t3 } catch ( final Exception ex ) { \n \n <ect>
\t2 cubeSegmentStatisticsResultMap . put ( ctxId , new CubeSegmentStatisticsResult ( type , cubeSegmentStatisticsMap ) ) ; } \n \n \t1 public void setContextRealization ( int ctxId , String realizationName , int realizationType ) { \n \n \t2 CubeSegmentStatisticsResult cubeSegmentStatisticsResult = cubeSegmentStatisticsResultMap . get ( ctxId ) ; \n \n \t2 if ( cubeSegmentStatisticsResult == null ) { \n \n <ect>
\t6 controller = new SingleIpFlowController ( queueSize , ip ) ; } } } \n \n \t3 if ( controller == null ) { \n \n \t4 LOGGER . severe ( <string_literal> + okey + <string_literal> + value ) ; \n \n \t3 } else { \n \n <ect>
\t3 lock . unlock ( ) ; } \n \n \t2 return resultFuture ; } \n \n \t1 protected void processBlock ( Block m ) { \n \n <ect>
\t2 NimbusClient client = clientManager . get ( clusterName ) ; \n \n \t2 if ( client != null ) { \n \n \t3 try { \n \n \t4 client . getClient ( ) . getVersion ( ) ; \n \n <ect>
\t3 @ Override \n \n \t3 public boolean isSatisified ( ) throws Exception { \n \n \t4 return brokerService . getAdminView ( ) . getInactiveDurableTopicSubscribers ( ) . length == 1 ; } \n \n \t2 } ) ) ; \n \n <ect>
\t4 . filter ( v - > values . contains ( v . getId ( ) ) ) \n \n \t4 . findAny ( ) ; \n \n \t2 if ( provider . isPresent ( ) ) { \n \n \t3 return CollectionUtils . wrapSet ( new Event ( this , provider . get ( ) . getId ( ) ) ) ; } \n \n <ect>
@ AfterClass \n \n public static void tearDownAfterClass ( ) throws Exception { \n \n \t1 if ( prevayler != null ) prevayler . close ( ) ; \n \n \t1 <comment> \n \n <ect>
<comment> \n \n \t1 @ Test \n \n \t1 public void addStagingAndDelete ( ) throws Exception { \n \n <ect>
\t4 checkOverFlow ( chunk , positionsArray [ chunk ] ) ; } \n \n \t3 count ++ ; } \n \n \t2 logger . info ( count + <string_literal> ) ; \n \n \t2 <comment> \n \n <ect>
\t1 if ( ! isSymmetric ) { \n \n \t2 e = Math . sqrt ( e ) ; } \n \n \t1 log . info ( <string_literal> , row , e ) ; \n \n \t1 state . setSingularValue ( row , e ) ; } \n \n <ect>
\t4 this . centralAuthenticationService . destroyTicketGrantingTicket ( ticketGrantingTicket ) ; } \n \n \t3 if ( isGatewayPresent ( context ) ) { \n \n \t4 LOGGER . debug ( <string_literal> , CasWebflowConstants . STATE_ID_GATEWAY ) ; \n \n \t4 return result ( CasWebflowConstants . STATE_ID_GATEWAY ) ; } \n \n <ect>
\t3 Log . fatal ( <string_literal> + dir ) ; \n \n \t3 return ; } \n \n \t2 for ( int i = 0 ; i < entries . length ; ++ i ) \n \n \t3 remove ( entries [ i ] ) ; \n \n <ect>
\t3 else { \n \n \t4 result = ( v2 != null ? 1 : 0 ) ; } } \n \n \t2 catch ( RuntimeException ex ) { \n \n <ect>
\t3 { \n \n \t4 stopServicesAndHandleBranchedStore ( config . get ( HaSettings . branched_data_policy ) , masterUri , me , cancellationRequest ) ; } \n \n \t3 catch ( IOException e ) \n \n \t3 { \n \n <ect>
\t1 boolean success = false ; \n \n \t1 Query query = null ; \n \n \t1 try { \n \n \t1 openTransaction ( ) ; \n \n <ect>
\t3 logger . trace ( <string_literal> , addr ) ; \n \n \t2 localState . markDead ( ) ; \n \n \t2 liveEndpoints . remove ( addr ) ; \n \n \t2 unreachableEndpoints . put ( addr , System . nanoTime ( ) ) ; \n \n <ect>
\t2 SslHandler sslHandler = configureClientSSLOnDemand ( ) ; \n \n \t2 if ( sslHandler != null ) { \n \n \t3 <comment> \n \n \t3 sslHandler . setCloseOnSSLException ( true ) ; \n \n <ect>
\t4 return value ; } \n \n \t2 try { \n \n \t3 value = db . get ( key ) ; \n \n \t2 } catch ( DBException e ) { \n \n <ect>
\t2 ClassUtils . instantiateAs ( analyzerClass , Analyzer . class ) ; } \n \n \t1 runJob ( inputPath , outputPath , catFile , cmdLine . hasOption ( exactMatchOpt ) , \n \n \t2 analyzerClass ) ; \n \n \t1 } catch ( OptionException e ) { \n \n <ect>
\t4 <comment> \n \n \t4 rv . get ( 0 ) . updated = _context . clock ( ) . now ( ) ; \n \n \t3 } else { \n \n \t4 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t2 public ERCInspect ( ) { \n \n \t3 super ( ) ; } \n \n \t2 public WOComponent deleteObjectAction ( WOComponent sender ) { \n \n \t3 if ( editingContext ( ) != null ) { \n \n <ect>
\t3 writer . write ( command + NEW_LINE ) ; \n \n \t3 writer . flush ( ) ; \n \n \t3 return true ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 else { \n \n \t3 log . error ( \n \n \t4 s <string_literal> + \n \n \t4 s <string_literal> ) } \n \n <ect>
\t2 poolInitializer . get ( ) . shutdownNow ( ) ; \n \n \t2 <comment> \n \n \t2 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t1 } finally { \n \n <ect>
\t3 if ( VersionComparator . comp ( _version , <string_literal> ) < 0 ) { \n \n \t4 <comment> \n \n \t4 if ( SystemVersion . isAndroid ( ) ) { \n \n \t5 if ( _log . shouldWarn ( ) ) \n \n <ect>
\t2 if ( ! _name . equals ( name ) ) { \n \n \t3 close ( ) ; \n \n \t3 return false ; } \n \n <ect>
\t5 TestUtils . waitUntilPortIsUp ( addr ) ; \n \n \t5 n ++ ; } } \n \n \t2 } catch ( CCMException e ) { \n \n \t3 logger . error ( <string_literal> + this , e ) ; \n \n <ect>
\t3 val packageFqName = file . packageFqName \n \n \t3 <comment> \n \n \t3 val packageDescriptor = session . moduleDescriptor . getPackage ( packageFqName ) \n \n \t3 if ( packageDescriptor . isEmpty ( ) ) { \n \n <ect>
\t4 Script command = new Script ( true , <string_literal> , _timeout , s_logger ) ; \n \n \t4 command . add ( mountPoint ) ; \n \n \t4 result = command . execute ( ) ; \n \n \t4 if ( result != null ) { \n \n <ect>
\t4 return new OvsSetTagAndFlowAnswer ( command , true , result ) ; \n \n \t3 } else { \n \n \t4 return new OvsSetTagAndFlowAnswer ( command , false , result ) ; } \n \n \t2 } catch ( final BadServerResponse e ) { \n \n <ect>
\t2 LOADED_DRIVERS = new ArrayList < String > ( ) ; } \n \n \t1 public static void loadDriver ( String dbDriver ) { \n \n \t2 String driverClass = DRIVERS . get ( dbDriver ) ; \n \n \t2 if ( driverClass == null ) { \n \n <ect>
\t4 @ Override \n \n \t4 public void handle ( File storeDir , PageCache pageCache , LogService logService ) throws IOException \n \n \t4 { \n \n \t5 Log msgLog = logService . getInternalLog ( getClass ( ) ) ; \n \n <ect>
\t2 private static final long serialVersionUID = 1L ; \n \n \t2 private static final Logger LOG = LoggerFactory . getLogger ( AscendingTimestampExtractor . class ) ; \n \n \t2 @ Override \n \n \t2 public void handleViolation ( long elementTimestamp , long lastTimestamp ) { \n \n <ect>
\t6 sr . setIgnoreTruncation ( false ) ; \n \n \t6 headResolver . addResolver ( sr ) ; } \n \n \t5 catch ( UnknownHostException e ) \n \n \t5 { \n \n <ect>
\t1 LOG . info ( <string_literal> , LlapDaemonInfo . INSTANCE . getPID ( ) ) ; \n \n \t1 <comment> \n \n \t1 } catch ( Throwable t ) { \n \n \t1 <comment> \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 if ( obj == null ) \n \n \t2 { \n \n \t3 return null ; } \n \n <ect>
\t1 if ( StringUtils . isNotEmpty ( memberAttributeValue ) && StringUtils . isNotEmpty ( pattern ) ) { \n \n \t1 try { \n \n \t2 Pattern p = Pattern . compile ( pattern ) ; \n \n \t2 Matcher m = p . matcher ( memberAttributeValue ) ; \n \n <ect>
\t1 switch ( authMethod ) { \n \n \t1 case FILE : return fileAuthenticationProvider . authenticate ( authentication ) ; \n \n \t1 case EXTERNAL_AUTH : return externalServerAuthenticationProvider . authenticate ( authentication ) ; \n \n \t1 case SIMPLE : return simpleAuthenticationProvider . authenticate ( authentication ) ; \n \n <ect>
\t3 client . close ( ) ; \n \n \t3 logger . debug ( <string_literal> + tvIp + <string_literal> + response ) ; \n \n \t3 return Integer . parseInt ( response . split ( <string_literal> ) [ 1 ] ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 if ( v . isLastStripeInFile ( ) ) { \n \n \t2 outWriter . appendUserMetadata ( v . getUserMetadata ( ) ) ; } \n \n \t1 } catch ( Throwable e ) { \n \n \t1 exception = true ; \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 String passphraseSrvr = configs . getConfigsMap ( ) . get ( Configuration . \n \n \t2 PASSPHRASE . getKey ( ) ) . trim ( ) ; \n \n \t1 if ( ! passphraseSrvr . equals ( passphraseAgent . trim ( ) ) ) { \n \n <ect>
\t4 if ( vmInstance . getState ( ) == State . Stopped ) { \n \n \t5 s_logger . debug ( <string_literal> + vmInstance + <string_literal> ) ; \n \n \t5 return true ; } \n \n \t4 if ( rebootVirtualMachine ( userId , vmId ) == null ) { \n \n <ect>
\t4 log . info ( <string_literal> , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; \n \n \t4 log . info ( <string_literal> , Locale . getDefault ( ) . getDisplayName ( ) ) ; \n \n \t4 log . info ( <string_literal> , JMeterUtils . getLocale ( ) . getDisplayName ( ) ) ; \n \n \t4 log . info ( <string_literal> , JMeterUtils . getJMeterHome ( ) ) ; \n \n <ect>
\t3 this . secondField = tripleClass . getField ( <string_literal> ) ; \n \n \t3 this . thirdField = tripleClass . getField ( <string_literal> ) ; \n \n \t3 this . available = true ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 if ( Secp256k1Context . isEnabled ( ) ) { \n \n \t3 try { \n \n \t4 return NativeSecp256k1 . verify ( data , signature , pub ) ; \n \n \t3 } catch ( NativeSecp256k1Util . AssertFailException e ) { \n \n <ect>
\t2 } ) ; \n \n \t2 CustomButtonAction createAccountAction = new CustomButtonAction ( <string_literal> , new Runnable ( ) { \n \n \t3 @ Override \n \n \t3 public void run ( ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 ensureGreen ( <string_literal> ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 assertAcked ( prepareCreate ( <string_literal> , 1 , Settings . builder ( ) . put ( <string_literal> , <number_literal> ) . put ( <string_literal> , 0 ) ) ) ; \n \n \t2 ensureGreen ( <string_literal> ) ; \n \n <ect>
\t3 KR2RMLWorksheetRDFGenerator rdfGen = new KR2RMLWorksheetRDFGenerator ( worksheet , \n \n \t4 workspace , \n \n \t4 generatedRDFFileName , false , mapping , errorReport , selection ) ; \n \n \t3 rdfGen . generateRDF ( true ) ; \n \n <ect>
private boolean isNativeLockingStrategy ( Properties dirConfiguration ) { \n \n \t1 return <string_literal> . equals ( dirConfiguration . getProperty ( Environment . LOCKING_STRATEGY ) ) ; } \n \n @ Override \n \n public void start ( DirectoryBasedIndexManager indexManager ) { \n \n <ect>
\t2 for ( int i = 0 ; i < size ; i ++ ) { \n \n \t3 template . sendBody ( url , <string_literal> + i ) ; } \n \n \t2 assertEquals ( size , processor . getCounter ( ) ) ; \n \n \t2 long delta = System . currentTimeMillis ( ) - start ; \n \n <ect>
\t3 currentChunk . store ( element ) ; \n \n \t3 totalItems ++ ; \n \n \t3 return true ; \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t4 final ResettableDriver < ? , ? > resDriver = ( ResettableDriver < ? , ? > ) this . driver ; \n \n \t4 try { \n \n \t5 resDriver . teardown ( ) ; \n \n \t4 } catch ( Throwable t ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , zoneAndName ) ; \n \n \t3 keyPairApi . get ( ) . delete ( pair . getName ( ) ) ; \n \n \t3 <comment> \n \n \t3 keyPairCache . invalidate ( zoneAndName ) ; \n \n <ect>
\t2 ArrayListStack < Iterator < DocumentElement > > iteratorStack ) \n \n \t1 { \n \n \t2 if ( tagNameStack . isEmpty ( ) ) \n \n \t2 { \n \n <ect>
\t4 uc . add ( new TrivialErrorUpdate ( <string_literal> + modelFile . getAbsolutePath ( ) ) ) ; \n \n \t4 return ; } } \n \n \t2 boolean result = workspace . getSemanticTypeModelHandler ( ) . readModelFromFile ( modelFile . getAbsolutePath ( ) ) ; \n \n \t2 if ( ! result ) \n \n <ect>
\t2 HttpMethod method = new GetMethod ( resultUrl ) ; \n \n \t2 while ( true ) { \n \n \t3 try { \n \n \t5 client . executeMethod ( method ) ; \n \n <ect>
\t3 result . tnase = ( org . apache . accumulo . core . client . impl . thrift . ThriftNotActiveServiceException ) e ; \n \n \t3 result . setTnaseIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t2 try { \n \n \t3 final int count = this . entityManager . createQuery ( <string_literal> + TABLE_NAME + <string_literal> ) \n \n \t5 . setParameter ( <string_literal> , key ) \n \n \t5 . executeUpdate ( ) ; \n \n <ect>
\t5 addr = new InetSocketAddress ( port ) ; \n \n \t4 } else { \n \n \t5 addr = new InetSocketAddress ( bindToAddr , port ) ; \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 return resource . getURL ( ) ; } \n \n \t2 catch ( MalformedURLException ex ) { \n \n \t3 throw ex ; } \n \n \t2 catch ( IOException ex ) { \n \n <ect>
\t3 if ( tfConfig . eIsSet ( tfConfig . eClass ( ) . getEStructuralFeature ( <string_literal> ) ) ) { \n \n \t4 setReceiverCode ( tfConfig . getReceiverCode ( ) ) ; \n \n \t4 receiverCodeFound = true ; \n \n \t3 } else { \n \n <ect>
\t3 if ( ! upgrade . supportsRollingUpgrade ( ) ) { \n \n \t4 supportsRollingUpgrade = false ; \n \n \t4 break ; } } \n \n \t2 if ( ! supportsRollingUpgrade && ClusterManagerImpl . arePeersRunning ( null ) ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 exchange . setException ( e ) ; } } \n \n \t1 void sendMessage ( Exchange exchange , org . apache . camel . Message camelMessage ) throws Exception { \n \n \t2 Message message = camelMessage . getBody ( Message . class ) ; \n \n <ect>
\t3 s_logger . info ( <string_literal> + newIsEnabled + <string_literal> ) ; \n \n \t3 specMatches = false ; } \n \n \t2 if ( oldIsEnabled || newIsEnabled ) { \n \n \t3 if ( oldAverageBandwidth != null && ! oldAverageBandwidth . equals ( newAverageBandwidth ) ) { \n \n <ect>
\t1 boolean cloningPlan ) { \n \n \t1 PerfLogger perfLogger = SessionState . getPerfLogger ( ) ; \n \n \t1 perfLogger . PerfLogBegin ( CLASS_NAME , PerfLogger . DESERIALIZE_PLAN ) ; \n \n \t1 T plan ; \n \n <ect>
\t4 || existingBucketName == null || <string_literal> . equals ( existingBucketName ) ) { \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 String path = new File ( <string_literal> + filePath ) . getCanonicalPath ( ) ; \n \n <ect>
\t2 encoder . SetEndMarkerMode ( true ) ; \n \n \t2 int dictionarySize = 1 ; \n \n \t2 if ( maxReadLength == Long . MAX_VALUE || maxReadLength < 0 ) { \n \n \t3 dictionarySize = MAX_DICTIONARY_SIZE ; \n \n <ect>
\t2 if ( driverClass == null ) { \n \n \t3 driverClass = this . getClass ( ) . getClassLoader ( ) . loadClass ( driverClassName ) ; \n \n \t3 LOGGER . debug ( <string_literal> , driverClassName , this . getClass ( ) . getClassLoader ( ) ) ; } \n \n \t1 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t3 <comment> \n \n <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n <ect>
\t3 out . flush ( ) ; \n \n \t4 log . trace ( <string_literal> + socket . getPort ( ) ) ; } \n \n \t2 } catch ( java . io . IOException x ) { \n \n <ect>
\t2 broker = createBroker ( false , url ) ; \n \n \t2 setDefaultPersistenceAdapter ( broker ) ; \n \n \t2 broker . start ( ) ; \n \n \t2 assertTrue ( <string_literal> , commitDoneLatch . await ( <number_literal> , TimeUnit . SECONDS ) ) ; \n \n <ect>
\t4 Cleanup entry = ( Cleanup ) referenceQueue . remove ( ) ; \n \n \t4 ClassPath key = entry . getKey ( ) ; \n \n \t4 removeCacheEntry ( key , entry , DONT_CLOSE_CLASSLOADER ) ; } \n \n \t2 } catch ( InterruptedException ex ) { \n \n <ect>
\t2 Log log = new Log ( ) ; \n \n \t2 ArrayList < String > osJarPath = new ArrayList < > ( ) ; \n \n \t2 String [ ] osDestJar = { null } ; \n \n \t2 if ( ! processArgs ( log , args , osJarPath , osDestJar ) ) { \n \n <ect>
\t4 this . lockService . destroy ( ) ; \n \n \t4 dbConnection . commit ( ) ; \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t3 } catch ( DatabaseException | SQLException de ) { \n \n <ect>
\t2 host = addr . getHostAddress ( ) ; \n \n \t1 } else { \n \n \t2 host = addr . getCanonicalHostName ( ) ; } \n \n \t1 } catch ( UnknownHostException e ) { \n \n <ect>
\t2 assert ( ip != null ) : <string_literal> + addrId + <string_literal> ; \n \n \t2 if ( ip == null ) { \n \n \t3 return true ; } \n \n <ect>
\t4 proxyUsername = user . getProperty ( proxyUsernameKey ) ; \n \n \t4 proxyPassword = user . getProperty ( proxyPasswordKey ) ; } \n \n \t3 content = HttpHelper . get ( address , authUsername , authPassword , proxyUrl , proxyUsername , proxyPassword , cookie , Collections . EMPTY_MAP ) . replace ( <string_literal> , <string_literal> <string_literal> \\ <string_literal> ) ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t1 protected void stopLdapServer ( ) { \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 ldapServer . stop ( ) ; } \n \n \t1 protected void shutdownDirectoryService ( ) throws Exception { \n \n <ect>
\t2 <comment> \n \n \t2 _heartbeatScheduler . scheduleAtFixedRate ( getHeartbeatTask ( ) , HeartbeatInterval . value ( ) , HeartbeatInterval . value ( ) , TimeUnit . MILLISECONDS ) ; \n \n \t2 _notificationExecutor . submit ( getNotificationTask ( ) ) ; \n \n <ect>
\t7 buildEventAttributeMap ( authentication . getPrincipal ( ) , registeredService , multifactorAuthenticationProvider ) ) ; \n \n \t5 return CollectionUtils . wrapSet ( event ) ; } \n \n \t4 LOGGER . warn ( <string_literal> , multifactorAuthenticationProvider ) ; \n \n \t4 return null ; } \n \n <ect>
\t3 log . debug ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 final Date date = DateUtils . parseDate ( response , HttpHeaders . DATE ) ; \n \n \t2 if ( date == null ) { \n \n <ect>
\t4 is . close ( ) ; \n \n \t3 } catch ( IOException ex ) { \n \n \t4 InternalLogApi logger = log == null ? defaultLog : log ; \n \n <ect>
\t2 KylinConfig config = null ; \n \n \t2 try { \n \n \t3 config = KylinConfig . getInstanceFromEnv ( ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t1 } catch ( IOException e ) { \n \n \t1 LOG . error ( <string_literal> , e ) ; \n \n \t1 throw new HiveException ( e ) ; } \n \n \t1 if ( srcs == null ) { \n \n <ect>
\t6 origRequestURI = requestURI ; \n \n \t6 if ( requestURI . getRawUserInfo ( ) != null || requestURI . getRawFragment ( ) != null ) { \n \n \t7 <comment> \n \n \t7 if ( _log . shouldLog ( Log . WARN ) ) { \n \n <ect>
private void startMonitorThread ( ) { \n \n \t1 inputIsReadyMonitor = new Thread ( <string_literal> ) { \n \n \t1 @ Override \n \n \t1 public void run ( ) { \n \n <ect>
\t2 super . assertMessagesReceivedAreValid ( receivedMessages ) ; \n \n \t2 <comment> \n \n \t2 for ( Message message : receivedMessages ) { \n \n \t3 String userID = message . getStringProperty ( <string_literal> ) ; \n \n <ect>
\t2 this . log = logProvider . getLog ( this . getClass ( ) ) ; \n \n \t2 this . myself = myself ; \n \n \t2 this . dbName = config . get ( CausalClusteringSettings . database ) ; \n \n \t2 readableName = StreamSupport . stream ( getKeys ( ) . spliterator ( ) , false ) . collect ( Collectors . joining ( <string_literal> ) ) ; \n \n <ect>
\t3 LOG . error ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 <comment> \n \n \t2 if ( ! insert && currentMap == null ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( repo , snapshot ) \n \n \t3 . setWaitForCompletion ( false ) \n \n \t3 . execute ( ) ; \n \n <ect>
\t1 try { \n \n \t2 driverThread . join ( ) ; \n \n \t1 } catch ( InterruptedException ie ) { \n \n \t2 <comment> \n \n <ect>
\t2 if ( ipId != null ) { \n \n \t3 return null ; } \n \n \t2 account = _accountDao . acquireInLockTable ( account . getId ( ) ) ; \n \n \t2 if ( account == null ) { \n \n <ect>
\t2 final RegisteredService registeredService = this . servicesManager . findServiceBy ( service ) ; \n \n \t2 final Map < String , Object > attributes = new HashMap < > ( ) ; \n \n \t2 final Map < String , Object > principalAttributes = getCasPrincipalAttributes ( model , registeredService ) ; \n \n \t2 attributes . putAll ( principalAttributes ) ; \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 return Collections . emptyMap ( ) ; } \n \n \t2 if ( statuses == null ) { \n \n <ect>
\t4 synchronized ( messageCount ) { \n \n \t5 messageCount . notify ( ) ; } } \n \n \t3 LOG . info ( <string_literal> + messageCount ) ; \n \n \t3 if ( messageCount . get ( ) % <number_literal> == 0 ) { \n \n <ect>
\t3 throw new ServletException ( e ) ; } } \n \n \t1 @ Override \n \n \t1 public void destroy ( ) { \n \n <ect>
\t3 this . dspaceObject = c ; \n \n \t3 <comment> \n \n \t3 context . restoreAuthSystemState ( ) ; \n \n \t2 } catch ( AuthorizeException ex ) { \n \n <ect>
\t3 } else { \n \n \t4 _accountMgr . checkAccess ( caller , null , true , ipToAssoc ) ; } \n \n \t3 owner = _accountMgr . getAccount ( ipToAssoc . getAllocatedToAccountId ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t3 String newEnTranscription = rebuildTrans ( otherLanguageTranscription ) ; \n \n \t3 String newGerundEndingTrans = rebuildTrans ( gerundEndingTrans ) ; <comment> \n \n \t3 String voicedNewGerundEndingTrans = voiceFinal ( newGerundEndingTrans ) ; <comment> \n \n \t3 <comment> \n \n <ect>
\t5 masterAndDataNodes ++ ; } } \n \n \t3 this . numDataNodes = dataNodes ; \n \n \t3 this . numMasterAndDataNodes = masterAndDataNodes ; \n \n \t3 this . client = client ; \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t2 Class clazz = new GroovyClassLoader ( ) . parseClass ( <string_literal> <string_literal> <ect>
\t3 Serializable { \n \n \t2 @ Override \n \n \t2 public Tuple2 < Tuple , Object > apply ( Tuple t ) { \n \n <ect>
\t3 cipher . init ( Cipher . ENCRYPT_MODE , keySpec , new IvParameterSpec ( keyIvPair . getIvBytes ( ) ) ) ; \n \n \t3 byte [ ] encryptedBytes = cipher . doFinal ( text . getBytes ( ) ) ; \n \n \t3 return Base64 . encodeBase64URLSafeString ( encryptedBytes ) ; \n \n \t2 } catch ( NoSuchAlgorithmException e ) { \n \n <ect>
\t1 protected boolean hasNextBinding ( ) \n \n \t1 { \n \n \t2 boolean b = super . hasNextBinding ( ) ; \n \n \t2 if ( logging ) \n \n <ect>
\t2 UTMaster master = createMaster ( i + <number_literal> ) ; \n \n \t2 logger . info ( <string_literal> , i ) ; \n \n \t2 server . save ( master ) ; \n \n \t2 if ( i == 1 ) { \n \n <ect>
\t3 <comment> \n \n \t3 for ( Thread thread : createdThreads ) { \n \n \t4 if ( thread . isAlive ( ) ) { \n \n \t5 assert false : <string_literal> + thread . getName ( ) + <string_literal> ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlSPFallingBackToLocalFormAuthentication ( ) { \n \n <ect>
\t2 Message in = exchange . getIn ( ) ; \n \n \t2 <comment> \n \n \t2 Object message = in . getBody ( ) ; \n \n \t2 if ( message == null ) { \n \n <ect>
\t1 if ( type . isAnnotationPresent ( Remote . class ) ) { \n \n \t1 log . info ( <string_literal> + type ) ; \n \n \t1 managedTypes . addRemoteInterface ( type . getJavaClass ( ) ) ; } \n \n \t1 else if ( type . isAnnotationPresent ( Service . class ) ) { \n \n <ect>
\t1 if ( ! metrics . isEmpty ( ) ) { \n \n \t1 if ( ! isInitialized ) { \n \n \t2 init ( ) ; } \n \n \t1 if ( isInitialized ) { \n \n <ect>
\t5 log . warn ( <string_literal> + file , pe ) ; \n \n \t4 error = true ; \n \n \t3 } catch ( IOException ioe ) { \n \n \t4 if ( log . shouldWarn ( ) ) \n \n <ect>
\t2 for ( String path : paths ) { \n \n \t3 try { \n \n \t4 jobIds . add ( jobIdfromPath ( path ) ) ; \n \n \t3 } catch ( Exception exception ) { \n \n <ect>
\t1 ParseStatus parse ( final Collection < String > buffer ) { \n \n \t2 assert buffer \n \n \t2 sourceBuffer = new SourceBuffer ( ) \n \n \t2 def source = buffer . join ( Parser . NEWLINE ) \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 LOG . error ( <string_literal> , e ) ; } \n \n \t2 while ( true ) { \n \n \t3 JStormUtils . sleepMs ( <number_literal> ) ; \n \n <ect>
\t4 writeFilter ( filterName , ArgumentDefinitionField . getArgumentFields ( new ParsingEngine ( null ) , filter ) , dependents ) ; } \n \n \t3 writeDependencies ( dependents ) ; \n \n \t3 return 0 ; \n \n \t2 } catch ( IOException exception ) { \n \n <ect>
<comment> \n \n \t1 public String getTestBuildFolder ( ) { \n \n <ect>
<comment> \n \n \t1 public synchronized void addJmxReporter ( String domain , String agentId ) { \n \n \t2 if ( null != jmxReporter ) { \n \n <ect>
\t1 private List < JobTaskDirectoryMatch > findOrphansForTask ( JobTask task ) { \n \n \t2 List < JobTaskDirectoryMatch > rv = new ArrayList < > ( ) ; \n \n \t2 Job job = getJob ( task . getJobUUID ( ) ) ; \n \n \t2 if ( job == null ) { \n \n <ect>
<comment> \n \n \t3 while ( running ) { \n \n \t4 if ( ! clientValid ( ) ) { \n \n \t5 try { \n \n <ect>
\t2 byte [ ] xor = SimpleByteCache . acquire ( Hash . HASH_LENGTH ) ; \n \n \t2 ctx . sha ( ) . calculateHash ( first256 , off , first256 . length - <number_literal> - off , xor , 0 ) ; \n \n \t2 xor32 ( us . getData ( ) , xor ) ; \n \n \t2 <comment> \n \n <ect>
\t3 LOG . info ( <string_literal> ) ; \n \n \t3 return new XOrder ( ) ; } \n \n \t2 @ Converter \n \n \t2 public XOrderResponse toXOrderResponse ( String res ) { \n \n <ect>
\t2 if ( stmt instanceof OraclePreparedStatement ) { \n \n \t3 return ( OraclePreparedStatement ) stmt ; } \n \n \t2 OraclePreparedStatement unwrapped = stmt . unwrap ( OraclePreparedStatement . class ) ; \n \n \t2 if ( unwrapped == null ) { \n \n <ect>
\t2 } catch ( FetchException e ) { \n \n \t3 if ( e . mode == FetchExceptionMode . RECENTLY_FAILED ) { \n \n \t4 Logger . error ( this , <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t6 LOGGER . debug ( <string_literal> + templateSvnDir + <string_literal> + username + <string_literal> + userDirectory + <string_literal> ) ; } \n \n \t5 final boolean preserveFileDate = true ; \n \n \t5 FileUtils . copyDirectory ( templateSvnDir , userDirectory , preserveFileDate ) ; \n \n \t4 } else { \n \n <ect>
\t6 break ; } \n \n \t4 } else { \n \n \t5 break ; } } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 } catch ( Exception e ) { \n \n \t3 exception = ExceptionUtils . firstOrSuppressed ( e , exception ) ; } \n \n \t2 jobExecutorService = null ; \n \n \t2 if ( exception != null ) { \n \n <ect>
\t2 byteBufferReadableClass . isInstance ( stream . getWrappedStream ( ) ) ) { \n \n \t1 try { \n \n \t2 return h2SeekableConstructor . newInstance ( stream ) ; \n \n \t1 } catch ( InstantiationException e ) { \n \n <ect>
\t4 catch ( IOException e ) \n \n \t4 { \n \n \t5 logger . debug ( <string_literal> + socket , e ) ; \n \n \t5 FileUtils . closeQuietly ( socket ) ; } } \n \n <ect>
\t2 assertThat ( tracker . getGlobalCheckpoint ( ) , not ( equalTo ( UNASSIGNED_SEQ_NO ) ) ) ; } \n \n \t1 public void testMissingInSyncIdsPreventAdvance ( ) { \n \n \t2 final Map < AllocationId , Long > active = randomAllocationsWithLocalCheckpoints ( 1 , <number_literal> ) ; \n \n \t2 final Map < AllocationId , Long > initializing = randomAllocationsWithLocalCheckpoints ( <number_literal> , <number_literal> ) ; \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t3 try { \n \n \t4 Native . register ( <string_literal> ) ; \n \n \t4 logger . debug ( <string_literal> ) ; \n \n \t3 } catch ( NoClassDefFoundError e ) { \n \n <ect>
\t2 Configuration jobConf = null ; \n \n \t2 try { \n \n \t3 jobConf = new XConfiguration ( new StringReader ( job . getConf ( ) ) ) ; } \n \n \t2 catch ( IOException ioe ) { \n \n <ect>
\t3 def . addClassList ( lists [ 0 ] , lists [ 1 ] ) ; } \n \n \t2 MungedClass . writeChanges ( ) ; \n \n \t2 LOG . info ( <string_literal> + lists [ 0 ] . length + <string_literal> ) ; \n \n \t2 LOG . info ( <string_literal> + lists [ 1 ] . length + <string_literal> ) ; \n \n <ect>
\t2 tls = MetaDataTableScanner . createTabletLocationState ( entry . getKey ( ) , entry . getValue ( ) ) ; \n \n \t1 } catch ( BadLocationStateException e ) { \n \n \t2 log . error ( <string_literal> , e . getMessage ( ) , e ) ; \n \n \t2 return false ; } \n \n <ect>
\t1 public List < String > getRules ( ) { \n \n \t2 try { \n \n \t3 return abilities . getRules ( this . getName ( ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 { \n \n \t3 if ( keywords . contains ( name ) ) \n \n \t4 continue ; \n \n \t3 if ( obsolete . contains ( name ) ) \n \n <ect>
\t6 values . add ( new Pair ( clz , entry . getSecond ( ) ) ) ; \n \n \t5 } else { \n \n \t6 logger . warn ( <string_literal> + clz + <string_literal> + ActiveReservoir . class ) ; } \n \n \t4 } catch ( ClassNotFoundException e ) { \n \n <ect>
\t1 <comment> \n \n \t1 RegistrationResponse response = null ; \n \n \t1 try { \n \n \t1 response = hh . handleRegistration ( message ) ; \n \n <ect>
\t1 public String encode ( final CharSequence password ) { \n \n \t2 if ( password == null ) { \n \n \t3 return null ; } \n \n \t2 if ( StringUtils . isBlank ( this . encodingAlgorithm ) ) { \n \n <ect>
\t6 Answer answer = _agentMgr . send ( host . getId ( ) , cleanup ( info . name ) ) ; \n \n \t6 if ( ! answer . getResult ( ) ) { \n \n \t7 s_logger . warn ( <string_literal> + answer . getDetails ( ) ) ; } } \n \n \t5 catch ( Exception e ) { \n \n <ect>
\t4 while ( true ) { \n \n \t5 if ( ( stdout . available ( ) == 0 ) && ( stderr . available ( ) == 0 ) ) { \n \n \t6 int conditions = sess . waitForCondition ( ChannelCondition . STDOUT_DATA | ChannelCondition . STDERR_DATA | ChannelCondition . EOF , <number_literal> ) ; \n \n \t6 if ( ( conditions & ChannelCondition . TIMEOUT ) != 0 ) { \n \n <ect>
\t2 Message message = consumer . receive ( <number_literal> ) ; \n \n \t2 messages . add ( message ) ; \n \n \t2 LOG . info ( <string_literal> + message ) ; \n \n \t2 <comment> \n \n <ect>
\t3 for ( SearchOperationListener listener : listeners ) { \n \n \t4 try { \n \n \t5 listener . onPreFetchPhase ( searchContext ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t2 LOG . debug ( <string_literal> + task . getDisplayName ( ) ) ; \n \n \t2 ImagingTasks . deleteTask ( task ) ; \n \n \t2 } catch ( final Exception ex ) { \n \n <ect>
\t3 if ( s != null ) { \n \n \t4 try { \n \n \t5 s . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t2 if ( args . length > 1 ) { \n \n \t3 ROOT_LOGGER . warn ( EeLogger . ROOT_LOGGER . invalidNumberOfArguments ( methodInfo . name ( ) , annotationType , classInfo . name ( ) ) ) ; \n \n \t3 return ; \n \n \t2 } else if ( args . length == 1 && ! args [ 0 ] . name ( ) . toString ( ) . equals ( InvocationContext . class . getName ( ) ) ) { \n \n <ect>
public void setDepartment ( er . example . erxpartials . model . Department value ) { \n \n \t1 takeStoredValueForKey ( value , <string_literal> ) ; } \n \n public void setDepartmentRelationship ( er . example . erxpartials . model . Department value ) { \n \n <ect>
\t4 sb . append ( <string_literal> ) ; \n \n \t4 sb . append ( errorOutput ) ; \n \n \t4 int ret = process . waitFor ( ) ; \n \n \t4 if ( ret != 0 ) { \n \n <ect>
\t2 } else { \n \n \t3 if ( ! _r ( ) . isCommitted ( ) ) { \n \n \t4 _r ( ) . sendError ( sc , msg ) ; \n \n \t3 } else { \n \n <ect>
\t3 if ( attache != null && attache . getQueueSize ( ) == 0 && attache . getNonRecurringListenersSize ( ) == 0 ) { \n \n \t4 handleDisconnectWithoutInvestigation ( attache , Event . StartAgentRebalance ) ; \n \n \t4 ClusteredAgentAttache forwardAttache = ( ClusteredAgentAttache ) createAttache ( hostId ) ; \n \n \t4 if ( forwardAttache == null ) { \n \n <ect>
\t3 @ JsonProperty ( <string_literal> ) AtomicInteger quiescentLevel , \n \n \t3 @ JsonProperty ( <string_literal> ) CopyOnWriteArraySet < String > disabledHosts ) { \n \n \t2 if ( uuid == null ) { \n \n \t3 this . uuid = UUID . randomUUID ( ) . toString ( ) ; \n \n <ect>
\t3 final InvalidParameterValueException ex = new InvalidParameterValueException ( <string_literal> + <string_literal> ) ; \n \n \t3 ex . addProxyObject ( vm . getUuid ( ) , <string_literal> ) ; \n \n \t3 throw ex ; } \n \n \t2 if ( _serviceOfferingDetailsDao . findDetail ( vm . getServiceOfferingId ( ) , GPU . Keys . pciDevice . toString ( ) ) != null ) { \n \n <ect>
\t3 s_logger . warn ( <string_literal> + mbean . getName ( ) , e ) ; \n \n \t2 } catch ( InstanceAlreadyExistsException e ) { \n \n \t3 s_logger . warn ( <string_literal> + mbean . getName ( ) , e ) ; \n \n \t2 } catch ( MBeanRegistrationException e ) { \n \n <ect>
\t2 return new RequestCallback ( ) { \n \n \t3 public void onSuccess ( int successCount ) { \n \n \t4 logger . info ( <string_literal> + successCount ) ; } \n \n \t3 public void onFailure ( int successCount , List < TrackerPayload > failedEvents ) { \n \n <ect>
\t1 <comment> \n \n \t1 LOG . warn ( <string_literal> + volumeId ) ; \n \n \t1 reply . set_return ( Boolean . TRUE ) ; \n \n \t1 } catch ( EucalyptusCloudException e ) { \n \n <ect>
\t1 public Record find ( Record record ) \n \n \t1 { \n \n \t2 log . info ( <string_literal> + record ) ; \n \n \t2 Record r2 = super . find ( record ) ; \n \n <ect>
\t7 . getDataTreeLastProcessedZxid ( ) , Code . NOTREADONLY . intValue ( ) ) ; \n \n \t5 try { \n \n \t6 request . cnxn . sendResponse ( hdr , null , null ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t3 List < VirtualNetwork > vncList = new ArrayList < VirtualNetwork > ( ) ; \n \n \t3 for ( VirtualNetwork vn : vList ) { \n \n \t4 if ( ! _manager . isSystemDefaultNetwork ( vn ) ) { \n \n \t5 vncList . add ( vn ) ; } } \n \n <ect>
\t2 } else { \n \n \t3 s_logger . debug ( <string_literal> + networkId ) ; } \n \n \t2 <comment> \n \n \t2 final DeployDestination dest = new DeployDestination ( _dcDao . findById ( network . getDataCenterId ( ) ) , null , null , null ) ; \n \n <ect>
\t5 Thread . sleep ( <number_literal> ) ; } } \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 <comment> \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 out . close ( ) ; \n \n \t2 if ( this . READ_NAME_REGEX == null ) { \n \n \t3 log . warn ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t1 if ( masterKey != null ) { \n \n \t1 try { \n \n \t2 atom = aes . encrypt ( masterKey ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 RoutingTable initialRoutingTable = RoutingTable . builder ( ) \n \n \t4 . addAsNew ( metaData . index ( <string_literal> ) ) \n \n \t4 . build ( ) ; \n \n \t2 ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . CLUSTER_NAME_SETTING . getDefault ( Settings . EMPTY ) ) . metaData ( metaData ) . routingTable ( initialRoutingTable ) . build ( ) ; \n \n <ect>
\t3 throw vex ; } \n \n \t2 catch ( AuthorizationException aex ) \n \n \t2 { \n \n \t3 onException ( transStatus ) ; \n \n <ect>
\t3 s_logger . debug ( <string_literal> + pool . getName ( ) + <string_literal> + pool . getId ( ) ) ; } \n \n \t2 if ( avoid . shouldAvoid ( pool ) ) { \n \n <ect>
\t2 try { \n \n \t3 producer . send ( queue , session . createTextMessage ( ) ) ; \n \n \t3 fail ( <string_literal> ) ; \n \n \t2 } catch ( JMSSecurityException jmsSE ) { \n \n <ect>
\t4 Pair < DatacenterMO , String > dcInfo = getOwnerDatacenter ( ) ; \n \n \t4 byte [ ] newVmdkContent = vmdkFileDescriptor . changeVmdkAdapterType ( vmdkInfo . second ( ) , newAdapterType ) ; \n \n \t4 String vmdkUploadUrl = getContext ( ) . composeDatastoreBrowseUrl ( dcInfo . first ( ) . getName ( ) , vmdkFileName ) ; \n \n \t4 getContext ( ) . uploadResourceContent ( vmdkUploadUrl , newVmdkContent ) ; \n \n <ect>
\t5 resumeOnNextOrPreviousIsOk = false ; \n \n \t5 <comment> \n \n \t5 nextExpectedSeqNum -= TRANSACITON_BATCH ; } \n \n \t3 } catch ( Throwable e ) { \n \n <ect>
\t2 <comment> \n \n \t2 String format = String . format ( <string_literal> , desc . sessionId , r1 . endpoint , r2 . endpoint , desc . columnFamily ) ; \n \n \t2 if ( differences . isEmpty ( ) ) \n \n \t2 { \n \n <ect>
\t3 logger . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( ServletException e ) { \n \n \t3 logger . warn ( <string_literal> , e ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 map . put ( StructrApp . key ( Image . class , <string_literal> ) , \t1 sourceHeight ) ; \n \n \t4 map . put ( StructrApp . key ( Image . class , <string_literal> ) , ImageHelper . getOrientation ( image ) ) ; \n \n \t4 image . setProperties ( image . getSecurityContext ( ) , map ) ; } \n \n \t2 } catch ( IOException ex ) { \n \n <ect>
\t5 return false ; } \n \n \t4 if ( StringUtils . containsIgnoreCase ( response , API_RETURN_STATUS_SUCCESS ) ) { \n \n \t5 return true ; \n \n \t4 } else { \n \n <ect>
\t4 <comment> \n \n \t4 _checkOpenLockTraces ( ) ; } \n \n \t2 } catch ( Throwable ex ) { \n \n \t3 <comment> \n \n <ect>
\t2 this . proxy = this ; } \n \n \t1 @ Override \n \n \t1 public void onFoundEdition ( long l , USK key , ClientContext context , boolean metadata , short codec , byte [ ] data , boolean newKnownGood , boolean newSlotToo ) { \n \n \t2 if ( l < 0 ) { \n \n <ect>
\t2 CommandLine cmd ; \n \n \t2 try { \n \n \t3 cmd = parser . parse ( ALL_OPTIONS , args ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t4 Glob g = options . extension ( ) ; \n \n \t4 if ( g == null ) \n \n \t5 g = new Glob ( <string_literal> ) ; \n \n \t4 Collection < File > files = IO . tree ( f , <string_literal> ) ; \n \n <ect>
\t2 int priority = 0 ; \n \n \t2 try { \n \n \t3 priority = Integer . parseInt ( priorityStr ) ; \n \n \t2 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t3 throw new Exception ( msg ) ; } \n \n \t2 if ( createGCTag ) { \n \n \t3 NetworkMO networkMo = new NetworkMO ( hostMo . getContext ( ) , morNetwork ) ; \n \n \t3 networkMo . setCustomFieldValue ( CustomFieldConstants . CLOUD_GC_DVP , <string_literal> ) ; \n \n <ect>
\t5 command . setCommand ( Command . NONE ) ; } \n \n \t4 if ( index < data . length - 1 ) { \n \n \t5 command . setArguments ( Arrays . copyOfRange ( data , index , data . length - 1 ) ) ; } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void memberDisappeared ( Member member ) { \n \n \t2 try { \n \n \t3 hasMembers = channel . hasMembers ( ) ; \t3 \n \n <ect>
\t1 throw new OAuthException ( e . getMessage ( ) , e ) ; } \n \n \t1 String signatureBaseString = authentication . getConsumerCredentials ( ) . getSignatureBaseString ( ) ; \n \n \t1 String signature = authentication . getConsumerCredentials ( ) . getSignature ( ) ; \n \n <ect>
\t1 private static Body getBodySafely ( SootMethod method ) { \n \n \t2 try { \n \n \t3 return method . getActiveBody ( ) ; \n \n \t2 } catch ( Exception exception ) { \n \n <ect>
\t2 } else if ( JdbcDialect . DIALECT_MSSQL . equals ( dialect ) ) { \n \n \t3 return String . format ( <string_literal> , tableName , tableFileDir , \n \n \t5 tableName ) ; \n \n \t2 } else { \n \n <ect>
\t4 if ( old != null ) { \n \n \t5 try { \n \n \t6 state . close ( ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t2 logger . info ( <string_literal> , numberOfShards ) ; \n \n \t2 dataNodeClient ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <string_literal> , <string_literal> ) . setWaitForCompletion ( false ) . setIndices ( <string_literal> ) . get ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 internalCluster ( ) . stopCurrentMasterNode ( ) ; \n \n <ect>
\t3 logger . debug ( indent ( node . depth ) + <string_literal> + allActions . size ( ) + <string_literal> + allActions ) ; \n \n \t2 for ( Ability action : allActions ) { \n \n \t3 if ( Thread . interrupted ( ) ) { \n \n \t4 Thread . currentThread ( ) . interrupt ( ) ; \n \n <ect>
@ Override \n \n public void shutdown ( ) { \n \n \t1 if ( ! active . compareAndSet ( true , false ) ) { \n \n \t1 throw new IllegalArgumentException ( <string_literal> + getName ( ) ) ; } \n \n <ect>
\t4 consumerChangeMutexMap . put ( info . getConsumerId ( ) , addGuard ) ; } } \n \n \t2 synchronized ( addGuard ) { \n \n \t3 Subscription o = subscriptions . get ( info . getConsumerId ( ) ) ; \n \n \t3 if ( o != null ) { \n \n <ect>
\t1 @ Inject \n \n \t1 private Logger log ; \n \n \t1 @ PostConstruct \n \n \t1 public void intercept ( InvocationContext ctx ) throws Exception { \n \n <ect>
\t2 if ( ! lowerBoundLowerBound . getTypeArgument ( ) . equals ( Primate . class ) ) { \n \n \t3 log . info ( <string_literal> + lowerBoundLowerBound . getTypeArgument ( ) ) ; \n \n \t3 result = false ; } \n \n \t2 if ( ! upperBoundLowerBound . getTypeArgument ( ) . equals ( Primate . class ) ) { \n \n <ect>
\t3 RestContext < AzureQueueClient , AzureQueueAsyncClient > context ) \n \n \t3 throws InterruptedException { \n \n \t1 String message = <string_literal> ; \n \n \t1 long timeOut = messageCount * <number_literal> ; <comment> \n \n <ect>
\t2 long rawDataSize = 0 ; \n \n \t2 long fileSize = 0 ; \n \n \t2 long numFiles = 0 ; \n \n \t2 <comment> \n \n <ect>
\t2 in . close ( ) ; \n \n \t2 version = prop . getProperty ( <string_literal> ) ; } \n \n \t1 logger . info ( <string_literal> , version ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 File nativeBaseDir = getNativeServicesDir ( userHomeDir ) ; \n \n \t4 try { \n \n \t5 net . rubygrapefruit . platform . Native . init ( nativeBaseDir ) ; \n \n \t4 } catch ( NativeIntegrationUnavailableException ex ) { \n \n <ect>
\t5 File subtaskBaseDirectory = directoryProvider . selectSubtaskBaseDirectory ( i ) ; \n \n \t5 try { \n \n \t6 deleteDirectory ( subtaskBaseDirectory ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t1 public void testMaxFileLengthShrink ( ) throws Exception { \n \n \t2 MessageStore messageStore = createStore ( <number_literal> * ONE_MB ) ; \n \n \t2 addMessages ( messageStore , <number_literal> ) ; \n \n \t2 long sizeBeforeChange = store . getJournal ( ) . getDiskSize ( ) ; \n \n <ect>
\t4 return null ; \n \n \t3 return new HTTPResponseResult ( result , httpClient ) ; } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t4 throw new ConfigurationException ( <string_literal> + name + <string_literal> + e . toString ( ) ) ; } } } \n \n \t1 private void launchAgentFromTypeInfo ( ) throws ConfigurationException { \n \n \t2 String typeInfo = getProperty ( null , <string_literal> ) ; \n \n \t2 if ( typeInfo == null ) { \n \n <ect>
\t2 try { \n \n \t3 os . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n \t3 LOG . error ( <string_literal> , session ) ; } \n \n <ect>
\t2 String ret = supervisor_local_dir ( conf ) + FILE_SEPERATEOR + <string_literal> ; \n \n \t2 try { \n \n \t3 FileUtils . forceMkdir ( new File ( ret ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 valueType = new ValueDataType ( docNodeStore , docStore , type ) ; \n \n \t2 this . memCacheMetadata = new CacheMetadata < K > ( ) ; \n \n \t2 if ( async ) { \n \n \t3 this . writeQueue = new CacheWriteQueue < K , V > ( dispatcher , cache , map ) ; \n \n <ect>
\t3 StaticFileServerHandler . sendError ( ctx , INTERNAL_SERVER_ERROR ) ; } } \n \n \t1 @ Override \n \n \t1 public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { \n \n \t2 if ( ctx . channel ( ) . isActive ( ) ) { \n \n <ect>
\t3 applier . applyRules ( network , purpose , rules ) ; \n \n \t2 } catch ( ResourceUnavailableException e ) { \n \n \t3 if ( ! continueOnError ) { \n \n \t4 throw e ; } \n \n <ect>
\t3 StringBuilder nodeStr = new StringBuilder ( ) ; \n \n \t3 for ( Node node : nodes ) { \n \n \t4 nodeStr . append ( node . getId ( ) + <string_literal> ) ; } \n \n <ect>
\t1 # \n \n \t1 # \t3 example : llapstatus - w - r 0 . <number_literal> - i <number_literal> - t <number_literal> \n \n \t1 llap_status_cmd = format ( <string_literal> ) \n \n \t1 Logger . info ( <string_literal> <ect>
\t2 LOG . error <string_literal> } \n \n \t1 if ( shmmax >= 0 && shmmax < MIN_SHMMAX ) { \n \n \t2 LOG . error <string_literal> } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t6 for ( UUID blockerId : group . getBlockers ( ) ) { \n \n \t7 Permanent blocker = game . getPermanent ( blockerId ) ; \n \n \t7 if ( blocker != null && ! blocker . isArtifact ( ) \n \n \t9 && ! attacker . getColor ( game ) . shares ( blocker . getColor ( game ) ) ) { \n \n <ect>
\t4 return new HitResult ( ( EntityRef ) closest . userData , \n \n \t6 VecMath . from ( closest . hitPointWorld ) , \n \n \t6 VecMath . from ( closest . hitNormalWorld ) ) ; \n \n \t3 } else { <comment> \n \n <ect>
\t2 prepareJsonWebSignatureForIdTokenSigning ( svc , jws , jsonWebKey ) ; \n \n \t2 return jws . getCompactSerialization ( ) ; } \n \n \t1 private void prepareJsonWebSignatureForIdTokenSigning ( final OidcRegisteredService svc , final JsonWebSignature jws , \n \n <number_literal> final RsaJsonWebKey jsonWebKey ) { \n \n <ect>
\t3 { \n \n \t4 log . info ( <string_literal> + f . channel ( ) ) ; \n \n \t4 f . channel ( ) . closeFuture ( ) . addListener ( closed - > \n \n \t4 { \n \n <ect>
\t6 if ( erase ) { \n \n \t7 try { \n \n \t8 StructrApp . getInstance ( securityContext ) . delete ( node ) ; \n \n \t7 } catch ( FrameworkException ex ) { \n \n <ect>
\t7 LOG . trace ( <string_literal> , md , session . getConnection ( ) ) ; } } \n \n \t4 } else { \n \n \t5 LOG . trace ( <string_literal> , session ) ; } } \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( liveCount < currentPageSize ) \n \n \t2 { \n \n <ect>
\t1 public void send ( TaskMessage message ) { \n \n \t2 LOG . warn ( <string_literal> ) ; } \n \n \t1 @ Override \n \n \t1 public void sendDirect ( TaskMessage message ) { \n \n <ect>
<number_literal> refreshSeconds , \n \n <number_literal> refreshSeconds ) ; \n \n \t3 searcherReopener . start ( ) ; <comment> \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 IgniteEvents events = createIgniteEvents ( ) ; \n \n \t2 IgniteEventsConsumer consumer = new IgniteEventsConsumer ( this , processor , events ) ; \n \n \t2 configureConsumer ( consumer ) ; \n \n <ect>
\t4 a . setDomainId ( rs . getLong ( <number_literal> ) ) ; \n \n \t4 a . setState ( State . valueOf ( rs . getString ( <number_literal> ) ) ) ; \n \n \t4 userAcctPair = new Pair < User , Account > ( u , a ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 crcFile . delete ( ) ; \n \n \t3 if ( ! cacheFilePaths . left . renameTo ( cacheFile ) ) \n \n \t4 logger . error ( <string_literal> , cacheFilePaths . left , cacheFile ) ; \n \n \t3 if ( ! cacheFilePaths . right . renameTo ( crcFile ) ) \n \n <ect>
\t3 log . error ( <string_literal> + entityShortName , e ) ; \n \n \t3 throw new ResourceException ( Status . CLIENT_ERROR_BAD_REQUEST , <string_literal> ) ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t4 while ( p . equals ( CmsProject . ONLINE_PROJECT_NAME ) & it . hasNext ( ) ) { \n \n \t5 p = ( String ) it . next ( ) ; } \n \n \t4 m_project . select ( p ) ; } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t3 . properties ( SubnetProperties . builder ( ) . addressPrefix ( defaultSubnetAddressPrefix ) . build ( ) ) . build ( ) ; \n \n \t2 VirtualNetworkProperties properties = VirtualNetworkProperties . builder ( ) \n \n \t3 . addressSpace ( AddressSpace . create ( Arrays . asList ( defaultVnetAddressPrefix ) ) ) \n \n \t3 . subnets ( Arrays . asList ( subnet ) ) . build ( ) ; \n \n <ect>
\t8 return false ; } \n \n \t7 else if ( api . getTestCaseInfo ( ) != null ) { \n \n \t8 s_logger . info ( <string_literal> + api . getTestCaseInfo ( ) + <string_literal> + api . getUrl ( ) ) ; } } } } \n \n \t4 else if ( ( api . getResponseType ( ) != ResponseType . ERROR ) && ( api . getResponseCode ( ) != <number_literal> ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( applicationContext != null && applicationContext . getClassLoader ( ) != null ) { \n \n \t3 cl = applicationContext . getClassLoader ( ) ; \n \n \t2 } else { \n \n <ect>
\t6 <string_literal> ) ; \n \n \t3 } else { \n \n \t4 _log . error ( <string_literal> ) ; } \n \n \t2 } else { \n \n <ect>
\t3 Iterator < X509CertificateHolder > certIt = certCollection . iterator ( ) ; \n \n \t3 X509CertificateHolder cert = certIt . next ( ) ; \n \n \t3 try { \n \n \t4 if ( signer . verify ( new JcaSimpleSignerInfoVerifierBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . build ( cert ) ) ) { \n \n <ect>
\t3 String targetResultString = mergeJSON ( sourceString , targetString , \n \n \t5 pathString , atId ) ; \n \n \t3 return new Text ( targetResultString ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 hsqlServer . signalCloseAllServerConnections ( ) ; \n \n \t2 logger . debug ( <string_literal> ) ; <comment> \n \n \t2 hsqlServer . stop ( ) ; \n \n \t2 int times = 0 ; \n \n <ect>
\t1 List < ColumnDescriptionImpl > header , \n \n \t1 boolean containsEndlines , \n \n \t1 CSVParams csvParams \n \n ) throws Exception { \n \n <ect>
\t2 if ( uri . startsWith ( <string_literal> ) ) { \n \n \t3 uri = uri . substring ( 1 ) ; } \n \n \t2 if ( uri . equals ( <string_literal> ) ) \n \n \t3 uri = <string_literal> ; \n \n <ect>
\t3 <comment> \n \n \t3 vrSystem = new VR_IVRSystem_FnTable ( JOpenVRLibrary . VR_GetGenericInterface ( JOpenVRLibrary . IVRSystem_Version , hmdErrorStore ) ) ; } \n \n \t2 if ( vrSystem == null || hmdErrorStore . get ( 0 ) != 0 ) { \n \n \t3 String errorString = jopenvr . JOpenVRLibrary . VR_GetVRInitErrorAsEnglishDescription ( hmdErrorStore . get ( 0 ) ) . getString ( 0 ) ; \n \n <ect>
\t3 public void onResponse ( SearchResponse searchResponse ) { \n \n \t4 response . set ( ( TestSearchResponse ) searchResponse ) ; } \n \n \t3 @ Override \n \n \t3 public void onFailure ( Exception e ) { \n \n <ect>
\t2 if ( false ) { \n \n \t3 <comment> \n \n \t3 int variant = ( int ) BitsLong . unpack ( leastSigBits , <number_literal> , <number_literal> ) ; \n \n \t3 if ( variant != <number_literal> ) \n \n <ect>
\t7 break ; } \n \n \t5 if ( state != null ) { \n \n \t6 eventPublisher . postUpdate ( itemName , state ) ; \n \n \t5 } else { \n \n <ect>
\t3 if ( occupancy >= VersioningInterestManager . MAX_FILL ) { \n \n \t4 packets ++ ; \n \n \t4 occupancy = VersioningInterestManager . MIN_FILL ; } \n \n \t3 occupancy ++ ; } \n \n <ect>
\t2 latch = new CountDownLatch ( maxNumberOfMessages ) ; } \n \n \t1 public void process ( final String message ) { \n \n \t2 log . info ( <string_literal> + message ) ; \n \n \t2 if ( seen . containsKey ( message ) ) { \n \n <ect>
\t3 return null ; } \n \n \t2 String vCenterAddress = tokens [ 1 ] ; \n \n \t2 String [ ] hostTokens = tokens [ 0 ] . split ( <string_literal> ) ; \n \n \t2 if ( hostTokens == null || hostTokens . length != <number_literal> ) { \n \n <ect>
\t2 return new ReadyAnswer ( cmd ) ; } \n \n \t1 private Answer executeRequest ( MaintainCommand cmd ) { \n \n \t2 return new MaintainAnswer ( cmd ) ; } \n \n \t1 private Answer retry ( Command cmd , int numRetries ) { \n \n <ect>
\t2 for ( Node node : cluster . getNodes ( ) ) { \n \n \t3 try { \n \n \t4 logger . info ( <string_literal> + node . briefToString ( ) + <string_literal> + storeName ) ; \n \n \t4 adminClient . readonlyOps . rollbackStore ( node . getId ( ) , storeName , pushVersion ) ; \n \n <ect>
\t2 if ( conf . memtable_heap_space_in_mb == null ) \n \n \t3 conf . memtable_heap_space_in_mb = ( int ) ( Runtime . getRuntime ( ) . maxMemory ( ) / ( <number_literal> * <number_literal> ) ) ; \n \n \t2 if ( conf . memtable_heap_space_in_mb < = 0 ) \n \n \t3 throw new ConfigurationException ( <string_literal> + conf . memtable_heap_space_in_mb , false ) ; \n \n <ect>
\t1 LOG . warn ( <string_literal> ) ; \n \n \t1 return null ; \n \n \t1 } else { \n \n \t1 <comment> \n \n <ect>
\t2 UserLocalObjects . getTempletonApi ( context ) . killJob ( object . getJobId ( ) ) ; \n \n \t1 } catch ( IOException e ) { \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 throw e ; } \n \n <ect>
\t2 actions . put ( name , action ) ; \n \n \t2 gson = null ; } \n \n \t1 public void registerDecorator ( String name , Class < ? extends Action > action ) { \n \n \t2 if ( decorators . containsKey ( name ) ) { \n \n <ect>
\t2 List < RESOURCE > currentGroup = new ArrayList < RESOURCE > ( ) ; \n \n \t2 result . add ( currentGroup ) ; \n \n \t2 long lastDate = getDateLastModified ( resources . get ( 0 ) ) ; \n \n \t2 for ( RESOURCE res : resources ) { \n \n <ect>
\t4 LOGGER . info ( <string_literal> ) ; \n \n \t4 String rightsClass = getConfiguration ( ) . getProperty ( <string_literal> ) ; \n \n \t4 if ( rightsClass != null && ! rightsClass . equals ( DEFAULT_RIGHT_SERVICE_CLASS ) ) { \n \n <ect>
\t5 result . add ( new ExternalTreeEntry ( new Path ( parentPath ) , new Path ( path ) , \n \n \t7 <string_literal> . equals ( isModuleA . atomValue ( ) ) ) ) ; } \n \n \t4 final String msg = <string_literal> + stopwatch ; \n \n \t4 if ( stopwatch . elapsed ( TimeUnit . SECONDS ) > <number_literal> ) { \n \n <ect>
\t2 if ( StringUtils . isNotBlank ( this . globalFailureMode ) ) { \n \n \t3 failureMode = RegisteredServiceMultifactorPolicy . FailureModes . valueOf ( this . globalFailureMode ) ; \n \n \t3 LOGGER . debug ( <string_literal> , service , failureMode ) ; } \n \n \t2 if ( service != null ) { \n \n <ect>
\t6 } else { \n \n \t7 throw new IOException ( <string_literal> + recoveryPosition , failedRecovery ) ; } } \n \n \t5 recoveryPosition = journal . getNextLocation ( recoveryPosition ) ; \n \n <ect>
\t4 log . error ( <string_literal> + threadLocal ) ; \n \n \t4 threadLocals . put ( threadLocal , value ) ; \n \n \t4 <comment> \n \n \t3 } else { \n \n <ect>
\t5 Optional < String > sid = value . get ( ) . getSession ( ) ; \n \n \t5 if ( sid . isPresent ( ) && ObjectHelper . isNotEmpty ( sid . get ( ) ) ) { \n \n \t6 <comment> \n \n \t6 <comment> \n \n <ect>
\t8 LOG . info ( <string_literal> + msg1 ) ; } \n \n \t6 } else { \n \n \t7 failed = true ; \n \n \t7 break ; } } \n \n <ect>
@ Override \n \n public String [ ] getPartitionKeys ( String location , Job job ) throws IOException { \n \n \t1 String jobToString = String . format ( <string_literal> , job . getJobID ( ) , job . getJobName ( ) ) ; \n \n <ect>
\t3 log . error ( <string_literal> ) ; \n \n \t3 log . error ( <string_literal> ) ; \n \n \t2 } catch ( InstantiationException ie ) { \n \n \t3 log . error ( <string_literal> + toolActionType + <string_literal> ) ; \n \n <ect>
\t4 return null ; } \n \n \t3 try { \n \n \t4 Thread . sleep ( _pauseInterval * <number_literal> ) ; \n \n \t3 } catch ( InterruptedException e ) { \n \n <ect>
\t2 Assert . assertTrue ( buckets [ 1 ] . getPath ( ) . getName ( ) . matches ( <string_literal> ) ) ; \n \n \t2 Assert . assertEquals ( 104L , buckets [ 0 ] . getLen ( ) ) ; \n \n \t2 Assert . assertEquals ( 104L , buckets [ 1 ] . getLen ( ) ) ; \n \n \t1 } else { \n \n <ect>
\t4 MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; \n \n \t4 mbs . registerMBean ( new StandardMBean ( new NativeAccess ( ) , NativeAccessMBean . class ) , new ObjectName ( MBEAN_NAME ) ) ; } \n \n \t3 catch ( Exception e ) \n \n \t3 { \n \n <ect>
\t3 for ( HiveProducerRecord elem : recordItr ) { \n \n \t4 fout . writeBytes ( elem . valueToString ( ) + <string_literal> ) ; } \n \n \t2 } catch ( IOException e ) { \n \n \t3 System . out . println ( <string_literal> + partitionContentPath . toString ( ) + <string_literal> + e ) ; \n \n <ect>
\t2 } catch ( ConcurrentOperationException ex ) { \n \n \t3 s_logger . warn ( <string_literal> , ex ) ; \n \n \t3 throw new ServerApiException ( ApiErrorCode . INTERNAL_ERROR , ex . getMessage ( ) ) ; \n \n \t2 } catch ( ManagementServerException ex ) { \n \n <ect>
\t2 final Resource resource = resourceLoader . getResource ( <string_literal> ) ; \n \n \t2 if ( resource != null && resource . exists ( ) ) { \n \n \t3 final Map pp = loadYamlProperties ( resource ) ; \n \n \t3 if ( pp . isEmpty ( ) ) { \n \n <ect>
<comment> \n \n \t1 protected void progress ( double pct , int blocksSoFar , Date date ) { \n \n <ect>
\t1 throw new RuntimeException ( e ) ; } } \n \n private ProtocolType createProxy ( final LlapNodeId nodeId , Token < TokenType > nodeToken ) { \n \n \t1 if ( nodeToken == null && token == null ) { \n \n <ect>
\t5 . withSchedule ( CronScheduleBuilder . cronSchedule ( backupInterval ) ) . build ( ) ; \n \n \t3 sched . scheduleJob ( backupJob , backupTrigger ) ; \n \n \t3 logger . debug ( <string_literal> , backupInterval ) ; \n \n \t2 } catch ( SchedulerException e ) { \n \n <ect>
\t2 Settings settings = createSettings ( resource ) ; \n \n \t2 Context context = newContext ( ) ; \n \n \t2 context . setSettings ( settings ) ; \n \n \t2 <comment> \n \n <ect>
\t3 ServiceHelper . stopService ( consumer ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 LOG . warn ( <string_literal> , e ) ; } } \n \n \t1 public void shutdown ( ) { \n \n <ect>
\t2 Long podId = plan . getPodId ( ) ; \n \n \t2 Long clusterId = plan . getClusterId ( ) ; \n \n \t2 List < Long > poolIdsByVolCount = _volumeDao . listPoolIdsByVolumeCount ( dcId , podId , clusterId , account . getAccountId ( ) ) ; \n \n <ect>
\t4 if ( t instanceof CompactionInterruptedException ) \n \n \t4 { \n \n \t5 logger . info ( t . getMessage ( ) ) ; \n \n \t5 if ( t . getSuppressed ( ) != null && t . getSuppressed ( ) . length > 0 ) \n \n <ect>
\t1 private synchronized void scheduleHostLBCheckerTask ( final long checkInterval ) { \n \n \t2 if ( hostLBTimer != null ) { \n \n \t3 hostLBTimer . cancel ( ) ; } \n \n \t2 if ( checkInterval > 0L ) { \n \n <ect>
\t2 { \n \n \t3 provider . dump ( phase , log . infoLogger ( ) ) ; } \n \n \t2 catch ( Exception cause ) \n \n \t2 { \n \n <ect>
\t3 if ( ( candidate [ i ] & netmask [ i ] ) != ( network [ i ] & netmask [ i ] ) ) { \n \n \t5 log . debug ( <string_literal> + candidate [ i ] ) ; \n \n \t5 log . debug ( <string_literal> + netmask [ i ] ) ; \n \n <ect>
\t3 s_logger . error ( e ) ; \n \n \t3 closeConfiguration ( ) ; \n \n \t3 if ( numRetries > 0 && refreshSrxConnection ( ) ) { \n \n \t4 int numRetriesRemaining = numRetries - 1 ; \n \n <ect>
\t1 <comment> \n \n \t1 try { \n \n \t1 Security . setProperty ( <string_literal> , <string_literal> ) ; \n \n \t1 } catch ( SecurityException exception ) { \n \n <ect>
\t3 tmp = tmplt . split ( <string_literal> ) ; \n \n \t3 String tmpltName = tmp [ tmp . length - <number_literal> ] ; \n \n \t3 tmplt = tmplt . substring ( tmplt . lastIndexOf ( <string_literal> ) ) ; \n \n \t3 TemplateInfo tInfo = new TemplateInfo ( tmpltName , tmplt , false ) ; \n \n <ect>
\t2 AllocationService strategy = createAllocationService ( Settings . builder ( ) \n \n \t4 . put ( <string_literal> , <number_literal> ) \n \n \t4 . put ( <string_literal> , <number_literal> ) \n \n \t4 . build ( ) , gatewayAllocator ) ; \n \n <ect>
\t1 protected synchronized void sendNext ( final long seq ) { \n \n \t2 _currentSequence = null ; \n \n \t2 if ( _requests . isEmpty ( ) ) { \n \n <ect>
\t2 int pos = nameExt . lastIndexOf ( ' . ' ) ; \n \n \t2 return ( pos > 0 ) ? nameExt . substring ( 0 , pos ) : nameExt ; } \n \n \t1 private void report ( Bndrun run ) { \n \n \t2 for ( String warning : run . getWarnings ( ) ) { \n \n <ect>
\t5 . error ( <string_literal> \n \n \t7 + username ) ; \n \n \t3 return - 1 ; \n \n \t2 } else { \n \n <ect>
\t2 protected void added ( int queueSize ) { \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( queueSize >= queueLength ) { \n \n <ect>
\t2 try { \n \n \t3 executor . execute ( cmdLine , resultHandler ) ; \n \n \t3 logger . debug ( <string_literal> , commandLine ) ; \n \n \t2 } catch ( ExecuteException e ) { \n \n <ect>
\t3 final String redisKey = getTicketRedisKey ( ticketId ) ; \n \n \t3 this . client . delete ( redisKey ) ; \n \n \t3 return true ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t2 commands . add ( kieServices . getCommands ( ) . newFireAllRules ( ) ) ; \n \n \t2 session . execute ( kieServices . getCommands ( ) . newBatchExecution ( commands , null ) ) ; \n \n \t2 session . dispose ( ) ; \n \n \t2 LOGGER . info ( <string_literal> ) ; \n \n <ect>
\t3 attachment . setDevice ( Images . DEFAULT_ROOT_DEVICE ) ; \n \n \t3 } else { <comment> \n \n \t3 <comment> \n \n \t3 for ( VmVolumeAttachment attachment : vm . getBootRecord ( ) . getPersistentVolumes ( ) ) { \n \n <ect>
\t3 { \n \n \t4 return errorResult ( new Error ( <string_literal> ) , new HTTPSampleResult ( ) ) ; } \n \n \t3 if ( thisCount == 0 ) { \n \n \t4 if ( count == 0 || filter == null ) { \n \n <ect>
\t3 } catch ( FileNotFoundException e ) { \n \n \t4 LOG . warn ( <string_literal> , e ) ; \n \n \t4 error ( ret , <string_literal> + logFile ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 { \n \n \t3 multiUserChat . revokeVoice ( nickname ) ; } \n \n \t2 catch ( XMPPException ex ) \n \n \t2 { \n \n <ect>
\t4 . endObject ( ) ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 client ( ) . prepareIndex ( <string_literal> , <string_literal> , <string_literal> ) . setSource ( source , XContentType . JSON ) . get ( ) ; \n \n \t2 client ( ) . prepareIndex ( <string_literal> , <string_literal> , <string_literal> ) . setSource ( source , XContentType . JSON ) . get ( ) ; \n \n <ect>
\t2 executeStatement ( stmt , records ) ; \n \n \t2 <comment> \n \n \t2 doRetry = false ; \n \n \t1 } catch ( SQLException sqlEx ) { \n \n <ect>
\t4 routerInfoFlood . runJob ( ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) { \n \n \t5 _log . logAlways ( Log . DEBUG , <string_literal> ) ; } } } \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 <comment> \n \n \t2 if ( ! _queuedMessages . contains ( msg ) ) \n \n \t3 _queuedMessages . offer ( msg ) ; \n \n \t2 else if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 if ( n2 . equals ( n ) ) \n \n \t6 Log . warn ( this , <string_literal> + v + <string_literal> ) ; \n \n \t5 else \n \n \t5 { \n \n <ect>
\t3 } catch ( final IOException e ) { \n \n \t4 LOGGER . error ( <string_literal> , e . getMessage ( ) , e ) ; } \n \n \t3 return ASN1Sequence . getInstance ( oct ) ; \n \n \t2 } catch ( final IOException e ) { \n \n <ect>
\t1 this . commitEnded = true ; \n \n \t1 logger . debug ( <string_literal> , xid , i ) ; } \n \n @ Override \n \n public void forget ( Xid xid ) throws XAException { \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t4 Logger . error ( this , <string_literal> + e , e ) ; } \n \n \t3 ramstore . clear ( ) ; \n \n \t2 } else if ( store instanceof SaltedHashFreenetStore ) { \n \n <ect>
\t1 public void runJob ( ) { \n \n \t2 if ( getContext ( ) . commSystem ( ) . getStatus ( ) != Status . DISCONNECTED ) { \n \n \t3 int removed = expireKeys ( ) ; \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 ServiceInfo service = ambariMetaInfo . getService ( stackInfo . get ( 0 ) , stackInfo . get ( 1 ) , serviceName ) ; \n \n \t2 LOG . debug ( String . format ( <string_literal> , service . getName ( ) ) ) ; \n \n \t2 services . put ( serviceName , service ) ; \n \n \t2 } catch ( AmbariException e ) { \n \n <ect>
\t3 for ( int i = 0 ; i < sz ; i ++ ) { \n \n \t4 OutboundMessageState state = new OutboundMessageState ( _context , msgs . get ( i ) , peer ) ; \n \n \t4 states . add ( state ) ; } \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t4 new EntityRoleCriterion ( SPSSODescriptor . DEFAULT_ELEMENT_NAME ) ) ) ; \n \n \t2 peer . setRole ( roleDescriptor . getElementQName ( ) ) ; \n \n \t2 final SAMLProtocolContext protocol = context . getSubcontext ( SAMLProtocolContext . class , true ) ; \n \n \t2 protocol . setProtocol ( SAMLConstants . SAML20P_NS ) ; \n \n <ect>
\t2 try { \n \n \t3 return cleaningCompiler . getCompiler ( ) . execute ( spec ) ; \n \n \t2 } finally { \n \n \t3 Collection < String > classesToCompile = recompilationSpec . getClassesToCompile ( ) ; \n \n <ect>
\t3 renderer . render ( xdom , printer ) ; \n \n \t3 String render = printer . toString ( ) . trim ( ) ; \n \n \t3 return <string_literal> . equals ( render ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 Answer dataAnswer = cmds . getAnswer ( <string_literal> ) ; \n \n \t3 if ( dataAnswer != null && dataAnswer . getResult ( ) ) { \n \n \t4 s_logger . info ( <string_literal> + uservm . getVirtualMachine ( ) . getInstanceName ( ) ) ; \n \n \t4 return true ; } \n \n <ect>
\t6 + <string_literal> \n \n \t6 + <string_literal> , deleted , count , \n \n \t6 timestampToString ( maxModifiedTime ) ) ; } \n \n \t2 if ( deletedSize > 0 ) { \n \n <ect>
\t3 if ( snapshotInfo != null ) { \n \n \t4 logger . warn ( ( ) - > new ParameterizedMessage ( <string_literal> , \n \n \t5 snapshotInfo . snapshotId ( ) , blobId ) , e ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 public void listAllServices ( ) { \n \n \t2 if ( serviceMap != null ) { \n \n \t3 logger . info ( <string_literal> ) ; \n \n <ect>
\t4 catch ( Exception e ) { \n \n \t5 <comment> \n \n \t5 if ( errorHandler != null ) \n \n \t6 errorHandler . handleErrorOnSet ( this , e , key ) ; \n \n <ect>
\t3 createPortGroup ( vSwitch , portGroupName , vlanId , secPolicy , shapingPolicy ) ; \n \n \t3 <comment> \n \n \t3 waitForPortGroup ( portGroupName , timeOutMs ) ; } \n \n <ect>
\t4 fileSystem . delete ( new Path ( basePath ) , false ) ; \n \n \t3 } catch ( IOException ignored ) { } \n \n \t3 return result ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t3 return false ; \n \n \t2 } else { \n \n \t3 vrSystem . setAutoSynch ( false ) ; \n \n \t3 vrSystem . read ( ) ; \n \n <ect>
\t2 boolean isInterface = type . asClassOrInterfaceDeclaration ( ) . isInterface ( ) ; \n \n \t2 if ( isInterface ) { \n \n \t3 <comment> \n \n \t3 clsOrIface = ( JavaInterface ) getOrCreate ( JavaInterface . class , identifyingProperties , identifyingProperties ) ; \n \n <ect>
\t2 sortTime . start ( ) ; \n \n \t2 Collections . sort ( rows , comparator ( ) ) ; \n \n \t2 sortTime . stop ( ) ; \n \n \t2 searchTime . stop ( ) ; \n \n <ect>
\t3 this . jpm = ( PersistenceContextManager ) env . get ( EnvironmentName . PERSISTENCE_CONTEXT_MANAGER ) ; \n \n \t2 } else { \n \n \t3 if ( tm != null && isSpringTransactionManager ( tm . getClass ( ) ) ) { \n \n \t4 try { \n \n <ect>
\t4 s_logger . debug ( <string_literal> ) ; \n \n \t4 s_logger . debug ( <string_literal> ) ; } \n \n \t2 } catch ( Throwable t ) { \t3 \n \n <ect>
\t5 <comment> \n \n \t5 if ( <string_literal> . equals ( typeName ) && decimalDigits == 0 ) { \n \n \t6 dataType = Types . NUMERIC ; \n \n <ect>
\t2 try { \n \n \t3 authenticateClientPrincipal ( ) ; } \n \n \t2 catch ( Exception e ) { \n \n \t3 <comment> \n \n <ect>
\t2 final int evtsCnt = <number_literal> + 1 ; \n \n \t2 final CountDownLatch latch = new CountDownLatch ( evtsCnt ) ; \n \n \t2 grid ( 1 ) . events ( ) . localListen ( lsnr = new GridPredicate < GridEvent > ( ) { \n \n \t3 @ Override public boolean apply ( GridEvent evt ) { \n \n <ect>
\t1 return Collections . singleton ( <string_literal> ) ; } \n \n @ Override \n \n public void registerSourceFiles ( Collection < String > sourceFileNames ) \n \n { \n \n <ect>
\t2 if ( result ) { \n \n \t3 _context . waitForTaskProgressDone ( morTask ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
public static class MinimumExpirationTimeChangeListener implements PropertyChangeListener < Integer > { \n \n \t1 @ Override \n \n \t1 public void fireChange ( ConfigurableProperty t , Integer newValue ) throws ConfigurablePropertyException { \n \n \t1 if ( newValue == null ) { \n \n <ect>
\t6 checkPutResults ( putResult ) ; \n \n \t6 next ++ ; \n \n \t6 accumulatedResults . add ( val ) ; } \n \n \t4 } catch ( NumberFormatException nfe ) { \n \n <ect>
\t1 public synchronized void stopRandomNode ( final Predicate < Settings > filter ) throws IOException { \n \n \t2 ensureOpen ( ) ; \n \n \t2 NodeAndClient nodeAndClient = getRandomNodeAndClient ( nc - > filter . test ( nc . node . settings ( ) ) ) ; \n \n \t2 if ( nodeAndClient != null ) { \n \n <ect>
\t4 this . ws . send ( text ) ; \n \n \t3 } else if ( ! text ) { \n \n \t4 Wicket . Log . error ( <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t3 throws Exception { \n \n \t2 this . submitTopologyWithOpts ( topologyName , conf , topology , null ) ; } \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 public void submitTopologyWithOpts ( final String topologyName , final Map conf , final FlinkTopology topology , final SubmitOptions submitOpts ) throws Exception { \n \n <ect>
\t1 } catch ( URISyntaxException e ) { \n \n \t1 logger . error ( <string_literal> , e ) ; \n \n \t1 migrationresult . setError ( <string_literal> + e . getMessage ( ) ) ; \n \n \t1 } catch ( PropertyVetoException e ) { \n \n <ect>
\t3 ResultSet rs = pstmt . executeQuery ( ) ; \n \n \t3 if ( rs . next ( ) ) { \n \n \t4 return Long . valueOf ( rs . getLong ( 1 ) ) ; } \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t2 try { \n \n \t3 this . queryStatistics = cubeSegmentStatisticsList == null ? null \n \n \t5 : SerializationUtils . serialize ( ( Serializable ) cubeSegmentStatisticsList ) ; \n \n \t2 } catch ( Exception e ) { <comment> \n \n <ect>
\t5 LOGGER . debug ( <string_literal> , dn ) ; \n \n \t5 return true ; } \n \n \t4 LOGGER . error ( <string_literal> , filter . format ( ) , ldap . getBaseDn ( ) ) ; \n \n \t3 } else { \n \n <ect>
\t8 . sendCommandExpectResponse ( cfg . mode . getItemModeCommandSetString ( sourceStr . toString ( ) ) ) ; \n \n \t6 cmdSent = true ; } } \n \n \t4 break ; \n \n \t3 default : \n \n <ect>
if not os . path . exists ( old_conf ) : \n \n \t1 Logger . debug ( <string_literal> . format ( old_conf ) ) \n \n \t1 return \n \n old_parent = os . path . abspath ( os . path . join ( old_conf , os . pardir ) ) \n \n <ect>
\t1 @ PostConstruct \n \n \t1 private void init ( ) { \n \n \t2 boolean currentState = true ; \n \n \t2 if ( this . testBean1 == null ) { \n \n <ect>
\t2 a ( log ) . shouldNotContain ( <string_literal> ) ; } \n \n \t1 @ Test \n \n \t1 public void shouldLogException ( ) { \n \n \t2 Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; \n \n <ect>
\t5 baits . add ( bait ) ; \n \n \t5 for ( final byte b : bait . getBases ( ) ) { \n \n \t6 final byte upper = StringUtil . toUpperCase ( b ) ; \n \n \t6 if ( upper != 'A' && upper != 'C' && upper != 'G' && upper != 'T' ) { \n \n <ect>
\t3 sendQueue . notifyAll ( ) ; \n \n \t3 sendQueueSize . decrementAndGet ( ) ; } \n \n \t2 sent = true ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 thrown . expect ( new ThriftExceptionMatchesPattern ( <string_literal> ) ) ; \n \n \t1 thrown . expect ( new ThriftExceptionMatchesPattern ( \n \n \t2 <string_literal> + proxyPrincipal + <string_literal> + kdc . qualifyUser ( user ) + <string_literal> ) ) ; \n \n \t1 TSocket socket = new TSocket ( hostname , proxyPort ) ; \n \n <ect>
\t3 BasicFileAttributes attrs = Files . readAttributes ( file . toPath ( ) , BasicFileAttributes . class ) ; \n \n \t3 long modifyIdle = System . currentTimeMillis ( ) - attrs . lastModifiedTime ( ) . toMillis ( ) ; \n \n \t3 long accessIdle = System . currentTimeMillis ( ) - attrs . lastAccessTime ( ) . toMillis ( ) ; \n \n \t3 if ( modifyIdle > inactiveThresholdMilliseconds && accessIdle > inactiveThresholdMilliseconds ) { \n \n <ect>
\t6 if ( val == null ) { \n \n \t7 return null ; } \n \n \t6 state = new StringType ( val ) ; \n \n \t5 } else { \n \n <ect>
\t4 else if ( false \n \n \t6 || value . equals ( <string_literal> ) \n \n \t4 ) { \n \n \t5 if ( java_version != 0 && java_version != java_version_default ) { \n \n <ect>
\t4 LOGGER . debug ( <string_literal> , ldap . getLdapUrl ( ) , ldap . getSearchFilter ( ) ) ; \n \n \t4 ldapDao . setSearchFilter ( ldap . getSearchFilter ( ) ) ; \n \n \t4 final SearchControls constraints = new SearchControls ( ) ; \n \n \t4 if ( ldap . getAttributes ( ) != null && ! ldap . getAttributes ( ) . isEmpty ( ) ) { \n \n <ect>
\t7 || ( ! matchPlayer . hasQuit ( ) && match . getGame ( ) != null && matchPlayer . getPlayer ( ) . isInGame ( ) ) ) { \n \n \t6 Optional < User > user = UserManager . instance . getUser ( userPlayerEntry . getKey ( ) ) ; \n \n \t6 if ( ! user . isPresent ( ) || ! user . get ( ) . isActive ( ) ) { \n \n \t7 logger . warn ( <string_literal> + matchPlayer . getName ( ) ) ; \n \n <ect>
\t2 boolean success = false ; \n \n \t2 if ( result != null && ! result . isEmpty ( ) ) { \n \n \t3 <comment> \n \n \t3 if ( result . equalsIgnoreCase ( <string_literal> ) ) { \n \n <ect>
\t2 logger . info ( <string_literal> , new Object [ ] { other } ) ; \n \n \t2 throw new UnsupportedOperationException ( <string_literal> ) ; <comment> \n \n \t1 @ Override \n \n \t1 public URI toUri ( ) { \n \n <ect>
\t3 indexRegistration . registerAsyncIndexer ( task , c . timeIntervalInSecs ) ; \n \n \t3 closer . register ( task ) ; } \n \n \t2 registerAsyncReindexSupport ( whiteboard ) ; \n \n \t2 log . info ( <string_literal> , asyncIndexerConfig ) ; \n \n <ect>
\t2 sendMessage ( messageBytes , bridgeId ) ; \n \n \t2 setCurrentState ( bulb , bridgeId , newValue , BindingType . brightness ) ; \n \n \t2 return newValue ; } \n \n \t1 private PercentType sendCooler ( int bulb , String bridgeId ) { \n \n <ect>
\t1 args . add ( <string_literal> ) ; \n \n \t1 args . add ( <string_literal> ) ; \n \n \t1 args . add ( <string_literal> ) ; \n \n \t1 args . add ( <string_literal> ) ; \n \n <ect>
\t2 Values values = new Values ( task , content ) ; \n \n \t2 collector . emit ( values , <string_literal> ) ; \n \n \t2 content ++ ; \n \n \t2 emitCounter . inc ( ) ; \n \n <ect>
\t3 if ( recoveredBy != 0 ) { \n \n \t4 update . set ( REV_RECOVERY_BY , recoveredBy ) ; } \n \n \t3 ClusterNodeInfoDocument old = store . findAndUpdate ( CLUSTER_NODES , update ) ; \n \n \t3 if ( old != null ) { \n \n <ect>
\t1 return isIdempotent ( command ) && ioRetryHandler . shouldRetryRequest ( command , response ) ; } \n \n private boolean isIdempotent ( HttpCommand command ) { \n \n \t1 String method = command . getCurrentRequest ( ) . getMethod ( ) ; \n \n \t1 if ( ! idempotentMethods . contains ( method ) ) { \n \n <ect>
\t5 InputStream is = method . getResponseBodyAsStream ( ) ; \n \n \t5 Map < String , String > success = getSingleValueFromXML ( is , new String [ ] { <string_literal> } ) ; \n \n \t5 s_logger . info ( <string_literal> + success . get ( <string_literal> ) ) ; \n \n \t4 } else { \n \n <ect>
\t1 } catch { \n \n \t1 case ex : Exception = > \n \n \t2 ex . printStackTrace ( System . err ) \n \n \t2 error ( <string_literal> , ex ) \n \n <ect>
\t6 log . info ( <string_literal> + rsrc8 ) ; \n \n \t6 log . info ( <string_literal> + rsrc9 ) ; \n \n \t6 log . info ( <string_literal> + rsrc10 ) ; \n \n \t6 log . info ( <string_literal> + log ) ; \n \n <ect>
\t3 Logger . error ( this , <string_literal> + e , e ) ; \n \n \t2 } catch ( Throwable t ) { \n \n \t3 System . err . println ( t ) ; \n \n \t3 t . printStackTrace ( ) ; \n \n <ect>
\t4 <string_literal> . format ( options . unknown_files_mapping_file ) ) \n \n if options . action == <string_literal> : \n \n \t1 ConfigMerge . INPUT_DIR = options . inputDir \n \n \t1 file_paths = ConfigMerge . get_all_supported_files_grouped_by_name ( directory = ConfigMerge . INPUT_DIR ) \n \n <ect>
\t3 } else if ( ( url . getPort ( ) == HTTPConstants . DEFAULT_HTTP_PORT && url . getProtocol ( ) . equalsIgnoreCase ( HTTPConstants . PROTOCOL_HTTP ) ) \n \n \t5 || ( url . getPort ( ) == HTTPConstants . DEFAULT_HTTPS_PORT && url . getProtocol ( ) . equalsIgnoreCase ( HTTPConstants . PROTOCOL_HTTPS ) ) ) { \n \n \t4 url2 = new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPath ( ) ) ; } \n \n \t2 } catch ( MalformedURLException e ) { \n \n <ect>
\t1 for ( Entry < String , String > osEntry : osMap . entrySet ( ) ) { \n \n \t1 String uriString = osEntry . getValue ( ) ; \n \n \t1 URI uri = StackModule . getURI ( stackModule , uriString ) ; \n \n \t1 if ( null == uri ) { \n \n <ect>
\t4 LOG . info ( <string_literal> + countValue + <string_literal> + sumValue ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 if ( doSum ) { \n \n \t5 dbSum . addAndGet ( - sum . get ( ) ) ; \n \n <ect>
\t4 newClusterType = Cluster . ClusterType . valueOf ( clusterType ) ; \n \n \t3 } catch ( final IllegalArgumentException ex ) { \n \n \t4 throw new InvalidParameterValueException ( <string_literal> + clusterType + <string_literal> ) ; } \n \n \t3 if ( newClusterType == null ) { \n \n <ect>
\t2 LOGGER . info ( <string_literal> , encrypted ) ; \n \n \t2 try { \n \n \t3 cipher . decryptValue ( encrypted ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t6 if ( mp != null ) \n \n \t7 semanticTypeMappings . add ( mp ) ; } } \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t2 chunk . dispose ( ) ; \n \n \t2 try { \n \n \t3 unloadRequestTaskMaster . put ( new ChunkUnloadRequest ( chunk , this ) ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t3 throw new InvalidParameterValueException ( <string_literal> ) ; \n \n \t2 if ( _accountMgr . checkAccessAndSpecifyAuthority ( caller , zone . getId ( ) ) != zone . getId ( ) ) \n \n \t3 throw new InvalidParameterValueException ( <string_literal> + <string_literal> + zoneId + <string_literal> ) ; \n \n <ect>
\t3 Object value = message . getObjectProperty ( <string_literal> ) ; \n \n \t3 if ( value instanceof Number ) { \n \n \t4 Number n = ( Number ) value ; \n \n \t4 return n . intValue ( ) ; } \n \n <ect>
\t8 if ( syncHandlerName . equals ( input [ 0 ] ) ) { \n \n \t9 return input [ 1 ] ; \n \n \t8 } <comment> \n \n \t7 } else { \n \n <ect>
\t3 if ( getIncludeRoutines ( ) ) { \n \n \t4 try { \n \n \t5 List < RoutineDefinition > r = getRoutines0 ( ) ; \n \n \t5 routines = sort ( filterExcludeInclude ( r ) ) ; \n \n <ect>
\t3 ctx . sendUpstream ( e ) ; \n \n \t3 } else { \n \n \t3 Handlers . sendRedirect ( ctx , e , compClass , request ) ; } \n \n \t2 } catch ( final NoSuchElementException ex ) { \n \n <ect>
\t3 Object object = _count . valueInComponent ( wocomponent ) ; \n \n \t3 if ( object != null ) { \n \n \t4 count = ERXValueUtilities . intValue ( object ) ; } \n \n \t3 else { \n \n <ect>
\t7 long expires = ts . getDate ( ) ; \n \n \t7 if ( curSize == origSize && curSize > <number_literal> && \n \n \t8 expires < now + SESSION_LIFETIME_MAX_MS - age ) { \n \n \t8 if ( _log . shouldInfo ( ) ) \n \n <ect>
\t6 if ( socketTester . apply ( socket ) ) { \n \n \t6 <comment> \n \n \t6 reachableSocket . compareAndSet ( null , socket ) ; } \n \n \t5 } catch ( RuntimeException e ) { \n \n <ect>
\t5 m_ok . setEnabled ( false ) ; \n \n \t5 m_infoSiteRoot . setVisible ( true ) ; \n \n \t5 return ; } } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
<comment> \n \n \t1 protected X509CRL fetchCRLFromLdap ( final Object r ) throws CertificateException , IOException , CRLException { \n \n \t2 try { \n \n \t3 final String ldapURL = r . toString ( ) ; \n \n <ect>
\t3 # \n \n \t3 for repo_path in get_repos ( logger , args . project , messages_file ) : \n \n \t4 logger . debug ( <string_literal> . format ( repo_path ) ) \n \n \t4 if repo_path in ignored_repos : \n \n <ect>
\t2 } catch ( final AgentUnavailableException e ) { \n \n \t3 s_logger . warn ( e . getMessage ( ) ) ; \n \n \t3 return null ; \n \n \t2 } catch ( final OperationTimedoutException e ) { \n \n <ect>
<comment> \n \n \t1 public static void listAvailableCovariates ( final Logger logger ) { \n \n <ect>
\t1 for ( Thread thread : threads ) { \n \n \t1 try { \n \n \t2 thread . join ( ) ; \n \n \t1 } catch ( InterruptedException e ) { \n \n <ect>
<comment> \n \n \t5 SallegraNode node = sallegraNodes . get ( bindingConfig . getModuleName ( ) ) ; \n \n \t5 if ( node == null ) { \n \n <ect>
\t3 throw new MessageHandlingException ( message , <string_literal> \n \n \t5 + expression . getExpressionString ( ) , cause == null ? e : cause ) ; } \n \n \t2 catch ( Exception e ) { \n \n <ect>
\t2 o2j . putIfAbsent ( openSslCipherSuite , p2j ) ; \n \n \t2 <comment> \n \n \t2 j2o . putIfAbsent ( javaCipherSuiteTls , openSslCipherSuite ) ; \n \n \t2 j2o . putIfAbsent ( javaCipherSuiteSsl , openSslCipherSuite ) ; \n \n <ect>
\t4 String jyhome = System . getenv ( <string_literal> ) ; \n \n \t4 if ( jyhome != null ) { \n \n \t5 Py . getSystemState ( ) . path . append ( new PyString ( jyhome + File . separator + <string_literal> ) ) ; } \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 installBootstrap ( bootstrapConfigFile , repHome ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 String sanSnapshotId = snapInfo . getSanVolumeId ( ) ; \n \n \t1 StorageResource storageResource = null ; \n \n \t1 String scIqn = StorageProperties . getStorageIqn ( ) ; \n \n \t1 if ( scIqn == null ) { \n \n <ect>
\t3 equalTo ( SnapshotState . SUCCESS ) ) ; \n \n \t2 <comment> \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 cluster ( ) . wipeIndices ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t2 if ( ! inputDir . isDirectory ( ) ) { \n \n \t3 throw new MojoExecutionException ( <string_literal> ) ; } \n \n \t2 logger . debug ( <string_literal> , inputDir . getAbsolutePath ( ) ) ; \n \n \t2 logger . debug ( <string_literal> , outputFile . getAbsolutePath ( ) ) ; \n \n <ect>
\t1 public void loadHeader ( String headerValue , WhenHttpRequest . Builder whenHttpRequestBuilder ) { \n \n \t2 String sessionContent = headerValue . trim ( ) ; \n \n \t2 if ( whenHttpRequestBuilder . containsCookie ( restxSessionCookieDescriptor . getCookieName ( ) ) \n \n \t4 || whenHttpRequestBuilder . containsCookie ( restxSessionCookieDescriptor . getCookieSignatureName ( ) ) ) { \n \n <ect>
\t2 final String originalUrl = singleLogoutService . getOriginalUrl ( ) ; \n \n \t2 if ( this . urlValidator . isValid ( originalUrl ) ) { \n \n \t3 LOGGER . debug ( <string_literal> , originalUrl , singleLogoutService ) ; \n \n \t3 return new URL ( originalUrl ) ; } \n \n <ect>
\t1 <comment> \n \n \t1 @ Override \n \n \t1 public void fatalTimeout ( ) { \n \n \t2 if ( node . isStopping ( ) ) return ; \n \n <ect>
\t3 try { \n \n \t4 if ( ! _ipAddrMgr . applyStaticNats ( staticNats , continueOnError , forRevoke ) ) { \n \n \t5 return false ; } \n \n \t3 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t2 if ( StringUtils . isBlank ( type ) ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 return NoOpPasswordEncoder . getInstance ( ) ; } \n \n \t2 if ( type . endsWith ( <string_literal> ) ) { \n \n <ect>
\t3 LinkedList < MessageId > reverseOrderIds = new LinkedList < MessageId > ( ) ; \n \n \t3 while ( rs . next ( ) ) { \n \n \t4 reverseOrderIds . addFirst ( new MessageId ( rs . getString ( <number_literal> ) , rs . getLong ( <number_literal> ) ) ) ; } \n \n <ect>
\t4 Collections . < String , String > emptyMap ( ) ) ) ) ; \n \n \t1 ret . setImageFormat ( ImageMetadata . ImageFormat . fulldisk . toString ( ) ) ; \n \n \t1 ret . setState ( ImageMetadata . State . available ) ; \n \n \t1 tx . commit ( ) ; \n \n <ect>
\t5 Thread . currentThread ( ) . interrupt ( ) ; \n \n \t5 return ; \n \n \t4 } catch ( Exception e ) { \n \n \t5 errorCount . incrementAndGet ( ) ; \n \n <ect>
\t4 <comment> \n \n \t4 tx . success ( ) ; \n \n \t3 } catch ( FrameworkException fex ) { \n \n \t4 fex . printStackTrace ( ) ; } } \n \n <ect>
\t3 <string_literal> , rows ) ; \n \n \t2 for ( String query : queries ) { \n \n \t2 LOG . debug ( <string_literal> + query + <string_literal> ) ; \n \n \t2 modCount = stmt . executeUpdate ( query ) ; } \n \n <ect>
\t1 Key key = null ; \n \n \t1 while ( key == null ) { \n \n \t2 try { \n \n \t3 key = client . generateKeyPair ( getNextName ( group ) ) ; \n \n <ect>
\t4 Primary primary = getTargetClass ( entry . getValue ( ) ) . getAnnotation ( Primary . class ) ; \n \n \t4 if ( primary != null ) \n \n \t5 return entry . getValue ( ) ; } \n \n \t3 if ( matchedTypes . size ( ) > 1 ) { \n \n <ect>
\t3 ContentName argName = ContentName . fromURI ( args [ CommonParameters . startArg ] ) ; \n \n \t3 CCNHandle handle = CCNHandle . open ( ) ; \n \n \t3 if ( args . length == ( CommonParameters . startArg + <number_literal> ) ) { \n \n \t4 if ( CommonParameters . verbose ) \n \n <ect>
\t5 <comment> \n \n \t5 ( ( AbstractNioChannel ) a ) . selectionKey = newKey ; } \n \n \t4 nChannels ++ ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 readLibrary = CCNHandle . open ( ) ; \n \n \t2 writeLibrary = CCNHandle . open ( ) ; } \n \n \t1 @ Test \n \n \t1 public void fastFlossTest ( ) { \n \n <ect>
\t1 protected void loadBeanDefinitions ( \n \n \t3 GenericWebApplicationContext context , WebMergedContextConfiguration webMergedConfig ) { \n \n \t2 Class < ? > [ ] annotatedClasses = webMergedConfig . getClasses ( ) ; \n \n <ect>
<comment> \n \n \t1 public void deleteFileVersion ( String fileId , Integer version ) { \n \n \t2 try { \n \n <ect>
\t5 state . consumeRowspan ( completedRowsHeight , rowHeight ) ; \n \n \t4 } else { \n \n \t5 state . beginCell ( cell , completedRowsHeight , rowHeight ) ; \n \n \t5 if ( LOGGER . isLogging ( Level . INFO ) ) { \n \n <ect>
\t2 public void finished ( FrameworkMethod method ) { \n \n \t3 LOG . info ( <string_literal> + testName ) ; } \n \n \t2 @ Override \n \n \t2 public void succeeded ( FrameworkMethod method ) { \n \n <ect>
public void setS3Url ( String s3Url ) { \n \n \t1 this . s3Url = s3Url ; } \n \n @ PreRemove \n \n public void deleteRemoteFile ( ) { \n \n <ect>
\t5 log . debug ( <string_literal> , sId . getId ( ) ) ; \n \n \t5 validateUser ( sId . getId ( ) ) ; } \n \n \t4 return false ; } \n \n \t2 } catch ( ExternalIdentityException e ) { \n \n <ect>
<number_literal> Map < String , String > requestProperties , boolean runSmokeTest , \n \n <number_literal> boolean reconfigureClients , boolean startDependencies ) throws AmbariException , AuthorizationException { \n \n \t1 AmbariManagementController controller = getManagementController ( ) ; \n \n \t1 if ( requests . isEmpty ( ) ) { \n \n <ect>
\t3 boolean res = frame . containsKey ( var ) ; \n \n \t3 if ( sub && ! res ) \n \n \t4 log . warn ( <string_literal> + var ) ; \n \n \t3 if ( ! sub && res ) \n \n <ect>
\t2 aclMap . put ( ( String ) key , new Integer ( aclJson . getInt ( ( String ) key ) ) ) ; } \n \n \t2 setDecodedAcl ( aclMap ) ; \n \n \t1 } catch ( Exception e ) { \n \n \t2 setDecodedAcl ( null ) ; \n \n <ect>
\t6 iter . remove ( ) ; \n \n \t6 changed = true ; \n \n \t5 } else { \n \n \t6 if ( log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t3 logger . error ( \n \n \t5 <string_literal> ) ; \n \n \t2 } else { \n \n \t3 serviceName = sn ; } \n \n <ect>
\t1 RexUtil . apply ( firstUsageFinder , ImmutableList . < RexNode > of ( ) , first ) ; \n \n \t1 RexUtil . apply ( secondUsageFinder , ImmutableList . < RexNode > of ( ) , second ) ; \n \n \t1 <comment> \n \n \t1 if ( ! checkSupport ( firstUsageFinder , secondUsageFinder ) ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + ( useDetail ? detail : <string_literal> ) + <string_literal> + path + <string_literal> + result ) ; \n \n \t3 System . out . println ( <string_literal> + ( useDetail ? detail : <string_literal> ) + <string_literal> + path + <string_literal> + result ) ; \n \n \t3 throw new Exception ( <string_literal> + ( useDetail ? detail : <string_literal> ) + <string_literal> + path + <string_literal> + result ) ; \n \n \t2 } else { \n \n <ect>
\t2 } else { \n \n \t3 subObject = object ( ) ; \n \n \t3 subKey = key ; } \n \n <ect>
\t4 { \n \n \t5 Supplier < ? > supplier = getConfigurationSupplier ( field , key , field . getType ( ) , Suppliers . ofInstance ( LifecycleMethods . fieldGet ( field , obj ) ) ) ; \n \n \t5 if ( supplier == null ) \n \n \t5 { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 bundleContext . removeServiceListener ( this ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 if ( ! isHypervisorTypeSupported ) { \n \n \t3 final String msg = <string_literal> + hypervisorType + <string_literal> + url ; \n \n \t3 s_logger . warn ( msg ) ; \n \n \t3 throw new DiscoveryException ( msg ) ; } \n \n <ect>
\t4 return m . invoke ( proxiee , ( Object [ ] ) null ) ; \n \n \t3 } else { \n \n \t4 return m . invoke ( proxiee , value ) ; } \n \n \t2 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t3 changeLocalUserPassword_result result = new changeLocalUserPassword_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t1 protected boolean reprogramNetworkRules ( long networkId , Account caller , NetworkVO network ) throws ResourceUnavailableException { \n \n \t2 boolean success = true ; \n \n \t2 <comment> \n \n \t2 if ( ! applyIpAssociations ( network , false ) ) { \n \n <ect>
\t6 { \n \n \t8 s_logger . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t8 throw new CloudRuntimeException ( <string_literal> + e . getMessage ( ) , e ) ; } } \n \n \t5 if ( noDuplicate ) { \n \n <ect>
\t2 refresh ( ) ; \n \n \t2 assertThat ( client . prepareSearch ( <string_literal> ) . setSize ( 0 ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( 100L ) ) ; \n \n \t2 <comment> \n \n \t2 String blockedNode = blockNodeWithIndex ( <string_literal> , <string_literal> ) ; \n \n <ect>
\t2 } catch ( IOException e ) { \n \n \t3 try { \n \n \t4 final URL resource = JMeterUtils . class . getClassLoader ( ) . getResource ( file ) ; \n \n \t4 if ( resource == null ) { \n \n <ect>
\t5 log . warn ( <string_literal> , ex ) ; } } \n \n \t2 } else { \n \n <ect>
\t2 processCurrentEvents ( currentEvents , syncWork ) ; \n \n \t2 scheduleWork ( syncWork ) ; \n \n \t2 updateSessionTriggerProvidersOnMasterThread ( ) ; \n \n \t1 } catch ( InterruptedException ex ) { \n \n <ect>
\t4 currentState = new SplitFileFetcher ( this , dis , context ) ; \n \n \t4 resumedFetcher = true ; \n \n \t4 return true ; \n \n \t3 } catch ( StorageFormatException e ) { \n \n <ect>
\t3 outputObject . put ( JsonKeys . result . name ( ) , transformedRows ) ; \n \n \t3 outputObject . put ( JsonKeys . errors . name ( ) , errorValues ) ; \n \n \t3 pw . println ( outputObject . toString ( ) ) ; \n \n \t2 } catch ( JSONException e ) { \n \n <ect>
\t2 StandardDeviation dev = new StandardDeviation ( ) ; \n \n \t2 double standardDeviation = dev . evaluate ( results ) ; \n \n \t2 double initialThreshold = standardDeviation / <number_literal> ; \n \n \t2 schrimpfAcceptance . setInitialThreshold ( initialThreshold ) ; \n \n <ect>
\t4 handleAccessRequest ( req , resp , vmId ) ; \n \n \t3 } else { \n \n \t4 handleAuthRequest ( req , resp , vmId ) ; } \n \n \t2 } catch ( Throwable e ) { \n \n <ect>
\t5 this . profileEnable = true ; \n \n \t4 } else if ( <string_literal> . equals ( param ) ) { \n \n \t5 this . profileEnable = false ; \n \n \t4 } else { \n \n <ect>
\t2 return try { \n \n \t3 val module = globals . get ( moduleName ) . checktable ( ) ? : globals \n \n \t3 ! module . get ( LuaInterpreter . ON_FILTER_NAME ) . isnil ( ) \n \n \t2 } catch ( e : LuaError ) { \n \n <ect>
<comment> \n \n \t1 public void done ( Repository repo ) { \n \n <ect>
\t2 sslSocket . setSoTimeout ( <number_literal> ) ; \n \n \t2 SSLSession session = sslSocket . getSession ( ) ; \n \n \t2 sslSocket . startHandshake ( ) ; \n \n \t2 LOG . info ( <string_literal> + session . getCipherSuite ( ) ) ; \n \n <ect>
\t3 return ; } \n \n \t2 RemoteHostId alice = new RemoteHostId ( ip , port ) ; \n \n \t2 if ( _transport . getPeerState ( alice ) != null ) { \n \n \t3 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t4 String actionText = ( String ) tableMatches . getValueAt ( modelRow , tableMatches . convertColumnIndexToView ( TournamentMatchesTableModel . ACTION_COLUMN ) ) ; \n \n \t4 UUID tableId = UUID . fromString ( ( String ) matchesModel . getValueAt ( modelRow , TournamentMatchesTableModel . ACTION_COLUMN + 1 ) ) ; \n \n \t4 UUID gameId = UUID . fromString ( ( String ) matchesModel . getValueAt ( modelRow , TournamentMatchesTableModel . ACTION_COLUMN + <number_literal> ) ) ; \n \n <comment> \n \n <ect>
\t5 syncState = SYNC_STATE_OUT_OF_SYNC ; } \n \n \t4 if ( _dbSync . getSyncMode ( ) == DBSyncGeneric . SYNC_MODE_CHECK ) { \n \n \t5 s_logger . debug ( <string_literal> + DBSyncGeneric . getClassName ( cls ) ) ; \n \n \t4 } else { \n \n <ect>
\t1 public void finishPlanMode ( ) { \n \n \t2 try { \n \n \t3 socket . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 if ( tezOp . plan . getLeaves ( ) . get ( 0 ) instanceof POSplit ) { \n \n \t5 <comment> \n \n \t5 st . setMultiStore ( true ) ; } \n \n \t3 } else { <comment> \n \n <ect>
\t4 if ( a . annotationType ( ) . equals ( BenchmarkOptions . class ) ) { \n \n \t5 final BenchmarkOptions old = ( BenchmarkOptions ) a ; \n \n \t5 BenchmarkOptions replacement = getWrappedBenchmarkOptions ( old , rounds ) ; \n \n \t5 modifiedAnnotations . add ( replacement ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n \t2 context = bc ; \n \n <ect>
\t1 return inputString . toLowerCase ( Locale . US ) ; } \n \n public void finish ( boolean success ) { \n \n \t1 progressReport . stop ( count + <string_literal> + total + <string_literal> ) ; \n \n \t1 if ( success && ! allFilesToBlame . isEmpty ( ) ) { \n \n <ect>
\t1 Logger logger = Logger . with ( Analytics . LogLevel . VERBOSE ) ; \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n \t1 logger . verbose ( <string_literal> ) ; \n \n <ect>
\t4 logger . warn ( <string_literal> , dex . getMessage ( ) ) ; \n \n \t4 <comment> \n \n \t4 throw new IOException ( dex ) ; } \n \n \t2 } else { \n \n <ect>
\t5 try { \n \n \t6 FileSystemUtils . deleteSubDirectories ( path ) ; \n \n \t6 logger . info ( <string_literal> , path ) ; \n \n \t5 } catch ( IOException e ) { \n \n <ect>
\t3 builder . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . add ( newNode ( randomAlphaOfLength ( <number_literal> ) ) ) ) ; \n \n \t3 tasksOrNodesChanged = true ; } \n \n \t2 if ( tasksOrNodesChanged == false ) { \n \n \t3 <comment> \n \n <ect>
\t3 MesosWorkerStore . Worker worker = MesosWorkerStore . Worker . newWorker ( workerStore . newTaskID ( ) , resourceProfile ) ; \n \n \t3 workerStore . putWorker ( worker ) ; \n \n \t3 workersInNew . put ( extractResourceID ( worker . taskID ( ) ) , worker ) ; \n \n \t3 LaunchableMesosWorker launchable = createLaunchableMesosWorker ( worker . taskID ( ) , resourceProfile ) ; \n \n <ect>
\t3 <comment> \n \n \t3 exchange . getOut ( ) . getHeaders ( ) . putAll ( exchange . getIn ( ) . getHeaders ( ) ) ; \n \n \t3 exchange . getOut ( ) . setBody ( result ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t3 namingResources . start ( ) ; } \n \n \t2 <comment> \n \n \t2 if ( webappResources == null ) { <comment> \n \n <ect>
\t5 public void run ( ) { \n \n \t6 try { \n \n \t7 ( ( StoppableTask ) invokable ) . stop ( ) ; \n \n \t6 } catch ( RuntimeException e ) { \n \n <ect>
\t1 c . tableOperations ( ) . addSplits ( table2 , splits ) ; \n \n \t1 <comment> \n \n \t1 log . info ( <string_literal> , table2 ) ; \n \n \t1 c . tableOperations ( ) . offline ( table2 , true ) ; \n \n <ect>
\t4 ( RuntimeConfigurationViewMBean ) brokerService . getManagementContext ( ) . newProxyInstance ( objectName , \n \n \t6 RuntimeConfigurationViewMBean . class , false ) ; \n \n \t2 HashMap < String , String > props = new HashMap < String , String > ( ) ; \n \n \t2 IntrospectionSupport . getProperties ( runtimeConfigurationView , props , null ) ; \n \n <ect>
\t4 new SpaceReference ( XWiki . SYSTEM_SPACE , new WikiReference ( xcontext . getWikiId ( ) ) ) ; \n \n \t3 DocumentReference userReference = this . explicitResolver . resolve ( xwikiUser . getUser ( ) , defaultUserSpace ) ; \n \n \t3 xcontext \n \n \t4 . setUserReference ( XWikiRightService . GUEST_USER . equals ( userReference . getName ( ) ) ? null : userReference ) ; \n \n <ect>
\t5 msg = cons . receive ( <number_literal> ) ; } \n \n \t3 } catch ( JMSException jms_exc ) { \n \n \t4 LOG . warn ( <string_literal> , jms_exc ) ; \n \n \t3 } finally { \n \n <ect>
<comment> \n \n \t3 Assert . assertEquals ( <string_literal> , \n \n \t5 <string_literal> , cookieEntry . getValue ( ) . toString ( ) ) ; } \n \n <comment> \n \n <ect>
\t2 session . commit ( ) ; \n \n \t2 <comment> \n \n \t2 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t3 msg = ( TextMessage ) consumer . receive ( <number_literal> ) ; \n \n <ect>
\t3 logger . debug ( <string_literal> ) ; \n \n \t3 createRealm = user . hasRole ( masterRealm . getRole ( AdminRoles . CREATE_REALM ) ) ; \n \n \t3 addMasterRealmAccess ( realm , user , realmAccess ) ; \n \n \t2 } else { \n \n <ect>
\t3 Element fstElmnt = ( Element ) fstNode ; \n \n \t3 <comment> \n \n \t3 ApiCommand api = new ApiCommand ( fstElmnt , this . getParam ( ) , this . getCommands ( ) ) ; \n \n \t3 if ( api . getName ( ) . equals ( <string_literal> ) ) { \n \n <ect>
\t2 return true ; } \n \n \t1 private List < String > listAll ( ExternalResourceName parent , BuildableModuleVersionListingResolveResult result ) { \n \n \t2 if ( ! visitedDirectories . add ( parent ) ) { \n \n \t3 return Collections . emptyList ( ) ; } \n \n <ect>
\t3 ack . grantedQos ( qos ) ; \n \n \t3 try { \n \n \t4 getMQTTTransport ( ) . sendToMQTT ( ack . encode ( ) ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 { \n \n \t3 pluginManager . checkRequiredMavenVersion ( pluginDescriptor ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t4 . field ( <string_literal> , id ) \n \n \t4 . endObject ( ) ; \n \n \t2 return builder ; } \n \n \t1 private void setBudget ( int numOfDocs ) { \n \n <ect>
\t6 if ( localizeHeader ) { \n \n \t7 try { \n \n \t8 value = LocalizeFunction . getLocalization ( locale , value , headerLocalizationDomain ) ; \n \n \t7 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 result . ouch2 = ( AccumuloSecurityException ) e ; \n \n \t3 result . setOuch2IsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
This function will obtain the Kerberos ticket if security is enabled . \n \n : return : \n \n ''' \n \n import params \n \n <ect>
\t2 logger . afterTest ( test2 , result ( true ) ) \n \n \t2 logger . afterSuite ( rootSuite , result ( ) ) \n \n \t2 then : \n \n \t2 1 * progressLogger . progress ( '2 tests completed , 1 failed' ) \n \n <ect>
\t3 if ( eds != null ) { \n \n \t4 if ( eds instanceof EODatabaseDataSource ) { \n \n \t5 EODatabaseDataSource dbds = ( EODatabaseDataSource ) eds ; \n \n \t5 EOQualifier q = dbds . fetchSpecification ( ) . qualifier ( ) ; \n \n <ect>
\t2 if ( this . eligibleAccounts . containsKey ( principal . getId ( ) ) ) { \n \n \t3 final Set surrogates = this . eligibleAccounts . get ( principal . getId ( ) ) ; \n \n \t3 LOGGER . debug ( <string_literal> , principal . getId ( ) , surrogates ) ; \n \n \t3 return surrogates . contains ( surrogate ) ; } \n \n <ect>
\t5 . code ( ) ; \n \n \t3 if ( code >= <number_literal> ) { \n \n \t4 logger . info ( <string_literal> , shareURL , code ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 return Response . ok ( ) . build ( ) ; } \n \n \t1 @ POST \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 public Response test ( ) { \n \n <ect>
\t2 if ( shutdownHook != null ) \n \n \t2 { \n \n \t3 if ( ! Runtime . getRuntime ( ) . removeShutdownHook ( shutdownHook ) ) \n \n \t3 { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t1 private void sendMessage ( MessageProducer producer , String threadName ) throws Exception { \n \n \t2 Message message = createMessage ( sentCount . get ( ) ) ; \n \n \t2 producer . send ( message ) ; \n \n <ect>
<comment> \n \n \t1 @ GetMapping ( <string_literal> ) \n \n \t1 public String logout ( final HttpServletRequest request , final HttpServletResponse response ) { \n \n <ect>
\t2 String propertyAtomUri = Namespaces . SWRL + <string_literal> ; \n \n \t2 <comment> \n \n \t2 nodeIterator = model . listObjectsOfProperty ( atom_resource , rdf_type ) ; \n \n \t2 if ( ! nodeIterator . hasNext ( ) || ! ( node = nodeIterator . next ( ) ) . isResource ( ) ) { \n \n <ect>
def get_pid_files ( self ) : \n \n \t1 import status_params \n \n \t1 return [ status_params . tagsync_pid_file ] \n \n def configure_atlas_user_for_tagsync ( self , env ) : \n \n <ect>
\t2 LOG . error ( <string_literal> + snapshotId + <string_literal> , ex ) ; \n \n \t2 cleanFailedSnapshot ( snapshotId ) ; \n \n \t2 throw ex ; } \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
<comment> \n \n \t1 private ItemMap determineItemMappingByItemCommand ( String itemCommand ) { \n \n \t2 ItemMap foundMapping = _allItemMap . get ( itemCommand ) ; \n \n \t2 if ( foundMapping == null ) { \n \n <ect>
\t5 } else { \n \n \t6 dest = <string_literal> ; \n \n \t6 ( new File ( _destFile ) ) . delete ( ) ; \n \n \t6 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 Configuration localConf ; \n \n \t3 try { \n \n \t4 localConf = new XConfiguration ( new StringReader ( strConfig ) ) ; } \n \n \t3 catch ( IOException e1 ) { \n \n <ect>
\t3 return null ; } \n \n \t2 LOGGER . debug ( <string_literal> , principalId ) ; \n \n \t2 final Map < String , List < Object > > attributes = retrievePersonAttributes ( principalId , credential ) ; \n \n \t2 if ( attributes == null || attributes . isEmpty ( ) ) { \n \n <ect>
\t2 if ( e instanceof TransportException ) \n \n \t3 return new ErrorMessage ( ( TransportException ) e , streamId ) ; \n \n \t2 <comment> \n \n \t2 if ( unexpectedExceptionHandler == null || ! unexpectedExceptionHandler . apply ( e ) ) \n \n <ect>
\t1 @ Override \n \n \t1 public Map < String , Object > getAttributes ( final Principal p ) { \n \n \t2 final Map < String , Object > cachedAttributes = getPrincipalAttributes ( p ) ; \n \n \t2 if ( cachedAttributes != null && ! cachedAttributes . isEmpty ( ) ) { \n \n <ect>
\t1 public void testSize ( ) { \n \n \t2 Log . info ( Log . FAC_TEST , <string_literal> ) ; \n \n \t2 ef = Exclude . uptoFactory ( b1 ) ; \n \n \t2 assertTrue ( ef . size ( ) == <number_literal> ) ; \n \n <ect>
\t2 GHEventPayload . Push push ; \n \n \t2 try { \n \n \t3 push = GitHub . offline ( ) . parseEventPayload ( new StringReader ( event . getPayload ( ) ) , GHEventPayload . Push . class ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
@ Override \n \n public TerminateFragmentResponseProto terminateFragment ( \n \n \t1 TerminateFragmentRequestProto request ) throws IOException { \n \n \t1 String fragmentId = request . getFragmentIdentifierString ( ) ; \n \n <ect>
\t1 if ( newValue == null ) { \n \n \t2 LOG . error ( <string_literal> + t . getFieldName ( ) ) ; \n \n \t2 throw new ConfigurablePropertyException ( <string_literal> + t . getFieldName ( ) ) ; \n \n \t1 } else if ( newValue . intValue ( ) < 0 ) { \n \n <ect>
\t1 } catch ( WebApplicationException ex ) { \n \n \t1 LOG . error ( <string_literal> , ex ) ; \n \n \t1 throw ex ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t4 document \n \n \t5 . insertString ( document . getLength ( ) , <string_literal> , style ) ; } \n \n \t3 catch ( BadLocationException e ) \n \n \t3 { \n \n <ect>
\t4 context . getJobScheduler ( ) . restart ( ) ; } } \n \n \t2 super . bindingChanged ( provider , itemName ) ; } \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n <ect>
\t4 error . setFunctionError ( invokeResult . getFunctionError ( ) ) ; \n \n \t4 error . fillInStackTrace ( method . getDeclaringClass ( ) ) ; \n \n \t4 return getExceptionToThrow ( method , error ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 } catch ( ResourceUnavailableException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t7 } else if ( command instanceof PercentType ) { \n \n \t8 if ( mDevice instanceof SetPointActor ) { \n \n \t9 ( ( SetPointActor < ? > ) mDevice ) . setValue ( ( ( PercentType ) command ) , \n \n <number_literal> provider . getDeviceOptions ( itemName ) ) ; \n \n <ect>
@ Override \n \n public File perform ( File inputFile ) { \n \n \t1 File outputFile = onPerform ( inputFile ) ; \n \n \t1 if ( ! inputFile . delete ( ) ) \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( fs . getAvailableRefs ( ) . length ( ) < = 0 ) { \n \n \t4 BlobCollectionType . DEFAULT . retrieve ( blobStore , fs , getBatchCount ( ) ) ; \n \n <ect>
\t3 cancelCompaction_result result = new cancelCompaction_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 { \n \n \t3 logger . error ( <string_literal> , exc ) ; } \n \n \t2 catch ( ParserConfigurationException exc ) \n \n \t2 { \n \n <ect>
\t5 logger . error ( <string_literal> + e , e ) ; \n \n \t5 try { \n \n \t6 Thread . sleep ( <number_literal> ) ; \n \n \t5 } catch ( Exception e2 ) { \n \n <ect>
\t2 DatagramSocket socket = new DatagramSocket ( ) ; \n \n \t2 InetAddress address = InetAddress . getByName ( <string_literal> ) ; \n \n \t2 byte [ ] data = input . getBytes ( ) ; \n \n \t2 DatagramPacket packet = new DatagramPacket ( data , data . length , address , getPort ( ) ) ; \n \n <ect>
\t2 if ( shutdown . get ( ) ) { \n \n \t3 LOG . info ( <string_literal> ) ; \n \n \t3 break ; \n \n \t2 } else { \n \n <ect>
\t1 } catch ( Exception e ) { \n \n \t2 if ( PersistenceExceptions . isStaleUpdate ( e ) ) { \n \n \t2 logger . debug ( <string_literal> + routeKey + <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t1 LOG . info ( <string_literal> ) ; \n \n \t1 <comment> \n \n \t1 agentHostname = StringUtils . trim ( agentHostname ) ; \n \n \t1 if ( StringUtils . isEmpty ( agentHostname ) ) { \n \n <ect>
\t1 @ DB \n \n \t1 public boolean remove ( Long id ) { \n \n \t2 <comment> \n \n \t2 if ( id != null && id . longValue ( ) == Domain . ROOT_DOMAIN ) { \n \n <ect>
\t2 final long initUsedMemory = Runtime . getRuntime ( ) . totalMemory ( ) - Runtime . getRuntime ( ) . freeMemory ( ) ; \n \n \t2 sendMessages ( <number_literal> ) ; \n \n \t2 Runtime . getRuntime ( ) . gc ( ) ; \n \n \t2 long usedMem = Runtime . getRuntime ( ) . totalMemory ( ) - Runtime . getRuntime ( ) . freeMemory ( ) - initUsedMemory ; \n \n <ect>
\t5 rootObject = invocation . getStack ( ) . peek ( ) ; \n \n \t4 <comment> \n \n \t4 populator . populateObject ( rootObject , json ) ; \n \n \t3 } else { \n \n <ect>
\t7 <comment> \n \n \t7 if ( ! mailMessage . hasAttachments ( ) ) { \n \n \t7 mailMessage . editingContext ( ) . deleteObject ( mailMessage ) ; } } \n \n \t5 } else { \n \n <ect>
\t1 return configFilterSet ; } \n \n \t1 private Set < String > validateSources ( Set < String > channelSet ) { \n \n \t1 <comment> \n \n \t1 if ( sources == null || sources . isEmpty ( ) ) { \n \n <ect>
\t6 catch ( HResultException hre ) \n \n \t6 { \n \n \t7 written = 0 ; \n \n \t7 ret = BUFFER_PROCESSED_FAILED ; \n \n <ect>
\t2 EntityManager em = context . get ( EntityManager . class ) ; \n \n \t2 boolean entityCreated = false ; \n \n \t2 for ( EntityRef entity : em . getAllEntities ( ) ) { \n \n \t3 entityCreated = true ; \n \n <ect>
\t1 } else if ( sortRel . fetch == null ) { \n \n \t2 LOG . debug ( <string_literal> + sortRel . getId ( ) + <string_literal> + sortRel . getRelTypeName ( ) \n \n \t3 + <string_literal> ) ; \n \n \t1 } else { \n \n <ect>
\t5 try { \n \n \t6 proto = Integer . parseInt ( s ) ; \n \n \t5 } catch ( NumberFormatException e ) { \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t2 if ( _secretKey . get ( ) == null ) { \n \n \t3 s_logger . error ( <string_literal> + username ) ; \n \n \t3 return - 1 ; \n \n \t2 } else { \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; <comment> \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t3 return eventTypes ; \n \n \t2 } catch ( final IllegalArgumentException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t2 } catch ( final IllegalAccessException e ) { \n \n <ect>
\t2 if ( mDevice instanceof OLEDBricklet ) { \n \n \t3 ( ( OLEDBricklet ) mDevice ) . simpleGauge ( angle ) ; \n \n \t3 return true ; \n \n \t2 } else { \n \n <ect>
\t4 return false ; } \n \n \t3 if ( altCE2 . getOperator ( ) == CigarOperator . I || altCE2 . getOperator ( ) == CigarOperator . D ) { \n \n \t4 indelCE = altCE2 ; \n \n \t3 } else { \n \n <ect>
\t4 { \n \n \t5 List < Object > feedback = interpolator . getFeedback ( ) ; \n \n \t5 if ( feedback != null && ! feedback . isEmpty ( ) ) \n \n \t5 { \n \n <ect>
\t1 if ( acceptThread != null ) { \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 while ( acceptThread . isAlive ( ) ) { \n \n \t2 try { \n \n <ect>
\t2 for ( int i = 0 ; i < Math . min ( expectedEvents . size ( ) , eventList . size ( ) ) ; i ++ ) { \n \n \t3 if ( ! expectedEvents . get ( i ) . equals ( eventList . get ( i ) ) ) { \n \n \t4 status = false ; \n \n \t4 log . info ( String . format ( <string_literal> , i , eventList . get ( i ) , expectedEvents . get ( i ) ) ) ; } } \n \n <ect>
\t3 m . appendReplacement ( sb , <string_literal> ) ; \n \n \t3 hasNonPrintable = true ; } \n \n \t2 m . appendTail ( sb ) ; \n \n \t2 if ( hasNonPrintable ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 retryMap . remove ( snapshotId ) ; \n \n <ect>
\t5 newTemplate . setSize ( prop . getSize ( ) ) ; \n \n \t5 newTemplate . setPhysicalSize ( prop . getPhysicalSize ( ) ) ; \n \n \t5 return new CopyCmdAnswer ( newTemplate ) ; \n \n \t4 } catch ( ConfigurationException e ) { \n \n <ect>
\t2 extTableThread . join ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t2 LOG . debug ( <string_literal> + e . getMessage ( ) ) ; } \n \n \t2 counter . stopClock ( ) ; \n \n <ect>
\t6 log . info ( <string_literal> + handle + <string_literal> ) ; } \n \n \t5 break ; \n \n \t4 case Constants . COLLECTION : \n \n \t5 buildDocument ( context , ( Collection ) dso ) ; \n \n <ect>
\t4 <comment> \n \n <ect>
\t1 this . importStream . close ( ) ; \n \n \t1 this . importStream = null ; } \n \n \t1 if ( null != this . mysqlImportProcess ) { \n \n \t1 <comment> \n \n <ect>
\t2 for ( int i = 0 ; i < count ; i ++ ) { \n \n \t3 realm = st . nextToken ( ) ; } \n \n \t2 realm = realm . toUpperCase ( ) ; \n \n \t2 if ( StringUtils . isBlank ( realm ) || ! realmMap . containsKey ( realm ) ) { \n \n <ect>
\t3 final long delay = <number_literal> * <number_literal> * <number_literal> ; \n \n \t3 gcTimerTask = new TimerTask ( ) { \n \n \t4 @ Override \n \n \t4 public void run ( ) { \n \n <ect>
\t3 if ( abbrevDict . containsKey ( sb . toString ( ) ) ) { \n \n \t4 break ; <comment> \n \n \t3 if ( tryLowerCase ) { \n \n \t4 sb . setCharAt ( 0 , Character . toLowerCase ( sb . charAt ( 0 ) ) ) ; \n \n <ect>
\t4 <comment> \n \n \t4 searchRequestBuilder . get ( ) ; \n \n \t4 success = true ; \n \n \t3 } catch ( SearchPhaseExecutionException ex ) { \n \n <ect>
\t2 } catch ( UnknownHostException e ) { \n \n \t3 logger . warn ( <string_literal> , ip ) ; \n \n \t3 return false ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t8 synchronized ( audioUpdateLock ) { \n \n \t9 audioUpdateLock . wait ( <number_literal> ) ; } \n \n \t7 } catch ( InterruptedException ignored ) { } } \n \n \t5 } catch ( IOException ex ) { \n \n <ect>
\t3 setLastUsed ( \n \n \t4 getWorkbenchProperty ( LAST_USED4 ) , getWorkbenchProperty ( \n \n \t5 LAST_USED4_URL ) ) ; \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
\t2 final Service targetService = this . serviceSelectionStrategy . resolveServiceFrom ( this . webApplicationServiceFactory . createService ( serviceUrl ) ) ; \n \n \t2 final WSFederationRegisteredService svc = getWsFederationRegisteredService ( targetService ) ; \n \n \t2 final WsFederationProperties . IdentityProvider idp = casProperties . getAuthn ( ) . getWsfedIdp ( ) . getIdp ( ) ; \n \n \t2 if ( StringUtils . isBlank ( fedRequest . getWtrealm ( ) ) || ! StringUtils . equals ( fedRequest . getWtrealm ( ) , svc . getRealm ( ) ) ) { \n \n <ect>
\t6 if ( logMINOR ) Logger . minor ( this , <string_literal> + tag + <string_literal> + entry . getKey ( ) ) ; \n \n \t6 transfersOut += tag . expectedTransfersOut ( ignoreLocalVsRemote , transfersPerInsert , false ) ; \n \n \t6 transfersIn += tag . expectedTransfersIn ( ignoreLocalVsRemote , transfersPerInsert , false ) ; \n \n \t6 count ++ ; \n \n <ect>
\t2 { \n \n \t3 return new Integer ( value ) ; } \n \n \t2 catch ( RuntimeException e ) \n \n \t2 { \n \n <ect>
\t1 public void receive ( long id , Message msg ) { \n \n \t2 Address sender = msg . getSrc ( ) ; \n \n \t2 if ( sender == null ) { \n \n \t3 if ( log . isErrorEnabled ( ) ) \n \n <ect>
\t4 throw UncheckedException . throwAsUncheckedException ( failure , true ) ; } \n \n \t2 } finally { \n \n \t3 setCurrentBuildOperation ( parentOperation ) ; \n \n \t3 newOperation . setRunning ( false ) ; \n \n <ect>
\t3 Object content = url . openConnection ( ) . getContent ( ) ; \n \n \t3 File f = ( File ) m . invoke ( content ) ; \n \n \t3 path = f . getPath ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 FreeListBlock . initPage ( file , page ) ; \n \n \t4 writeSuperBlock ( ) ; \n \n \t4 flb = null ; } \n \n \t2 } catch ( IOException ioe ) { \n \n <ect>
<comment> \n \n \t1 private void sendRequest ( OutboundEstablishState state ) { \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t9 break ; \n \n \t8 case NOT_FOUND : \n \n \t8 case UPDATED : \n \n \t8 default : \n \n <ect>
\t6 e . addSuppressed ( inner ) ; } \n \n \t5 throw e ; } \n \n \t3 } ) ; \n \n \t2 } catch ( TimeoutException e ) { \n \n <ect>
\t2 assert pieces . length >= <number_literal> ; \n \n \t2 Collection < Token > tokens ; \n \n \t2 tokens = getTokensFor ( endpoint ) ; \n \n <ect>
\t4 . put ( <string_literal> , randomIntBetween ( <number_literal> , <number_literal> ) , ByteSizeUnit . BYTES ) \n \n \t3 ) ) ; \n \n \t2 createIndex ( <string_literal> , <string_literal> ) ; \n \n \t2 ensureGreen ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 protected void stopInner ( ) throws VoldemortException { \n \n \t2 List < VoldemortException > exceptions = new ArrayList < VoldemortException > ( ) ; \n \n <ect>
\t8 if ( optionPrintDebug ) { \n \n \t9 logger . debug ( <string_literal> + tn1 . setNumber + <string_literal> + tn2 . setNumber ) ; \n \n \t9 logger . debug ( <string_literal> + tn1 . group . criticalSections . size ( ) \n \n <number_literal> + <string_literal> + tn2 . group . criticalSections . size ( ) ) ; \n \n <ect>
\t2 public void run ( ) { \n \n \t3 try { \n \n \t4 time = System . currentTimeMillis ( ) ; \n \n \t3 } catch ( Throwable th ) { \n \n <ect>
\t2 if ( ! initializeOpenVRLibrary ( ) ) { \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! initializeJOpenVR ( ) ) { \n \n <ect>
\t2 args . add ( <string_literal> ) ; \n \n \t2 try { \n \n \t3 HybridCubeCLI . main ( args . toArray ( new String [ args . size ( ) ] ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 public MediaInfo ( ) { \n \n \t2 try { \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 Handle = MediaInfoDLL_Internal . INSTANCE . New ( ) ; \n \n <ect>
\t2 tableDesc . addFamily ( colDesc ) ; \n \n \t2 admin . createTable ( tableDesc ) ; \n \n \t1 } else { \n \n \t2 LOG . warn ( <string_literal> + tableName ) ; \n \n <ect>
\t1 } else if ( msge . getMessage ( ) instanceof Throwable ) { \n \n \t2 ctx . sendDownstream ( e ) ; \n \n \t1 } else { \n \n \t2 e . getFuture ( ) . cancel ( ) ; \n \n <ect>
\t2 s_logger . debug ( details ) ; \n \n \t2 try { \n \n \t3 SshHelper . scpTo ( routerIp , <number_literal> , <string_literal> , permKey , null , path , content . getBytes ( ) , filename , null ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t4 try { \n \n \t5 StringTokenizer tokenizer = new StringTokenizer ( property , <string_literal> ) ; \n \n \t5 setConnectionInitSqls ( Collections . list ( tokenizer ) ) ; \n \n \t4 } catch ( NumberFormatException e ) { \n \n <ect>
\t1 VolumeManager fs = master . getFileSystem ( ) ; \n \n \t1 mbw = master . getConnector ( ) . createBatchWriter ( MetadataTable . NAME , new BatchWriterConfig ( ) ) ; \n \n \t1 zis = new ZipInputStream ( fs . open ( path ) ) ; \n \n \t1 Map < String , String > fileNameMappings = readMappingFile ( fs , tableInfo ) ; \n \n <ect>
\t2 super . processBindingConfiguration ( context , item , bindingConfig ) ; \n \n \t2 if ( bindingConfig != null ) { \n \n \t3 parseAndAddBindingConfig ( item , bindingConfig ) ; \n \n \t2 } else { \n \n <ect>
<comment> \n \n \t1 @ Nullable \n \n \t1 protected InvocableHandlerMethod getExceptionHandlerMethod ( HandlerMethod handlerMethod , Exception exception ) { \n \n <ect>
\t2 lb = lookupAuthorizedByNameOrDnsName ( ctx . getAccountNumber ( ) , lbName ) ; \n \n \t1 } catch ( final LoadBalancingException e ) { \n \n \t2 throw e ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t1 try { \n \n \t2 exceptionsCache . get ( cacheKey , new Callable < Throwable > ( ) { \n \n \t2 @ Override \n \n \t2 public Throwable call ( ) { \n \n <ect>
\t5 else if ( _log . shouldLog ( Log . INFO ) ) \n \n \t6 _log . info ( direction + <string_literal> ) ; \n \n \t4 } catch ( IOException ioe ) { \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t5 else \n \n \t6 fut . onError ( new GridException ( <string_literal> + CU . txString ( this ) ) ) ; } \n \n \t4 catch ( GridCacheTxOptimisticException e ) { \n \n <ect>
\t3 <comment> \n \n \t3 Index index = resolveIndex ( <string_literal> ) ; \n \n \t3 IndexShard replica = internalCluster ( ) . getInstance ( IndicesService . class , replicaNode ) . getShardOrNull ( new ShardId ( index , 0 ) ) ; \n \n \t3 replica . flush ( new FlushRequest ( ) ) ; \n \n <ect>
\t2 if ( groupCount == 0 ) { <comment> \n \n \t3 log . info ( <string_literal> ) ; \n \n \t2 } else { \n \n \t3 if ( running ) { \n \n <ect>
\t3 try { \n \n \t4 sock . setEnabledProtocols ( protocols ) ; \n \n \t3 } catch ( IllegalArgumentException e ) { <comment> \n \n <ect>
\t2 failedCount ++ ; \n \n \t2 handleCounter . decrementAndGet ( ) ; \n \n \t2 if ( id instanceof Long ) { \n \n \t3 Long failId = ( Long ) id ; \n \n <ect>
\t2 <comment> \n \n \t2 names = mbeanServer . queryNames ( on , null ) ; \n \n \t2 assertEquals ( services , names . size ( ) ) ; \n \n \t2 <comment> \n \n <ect>
\t1 colValues . add ( row . getRow ( ) [ colNum ] ) ; } \n \n \t1 return ParseUtils . detectHiveColumnDataType ( colValues ) ; } \n \n @ Override \n \n public PreviewData parsePreview ( ) { \n \n <ect>
\t5 logger . info ( <string_literal> + getClass ( ) . getSimpleName ( ) ) ; } \n \n \t4 try { \n \n \t5 stopInternal ( ) ; } \n \n \t4 catch ( Throwable ex ) { \n \n <ect>
\t1 workflow . fireEvents ( options ) ; \n \n \t1 } catch ( final WorkflowExecutionAlreadyStartedException ex ) { \n \n \t1 ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t3 logger . trace ( <string_literal> , dropboxEntryFile . getPath ( ) ) ; \n \n \t3 dropboxEntries = extractDropboxEntries ( dropboxEntryFile ) ; } \n \n \t2 Map < String , Long > localEntries = new HashMap < String , Long > ( ) ; \n \n \t2 collectLocalEntries ( localEntries , contentDir ) ; \n \n <ect>
\t3 if ( providersToImplement . contains ( element . getProvider ( ) ) ) { \n \n \t4 if ( element . implementVpc ( vpc , dest , context ) ) { \n \n \t5 s_logger . debug ( <string_literal> + vpc + <string_literal> ) ; \n \n \t4 } else { \n \n <ect>
\t6 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n \t7 _log . debug ( <string_literal> + bitfields [ i ] + <string_literal> + from . getRemotePeer ( ) ) ; \n \n \t6 newAck = true ; \n \n \t5 } else if ( _log . shouldLog ( Log . DEBUG ) ) { \n \n <ect>
\t6 result . put ( pair . getKey ( ) , values ) ; \n \n \t5 } else { \n \n \t6 result . put ( pair . getKey ( ) , new ArrayList < > ( Collections . singletonList ( pair . getValue ( ) ) ) ) ; } } } \n \n \t2 } catch ( URISyntaxException e ) { \n \n <ect>
private ErrorTypeRepository errorTypeRepository ; \n \n private ConfigurationComponentLocator componentLocator ; \n \n static { \n \n \t1 <comment> \n \n <ect>
\t4 <comment> <ect>
\t5 temp . delete ( ) ; \n \n \t5 Logger . error ( this , <string_literal> + version + <string_literal> + toString + <string_literal> + e , e ) ; \n \n \t5 System . err . println ( <string_literal> + version + <string_literal> + toString + <string_literal> + e ) ; \n \n \t4 } else { \n \n <ect>
\t3 pstmt . executeBatch ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t4 result = new DynamicHtmlView ( action . getContent ( ) ) ; \n \n \t3 } else { \n \n \t4 final URIBuilder builder = new URIBuilder ( action . getLocation ( ) ) ; \n \n \t4 final String url = builder . toString ( ) ; \n \n <ect>
\t1 public byte [ ] composeRecord ( String value , byte [ ] response , RecordDefinition recordDefinition ) \n \n \t3 throws StiebelHeatPumpException { \n \n \t2 short newValue = 0 ; \n \n \t2 if ( recordDefinition . getDataType ( ) != Type . Settings ) { \n \n <ect>
\t4 List < FileWatcherEvent > events = poller . takeEvents ( ) ; \n \n \t4 if ( events != null ) { \n \n \t5 deliverEvents ( events ) ; } \n \n \t3 } catch ( ClosedWatchServiceException e ) { \n \n <ect>
\t3 i += <number_literal> ; } \n \n \t2 String content = encodeDataArgs ( vmDataArgs ) ; \n \n \t2 String tmpFileName = UUID . randomUUID ( ) . toString ( ) ; \n \n <ect>
\t3 if ( cred != null ) { \n \n \t4 creds . add ( cred ) ; } \n \n \t2 } ) ; \n \n \t2 config . setSigningCredentials ( creds ) ; \n \n <ect>
\t4 OutputStream outputStream = socket . getOutputStream ( ) ; \n \n \t4 for ( int i = 0 ; i < <number_literal> ; i ++ ) { \n \n \t5 writeByte ( outputStream , 0x02 , true ) ; \n \n \t5 outputStream . write ( TEST_STRING . getBytes ( ) ) ; \n \n <ect>
\t4 s_logger . debug ( <string_literal> + host . getId ( ) + <string_literal> + cpuCap . getUsedCapacity ( ) + <string_literal> + \n \n \t5 cpuCap . getReservedCapacity ( ) ) ; \n \n \t3 } else { \n \n \t4 if ( cpuCap . getReservedCapacity ( ) != reservedCpu ) { \n \n <ect>
\t1 private static final Logger s_logger = Logger . getLogger ( LibvirtOvsFetchInterfaceCommandWrapper . class ) ; \n \n \t1 @ Override \n \n \t1 public Answer execute ( final OvsFetchInterfaceCommand command , final LibvirtComputingResource libvirtComputingResource ) { \n \n \t2 final String label = command . getLabel ( ) ; \n \n <ect>
\t2 int COUNT = between ( <number_literal> , <number_literal> ) ; \n \n \t2 IndexRequestBuilder [ ] indexRequestBuilders = new IndexRequestBuilder [ COUNT ] ; \n \n \t2 for ( int i = 0 ; i < COUNT ; i ++ ) { \n \n \t3 indexRequestBuilders [ i ] = client ( ) . prepareIndex ( <string_literal> , <string_literal> , Integer . toString ( i ) ) . setSource ( <string_literal> , <string_literal> + i ) ; } \n \n <ect>
\t2 fileSystem . close ( ) ; \n \n \t2 return null ; } \n \n \t1 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 } finally { \n \n \t4 IOUtils . closeStream ( is ) ; } \n \n \t3 return ExecuteResult . createSucceed ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t5 propertyValue = tmp ; } \n \n \t3 if ( propertyName != null && propertyValue != null ) { \n \n \t4 String deprecated_msg = annotation . deprecatedMessage ( ) ; \n \n \t4 if ( deprecated_msg != null && ! deprecated_msg . isEmpty ( ) ) { \n \n <ect>
\t3 getElectionAlg ( ) . shutdown ( ) ; } \n \n \t2 try { \n \n \t3 zkDb . close ( ) ; \n \n \t2 } catch ( IOException ie ) { \n \n <ect>
\t5 bytesSentAndReceived [ 1 ] += stat_entry . get_totalresponsebytes ( ) ; \n \n \t5 if ( bytesSentAndReceived [ 0 ] >= 0 && bytesSentAndReceived [ 1 ] >= 0 ) { \n \n \t6 answer . ipBytes . put ( lbVirtualServerIp , bytesSentAndReceived ) ; } } } \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t1 snamenode ( action = <string_literal> ) \n \n @ OsFamilyImpl ( os_family = OsFamilyImpl . DEFAULT ) \n \n class SNameNodeDefault ( SNameNode ) : \n \n def pre_upgrade_restart ( self , env , upgrade_type = None ) : \n \n <ect>
\t2 if ( jstormClientContext . shellArgs . length > 0 ) { \n \n \t3 addToLocalResources ( fs , null , JOYConstants . shellArgsPath , appId . toString ( ) , \n \n \t5 localResources , StringUtils . join ( jstormClientContext . shellArgs , JOYConstants . BLANK ) ) ; } \n \n \t2 <comment> \n \n <ect>
\t3 uncommittedPuts . removeAll ( record . getTransactionID ( ) ) ; \n \n \t3 } else { \n \n \t3 uncommittedTakes . removeAll ( record . getTransactionID ( ) ) ; } } } } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 String hStatus = null ; \n \n \t2 String [ ] frameParts = null ; \n \n \t2 ProtocolRead event = null ; \n \n \t2 if ( frame . isEmpty ( ) ) { \n \n <ect>
\t1 public void processClass ( Class klass ) { \n \n \t1 if ( this . out == null ) { \n \n \t2 if ( this . outFile . exists ( ) ) { \n \n \t2 if ( ! this . outFile . delete ( ) ) { \n \n <ect>
\t3 if ( conn != null ) { \n \n \t4 try { \n \n \t5 Session . logout ( conn ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 return getSnapshotGroup ( getConversation ( executionId ) ) . nextSnapshotId ( ) ; } \n \n \t1 <comment> \n \n \t1 public FlowExecution getFlowExecution ( FlowExecutionKey key ) { \n \n <ect>
\t7 PhysicalNetwork physicalNetwork = _physicalNetworkDao . findById ( physicalNetworkId ) ; \n \n \t7 if ( physicalNetwork == null ) { \n \n \t8 throw new InvalidParameterValueException ( <string_literal> + physicalNetworkId + <string_literal> \n \n \t10 + requiredOfferings . get ( 0 ) . getTags ( ) ) ; } \n \n <ect>
\t1 { \n \n \t2 assert ! sstables . isEmpty ( ) ; <comment> \n \n \t2 if ( ! cfs . getDataTracker ( ) . markCompacting ( sstables ) ) \n \n \t2 { \n \n <ect>
\t4 default : \n \n \t5 assert false ; \n \n \t5 break ; } \n \n \t3 } else { \n \n <ect>
\t2 # in configurations , if 'capacity - scheduler' changed in current invocation . \n \n \t2 if not capacity_scheduler_properties : \n \n \t2 if isinstance ( cap_sched_props_as_dict , dict ) and len ( cap_sched_props_as_dict ) > 1 : \n \n \t3 capacity_scheduler_properties = cap_sched_props_as_dict \n \n <ect>
\t1 try { \n \n \t2 tm ( 0 ) . commit ( ) ; \n \n \t2 assert false ; \n \n \t1 } catch ( Throwable e ) { \n \n <ect>
\t7 this . markForUpdate ( x + this . x_offset , src_y , z + this . z_offset ) ; \n \n \t7 dst . markForUpdate ( x + dst . x_offset , dst_y , z + dst . z_offset ) ; } } } } \n \n \t3 long endTime = System . nanoTime ( ) ; \n \n \t3 long duration = endTime - startTime ; \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t1 try { \n \n \t1 threadPool . shutdown ( ) ; \n \n \t1 if ( ! threadPool . awaitTermination ( <number_literal> , TimeUnit . SECONDS ) ) { \n \n <ect>
\t2 } ; \n \n \t2 int numFiles = ( ( KahaDBPersistenceAdapter ) broker . getPersistenceAdapter ( ) ) . getDirectory ( ) . list ( justLogFiles ) . length ; \n \n \t2 if ( numFiles > <number_literal> ) { \n \n \t3 LOG . info ( Arrays . toString ( ( ( KahaDBPersistenceAdapter ) broker . getPersistenceAdapter ( ) ) . getDirectory ( ) . list ( justLogFiles ) ) ) ; } \n \n <ect>
\t3 public void nodeNotAdded ( ) { \n \n \t4 Logger . normal ( this , <string_literal> + seed . userToString ( ) + <string_literal> ) ; } \n \n \t3 @ Override \n \n \t3 public void relayedNoderef ( ) { \n \n <ect>
\t3 s_logger . debug ( String . format ( <string_literal> + \n \n \t5 <string_literal> , network_id ) ) ; \t2 } } \n \n \t1 private void handleSetupBridgeAnswer ( Answer [ ] answers ) { \n \n \t2 <comment> \n \n <ect>
\t6 long accountResourceCount = recalculateAccountResourceCount ( account . getId ( ) , type ) ; \n \n \t6 newResourceCount += accountResourceCount ; <comment> \n \n \t4 _resourceCountDao . setResourceCount ( domainId , ResourceOwnerType . Domain , type , newResourceCount ) ; \n \n \t4 if ( oldResourceCount != newResourceCount ) { \n \n <ect>
\t2 } catch ( SQLException sql ) { \n \n \t2 <comment> \n \n \t1 long end = System . currentTimeMillis ( ) ; \n \n \t1 if ( ( end - start ) > 60000l ) { \n \n <ect>
\t7 @ QueryParam ( <string_literal> ) String user , \n \n \t7 @ QueryParam ( <string_literal> ) String token , \n \n \t7 @ QueryParam ( <string_literal> ) String sudo ) { \n \n \t2 String id = KVUtils . getValue ( kv , <string_literal> , <string_literal> , <string_literal> ) ; \n \n <ect>
\t5 task . name } \n \n \t3 } else { \n \n \t4 <string_literal> } \n \n \t2 } catch ( e : Exception ) { \n \n <ect>
\t2 assertEquals ( responseCode , <number_literal> ) ; \n \n \t2 conn . disconnect ( ) ; } \n \n \t1 @ Test \n \n \t1 public void testMissingVectorClock ( ) { \n \n <ect>
boolean logRequest ( ) { \n \n \t1 boolean alreadyOwned = lock . isHeldByCurrentThread ( ) ; \n \n \t1 if ( ! alreadyOwned ) { \n \n <ect>
\t1 ParseStatus parse ( final Collection < String > buffer ) { \n \n \t2 assert buffer \n \n \t2 sourceBuffer = new SourceBuffer ( ) \n \n \t2 def source = buffer . join ( Parser . NEWLINE ) \n \n <ect>
\t2 tryAddInt ( doc , <string_literal> , user . get ( <string_literal> ) ) ; \n \n \t2 tryAddString ( doc , <string_literal> , user . get ( <string_literal> ) ) ; \n \n \t2 tryAddString ( doc , <string_literal> , user . get ( <string_literal> ) ) ; \n \n \t2 incrementNumRecords ( ) ; \n \n <ect>
\t4 dnld . setTemplatesize ( info . virtualSize ) ; \n \n \t4 dnld . setTemplatePhysicalSize ( info . size ) ; \n \n \t4 break ; } } \n \n \t2 if ( ! loc . save ( ) ) { \n \n <ect>
\t6 new SimplePropertyDescriptor ( pd ) ) ; } \n \n \t3 catch ( IntrospectionException ex ) { \n \n \t4 <comment> \n \n <ect>
\t3 connection = null ; } \n \n \t2 if ( brokerService != null ) { \n \n \t3 brokerService . stop ( ) ; \n \n \t3 brokerService = null ; } \n \n <ect>
\t1 if ( split . hasBase ( ) ) { \n \n \t1 AcidOutputFormat . Options acidIOOptions = \n \n \t2 AcidUtils . parseBaseOrDeltaBucketFilename ( split . getPath ( ) , conf ) ; \n \n \t1 if ( acidIOOptions . getBucketId ( ) < 0 ) { \n \n <ect>
\t3 if ( ! containsName ) { \n \n \t4 PersonName tmpName = constructTemporaryName ( newName ) ; \n \n \t4 preferred . addName ( tmpName ) ; \n \n \t4 mergedData . addCreatedName ( tmpName . getUuid ( ) ) ; \n \n <ect>
\t4 s_logger . debug ( <string_literal> + dataCenterId + <string_literal> ) ; } \n \n \t3 return null ; } \n \n <ect>
\t2 String localHostName = <string_literal> ; \n \n \t2 try { \n \n \t3 localHostName = InetAddressUtil . getLocalHostName ( ) ; \n \n \t2 } catch ( UnknownHostException e ) { \n \n <ect>
\t3 for ( Repository repository : repositories ) { \n \n \t4 if ( repository . getType ( ) == RepositoryType . URL ) { \n \n \t5 URL url = buildClassLoaderUrl ( repository . getLocation ( ) ) ; \n \n <ect>
\t4 LOGGER . warning ( <string_literal> + ncdfe ) ; \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t3 if ( mimeTypes == null ) { \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t4 ctx . close ( ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 if ( getConfig ( ) . hasShutdownLock ( ) ) { \n \n \t3 try { \n \n \t4 response . sendError ( <number_literal> , <string_literal> ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 if ( root != null ) { \n \n \t4 LOG . error ( <string_literal> , root . toString ( ) , e ) ; } \n \n \t3 else { \n \n \t4 LOG . error ( <string_literal> , e ) ; } \n \n <ect>
\t1 private Set < Event > checkRequireMultifactorProvidersForRequest ( final RequestContext context , final RegisteredService service , \n \n <number_literal> final Authentication authentication ) { \n \n \t2 final ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; \n \n \t2 final String clientIp = clientInfo . getClientIpAddress ( ) ; \n \n <ect>
\t4 String value = nextOption ( ) ; \n \n \t4 if ( android_jars . isEmpty ( ) ) \n \n \t5 android_jars = value ; \n \n \t4 else { \n \n <ect>
\t2 if ( StringUtils . isBlank ( ticketId ) ) { \n \n \t3 return null ; } \n \n \t2 final TicketDefinition metadata = this . ticketCatalog . find ( ticketIdToGet ) ; \n \n \t2 if ( metadata == null ) { \n \n <ect>
\t3 log . debug ( <string_literal> , this . getJobKey ( ) ) ; } \n \n \t2 require ( ! execute || testTaskIdle ( ) , <string_literal> ) ; \n \n \t2 try { \n \n <ect>
\t2 nanoScheduler . shutdown ( ) ; } \n \n \t1 @ Test ( enabled = true && ! DEBUG , dataProvider = <string_literal> , dependsOnMethods = <string_literal> , timeOut = <number_literal> * NANO_SCHEDULE_MAX_RUNTIME ) \n \n \t1 public void testNanoSchedulerInLoop ( final NanoSchedulerBasicTest test ) throws InterruptedException { \n \n \t2 if ( test . bufferSize > 1 ) { \n \n <ect>
\t1 try { \n \n \t1 if ( ! executionScheduler . isSchedulerStarted ( ) ) { \n \n \t2 executionScheduler . startScheduler ( null ) ; } \n \n \t1 } catch ( SchedulerException e ) { \n \n <ect>
\t7 evict ( id , collectionPersister , session ) ; } \n \n \t6 if ( oldId != null ) { \n \n \t7 evict ( oldId , collectionPersister , session ) ; } } } \n \n \t4 else { \n \n <ect>
\t2 this . target = target ; \n \n \t2 this . retryAwareRunNotifier = retryAwareRunNotifier ; } \n \n \t1 @ Override \n \n \t1 public void fireTestStarted ( Description description ) throws StoppedByUserException { \n \n <ect>
\t2 getAllowedAttributes ( ) . entrySet ( ) . stream ( ) . filter ( entry - > WSFederationClaims . contains ( entry . getKey ( ) . toUpperCase ( ) ) ) . forEach ( entry - > { \n \n \t3 final String claimName = entry . getKey ( ) ; \n \n \t3 final String attributeName = entry . getValue ( ) ; \n \n \t3 final WSFederationClaims claim = WSFederationClaims . valueOf ( claimName . toUpperCase ( ) ) ; \n \n <ect>
\t5 return null ; } } \n \n \t2 @ Override \n \n \t2 public void setValueAt ( Object value , int row , int column ) { \n \n \t3 JMSProperty property = jmsProperties . getJmsProperty ( row ) ; \n \n <ect>
\t4 else { \n \n \t5 for ( WorkflowActionBean action : actions ) { <comment> \n \n \t6 if ( action . getStatus ( ) == WorkflowAction . Status . OK ) { \n \n \t7 nodesToSkip . add ( action . getName ( ) ) ; } } \n \n <ect>
\t5 if ( tunnel . getLength ( ) < = 1 || ! getContext ( ) . commSystem ( ) . isBacklogged ( tunnel . getPeer ( 1 ) ) ) \n \n \t6 return tunnel ; \n \n \t5 <comment> \n \n \t5 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
<comment> \n \n \t2 if ( null == theGroup ) { \n \n \t3 if ( Log . isLoggable ( Log . FAC_ACCESSCONTROL , Level . INFO ) ) { \n \n <ect>
\t3 storage . onResume ( context ) ; \n \n \t3 this . sender = new SplitFileInserterSender ( this , storage ) ; \n \n \t3 schedule ( context ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 } catch ( FetchException e ) { \n \n \t3 Logger . error ( this , <string_literal> + e , e ) ; \n \n \t3 ex = e ; \n \n \t2 } catch ( Throwable t ) { \n \n <ect>
\t1 } catch ( NullPointerException e ) { \n \n \t1 LOG . error ( <string_literal> ) ; \n \n \t1 LOG . error ( <string_literal> ) ; \n \n \t1 LOG . error ( <string_literal> ) ; \n \n <ect>
\t1 childOperatorsArray [ i ] . initialize ( hconf , outputObjInspector , childOperatorsTag [ i ] ) ; \n \n \t1 if ( reporter != null ) { \n \n \t2 childOperatorsArray [ i ] . setReporter ( reporter ) ; } } } \n \n public void abort ( ) { \n \n <ect>
\t2 try { \n \n \t3 if ( ac != null ) { \n \n \t4 ac . close ( ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 LOG . debug ( <string_literal> + parentName , e ) ; } } } } \n \n \t1 } , parentPoolName ) ; } \n \n @ Override \n \n public void deleteSnapshot ( final String parentName , final String snapName , final String parentPoolName ) { \n \n <ect>
\t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n \t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 } catch ( java . lang . Exception e ) { \n \n <ect>
\t3 aliveWithOpts . maxWith ( comparator ) ? . let { bestDaemonWithMetadata - > \n \n \t4 val fattestOpts = bestDaemonWithMetadata . jvmOptions \n \n \t4 if ( fattestOpts memorywiseFitsInto daemonJVMOptions && FileAgeComparator ( ) . compare ( bestDaemonWithMetadata . runFile , runFile ) < 0 ) { \n \n \t5 <comment> \n \n <ect>
\t6 final IoCTX io = r . ioCtxCreate ( primaryPool . getSourceDir ( ) ) ; \n \n \t6 final Rbd rbd = new Rbd ( io ) ; \n \n \t6 final RbdImage image = rbd . open ( disk . getName ( ) ) ; \n \n \t6 if ( command . getCommandSwitch ( ) . equalsIgnoreCase ( ManageSnapshotCommand . CREATE_SNAPSHOT ) ) { \n \n <ect>
\t4 <comment> \n \n \t4 <comment> \n \n \t4 ConcurrentOperationException ex = new ConcurrentOperationException ( <string_literal> ) ; } \n \n <ect>
\t4 final RpcService jobManagerRpcService ; \n \n \t4 final RpcService resourceManagerRpcService ; \n \n \t4 final RpcService [ ] taskManagerRpcServices = new RpcService [ numTaskManagers ] ; \n \n \t4 <comment> \n \n <ect>
\t2 if ( heatpumpCommand != null ) { \n \n \t3 HeatPumpBindingConfig config = parseBindingConfig ( item , HeatpumpCommandType . fromString ( heatpumpCommand ) ) ; \n \n \t3 addBindingConfig ( item , config ) ; \n \n \t2 } else { \n \n <ect>
\t2 final Pac4jDelegatedAuthenticationProperties . WindowsLive live = pac4jProperties . getWindowsLive ( ) ; \n \n \t2 if ( StringUtils . isNotBlank ( live . getId ( ) ) && StringUtils . isNotBlank ( live . getSecret ( ) ) ) { \n \n \t3 final WindowsLiveClient client = new WindowsLiveClient ( live . getId ( ) , live . getSecret ( ) ) ; \n \n \t3 configureClient ( client , live ) ; \n \n <ect>
\t3 return filenameOrURI ; \n \n \t2 String uri = mapper . altMapping ( filenameOrURI , null ) ; \n \n \t2 if ( uri == null ) { \n \n <ect>
\t1 { \n \n \t2 ByteBuffer ret = ByteBuffer . allocate ( Ints . checkedCast ( size ) ) ; \n \n \t2 long seed = System . nanoTime ( ) ; \n \n \t2 <comment> \n \n <ect>
\t1 public void work ( ) { } \n \n \t1 public void run ( ) { \n \n \t2 initialize ( ) ; \n \n \t2 System . out . println ( <string_literal> + new Date ( ) . toString ( ) + <string_literal> ) ; \n \n <ect>
\t4 public void onResponse ( PutIndexTemplateResponse response ) { \n \n \t5 if ( updatesInProgress . decrementAndGet ( ) == 0 ) { \n \n \t6 logger . info ( <string_literal> , Version . CURRENT ) ; } \n \n \t5 if ( response . isAcknowledged ( ) == false ) { \n \n <ect>
<comment> \n \n \t1 public static final void validateKey ( String key ) throws IllegalArgumentException { \n \n \t2 if ( StringUtils . isEmpty ( key ) || <string_literal> . equals ( key ) || <string_literal> . equals ( key ) || ! KEY_PATTERN . matcher ( key ) . matches ( ) ) { \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 for ( String s : Iterables . transform ( task . getDstWhCommands ( ) , commandDebugPrinter ) ) { \n \n \t2 LOG . info ( s ) ; } \n \n \t1 } else { \n \n <ect>
\t1 if ( isOpen ) { \n \n \t2 timerContext . close ( ) ; \n \n \t2 CodahaleMetrics . this . decrementCounter ( MetricsConstant . ACTIVE_CALLS + name ) ; \n \n \t1 } else { \n \n <ect>
\t5 status += <string_literal> ; \n \n \t4 } else if ( missing . getMinU ( ) == stitched . getMinU ( ) && missing . getMinV ( ) == stitched . getMinV ( ) ) { \n \n \t5 status += <string_literal> ; } \n \n \t4 BCLog . logger . info ( <string_literal> + r + status ) ; } \n \n <ect>
\t3 String filename = propertiesFile . getFilename ( ) ; \n \n \t3 Locale parsedLocale = parseLocaleFrom ( filename ) ; \n \n \t3 foundLocales . add ( parsedLocale ) ; } \n \n \t2 if ( foundLocales . isEmpty ( ) ) { \n \n <ect>
\t2 while ( ! hasChanges ) { \n \n \t2 try { \n \n \t3 hasChangesCondition . await ( 1 , TimeUnit . SECONDS ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n <ect>
\t1 { \n \n \t2 String path = getImagePath ( streamKey ) ; \n \n \t2 if ( path == null || path . length ( ) == 0 ) \n \n \t2 { \n \n <ect>
\t6 new Object [ ] { config . maxActive , config . minIdle , config . maxIdle , config . minEvictableIdleTimeMillis , pool } ) ; } \n \n \t2 } else { \n \n \t3 pool = new SharedSingletonObjectPool < ChannelFuture > ( new NettyProducerPoolableObjectFactory ( ) ) ; \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t1 TestLogger logger = new TestLogger ( logFile , TestLogger . LEVEL . INFO ) ; \n \n \t1 logger . trace ( <string_literal> ) ; \n \n \t1 logger . debug ( <string_literal> ) ; \n \n \t1 logger . info ( <string_literal> ) ; \n \n <ect>
\t3 log . info ( <string_literal> ) ; \n \n \t3 try { \n \n \t3 <comment> \n \n \t3 latch . await ( <number_literal> , TimeUnit . SECONDS ) ; \n \n <ect>
\t5 Class < ? > c = descriptor . getPropertyType ( ) ; \n \n \t5 propertyEditor = PropertyEditorManager . findEditor ( c ) ; } } \n \n \t3 if ( propertyEditor == null ) { \n \n <ect>
<comment> \n \n @ Test \n \n public void testVersionInfoUnknown ( ) { \n \n \t1 logger . debug ( <string_literal> + VersionInfo . getVersion ( ) ) ; \n \n <ect>
\t3 Element elt = qdc2element . get ( qdc ) ; \n \n \t3 <comment> \n \n \t3 if ( elt == null ) { \n \n \t4 if ( metadataField . getMetadataSchema ( ) . getName ( ) . equals ( MetadataSchema . DC_SCHEMA ) ) { \n \n <ect>
\t5 Thread . sleep ( sleepTime ) ; \n \n \t4 } catch ( InterruptedException e1 ) { \n \n \t5 logger . trace ( <string_literal> ) ; } \n \n \t4 sleepTime *= delayFactor ; } } \n \n <ect>
\t2 channel . put ( event ) ; } \n \n \t1 channel . getTransaction ( ) . commit ( ) ; \n \n \t1 } finally { \n \n \t1 channel . getTransaction ( ) . close ( ) ; } \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 boolean validateNetworkReadyToMigrate = ( network . getState ( ) == Network . State . Implemented \n \n \t4 || network . getState ( ) == Network . State . Setup \n \n \t4 || network . getState ( ) == Network . State . Allocated ) ; \n \n \t2 if ( ! validateNetworkReadyToMigrate ) { \n \n <ect>
\t2 if ( resultOut != null ) { \n \n \t2 try { \n \n \t3 resultOut . close ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 processTimerEvent ( ( TimerTrigger . TimerEvent ) event ) ; \n \n \t3 } else if ( event instanceof Tuple ) { \n \n \t4 runnable = processTupleEvent ( ( Tuple ) event ) ; \n \n \t3 } else { \n \n <ect>
\t2 hosts = prioritizeHosts ( template , hosts ) ; \n \n \t3 s_logger . debug ( <string_literal> + hosts . size ( ) + <string_literal> + hosts ) ; } \n \n <ect>
\t4 return false ; } \n \n \t3 for ( int i = tokensCanBeGivenLowerLimit ; i < = tokensCanBeGivenUpperLimit && i < = valueParts . length ; i ++ ) { \n \n \t4 ParsedWord [ ] before = Arrays . copyOf ( valueParts , i ) ; \n \n \t4 if ( CSSTokenizerFilter . auxilaryVerifiers [ verifierIndex ] . checkValidity ( before , cb ) ) { \n \n <ect>
\t2 driver . navigate ( ) . to ( getSamlIdpInitiatedUrl ( REALM_PROV_NAME , <string_literal> ) ) ; \n \n \t2 waitForPage ( <string_literal> , true ) ; \n \n \t2 Assert . assertThat ( <string_literal> , \n \n \t4 driver . getCurrentUrl ( ) , containsString ( <string_literal> + REALM_PROV_NAME + <string_literal> ) ) ; \n \n <ect>
\t4 pstmt . setLong ( <number_literal> , volumeId ) ; \n \n \t4 pstmt . executeUpdate ( ) ; } \n \n \t3 s_logger . debug ( <string_literal> ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t1 @ Override public GridNode failover ( GridFailoverContext ctx , List < GridNode > top ) { \n \n \t2 assert ctx != null ; \n \n \t2 assert top != null ; \n \n <ect>
\t5 if ( ! X . hasCause ( e , InterruptedException . class ) && ! X . hasCause ( e , GridInterruptedException . class ) ) \n \n \t6 LT . warn ( log , e , <string_literal> ) ; \n \n \t5 else { \n \n <ect>
\t1 if ( options . isValidationEnabled ( ) ) { \n \n \t2 validateImport ( tableName , conf , job ) ; } \n \n \t1 if ( options . doHiveImport ( ) || isHCatJob ) { \n \n \t2 <comment> \n \n <ect>
\t2 deployResponse . put ( <string_literal> , pvlan ) ; \n \n \t2 return deployResponse ; } \n \n \t1 protected void startNsVpx ( VMInstanceVO nsVpx , Map < Param , Object > params ) throws StorageUnavailableException , \n \n \t1 InsufficientCapacityException , ConcurrentOperationException , ResourceUnavailableException { \n \n <ect>
\t3 logger . info ( <string_literal> , block , block . getId ( ) ) ; \n \n \t3 newState . blocksById . put ( block . getId ( ) , block ) ; \n \n \t3 newState . idByUri . put ( block . getURI ( ) , block . getId ( ) ) ; \n \n \t2 } else { \n \n <ect>
\t6 ObjectName oname = new ObjectName ( name ) ; \n \n \t6 processArg ( mbeanN ) ; \n \n \t6 server . invoke ( oname , operation , null , null ) ; \n \n \t5 } catch ( Exception e ) { \n \n <ect>
\t3 log . info ( <string_literal> + book1 . getName ( ) ) ; \n \n \t3 CDIInjectionBook book2 = new CDIInjectionBook ( <string_literal> ) ; \n \n \t3 message = session . createTextMessage ( book2 . getName ( ) ) ; \n \n \t3 producer . send ( message ) ; \n \n <ect>
\t3 val currentRev = download . result . rev \n \n \t3 log . info ( TAG , <string_literal> ) \n \n \t3 currentRev \n \n \t2 } catch ( e : DownloadErrorException ) { \n \n <ect>
\t2 keyInfoProviderList . add ( new RSAKeyValueProvider ( ) ) ; \n \n \t2 keyInfoProviderList . add ( new DSAKeyValueProvider ( ) ) ; \n \n \t2 keyInfoProviderList . add ( new DEREncodedKeyValueProvider ( ) ) ; \n \n \t2 keyInfoProviderList . add ( new InlineX509DataProvider ( ) ) ; \n \n <ect>
\t2 return DatabaseDescriptor . getRpcTimeout ( ) ; } \n \n \t1 public void setReadRpcTimeout ( long value ) \n \n \t1 { \n \n \t2 DatabaseDescriptor . setReadRpcTimeout ( value ) ; \n \n <ect>
<comment> \n \n \t6 } else { \n \n \t7 logger . error ( <string_literal> + record . toString ( ) ) ; } } \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t5 grp . getSources ( ) . forEach ( Unchecked . biConsumer ( ( k , v ) - > { \n \n \t6 final Object obj = ClassUtils . getClass ( k , true ) . getDeclaredConstructor ( ) . newInstance ( ) ; \n \n \t6 if ( obj instanceof EncryptionJwtSigningJwtCryptographyProperties ) { \n \n \t7 final EncryptionJwtSigningJwtCryptographyProperties crypto = ( EncryptionJwtSigningJwtCryptographyProperties ) obj ; \n \n <ect>
\t4 log . trace ( <string_literal> ) ; } \n \n \t3 return ( params . pop ( ) ) ; \n \n \t2 } catch ( EmptyStackException e ) { \n \n <ect>
\t1 private void updateKeyPairsOnDisk ( String homeDir ) { \n \n \t2 File keyDir = new File ( homeDir + <string_literal> ) ; \n \n \t2 Boolean devel = Boolean . valueOf ( _configDao . getValue ( <string_literal> ) ) ; \n \n \t2 if ( ! keyDir . isDirectory ( ) ) { \n \n <ect>
\t4 faService . createFailSafeTransaction ( this . contactlistFile ) ; \n \n \t3 contactlistTrans . restoreFile ( ) ; } \n \n \t2 catch ( NullPointerException e ) \n \n \t2 { \n \n <ect>
\t2 for ( Host host : hosts ) { \n \n \t3 String dc = dc ( host ) ; \n \n \t3 <comment> \n \n \t3 if ( localDc == UNSET && dc != UNSET ) { \n \n <ect>
\t1 parsed_path = HdfsResourceProvider . parse_path ( self . resource . target ) \n \n \t1 parsed_not_managed_paths = [ HdfsResourceProvider . parse_path ( path ) for path in self . resource . immutable_paths ] \n \n \t1 self . manage_if_exists = not parsed_path in parsed_not_managed_paths \n \n \t1 if parsed_path in self . ignored_resources_list : \n \n <ect>
\t4 if ( indexResponse . getResult ( ) == DocWriteResponse . Result . CREATED ) { \n \n \t5 numCreated ++ ; \n \n \t5 added [ i ] = true ; } \n \n \t3 } catch ( ElasticsearchException ex ) { } } \n \n <ect>
\t2 StmtIterator manifestStmts = \n \n \t3 manifest . listStatements ( null , RDF . type , TestManifest . Manifest ) ; \n \n \t2 if ( ! manifestStmts . hasNext ( ) ) \n \n \t2 { \n \n <ect>
\t1 private NSTimestamp randomTime ( ) { \n \n \t2 return new NSTimestamp ( randomInt ( ( int ) ( System . currentTimeMillis ( ) / <number_literal> ) ) * <number_literal> ) ; } \n \n \t1 private void doCreateDummyData ( ) { \n \n \t2 try { \n \n <ect>
\t3 obj . put ( GenericJsonKeys . updateType . name ( ) , JsonValues . KarmaInfo . name ( ) ) ; \n \n \t3 obj . put ( JsonKeys . Info . name ( ) , infoMessage ) ; \n \n \t3 pw . println ( obj . toString ( ) ) ; \n \n \t2 } catch ( JSONException e ) { \n \n <ect>
\t4 { \n \n \t5 String oq = blankNodeOrIRIString ( o ) ; \n \n \t5 result . addQuad ( sq , pq , oq , gq ) ; } } } \n \n \t2 else \n \n <ect>
\t1 long start = System . currentTimeMillis ( ) ; \n \n \t1 KDDCupDataModel model = new KDDCupDataModel ( KDDCupDataModel . getTrainingFile ( dataFileDirectory ) ) ; \n \n \t1 Track2Recommender recommender = new Track2Recommender ( model , dataFileDirectory ) ; \n \n \t1 long end = System . currentTimeMillis ( ) ; \n \n <ect>
\t3 return false ; } \n \n \t2 try { \n \n \t3 caKeyPair = new KeyPair ( CertUtils . pemToPublicKey ( rootCAPublicKey . value ( ) ) , CertUtils . pemToPrivateKey ( rootCAPrivateKey . value ( ) ) ) ; \n \n \t2 } catch ( InvalidKeySpecException | IOException e ) { \n \n <ect>
<comment> \n \n \t1 public void makeNodeBdbError ( int nodeId ) { \n \n \t2 if ( nodesStatus . get ( nodeId ) != NodeStatus . BDB_ERROR ) { \n \n <ect>
\t3 throw new InvalidParameterValueException ( <string_literal> + ipAddress + <string_literal> + aggrName + <string_literal> + volName + <string_literal> ) ; } \n \n \t2 List < LunVO > lunsOnVol = _lunDao . listLunsByVolId ( volume . getId ( ) ) ; \n \n \t2 if ( lunsOnVol != null && lunsOnVol . size ( ) > 0 ) \n \n \t2 { \n \n <ect>
\t3 e . printStackTrace ( ) ; \n \n \t3 return new RevertToVMSnapshotAnswer ( cmd , false , <string_literal> ) ; } } \n \n \t1 protected Answer execute ( CreateVolumeFromSnapshotCommand cmd ) { \n \n <ect>
\t3 result . sec = ( org . apache . accumulo . core . client . impl . thrift . ThriftSecurityException ) e ; \n \n \t3 result . setSecIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
<comment> \n \n \t1 public void runFromConfig ( ServerConfig config ) \n \n \t3 throws IOException , AdminServerException { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + id ) ; \n \n \t3 throw new InvalidParameterValueException ( <string_literal> + id ) ; } \n \n \t2 <comment> \n \n \t2 if ( type != rule . getRuleType ( ) ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , url , \n \n \t4 pm . getReset ( ) . getExpirationMinutes ( ) ) ; \n \n \t2 if ( sendPasswordResetEmailToAccount ( to , url ) ) { \n \n \t3 return success ( ) ; } \n \n <ect>
\t3 new GridBiClosure < Object , Exception , Collection < GridCacheEntryInfo < K , V > > > ( ) { \n \n \t4 @ Override public Collection < GridCacheEntryInfo < K , V > > apply ( Object o , Exception e ) { \n \n \t5 if ( e != null ) { <comment> \n \n <ect>
\t3 { \n \n \t4 chunk = new Chunk ( allocateDirectAligned ( MACRO_CHUNK_SIZE ) ) ; } \n \n \t3 catch ( OutOfMemoryError oom ) \n \n \t3 { \n \n <ect>
\t4 lastAlertScanFailed = false ; \n \n \t4 log . info ( <string_literal> ) ; \n \n \t3 } catch ( Exception e ) { \n \n \t4 lastAlertScanFailed = true ; \n \n <ect>
\t2 long duration = System . currentTimeMillis ( ) - start ; \n \n \t2 { \n \n \t3 log . info ( <string_literal> + resultList . size ( ) + <string_literal> + duration + <string_literal> ) ; } \n \n <ect>
\t4 setDirection ( DirectionValue . RIGHT ) ; } \n \n \t2 } else if ( direction . equals ( UpDownType . UP ) ) { \n \n \t3 speed = Tools . getShortOpt ( ConfigOptsMove . LEFTSPEED . toString ( ) , opts ) ; \n \n \t3 if ( speed == null ) { \n \n <ect>
\t2 int index = 0 ; \n \n \t2 while ( index < toCheckwaitConditions . size ( ) && currentTime < = maxTime ) { \n \n \t3 ExpectedCondition checkCondition = toCheckwaitConditions . get ( index ) ; \n \n \t3 lastCheckCondition = checkCondition ; \n \n <ect>
\t2 context . start ( ) ; \n \n \t2 LOG . debug ( <string_literal> ) ; \n \n \t2 sendQuery ( ) ; \n \n \t2 mockSearchEndpoint . assertIsSatisfied ( ) ; \n \n <ect>
\t3 if ( indexSettings != null ) { \n \n \t4 threadPool . generic ( ) . execute ( new AbstractRunnable ( ) { \n \n \t5 @ Override \n \n \t5 public void onFailure ( Exception e ) { \n \n <ect>
\t5 } catch ( SchedulerException e ) { \n \n \t6 logger . error ( <string_literal> , \n \n \t8 e . getMessage ( ) ) ; } } \n \n \t3 } catch ( SchedulerException e ) { \n \n <ect>
@ POST \n \n @ Consumes ( MediaType . APPLICATION_JSON ) \n \n public Response saveScript ( PigScriptRequest request , @ Context HttpServletResponse response , \n \n \t7 @ Context UriInfo ui ) { \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t1 writeModel = modelWeight == 1 \n \n \t2 ? new TopicModel ( numTopics , numTerms , eta , alpha , null , numUpdateThreads ) \n \n \t2 : readModel ; \n \n <ect>
\t1 public V getOrFill ( K key , Callable < V > filler ) { \n \n \t2 try { \n \n \t3 return cache . get ( key , filler ) ; } \n \n \t2 catch ( ExecutionException e ) { \n \n <ect>
\t7 try ( PreparedStatement updateUserStatistics = conn . prepareStatement ( <string_literal> ) ; ) { \n \n \t8 updateUserStatistics . setLong ( 1 , deviceId ) ; \n \n \t8 updateUserStatistics . setLong ( <number_literal> , id ) ; \n \n \t8 updateUserStatistics . executeUpdate ( ) ; } } } } } \n \n <ect>
\t1 super . start ( ) ; \n \n \t1 logger . info ( <string_literal> , this ) ; } \n \n @ Override \n \n public void stop ( ) { \n \n <ect>
\t2 try { \n \n \t2 session . preWarm ( prewarmVertex ) ; \n \n \t2 } catch ( IOException ie ) { \n \n \t2 if ( ! isOnThread && ie . getMessage ( ) . contains ( <string_literal> ) ) { \n \n <ect>
\t2 for ( InsteonHubProxy proxy : proxies . values ( ) ) { \n \n \t3 proxy . start ( ) ; } } \n \n \t1 @ Override \n \n \t1 public synchronized void deactivate ( ) { \n \n <ect>
\t3 if ( ! vmMo . configureVm ( vmConfigSpec ) ) { \n \n \t4 throw new Exception ( <string_literal> ) ; } \n \n \t3 return new UnPlugNicAnswer ( cmd , true , <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t5 case IB_STATE_CONFIRMED_COMPLETELY : \n \n \t6 <comment> \n \n \t6 inState . addMessage ( msg ) ; \n \n \t6 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlHandlerRoleGeneratorSetupError ( Throwable t ) { \n \n <ect>
\t2 if ( reader != null ) { \n \n \t3 reclaimed . addAll ( cleaned ) ; \n \n \t3 return reader ; \n \n \t2 } else { \n \n <ect>
\t2 <comment> \n \n \t2 int counter = 0 ; \n \n \t2 for ( Map < String , String > row : data . subList ( 1 , <number_literal> ) ) { \n \n \t3 assertEquals ( <string_literal> , expectedFirstName [ counter ] , row . get ( <string_literal> ) ) ; \n \n <ect>
\t3 if ( backendResponse . getCode ( ) != HttpStatus . SC_NOT_MODIFIED ) { \n \n \t4 return handleBackendResponse ( target , request , scope , requestDate , responseDate , backendResponse ) ; } \n \n \t3 final Header resultEtagHeader = backendResponse . getFirstHeader ( HeaderConstants . ETAG ) ; \n \n \t3 if ( resultEtagHeader == null ) { \n \n <ect>
\t3 _connection . start ( ) ; \n \n \t3 s_logger . info ( <string_literal> + _listenerPort + <string_literal> ) ; \n \n \t3 while ( _connection . isRunning ( ) ) ; \n \n \t2 } catch ( final ConfigurationException e ) { \n \n <ect>
\t3 pstmt . executeUpdate ( ) ; \n \n \t3 txn . commit ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n \t3 txn . rollback ( ) ; \n \n <ect>
\t6 continue ; \n \n \t5 } else if ( keyword == null && name == null ) { \n \n \t6 templateZonePairList . add ( new Pair < Long , Long > ( publicIsos . get ( i ) . getId ( ) , null ) ) ; } } } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t1 if ( lifecycleManager . getState ( ) . isStarted ( ) ) { \n \n \t1 try { \n \n \t2 getLifecycleManager ( ) . fireLifecycle ( Stoppable . PHASE_NAME ) ; \n \n \t1 } catch ( LifecycleException e ) { \n \n <ect>
\t4 PairingInitialisationSequence ps = new PairingInitialisationSequence ( this . DEFAULT_GROUP_ID , \n \n \t6 messageHandler , configWithTempsConfig , associations ) ; \n \n \t4 messageHandler . startSequence ( ps , pkt ) ; \n \n \t3 } else { \n \n <ect>
\t1 Logger . info ( <string_literal> ) \n \n \t1 hostInfo = HostInfo ( ) \n \n \t1 last_agent_env_check_structured_output = { } \n \n \t1 hostInfo . register ( last_agent_env_check_structured_output , runExpensiveChecks = False , checkJavaProcs = True ) \n \n <ect>
\t8 entry . setValue ( snapSaved . getResourcePath ( ) ) ; } } } \n \n \t5 dstStore . putResource ( cubeResPath , cube , cubeSerializer ) ; \n \n \t5 logger . info ( <string_literal> + item + <string_literal> + snapSaved . getResourcePath ( ) + <string_literal> ) ; } \n \n \t3 } else { \n \n <ect>
\t2 if ( listener == null ) { \n \n \t3 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t2 if ( ( urls == null || urls . isEmpty ( ) ) \n \n \t4 && ! Constants . ANY_VALUE . equals ( url . getServiceInterface ( ) ) ) { \n \n <ect>
\t2 } catch ( AuthorizeException ex ) { \n \n \t3 log . error ( <string_literal> , ex ) ; \n \n \t3 fail ( <string_literal> + ex . getMessage ( ) ) ; \n \n \t2 } catch ( SQLException ex ) { \n \n <ect>
\t5 return writeString ( SESSION_ERROR , <string_literal> ) ; } \n \n \t4 dest = ( String ) props . remove ( <string_literal> ) ; \n \n \t4 if ( dest == null ) { \n \n \t5 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t4 if ( l != null && l . size ( ) > 0 && l . get ( 0 ) . second ( ) . intValue ( ) > 0 ) { \n \n \t5 return true ; \n \n \t4 } else { \n \n <ect>
\t1 JobImpl atsJob ; \n \n \t1 try { \n \n \t1 atsJob = new JobImpl ( PropertyUtils . describe ( viewJob ) ) ; \n \n \t1 } catch ( IllegalAccessException e ) { \n \n <ect>
\t2 if ( requestStr == null ) \n \n \t3 requestStr = action . request . getParameter ( paramRequest ) ; \n \n \t2 if ( action . verbose ) \n \n \t3 <comment> \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 throw processException ( e . getMessage ( ) , e ) ; } \n \n \t2 MXBeanStorage . getInstance ( ) . addMXBean ( subDomainName , bean ) ; \n \n <ect>
\t3 for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { \n \n \t4 try { \n \n \t5 listeners . get ( i ) . onStreamAdded ( stream ) ; \n \n \t4 } catch ( Throwable cause ) { \n \n <ect>
\t3 if ( returnValue . length ( ) == 0 ) { \n \n \t3 throw new EucalyptusCloudException ( <string_literal> + loDevName ) ; } \n \n \t3 returnValue = removeLoopback ( loDevName ) ; \n \n \t3 if ( ! ( new File ( rawFileName ) ) . delete ( ) ) { \n \n <ect>
\t5 message = validatorContext . getText ( key ) ; \n \n \t5 if ( convertToUtf8 && StringUtils . isNotBlank ( message ) ) { \n \n \t6 message = new String ( message . getBytes ( convertFromEncoding ) , <string_literal> ) ; } \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t2 try { \n \n \t2 finalizeExecution ( properties ) ; \n \n \t2 } catch ( AmbariException e ) { \n \n \t2 LOG . warn ( <string_literal> + jobKey ) ; } } } \n \n <ect>
\t2 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n \t1 Method m = this . getClass ( ) . getMethod ( <string_literal> + actionNum , String . class ) ; \n \n \t1 m . invoke ( this , value ) ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t3 return \n \n \t2 used_ram = get_used_ram ( ) / <number_literal> \n \n \t2 # dealing with a possible memory leaks \n \n \t2 if self . max_ram_soft and used_ram >= self . max_ram_soft and not self . actionQueue . tasks_in_progress_or_pending ( ) : \n \n <ect>
\t1 try { \n \n \t2 token = getToken ( httpRequest ) ; } \n \n \t1 catch ( AuthenticationException ex ) { \n \n \t2 ex . printStackTrace ( ) ; \n \n <ect>
\t3 String dest = ( String ) props . remove ( <string_literal> ) ; \n \n \t3 if ( dest == null ) { \n \n \t4 notifyStreamResult ( verbose , <string_literal> , <string_literal> ) ; \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 fb . close ( ) ; \n \n \t3 return ; \n \n \t3 } else if ( e instanceof org . apache . thrift . TApplicationException ) { \n \n <ect>
<comment> \n \n \t1 private void handleFailedSlotRequest ( SlotID slotId , AllocationID allocationId , Throwable cause ) { \n \n \t2 PendingSlotRequest pendingSlotRequest = pendingSlotRequests . get ( allocationId ) ; \n \n <ect>
\t3 Thread . sleep ( <number_literal> ) ; } \n \n \t2 catch ( InterruptedException ex ) \n \n \t2 { } \n \n \t2 String roomName = testRoomBaseName + roomID ; \n \n <ect>
\t4 isConnecting . set ( false ) ; \n \n \t4 Channel channel = future . getChannel ( ) ; \n \n \t4 if ( future . isSuccess ( ) ) { \n \n \t5 <comment> \n \n <ect>
\t1 try { \n \n \t2 hiveOutputFormat . checkOutputSpecs ( ignored , job ) ; \n \n \t1 } catch ( NoSuchMethodError e ) { \n \n \t2 <comment> \n \n <ect>
\t3 ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; \n \n \t3 while ( true ) { \n \n \t4 if ( this . sockJsSession . isDisconnected ( ) ) { \n \n <ect>
\t2 public void postRun ( ) { \n \n \t3 WorkerClassLoader . restoreThreadContext ( ) ; } \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n <ect>
\t1 throws ClassNotFoundException , IOException { \n \n \t1 if ( null == tableName ) { \n \n \t2 LOG . error ( \n \n \t3 <string_literal> ) ; \n \n <ect>
\t3 System . err . println ( <string_literal> + wd ) ; \n \n \t3 try { \n \n \t4 secureDelete ( wd ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 hzInstance . perform ( hazelcastInstance - > \n \n \t2 { \n \n \t3 String uuid = hazelcastInstance . getLocalEndpoint ( ) . getUuid ( ) ; \n \n \t3 String addresses = connectorAddresses . toString ( ) ; \n \n <ect>
\t6 doUpdate ( testLocalAccessStrategy , session , KEY , VALUE2 , <number_literal> ) ; \n \n \t6 return latch ; \n \n \t5 } ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
\t1 if ( ! currentItemIDs . isEmpty ( ) ) { \n \n \t2 result . put ( currentUserID , currentItemIDs ) ; } \n \n \t1 return result ; \n \n \t1 } catch ( SQLException sqle ) { \n \n <ect>
\t1 AuthenticationToken authToken = super . getToken ( ) ; \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t1 if ( authToken instanceof KerberosToken ) { \n \n <ect>
\t2 List < URL > urls = new ArrayList < URL > ( ) ; \n \n \t2 for ( File file : runtimeClasspath ) { \n \n \t3 try { \n \n \t4 urls . add ( file . toURI ( ) . toURL ( ) ) ; \n \n <ect>
\t1 if ( conn != null ) { \n \n \t2 try { \n \n \t2 conn . close ( ) ; \n \n \t2 } catch ( SQLException e ) { \n \n <ect>
\t2 for ( Iterator < BindingOperation > iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { \n \n \t3 BindingOperation operation = ( BindingOperation ) iter . next ( ) ; \n \n \t3 <comment> \n \n \t3 if ( operation . getOperation ( ) == null || operation . getOperation ( ) . isUndefined ( ) ) { \n \n <ect>
public abstract boolean match ( Path absolutePath , Path relativePath , boolean caseSensitiveFileExtension ) ; \n \n public static PathPattern create ( String s ) { \n \n \t1 String trimmed = StringUtils . trim ( s ) ; \n \n \t1 if ( StringUtils . startsWithIgnoreCase ( trimmed , ABSOLUTE_PATH_PATTERN_PREFIX ) ) { \n \n <ect>
\t3 public void run ( ) { \n \n \t4 currentReconnectDelay = INITIAL_RECONNECT_DELAY ; \n \n \t4 MessageActivationSpec activationSpec = endpointActivationKey . getActivationSpec ( ) ; \n \n <ect>
\t5 _serviceOffering = _offeringDao . findById ( Long . parseLong ( cpvmSrvcOffIdStr ) ) ; \n \n \t4 } catch ( NumberFormatException ex ) { \n \n \t5 s_logger . debug ( <string_literal> + cpvmSrvcOffIdStr + <string_literal> ) ; } } \n \n \t3 if ( _serviceOffering == null ) { \n \n <ect>
\t4 if ( file . exists ( ) ) { \n \n \t5 FileInputStream fileInputStream = new FileInputStream ( file ) ; \n \n \t5 complexData = new ComplexData ( originalFilename , fileInputStream ) ; \n \n \t4 } else { \n \n <ect>
\t2 { \n \n \t3 listeners = new ArrayList < DTMFListener > ( this . dtmfListeners ) ; } \n \n \t2 DTMFReceivedEvent evt = new DTMFReceivedEvent ( pps , tone , duration ) ; \n \n <ect>
\t3 <comment> \n \n \t3 if ( operation . getOperation ( ) == null || operation . getOperation ( ) . isUndefined ( ) ) { \n \n \t4 log . error ( <string_literal> + operation . getName ( ) + <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t2 doiRow . setStatus ( DELETED ) ; \n \n \t2 try { \n \n \t3 doiService . update ( context , doiRow ) ; \n \n \t2 } catch ( SQLException sqle ) { \n \n <ect>
\t1 public void tearDown ( ) throws Exception { \n \n \t2 if ( this . gateway != null ) { \n \n \t3 for ( String token : this . paymentMethodsTokens ) { \n \n \t4 if ( this . gateway . paymentMethod ( ) . delete ( token ) . isSuccess ( ) ) { \n \n <ect>
\t3 return ( Script ) value ; } \n \n \t2 if ( value == null ) { \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t1 LOG . debug ( <string_literal> + snapshotId + <string_literal> ) ; \n \n \t1 try { \n \n \t1 blockManager . deleteSnapshot ( snapshotId , snap . getSnapPointId ( ) ) ; \n \n \t1 } catch ( EucalyptusCloudException e ) { \n \n <ect>
public boolean check ( @ Nullable String key , String value ) { \n \n \t1 try { \n \n \t1 return key != null && Iso8601DateParser . parse ( key ) . compareTo ( Iso8601DateParser . parse ( value ) ) >= 0 ; \n \n \t1 } catch ( ParseException e ) { \n \n <ect>
\t5 } catch ( Exception ex ) { \n \n \t6 logger . warn ( <string_literal> , \n \n \t8 ex . toString ( ) ) ; } } \n \n \t3 } else { \n \n <ect>
\t5 final Duration initialDelay = ObjectHelper . supplyIfEmpty ( configuration . getInitialDelay ( ) , defaultConfiguration : : getInitialDelay ) ; \n \n \t5 ClusteredRoutePolicy policy = ClusteredRoutePolicy . forNamespace ( clusterService , namespace ) ; \n \n \t5 policy . setCamelContext ( getCamelContext ( ) ) ; \n \n \t5 policy . setInitialDelay ( initialDelay ) ; \n \n <ect>
\t2 if ( value != null ) { \n \n \t3 try { \n \n \t4 return KubernetesHelper . toYaml ( value ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t2 final Network network = _networkDao . findById ( gateway . getNetworkId ( ) ) ; \n \n \t2 final boolean isPrivateGateway = true ; \n \n \t2 final List < DomainRouterVO > routers = _vpcRouterMgr . getVpcRouters ( gateway . getVpcId ( ) ) ; \n \n \t2 if ( routers == null || routers . isEmpty ( ) ) { \n \n <ect>
\t4 new GridThread ( worker ) . start ( ) ; \n \n \t4 fin . await ( connTimeout0 ) ; } \n \n \t3 catch ( GridHadoopHandshakeTimeoutException e ) { \n \n <ect>
\t4 List < ? extends IpAddress > ipsToRelease = _ipAddressDao . listByAccount ( accountId ) ; \n \n \t4 for ( IpAddress ip : ipsToRelease ) { \n \n \t5 s_logger . debug ( <string_literal> + ip + <string_literal> + accountId + <string_literal> ) ; \n \n \t5 if ( ! _ipAddrMgr . disassociatePublicIpAddress ( ip . getId ( ) , callerUserId , caller ) ) { \n \n <ect>
\t2 Request req = null ; \n \n \t2 try { \n \n \t3 req = Util . streamableFromBuffer ( Request : : new , msg . getRawBuffer ( ) , msg . getOffset ( ) , msg . getLength ( ) ) ; } \n \n \t2 catch ( Exception ex ) { \n \n <ect>
\t4 log . info ( <string_literal> + rsrc4 ) ; \n \n \t4 log . info ( <string_literal> + rsrc5 ) ; \n \n \t4 log . info ( <string_literal> + rsrc6 ) ; \n \n \t4 log . info ( <string_literal> + rsrc7 ) ; \n \n <ect>
private final static class ErrorHandle implements Thread . UncaughtExceptionHandler { \n \n \t1 Throwable error = null ; \n \n \t1 @ Override \n \n \t1 public void uncaughtException ( Thread t , Throwable e ) { \n \n <ect>
\t3 queueCallable ( new CoordActionUpdateCommand ( workflow ) , LOCK_FAILURE_REQUEUE_INTERVAL ) ; \n \n \t3 log . warn ( <string_literal> + e . getMessage ( ) + <string_literal> \n \n \t5 + jobId + <string_literal> + workflow . getId ( ) + <string_literal> ) ; } \n \n \t2 finally { \n \n <ect>
\t6 formClass = beanValidatorForm . getInstance ( ) . getClass ( ) ; } \n \n \t5 Class configClass = \n \n \t6 ClassUtils . getApplicationClass ( this . getType ( ) ) ; \n \n \t5 if ( configClass . isAssignableFrom ( formClass ) ) { \n \n <ect>
<comment> \n \n \t1 public Map < String , Object > parse ( EBusTelegram telegram ) { \n \n \t2 <comment> \n \n \t2 if ( configurationProvider == null ) { \n \n <ect>
\t3 public void onMessage ( Message message ) { \n \n \t4 if ( ++ count > <number_literal> ) { \n \n \t5 try { \n \n \t6 session . rollback ( ) ; \n \n <ect>
\t3 LOGGER . debug ( <string_literal> , crls ) ; \n \n \t3 revokedCrls = crls . stream ( ) . map ( crl - > crl . getRevokedCertificate ( cert ) ) . filter ( Objects : : nonNull ) . collect ( Collectors . toList ( ) ) ; \n \n \t3 if ( revokedCrls . size ( ) == crls . size ( ) ) { \n \n \t4 final X509CRLEntry entry = revokedCrls . get ( 0 ) ; \n \n <ect>
\t2 File directory ; \n \n \t2 if ( StringUtils . isEmpty ( getDirectory ( ) ) ) { \n \n \t3 directory = new File ( FileServer . getDefaultBase ( ) ) ; \n \n <ect>
\t7 logger . warn ( databaseProductName + <string_literal> + \n \n \t9 <string_literal> + supportedDatabaseProductsForFunctions ) ; } \n \n \t6 if ( accessProcedureColumnMetaData ) { \n \n <ect>
\t3 s_logger . error ( <string_literal> + e . getMessage ( ) ) ; \n \n \t3 throw new CloudRuntimeException ( <string_literal> + e . getMessage ( ) , e ) ; } } \n \n \t1 @ Override \n \n \t1 public boolean releaseLockAsLastResortAndIReallyKnowWhatIAmDoing ( String key ) { \n \n <ect>
\t4 } catch ( IOException e ) { \n \n \t5 <comment> \n \n \t5 <comment> \n \n \t5 <comment> \n \n <ect>
\t1 @ Path ( <string_literal> ) \n \n \t1 @ Consumes ( <string_literal> ) \n \n \t1 @ Produces ( <string_literal> ) \n \n \t1 public XmlJavaTypeAdapterFoo foo ( XmlJavaTypeAdapterFoo foo ) { \n \n <ect>
\t4 log . info ( <string_literal> ) ; \n \n \t4 waitForRunning ( false ) ; \n \n \t4 log . info ( <string_literal> ) ; \n \n \t4 channel . close ( ) . sync ( ) ; \n \n <ect>
\t2 config . setProviderClient ( <string_literal> ) ; <comment> \n \n \t2 trans . commit ( ) ; \n \n \t2 return true ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t1 FileListing . recursiveDeleteDir ( tableFile ) ; } \n \n \t1 String [ ] argv = getArgv ( ) ; \n \n \t1 try { \n \n \t1 runImport ( argv ) ; \n \n <ect>
\t2 BreakerSettings newInFlightRequestsSettings = new BreakerSettings ( CircuitBreaker . IN_FLIGHT_REQUESTS , newInFlightRequestsMax . getBytes ( ) , \n \n \t3 newInFlightRequestsOverhead , HierarchyCircuitBreakerService . this . inFlightRequestsSettings . getType ( ) ) ; \n \n \t2 registerBreaker ( newInFlightRequestsSettings ) ; \n \n \t2 HierarchyCircuitBreakerService . this . inFlightRequestsSettings = newInFlightRequestsSettings ; \n \n <ect>
\t2 final String regex = buildPatternForConfigurationFileDiscovery ( config , profiles ) ; \n \n \t2 final Collection < File > configFiles = scanForConfigurationFilesByPattern ( config , regex ) ; \n \n \t2 LOGGER . info ( <string_literal> , config , configFiles ) ; \n \n \t2 configFiles . forEach ( Unchecked . consumer ( f - > { \n \n <ect>
\t6 LOGGER . trace ( <string_literal> , e ) ; \n \n \t6 return null ; } } \n \n \t4 round ++ ; } \n \n \t3 if ( isNotBlank ( mBID ) ) { \n \n <ect>
\t2 LOG . error ( <string_literal> , he . getMessage ( ) ) ; \n \n \t2 } else { \n \n \t2 LOG . error ( <string_literal> , he . getRemoteErrorMsg ( ) ) ; } } \n \n \t1 } else { \n \n <ect>
\t4 continue ; } \n \n \t3 if ( membership . memberAlive ( ( MemberImpl ) members [ i ] ) ) { \n \n \t4 <comment> \n \n \t4 if ( memberAlive ( members [ i ] ) ) { \n \n <ect>
\t1 @ Override \n \n \t1 public void sampleOccurred ( SampleEvent se ) { \n \n \t2 final BeanShellInterpreter bshInterpreter = getBeanShellInterpreter ( ) ; \n \n \t2 if ( bshInterpreter == null ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 } else { \n \n \t3 <comment> \n \n \t3 ok = parseOptions ( args ) ; \n \n \t3 if ( ok && compileCount == 0 ) { \n \n <ect>
\t4 if ( ! Files . isDirectory ( entry ) ) \n \n \t5 throw new DBOpEnvException ( <string_literal> + entry ) ; \n \n \t4 paths . add ( entry ) ; } } \n \n \t2 catch ( IOException ex ) { \n \n <ect>
\t1 INSTANCE ; \n \n \t1 private List < ObjectHolderRef > objectHolders = Lists . newArrayList ( ) ; \n \n \t1 public void findObjectHolders ( ASMDataTable table ) \n \n \t1 { \n \n <ect>
\t5 cube . setCuboidLastOptimized ( getEndTime ( ) ) ; \n \n \t5 CubeUpdate cubeUpdate = new CubeUpdate ( cube ) ; \n \n \t5 cubeManager . updateCube ( cubeUpdate ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
\t1 logger . info ( <string_literal> , filePath ) ; \n \n \t1 FSDataInputStream stream = fs . open ( filePath ) ; \n \n \t1 BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; \n \n \t1 String line = reader . readLine ( ) ; \n \n <ect>
\t2 } catch ( InterruptedException e ) { \n \n \t3 System . err . println ( <string_literal> ) ; \n \n \t3 Assert . fail ( ) ; } \n \n \t2 explicitExcludeHandle . close ( ) ; \n \n <ect>
\t5 currentStage ) ; \n \n \t3 if ( node . getNodeId ( ) != event . getNodeId ( ) ) { \n \n \t4 return ; } \n \n \t3 if ( currentStage == ZWaveNodeInitStage . PING ) { \n \n <ect>
\t4 case _ = > \n \n \t4 log . error ( s <string_literal> ) \n \n \t4 null } \n \n \t3 case _ = > \n \n <ect>
\t1 LOG . error ( <string_literal> , url ) ; \n \n \t1 throw new TezWebAppException ( <string_literal> + url + <string_literal> , \n \n \t2 Response . Status . INTERNAL_SERVER_ERROR . getStatusCode ( ) , response ) ; } \n \n \t1 try { \n \n <ect>
\t4 grabArrays = newGrabberArray ( 0 ) ; \n \n \t4 grabClients = newClientArray ( 0 ) ; \n \n \t4 return null ; \n \n \t3 } else { \n \n <ect>
\t4 thread . setContextClassLoader ( getInstance ( ) ) ; } } } \n \n \t1 <comment> \n \n \t1 private static List < Thread > listThreads ( ThreadGroup group , String indent ) { \n \n \t2 List < Thread > threadToReturn = new ArrayList < > ( ) ; \n \n <ect>
\t3 Person person = personMapper . findById ( userId ) ; \n \n \t3 log . debug ( <string_literal> + inActionContext . getPrincipal ( ) . getAccountId ( ) ) ; \n \n \t3 person . setTheme ( theme ) ; \n \n \t3 personMapper . flush ( ) ; \n \n <ect>
\t5 tx . rollback ( ) ; \n \n \t5 tx = null ; \n \n \t5 logger . error ( <string_literal> , \n \n \t7 e . getMessage ( ) , processor , userlogName , i , retryAttempts ) ; \n \n <ect>
\t3 NetworkVO nc = _networkDao . findById ( n . getNetworkId ( ) ) ; \n \n \t3 if ( nc . getTrafficType ( ) == TrafficType . Control ) { \n \n \t4 routerControlIpAddress = n . getIp4Address ( ) ; } } \n \n \t2 if ( routerControlIpAddress == null ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void start ( BundleContext bc ) throws Exception { \n \n <ect>
\t7 <string_literal> + method . getName ( ) + <string_literal> ) ; } } \n \n \t3 <comment> \n \n \t3 boolean isNewEm = false ; \n \n \t3 if ( target == null ) { \n \n <ect>
\t2 } catch ( Exception unexpectedEx ) { \n \n \t3 log . error ( <string_literal> , unexpectedEx ) ; \n \n \t2 } finally { \n \n \t3 consumer . getConsumerRunnables ( ) . remove ( this ) ; \n \n <ect>
\t3 return newKey ; \n \n \t2 } } ; \n \n \t2 RestrictedTypes . allocateUnitlessResource ( allocator ) ; \n \n \t1 } catch ( GeneralSecurityException e ) { \n \n <ect>
\t5 } catch ( final ResourceUnavailableException e ) { \n \n \t6 s_logger . warn ( <string_literal> + router . getInstanceName ( ) , e ) ; \n \n \t6 throw new ConnectionException ( false , <string_literal> + router . getInstanceName ( ) ) ; \n \n \t5 } catch ( final ConcurrentOperationException e ) { \n \n <ect>
\t5 if ( meterName != null && meterName . equals ( entry . getKey ( ) ) ) { \n \n \t6 Map < String , DataSet > dataSets ; \n \n \t6 if ( ( dataSets = cache . get ( meterName ) ) == null ) { \n \n <ect>
\t1 public boolean verifyServicesCombination ( Set < Service > services ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( ! services . contains ( Service . Connectivity ) ) { \n \n <ect>
\t4 Principal principal = principalManager . getPrincipal ( principalName ) ; \n \n \t4 if ( principal == null ) { \n \n \t5 switch ( importBehavior ) { \n \n \t6 case ImportBehavior . IGNORE : \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t1 if ( storageHandlerClassName . equals ( tableInfo . getStorerInfo ( ) . getStorageHandlerClass ( ) ) ) { \n \n \t2 storageHandlerClassName = null ; \n \n \t1 } else { \n \n <ect>
\t3 <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> } ; \n \n \t2 Map < Integer , String > lockColors = new HashMap < Integer , String > ( ) ; \n \n \t2 int colorNum = 0 ; \n \n \t2 HashSet < CriticalSection > visited = new HashSet < CriticalSection > ( ) ; \n \n <ect>
\t7 case WireFormatInfo . DATA_STRUCTURE_TYPE : \n \n \t7 case ShutdownInfo . DATA_STRUCTURE_TYPE : \n \n \t8 break ; \n \n \t7 default : \n \n <ect>
\t1 @ GET \n \n \t1 @ Path ( <string_literal> ) \n \n \t1 @ Produces ( <string_literal> ) \n \n \t1 public String getQueryParam ( @ QueryParam ( <string_literal> ) String param ) { \n \n <ect>
\t2 if ( info . isDelete ( ) ) { \n \n \t2 if ( ! lowerSplit ) \n \n \t3 log . info ( <string_literal> , info , info . getExtent ( ) ) ; \n \n \t2 else if ( ! upperSplit ) \n \n <ect>
\t4 return null ; } \n \n \t2 } catch ( Exception e ) { \n \n \t3 if ( failover ) { \n \n \t4 return getXObject ( classReference ) ; } \n \n <ect>
\t3 try { \n \n \t4 if ( before != null ) \n \n \t5 before . run ( ) ; \n \n \t3 } catch ( Throwable th ) { \n \n <ect>
\t3 rmv = cur . remove ( fut ) ; \n \n \t3 empty = cur . isEmpty ( ) ; } \n \n \t2 if ( rmv ) { \n \n <ect>
\t3 try { \n \n \t4 Path path = new Path ( jobWorkingDir ) ; \n \n \t4 FileSystem fileSystem = HadoopUtil . getFileSystem ( path ) ; \n \n \t4 if ( ! fileSystem . exists ( path ) ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t3 } else { \n \n \t4 log . info ( <string_literal> , \n \n \t5 resourceManagerConnection . getTargetAddress ( ) ) ; } } \n \n \t2 if ( resourceManagerAddress != null ) { \n \n <ect>
\t3 result . tope = ( ThriftTableOperationException ) e ; \n \n \t3 result . setTopeIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t2 final long expiry = System . currentTimeMillis ( ) + MAX_WAIT_MILLIS ; \n \n \t2 while ( ! condition . isSatisified ( ) && System . currentTimeMillis ( ) < expiry ) { \n \n \t3 Thread . sleep ( <number_literal> ) ; } \n \n \t2 if ( System . currentTimeMillis ( ) >= expiry ) { \n \n <ect>
\t2 } else { \n \n \t3 try { \n \n \t3 caster_ = ( LoadCaster ) PigContext . instantiateFuncFromSpec ( casterOption ) ; \n \n \t3 } catch ( ClassCastException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 ModifiableConfiguration mcfg = BerkeleyStorageSetup . getBerkeleyJEConfiguration ( ) ; \n \n \t2 String methodName = methodNameRule . getMethodName ( ) ; \n \n \t2 if ( methodName . equals ( <string_literal> ) ) { \n \n \t3 IsolationLevel iso = IsolationLevel . SERIALIZABLE ; \n \n <ect>
\t2 params . put ( <string_literal> , infos [ 0 ] ) ; \n \n \t2 params . put ( <string_literal> , infos [ 1 ] ) ; \n \n \t2 return true ; } \n \n \t1 protected NetworkInterface getNetworkInterface ( String nicName ) { \n \n <ect>
\t2 case CANDIDATE : \n \n \t3 term = ( ( ElectionRound ) runningRound ) . getTerm ( ) ; \n \n \t3 state = LEADER ; \n \n <ect>
\t1 stream . seek ( footerLengthIndex ) ; \n \n \t1 int footerLength = BytesUtils . readIntLittleEndian ( stream ) ; \n \n \t1 stream . seek ( footerLengthIndex - footerLength ) ; \n \n <ect>
\t3 writer . write ( comment ) ; \n \n \t3 writer . newLine ( ) ; \n \n \t3 writer . flush ( ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 <comment> \n \n \t2 app . getBean ( Scheduler . class ) . shutdown ( ) ; \n \n \t2 IOHelper . close ( app ) ; \n \n \t2 log . warn ( <string_literal> ) ; \n \n <ect>
\t4 if self . excludeFiles != None and fnmatch . fnmatch ( f , self . excludeFiles ) : \n \n \t5 Logger . info ( <string_literal> % fpath ) \n \n \t5 continue \n \n \t4 if self . targetFiles != None and not fnmatch . fnmatch ( f , self . targetFiles ) : \n \n <ect>
\t2 if ( connHostName == null ) { \n \n \t3 _log . error ( <string_literal> ) ; \n \n \t3 throw new SOCKSException ( <string_literal> ) ; } \n \n \t2 if ( connPort == 0 ) { \n \n <ect>
<comment> \n \n \t1 public HttpResponseResource getRawResource ( final URI uri , boolean revalidate ) { \n \n \t2 String location = uri . toString ( ) ; \n \n <ect>
\t3 return new ModelAndView ( CasWebflowConstants . VIEW_ID_ERROR , new HashMap < > ( ) , HttpStatus . FORBIDDEN ) ; } \n \n \t2 final Assertion assertion = validateRequestAndBuildCasAssertion ( response , request , fedRequest ) ; \n \n \t2 SecurityToken securityToken = getSecurityTokenFromRequest ( request ) ; \n \n \t2 if ( securityToken == null ) { \n \n <ect>
\t4 data = new byte [ 0 ] ; } \n \n \t3 zkClient . set_data ( path , data ) ; \n \n \t3 LOG . info ( <string_literal> + path + <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 if ( result != 0 ) { \n \n \t5 logger . warn ( <string_literal> , S7Client . ErrorText ( result ) ) ; \n \n \t5 ReconnectLogo ( LogoS7Client ) ; } \n \n \t3 } else { \n \n <ect>
\t6 if ( when < nextSendTime ) \n \n \t7 nextSendTime = when ; } } } \n \n \t2 if ( inboundState != null ) { \n \n \t3 <comment> \n \n <ect>
\t1 Path tmpFile = null ; \n \n \t1 try { \n \n \t1 tmpFile = Files . createTempFile ( metricsDir , <string_literal> , <string_literal> , FILE_ATTRS ) ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t7 return true ; } \n \n \t5 } ) . execute ( ) ; \n \n \t3 for ( Row < String , String > row : rows . getResult ( ) ) { \n \n \t4 counter . incrementAndGet ( ) ; \n \n <ect>
\t3 <comment> \n \n \t3 pzc . checkAllPodCidrSubnets ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n \t3 System . out . print ( <string_literal> + ex ) ; \n \n <ect>
\t3 if ( ! memoryStarved ) { \n \n \t4 log . warn ( <string_literal> ) ; \n \n \t4 NSNotificationCenter . defaultCenter ( ) . postNotification ( new NSNotification ( StarvedMemoryResolvedNotification , this ) ) ; \n \n \t3 } else { \n \n <ect>
\t2 Exchange exchange = endpoint . createExchange ( parameters , SWFConstants . SIGNAL_RECEIVED_ACTION ) ; \n \n \t2 exchange . setPattern ( InOnly ) ; \n \n \t2 getProcessor ( ) . process ( exchange ) ; } \n \n \t1 public Object getWorkflowState ( Object parameters ) throws Exception { \n \n <ect>
public class SomeFineGrainedLazySingleton { \n \n \t1 private static final Logger LOG = LoggerFactory . getLogger ( SomeFineGrainedLazySingleton . class ) ; \n \n \t1 @ Inject \n \n \t1 public SomeFineGrainedLazySingleton ( ) { \n \n <ect>
\t2 try { \n \n \t3 super . setUp ( ) ; \n \n \t3 fail ( <string_literal> ) ; \n \n \t2 } catch ( FailedToCreateRouteException e ) { \n \n <ect>
\t2 if ( null != currentACL ) { \n \n \t3 newACL = currentACL . acl ( ) ; \n \n \t2 } else { \n \n \t3 if ( Log . isLoggable ( Log . FAC_ACCESSCONTROL , Level . INFO ) ) { \n \n <ect>
\t1 String pid = matcher . group ( 1 ) ; \n \n \t1 String key = matcher . group ( <number_literal> ) ; \n \n \t1 IConfiguration con = getConfiguration ( pid ) ; \n \n \t1 if ( con == null ) { \n \n <ect>
\t5 request . setTxn ( new ErrorTxn ( ke . code ( ) . intValue ( ) ) ) ; } \n \n \t4 request . setException ( ke ) ; \n \n \t4 LOG . info ( <string_literal> , ke ) ; \n \n \t3 } catch ( IOException ie ) { \n \n <ect>
\t2 return method . invoke ( object , ( Object [ ] ) null ) ; } \n \n \t1 @ Override \n \n \t1 public void setMethodValue ( Object object , Method method , Object value ) throws IllegalArgumentException , IllegalAccessException , \n \n \t1 InvocationTargetException { \n \n <ect>
\t2 if ( _log . shouldLog ( Log . DEBUG ) ) _log . debug ( <string_literal> ) ; \n \n \t2 msg . setSessionConfig ( cfg ) ; \n \n \t2 if ( _log . shouldLog ( Log . DEBUG ) ) _log . debug ( <string_literal> ) ; \n \n \t2 session . sendMessage_unchecked ( msg ) ; \n \n <ect>
\t5 return true ; \n \n \t4 } else { \n \n \t5 return false ; } \n \n \t3 } catch ( InsertException e1 ) { \n \n <ect>
\t2 LOGGER . debug ( <string_literal> , client , service ) ; \n \n \t2 if ( service != null ) { \n \n \t3 request . setAttribute ( CasProtocolConstants . PARAMETER_SERVICE , service . getId ( ) ) ; \n \n \t3 if ( ! isDelegatedClientAuthorizedForService ( client , service ) ) { \n \n <ect>
\t2 resultByteBuffer . write ( ( byte ) messageClass . getKey ( ) ) ; \n \n \t2 try { \n \n \t3 resultByteBuffer . write ( messagePayload ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t1 IOUtils . closeQuietly ( sxml ) ; } \n \n @ Override \n \n public MondrianCatalog getCatalog ( final String context , final IPentahoSession pentahoSession ) { \n \n <ect>
\t3 BCLog . logger . info ( <string_literal> ) ; \n \n \t3 for ( int i = 0 ; i < CACHES . size ( ) ; i ++ ) { \n \n \t4 final MarkerCache < ? > cache = CACHES . get ( i ) ; \n \n \t4 BCLog . logger . info ( <string_literal> + i + <string_literal> + cache . name ) ; } \n \n <ect>
\t3 cloneTable_result result = new cloneTable_result ( ) ; \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 } catch ( org . apache . thrift . transport . TTransportException e ) { \n \n <ect>
\t2 protected void setterInjection ( Method method , Object bean , String beanName , String endpointUri , String endpointRef , String endpointProperty ) { \n \n \t3 Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; \n \n \t3 if ( parameterTypes != null ) { \n \n \t4 if ( parameterTypes . length != 1 ) { \n \n <ect>
\t3 for ( String name : bitsProvider . getPrivilegeNames ( getPrivilegeBits ( ) ) ) { \n \n \t4 try { \n \n \t5 privileges . add ( getPrivilegeManager ( ) . getPrivilege ( name ) ) ; \n \n \t4 } catch ( RepositoryException e ) { \n \n <ect>
\t4 <string_literal> ) ; \n \n \t2 } else { \n \n \t3 numOpenTxns . set ( numOpen . intValue ( ) ) ; } } \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t3 log . info ( <string_literal> + nodeId ) ; \n \n \t3 log . info ( <string_literal> + mbeanSrv ) ; \n \n \t3 log . info ( <string_literal> + exec ) ; \n \n \t3 log . info ( <string_literal> + ggHome ) ; \n \n <ect>
\t5 return new ExamplePluginMenuItem ( this ) ; } \n \n \t3 } , \n \n \t3 containerFilter ) ; \n \n <ect>
\t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . SECRET ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , grantType ) ; \n \n \t3 return false ; } \n \n \t2 if ( ! validator . checkParameterExist ( request , OAuth20Constants . USERNAME ) ) { \n \n <ect>
\t1 public static void copy ( KylinConfig srcConfig , KylinConfig dstConfig , String path , boolean copyImmutableResource ) \n \n \t3 throws IOException { \n \n \t2 ResourceStore src = ResourceStore . getStore ( srcConfig ) ; \n \n \t2 ResourceStore dst = ResourceStore . getStore ( dstConfig ) ; \n \n <ect>
\t3 <comment> \n \n \t3 String requestStr = null ; \n \n \t3 try { requestStr = IO . readWholeFileAsUTF8 ( input ) ; } \n \n \t3 catch ( IOException ex ) { IO . exception ( ex ) ; } \n \n <ect>
\t2 optimizer . getTaskAssigner . call ( task . f0 , task . f1 ) } \n \n \t1 stay ( ) \n \n \t1 case Event ( msg : Unassign , _ ) = > \n \n \t1 <comment> \n \n <ect>
\t6 case POWERSTATE : \n \n \t7 value = node . getOnOff ( ) ; \n \n \t7 break ; \n \n \t6 case PAUSE : \n \n <ect>
\t2 { \n \n \t3 logger . info ( <string_literal> + instanceLocation . getURL ( ) ) ; } \n \n \t2 logger . debug ( <string_literal> + Platform . getUserLocation ( ) . getURL ( ) ) ; \n \n \t2 logger . debug ( <string_literal> + Platform . getInstallLocation ( ) . getURL ( ) ) ; \n \n <ect>
\t2 log . info ( <string_literal> ) ; \n \n \t2 DecoratorsVisitList . add ( DecoratorsVisitList . READER_DECORATOR_ENTER ) ; \n \n \t2 EJBBook b = reader . readFrom ( type , genericType , annotations , mediaType , httpHeaders , entityStream ) ; \n \n \t2 DecoratorsVisitList . add ( DecoratorsVisitList . READER_DECORATOR_LEAVE ) ; \n \n <ect>
\t7 . getBindingConfig ( itemName ) ; \n \n \t5 SappAddressOpenClosedStatus statusAddress = sappBindingConfigContactItem . getStatus ( ) ; \n \n \t5 if ( statusAddress . getAddressType ( ) == sappAddressType && statusAddress . getPnmasId ( ) . equals ( pnmasId ) \n \n \t7 && addressToUpdate == statusAddress . getAddress ( ) ) { \n \n <ect>
\t3 synchronized ( finishLock ) { \n \n \t4 while ( ! finished ) { \n \n \t5 finishLock . wait ( ) ; } } \n \n \t3 if ( _log . shouldLog ( Log . DEBUG ) ) \n \n <ect>
\t5 if ( StringUtils . isEmpty ( port ) ) { \n \n \t6 throw new IllegalStateException ( <string_literal> + host + <string_literal> ) ; } \n \n \t5 final SyncHostInfo syncHostInfo = new SyncHostInfo ( host , user , pwd , port ) ; \n \n \t5 syncHosts . add ( syncHostInfo ) ; \n \n <ect>
\t5 checkpoint . abortError ( new Exception ( <string_literal> , t ) ) ; } \n \n \t4 try { \n \n \t5 checkpointStorageLocation . disposeOnFailure ( ) ; } \n \n \t4 catch ( Throwable t2 ) { \n \n <ect>
\t2 BufferedReader reader = new BufferedReader ( new InputStreamReader ( in , StandardCharsets . UTF_8 ) ) ; \n \n \t2 try { \n \n \t3 doGobble ( reader , enableLogging ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t4 id = Integer . parseInt ( oldName . substring ( oldName . lastIndexOf ( <string_literal> ) + 1 ) ) ; \n \n \t4 logger . warn ( <string_literal> , oldName , ( id ) ) ; } \n \n \t3 logger . warn ( <string_literal> , id ) ; \n \n \t3 newName = tableIds . get ( id ) ; \n \n <ect>
\t2 String bucketCount = fso . getConf ( ) . getTableInfo ( ) . getProperties ( ) . getProperty ( \n \n \t3 hive_metastoreConstants . BUCKET_COUNT ) ; \n \n \t2 int numBuckets = bucketCount == null ? 0 : Integer . parseInt ( bucketCount ) ; \n \n \t2 if ( numBuckets > 0 ) { \n \n <ect>
\t6 try { \n \n \t7 myUser . launchUser ( ) ; \n \n \t7 myUser . registerUser ( ) ; \n \n \t6 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 resetContext ( ) ; \n \n \t2 } catch ( Exception ex ) { \n \n <ect>
\t1 @ Requirement \n \n \t1 lateinit var logger : Logger \n \n \t1 override fun isApplicable ( project : MavenProject , execution : MojoExecution ) = true \n \n \t1 override fun getPluginOptions ( project : MavenProject , execution : MojoExecution ) : List < PluginOption > { \n \n <ect>
\t1 AdvancedCache < String , String > cache1 = advancedCache ( 0 , <string_literal> ) ; \n \n \t1 AdvancedCache < String , String > cache2 = advancedCache ( 1 , <string_literal> ) ; \n \n \t1 assertNull ( <string_literal> , cache1 . get ( <string_literal> ) ) ; \n \n \t1 assertNull ( <string_literal> , cache2 . get ( <string_literal> ) ) ; \n \n <ect>
\t1 SortedSet < Text > splits = new TreeSet < > ( ) ; \n \n \t1 for ( int i = 1 ; i < 0xfff ; i += <number_literal> ) { \n \n \t1 splits . add ( new Text ( Integer . toHexString ( i ) ) ) ; } \n \n \t1 c . tableOperations ( ) . addSplits ( tableName , splits ) ; \n \n <ect>
\t5 markUnreachable ( peer ) ; \n \n \t5 return null ; } } } \n \n \t2 if ( ! allowConnection ( ) ) { \n \n \t3 <comment> \n \n <ect>
\t1 Partition partition = vm . lookupPartition ( ) ; \n \n \t1 ServiceConfiguration sc = Topology . lookup ( Storage . class , partition ) ; \n \n \t1 <comment> <ect>
\t4 Driver driver = ( Driver ) e . nextElement ( ) ; \n \n \t4 if ( driver . getClass ( ) . getClassLoader ( ) == getClass ( ) . getClassLoader ( ) ) { \n \n \t5 DriverManager . deregisterDriver ( driver ) ; } } \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t3 List < Pair < String , Long > > states = new ArrayList < Pair < String , Long > > ( ) ; \n \n \t3 for ( String log : logs ) { \n \n \t4 String [ ] info = log . split ( <string_literal> ) ; \n \n \t4 if ( info . length != <number_literal> ) { \n \n <ect>
\t1 log . debug ( <string_literal> ) ; \n \n \t1 for ( ServerCache serverCache : allCaches . values ( ) ) { \n \n \t1 serverCache . clear ( ) ; } } \n \n public void clear ( String name ) { \n \n <ect>
\t2 logger . debug ( GraphUtil . defaultGraphToString ( tree ) ) ; \n \n \t2 TreePostProcess treePostProcess = new TreePostProcess ( this . graphBuilder , tree , getLinksByStatus ( LinkStatus . ForcedByUser ) , true ) ; \n \n \t2 this . steinerTree = treePostProcess . getTree ( ) ; \n \n \t2 this . root = treePostProcess . getRoot ( ) ; \n \n <ect>
\t3 logoutLatch = new CountDownLatch ( 1 ) ; } \n \n \t2 @ Override \n \n \t2 public void onLogon ( SessionID sessionId ) { \n \n \t3 if ( logonLatch != null ) { \n \n <ect>
<number_literal> Schema pigSchema , HCatSchema tableSchema ) \n \n \t2 throws FrontendException , HCatException { \n \n \t1 if ( hcatFieldSchema == null ) { \n \n <ect>
\t3 if ( includeRelations ) { \n \n \t4 try { \n \n \t5 relations = getRelations0 ( ) ; } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 String amds = file . getAttributeValue ( <string_literal> ) ; \n \n \t2 if ( amds == null ) { \n \n <ect>
\t2 protected void setterPropertyInjection ( Method method , String propertyValue , String propertyDefaultValue , Object bean , String beanName ) { \n \n \t3 Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; \n \n \t3 if ( parameterTypes != null ) { \n \n \t4 if ( parameterTypes . length != 1 ) { \n \n <ect>
\t5 . append ( flushResponse . getTotalShards ( ) ) . append ( <string_literal> ) . append ( flushResponse . getFailedShards ( ) ) . append ( <string_literal> ) ; \n \n \t3 for ( DefaultShardOperationFailedException failure : flushResponse . getShardFailures ( ) ) { \n \n \t4 sb . append ( <string_literal> ) . append ( failure ) ; } \n \n \t3 fail ( sb . toString ( ) ) ; } \n \n <ect>
\t4 for ( AwaitThread entry : threads ) { \n \n \t5 try { \n \n \t6 interrupt ( entry . getExchange ( ) ) ; \n \n \t5 } catch ( Throwable e ) { \n \n <ect>
\t2 } catch ( Exception ex ) { \n \n \t3 log . error ( <string_literal> , server , ex . toString ( ) ) ; \n \n \t3 log . debug ( <string_literal> , server , ex ) ; \n \n \t3 if ( badServers . get ( server ) . incrementAndGet ( ) > MAX_BAD_STATUS_COUNT ) { \n \n <ect>
<number_literal> toolchainsResult . getEffectiveToolchains ( ) ) ; \n \n \t2 { \n \n \t3 slf4jLogger . warn ( <string_literal> ) ; \n \n <ect>
\t4 client . isResponse200 ( ) ) ; \n \n \t2 client . reset ( ) ; } \n \n \t1 @ Test \n \n \t1 public void testAbortedUploadLimitedSwallow ( ) { \n \n <ect>
\t1 public void widgetDefaultSelected ( final SelectionEvent e ) { \n \n \t2 <comment> \n \n \t1 @ Override \n \n \t1 public void widgetSelected ( final SelectionEvent e ) { \n \n <ect>
\t1 if ( downloadedSolrHomeDir != null ) { \n \n \t2 try { \n \n \t2 FileUtils . deleteDirectory ( downloadedSolrHomeDir ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 connection . close ( ) ; } \n \n \t1 } catch ( SQLException e ) { \n \n \t1 LOG . error ( <string_literal> , e ) ; } } \n \n public static DatabaseConsistencyCheckResult runAllDBChecks ( boolean fixIssues ) throws Throwable { \n \n <ect>
\t5 return fallbackOakSolrConfigurationProvider . getConfiguration ( ) ; } \n \n \t3 } else if ( node . exists ( ) ) { \n \n \t4 log . warn ( <string_literal> , path ) ; } \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 synchronized ( updatesConfirmed ) { \n \n \t3 while ( exception . get ( ) == null && updatesSent != updatesConfirmed . get ( ) ) { \n \n \t4 updatesConfirmed . wait ( ) ; } } \n \n \t2 if ( exception . get ( ) != null ) { \n \n <ect>
\t2 String fileString = null ; \n \n \t2 try { \n \n \t3 fileString = new String ( Files . readAllBytes ( Paths . get ( filename ) ) , StandardCharsets . UTF_8 ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t6 if ( ( bundleJob . getPauseTime ( ) != null ) && ! bundleJob . getPauseTime ( ) . after ( d ) ) { \n \n \t7 new BundlePauseXCommand ( bundleJob ) . call ( ) ; \n \n \t7 LOG . debug ( <string_literal> + bundleJob . getId ( ) ) ; } } } } \n \n \t3 catch ( Exception ex ) { \n \n <ect>
\t5 } catch ( final LibvirtException e ) { \n \n \t6 s_logger . info ( <string_literal> + sleeptime + <string_literal> + e . getMessage ( ) ) ; } \n \n \t5 if ( state != null && state == DomainState . VIR_DOMAIN_RUNNING ) { \n \n \t6 try { \n \n <ect>
\t4 } else { \n \n \t5 logger . info ( <string_literal> + nodeId + <string_literal> ) ; \n \n \t5 nodeGood = false ; } } \n \n \t3 success = success && nodeGood ; } \n \n <ect>
\t2 SelendroidLogger . debug ( <string_literal> ) ; \n \n \t2 inst . sendPointerSync ( event ) ; \n \n \t2 isSuccess = true ; \n \n \t1 } catch ( SecurityException e ) { \n \n <ect>
\t5 <comment> \n \n \t5 return false ; } \n \n \t4 cmd1 = msg . getByte ( <string_literal> ) ; \n \n \t3 } catch ( FieldException e ) { \n \n <ect>
\t5 classInputStream . close ( ) ; } } \n \n \t2 } finally { \n \n \t3 jos . close ( ) ; } \n \n \t2 Assert . assertTrue ( jarFile . exists ( ) ) ; \n \n <ect>
\t1 catch ( Throwable ex ) { \n \n \t1 LOG . error ( <string_literal> , ex ) ; \n \n \t1 throw ex ; } } \n \n public static void checkDBVersionCompatible ( ) throws AmbariException { \n \n <ect>
\t2 <comment> \n \n \t2 long localFileSize = 0 ; \n \n \t2 if ( file . exists ( ) && resume ) { \n \n \t3 localFileSize = file . length ( ) ; \n \n <ect>
\t3 cidrlist = [ '0 . 0 . 0 . 0 / 0' ] , \n \n \t3 startport = self . services [ <string_literal> ] [ <string_literal> ] , \n \n \t3 endport = self . services [ <string_literal> ] [ <string_literal> ] \n \n \t2 ) \n \n <ect>
\t2 if ( vmiModel != null ) { \n \n \t3 try { \n \n \t4 vmiModel . destroy ( _manager . getModelController ( ) ) ; \n \n \t3 } catch ( IOException ex ) { \n \n <ect>
\t3 final ViewRow res = iterator . next ( ) ; \n \n \t3 final Integer count = ( Integer ) res . value ( ) ; \n \n \t3 LOGGER . debug ( <string_literal> , count ) ; \n \n \t3 return count ; } \n \n <ect>
\t2 synchronized ( serializeCheckpoints ) { \n \n \t3 try { \n \n \t4 innerCheckpoint ( shutdown ) ; \n \n \t3 } catch ( Throwable t ) { \n \n <ect>
\t4 final Map . Entry < Long , Listener > entry = it . next ( ) ; \n \n \t4 final Listener monitor = entry . getValue ( ) ; \n \n \t4 if ( ! monitor . isRecurring ( ) ) { \n \n \t5 <comment> \n \n <ect>
\t3 deployment . updateNotBefore ( tokenResponse . getNotBeforePolicy ( ) ) ; } \n \n \t2 if ( token . getIssuedAt ( ) < deployment . getNotBefore ( ) ) { \n \n \t3 log . error ( <string_literal> ) ; \n \n \t3 return challenge ( <number_literal> , OIDCAuthenticationError . Reason . STALE_TOKEN , null ) ; } \n \n <ect>
\t6 JMSException jmsEx = null ; \n \n \t6 try { \n \n \t7 jmsEx = JMSExceptionSupport . create ( er . getException ( ) ) ; \n \n \t6 } catch ( Throwable e ) { \n \n <ect>
<comment> \n \n Ember . warn = function ( message , test ) { \n \n if ( ! test ) { \n \n <ect>
\t2 final Principal p = authentication . getPrincipal ( ) ; \n \n \t2 LOGGER . debug ( <string_literal> , p ) ; \n \n \t2 final boolean res = this . scimProvisioner . create ( p , c ) ; \n \n \t2 if ( res ) { \n \n <ect>
\t4 } else { \n \n \t4 LOG . warn ( <string_literal> + input . getVolume ( ) . getScName ( ) + <string_literal> ) ; \n \n \t4 return ; } \n \n \t3 } else { \n \n <ect>
\t4 m_writer = new BufferedWriter ( new OutputStreamWriter ( m_port . getOutputStream ( ) ) ) ; \n \n \t4 logger . info ( <string_literal> , m_serialDeviceName ) ; \n \n \t4 startMsgReader ( ) ; \n \n \t3 } else { \n \n <ect>
\t3 allPools . removeAll ( availablePools ) ; \n \n \t3 for ( StoragePoolVO pool : allPools ) { \n \n \t4 avoid . addPool ( pool . getId ( ) ) ; } } \n \n <ect>
\t4 isVargs = cm . isVargsMethod ( ) ; \n \n \t4 try { \n \n \t5 Method m = cm . getCachedMethod ( ) ; \n \n \t5 handle = correctClassForNameAndUnReflectOtherwise ( m ) ; \n \n <ect>
\t1 public void setDisconnected ( ) { \n \n \t2 transition ( DownloadEvent . DISCONNECT , null ) ; } \n \n \t1 public void logDisconnect ( ) { \n \n \t2 if ( template != null ) { \n \n <ect>
\t6 destTemplateObjectTO . format = srcVolumeObjectTO . format ; \n \n \t6 destFile = destTemplateObjectTO . FullFileName ; \n \n \t6 if ( File . Exists ( destFile ) ) \n \n \t6 { \n \n <ect>
\t4 return true ; \n \n \t3 } else { \n \n \t4 logger . debug ( userName + <string_literal> + returnMessage ) ; } \n \n \t2 } else { \n \n <ect>
\t2 ProtoUtils . writeMessage ( outputStream , responseBuilder . build ( ) ) ; } \n \n \t1 public void handleError ( DataOutputStream outputStream , VoldemortException e ) throws IOException { \n \n \t2 responseBuilder . setError ( ProtoUtils . encodeError ( errorCodeMapper , e ) ) ; \n \n \t2 if ( logger . isEnabledFor ( Level . ERROR ) ) \n \n <ect>
\t4 <comment> \n \n \t4 api . sendCommand ( this . getClient ( ) , null ) ; \n \n \t4 <comment> \n \n \t4 if ( ( api . getResponseType ( ) == ResponseType . ERROR ) && ( api . getResponseCode ( ) == <number_literal> ) && ( api . getTestCaseInfo ( ) != null ) ) { \n \n <ect>
\t3 if ( offsetIntSize < 1 ) { \n \n \t4 log . error ( <string_literal> ) ; \n \n \t4 return false ; } \n \n \t3 if ( objectRefSize < 1 ) { \n \n <ect>
\t1 <comment> \n \n \t1 <comment> \n \n \t1 <comment> \n \n \t2 logger . debug ( <string_literal> + toTimeString ( usesTimer , totalTime ) ) ; \n \n <ect>
\t5 if ( portSettings == DSMRPortSettings . LOW_SPEED_SETTINGS ) { \n \n \t6 serialPort . setDTR ( false ) ; \n \n \t6 serialPort . setRTS ( true ) ; } \n \n \t4 } else { \n \n <ect>
\t3 state = MergeState . WAITING_FOR_CHOPPED ; \n \n \t2 } else { \n \n \t2 state = MergeState . WAITING_FOR_CHOPPED ; } \n \n \t1 } else { \n \n <ect>
\t4 service_id = service_uri . substring ( service_uri . lastIndexOf ( <string_literal> ) + 1 , service_uri . length ( ) - 1 ) ; \n \n \t4 logger . debug ( <string_literal> + service_uri ) ; \n \n \t4 logger . debug ( <string_literal> + service_id ) ; \n \n \t4 if ( name != null && name . isLiteral ( ) ) service_name = name . asLiteral ( ) . getString ( ) ; \n \n <ect>
\t4 <comment> \n \n \t4 SwingUtilities . invokeLater ( scrollToBottomRunnable ) ; } \n \n \t3 catch ( BadLocationException e ) \n \n \t3 { \n \n <ect>
\t4 this . sequence = Integer . parseInt ( name . substring ( idx + 1 ) ) ; \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t3 } catch ( NumberFormatException e ) { \n \n <ect>
\t4 MailerModel model = ( ( MailerResultCollector ) testElement ) . getMailerModel ( ) ; \n \n \t4 model . sendTestMail ( ) ; \n \n \t4 displayMessage ( JMeterUtils . getResString ( <string_literal> ) , false ) ; <comment> \n \n \t3 } catch ( AddressException ex ) { \n \n <ect>
\t4 storageVOs = _usageStorageDao . listByIdAndZone ( event . getAccountId ( ) , isoId , StorageTypes . ISO , zoneId ) ; \n \n \t3 } else { \n \n \t4 storageVOs = _usageStorageDao . listById ( event . getAccountId ( ) , isoId , StorageTypes . ISO ) ; } \n \n \t3 if ( storageVOs . size ( ) > 1 ) { \n \n <ect>
\t2 try { \n \n \t3 return StructrApp . getInstance ( securityContext ) . nodeQuery ( AbstractFile . class ) . and ( StructrApp . key ( AbstractFile . class , <string_literal> ) , absolutePath ) . getFirst ( ) ; \n \n \t2 } catch ( FrameworkException ex ) { \n \n \t3 ex . printStackTrace ( ) ; \n \n <ect>
\t2 checkNotNull ( ticket ) ; \n \n \t2 if ( taskSlotTable . isValidTimeout ( allocationId , ticket ) ) { \n \n \t3 freeSlotInternal ( allocationId , new Exception ( <string_literal> + allocationId + <string_literal> ) ) ; \n \n \t2 } else { \n \n <ect>
\t3 return resource . getURL ( ) ; } \n \n \t2 catch ( MalformedURLException ex ) { \n \n \t3 throw ex ; } \n \n \t2 catch ( IOException ex ) { \n \n <ect>
\t2 for ( Object compoundKey : batchIds ) \n \n \t2 { \n \n \t3 if ( ! ( compoundKey instanceof DataMap ) ) \n \n \t3 { \n \n <ect>
\t2 } finally { \n \n \t3 connection . disconnect ( ) ; } } \n \n \t1 @ Test ( timeout = <number_literal> ) \n \n \t1 public void testFrameSizeNotExceededWorks ( ) throws Exception { \n \n <ect>
\t5 log . error ( <string_literal> , _configDirectoryPath ) ; \n \n \t5 System . exit ( 1 ) ; } \n \n \t3 } else { \n \n \t4 if ( ! configDir . isDirectory ( ) ) { \n \n <ect>
\t1 public AuthenticationEventExecutionPlan authenticationEventExecutionPlan ( final List < AuthenticationEventExecutionPlanConfigurer > configurers ) { \n \n \t2 final DefaultAuthenticationEventExecutionPlan plan = new DefaultAuthenticationEventExecutionPlan ( ) ; \n \n \t2 configurers . forEach ( c - > { \n \n \t3 final String name = StringUtils . removePattern ( c . getClass ( ) . getSimpleName ( ) , <string_literal> ) ; \n \n <ect>
\t3 LOG . info ( <string_literal> + sb ) ; } \n \n \t2 orderStatusReply . close ( ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 context . stop ( ) ; \n \n <ect>
\t5 Node domain = l . getSource ( ) ; \n \n \t5 LabeledLink incomingLink = l ; \n \n \t5 Set < Node > matchedNodes = this . graphBuilder . getUriToNodesMap ( ) . get ( domain . getUri ( ) ) ; \n \n \t5 if ( matchedNodes == null || matchedNodes . isEmpty ( ) ) { \n \n <ect>
@ Override \n \n public void signal ( ServerType server , String hostname , String signal ) throws IOException { \n \n \t1 String pid = getPid ( server , accumuloHome , hostname ) ; \n \n \t1 if ( pid . trim ( ) . isEmpty ( ) ) { \n \n <ect>
\t1 String outFile = outDir + ' / ' + file . getName ( ) + <string_literal> ; \n \n \t1 try ( VectorWriter vectorWriter = getSeqFileWriter ( outFile ) ) { \n \n \t1 long numDocs = vectorWriter . write ( iteratable , maxDocs ) ; \n \n \t1 writeLabelBindings ( dictOut , model , delimiter , jsonDictonary ) ; \n \n <ect>
\t3 if ( this . mapInboundPriority ) { \n \n \t4 try { \n \n \t5 headers . put ( IntegrationMessageHeaderAccessor . PRIORITY , jmsMessage . getJMSPriority ( ) ) ; } \n \n \t4 catch ( Exception e ) { \n \n <ect>
\t3 props . load ( file ) ; \n \n \t3 file . close ( ) ; \n \n \t3 return props . getProperty ( property ) ; } \n \n \t2 catch ( IOException e ) { \n \n <ect>
\t4 public void handleThrowable ( SecurityContext securityContext , Throwable t , AbstractRelationship rel ) { \n \n \t5 logger . warn ( <string_literal> , rel , t . getMessage ( ) ) ; } \n \n \t4 @ Override \n \n \t4 public void handleTransactionFailure ( SecurityContext securityContext , Throwable t ) { \n \n <ect>
\t6 currentAvatar , \n \n \t6 newAvatar ) ; } } \n \n \t3 catch ( XMPPException ex ) \n \n \t3 { \n \n <ect>
\t6 ptStr ) ; } \n \n \t3 catch ( SdpException e ) \n \n \t3 { \n \n <ect>
\t8 putErrorHandler . handleExceptions ( messageEvent , e ) ; } } \n \n \t6 break ; \n \n \t5 case VoldemortOpCode . DELETE_OP_CODE : \n \n <ect>
\t2 LOGGER . warn ( <string_literal> , this . groovyScript , principal . getId ( ) ) ; \n \n \t2 return principal . getId ( ) ; } \n \n \t1 private String resolveUsernameFromInlineGroovyScript ( final Principal principal , final Service service , final String script ) { \n \n \t2 try { \n \n <ect>
\t3 sensor . init ( COMPONENT_NAME_PREFIX , <string_literal> , tags , ttl ) ; \n \n \t3 sensors . add ( new SensorEntry ( sensor , pollingInterval ) ) ; \n \n \t3 return sensors ; \n \n \t2 } catch ( Throwable f ) { \n \n <ect>
\t1 registerAutoGeneratedKeyPairCleanupCallbacks ( responses , generatedSshKeyIds ) ; \n \n \t1 return responses ; } \n \n private void createKeyPairForPublicKeyInOptionsAndAddToSet ( PacketTemplateOptions options , \n \n \t2 Set < String > generatedSshKeyIds ) { \n \n <ect>
\t4 awtAppClassName . setAccessible ( true ) ; \n \n \t4 awtAppClassName . set ( null , DEFAULT_APP_NAME ) ; \n \n \t3 } catch ( NoSuchFieldException | IllegalAccessException nsfe ) { \n \n <ect>
\t1 try { \n \n \t1 FileStatus [ ] fileStatuses = fs . globStatus ( p ) ; \n \n \t1 if ( null == fileStatuses ) { \n \n \t2 <comment> \n \n <ect>
\t6 headerAccessor . getMessageHeaders ( ) ) ; \n \n \t4 getMessagingTemplate ( ) . send ( StompInboundChannelAdapter . this . errorChannel , \n \n \t6 new ErrorMessage ( new MessageHandlingException ( failedMessage , exception ) ) ) ; } \n \n \t3 else { \n \n <ect>
\t5 break ; } } \n \n \t3 s_logger . error ( <string_literal> + mntPt ) ; } \n \n \t2 return mountPoint ; } \n \n \t1 private void startupCleanup ( String parent ) { \n \n <ect>
\t5 config . getCsHostGuid ( ) , \n \n \t5 config . getAgentStorageCheckTimeout ( ) , \n \n \t5 config . getAgentStorageCheckInterval ( ) ) ; \n \n \t2 } catch ( Exception es ) { \n \n <ect>
<comment> \n \n \t1 protected void assertScript ( String text ) throws Exception { \n \n \t2 assertScript ( text , getTestClassName ( ) ) ; } \n \n \t1 protected void assertScript ( final String text , final String scriptName ) throws Exception { \n \n <ect>
\t2 } finally { \n \n \t3 try { \n \n \t4 baos . close ( ) ; \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t5 return <string_literal> ; } \n \n \t4 return Double . toString ( d ) ; \n \n \t3 } catch ( NumberFormatException ex2 ) { \n \n \t4 <comment> \n \n <ect>
\t2 catch ( APIException e ) { \n \n \t3 response . sendError ( HttpServletResponse . SC_UNSUPPORTED_MEDIA_TYPE ) ; \n \n \t3 return ; } \n \n \t2 if ( isGZIPSupported ( request ) && isGZIPEnabled ( ) ) { \n \n <ect>
\t1 public int testUse ( @ PathParam ( <string_literal> ) int count ) { \n \n \t2 log . info ( <string_literal> ) ; \n \n \t2 log . info ( <string_literal> + readerEJB . getUses ( ) ) ; \n \n \t2 log . info ( <string_literal> + writerEJB . getUses ( ) ) ; \n \n <ect>
\t5 <comment> \n \n \t5 peer . setPeerState ( ServerState . LOOKING ) ; \n \n <ect>
\t1 this . fs = fs ; } \n \n @ Override \n \n public final void tokenize ( SourceCode source , Tokens cpdTokens ) { \n \n \t1 String fileName = source . getFileName ( ) ; \n \n <ect>
\t3 modefyTime = localstate . lastModified ( ) ; \n \n \t3 LOG . info ( modefyTime . toString ( ) ) ; \n \n \t3 LOG . info ( Long . toString ( new Date ( ) . getTime ( ) ) ) ; \n \n \t3 LOG . info ( dataPath + <string_literal> + startType + <string_literal> + startType + <string_literal> ) ; \n \n <ect>
\t2 } else { \n \n \t3 if ( debug > 0 ) { \n \n \t4 debug ( false ) ; } \n \n <ect>
\t2 logger . warn ( <string_literal> , uri , env ) ; \n \n \t2 throw new UnsupportedOperationException ( <string_literal> ) ; <comment> \n \n \t1 @ Override \n \n \t1 public synchronized FileSystem getFileSystem ( final URI uri ) { \n \n <ect>
\t1 sessionId = makeSessionId ( ) ; \n \n \t1 initErrorPatterns ( ) ; } \n \n @ Override \n \n public void open ( HiveConf conf ) throws HiveException { \n \n <ect>
\t2 unsubscribeAll ( message . get ( String . class , Subject ) ) ; \n \n \t2 break ; \n \n \t2 case FinishAssociation : \n \n \t2 sessionId = message . get ( String . class , MessageParts . ConnectionSessionKey ) ; \n \n <ect>
\t2 for ( String refName : refNames ) { \n \n \t3 String origValue = readRef ( refName ) ; \n \n \t3 if ( origValue != null ) { \n \n \t4 String origInternal = toOrigInternal ( refName ) ; \n \n <ect>
\t3 throw e ; } } \n \n \t1 @ Override \n \n \t1 protected void internalReceiveCommand ( String itemName , Command command ) { \n \n \t2 if ( ! m_acceptCommands ) { \n \n <ect>
\t2 String dir = PMS . getConfiguration ( ) . getDataFile ( SUB_DIR ) ; \n \n \t2 File path = new File ( dir ) ; \n \n \t2 if ( ! path . exists ( ) ) { \n \n \t3 if ( ! path . mkdirs ( ) ) { \n \n <ect>
\t3 assertFalse ( store . isMaster ( ) ) ; } \n \n \t2 master = null ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 this . connector . testHandle . setIOWaitMillis ( 0 , <number_literal> * <number_literal> ) ; \n \n <ect>
<comment> \n \n \t1 private void processGetHomeData ( OAuthCredentials oauthCredentials , Collection < NetatmoBindingProvider > providers , \n \n \t3 EventPublisher eventPublisher ) { \n \n \t2 GetHomeDataRequest homeDataRequest = new GetHomeDataRequest ( oauthCredentials . getAccessToken ( ) ) ; \n \n <ect>
\t3 Object value = parseKeyFromBatchV1 ( id , resource ) ; \n \n \t3 batchKeys . add ( value ) ; } \n \n \t3 catch ( NumberFormatException e ) \n \n \t3 { \n \n <ect>
\t2 right . write ( ) ; \n \n \t2 <comment> \n \n \t2 if ( logging ( ) ) \n \n \t2 { \n \n <ect>
\t3 assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <string_literal> ) . setWaitForGreenStatus ( ) ) ; \n \n \t3 logger . info ( <string_literal> , totalNumDocs ) ; \n \n \t3 waitForDocs ( totalNumDocs , indexer ) ; \n \n \t3 indexer . assertNoFailures ( ) ; \n \n <ect>
\t2 File f = new File ( new URI ( configFile ) ) ; \n \n \t2 if ( f . exists ( ) && ! f . isDirectory ( ) ) { \n \n \t2 accumuloConfigUrl = f . toURI ( ) . toURL ( ) ; \n \n \t2 } else { \n \n <ect>
\t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof RemoteException ) { \n \n \t4 s_logger . warn ( <string_literal> ) ; \n \n \t4 invalidateServiceContext ( ) ; } \n \n <ect>
<comment> \n \n \t1 public boolean isConnected ( ) { \n \n \t2 return connection . getSocket ( ) != null && ! connection . getSocket ( ) . isClosed ( ) ; } \n \n \t1 private void notifyConfigReceived ( ) { \n \n <ect>
\t6 log . info ( <string_literal> + ggHome ) ; \n \n \t6 log . info ( <string_literal> + marshaller ) ; \n \n \t6 log . info ( <string_literal> + springCtx ) ; \n \n \t6 log . info ( <string_literal> + ses ) ; \n \n <ect>
\t2 throws IOException { \n \n \t1 try { \n \n \t1 if ( fs instanceof DistributedFileSystem ) { \n \n \t2 if ( ! ( ( DistributedFileSystem ) fs ) . recoverLease ( lockFile ) ) { \n \n <ect>
\t2 <comment> \n \n \t2 String str = bos . toString ( ) ; \n \n \t2 <comment> \n \n \t2 if ( propsFile != null ) { \n \n <ect>
\t1 final String qualifiedUser1 = kdc . qualifyUser ( user1 ) ; \n \n \t1 <comment> \n \n \t1 UserGroupInformation ugi = UserGroupInformation . loginUserFromKeytabAndReturnUGI ( qualifiedUser1 , \n \n \t2 user1Keytab . getAbsolutePath ( ) ) ; \n \n <ect>
\t2 if ( encryptionSecretSize < = 0 || StringUtils . isBlank ( encryptionMethod ) || StringUtils . isBlank ( encryptionAlgorithm ) ) { \n \n \t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 final String encryptionSecret = RandomStringUtils . randomAlphanumeric ( encryptionSecretSize ) ; \n \n <ect>
\t1 boolean isInvoking = false ; \n \n \t1 public void awake ( ) { \n \n \t2 super . awake ( ) ; \n \n \t2 isInvoking = false ; \n \n <ect>
\t4 zController . notifyEventListeners ( new ZWaveInclusionEvent ( ZWaveInclusionEvent . Type . ExcludeSlaveFound , \n \n \t6 incomingMessage . getMessagePayloadByte ( <number_literal> ) ) ) ; \n \n \t4 break ; \n \n \t3 case REMOVE_NODE_STATUS_REMOVING_CONTROLLER : \n \n <ect>
\t1 } catch ( ClassNotFoundException e ) { \n \n \t1 LOG . error ( <string_literal> + StringUtils . stringifyException ( e ) ) ; \n \n \t1 throw new IOException ( e ) ; \n \n \t1 } catch ( InstantiationException e ) { \n \n <ect>
\t1 logger . warn ( <string_literal> , upload_command ) \n \n \t1 logger . warn ( str ( e ) ) \n \n \t1 sys . exit ( ) \n \n \t1 if result != 0 : \n \n <ect>
\t2 super . sendInitialMessages ( ) ; \n \n \t2 try { \n \n \t3 sendVisibility ( ) ; \n \n \t2 } catch ( NotConnectedException e ) { \n \n <ect>
\t1 if ( response . getPayload ( ) != null ) { \n \n \t2 try { \n \n \t3 return Strings2 . toString ( response . getPayload ( ) ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t2 boolean checkexpired = true ; \n \n \t2 try { \n \n \t3 socket . receive ( receivePacket ) ; \n \n \t3 if ( receivePacket . getLength ( ) > MAX_PACKET_SIZE ) { \n \n <ect>
\t2 int breakindex = 0 ; \n \n \t2 try { \n \n \t3 breakindex = Integer . parseInt ( boundary . getAttribute ( <string_literal> ) ) ; \n \n \t2 } catch ( NumberFormatException e ) { \n \n <ect>
\t2 } finally { \n \n \t3 removeNamespace ( testName ) ; \n \n \t3 removeNamespace ( testName2 ) ; \n \n \t3 tHandle . close ( ) ; } \n \n <ect>
\t4 String location = this . defaultEntityReferenceSerializer . serialize ( newReference ) ; \n \n \t4 oldDocument . getXObject ( redirectClassReference , number ) . setStringValue ( <string_literal> , location ) ; \n \n \t4 oldDocument . setHidden ( true ) ; \n \n \t4 xcontext . getWiki ( ) . saveDocument ( oldDocument , <string_literal> , xcontext ) ; \n \n <ect>
\t1 cd_access = 'a' , \n \n \t1 create_parents = True , \n \n \t1 recursive_ownership = True ) \n \n mapreduce_tarball_with_native_lib = os . path . join ( mapreduce_native_tarball_staging_dir , <string_literal> ) \n \n <ect>
\t1 } finally { \n \n \t2 tm ( 0 ) . rollback ( ) ; } \n \n \t1 assertNotLocked ( k1 ) ; \n \n \t1 eventually ( ( ) - > checkTxCount ( 0 , 1 , 0 ) && checkTxCount ( 1 , 0 , 0 ) && checkTxCount ( <number_literal> , 0 , 0 ) ) ; \n \n <ect>
\t8 singlePrivateIp = myVM . getPrivateIp ( ) ; \n \n \t8 if ( singlePrivateIp != null ) { \n \n \t9 s_logger . info ( <string_literal> + singlePrivateIp + <string_literal> ) ; \n \n \t8 } else { \n \n <ect>
\t4 s_logger . debug ( <string_literal> + t . getRequestURI ( ) ) ; \n \n \t3 long startTick = System . currentTimeMillis ( ) ; \n \n \t3 doHandle ( t ) ; \n \n <ect>
\t3 tracker = _DCCClientManager ; } \n \n \t2 <comment> \n \n \t2 int rv = tracker . newIncoming ( b32 , port , type ) ; \n \n \t2 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n \t3 logger . warn ( <string_literal> ) ; \n \n \t2 if ( ! PackManager . v ( ) . hasPhase ( <string_literal> ) ) \n \n <ect>
<number_literal> TunnelPoolSettings . PROP_BACKUP_QUANTITY , out . getBackupQuantity ( ) + <string_literal> ) ; } \n \n \t3 if ( <string_literal> . equals ( poolName ) ) { \n \n \t4 if ( _log . shouldLog ( Log . DEBUG ) ) { \n \n \t5 _log . debug ( <string_literal> + in ) ; \n \n <ect>
\t4 sb . append ( Integer . toHexString ( c ) ) ; \n \n \t4 sb . append ( ' ' ) ; } \n \n \t3 String hexReturn = sb . toString ( ) ; \n \n \t3 { \n \n <ect>
\t1 static public < T > List < List < T > > permute ( List < T > c ) \n \n \t1 { \n \n \t2 if ( c . size ( ) > <number_literal> ) \n \n \t2 { \n \n <ect>
\t1 @ Override \n \n \t1 public void execute ( JobExecutionContext jobContext ) throws JobExecutionException { \n \n \t2 JobDataMap jobDataMap = jobContext . getJobDetail ( ) . getJobDataMap ( ) ; \n \n \t2 String locationId = jobDataMap . getString ( <string_literal> ) ; \n \n <ect>
\t6 Map < String , Tag > parentTags , \n \n \t6 List < Parameter > parentParameters ) { \n \n \t1 NestedApiRecord nestedApiRecord = nestedAPIs . get ( cls ) ; \n \n \t1 if ( null != nestedApiRecord ) { \n \n <ect>
\t2 <comment> \n \n \t2 public void setBrokerService ( BrokerService brokerService ) { \n \n <ect>
\t3 try { \n \n \t4 System . arraycopy ( buffer , 0 , copy , 0 , buffer . length ) ; \n \n \t4 logger . info ( <string_literal> + formatter . format ( buffer . length ) + <string_literal> + formatter . format ( copy . length ) + <string_literal> ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 } catch ( IllegalBlockSizeException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( BadPaddingException e ) { \n \n <ect>
\t3 log . warn ( <string_literal> + id + <string_literal> ) ; \n \n \t3 context . getBatchKeyErrors ( ) . put ( id , new RestLiServiceException ( HttpStatus . S_400_BAD_REQUEST , null , e ) ) ; } \n \n \t3 catch ( PathSegmentSyntaxException e ) \n \n \t3 { \n \n <ect>
<number_literal> public Message createMessage ( Session session ) throws JMSException { \n \n <number_literal> return session . createTextMessage ( <string_literal> + queue + <string_literal> + BODY ) ; } \n \n \t10 } ) ; \n \n \t10 Thread . sleep ( ( long ) ( Math . random ( ) * SLEEP ) ) ; \n \n <ect>
\t4 . addScriptField ( <string_literal> , scripField ) \n \n \t4 . addSort ( <string_literal> , SortOrder . DESC ) \n \n \t4 . get ( ) ; \n \n \t2 if ( searchResponse . getFailedShards ( ) > 0 ) { \n \n <ect>
@ ToString \n \n public abstract class BaseOneTimeTokenRepository implements OneTimeTokenRepository { \n \n \t1 @ Override \n \n \t1 public final void clean ( ) { \n \n <ect>
\t1 } else { \n \n \t2 mLogger . warn ( String . format ( <string_literal> , failedTests . size ( ) ) ) ; } \n \n \t1 for ( String failingTestName : failedTests ) { \n \n \t2 mLogger . warn ( failingTestName ) ; } \n \n <ect>
\t1 public void commit ( ) { \n \n \t2 try { \n \n \t3 getSolr ( ) . commit ( ) ; \n \n \t2 } catch ( SolrServerException e ) { \n \n <ect>
\t6 executeRequest ( new SyncBcfTopologyCommand ( true , false ) , _numRetries ) ; } \n \n \t4 } else { \n \n \t5 s_logger . debug ( <string_literal> ) ; } } \n \n \t2 } catch ( BigSwitchBcfApiException e ) { \n \n <ect>
\t2 log . error ( prefix + <string_literal> ) ; \n \n \t2 traceForPermanent ( game , attacker , prefix , restrictionEffects ) ; \n \n \t2 if ( blocker != null ) { \n \n \t3 log . error ( prefix ) ; \n \n <ect>
\t1 try { \n \n \t2 connectionAmbariDatabase . rollback ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t1 } catch ( SQLException e2 ) { \n \n <ect>
\t3 _LOGGER . error ( <string_literal> , e ) ; \n \n \t3 msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; \n \n \t3 msg = ( org . apache . thrift . TApplicationException ) e ; \n \n \t3 } else { \n \n <ect>
\t4 ExternalIdentity extId = idp . getIdentity ( ref ) ; \n \n \t4 if ( extId instanceof ExternalGroup ) { \n \n \t5 extGroup = ( ExternalGroup ) extId ; \n \n \t4 } else { \n \n <ect>
\t3 return null ; } } \n \n \t1 public ProjectInstance createProject ( String projectName , String owner , String description , \n \n \t3 LinkedHashMap < String , String > overrideProps ) throws IOException { \n \n \t2 try ( AutoLock lock = prjMapLock . lockForWrite ( ) ) { \n \n <ect>
public void removeFromEmployees ( er . rest . example . model . Person object ) { \n \n \t1 excludeObjectFromPropertyWithKey ( object , _Company . EMPLOYEES_KEY ) ; } \n \n public void addToEmployeesRelationship ( er . rest . example . model . Person object ) { \n \n <ect>
counter = 0 \n \n while not component_is_stopped : \n \n \t1 try : \n \n \t1 if counter % <number_literal> == 0 : \n \n <ect>
\t3 masterEntry . getKey ( ) . compareTo ( peerEntry . getKey ( ) , \n \n \t4 PartialKey . ROW_COLFAM_COLQUAL_COLVIS ) ) ; \n \n \t2 Assert . assertEquals ( masterEntry . getValue ( ) , peerEntry . getValue ( ) ) ; } \n \n \t2 log . info ( <string_literal> , masterEntry ) ; \n \n <ect>
\t3 client . deleteNode ( node . getId ( ) ) ; \n \n \t3 logger . debug ( <string_literal> , node . getName ( ) ) ; \n \n \t3 Set < Node > nodes = client . getNodes ( service . getId ( ) ) ; \n \n \t3 if ( nodes . size ( ) == 0 ) { \n \n <ect>
\t2 else { \n \n \t3 try { \n \n \t4 return Double . parseDouble ( o . toString ( ) ) ; } \n \n \t3 catch ( NumberFormatException e ) { \n \n <ect>
\t1 try { \n \n \t2 cacheManager . persistMetadata ( metadataToPersist ) ; \n \n \t2 markSuccess = true ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t4 throw new CloudRuntimeException ( <string_literal> ) ; } \n \n \t2 } else { \n \n \t3 s_logger . info ( <string_literal> ) ; \n \n \t3 if ( userid . startsWith ( <string_literal> ) ) { \n \n <ect>
\t2 logger . info ( <string_literal> ) ; \n \n \t2 indexData ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( primaryNode ) ) ; \n \n <ect>
\t3 setDisconnectedState ( failed , reason ) ; } \n \n \t2 else \n \n \t2 { \n \n \t3 setDisconnectedState ( failed , reason ) ; \n \n <ect>
\t2 case PASSIVE_INTERACTION_REQUIRED : \n \n \t2 case PASSIVE_LOGIN_REQUIRED : \n \n \t3 return Messages . UNEXPECTED_ERROR_HANDLING_REQUEST ; \n \n \t2 default : \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bc ) throws Exception { \n \n \t2 context = null ; \n \n <ect>
\t3 } catch ( I2PException ie ) { \n \n \t4 _log . error ( <string_literal> , ie ) ; \n \n \t4 return ; \n \n \t3 } catch ( IOException ioe ) { \n \n <ect>
\t5 try { \n \n \t6 getInternalSession ( ) . rollback ( ) ; \n \n \t5 } catch ( JMSException e ) { \n \n \t6 invalidate = true ; \n \n <ect>
\t5 OWServerConfig server = serverList . get ( unit ) ; \n \n \t5 needsUpdate = false ; \n \n \t5 if ( server == null ) { \n \n \t6 needsUpdate = false ; \n \n <ect>
\t2 <comment> \n \n \t2 HashMap < String , String > infoMap = new HashMap < String , String > ( ) ; \n \n \t2 saveObjectInfo ( topCommunity , infoMap ) ; \n \n \t2 <comment> \n \n <ect>
\t1 iops . setProperty ( Property . GC_CYCLE_START . getKey ( ) , gcCycleStart ) ; } \n \n \t1 log . info ( <string_literal> ) ; \n \n \t1 getCluster ( ) . getClusterControl ( ) . stopAllServers ( ServerType . GARBAGE_COLLECTOR ) ; \n \n \t1 getCluster ( ) . getClusterControl ( ) . startAllServers ( ServerType . GARBAGE_COLLECTOR ) ; \n \n <ect>
\t2 LOG . info ( <string_literal> ) ; \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 options . setOutputDelimiters ( DelimiterSet . HIVE_DELIMITERS ) ; } \n \n \t1 if ( options . getOutputEscapedBy ( ) != DelimiterSet . NULL_CHAR ) { \n \n <ect>
\t2 if ( ! success ) { \n \n \t3 log . warn ( <string_literal> + dir . getAbsolutePath ( ) ) ; \n \n \t3 dir . deleteOnExit ( ) ; } \n \n <ect>
\t3 return false ; } \n \n \t2 return true ; } \n \n \t1 private boolean validateOutputPath ( String output ) throws URISyntaxException { \n \n \t2 if ( ! output . startsWith ( <string_literal> ) ) { \n \n <ect>
\t4 throw new CloudRuntimeException ( <string_literal> + storageUrl ) ; } \n \n \t3 mountPoint = mount ( File . separator + File . separator + uri . getHost ( ) + uri . getPath ( ) , getMountParent ( ) , \n \n \t4 uri . getScheme ( ) , uri . getQuery ( ) ) ; \n \n \t3 if ( mountPoint == null ) { \n \n <ect>
\t3 Pair < Integer , Integer > pair = getExpectedRowAndCol ( expectResultFile ) ; \n \n \t3 int expectRowCount = pair . getFirst ( ) ; \n \n \t3 int expectColCount = pair . getSecond ( ) ; \n \n \t3 <comment> \n \n <ect>
\t5 if ( success ) \n \n \t6 <comment> \n \n \t6 processMainJarBlob ( temp , source , version , jarURI ) ; \n \n \t5 else { \n \n <ect>
\t4 SAXParser parser = newSAXParser ( ) ; \n \n \t4 if ( parser != null ) \n \n \t5 parser . parse ( new InputSource ( new StringReader ( string ) ) , dictionaryParser ) ; \n \n \t3 } catch ( SAXException exception ) { \n \n <ect>
public String reviewer ( ) { \n \n \t1 return ( String ) storedValueForKey ( _Review . REVIEWER_KEY ) ; } \n \n public void setReviewer ( String value ) { \n \n <ect>
\t3 DurableTopicSubscription sub = entry . getValue ( ) ; \n \n \t3 if ( ! sub . isActive ( ) ) { \n \n \t4 long offline = sub . getOfflineTimestamp ( ) ; \n \n \t4 if ( offline != - 1 && now - offline >= broker . getBrokerService ( ) . getOfflineDurableSubscriberTimeout ( ) ) { \n \n <ect>
\t2 try { \n \n \t3 synchronized ( progressLock ) { \n \n \t4 <comment> \n \n \t4 if ( globalModVersion != expectedGlobalVersion ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 logger . error ( <string_literal> + index + <string_literal> ) ; \n \n \t4 throw new IllegalStateException ( \n \n \t6 <string_literal> + index + <string_literal> ) ; } \n \n \t3 if ( hasSingleOrNone ( jointDimsList ) ) { \n \n <ect>
\t6 LOGGER . debug ( <string_literal> , file . getAbsolutePath ( ) ) ; \n \n \t6 writeToZip ( zos , file ) ; } } } \n \n \t3 openZip . setEnabled ( true ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t4 apps . add ( app ) ; } \n \n \t2 } catch ( SQLException e ) { \n \n \t3 log . error ( <string_literal> , e ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t6 <string_literal> + ctx . getTaskSession ( ) . getTaskName ( ) + ' ] ' ) ; } \n \n \t4 else { \n \n \t5 totalStolenJobs ++ ; \n \n <ect>
\t3 reconcileOks . add ( msg . getSrc ( ) ) ; \n \n \t3 if ( reconcileOks . size ( ) >= flushMembers . size ( ) ) { \n \n \t4 flush_promise . setResult ( SUCCESS_START_FLUSH ) ; \n \n <ect>
\t1 @ SneakyThrows \n \n \t1 private static Optional < SamlRegisteredServiceServiceProviderMetadataFacade > get ( final SamlRegisteredServiceCachingMetadataResolver resolver , \n \n <number_literal> final SamlRegisteredService registeredService , \n \n <number_literal> final String entityID , final CriteriaSet criterions ) { \n \n <ect>
\t1 private static final Logger LOG = LoggerFactory . getLogger ( StompTelnetTest . class ) ; \n \n \t1 @ Test ( timeout = <number_literal> ) \n \n \t1 public void testCRLF ( ) throws Exception { \n \n \t2 for ( TransportConnector connector : brokerService . getTransportConnectors ( ) ) { \n \n <ect>
\t4 state = FHTState . WINDOW_CLOSED ; } \n \n \t3 if ( state != null ) { \n \n \t4 receivedNewFHT8bState ( device , state ) ; \n \n \t3 } else { \n \n <ect>
\t3 lock . unlock ( ) ; } } \n \n \t1 @ Override \n \n \t1 public boolean checkDiskSpace ( File file , int toWrite , int bufferSize ) { \n \n \t2 if ( ! FileUtil . isParent ( dir , file ) ) { \n \n <ect>
\t2 final CountDownLatch called = new CountDownLatch ( 1 ) ; \n \n \t2 connection . setExceptionListener ( new ExceptionListener ( ) { \n \n \t3 @ Override \n \n \t3 public void onException ( JMSException exception ) { \n \n <ect>
\t1 collectionCreateRequest . setMaxShardsPerNode ( solrPropsConfig . getReplicationFactor ( ) * solrPropsConfig . getNumberOfShards ( ) ) ; \n \n \t1 CollectionAdminResponse createResponse = collectionCreateRequest . process ( solrClient ) ; \n \n \t1 if ( createResponse . getStatus ( ) != 0 ) { \n \n \t2 returnValue = false ; \n \n <ect>
\t4 } catch ( InsufficientCapacityException e ) { \n \n \t5 s_logger . warn ( <string_literal> + getName ( ) + <string_literal> + sourceIp + <string_literal> , e ) ; \n \n \t5 return false ; \n \n \t4 } catch ( ConcurrentOperationException e ) { \n \n <ect>
\t10 <string_literal> , \n \n \t10 adname , value ) ; } } \n \n \t6 if ( advalue == null ) { \n \n \t7 if ( logger != null ) \n \n <ect>
\t2 if ( failoverRegion == null ) { \n \n \t3 executionGraph . failGlobal ( new FlinkException ( \n \n \t5 <string_literal> + ev . getTaskNameWithSubtaskIndex ( ) , cause ) ) ; } \n \n \t2 else { \n \n <ect>
\t3 HostOfferResponse hostOfferResponse = request . offer ( host ) ; \n \n \t3 switch ( hostOfferResponse . getAnswer ( ) ) { \n \n \t3 case ACCEPTED : \n \n \t4 matchedToRequest = true ; \n \n <ect>
\t7 sendRequest ( owner . getAddress ( ) , Type . INTERRUPT_RUN , \n \n \t8 owner . getRequestId ( ) , null ) ; } } \n \n \t5 else { \n \n <ect>
\t3 LOG . debug ( key + <string_literal> ) ; \n \n \t3 if ( hasHeader && header == null ) \n \n \t3 { \n \n \t4 header = contents ; \n \n <ect>
\t2 <comment> \n \n \t2 return options ; } \n \n \t1 protected abstract void applyDataModuleOptions ( T2 options , Map < String , Object > parameters ) ; \n \n \t1 private T1 lookupConnection ( final String fullUri , final Map < String , Object > parameters ) throws Exception { \n \n <ect>
\t2 for ( BroadcasterCacheListener l : listeners ) { \n \n \t3 try { \n \n \t4 l . onAddCache ( broadcasterId , message ) ; \n \n \t3 } catch ( Exception ex ) { \n \n <ect>
\t2 try { \n \n \t3 urlSet = urlSet . excludeJavaHome ( ) ; \n \n \t2 } catch ( NullPointerException e ) { \n \n \t3 <comment> \n \n <ect>
\t3 OAuth20Utils . writeTextError ( response , OAuth20Constants . INVALID_GRANT ) ; \n \n \t3 return ; } \n \n \t2 final J2EContext context = Pac4jUtils . getPac4jJ2EContext ( request , response ) ; \n \n \t2 final Pair < AccessToken , RefreshToken > accessToken = accessTokenGenerator . generate ( requestHolder ) ; \n \n <ect>
\t1 private InputStream retrieveResource ( String path ) throws FileNotFoundException { \n \n \t2 File file = new File ( path ) ; \n \n \t2 if ( file . exists ( ) ) { \n \n \t3 return new FileInputStream ( file ) ; } \n \n <ect>
\t2 for ( Entry < String , TableInfo > entry : tserver . tableMap . entrySet ( ) ) { \n \n \t2 if ( entry . getKey ( ) . startsWith ( <string_literal> ) || entry . getKey ( ) . startsWith ( <string_literal> ) ) \n \n \t3 continue ; \n \n \t2 tablets += entry . getValue ( ) . onlineTablets ; } } \n \n <ect>
\t4 } catch ( InterruptedException ignored ) { } } \n \n \t2 } catch ( Throwable e ) { \n \n \t3 if ( e instanceof OutOfMemoryError ) { \n \n \t4 LOG . error ( <string_literal> ) ; } \n \n <ect>
\t7 lca = lca . lca_1 ( type ) ; } } } \n \n \t4 if ( lca != null ) { \n \n \t5 if ( DEBUG ) { \n \n \t6 if ( lca == ClassHierarchy . v ( ) . TOP ) { \n \n <ect>
\t1 public boolean isVmAlive ( com . cloud . vm . VirtualMachine vm , Host host ) throws UnknownVM { \n \n \t2 if ( haManager . isHAEligible ( host ) ) { \n \n \t3 return haManager . isVMAliveOnHost ( host ) ; } \n \n \t2 Status status = isAgentAlive ( host ) ; \n \n <ect>
\t1 void handleConnectionFailure ( Connection connection ) { \n \n \t2 <comment> \n \n \t2 if ( connection == null || ! this . started . get ( ) ) { \n \n \t3 return ; } \n \n <ect>
\t1 verifyRun ( <string_literal> + replDbName + <string_literal> , unptn_data , driverMirror ) ; } \n \n @ Test \n \n public void testIncrementalInsertToPartition ( ) throws IOException { \n \n \t1 String testName = <string_literal> ; \n \n <ect>
\t7 String password , \n \n \t7 String realm , \n \n \t7 HttpServletRequest request ) \n \n \t2 throws SQLException { \n \n <ect>
\t9 self . apiclient , \n \n \t9 self . services [ <string_literal> ] \n \n \t7 ) \n \n \t2 self . _cleanup . append ( self . public_ip_range ) \n \n <ect>
\t4 return null ; } \n \n \t3 try { \n \n \t4 connection . setAutoCommit ( true ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t2 @ Override \n \n \t2 public void setup ( final ManagementClient managementClient , final String containerId ) throws IOException { \n \n \t3 for ( TestModule testModule : modules ) { \n \n \t4 testModule . create ( true ) ; } \n \n <ect>
\t2 if ( mod == null ) { \n \n \t3 throw new IllegalStateException ( <string_literal> ) ; } \n \n \t2 CACHES . add ( cache ) ; \n \n \t2 if ( DEBUG ) { \n \n <ect>
\t2 if ( StringUtils . isNotBlank ( ticketGrantingTicket ) ) { \n \n \t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 final Authentication authenticationFromTgt = this . ticketRegistrySupport . getAuthenticationFrom ( ticketGrantingTicket ) ; \n \n \t3 if ( authenticationFromTgt == null ) { \n \n <ect>
<comment> \n \n \t1 public boolean safeEvalAsBodyClause ( RuleContext context ) { \n \n \t2 if ( getImplementor ( ) == null ) { \n \n <ect>
\t2 boolean savingSuccessful = false ; \n \n \t2 int countNumeric = 0 ; \n \n \t2 <comment> \n \n \t2 if ( label == null || label . trim ( ) . length ( ) == 0 || examples . isEmpty ( ) ) { \n \n <ect>
\t6 handleIO ( key ) ; \n \n \t5 } else { \n \n \t6 LOG . warn ( <string_literal> + key . readyOps ( ) ) ; } } \n \n \t3 } catch ( IOException e ) { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 this . query = query ; } \n \n \t2 @ Override \n \n \t2 public Object visit ( ResolvedFunCall call ) { \n \n <ect>
\t7 noCleanup ) ) ; \n \n \t5 updateBundleAction ( coordNameToBAMapping . get ( coordName ) ) ; \n \n \t5 isUpdateActionDone = true ; } \n \n \t4 else { \n \n <ect>
\t3 Logger . error ( this , <string_literal> + extraPeerDataPeerDir . getPath ( ) ) ; \n \n \t3 return false ; } \n \n \t2 File extraPeerDataFile = new File ( extraPeerDataDirPath + File . separator + getIdentityString ( ) + File . separator + fileNumber ) ; \n \n \t2 if ( ! extraPeerDataFile . exists ( ) ) { \n \n <ect>
\t5 itemregistry = ( ItemRegistry ) bundleContext . getService ( serviceReference2 ) ; \n \n \t4 } else { \n \n \t5 logger . warn ( <string_literal> ) ; } \n \n \t3 } else { \n \n <ect>
<comment> \n \n \t1 public void executeDirectly ( String jobId ) { \n \n \t2 final CmsScheduledJobInfo jobInfo = ( CmsScheduledJobInfo ) getJob ( jobId ) . clone ( ) ; \n \n \t2 if ( jobInfo == null ) { \n \n <ect>
\t3 if ( TIKA_AVAILABLE ) { \n \n \t4 LOGGER . debug ( <string_literal> ) ; \n \n \t3 } else { \n \n <ect>
\t3 LOGGER . debug ( <string_literal> ) ; \n \n \t3 final RequestSecurityTokenResponse rsToken = ( RequestSecurityTokenResponse ) unmarshaller . unmarshall ( metadataRoot ) ; \n \n \t3 if ( rsToken . getRequestedSecurityToken ( ) == null ) { \n \n \t4 throw new IllegalArgumentException ( <string_literal> ) ; } \n \n <ect>
\t1 if ( HIKARI . equals ( poolingType ) ) { \n \n \t1 int hikariPropsNr = DataSourceProvider . getPrefixedProperties ( configuration , HIKARI ) . size ( ) ; \n \n \t1 LOG . debug ( <string_literal> + hikariPropsNr + <string_literal> ) ; \n \n \t1 return hikariPropsNr > 0 ; } \n \n <ect>
\t3 return - 1L ; } \n \n \t2 try { \n \n \t3 return store . getBlobLength ( blobId ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 t = remoteaddr . substring ( start + 1 , remoteaddr . length ( ) ) ; \n \n \t2 } else { \n \n \t3 t = remoteaddr ; } \n \n \t2 remoteaddr = t ; \n \n <ect>
\t6 LOG . error ( <string_literal> + newTransports , e ) ; } } } } } \n \n \t1 @ Override \n \n \t1 public void start ( ) throws Exception { \n \n \t2 synchronized ( reconnectMutex ) { \n \n <ect>
\t3 LOGGER . warn ( <string_literal> , registeredService ) ; \n \n \t3 return false ; } \n \n \t2 final String redirectUri = request . getParameter ( OAuth20Constants . REDIRECT_URI ) ; \n \n \t2 if ( ! validator . checkCallbackValid ( registeredService , redirectUri ) ) { \n \n <ect>
\t2 this . packageName = packageName ; \n \n \t2 this . author = author ; \n \n \t2 this . description = description ; \n \n \t2 this . version = version ; \n \n <ect>
\t5 LOG . debug ( format ( <string_literal> , file . getPath ( ) ) ) ; } \n \n \t4 splitter . readSplitsForFile ( file ) ; } \n \n <ect>
<comment> \n \n \t1 public List < Protos . Resource > takeRanges ( String resourceName , int amount , Set < String > roles ) { \n \n <ect>
\t3 try { \n \n \t4 if ( mod . getModuleActivator ( ) != null ) { <comment> \n \n \t5 mod . getModuleActivator ( ) . willStop ( ) ; } } \n \n \t3 catch ( Exception t ) { \n \n <ect>
\t2 <comment> \n \n \t2 <comment> \n \n \t2 if ( StringUtils . isBlank ( session ) ) { \n \n \t3 session = UUID . randomUUID ( ) . toString ( ) ; \n \n <ect>
\t1 JSONObject response = new JSONObject ( ) ; \n \n \t1 response . put ( <string_literal> , new DDL ( query ) ) ; \n \n \t1 return Response . status ( Response . Status . ACCEPTED ) . entity ( response ) . build ( ) ; \n \n \t1 } catch ( ServiceException e ) { \n \n <ect>
\t1 try { \n \n \t1 currentFileRead . closeOffsetReader ( ) ; \n \n \t1 currentFileRead = null ; \n \n \t1 } catch ( Exception ex ) { \n \n <ect>
\t2 this . readDir = readDir ; \n \n \t2 if ( StringUtils . isBlank ( readDir ) ) { \n \n \t3 LOG . warn ( <string_literal> ) ; \n \n \t2 } else { \n \n <ect>
\t3 logger . trace ( <string_literal> , this . hashCode ( ) ) ; \n \n \t3 throw new IOException ( <string_literal> + uuid ) ; } } \n \n \t1 private boolean validFlushOrClose ( ) { \n \n \t2 if ( asyncIOWriter == null ) { \n \n <ect>
\t2 try { \n \n \t3 final TicketDefinition tkt = this . ticketCatalog . find ( ticketId ) ; \n \n \t3 return this . entityManager . find ( tkt . getImplementationClass ( ) , ticketId , this . lockType ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t3 discover = new MDNSProvisioningDiscover ( ) ; \n \n \t3 discover . addDiscoveryListener ( this ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n <ect>
\t2 yk [ 0 ] = y ; \n \n \t2 yk [ 1 ] = k ; \n \n \t2 <comment> \n \n \t2 <comment> \n \n <ect>
\t3 sendResponse ( resp , <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 HostVO host = _ms . getHostBy ( vm . getHostId ( ) ) ; \n \n \t2 if ( host == null ) { \n \n <ect>
\t3 msg = new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } \n \n \t3 try { \n \n \t3 fcall . sendResponse ( fb , msg , msgType , seqid ) ; \n \n \t3 } catch ( java . lang . Exception ex ) { \n \n <ect>
\t1 <comment> \n \n \t1 @ SuppressWarnings ( <string_literal> ) \n \n \t1 @ Override public Object call ( ) throws Exception { \n \n <ect>
\t3 addMessage ( ms , msgid , playload ) ; \n \n \t3 expected_list . add ( msgid ) ; } \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 assertEquals ( expected_list , getMessages ( ms ) ) ; \n \n <ect>
\t4 started = true ; \n \n \t4 flags | = FLAG_STARTED ; } \n \n \t3 catch ( PortAudioException paex ) \n \n \t3 { \n \n <ect>
def checkForUserKey ( ) : Boolean = { \n \n \t1 val userKeySet = ! userKey . equalsIgnoreCase ( <string_literal> ) \n \n \t1 if ( userKeySet ) true \n \n \t1 else { \n \n <ect>
<comment> \n \n \t1 public static void setProperties ( SystemStoreClient < String , String > versionStore , \n \n \t9 Versioned < Properties > props ) { \n \n \t2 if ( props == null || props . getValue ( ) == null ) { \n \n <ect>
\t3 logger . debug ( <string_literal> , max ) ; } \n \n \t2 BigDecimal min = Tools . getBigDecimalOpt ( ConfigOptsDimmable . MIN . toString ( ) , opts ) ; \n \n \t2 logger . debug ( <string_literal> , min ) ; \n \n \t2 if ( min == null ) { \n \n <ect>
<number_literal> s_logger . warn ( <string_literal> + domainId ) ; } } } \n \n \t8 s_logger . debug ( <string_literal> + domainId ) ; \n \n \t8 _domainMgr . removeDomain ( domainId ) ; \n \n \t7 } else { \n \n <ect>
\t3 for ( int i = 0 ; i < num ; i ++ ) { \n \n \t4 rev = context . newRevision ( ) ; \n \n \t4 revs . add ( rev ) ; } \n \n \t3 commits . put ( rev , new Entry ( rev ) ) ; } \n \n <ect>
\t2 if ( filePath . exists ( ) && ( filePath . isDirectory ( ) || ! filePath . canRead ( ) || ! filePath . canWrite ( ) ) ) { \n \n \t3 LOGGER . warn ( <string_literal> , filePath . getCanonicalPath ( ) ) ; \n \n \t3 return ; } \n \n \t2 final Map < String , ConfigurationMetadataProperty > results = findProperties ( group ) ; \n \n <ect>
\t5 System . exit ( 1 ) ; \n \n \t4 } else if ( m instanceof GetDataMessage ) { \n \n \t5 for ( InventoryItem item : ( ( GetDataMessage ) m ) . items ) \n \n \t6 if ( item . type == InventoryItem . Type . Block ) { \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void stop ( BundleContext bc ) throws Exception { \n \n \t2 context = null ; \n \n <ect>
\t4 } else if ( ! stop . force ( ) && task . isReplicating ( ) && task . getRebalanceSource ( ) == null ) { \n \n \t5 log . warn ( <string_literal> + task . getName ( ) + <string_literal> ) ; \n \n \t4 } else { \n \n \t5 task . stopWait ( stop . force ( ) ) ; \n \n <ect>
\t1 if ( connectionManager . deleteSnapshot ( sanSnapshotId , iqn , snapshotPointId ) ) { \n \n \t1 deleteEntity = true ; \n \n \t1 } else { \n \n \t1 <comment> \n \n <ect>
\t1 public boolean isLoggedIn ( ) { \n \n \t2 HttpSession session = request . getSession ( false ) ; \n \n \t2 if ( session == null ) return false ; \n \n \t2 if ( session == null ) { \n \n <ect>
\t1 do { \n \n \t2 retry = false ; \n \n \t2 cmd = mLocalCommandFactory . create ( collector , commandText ) ; \n \n \t2 if ( mShutdown ) { \n \n <ect>
\t1 @ After \n \n \t1 public void tearDown ( ) throws Exception { \n \n \t2 LOG . info ( <string_literal> ) ; \n \n \t2 if ( broker != null && broker . isStarted ( ) ) { \n \n <ect>
\t1 } catch ( InvalidObjectException e ) { \n \n \t2 LOG . debug ( ADMIN + <string_literal> , e ) ; \n \n \t1 } catch ( NoSuchObjectException e ) { \n \n \t2 <comment> \n \n <ect>
\t2 String templateUuid ; \n \n \t2 try { \n \n \t3 templateUuid = UUID . nameUUIDFromBytes ( ( templateName + <string_literal> + storeIdentifier + <string_literal> + hyperHost . getMor ( ) . getValue ( ) ) . getBytes ( <string_literal> ) ) . toString ( ) ; \n \n \t2 } catch ( UnsupportedEncodingException e ) { \n \n <ect>
\t2 log . info ( <string_literal> , getConnectionAddress ( ) ) ; \n \n \t2 mllpBuffer . closeSocket ( socket ) ; } \n \n \t1 @ ManagedOperation ( description = <string_literal> ) \n \n \t1 public void resetConnection ( ) { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t2 if ( isRunning ( ) ) { \n \n \t3 LOGGER . info ( <string_literal> ) ; \n \n \t3 stop ( ) ; \n \n \t3 for ( int rep = 1 ; rep < = max ; ++ rep ) { \n \n <ect>
\t2 this . encryptionEnabled = encryptionEnabled ; \n \n \t2 if ( this . encryptionEnabled ) { \n \n \t3 configureEncryptionParameters ( secretKeyEncryption , contentEncryptionAlgorithmIdentifier ) ; \n \n \t2 } else { \n \n <ect>
\t2 { \n \n \t3 smackMultiUserChat . sendConfigurationForm ( smackSubmitForm ) ; } \n \n \t2 catch ( XMPPException e ) \n \n \t2 { \n \n <ect>
<comment> \n \n private def dryRunJobs ( ) { \n \n \t1 if ( settings . startFromScratch ) \n \n <ect>
\t2 ThreadModel threadModel = ThreadModel . ThreadPerConnector ; \n \n \t2 if ( settings . isSetting ( SETTING_THREAD_MODEL ) ) { \n \n \t3 threadModel = ThreadModel . valueOf ( settings . getString ( SETTING_THREAD_MODEL ) ) ; } \n \n \t2 if ( settings . isSetting ( SETTING_USE_JMX ) && settings . getBool ( SETTING_USE_JMX ) ) { \n \n <ect>
\t4 } catch ( Exception e ) { \n \n \t5 if ( null != requiredNodes && requiredNodes . contains ( node . getId ( ) ) ) \n \n \t6 throw new VoldemortException ( <string_literal> + node . getId ( ) , e ) ; \n \n \t5 else \n \n <ect>
\t2 if ( exchangeCharsetName != null && ! exchangeCharsetName . isEmpty ( ) ) { \n \n \t3 try { \n \n \t4 if ( Charset . isSupported ( exchangeCharsetName ) ) { \n \n \t5 return Charset . forName ( exchangeCharsetName ) ; } \n \n <ect>
\t4 { \n \n \t5 contactListDocument = builder . parse ( contactlistFile ) ; } \n \n \t4 catch ( Throwable ex ) \n \n \t4 { \n \n <ect>
\t4 public String toString ( ) { \n \n \t5 return <string_literal> ; } \n \n \t3 } , this , times , maxWriteTime ) ; \n \n \t3 Preconditions . checkState ( success ) ; \n \n <ect>
\t1 private void restoreStack ( ActionInvocation invocation ) { \n \n \t2 RenderRequest request = ( RenderRequest ) invocation . getInvocationContext ( ) . get ( REQUEST ) ; \n \n \t2 if ( StringUtils . isNotEmpty ( request . getParameter ( EVENT_ACTION ) ) ) { \n \n \t3 if ( ! isProperPrg ( invocation ) ) { \n \n <ect>
\t1 private void setTaskNum ( int taskNum , int workerNum ) { \n \n \t2 if ( taskNum >= 0 && workerNum > 0 ) { \n \n \t3 this . avgTaskNum = taskNum / workerNum ; \n \n \t3 this . leftTaskNum = taskNum % workerNum ; \n \n <ect>
\t2 } finally { \n \n \t3 w . close ( ) ; } } \n \n \t1 private Writer writerFor ( File file ) { \n \n \t2 if ( ! file . getParentFile ( ) . exists ( ) && ! file . getParentFile ( ) . mkdirs ( ) ) { \n \n <ect>
\t3 logger . warn ( <string_literal> ) ; } \n \n \t2 <comment> \n \n \t2 if ( ! this . externalAuth && this . datasourceBean == null && this . driverProperties != null ) { \n \n \t3 if ( ( this . driverProperties . get ( USER ) == null ) && this . username == null ) { \n \n <ect>
\t2 for ( Map . Entry < Class < ? > , StateChange > stateChangeEntry : persistentStateChanges . entrySet ( ) ) { \n \n \t3 taskList . add ( stateChangeEntry . getValue ( ) . getDefaultInstance ( ) ) ; } \n \n \t2 long endTimeInNanoSeconds = System . nanoTime ( ) ; \n \n <ect>
\t2 initControllers ( ) ; } \n \n \t1 private void initControllers ( ) { \n \n \t2 checkConfiguration ( ) ; \n \n \t2 if ( controllers . size ( ) == 0 ) { \n \n <ect>
\t2 for ( int i = 1 ; i < = expectedMessagesReceived ; i ++ ) { \n \n \t3 Message message = session . createMessage ( ) ; \n \n \t3 producer . send ( message ) ; \n \n \t3 if ( i % <number_literal> == 0 ) { \n \n <ect>
\t2 return x ; } \n \n \t1 private static String get ( HttpServletResponse response , String name ) { \n \n \t2 Collection < String > en = response . getHeaders ( name ) ; \n \n \t2 if ( en . isEmpty ( ) ) return null ; \n \n <ect>
\t2 numSchedulableTasksPerNode , metrics ) , serviceInstance ) ; } \n \n \t1 @ Override \n \n \t1 public void onUpdate ( LlapServiceInstance serviceInstance , int ephSeqVersion ) { \n \n \t1 <comment> \n \n <ect>
\t1 <comment> \n \n \t1 if ( ! transport . isOpen ( ) ) { \n \n \t2 transport . open ( ) ; } \n \n \t1 if ( protocol . equals ( BINARY_PROTOCOL ) ) { \n \n <ect>
\t1 Topic topic = ( Topic ) ctx . lookup ( topicBindingName ) ; \n \n \t1 TopicSubscriber topicSubscriber = topicSession . createSubscriber ( topic ) ; \n \n \t1 topicSubscriber . setMessageListener ( this ) ; \n \n \t1 } catch ( JMSException e ) { \n \n <ect>
\t6 <comment> \n \n \t5 } else if ( itemType . isAssignableFrom ( StringItem . class ) ) { \n \n \t6 state = new StringType ( sVal ) ; \n \n \t5 } else { \n \n <ect>
\t2 Assert . assertTrue ( buckets [ 1 ] . getPath ( ) . getName ( ) . matches ( <string_literal> ) ) ; \n \n \t2 Assert . assertEquals ( 624L , buckets [ 0 ] . getLen ( ) ) ; \n \n \t2 Assert . assertEquals ( 624L , buckets [ 1 ] . getLen ( ) ) ; \n \n \t1 } else { \n \n <ect>
\t2 scheduler . scheduleJob ( jobDetail , trigger ) ; \n \n \t2 LOG . info ( <string_literal> + jobIdx + <string_literal> + OSG_JOB_GROUP + <string_literal> + jobClassName + <string_literal> \n \n \t3 + schedule + <string_literal> ) ; } \n \n \t1 } catch ( SchedulerException se ) { \n \n <ect>
\t4 Statement s = conn . createStatement ( ) ; \n \n \t4 s . execute ( query ) ; \n \n \t4 s . close ( ) ; \n \n \t3 } catch ( SQLException e ) { \n \n <ect>
\t4 CmsUser user = A_CmsUI . getCmsObject ( ) . readUser ( \n \n \t5 OpenCms . getSessionManager ( ) . getSessionInfo ( new CmsUUID ( id ) ) . getUserId ( ) ) ; \n \n \t4 ret . add ( CmsAccountsApp . getPrincipalInfo ( user ) ) ; } \n \n \t2 } catch ( CmsException e ) { \n \n <ect>
\t3 } else { \n \n \t4 <comment> \n \n \t4 <comment> \n \n \t4 <comment> \n \n <ect>
\t4 arr . put ( tagObj ) ; } \n \n \t3 topObj . put ( JsonKeys . Tags . name ( ) , arr ) ; \n \n \t3 pw . write ( topObj . toString ( <number_literal> ) ) ; \n \n \t2 } catch ( JSONException e ) { \n \n <ect>
\t3 for ( StoragePoolVO pool : hostTagsPools ) { \n \n \t4 if ( pool != null && pool . isLocal ( ) ) { \n \n \t5 StoragePool storagePool = ( StoragePool ) this . dataStoreMgr . getPrimaryDataStore ( pool . getId ( ) ) ; \n \n \t5 if ( filter ( avoid , storagePool , dskCh , plan ) ) { \n \n <ect>
\t1 { \n \n \t2 setWicketTester ( new WicketTester ( new TestWicketJavaEEApplication ( ) ) ) ; \n \n \t2 assertNotNull ( getWicketTester ( ) . getApplication ( ) ) ; \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t2 String createSql = ( <string_literal> + viewName + <string_literal> + tableName ) ; \n \n \t2 return new String [ ] { dropView , dropTable , createSql } ; } \n \n \t1 private void executeSQL ( String sql ) throws SQLException { \n \n \t2 Connection con = SqlUtil . getConnection ( dbconf ) ; \n \n <ect>
\t3 final Update update = Update . update ( TicketHolder . FIELD_NAME_JSON , holder . getJson ( ) ) ; \n \n \t3 this . mongoTemplate . upsert ( query , update , collectionName ) ; \n \n \t3 LOGGER . debug ( <string_literal> , ticket ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t4 this . setResponseObject ( response ) ; \n \n \t3 } else { \n \n \t4 throw new ServerApiException ( BaseCmd . INTERNAL_ERROR , <string_literal> ) ; } \n \n \t2 } catch ( ResourceUnavailableException ex ) { \n \n <ect>
\t2 return ; \n \n \t2 } finally { \n \n \t2 xc . close ( ) ; } \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t4 return ; \n \n \t3 EnterFiniteCooldownEvent event = ( EnterFiniteCooldownEvent ) ce ; \n \n \t3 progress = new EnterFiniteCooldown ( identifier , global , event . wakeupTime ) ; \n \n \t2 } else { \n \n <ect>
\t5 converted . add ( value ) ; } \n \n \t4 return converted ; } \n \n \t3 if ( TabularData . class . isAssignableFrom ( input . getClass ( ) . getComponentType ( ) ) ) { \n \n \t4 <comment> \n \n <ect>
\t3 flushDefault = true ; } \n \n \t2 } catch ( KeeperException . NoNodeException ex ) { \n \n \t2 <comment> \n \n \t2 for ( String id : zoo . getChildren ( zooRoot + Constants . ZTABLES ) ) { \n \n <ect>
\t7 ctx . onDeferredDelete ( entry , updRes . removeVersion ( ) ) ; \n \n \t6 break ; } \n \n \t5 catch ( GridCacheEntryRemovedException ignored ) { \n \n <ect>
\t2 { \n \n \t3 endLockSessionOnMaster ( false ) ; } \n \n \t2 catch ( Throwable t ) \n \n \t2 { \n \n <ect>
\t5 LOG . error ( <string_literal> + Integer . toString ( lastSeq + 1 ) + <string_literal> + Integer . toString ( seq ) ) ; \n \n \t5 testError = true ; } \n \n \t4 lastSeq = seq ; \n \n \t4 if ( msgCount > expectedCount ) { \n \n <ect>
\t3 SootMethod currentCaller = e . src ( ) ; \n \n \t3 <comment> \n \n \t3 if ( ! rm . contains ( currentCaller ) ) \n \n \t3 { \n \n <ect>
\t4 <comment> \n \n \t4 if ( msg . msgType == MaxCulMsgType . ACK ) { \n \n \t5 AckMsg ack = new AckMsg ( msg . rawMsg ) ; \n \n \t5 if ( ack . getIsNack ( ) ) { \n \n <ect>
\t5 } else if ( root . equals ( Cluster . BLOBSTORE_ROOT ) ) { \n \n \t6 fn = blobstore_callback . getAndSet ( null ) ; \n \n \t5 } else if ( root . equals ( Cluster . GRAY_UPGRADE_ROOT ) ) { \n \n \t6 fn = gray_upgrade_callback . getAndSet ( null ) ; \n \n <ect>
\t3 if ( writeTx != null && writeTx . isOpen ( ) ) \n \n \t4 writeTx . commit ( ) ; \n \n \t3 metrics . incrementCustom ( SUCCESS_TX ) ; \n \n \t2 } catch ( RuntimeException e ) { \n \n <ect>
\t3 ex . addProxyObject ( project , projectId , <string_literal> ) ; \n \n \t3 throw ex ; } \n \n \t2 _accountMgr . checkAccess ( caller , AccessType . ModifyProject , true , _accountMgr . getAccount ( project . getProjectAccountId ( ) ) ) ; \n \n \t2 if ( suspendProject ( project ) ) { \n \n <ect>
\t5 ipv6 = true ; \n \n \t4 } else { \n \n \t5 ipv4 = true ; } \n \n \t3 } catch ( UnknownHostException e ) { \n \n <ect>
\t3 { \n \n \t4 socket . setSendBufferSize ( this . sendBufferSize . intValue ( ) ) ; } \n \n \t3 catch ( SocketException se ) \n \n \t3 { \n \n <ect>
\t5 public void handleException ( TransportException exp ) { \n \n \t6 logger . warn ( ( ) - > new ParameterizedMessage ( <string_literal> , otherMaster ) , exp ) ; } \n \n \t4 } ) ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 LOG . debug ( <string_literal> ) ; } \n \n \t3 return ; } \n \n <ect>
\t8 l . add ( new Pair < String , Object > ( paramName , fieldValue . toString ( ) ) ) ; } } \n \n \t6 <comment> \n \n \t6 <comment> \n \n \t5 } catch ( IllegalArgumentException e ) { \n \n <ect>
\t3 Stat stat = new Stat ( ) ; \n \n \t3 <comment> \n \n \t3 zk . create ( <string_literal> , <string_literal> . getBytes ( ) , Ids . OPEN_ACL_UNSAFE , \n \n \t5 CreateMode . PERSISTENT ) ; \n \n <ect>
\t3 } catch ( IOException e ) { \n \n \t4 if ( firstAddr == null ) { \n \n \t5 LOG . error ( <string_literal> , first , e ) ; \n \n \t4 } else { \n \n <ect>
\t6 decrementContainersInProgress ( t ) ; } } \n \n \t4 remainingWorkload -= t . getNumExecutors ( ) ; } \n \n \t3 return r ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 throw new IllegalArgumentException ( <string_literal> + startup . getPrivateIpAddress ( ) + <string_literal> + dataCenter ) ; } \n \n \t2 dcId = dc . getId ( ) ; \n \n \t2 final HypervisorType hypervisorType = startup . getHypervisorType ( ) ; \n \n <ect>
\t1 } else { \n \n \t1 partitionValues = null ; } \n \n \t1 String txnString = conf . get ( ValidWriteIdList . VALID_WRITEIDS_KEY ) ; \n \n \t1 this . validWriteIdList = ( txnString == null ) ? new ValidReaderWriteIdList ( ) : new ValidReaderWriteIdList ( txnString ) ; \n \n <ect>
\t5 jettyServerConfig . port = Integer . parseInt ( portStr ) ; \n \n \t4 } catch ( NumberFormatException ex ) { \n \n \t5 throw new CmdException ( argPort . getKeyName ( ) + <string_literal> + portStr ) ; } } \n \n \t3 if ( contains ( argMgt ) ) \n \n <ect>
\t1 private void fillInputStreamCache ( ) throws InterruptedException { \n \n \t2 try { \n \n \t3 while ( wrapperList . size ( ) < maxCacheSize && queuedSourceInitTasks . get ( ) < maxCacheSize && ! finished ) { \n \n \t4 if ( exiting ) { \n \n <ect>
\t3 <comment> \n \n \t3 <comment> \n \n \t3 <comment> \n \n \t3 if ( ! vmMo . consolidateVmDisks ( ) ) { \n \n <ect>
<comment> \n \n \t2 public void writePropertyListToStream ( Object plist , OutputStream out ) { \n \n \t3 if ( plist == null || out == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 ClusterHealthResponse clusterHealth = \n \n \t3 client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForGreenStatus ( ) . waitForNodes ( <string_literal> ) ) . actionGet ( ) ; \n \n <ect>
\t3 s_logger . info ( <string_literal> ) ; } } \n \n \t1 @ Override \n \n \t1 public void scheduleParse ( ) { \n \n <ect>
\t3 message . setMessageAnnotation ( <string_literal> , i ) ; \n \n \t3 message . setText ( <string_literal> ) ; \n \n \t3 sender . send ( message ) ; } \n \n \t2 sender . close ( ) ; \n \n <ect>
<comment> \n \n \t1 public void destroy ( @ SuppressWarnings ( <string_literal> ) T instance , \n \n \t3 @ SuppressWarnings ( <string_literal> ) CreationalContext < T > creationalContext ) { \n \n <ect>
\t2 ConcurrentOperationException , InsufficientNetworkCapacityException { \n \n \t2 DataCenter zone = _entityMgr . findById ( DataCenter . class , network . getDataCenterId ( ) ) ; \n \n \t2 <comment> \n \n \t2 if ( zone . getNetworkType ( ) == NetworkType . Basic ) { \n \n <ect>
<comment> \n \n \t1 public WsFederationCredential createCredentialFromToken ( final Assertion assertion ) { \n \n \t2 final ZonedDateTime retrievedOn = ZonedDateTime . now ( ) ; \n \n <ect>
\t2 try { \n \n \t3 LoadBalancer result = _lbService . createLoadBalancerRule ( this , getOpenFirewall ( ) ) ; \n \n \t3 this . setEntityId ( result . getId ( ) ) ; \n \n \t2 } catch ( NetworkRuleConflictException e ) { \n \n <ect>
\t2 ensureGreen ( ) ; \n \n \t2 logger . info ( <string_literal> ) ; \n \n \t2 assertAcked ( admin ( ) . indices ( ) . prepareAliases ( ) \n \n \t4 . addAliasAction ( AliasActions . add ( ) . index ( <string_literal> ) . alias ( <string_literal> ) . routing ( <string_literal> ) ) ) ; \n \n <ect>
\t2 } catch ( final NoTransitionException e ) { \n \n \t3 s_logger . error ( e . getMessage ( ) ) ; \n \n \t3 return null ; \n \n \t2 } catch ( final CloudRuntimeException e ) { \n \n <ect>
\t5 returnCallback = ( message , replyCode1 , replyText1 , exchange1 , routingKey1 ) - > \n \n \t7 pendingReply . returned ( new AmqpMessageReturnedException ( <string_literal> , \n \n \t9 message , replyCode1 , replyText1 , exchange1 , routingKey1 ) ) ; } \n \n <ect>
\t2 initQueries . pollFirst ( ) ; } \n \n \t1 return true ; \n \n \t1 } catch ( Exception ex ) { \n \n \t1 doCommit = false ; \n \n <ect>
\t3 <comment> \n \n \t3 setParentFolder ( newFolder ) ; \n \n \t3 tx . success ( ) ; \n \n \t2 } catch ( FrameworkException fex ) { \n \n <ect>
\t3 updateCachedBannerMapper . execute ( new UpdateCachedBannerMapperRequest ( null , entityId ) ) ; \n \n \t3 return bannerObject ; } \n \n \t2 catch ( Exception ex ) \n \n \t2 { \n \n <ect>
\t3 public String apply ( Instance arg0 ) { \n \n \t3 return arg0 . getInstanceId ( ) ; } \n \n \t2 } ) ) ; \n \n \t1 } catch ( final Exception ex ) { \n \n <ect>
\t2 <comment> \n \n \t2 sendMessages ( queue ) ; \n \n \t2 LOG . info ( <string_literal> , getNumberOfJournalFiles ( ) ) ; \n \n \t2 assertTrue ( getNumberOfJournalFiles ( ) > 1 ) ; \n \n <ect>
\t2 if ( points != null ) { \n \n \t3 points . stream ( ) . map ( DistributionPoint : : getDistributionPoint ) . filter ( Objects : : nonNull ) . forEach ( pointName - > { \n \n \t4 final ASN1Sequence nameSequence = ASN1Sequence . getInstance ( pointName . getName ( ) ) ; \n \n \t4 IntStream . range ( 0 , nameSequence . size ( ) ) . mapToObj ( i - > GeneralName . getInstance ( nameSequence . getObjectAt ( i ) ) ) . forEach ( name - > { \n \n <ect>
\t2 final Pattern pattern = RegexUtils . createPattern ( this . entityIds ) ; \n \n \t2 final Matcher matcher = pattern . matcher ( entityDescriptor . getEntityID ( ) ) ; \n \n \t2 LOGGER . debug ( <string_literal> , pattern . pattern ( ) , entityDescriptor . getEntityID ( ) ) ; \n \n \t2 final boolean matched = fullMatch ? matcher . matches ( ) : matcher . find ( ) ; \n \n <ect>
\t1 upload_block ( solr_kinit_command , hdfs_kinit_command , curl_prefix , solr_url , collection , filter_field , id_field , \n \n \t4 working_dir , tmp_file_path , name , prev_lot_end_value , prev_lot_end_id , hdfs_user , hdfs_path , \n \n \t4 key_file_path , bucket , key_prefix , local_path , compression ) \n \n \t1 total_records += records \n \n <ect>
\t1 public String decryptValue ( final String value ) { \n \n \t2 try { \n \n \t3 return decryptValuePropagateExceptions ( value ) ; \n \n \t2 } catch ( final Exception e ) { \n \n <ect>
\t2 samlResponse . setID ( id ) ; \n \n \t2 samlResponse . setIssueInstant ( DateTimeUtils . dateTimeOf ( issueInstant ) ) ; \n \n \t2 samlResponse . setVersion ( SAMLVersion . VERSION_20 ) ; \n \n \t2 if ( StringUtils . isNotBlank ( recipient ) ) { \n \n <ect>
\t4 assert ( zone != null ) : <string_literal> ; \n \n \t4 Boolean useLocalStorageForSystemVM = ConfigurationManagerImpl . SystemVMUseLocalStorage . valueIn ( zone . getId ( ) ) ; \n \n \t4 if ( useLocalStorageForSystemVM != null ) { \n \n \t5 useLocalStorage = useLocalStorageForSystemVM . booleanValue ( ) ; \n \n <ect>
\t5 responseDate , \n \n \t5 new FutureCallback < HttpCacheEntry > ( ) { \n \n \t6 @ Override \n \n \t6 public void completed ( final HttpCacheEntry newEntry ) { \n \n <ect>
\t2 templateNames . add ( getTemplate1Response . getIndexTemplates ( ) . get ( 0 ) . name ( ) ) ; \n \n \t2 templateNames . add ( getTemplate1Response . getIndexTemplates ( ) . get ( 1 ) . name ( ) ) ; \n \n \t2 templateNames . add ( getTemplate1Response . getIndexTemplates ( ) . get ( <number_literal> ) . name ( ) ) ; \n \n \t2 assertThat ( templateNames , containsInAnyOrder ( <string_literal> , <string_literal> , <string_literal> ) ) ; \n \n <ect>
\t2 LOG . debug ( <string_literal> ) ; \n \n \t2 dbConn . rollback ( ) ; \n \n \t2 return rc ; \n \n \t1 } catch ( SQLException e ) { \n \n <ect>
\t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n \t5 _log . info ( <string_literal> + ff + <string_literal> + non + <string_literal> ) ; } \n \n \t3 if ( _routers . isEmpty ( ) ) { \n \n \t4 if ( _log . shouldLog ( Log . INFO ) ) \n \n <ect>
\t2 return true ; } \n \n \t1 protected class CleanupTask implements Runnable { \n \n \t2 @ Override \n \n \t2 public void run ( ) { \n \n <ect>
\t2 try { \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 statement = cubeConnection . createStatement ( ) ; \n \n \t3 resultSet = statement . executeQuery ( sql ) ; \n \n <ect>
\t2 if ( comparator . compare ( value , entry ) >= 0 ) { \n \n \t2 return BLOCK_MIGHT_MATCH ; } } \n \n \t1 return BLOCK_CANNOT_MATCH ; \n \n \t1 } catch ( IOException e ) { \n \n <ect>
\t1 public MondrianServer . MondrianVersion getVersion ( ) { \n \n \t3 logger . debug ( <string_literal> + MondrianServerVersion . VENDOR ) ; \n \n \t3 final String title = MondrianServerVersion . NAME ; \n \n <ect>
\t1 c3p0 . setPassword ( poolConfig . password ( ) ) ; } \n \n public static boolean forceC3P0 ( ) { \n \n \t1 return Boolean . parseBoolean ( System . getProperty ( FORCE_C3P0 ) ) ; } \n \n private void logWarnMessages ( PooledConnectionFactoryConfiguration poolConfig ) { \n \n <ect>
\t1 } catch ( InterruptedException e ) { \n \n \t2 <comment> \n \n \t2 <comment> \n \n \t1 OperationStatus opStatus = operation . getStatus ( ) ; \n \n <ect>
public < O extends S3Exception , T extends WalrusException > O proxyWalrusException ( T initialException ) throws EucalyptusCloudException { \n \n \t1 try { \n \n \t1 Class c = exceptionMap . get ( initialException . getClass ( ) ) ; \n \n \t1 if ( c == null ) { \n \n <ect>
\t3 s_logger . info ( description ) ; } } \n \n \t1 @ Override \n \n \t1 public void handleTemplateSync ( HostVO ssHost ) { \n \n \t2 if ( ssHost == null ) { \n \n <ect>
\t2 long gslbRuleId = deleteGslbCmd . getGlobalLoadBalancerId ( ) ; \n \n \t2 try { \n \n \t3 revokeGslbRule ( gslbRuleId , caller ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t2 ( ( MuleXaObject ) xaObject ) . delist ( ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 Logger logger = loggerContext . getLogger ( <string_literal> ) ; \n \n \t2 logger . addAppender ( smtpAppender ) ; \n \n \t2 for ( int i = 0 ; i < CoreConstants . TABLE_ROW_LIMIT * <number_literal> ; i ++ ) { \n \n \t3 logger . debug ( <string_literal> + i ) ; } \n \n <ect>
\t3 Map < OvmResourceBase , Map < String , String > > resources = new HashMap < OvmResourceBase , Map < String , String > > ( ) ; \n \n \t3 resources . put ( ovmResource , details ) ; \n \n \t3 return resources ; \n \n \t2 } catch ( XmlRpcException e ) { \n \n <ect>
\t2 } catch ( final LibvirtException e ) { \n \n \t3 s_logger . error ( <string_literal> , e ) ; \n \n \t3 return new ExecutionResult ( false , e . getMessage ( ) ) ; \n \n \t2 } catch ( final InternalErrorException e ) { \n \n <ect>
\t5 zk . create ( <string_literal> , new byte [ 0 ] , Ids . OPEN_ACL_UNSAFE , \n \n \t7 CreateMode . PERSISTENT_SEQUENTIAL , this , null ) ; } \n \n \t3 } catch ( InterruptedException e ) { \n \n \t4 if ( bang ) { \n \n <ect>
\t3 if ( bug . state ( ) . equals ( State . CLOSED ) ) { \n \n \t4 result = choiceByRemovingKeys ( new NSArray ( new Object [ ] { <string_literal> } ) , result ) ; } \n \n \t3 if ( ! bug . state ( ) . equals ( State . VERIFY ) ) { \n \n \t4 result = choiceByRemovingKeys ( new NSArray ( <string_literal> ) , result ) ; } \n \n <ect>
\t3 result . nssi = ( NoSuchScanIDException ) e ; \n \n \t3 result . setNssiIsSet ( true ) ; \n \n \t3 msg = result ; \n \n \t3 } else if ( e instanceof org . apache . thrift . transport . TTransportException ) { \n \n <ect>
\t2 logger . debug ( <string_literal> ) ; \n \n \t2 for ( Iterator < ProjectSegment > it = projectBuilds . iterator ( ) ; it . hasNext ( ) ; ) \n \n \t2 { \n \n \t3 ProjectSegment projectBuild = it . next ( ) ; \n \n <ect>
\t4 rootLogger . setLevel ( logLevels [ cb . getSelectedIndex ( ) ] ) ; \n \n \t4 Level newLevel = rootLogger . getLevel ( ) ; \n \n \t4 if ( newLevel . toInt ( ) > Level . INFO_INT ) { \n \n \t5 rootLogger . setLevel ( Level . INFO ) ; } \n \n <ect>
\t4 logOverWS = false ; } \n \n \t3 else { \n \n \t4 String pattern = conf . get ( <string_literal> ) ; \n \n \t4 if ( pattern == null ) { \n \n <ect>
\t4 String id = LinkIdFactory . getLinkId ( Uris . DEFAULT_LINK_URI , source . getId ( ) , target . getId ( ) ) ; \t5 \n \n \t4 l = new CompactObjectPropertyLink ( id , ObjectPropertyType . None ) ; } \n \n \t3 else l = this . getIdToLinkMap ( ) . get ( f . label ( ) . name ) ; \n \n \t3 if ( l == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 for ( int i = 0 ; i < URLs . size ( ) ; i ++ ) { \n \n \t3 String url = URLs . get ( i ) ; \n \n \t3 if ( url . startsWith ( <string_literal> + hostname + <string_literal> ) ) { \n \n <ect>
\t3 } finally { \n \n \t4 try { \n \n \t5 is . close ( ) ; \n \n \t4 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n public String downloadConfiguration ( ) throws Exception { \n \n \t1 String configDir = new DownloadConfigZkCommand ( getRetryTimes ( ) , getInterval ( ) ) . run ( this ) ; \n \n <ect>
\t3 Flog . info ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 String newRelativePath = context . toProjectRelPath ( newPath ) ; \n \n \t2 if ( newRelativePath == null ) { \n \n <ect>
\t2 Type type = getSnapshotType ( intvType ) ; \n \n \t2 TimeZone timeZone = TimeZone . getTimeZone ( cmd . getTimezone ( ) ) ; \n \n \t2 String timezoneId = timeZone . getID ( ) ; \n \n \t2 if ( ! timezoneId . equals ( cmd . getTimezone ( ) ) ) { \n \n <ect>
\t2 boolean shouldRoll = false ; \n \n \t2 int subtaskIndex = getRuntimeContext ( ) . getIndexOfThisSubtask ( ) ; \n \n \t2 if ( ! isWriterOpen ) { \n \n \t3 shouldRoll = true ; \n \n <ect>
\t2 for ( Class < ? > clazz : models ) { \n \n \t3 if ( model . containsKey ( clazz . getName ( ) ) ) { \n \n \t4 Object obj = model . get ( clazz . getName ( ) ) ; \n \n <ect>
\t1 public static ISchematicBlock getSchematicSafe ( @ Nonnull ItemStack stack ) { \n \n \t2 try { \n \n \t3 return getSchematic ( stack ) ; \n \n \t2 } catch ( InvalidInputDataException e ) { \n \n <ect>
\t2 assertThat ( clusterState . metaData ( ) . index ( <string_literal> ) . primaryTerm ( 0 ) , equalTo ( 2L ) ) ; \n \n \t2 assertThat ( routingTable . index ( <string_literal> ) . shard ( 0 ) . replicaShards ( ) . get ( 0 ) . currentNodeId ( ) , equalTo ( <string_literal> ) ) ; } \n \n \t1 public void testRemovingInitializingReplicasIfPrimariesFails ( ) { \n \n \t2 AllocationService allocation = createAllocationService ( Settings . builder ( ) . put ( <string_literal> , <number_literal> ) . build ( ) ) ; \n \n <ect>
\t3 try { \n \n \t4 int pos = buf . bytesBefore ( ( byte ) config . getStartByte ( ) ) ; \n \n \t4 if ( pos >= 0 ) { \n \n \t5 ByteBuf msg = buf . readerIndex ( pos + 1 ) . slice ( ) ; \n \n <ect>
\t3 Thread . sleep ( Long . MAX_VALUE ) ; \n \n \t2 } catch ( InterruptedException e ) { \n \n \t3 logger . warn ( <string_literal> , e ) ; } } \n \n \t1 private String sendMessage ( String data , int timeout ) throws IOException { \n \n <ect>
\t3 try { \n \n \t3 fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; \n \n \t3 return ; \n \n \t3 } catch ( Exception e ) { \n \n <ect>
\t4 break ; } \n \n \t3 <comment> \n \n \t3 if ( jobId == null ) { \n \n \t4 Thread . sleep ( 100L ) ; } } \n \n <ect>
\t5 classes . clear ( ) ; \n \n \t5 <comment> \n \n \t5 for ( final Class newType : newClasses ) { \n \n \t6 classes . put ( newType . getName ( ) , newType ) ; } \n \n <ect>
\t1 @ Path ( <string_literal> ) \n \n \t1 @ Produces ( MediaType . TEXT_PLAIN ) \n \n \t1 public Response test ( ) { \n \n \t2 log . info ( <string_literal> ) ; \n \n <ect>
\t3 ( <string_literal> ) ; \n \n \t2 Object startupInstance = startupClass . newInstance ( ) ; \n \n \t2 <comment> \n \n <ect>
\t4 } else { \n \n \t5 expression . push ( Expression . FALSE ) ; \n \n \t5 return ; } \n \n \t3 } else { \n \n <ect>
\t2 if ( socket == null ) return ; \n \n \t2 try { \n \n \t3 drainSocket ( ) ; \n \n \t2 } catch ( Exception x ) { \n \n <ect>
\t3 Location recoveryPosition = requiresJournalReplay ? journal . getNextLocation ( null ) : lastIndoubtPosition ; \n \n \t3 if ( recoveryPosition != null ) { \n \n \t4 int redoCounter = 0 ; \n \n \t4 int dataFileRotationTracker = recoveryPosition . getDataFileId ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void samlIDPHandlingSAML11Error ( Throwable t ) { \n \n <ect>
\t3 log . warn ( LogManager . getHeader ( context , <string_literal> , <string_literal> ) , e ) ; } } \n \n \t1 @ Override \n \n \t1 public void emailErrorMessage ( EPerson eperson , String error ) \n \n \t2 throws MessagingException { \n \n <ect>
\t2 <comment> \n \n \t2 if ( installManager || installServices ) { \n \n \t3 <comment> \n \n \t3 if ( serverConfig . pagesPort != serverConfig . port ) \n \n <ect>
\t2 TopicSubscriber durableSubscriber = topicSession . createDurableSubscriber ( topic , durableSubName ) ; \n \n \t2 connection . start ( ) ; \n \n \t2 durableSubscriber . close ( ) ; \n \n \t2 connection . close ( ) ; \n \n <ect>
\t3 log . trace ( \n \n \t4 String . format ( <string_literal> , \n \n \t5 keys . firstKey ( ) ) ) ; \n \n \t3 return new SplitRowSpec ( keys . firstKey ( ) , candidate . getRow ( ) ) ; } } \n \n <ect>
\t3 List < String > names = new ArrayList < String > ( ) ; \n \n \t3 for ( String filename : xmlFiles ) { \n \n \t4 names . add ( ( new File ( filename ) ) . getName ( ) . replace ( <string_literal> , <string_literal> ) ) ; } \n \n \t3 pluginNames = names . toArray ( new String [ names . size ( ) ] ) ; \n \n <ect>
\t3 deliveryCount = delvery ; } \n \n \t2 public void onMessage ( Message message ) { \n \n \t3 try { \n \n \t4 int expectedMessageId = rollbacks . get ( ) / deliveryCount ; \n \n <ect>
\t2 { \n \n \t2 observer . onDone ( ) ; } \n \n \t2 catch ( Throwable ex ) \n \n \t2 { \n \n <ect>
\t5 <string_literal> ) ; } \n \n \t2 <comment> \n \n \t2 if ( this . transactionManager != null ) { \n \n <ect>
\t8 proc . stop ( ) ; \n \n \t8 stopped = address . getPort ( ) ; \n \n \t8 break ; \n \n \t7 } catch ( Exception e ) { \n \n <ect>
\t1 eventIdModifier . assertInjectionsPerformed ( true , false ) ; \n \n \t1 InjectableBehaviourObjectStore . resetGetNextNotificationBehaviour ( ) ; <comment> \n \n \t1 String incrementalDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String incrementalDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t3 if ( classProp != null ) { \n \n \t4 clazz = ( Class ) classProp [ 0 ] ; \n \n \t4 property = ( String ) classProp [ 1 ] ; } \n \n \t3 tc = ( TypeConverter ) getConverter ( clazz , property ) ; \n \n <ect>
\t3 return ; } \n \n \t2 if ( isInteractive ( ) ) { \n \n \t3 <comment> \n \n \t3 if ( user == null ) { \n \n <ect>
\t1 LoadBalancerClientCli . runDiscovery ( _zkHosts , <string_literal> , _d2ConfigFileName ) ; \n \n \t1 validate ( LoadBalancerClientCli . printStores ( _cli . getZKClient ( ) , <string_literal> + _zkHosts , <string_literal> ) ) ; } \n \n private void validate ( String stores ) \n \n { \n \n <ect>
\t3 URI location = AdminRoot . realmsUrl ( uriInfo ) . path ( realm . getName ( ) ) . build ( ) ; \n \n \t3 logger . debugv ( <string_literal> , location . toString ( ) ) ; \n \n \t3 return Response . created ( location ) . build ( ) ; \n \n \t2 } catch ( ModelDuplicateException e ) { \n \n <ect>
\t3 throw e ; } \n \n \t3 break ; \n \n \t2 default : \n \n \t3 throw e ; } } \n \n <ect>
\t2 < N , V > StateTable < K , N , V > newStateTable ( RegisteredKeyedBackendStateMetaInfo < N , V > newMetaInfo ) ; } \n \n \t1 private class AsyncSnapshotStrategySynchronicityBehavior implements SnapshotStrategySynchronicityBehavior < K > { \n \n \t2 @ Override \n \n \t2 public void logOperationCompleted ( CheckpointStreamFactory streamFactory , long startTime ) { \n \n <ect>
\t2 LOG . info ( <string_literal> + baseDestinationB . getSystemUsage ( ) . getStoreUsage ( ) . getUsage ( ) + <string_literal> + baseDestinationB . getSystemUsage ( ) . getStoreUsage ( ) . getPercentUsage ( ) ) ; \n \n \t2 LOG . info ( <string_literal> + broker . getSystemUsage ( ) . getStoreUsage ( ) . getUsage ( ) + <string_literal> + broker . getSystemUsage ( ) . getStoreUsage ( ) . getPercentUsage ( ) ) ; \n \n \t2 consume ( queueA ) ; \n \n \t2 consume ( queueB ) ; \n \n <ect>
\t2 LOG . warn ( <string_literal> , t ) ; } \n \n \t1 session = null ; \n \n \t1 throw new HiveSQLException ( <string_literal> + e . getMessage ( ) , e ) ; } \n \n \t1 handleToSession . put ( session . getSessionHandle ( ) , session ) ; \n \n <ect>
\t3 if ( 0 == entryNesting ) inStatement = false ; \n \n \t3 return true ; } \n \n \t2 public boolean endObjectEntry ( ) throws ParseException , PermissionDeniedException \n \n \t2 { \n \n <ect>
<comment> \n \n \t1 public void addPolicy ( final String name , final ExpirationPolicy policy ) { \n \n <ect>
\t1 log . info ( <string_literal> ) ; \n \n \t1 t . start ( ) ; \n \n \t1 <comment> \n \n \t1 keyManager . latch . await ( ) ; \n \n <ect>
\t3 if ( ! cpFile . isFile ( ) && ! cpFile . isDirectory ( ) ) { \n \n \t4 return ; } \n \n \t3 File targetFile = new File ( tempFileName ) ; \n \n \t3 if ( ! targetFile . createNewFile ( ) ) { \n \n <ect>
\t1 String oldVar = currentMetaVarsCopy . get ( oneVar . getVarname ( ) ) ; \n \n \t1 String newVar = MetastoreConf . getAsString ( conf , oneVar ) ; \n \n \t1 if ( oldVar == null || \n \n \t2 ( oneVar . isCaseSensitive ( ) ? ! oldVar . equals ( newVar ) : ! oldVar . equalsIgnoreCase ( newVar ) ) ) { \n \n <ect>
\t4 throw new ResourceUnavailableException ( <string_literal> + router . getDataCenterIdToDeployIn ( ) + <string_literal> + vpn . getAccountId ( ) + <string_literal> \n \n \t6 + router . getInstanceName ( ) + <string_literal> + answer . getDetails ( ) , DataCenter . class , router . getDataCenterIdToDeployIn ( ) ) ; } \n \n \t3 answer = cmds . getAnswer ( <string_literal> ) ; \n \n \t3 if ( ! answer . getResult ( ) ) { \n \n <ect>
\t1 protected Settings nodeSettings ( int nodeOrdinal ) { \n \n \t2 return Settings . builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) \n \n \t3 . put ( TestZenDiscovery . USE_MOCK_PINGS . getKey ( ) , false ) . build ( ) ; } \n \n \t1 private void createStaleReplicaScenario ( ) throws Exception { \n \n <ect>
\t2 Configuration runConf = null ; \n \n \t2 try { \n \n \t3 runConf = new XConfiguration ( new StringReader ( createdConf ) ) ; } \n \n \t2 catch ( IOException e1 ) { \n \n <ect>
\t1 PersistenceContexts . deregisterPersistenceContext ( context_name ) ; \n \n } catch ( final Exception ex ) { \n \n \t1 LOG . error ( <string_literal> + context_name , ex ) ; \n \n \t1 throw new EucalyptusCloudException ( <string_literal> + context_name , ex ) ; } \n \n <ect>
\t1 <comment> \n \n \t1 if ( process . outputService . waitForFinish ( ) ) \n \n \t2 throw new IOException ( <string_literal> + process . outputService . error ( ) ) ; \n \n \t1 } catch ( Throwable t ) { \t5 <comment> \n \n <ect>
\t3 fs . setOwner ( new Path ( dirPath ) , username , username ) ; } \n \n \t2 return b ; } \n \n \t1 } ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t2 CmsObject cmsExportObject = OpenCms . initCmsObject ( OpenCms . getDefaultUsers ( ) . getUserExport ( ) ) ; \n \n \t2 List < CmsPublishedResource > resourcesToExport = getRelatedResources ( cmsExportObject , resources ) ; \n \n \t2 <comment> \n \n \t2 templatesFound = exportNonTemplateResources ( cmsExportObject , resourcesToExport , report ) ; \n \n <ect>
\t4 s_logger . info ( <string_literal> + quotaAccount . getId ( ) + <string_literal> + getDifferenceDays ( lastStatementDate , new Date ( ) ) \n \n \t6 + <string_literal> ) ; } } \n \n \t2 for ( DeferredQuotaEmail emailToBeSent : deferredQuotaEmailList ) { \n \n <ect>
\t4 String messageId = jmsMessage . getJMSMessageID ( ) ; \n \n \t4 if ( messageId != null ) { \n \n \t5 headers . put ( JmsHeaders . MESSAGE_ID , messageId ) ; } } \n \n \t3 catch ( Exception e ) { \n \n <ect>
\t3 logger . debug ( <string_literal> + SERVLET_NAME ) ; \n \n \t3 Hashtable < String , String > props = new Hashtable < String , String > ( ) ; \n \n \t3 httpService . registerServlet ( SERVLET_NAME , this , props , createHttpContext ( ) ) ; \n \n \t2 } catch ( NamespaceException e ) { \n \n <ect>
\t3 return false ; } \n \n \t2 catch ( InvalidArgumentException ex ) \n \n \t2 { \n \n \t3 <comment> \n \n <ect>
\t2 { \n \n \t3 this . lastGridStorage = Long . parseLong ( lastString ) ; } \n \n \t2 catch ( final NumberFormatException err ) \n \n \t2 { \n \n <ect>
\t2 if ( clusterIdStorage . exists ( ) ) \n \n \t2 { \n \n \t3 clusterId = clusterIdStorage . readState ( ) ; \n \n \t3 publishClusterId ( clusterId ) ; \n \n <ect>
\t2 <comment> \n \n \t2 if ( ! spillWriter . registerAllRequestsProcessedListener ( this ) ) { \n \n \t3 isSpillInProgress = false ; \n \n \t3 availabilityListener . notifyDataAvailable ( ) ; \n \n <ect>
\t1 try { \n \n \t1 super . applyLifecycle ( o ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 String [ ] sCiphers = context . getSocketFactory ( ) . getSupportedCipherSuites ( ) ; \n \n \t3 int len = ( dCiphers . length > sCiphers . length ) ? dCiphers . length : sCiphers . length ; \n \n \t3 for ( int i = 0 ; i < len ; i ++ ) { \n \n \t4 if ( i < dCiphers . length ) { \n \n <ect>
\t2 System . nanoTime ( ) - startNanos , TimeUnit . NANOSECONDS ) ; \n \n \t1 long elapsedSeconds = elapsedMillis / 1000L ; \n \n \t1 logger . info ( <string_literal> , elapsedMillis ) ; \n \n \t1 logger . info ( <string_literal> , hdfsWriter . getEventsWritten ( ) ) ; \n \n <ect>
\t3 SystemKeyspace . setViewBuiltReplicated ( ksName , view . name ) ; } \n \n \t2 catch ( Exception e ) \n \n \t2 { \n \n \t3 ScheduledExecutors . nonPeriodicTasks . schedule ( this : : updateDistributed , <number_literal> , TimeUnit . MINUTES ) ; \n \n <ect>
\t3 if ( _sentNotReceived . isEmpty ( ) ) { \n \n \t4 _log . info ( <string_literal> ) ; \n \n \t4 System . exit ( 0 ) ; \n \n \t3 } else { \n \n <ect>
\t2 try { \n \n \t3 this . lastSeenTxn = getTxnRecord ( indexFilePath ) ; \n \n \t3 LOG . debug ( <string_literal> , this . lastSeenTxn ) ; \n \n \t2 } catch ( IOException e ) { \n \n <ect>
\t3 FormatInfo info = null ; \n \n \t3 try { \n \n \t4 info = processor . process ( resourcePath , null , templateName , this . _processTimeout ) ; \n \n \t3 } catch ( InternalErrorException e ) { \n \n <ect>
\t3 Logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; \n \n \t3 System . err . println ( <string_literal> + filename + <string_literal> + e ) ; \n \n \t3 e . printStackTrace ( ) ; \n \n \t3 System . err . println ( <string_literal> + filename + <string_literal> ) ; \n \n <ect>
\t2 <comment> \n \n \t2 LOG . warn ( <string_literal> + p + <string_literal> ) ; \n \n \t2 return FileType . UNKNOWN ; } \n \n \t1 if ( fileStatuses . length == 0 ) { \n \n <ect>
\t4 LOG . recognizedObsoleteHibernateNamespace ( OLD_HIBERNATE_NAMESPACE , HIBERNATE_NAMESPACE ) ; \n \n \t4 LOG . debug ( <string_literal> ) ; \n \n \t4 source = resolveOnClassPath ( publicId , systemId , OLD_HIBERNATE_NAMESPACE ) ; } \n \n \t3 else if ( systemId . startsWith ( USER_NAMESPACE ) ) { \n \n <ect>
\t1 advanceDumpDir ( ) ; \n \n \t1 run ( <string_literal> + dbName + <string_literal> + replDumpId , driver ) ; \n \n \t1 String incrementalDumpLocn = getResult ( 0 , 0 , driver ) ; \n \n \t1 String incrementalDumpId = getResult ( 0 , 1 , true , driver ) ; \n \n <ect>
\t3 return ; } \n \n \t2 Pod old = kubernetesClient . pods ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; \n \n \t2 if ( isRunning ( old ) ) { \n \n \t3 if ( UserConfigurationCompare . configEqual ( pod , old ) ) { \n \n <ect>
\t2 assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( 3L ) ) ; \n \n \t2 assertThat ( searchResponse . getHits ( ) . getAt ( 0 ) . getId ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 assertThat ( searchResponse . getHits ( ) . getAt ( 1 ) . getId ( ) , equalTo ( <string_literal> ) ) ; \n \n \t2 assertThat ( searchResponse . getHits ( ) . getAt ( <number_literal> ) . getId ( ) , equalTo ( <string_literal> ) ) ; \n \n <ect>
\t3 externalLoadBalancer = getNetScalerControlCenterForNetwork ( network ) ; \n \n \t2 } else { \n \n \t3 ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork ( network ) ; \n \n \t3 if ( lbDeviceVO == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( ( sourceStep == null && old == null ) || ( sourceStep != null && old != null && sourceStep . equals ( old ) ) ) { \n \n \t3 return ; } \n \n \t2 if ( sourceStep == null ) { \n \n <ect>
\t2 <comment> \n \n \t2 if ( ! indexRules . exists ( ) ) { \n \n \t3 return Collections . emptyMap ( ) ; } \n \n \t2 if ( ! hasOrderableChildren ( indexRules ) ) { \n \n <ect>
\t2 if ( in != null ) { \n \n \t3 logger . debug ( <string_literal> ) ; \n \n \t3 IOUtils . closeQuietly ( in ) ; } \n \n \t2 if ( serialPort != null ) { \n \n <ect>
\t7 Message m = it . next ( ) ; \n \n \t7 MATCHED status = f . match ( m , true , tStart ) ; \n \n \t7 if ( status == MATCHED . MATCHED ) { \n \n \t8 <comment> \n \n <ect>
\t3 wakeupCnxn ( ) ; } \n \n \t2 @ Override \n \n \t2 public void exceptionCaught ( ChannelHandlerContext ctx , \n \n \t9 ExceptionEvent e ) throws Exception { \n \n <ect>
<comment> \n \n \t1 protected synchronized StealerBasedRebalanceTask scheduleNextTask ( boolean executeService ) { \n \n \t2 <comment> \n \n \t2 if ( doneSignal . getCount ( ) == 0 ) { \n \n <ect>
\t5 if ( bit >= 0 ) { <comment> \n \n \t6 int v = ( status > > bit ) & 0x1 ; \n \n \t6 updateItem ( c , ( v == 0 ) ? OpenClosedType . CLOSED : OpenClosedType . OPEN ) ; \n \n \t5 } else { <comment> \n \n <ect>
\t3 if ( _socket == null ) { \n \n \t4 try { \n \n \t5 _socket = _manager . connect ( _remoteDestination ) ; \n \n \t4 } catch ( Exception e ) { \n \n <ect>
<comment> \n \n <comment> \n \n <comment> \n \n <comment> \n \n <ect>
\t2 } catch ( ConcurrentOperationException e ) { \n \n \t3 s_logger . warn ( <string_literal> , e ) ; \n \n \t3 return null ; \n \n \t2 } catch ( CloudRuntimeException e ) { \n \n <ect>
\t3 try { \n \n \t4 s_logger . trace ( <string_literal> ) ; \n \n \t4 _conn . setAutoCommit ( false ) ; \n \n \t3 } catch ( final SQLException e ) { \n \n <ect>
\t1 try { \n \n \t2 if ( dbAccessor . tableExists ( tableName ) ) { \n \n \t2 dbAccessor . truncateTable ( tableName ) ; } \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t6 logger . warn ( ( ) - > new ParameterizedMessage ( \n \n \t8 <string_literal> , retryCount ) , e ) ; \n \n \t6 fail . accept ( e ) ; } \n \n \t4 } else { \n \n <ect>
\t1 public boolean hasNexusVSM ( Long clusterId ) { \n \n \t2 ClusterVSMMapVO vsmMapVo = null ; \n \n \t2 vsmMapVo = _vsmMapDao . findByClusterId ( clusterId ) ; \n \n \t2 if ( vsmMapVo == null ) { \n \n <ect>
\t6 <comment> \n \n \t6 try { \n \n \t7 xarExtensionPlan . close ( ) ; \n \n \t6 } catch ( IOException e ) { \n \n <ect>
<comment> \n \n \t2 private void prepare0 ( ) { \n \n <ect>
\t1 try { \n \n \t1 SimpleDateFormat formatter = new SimpleDateFormat ( dateFormat ) ; \n \n \t1 return formatter . format ( date ) . toString ( ) ; \n \n \t1 } catch ( Exception e ) { \n \n <ect>
\t3 log \n \n \t5 . debug ( <string_literal> ) ; \n \n \t3 return ; } \n \n \t2 if ( mr . reducePlan . isEmpty ( ) ) { \n \n <ect>
\t2 if ( pathname != null && pathname . length ( ) > 0 ) { \n \n \t3 _tapStreamOut = new FileOutputStream ( new File ( pathname + <string_literal> ) ) ; \n \n \t3 _tapStreamIn = new FileOutputStream ( new File ( pathname + <string_literal> ) ) ; \n \n \t3 if ( Log . isLoggable ( Log . FAC_NETMANAGER , Level . INFO ) ) \n \n <ect>
''' \n \n merged_hiveserver2_interactive_site = { } \n \n if 'hiveserver2 - site' in params . config [ 'configurations' ] : \n \n \t1 merged_hiveserver2_interactive_site . update ( params . config [ 'configurations' ] [ 'hiveserver2 - site' ] ) \n \n <ect>
<comment> \n \n \t1 public void writeMessage ( Msg m ) throws IOException { \n \n \t2 if ( m == null ) { \n \n <ect>
\t2 RouterInfo info = _context . netDb ( ) . lookupRouterInfoLocally ( peer ) ; \n \n \t2 if ( null != info ) { \n \n \t3 if ( info . isHidden ( ) ) { \n \n \t3 if ( _log . shouldLog ( Log . WARN ) ) \n \n <ect>
\t1 @ Override \n \n \t1 protected void startInner ( ) throws VoldemortException { \n \n \t2 <comment> \n \n \t2 JNAUtils . tryMlockall ( ) ; \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public Collection < RegisteredService > load ( final File file ) { \n \n \t2 if ( ! file . canRead ( ) ) { \n \n <ect>
\t3 s_logger . debug ( <string_literal> + ex . toString ( ) ) ; \n \n \t3 try { \n \n \t4 snapshotObj . processEvent ( Snapshot . Event . OperationFailed ) ; } \n \n \t3 catch ( NoTransitionException ex2 ) { \n \n <ect>
\t2 } finally { \n \n \t3 <comment> \n \n \t3 logger . info ( <string_literal> ) ; \n \n \t3 unblockAllDataNodes ( repoName ) ; } \n \n <ect>
<comment> \n \n \t1 public void stopHandling ( ) { \n \n \t2 if ( _log . shouldInfo ( ) ) \n \n <ect>
<comment> \n \n \t4 <comment> \n \n <ect>
\t9 <string_literal> + cacheId + <string_literal> + cacheUuid + <string_literal> ) ; \n \n \t6 cacheMgr . releaseCacheObject ( srcForCopy ) ; } } } \n \n \t3 return answer ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t3 public boolean validateMetrics ( Map < String , Double > metrics ) { \n \n \t4 <comment> \n \n \t4 double cycle = 1 / ( metrics . get ( <string_literal> ) / TICK_TUPLE_BOLT_PARALLELISM ) ; \n \n \t4 LOG . info ( <string_literal> + metrics . get ( <string_literal> ) ) ; \n \n <ect>
\t2 blobs . add ( blob ) ; } \n \n \t1 @ Override \n \n \t1 public void release ( Blob blob ) { \n \n \t2 if ( blobs == null ) { \n \n <ect>
\t3 LOG . info ( <string_literal> + this . getClass ( ) . getName ( ) \n \n \t4 + <string_literal> \n \n \t4 + ( System . currentTimeMillis ( ) - start ) + <string_literal> ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
\t2 <comment> \n \n \t2 parseWithException ( <string_literal> ) ; \n \n \t2 parseWithException ( <string_literal> ) ; \n \n \t2 parseWithException ( <string_literal> ) ; \n \n <ect>
\t1 <comment> \n \n \t1 if ( cancel ) { \n \n \t1 try { \n \n \t2 shellState . getConnector ( ) . tableOperations ( ) . cancelCompaction ( tableName ) ; \n \n <ect>
\t2 doInBackground ( context . getMBeanServerConnection ( ) ) ; \n \n \t2 return null ; } \n \n \t1 protected void doInBackground ( MBeanServerConnection conn ) { \n \n \t2 if ( conn == null ) { \n \n <ect>
\t5 } else { \n \n \t6 LoggingInitializer . LOGGER . warning ( <string_literal> ) ; } } \n \n \t3 <comment> \n \n \t3 if ( suppressStdOutLogging ) { \n \n <ect>
\t4 case SECRET_KEY_RSP : \n \n \t5 handleSecretKeyResponse ( pub_key , hdr . encrypted_secret_key , hdr . secret_key_version , sender ) ; \n \n \t5 break ; \n \n \t4 default : \n \n <ect>
<comment> \n \n \t1 @ Override \n \n \t1 public void handleApplicationCommandRequest ( SerialMessage serialMessage , int offset , int endpoint ) { \n \n \t2 logger . trace ( <string_literal> ) ; \n \n <ect>
private static ScheduledExecutorService pool ; \n \n public static synchronized ThreadPool initialize ( Configuration conf ) { \n \n \t1 if ( self == null ) { \n \n \t1 self = new ThreadPool ( conf ) ; \n \n <ect>
\t2 LogManager . getLogger ( <string_literal> ) . setLevel ( Level . DEBUG ) ; \n \n \t2 LogManager . getLogger ( <string_literal> ) . setLevel ( Level . TRACE ) ; \n \n \t2 LogManager . getLogger ( <string_literal> ) . setLevel ( Level . DEBUG ) ; \n \n \t2 LogManager . getLogger ( <string_literal> ) . setLevel ( Level . DEBUG ) ; \n \n <ect>
\t1 private void updateSSOKey ( ) { \n \n \t2 try { \n \n \t3 _configDao . update ( Config . SSOKey . key ( ) , Config . SSOKey . getCategory ( ) , getPrivateKey ( ) ) ; \n \n \t2 } catch ( NoSuchAlgorithmException ex ) { \n \n <ect>
\t4 } catch ( Exception x ) { \n \n \t5 if ( x instanceof InterruptedException ) interrupted ( ) ; \n \n \t5 else { \n \n \t6 if ( errorCounter == 0 && doRunReceiver ) log . warn ( <string_literal> , x ) ; \n \n <ect>
\t5 volDao . update ( volume . getId ( ) , volumeVO ) ; \n \n \t5 updated = true ; \n \n \t5 break ; } } \n \n \t3 if ( ! updated ) { \n \n <ect>
\t6 return allocationService . reroute ( currentState , <string_literal> ) ; } \n \n \t4 } ) ; } \n \n \t3 @ Override \n \n \t3 public void onFailure ( String source , Exception e ) { \n \n <ect>
\t2 assertTrue ( ( startText == null || row . compareTo ( startText ) < = 0 ) \n \n \t3 || ( endText == null || row . compareTo ( endText ) > 0 ) ) ; \n \n \t2 assertTrue ( startText != null || endText != null ) ; \n \n \t2 count ++ ; } \n \n <ect>
\t2 <comment> \n \n \t2 try { \n \n \t3 c . add ( new AlignmentSVGVisualizationUpdate ( worksheetId ) ) ; \n \n \t2 } catch ( Exception e ) { \n \n <ect>
