lookup lookup ; try { lookup = create <identifiersep> lookup ( domain , v6lookup ? type . aaaa : type . a ) ; } catch ( text <identifiersep> parse <identifiersep> exception tpe ) { <LOG> throw new parse <identifiersep> exception ( tpe . get <identifiersep> message ( ) , 0 ) ; } record [ ] records = null ; try { records = lookup . run ( ) ; } catch ( dnssec <identifiersep> runtime <identifiersep> exception e ) <ect>
) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } v6lookup = ! v6lookup ; } <LOG> return addresses . to <identifiersep> array ( new inet <identifiersep> socket <identifiersep> address [ 0 ] ) ; } <comment> <ect>
catch ( unknown <identifiersep> host <identifiersep> exception e ) { return null ; } } else { <LOG> return null ; } } <comment> <ect>
catch ( unknown <identifiersep> host <identifiersep> exception e ) { return null ; } } else { <LOG> return null ; } } <comment> <ect>
{ protocol <identifiersep> provider <identifiersep> factory = util <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( refs . iterator ( ) . next ( ) ) ; } } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } return protocol <identifiersep> provider <identifiersep> factory ; } <comment> <ect>
util <identifiersep> activator . get <identifiersep> alert <identifiersep> ui <identifiersep> service ( ) . show <identifiersep> alert <identifiersep> dialog ( util <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , error <identifiersep> message , ex ) ; } break ; default : <LOG> } } } <comment> private static class unregister <identifiersep> provider extends thread { <ect>
catch ( exception e ) <comment> <LOG> } } <comment> <ect>
localhost <identifiersep> name . to <identifiersep> string ( ) ) ; localhost <identifiersep> addresses = ( inet <identifiersep> address [ ] ) lookup . invoke ( impl , <string_literal> ) ; addresses <identifiersep> loaded = true ; } catch ( exception e ) { <LOG> } } @ override public string get <identifiersep> host <identifiersep> by <identifiersep> addr ( final byte [ ] bytes ) throws unknown <identifiersep> host <identifiersep> exception { inet <identifiersep> address addr = inet <identifiersep> address . get <identifiersep> by <identifiersep> address ( bytes ) ; if ( addr . is <identifiersep> loopback <identifiersep> address ( ) ) <ect>
bundle <identifiersep> context . register <identifiersep> service ( service <identifiersep> class . get <identifiersep> name ( ) , service <identifiersep> impl , null ) ; <LOG> } <comment> <ect>
try { lock <identifiersep> file . get <identifiersep> parent <identifiersep> file ( ) . mkdirs ( ) ; lock <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } lock <identifiersep> file . delete <identifiersep> on <identifiersep> exit ( ) ; delete <identifiersep> on <identifiersep> halt <identifiersep> hook . add ( lock <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; write <identifiersep> lock <identifiersep> file ( lock <identifiersep> file , server <identifiersep> socket <identifiersep> address ) ; return success ; } <comment> <ect>
try { instance <identifiersep> server <identifiersep> socket . bind ( local <identifiersep> address , <number_literal> ) ; <comment> <LOG> return lock <identifiersep> error ; } lock <identifiersep> server lock <identifiersep> serv = new lock <identifiersep> server ( instance <identifiersep> server <identifiersep> socket ) ; lock <identifiersep> serv . start ( ) ; return success ; } <comment> <ect>
properties lock <identifiersep> properties = new properties ( ) ; try { lock <identifiersep> properties . load ( new file <identifiersep> input <identifiersep> stream ( lock <identifiersep> file ) ) ; } catch ( exception exc ) { <LOG> return null ; } string lock <identifiersep> address <identifiersep> str = lock <identifiersep> properties . get <identifiersep> property ( pname <identifiersep> lock <identifiersep> address ) ; if ( lock <identifiersep> address <identifiersep> str == null ) { logger . error ( <string_literal> ) ; return null ; <ect>
{ logger . error ( <string_literal> ) ; return null ; } string lock <identifiersep> port = lock <identifiersep> properties . get <identifiersep> property ( pname <identifiersep> lock <identifiersep> port ) ; if ( lock <identifiersep> port == null ) { <LOG> return null ; } inet <identifiersep> address lock <identifiersep> address = find <identifiersep> local <identifiersep> address ( lock <identifiersep> address <identifiersep> str ) ; if ( lock <identifiersep> address == null ) { logger . error ( lock <identifiersep> address <identifiersep> str + <string_literal> ) ; return null ; <ect>
int port ; try { port = integer . parse <identifiersep> int ( lock <identifiersep> port ) ; } catch ( number <identifiersep> format <identifiersep> exception exc ) { <LOG> return null ; } inet <identifiersep> socket <identifiersep> address lock <identifiersep> socket <identifiersep> address = new inet <identifiersep> socket <identifiersep> address ( lock <identifiersep> address , port ) ; return lock <identifiersep> socket <identifiersep> address ; } <comment> <ect>
<comment> <LOG> if ( server <identifiersep> read <identifiersep> arg <identifiersep> count != args . length ) return lock <identifiersep> error ; print <identifiersep> stream . flush ( ) ; print <identifiersep> stream . close ( ) ; inter <identifiersep> instance <identifiersep> socket . close ( ) ; } <comment> <ect>
{ <comment> <LOG> inter <identifiersep> instance <identifiersep> socket . close ( ) ; } catch ( exception exception ) { logger . error ( <string_literal> , exception ) ; } } <comment> <ect>
<comment> public void handle <identifiersep> help <identifiersep> arg ( ) { handle <identifiersep> version <identifiersep> arg ( ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
<comment> public void handle <identifiersep> help <identifiersep> arg ( ) { handle <identifiersep> version <identifiersep> arg ( ) ; system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
{ handle <identifiersep> version <identifiersep> arg ( ) ; system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; } <comment> <ect>
system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; } <comment> <ect>
system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; } <comment> <ect>
+ <string_literal> + recorded <identifiersep> args . size ( ) + <string_literal> ) ; this . uri <identifiersep> delegation <identifiersep> peer = delegation <identifiersep> peer ; for ( string arg : recorded <identifiersep> args ) { <LOG> uri <identifiersep> delegation <identifiersep> peer . handle <identifiersep> uri ( arg ) ; } recorded <identifiersep> args . clear ( ) ; } } <comment> <ect>
= bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { ser <identifiersep> refs = null ; <LOG> } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < protocol <identifiersep> provider <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { protocol <identifiersep> provider <identifiersep> factory provider <identifiersep> factory = bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
protected plugin <identifiersep> component get <identifiersep> plugin <identifiersep> instance ( ) { return new about <identifiersep> window <identifiersep> plugin <identifiersep> component ( get <identifiersep> container ( ) , this ) ; } } , chat <identifiersep> help <identifiersep> menu <identifiersep> filter ) ; <LOG> } static bundle <identifiersep> context get <identifiersep> bundle <identifiersep> context ( ) { return bundle <identifiersep> context ; } <comment> <ect>
try { document . insert <identifiersep> after <identifiersep> end ( root . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } public void insert <identifiersep> after <identifiersep> start ( string text ) { element root = this . document . get <identifiersep> default <identifiersep> root <identifiersep> element ( ) ; <ect>
{ element root = this . document . get <identifiersep> default <identifiersep> root <identifiersep> element ( ) ; try { this . document . insert <identifiersep> before <identifiersep> start ( root . get <identifiersep> element ( 0 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } <ect>
{ show <identifiersep> dialog ( ) ; } } catch ( invalid <identifiersep> syntax <identifiersep> exception e ) { logger . error ( e ) ; } } <LOG> } private void show <identifiersep> dialog ( ) { initial <identifiersep> account <identifiersep> registration <identifiersep> frame account <identifiersep> reg <identifiersep> frame = new initial <identifiersep> account <identifiersep> registration <identifiersep> frame ( ) ; dimension screen <identifiersep> size = toolkit . get <identifiersep> default <identifiersep> toolkit ( ) . get <identifiersep> screen <identifiersep> size ( ) ; account <identifiersep> reg <identifiersep> frame . set <identifiersep> location ( screen <identifiersep> size . width / <number_literal> <ect>
= ( account <identifiersep> registration <identifiersep> wizard ) simple <identifiersep> account <identifiersep> registration <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( service <identifiersep> refs [ 0 ] ) ; this . add <identifiersep> account <identifiersep> registration <identifiersep> form ( wizard ) ; } } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } } } <comment> private class account <identifiersep> registration <identifiersep> panel extends j <identifiersep> panel { <ect>
{ if ( reg <identifiersep> form . is <identifiersep> filled ( ) ) reg <identifiersep> form . signin ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> popup <identifiersep> dialog popup <identifiersep> dialog = simple <identifiersep> account <identifiersep> registration <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) ; if ( e . get <identifiersep> error <identifiersep> code ( ) == operation <identifiersep> failed <identifiersep> exception . illegal <identifiersep> argument ) { <ect>
get <identifiersep> current <identifiersep> version ( ) ) < = 0 ; else logger . error ( <string_literal> + latest <identifiersep> version + <string_literal> ) ; } catch ( throwable t ) { <LOG> } <comment> <ect>
<comment> @ override public void start ( object dependent <identifiersep> service ) { <LOG> configuration <identifiersep> service cfg = get <identifiersep> configuration ( ) ; if ( os <identifiersep> utils . is <identifiersep> windows ) { update <identifiersep> service = new update <identifiersep> service <identifiersep> impl ( ) ; bundle <identifiersep> context . register <identifiersep> service ( update <identifiersep> service . class . get <identifiersep> name ( ) , <ect>
<comment> <LOG> get <identifiersep> update <identifiersep> service ( ) . check <identifiersep> for <identifiersep> updates ( false ) ; } } ; m <identifiersep> update <identifiersep> executor = executors . new <identifiersep> single <identifiersep> thread <identifiersep> scheduled <identifiersep> executor ( ) ; m <identifiersep> update <identifiersep> executor . schedule <identifiersep> at <identifiersep> fixed <identifiersep> rate ( update <identifiersep> runnable , hours <identifiersep> to <identifiersep> wait , <number_literal> * <number_literal> * <number_literal> , <ect>
logger . error ( <string_literal> , e ) ; } catch ( parser <identifiersep> configuration <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } element root = server <identifiersep> comments . get <identifiersep> document <identifiersep> element ( ) ; comments <identifiersep> list = root . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) ; } public int get <identifiersep> column <identifiersep> count ( ) { return <number_literal> ; } public int get <identifiersep> row <identifiersep> count ( ) <ect>
<comment> <LOG> change <identifiersep> password <identifiersep> message <identifiersep> pane . set <identifiersep> text ( <string_literal> ) ; } else if ( ! protocol <identifiersep> provider . is <identifiersep> registered ( ) ) { change <identifiersep> password <identifiersep> message <identifiersep> pane . set <identifiersep> text ( resources . get <identifiersep> string ( <string_literal> ) ) ; <ect>
string user <identifiersep> name , string passwd ) throws operation <identifiersep> failed <identifiersep> exception { { <LOG> } hashtable < string , string > account <identifiersep> properties = new hashtable < string , string > ( ) ; string protocol <identifiersep> icon <identifiersep> path = get <identifiersep> protocol <identifiersep> icon <identifiersep> path ( ) ; string account <identifiersep> icon <identifiersep> path = get <identifiersep> account <identifiersep> icon <identifiersep> path ( ) ; registration . store <identifiersep> properties ( user <identifiersep> name , passwd , <ect>
protocol <identifiersep> names . gibberish ) ; bundle <identifiersep> context . register <identifiersep> service ( account <identifiersep> registration <identifiersep> wizard . class . get <identifiersep> name ( ) , gibberish <identifiersep> wizard , container <identifiersep> filter ) ; <LOG> } <comment> <ect>
<comment> public void start ( final object dependent <identifiersep> service ) { { <LOG> } ui <identifiersep> service = ( ui <identifiersep> service ) dependent <identifiersep> service ; wizard <identifiersep> container = ui <identifiersep> service . get <identifiersep> account <identifiersep> reg <identifiersep> wizard <identifiersep> container ( ) ; irc <identifiersep> wizard = new irc <identifiersep> account <identifiersep> registration <identifiersep> wizard ( wizard <identifiersep> container ) ; hashtable < string , string > container <identifiersep> filter = new hashtable < string , string > ( ) ; container <identifiersep> filter <ect>
if ( ( config <identifiersep> form == this ) || ! config <identifiersep> form . is <identifiersep> advanced ( ) ) return ; switch ( event . get <identifiersep> type ( ) ) { case service <identifiersep> event . registered : <LOG> this . add <identifiersep> config <identifiersep> form ( config <identifiersep> form ) ; break ; case service <identifiersep> event . unregistering : this . remove <identifiersep> config <identifiersep> form ( config <identifiersep> form ) ; break ; } } <comment> <ect>
key <identifiersep> store = load <identifiersep> key <identifiersep> store ( ) ; cbo <identifiersep> alias . set <identifiersep> enabled ( true ) ; load <identifiersep> aliases ( ) ; cbo <identifiersep> alias . set <identifiersep> selected <identifiersep> item ( entry . get <identifiersep> alias ( ) ) ; } } catch ( key <identifiersep> store <identifiersep> exception ex ) { <LOG> show <identifiersep> generic <identifiersep> error ( <string_literal> , ex ) ; } catch ( provider <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; show <identifiersep> generic <identifiersep> error ( <string_literal> , ex ) ; } } private void init <identifiersep> components ( ) <ect>
cmd <identifiersep> close . do <identifiersep> click ( ) ; } } ; dlg . set <identifiersep> modal ( true ) ; dlg . set <identifiersep> visible ( true ) ; } catch ( key <identifiersep> store <identifiersep> exception e1 ) { <LOG> show <identifiersep> generic <identifiersep> error ( <string_literal> , e1 ) ; } } <comment> private void browse <identifiersep> key <identifiersep> store ( ) <ect>
+ protocol <identifiersep> provider <identifiersep> factory . protocol + <string_literal> + protocol <identifiersep> names . icq + <string_literal> ; try { ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } return ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; } <comment> <ect>
{ handler <identifiersep> refs = bc . get <identifiersep> service <identifiersep> references ( popup <identifiersep> message <identifiersep> handler . class . get <identifiersep> name ( ) , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } if ( handler <identifiersep> refs == null ) return null ; j <identifiersep> panel notif <identifiersep> config <identifiersep> panel = general <identifiersep> config <identifiersep> plugin <identifiersep> activator . create <identifiersep> config <identifiersep> section <identifiersep> component ( resources . get <identifiersep> string ( <string_literal> ) ) ; <ect>
start <identifiersep> thread <identifiersep> is <identifiersep> called = true ; } } } else bundle <identifiersep> context . add <identifiersep> service <identifiersep> listener ( this ) ; } catch ( throwable t ) { <comment> <LOG> logger . info ( <string_literal> ) ; } <comment> <ect>
if ( session != null ) session . join ( ) ; else session <identifiersep> manager . init <identifiersep> whiteboard ( contact ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { <LOG> } } } ) ; file <identifiersep> menu . add ( new <identifiersep> menu <identifiersep> item ) ; open <identifiersep> menu <identifiersep> item . set <identifiersep> text ( resources . get <identifiersep> string ( <string_literal> ) ) ; open <identifiersep> menu <identifiersep> item . set <identifiersep> enabled ( false ) ; file <identifiersep> menu . add ( open <identifiersep> menu <identifiersep> item ) ; save <identifiersep> menu <identifiersep> item . set <identifiersep> text ( resources . get <identifiersep> string ( <string_literal> ) ) ; <ect>
<comment> private void released <identifiersep> polyline ( boolean fill ) { <LOG> done <identifiersep> drawing = true ; append <identifiersep> and <identifiersep> send ( new whiteboard <identifiersep> shape <identifiersep> poly <identifiersep> line ( id ( ) , spin <identifiersep> model . get <identifiersep> number ( ) . int <identifiersep> value ( ) , current <identifiersep> color , path <identifiersep> list , fill , s2w ) ) ; path <identifiersep> list . clear ( ) ; } <comment> <ect>
<comment> public void receive <identifiersep> delete <identifiersep> whiteboard <identifiersep> object ( string id ) { <LOG> int i = 0 ; while ( i < display <identifiersep> list . size ( ) ) { whiteboard <identifiersep> shape wbs = display <identifiersep> list . get ( i ) ; if ( id . equals ( wbs . get <identifiersep> id ( ) ) ) display <identifiersep> list . remove ( i ) ; <ect>
int color = wbo . get <identifiersep> color ( ) ; int t = wbo . get <identifiersep> thickness ( ) ; if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> path ) { whiteboard <identifiersep> object <identifiersep> path path = ( whiteboard <identifiersep> object <identifiersep> path ) wbo ; <LOG> color c = color . get <identifiersep> color ( <string_literal> , color ) ; list < whiteboard <identifiersep> point > points = path . get <identifiersep> points ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> path ( id , t , c , points ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> poly <identifiersep> line ) { <ect>
list < whiteboard <identifiersep> point > points = p <identifiersep> line . get <identifiersep> points ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> poly <identifiersep> line ( id , t , c , points , false ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> polygon ) { whiteboard <identifiersep> object <identifiersep> polygon polygon = ( whiteboard <identifiersep> object <identifiersep> polygon ) wbo ; <LOG> color c = color . get <identifiersep> color ( <string_literal> , color ) ; list < whiteboard <identifiersep> point > points = polygon . get <identifiersep> points ( ) ; boolean fill = polygon . is <identifiersep> fill ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> polygon ( id , t , c , points , fill ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> line ) { <ect>
ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> return null ; } return ( ser <identifiersep> refs == null ) ? null : ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; <ect>
string master ; boolean correct = true ; master <identifiersep> password <identifiersep> input <identifiersep> service master <identifiersep> password <identifiersep> input <identifiersep> service = security <identifiersep> config <identifiersep> activator . get <identifiersep> master <identifiersep> password <identifiersep> input <identifiersep> service ( ) ; if ( master <identifiersep> password <identifiersep> input <identifiersep> service == null ) { <LOG> return ; } do { master = master <identifiersep> password <identifiersep> input <identifiersep> service . show <identifiersep> input <identifiersep> dialog ( correct ) ; if ( master == null ) return ; <ect>
string master ; boolean correct = true ; master <identifiersep> password <identifiersep> input <identifiersep> service master <identifiersep> password <identifiersep> input <identifiersep> service = security <identifiersep> config <identifiersep> activator . get <identifiersep> master <identifiersep> password <identifiersep> input <identifiersep> service ( ) ; if ( master <identifiersep> password <identifiersep> input <identifiersep> service == null ) { <LOG> return ; } do { master = master <identifiersep> password <identifiersep> input <identifiersep> service . show <identifiersep> input <identifiersep> dialog ( correct ) ; if ( master == null ) return ; <ect>
if ( op <identifiersep> set <identifiersep> im != null ) { op <identifiersep> set <identifiersep> im . add <identifiersep> message <identifiersep> listener ( this ) ; } else { <LOG> } <comment> <ect>
for ( chat <identifiersep> room room : op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat . get <identifiersep> currently <identifiersep> joined <identifiersep> chat <identifiersep> rooms ( ) ) room . add <identifiersep> message <identifiersep> listener ( this ) ; op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat . add <identifiersep> presence <identifiersep> listener ( this ) ; } else { <LOG> } operation <identifiersep> set <identifiersep> basic <identifiersep> telephony < ? > basic <identifiersep> telephony <identifiersep> op <identifiersep> set = provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> basic <identifiersep> telephony . class ) ; if ( basic <identifiersep> telephony <identifiersep> op <identifiersep> set != null ) { basic <identifiersep> telephony <identifiersep> op <identifiersep> set . add <identifiersep> call <identifiersep> listener ( this ) ; } } <comment> <ect>
s <identifiersep> service . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; <comment> <LOG> switch ( service <identifiersep> event . get <identifiersep> type ( ) ) { case service <identifiersep> event . registered : this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; break ; case service <identifiersep> event . unregistering : <ect>
<string_literal> ) ) ) ; unlocked <identifiersep> padlock <identifiersep> image = new image <identifiersep> icon ( image <identifiersep> io . read ( otr <identifiersep> activator . resource <identifiersep> service . get <identifiersep> image <identifiersep> url ( <string_literal> ) ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> } build <identifiersep> menu ( contact ) ; } @ override public int get <identifiersep> position <identifiersep> index ( ) { return - 1 ; } <comment> <ect>
session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( otr <identifiersep> contact ) ; try { otr <identifiersep> engine . get <identifiersep> session ( session <identifiersep> id ) . refresh <identifiersep> session ( ) ; } catch ( otr <identifiersep> exception e ) { <LOG> show <identifiersep> error ( session <identifiersep> id , e . get <identifiersep> message ( ) ) ; } } @ override public void remove <identifiersep> listener ( sc <identifiersep> otr <identifiersep> engine <identifiersep> listener l ) { synchronized ( listeners ) { <ect>
session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( otr <identifiersep> contact ) ; try { return otr <identifiersep> engine . get <identifiersep> session ( session <identifiersep> id ) . transform <identifiersep> receiving ( msg <identifiersep> text ) ; } catch ( otr <identifiersep> exception e ) { <LOG> show <identifiersep> error ( session <identifiersep> id , e . get <identifiersep> message ( ) ) ; return null ; } } @ override public string [ ] transform <identifiersep> sending ( otr <identifiersep> contact otr <identifiersep> contact , string msg <identifiersep> text ) { session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( otr <identifiersep> contact ) ; <ect>
operation <identifiersep> set <identifiersep> instant <identifiersep> message <identifiersep> transform op <identifiersep> set <identifiersep> message <identifiersep> transform = provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> instant <identifiersep> message <identifiersep> transform . class ) ; if ( op <identifiersep> set <identifiersep> message <identifiersep> transform != null ) op <identifiersep> set <identifiersep> message <identifiersep> transform . add <identifiersep> transform <identifiersep> layer ( this . otr <identifiersep> transform <identifiersep> layer ) ; <LOG> } private void handle <identifiersep> provider <identifiersep> removed ( protocol <identifiersep> provider <identifiersep> service provider ) { <comment> <ect>
<string_literal> ) ) ; timedout <identifiersep> padlock <identifiersep> image = image <identifiersep> io . read ( otr <identifiersep> activator . resource <identifiersep> service . get <identifiersep> image <identifiersep> url ( <string_literal> ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> } animated <identifiersep> padlock <identifiersep> image = new animated <identifiersep> image ( button , i1 , i2 , i3 ) ; button . add <identifiersep> action <identifiersep> listener ( new action <identifiersep> listener ( ) { public void action <identifiersep> performed ( action <identifiersep> event e ) { if ( otr <identifiersep> contact == null ) <ect>
<comment> public ldap <identifiersep> config <identifiersep> form ( ) { super ( new border <identifiersep> layout ( ) ) ; <LOG> this . init <identifiersep> components ( ) ; } <comment> private void init <identifiersep> components ( ) { <ect>
{ resource <identifiersep> bundle resource <identifiersep> bundle = resource <identifiersep> bundle . get <identifiersep> bundle ( default <identifiersep> style <identifiersep> resource <identifiersep> path ) ; this . init <identifiersep> resources ( resource <identifiersep> bundle , resources ) ; } catch ( missing <identifiersep> resource <identifiersep> exception ex ) { <LOG> } this . init <identifiersep> style <identifiersep> plugin <identifiersep> resources ( resources ) ; style <identifiersep> resources = resources ; return resources ; } <comment> <ect>
{ resource <identifiersep> bundle resource <identifiersep> bundle = resource <identifiersep> bundle . get <identifiersep> bundle ( default <identifiersep> settings <identifiersep> resource <identifiersep> path ) ; this . init <identifiersep> resources ( resource <identifiersep> bundle , resources ) ; } catch ( missing <identifiersep> resource <identifiersep> exception ex ) { <LOG> } this . init <identifiersep> settings <identifiersep> plugin <identifiersep> resources ( resources ) ; sttings <identifiersep> resources = resources ; return resources ; } <comment> <ect>
<string_literal> , <string_literal> , <number_literal> , true ) , properties ) ; } init <identifiersep> properties ( ) ; <LOG> } <comment> public void stop ( bundle <identifiersep> context bc ) throws exception <ect>
<comment> <LOG> } if ( ser <identifiersep> refs != null ) { for ( int i = 0 ; i < ser <identifiersep> refs . length ; i ++ ) { replacement <identifiersep> service replacement <identifiersep> sources = ( replacement <identifiersep> service ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ i ] ) ; <ect>
<comment> private void notify <identifiersep> network <identifiersep> down ( ) { <LOG> notify ( <string_literal> , <string_literal> , new string [ 0 ] , this ) ; } } <ect>
try { ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } return ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; } <comment> <ect>
ser <identifiersep> refs = notification <identifiersep> wiring <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception e ) { <LOG> } list < protocol <identifiersep> provider <identifiersep> service > providers <identifiersep> list = new array <identifiersep> list < protocol <identifiersep> provider <identifiersep> service > ( ) ; if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { <ect>
incoming <identifiersep> file , title , request . get <identifiersep> file <identifiersep> name ( ) , request . get <identifiersep> id ( ) ) ; } catch ( throwable t ) { <LOG> } } <comment> public void file <identifiersep> transfer <identifiersep> request <identifiersep> rejected ( file <identifiersep> transfer <identifiersep> request <identifiersep> event ev ) { } <ect>
incoming <identifiersep> message , title , html <identifiersep> content , source <identifiersep> msg . get <identifiersep> message <identifiersep> uid ( ) ) ; } } catch ( throwable t ) { <LOG> } } <comment> public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) <ect>
public void start ( bundle <identifiersep> context bc ) throws exception { bundle <identifiersep> context = bc ; try { logger . log <identifiersep> entry ( ) ; <LOG> <comment> <ect>
logger . info ( <string_literal> ) ; } finally { logger . log <identifiersep> exit ( ) ; } } public void stop ( bundle <identifiersep> context bc ) throws exception { <LOG> } <comment> public static notification <identifiersep> service get <identifiersep> notification <identifiersep> service ( ) <ect>
+ protocol <identifiersep> provider <identifiersep> factory . protocol + <string_literal> + protocol <identifiersep> names . aim + <string_literal> ; try { ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } return ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; } <comment> <ect>
parse <identifiersep> defaults ( node . get <identifiersep> child <identifiersep> nodes ( ) ) ; } else if ( node . get <identifiersep> node <identifiersep> name ( ) . equals ( node <identifiersep> locales ) ) { parse <identifiersep> locales ( node . get <identifiersep> child <identifiersep> nodes ( ) ) ; } else { <LOG> } } } catch ( io <identifiersep> exception exc ) { logger . error ( <string_literal> , exc ) ; } catch ( sax <identifiersep> exception exc ) { logger . error ( <string_literal> , exc ) ; <ect>
logger . warn ( <string_literal> + node . get <identifiersep> node <identifiersep> name ( ) ) ; } } } catch ( io <identifiersep> exception exc ) { logger . error ( <string_literal> , exc ) ; } catch ( sax <identifiersep> exception exc ) { <LOG> } catch ( parser <identifiersep> configuration <identifiersep> exception exc ) { logger . error ( <string_literal> , exc ) ; } } <comment> <ect>
try { default field = default . from <identifiersep> string ( attribute ) ; defaults . put ( field , value ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception exc ) { <LOG> } } } <comment> private static void parse <identifiersep> locales ( node <identifiersep> list list ) <ect>
catch ( bad <identifiersep> location <identifiersep> exception exc ) { string msg = <string_literal> ; logger . error ( msg , exc ) ; } catch ( throwable exc ) { <LOG> } } public void changed <identifiersep> update ( document <identifiersep> event e ) { } <comment> <ect>
<comment> public static image <identifiersep> icon get <identifiersep> flag <identifiersep> image ( string resource ) throws io <identifiersep> exception { string path = flag <identifiersep> path + resource + <string_literal> ; input <identifiersep> stream input = get <identifiersep> resources ( ) . get <identifiersep> image <identifiersep> input <identifiersep> stream <identifiersep> for <identifiersep> path ( path ) ; if ( input == null ) <LOG> buffered <identifiersep> image image = image <identifiersep> io . read ( input ) ; return new image <identifiersep> icon ( image ) ; } <comment> <ect>
checker = new spell <identifiersep> checker ( ) ; } } try { checker . start ( bundle <identifiersep> context ) ; } catch ( exception ex ) { <LOG> } menu <identifiersep> bar = new language <identifiersep> menu <identifiersep> bar ( checker , parent <identifiersep> factory ) ; menu <identifiersep> bar . create <identifiersep> spell <identifiersep> checker <identifiersep> worker ( checker . get <identifiersep> locale ( ) ) . start ( ) ; } } <comment> <ect>
personal <identifiersep> words . add ( personal <identifiersep> dict <identifiersep> scanner . next <identifiersep> line ( ) ) ; } finally { personal <identifiersep> dict <identifiersep> scanner . close ( ) ; } } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception exc ) { <LOG> } } return personal <identifiersep> words ; } <comment> <ect>
snd <identifiersep> props . put ( resource <identifiersep> pack . resource <identifiersep> name , sound <identifiersep> pack . resource <identifiersep> name <identifiersep> default <identifiersep> value ) ; bundle <identifiersep> context . register <identifiersep> service ( sound <identifiersep> pack . class . get <identifiersep> name ( ) , snd <identifiersep> pack <identifiersep> impl , snd <identifiersep> props ) ; <LOG> } public void stop ( bundle <identifiersep> context bc ) throws exception { } <comment> <ect>
{ synchronized ( this ) { string id = ( string ) get <identifiersep> data ( source <identifiersep> contact . data <identifiersep> id ) ; if ( id == null ) { <LOG> return ; } string sub <identifiersep> property = null ; int property = mac <identifiersep> osx <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> query . get <identifiersep> property ( detail . get <identifiersep> category ( ) , detail . get <identifiersep> sub <identifiersep> categories ( ) ) ; if ( mac <identifiersep> osx <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> detail . is <identifiersep> multiline ( detail . get <identifiersep> category ( ) ) ) <ect>
long time = new simple <identifiersep> date <identifiersep> format ( <string_literal> ) . parse ( props [ i ] + <string_literal> ) . get <identifiersep> time ( ) ; start <identifiersep> time = new date ( time ) ; } catch ( parse <identifiersep> exception e ) { <LOG> return ; } break ; case pid <identifiersep> lid <identifiersep> appointment <identifiersep> end <identifiersep> whole : try { long time <ect>
= new recurring <identifiersep> pattern ( recurring <identifiersep> data , task ) ; task . set <identifiersep> pattern ( pattern ) ; } catch ( index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception e ) { logger . error ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; <LOG> return ; } } if ( end <identifiersep> time . before ( current <identifiersep> time ) || end <identifiersep> time . equals ( current <identifiersep> time ) ) { if ( is <identifiersep> recurring ) { task = task . get <identifiersep> pattern ( ) . next ( start <identifiersep> time , end <identifiersep> time ) ; <ect>
public ms <identifiersep> outlook <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> query ( ms <identifiersep> outlook <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> source <identifiersep> service msoabcss , pattern query ) { super ( msoabcss , query ) ; <LOG> } <comment> <ect>
<comment> <LOG> } return false ; } int prop <identifiersep> index = 0 ; boolean matches = false ; object prop ; for ( int i = 0 ; i < props . length ; ++ i ) { <ect>
logger . info ( <string_literal> , ex ) ; plugin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } catch ( throwable ex ) { <LOG> } finally { dispose ( ) ; } } } else if ( source <identifiersep> button . equals ( file <identifiersep> chooser <identifiersep> button ) ) { sip <identifiersep> comm <identifiersep> file <identifiersep> chooser chooser = generic <identifiersep> file <identifiersep> dialog . create ( <ect>
try { ( ( bundle ) plugin <identifiersep> table . get <identifiersep> model ( ) . get <identifiersep> value <identifiersep> at ( selected <identifiersep> rows [ i ] , 0 ) ) . start ( ) ; } catch ( bundle <identifiersep> exception ex ) { <LOG> plugin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } } default <identifiersep> button <identifiersep> state ( ) ; } else if ( source <identifiersep> button . equals ( deactivate <identifiersep> button ) ) { <ect>
try { ( ( bundle ) plugin <identifiersep> table . get <identifiersep> model ( ) . get <identifiersep> value <identifiersep> at ( selected <identifiersep> rows [ i ] , 0 ) ) . uninstall ( ) ; } catch ( bundle <identifiersep> exception ex ) { <LOG> plugin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } } default <identifiersep> button <identifiersep> state ( ) ; } else if ( source <identifiersep> button . equals ( update <identifiersep> button ) ) { <ect>
<comment> <LOG> } for ( int i = 0 ; i < ser <identifiersep> refs . length ; i ++ ) { protocol <identifiersep> provider <identifiersep> factory provider <identifiersep> factory = ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ i ] ) ; provider <identifiersep> factories <identifiersep> map . put ( ser <identifiersep> refs [ i ] . get <identifiersep> property ( protocol <identifiersep> provider <identifiersep> factory . protocol ) , <ect>
resources . get <identifiersep> i18n <identifiersep> string ( body <identifiersep> msg <identifiersep> key , new string [ ] { upload <identifiersep> location } ) , null ) ; } } } catch ( throwable e ) { <LOG> } } } <ect>
return destination ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } catch ( io <identifiersep> exception ex ) { <LOG> } return null ; } <comment> public static string get <identifiersep> default <identifiersep> file <identifiersep> name ( ) <ect>
{ out . write ( buf , 0 , len ) ; } out . close <identifiersep> entry ( ) ; in . close ( ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { <LOG> } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } <comment> <ect>
chk <identifiersep> enabled . set <identifiersep> selected ( true ) ; } config . set <identifiersep> property ( custom <identifiersep> resolver . pname <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled , chk <identifiersep> enabled . is <identifiersep> selected ( ) ) ; } catch ( exception ex ) { <LOG> error <identifiersep> dialog ed = new error <identifiersep> dialog ( null , r . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , r . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , ex ) ; ed . show <identifiersep> dialog ( ) ; <ect>
else { show <identifiersep> error <identifiersep> message ( ( string ) json <identifiersep> object . get ( <string_literal> ) ) ; } } catch ( throwable e1 ) { <LOG> } return new <identifiersep> account ; } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <LOG> provisioning <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; string url = null ; provisioning <identifiersep> service = new provisioning <identifiersep> service <identifiersep> impl ( ) ; <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { provisioning <identifiersep> activator . bundle <identifiersep> context = null ; <LOG> } <comment> public static ui <identifiersep> service get <identifiersep> ui <identifiersep> service ( ) <ect>
logger . info ( <string_literal> , ex ) ; skin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } catch ( throwable ex ) { <LOG> } } else { if ( current != null ) { selector . set <identifiersep> selected <identifiersep> item ( current ) ; } else <ect>
return null ; try { image = image <identifiersep> io . read ( in ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return image ; } <comment> <ect>
else { event . reject <identifiersep> drop ( ) ; } } catch ( exception ex ) { <LOG> event . reject <identifiersep> drop ( ) ; } } <comment> <ect>
public void run ( ) { verify <identifiersep> certificate <identifiersep> dialog <identifiersep> impl . super . set <identifiersep> visible ( true ) ; } } ) ; } catch ( exception e ) { <LOG> } } } <ect>
presence <identifiersep> op <identifiersep> set . get <identifiersep> presence <identifiersep> status ( ) , message ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e1 ) { logger . error ( <string_literal> , e1 ) ; } catch ( illegal <identifiersep> state <identifiersep> exception e1 ) { <LOG> } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { if ( e1 . get <identifiersep> error <identifiersep> code ( ) == operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error ) { logger . error ( <ect>
try { file image <identifiersep> file = desktop <identifiersep> util <identifiersep> activator . get <identifiersep> file <identifiersep> access <identifiersep> service ( ) . get <identifiersep> private <identifiersep> persistent <identifiersep> file ( file <identifiersep> name , file <identifiersep> category . cache ) ; if ( image <identifiersep> file . exists ( ) && ! image <identifiersep> file . delete ( ) ) <LOG> } catch ( exception e ) { <comment> <ect>
string image <identifiersep> path = store <identifiersep> dir + index + <string_literal> ; image <identifiersep> file = desktop <identifiersep> util <identifiersep> activator . get <identifiersep> file <identifiersep> access <identifiersep> service ( ) . get <identifiersep> private <identifiersep> persistent <identifiersep> file ( image <identifiersep> path , file <identifiersep> category . cache ) ; } catch ( exception e ) { <LOG> return null ; } <comment> <ect>
store <identifiersep> dir . mkdirs ( ) ; file file = fas . get <identifiersep> private <identifiersep> persistent <identifiersep> file ( image <identifiersep> path , file <identifiersep> category . cache ) ; image <identifiersep> io . write ( image , <string_literal> , file ) ; } catch ( exception e ) { <LOG> } } } <ect>
timer <identifiersep> images [ i ] . set <identifiersep> elapsed ( ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } } play <identifiersep> sound ( ) ; grab <identifiersep> snapshot ( ) ; webcam <identifiersep> dialog . this . set <identifiersep> visible ( false ) ; webcam <identifiersep> dialog . this . dispose ( ) ; } } <comment> <ect>
presence <identifiersep> op <identifiersep> set . publish <identifiersep> presence <identifiersep> status ( current <identifiersep> status , message ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e1 ) { logger . error ( <string_literal> , e1 ) ; } catch ( illegal <identifiersep> state <identifiersep> exception e1 ) { <LOG> } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { if ( e1 . get <identifiersep> error <identifiersep> code ( ) == operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error ) { logger . error ( <ect>
<comment> <LOG> } catch ( exception e ) { logger . debug ( <string_literal> , e ) ; } if ( image <identifiersep> icon != null ) return new image <identifiersep> icon ( image <identifiersep> icon ) ; <ect>
break ; case rounded <identifiersep> rectangle : image <identifiersep> icon = get <identifiersep> scaled <identifiersep> rounded <identifiersep> icon ( image , width , height ) ; break ; } } else <LOG> } catch ( exception e ) { logger . debug ( <string_literal> , e ) ; } return image <identifiersep> icon ; } <comment> <ect>
try { image = image <identifiersep> io . read ( image <identifiersep> path ) ; } catch ( io <identifiersep> exception ex ) { <LOG> } } return image ; } <comment> <ect>
image image = null ; try { image = image <identifiersep> io . read ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( image <identifiersep> bytes ) ) ; } catch ( exception e ) { <LOG> } return image ; } <comment> <ect>
try { document . insert <identifiersep> after <identifiersep> end ( root . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } <comment> <ect>
try { this . document . insert <identifiersep> before <identifiersep> start ( root . get <identifiersep> element ( 0 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } <ect>
<string_literal> , window . class , boolean . class ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( security <identifiersep> exception ex ) { <LOG> } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } } static { init ( ) ; <ect>
object ret = method . invoke ( null , kind ) ; if ( ret instanceof boolean ) { return ( ( boolean ) ret ) . boolean <identifiersep> value ( ) ; } } catch ( illegal <identifiersep> access <identifiersep> exception ex ) { <LOG> } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; <ect>
logger . info ( <string_literal> ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ex ) { <LOG> } return false ; } public static boolean is <identifiersep> translucency <identifiersep> supported ( object kind ) { if ( translucency <identifiersep> class == null ) return false ; return is <identifiersep> supported ( m <identifiersep> is <identifiersep> translucency <identifiersep> supported , kind ) ; <ect>
method . invoke ( null , window , value ) ; } catch ( illegal <identifiersep> access <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { <LOG> } catch ( invocation <identifiersep> target <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } } public static void set <identifiersep> window <identifiersep> shape ( window window , shape shape ) { set ( m <identifiersep> set <identifiersep> window <identifiersep> shape , window , shape ) ; <ect>
ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception e ) { <LOG> } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { protocol <identifiersep> provider <identifiersep> factory provider <identifiersep> factory = ( protocol <identifiersep> provider <identifiersep> factory ) <ect>
super . stopped ( true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } catch ( exception e ) { <LOG> } } <comment> <ect>
logger . log <identifiersep> entry ( ) ; logger . info ( <string_literal> ) ; notification <identifiersep> service = bundle <identifiersep> context . register <identifiersep> service ( notification <identifiersep> service . class . get <identifiersep> name ( ) , new notification <identifiersep> service <identifiersep> impl ( ) , null ) ; <LOG> } finally { logger . log <identifiersep> exit ( ) ; } } public void stop ( bundle <identifiersep> context bc ) throws exception { notification <identifiersep> service . unregister ( ) ; <ect>
action <identifiersep> prop <identifiersep> name + <string_literal> ) ; int pattern <identifiersep> len = config <identifiersep> service . get <identifiersep> int ( action <identifiersep> prop <identifiersep> name + <string_literal> , - 1 ) ; if ( pattern <identifiersep> len == - 1 ) { <LOG> continue ; } long [ ] pattern = new long [ pattern <identifiersep> len ] ; for ( int p <identifiersep> idx = 0 ; p <identifiersep> idx < pattern <identifiersep> len ; p <identifiersep> idx ++ ) { pattern [ p <identifiersep> idx ] = config <identifiersep> service . get <identifiersep> long ( <ect>
http <identifiersep> entity result = execute <identifiersep> method ( http <identifiersep> client , http <identifiersep> get , null , null ) ; if ( result == null ) return null ; return new http <identifiersep> response <identifiersep> result ( result , http <identifiersep> client ) ; } catch ( throwable t ) { <LOG> } return null ; } <comment> <ect>
execute <identifiersep> method ( http <identifiersep> client , post <identifiersep> method , null , null ) ; if ( res <identifiersep> entity == null ) return null ; return new http <identifiersep> response <identifiersep> result ( res <identifiersep> entity , http <identifiersep> client ) ; } catch ( throwable e ) { <LOG> } return null ; } <comment> <ect>
{ return ; } resource <identifiersep> pack resource <identifiersep> pack = ( resource <identifiersep> pack ) s <identifiersep> service ; if ( event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { <LOG> map < string , string > resources = get <identifiersep> resources ( resource <identifiersep> pack ) ; if ( resource <identifiersep> pack instanceof color <identifiersep> pack && color <identifiersep> pack == null ) { color <identifiersep> pack = resource <identifiersep> pack ; color <identifiersep> resources = resources ; } else if ( resource <identifiersep> pack instanceof image <identifiersep> pack && image <identifiersep> pack == null ) <ect>
<comment> public string get <identifiersep> i18n <identifiersep> string ( string key , string [ ] params , locale locale ) { string resource <identifiersep> string = do <identifiersep> get <identifiersep> i18string ( key , locale ) ; if ( resource <identifiersep> string == null ) { <LOG> return ' ! ' + key + ' ! ' ; } if ( params != null ) { resource <identifiersep> string = message <identifiersep> format . format ( resource <identifiersep> string , ( object [ ] ) params ) ; } return process <identifiersep> i18n <identifiersep> string ( resource <identifiersep> string ) ; <ect>
<comment> public int get <identifiersep> settings <identifiersep> int ( string key ) { string resource <identifiersep> string = get <identifiersep> settings <identifiersep> string ( key ) ; if ( resource <identifiersep> string == null ) { <LOG> return 0 ; } return integer . parse <identifiersep> int ( resource <identifiersep> string ) ; } <comment> <ect>
public input <identifiersep> stream get <identifiersep> settings <identifiersep> input <identifiersep> stream ( string stream <identifiersep> key , class < ? > resource <identifiersep> class ) { string path = get <identifiersep> settings <identifiersep> string ( stream <identifiersep> key ) ; if ( path == null || path . length ( ) == 0 ) { <LOG> return null ; } return resource <identifiersep> class . get <identifiersep> class <identifiersep> loader ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( path ) ; } <comment> <ect>
this . account <identifiersep> info <identifiersep> op <identifiersep> set . add <identifiersep> detail ( new <identifiersep> detail ) ; else this . account <identifiersep> info <identifiersep> op <identifiersep> set . replace <identifiersep> detail ( old <identifiersep> detail , new <identifiersep> detail ) ; account <identifiersep> info <identifiersep> op <identifiersep> set . save ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> } fire <identifiersep> avatar <identifiersep> changed ( avatar ) ; } public void add <identifiersep> avatar <identifiersep> listener ( avatar <identifiersep> listener listener ) { synchronized ( this . avatar <identifiersep> listeners ) { if ( ! this . avatar <identifiersep> listeners . contains ( listener ) ) <ect>
<comment> break ; } } } catch ( throwable e ) { <LOG> } } } <comment> <ect>
<comment> <LOG> return - 1 ; } new <identifiersep> document . set <identifiersep> state ( conference <identifiersep> info <identifiersep> document . state . full ) ; } else if ( users <identifiersep> state == conference <identifiersep> info <identifiersep> document . state . deleted ) { try { <ect>
{ try { new <identifiersep> document = new conference <identifiersep> info <identifiersep> document ( our <identifiersep> document ) ; } catch ( xml <identifiersep> exception e ) { <LOG> return - 1 ; } new <identifiersep> document . set <identifiersep> version ( diff . get <identifiersep> version ( ) ) ; new <identifiersep> document . set <identifiersep> entity ( diff . get <identifiersep> entity ( ) ) ; new <identifiersep> document . set <identifiersep> user <identifiersep> count ( diff . get <identifiersep> user <identifiersep> count ( ) ) ; for ( conference <identifiersep> info <identifiersep> document . user user : diff . get <identifiersep> users ( ) ) { <ect>
{ try { document = xml <identifiersep> utils . create <identifiersep> document ( ) ; } catch ( exception e ) { <LOG> throw ( new xml <identifiersep> exception ( e . get <identifiersep> message ( ) ) ) ; } conference <identifiersep> info = document . create <identifiersep> element <identifiersep> ns ( namespace , conference <identifiersep> info <identifiersep> element <identifiersep> name ) ; document . append <identifiersep> child ( conference <identifiersep> info ) ; set <identifiersep> version ( 1 ) ; conference <identifiersep> description <ect>
int ret = - 1 ; try { ret = integer . parse <identifiersep> int ( user <identifiersep> count . get <identifiersep> text <identifiersep> content ( ) ) ; } catch ( exception e ) { <LOG> } return ret ; } <comment> <ect>
buf , buf . length , control <identifiersep> address . get <identifiersep> address ( ) , control <identifiersep> address . get <identifiersep> port ( ) ) ) ; } } } } catch ( exception e ) { <LOG> } } <comment> <ect>
<comment> public void set <identifiersep> locally <identifiersep> on <identifiersep> hold ( boolean locally <identifiersep> on <identifiersep> hold ) { <LOG> this . locally <identifiersep> on <identifiersep> hold = locally <identifiersep> on <identifiersep> hold ; <comment> <ect>
<comment> public void start ( ) throws illegal <identifiersep> state <identifiersep> exception { <LOG> media <identifiersep> stream stream ; stream = get <identifiersep> stream ( media <identifiersep> type . audio ) ; if ( ( stream != null ) && ! stream . is <identifiersep> started ( ) && is <identifiersep> local <identifiersep> audio <identifiersep> transmission <identifiersep> enabled ( ) ) { <ect>
private void add <identifiersep> operation <identifiersep> set <identifiersep> basic <identifiersep> telephony <identifiersep> listener ( operation <identifiersep> set <identifiersep> basic <identifiersep> telephony < ? extends protocol <identifiersep> provider <identifiersep> service > telephony ) { { <LOG> } telephony . add <identifiersep> call <identifiersep> listener ( listener ) ; } <comment> <ect>
<comment> private void handle <identifiersep> call <identifiersep> event ( int type , call <identifiersep> event ev ) { call call = ev . get <identifiersep> source <identifiersep> call ( ) ; { <LOG> } switch ( type ) { case call <identifiersep> event . call <identifiersep> ended : remove <identifiersep> call <identifiersep> listener ( call ) ; break ; case call <identifiersep> event . call <identifiersep> initiated : <ect>
telephony . hangup <identifiersep> call <identifiersep> peer ( peer , hangup <identifiersep> reason <identifiersep> busy <identifiersep> here , null ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> } } } } <comment> <ect>
{ object service = bundle <identifiersep> context . get <identifiersep> service ( ev . get <identifiersep> service <identifiersep> reference ( ) ) ; if ( service instanceof protocol <identifiersep> provider <identifiersep> service ) { { <LOG> } operation <identifiersep> set <identifiersep> basic <identifiersep> telephony < ? > telephony = ( ( protocol <identifiersep> provider <identifiersep> service ) service ) . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> basic <identifiersep> telephony . class ) ; if ( telephony != null ) { switch ( ev . get <identifiersep> type ( ) ) <ect>
{ run ( ) ; } else { { <LOG> } } } <comment> <ect>
if ( ! protocol <identifiersep> provider <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> boolean ( pname <identifiersep> on <identifiersep> the <identifiersep> phone <identifiersep> status <identifiersep> enabled , false ) ) { { <LOG> } forget <identifiersep> presence <identifiersep> statuses ( ) ; return ; } service <identifiersep> reference [ ] pps <identifiersep> refs ; try { pps <identifiersep> refs <ect>
= protocol <identifiersep> provider <identifiersep> activator . get <identifiersep> calendar <identifiersep> service ( ) ; if ( ! is <identifiersep> on <identifiersep> the <identifiersep> phone && calendar != null && calendar . on <identifiersep> the <identifiersep> phone <identifiersep> status <identifiersep> changed ( presence <identifiersep> statuses ) ) { { <LOG> } forget <identifiersep> presence <identifiersep> statuses ( ) ; return ; } for ( service <identifiersep> reference pps <identifiersep> ref : pps <identifiersep> refs ) { protocol <identifiersep> provider <identifiersep> service pps = ( protocol <identifiersep> provider <identifiersep> service ) <ect>
operation <identifiersep> set <identifiersep> presence presence = pps . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> presence . class ) ; if ( presence == null ) { { <LOG> } <comment> forget <identifiersep> presence <identifiersep> status ( pps ) ; <ect>
presence <identifiersep> status on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status = find <identifiersep> on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status ( presence ) ; if ( on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status == null ) { { <LOG> } <comment> forget <identifiersep> presence <identifiersep> status ( pps ) ; <ect>
collection < subscription <identifiersep> listener > listeners ; synchronized ( subscription <identifiersep> listeners ) { listeners = new array <identifiersep> list < subscription <identifiersep> listener > ( subscription <identifiersep> listeners ) ; } <LOG> + <string_literal> + evt ) ; for ( subscription <identifiersep> listener listener : listeners ) switch ( event <identifiersep> id ) { case subscription <identifiersep> event . subscription <identifiersep> created : listener . subscription <identifiersep> created ( evt ) ; <ect>
<comment> public void fire <identifiersep> conference <identifiersep> member <identifiersep> error <identifiersep> event ( string error <identifiersep> message ) { if ( error <identifiersep> message == null || error <identifiersep> message . length ( ) == 0 ) { <LOG> + <string_literal> ) ; return ; } fire <identifiersep> call <identifiersep> peer <identifiersep> conference <identifiersep> event ( new call <identifiersep> peer <identifiersep> conference <identifiersep> event ( this , call <identifiersep> peer <identifiersep> conference <identifiersep> event <ect>
if ( ! sparkle <identifiersep> activator . sparkle <identifiersep> lib <identifiersep> loaded ) { system . load <identifiersep> library ( <string_literal> ) ; sparkle <identifiersep> activator . sparkle <identifiersep> lib <identifiersep> loaded = true ; } } catch ( throwable t ) { <LOG> logger . debug ( <string_literal> , t ) ; return ; } string download <identifiersep> link = get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> string ( prop <identifiersep> update <identifiersep> link ) ; string title = resource <identifiersep> management <identifiersep> service <identifiersep> utils . get <identifiersep> service ( bundle <identifiersep> context ) <ect>
title += <string_literal> ; <comment> <LOG> } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bc ) { <LOG> resource <identifiersep> management <identifiersep> service resources = growl <identifiersep> notification <identifiersep> activator . get <identifiersep> resources ( ) ; byte [ ] sip <identifiersep> icon = resources . get <identifiersep> image <identifiersep> in <identifiersep> bytes ( <string_literal> ) ; string [ ] dict = { show <identifiersep> popup <identifiersep> message <identifiersep> type } ; <ect>
{ public void run ( ) { fire <identifiersep> popup <identifiersep> message <identifiersep> clicked ( new systray <identifiersep> popup <identifiersep> message <identifiersep> event ( this , context ) ) ; <LOG> } } ) . start ( ) ; } <comment> <ect>
handler . start ( bundle <identifiersep> context ) ; bundle <identifiersep> context . register <identifiersep> service ( popup <identifiersep> message <identifiersep> handler . class . get <identifiersep> name ( ) , handler , null ) ; <LOG> } <comment> <ect>
= new popup <identifiersep> message ( title , message , icon , tag ) ; popup <identifiersep> msg . set <identifiersep> timeout ( action . get <identifiersep> timeout ( ) ) ; popup <identifiersep> msg . set <identifiersep> group ( action . get <identifiersep> group <identifiersep> name ( ) ) ; systray . show <identifiersep> popup <identifiersep> message ( popup <identifiersep> msg ) ; } else if ( message == null ) { <LOG> } <comment> <ect>
class . for <identifiersep> name ( <string_literal> ) . get <identifiersep> method ( <string_literal> ) ; toolkit = get <identifiersep> default <identifiersep> toolkit <identifiersep> method . invoke ( null ) ; beep <identifiersep> method = toolkit . get <identifiersep> class ( ) . get <identifiersep> method ( <string_literal> ) ; } catch ( throwable t ) { <LOG> } } <comment> <ect>
popup <identifiersep> message <identifiersep> handler = new popup <identifiersep> message <identifiersep> notification <identifiersep> handler <identifiersep> impl ( ) ; sound <identifiersep> handler = new sound <identifiersep> notification <identifiersep> handler <identifiersep> impl ( ) ; notification <identifiersep> service . add <identifiersep> action <identifiersep> handler ( command <identifiersep> handler ) ; notification <identifiersep> service . add <identifiersep> action <identifiersep> handler ( log <identifiersep> message <identifiersep> handler ) ; notification <identifiersep> service . add <identifiersep> action <identifiersep> handler ( popup <identifiersep> message <identifiersep> handler ) ; notification <identifiersep> service . add <identifiersep> action <identifiersep> handler ( sound <identifiersep> handler ) ; <LOG> } finally { logger . log <identifiersep> exit ( ) ; } } public void stop ( bundle <identifiersep> context bc ) throws exception { notification <identifiersep> service . remove <identifiersep> action <identifiersep> handler ( <ect>
. get <identifiersep> runtime ( ) . exec ( <string_literal> + url ) ; } else { string browser = get <identifiersep> linux <identifiersep> browser ( ) ; if ( browser == null ) <LOG> else runtime . get <identifiersep> runtime ( ) . exec ( new string [ ] { browser , url } ) ; } } <comment> <ect>
try { ks = key <identifiersep> store . get <identifiersep> instance ( ts <identifiersep> type ) ; ks . load ( null , null ) ; } catch ( exception e ) { <LOG> } } tm <identifiersep> factory . init ( ks ) ; for ( trust <identifiersep> manager m : tm <identifiersep> factory . get <identifiersep> trust <identifiersep> managers ( ) ) { if ( m instanceof x509extended <identifiersep> trust <identifiersep> manager ) { default <identifiersep> tm = ( x509extended <identifiersep> trust <identifiersep> manager ) m ; <ect>
{ new <identifiersep> chain . add ( cert ) ; found <identifiersep> parent = true ; current = cert ; break ; <comment> <LOG> } } chain <identifiersep> lookup <identifiersep> count ++ ; } while ( found <identifiersep> parent && chain <identifiersep> lookup <identifiersep> count < <number_literal> ) ; chain = new <identifiersep> chain . to <identifiersep> array ( chain ) ; return chain ; } } ; } protected class browser <identifiersep> like <identifiersep> hostname <identifiersep> matcher <ect>
bundle <identifiersep> context . register <identifiersep> service ( provisioning <identifiersep> discovery <identifiersep> service . class . get <identifiersep> name ( ) , provisioning <identifiersep> service , null ) ; <LOG> } <comment> <ect>
try { discover = new mdns <identifiersep> provisioning <identifiersep> discover ( ) ; discover . add <identifiersep> discovery <identifiersep> listener ( this ) ; } catch ( exception e ) { <LOG> } } <comment> @ override <ect>
try { jmdns . close ( ) ; jmdns = null ; } catch ( exception e ) { <LOG> } return ( url . to <identifiersep> string ( ) . length ( ) > 0 ) ? url . to <identifiersep> string ( ) : null ; } <comment> <ect>
return ; plugin <identifiersep> component <identifiersep> factory factory = ( plugin <identifiersep> component <identifiersep> factory ) s <identifiersep> service ; switch ( event . get <identifiersep> type ( ) ) { case service <identifiersep> event . registered : <LOG> this . fire <identifiersep> plugin <identifiersep> event ( factory , plugin <identifiersep> component <identifiersep> event . plugin <identifiersep> component <identifiersep> added ) ; break ; case service <identifiersep> event . unregistering : this . fire <identifiersep> plugin <identifiersep> event ( factory , plugin <identifiersep> component <identifiersep> event . plugin <identifiersep> component <identifiersep> removed ) ; <ect>
html <identifiersep> document doc = ( html <identifiersep> document ) editor <identifiersep> pane . get <identifiersep> document ( ) ; try { doc . insert <identifiersep> string ( caret <identifiersep> position , <string_literal> , null ) ; } catch ( bad <identifiersep> location <identifiersep> exception e1 ) { <LOG> } editor <identifiersep> pane . set <identifiersep> caret <identifiersep> position ( caret <identifiersep> position + 1 ) ; } } <comment> <ect>
{ try { undo . redo ( ) ; } catch ( cannot <identifiersep> redo <identifiersep> exception e ) { <LOG> } } <comment> public void key <identifiersep> typed ( key <identifiersep> event e ) <ect>
try { document doc = editor <identifiersep> pane . get <identifiersep> document ( ) ; return doc . get <identifiersep> text ( 0 , doc . get <identifiersep> length ( ) ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } return null ; } <comment> public void clear <identifiersep> write <identifiersep> area ( ) { <ect>
= doc . get <identifiersep> character <identifiersep> element ( editor <identifiersep> pane . get <identifiersep> caret <identifiersep> position ( ) ) ; try { doc . insert <identifiersep> after <identifiersep> end ( current <identifiersep> element , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } this . editor <identifiersep> pane . set <identifiersep> caret <identifiersep> position ( doc . get <identifiersep> length ( ) ) ; } <comment> <ect>
= gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { ser <identifiersep> refs = null ; <LOG> } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
{ string text = doc . get <identifiersep> text ( 0 , doc . get <identifiersep> length ( ) ) ; if ( text == null || text . equals ( <string_literal> ) ) return true ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } return false ; } <comment> <ect>
final chat <identifiersep> transport file <identifiersep> transfer <identifiersep> transport = find <identifiersep> file <identifiersep> transfer <identifiersep> chat <identifiersep> transport ( ) ; <comment> <LOG> this . add <identifiersep> error <identifiersep> message ( chat <identifiersep> session . get <identifiersep> chat <identifiersep> name ( ) , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { file . get <identifiersep> name ( ) } ) , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <ect>
{ chat <identifiersep> session . get <identifiersep> current <identifiersep> chat <identifiersep> transport ( ) . send <identifiersep> instant <identifiersep> message ( message <identifiersep> text , mime <identifiersep> type ) ; } stop <identifiersep> message <identifiersep> correction ( ) ; } catch ( illegal <identifiersep> state <identifiersep> exception ex ) { <LOG> this . add <identifiersep> message ( chat <identifiersep> session . get <identifiersep> current <identifiersep> chat <identifiersep> transport ( ) . get <identifiersep> name ( ) , new date ( ) , chat . outgoing <identifiersep> message , message <identifiersep> text , mime <identifiersep> type ) ; <ect>
<comment> public void fire <identifiersep> chat <identifiersep> focus <identifiersep> event ( int event <identifiersep> id ) { chat <identifiersep> focus <identifiersep> event evt = new chat <identifiersep> focus <identifiersep> event ( this , event <identifiersep> id ) ; <LOG> iterable < chat <identifiersep> focus <identifiersep> listener > listeners ; synchronized ( focus <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> focus <identifiersep> listener > ( focus <identifiersep> listeners ) ; } for ( chat <identifiersep> focus <identifiersep> listener listener : listeners ) { <ect>
( ( incoming <identifiersep> file <identifiersep> transfer <identifiersep> request ) descriptor ) . reject <identifiersep> file ( ) ; } else if ( descriptor instanceof file <identifiersep> transfer ) { ( ( file <identifiersep> transfer ) descriptor ) . cancel ( ) ; } } catch ( throwable t ) { <LOG> } } } <comment> private class divider <identifiersep> location <identifiersep> listener implements property <identifiersep> change <identifiersep> listener { public void property <identifiersep> change ( property <identifiersep> change <identifiersep> event evt ) <ect>
{ tn <identifiersep> operation <identifiersep> set . send <identifiersep> typing <identifiersep> notification ( contact , typing <identifiersep> state ) ; return chat <identifiersep> panel . typing <identifiersep> notification <identifiersep> successfully <identifiersep> sent ; } catch ( exception ex ) { <LOG> return chat <identifiersep> panel . typing <identifiersep> notification <identifiersep> send <identifiersep> failed ; } } return chat <identifiersep> panel . typing <identifiersep> notification <identifiersep> send <identifiersep> failed ; } <comment> <ect>
try { gui <identifiersep> activator . get <identifiersep> desktop <identifiersep> service ( ) . open ( download <identifiersep> file ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { <LOG> this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) { <ect>
this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( unsupported <identifiersep> operation <identifiersep> exception e ) { <LOG> this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( security <identifiersep> exception e ) { <ect>
this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( exception e ) { <ect>
logger . debug ( <string_literal> + download <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } download <identifiersep> file = new file ( download <identifiersep> dir , incoming <identifiersep> file <identifiersep> name ) ; <comment> <ect>
= gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { ser <identifiersep> refs = null ; <LOG> } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
chat <identifiersep> panel . document . set <identifiersep> outer <identifiersep> html ( elem , new <identifiersep> chat <identifiersep> string ) ; msg <identifiersep> id <identifiersep> to <identifiersep> chat <identifiersep> string . put ( current <identifiersep> message <identifiersep> id , new <identifiersep> chat <identifiersep> string ) ; } catch ( bad <identifiersep> location <identifiersep> exception ex ) { <LOG> } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } } @ override protected object construct ( ) throws exception { <ect>
+ current <identifiersep> link <identifiersep> position + <string_literal> + gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ; new <identifiersep> chat <identifiersep> string = new <identifiersep> chat <identifiersep> string . replace ( old , replacement ) ; } catch ( exception ex ) { <LOG> } return new <identifiersep> chat <identifiersep> string ; } } ; worker . start ( ) ; this . set <identifiersep> visible ( false ) ; } else if ( arg0 . get <identifiersep> source ( ) . equals ( cancel <identifiersep> button ) ) { <ect>
{ chat <identifiersep> room . ban <identifiersep> participant ( ( chat <identifiersep> room <identifiersep> member ) chat <identifiersep> contact . get <identifiersep> descriptor ( ) , reason ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> string error <identifiersep> title = gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ; string error <identifiersep> message <identifiersep> key ; switch ( e . get <identifiersep> error <identifiersep> code ( ) ) { case operation <identifiersep> failed <identifiersep> exception . not <identifiersep> enough <identifiersep> privileges : error <identifiersep> message <identifiersep> key = <ect>
chat <identifiersep> panel . send <identifiersep> file ( file ) ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } } if ( t . is <identifiersep> data <identifiersep> flavor <identifiersep> supported ( uri <identifiersep> list <identifiersep> flavor ) && os <identifiersep> utils . is <identifiersep> linux ) { <ect>
chat <identifiersep> panel . send <identifiersep> file ( file ) ; data <identifiersep> processed = true ; } return data <identifiersep> processed ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } } if ( t . is <identifiersep> data <identifiersep> flavor <identifiersep> supported ( ui <identifiersep> contact <identifiersep> data <identifiersep> flavor ) ) { <ect>
try { o = t . get <identifiersep> transfer <identifiersep> data ( ui <identifiersep> contact <identifiersep> data <identifiersep> flavor ) ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } if ( o instanceof contact <identifiersep> node ) { <ect>
( ( j <identifiersep> text <identifiersep> component ) comp ) . replace <identifiersep> selection ( buff <identifiersep> to <identifiersep> paste . to <identifiersep> string ( ) ) ; return true ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception ufe ) { <LOG> } catch ( io <identifiersep> exception ioe ) { logger . debug ( <string_literal> , ioe ) ; } } return false ; } } <ect>
try { doc . insert <identifiersep> after <identifiersep> end ( root . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , chat <identifiersep> string ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } public void message <identifiersep> delivered ( chat <identifiersep> room <identifiersep> message <identifiersep> delivered <identifiersep> event evt ) { } public void message <identifiersep> delivery <identifiersep> failed ( chat <identifiersep> room <identifiersep> message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { } public void message <identifiersep> received ( chat <identifiersep> room <identifiersep> message <identifiersep> received <identifiersep> event evt ) { } <ect>
{ try { close <identifiersep> chat <identifiersep> panel ( chat <identifiersep> panel ) ; } catch ( exception e ) { <LOG> } } } <comment> if ( ( current <identifiersep> chat != null ) && chat <identifiersep> panels . contains ( current <identifiersep> chat ) ) close <identifiersep> chat <identifiersep> panel ( current <identifiersep> chat ) ; <comment> <ect>
element e = document . get <identifiersep> element ( root , attribute . id , chat <identifiersep> html <identifiersep> utils . message <identifiersep> text <identifiersep> id + message <identifiersep> uid ) ; if ( e == null ) { <LOG> return null ; } object original <identifiersep> message = e . get <identifiersep> attributes ( ) . get <identifiersep> attribute ( chat <identifiersep> html <identifiersep> utils . original <identifiersep> message <identifiersep> attribute ) ; if ( original <identifiersep> message == null ) { logger . warn ( <string_literal> + message <identifiersep> uid + <ect>
swing <identifiersep> utilities . invoke <identifiersep> later ( scroll <identifiersep> to <identifiersep> bottom <identifiersep> runnable ) ; } catch ( bad <identifiersep> location <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } catch ( io <identifiersep> exception ex ) { <LOG> } } finish <identifiersep> message <identifiersep> add ( new <identifiersep> message ) ; } <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } finish <identifiersep> message <identifiersep> add ( new <identifiersep> message ) ; } <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } string last <identifiersep> elem <identifiersep> content = get <identifiersep> element <identifiersep> content ( last <identifiersep> message <identifiersep> uid , message ) ; if ( last <identifiersep> elem <identifiersep> content != null ) { <ect>
try { <comment> <LOG> } if ( first <identifiersep> msg <identifiersep> element . get <identifiersep> name ( ) . equals ( <string_literal> ) ) { <comment> <ect>
try { document . insert <identifiersep> string ( document . get <identifiersep> length ( ) , <string_literal> , style ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { <LOG> } } } <comment> <ect>
+ container . container <identifiersep> main <identifiersep> window . get <identifiersep> id ( ) + <string_literal> + container . container <identifiersep> id + <string_literal> + container . container <identifiersep> status <identifiersep> bar . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception exc ) { ser <identifiersep> refs = null ; <LOG> } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
<comment> private void dispatch <identifiersep> event <identifiersep> to <identifiersep> check <identifiersep> box ( mouse <identifiersep> event event ) { if ( enable <identifiersep> account <identifiersep> worker != null ) { <LOG> return ; } int mouse <identifiersep> index = this . location <identifiersep> to <identifiersep> index ( event . get <identifiersep> point ( ) ) ; logger . trace ( <string_literal> + mouse <identifiersep> index ) ; <comment> <ect>
= gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { ser <identifiersep> refs = null ; <LOG> } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
account <identifiersep> registration <identifiersep> wizard . class , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <comment> <LOG> return ; } <comment> <ect>
account <identifiersep> registration <identifiersep> wizard . class , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <comment> <LOG> return ; } <comment> <ect>
{ load <identifiersep> error <identifiersep> message ( gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { e . get <identifiersep> message ( ) } ) ) ; } } catch ( exception e ) { <LOG> <comment> <ect>
{ ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception exc ) { <LOG> } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { final plugin <identifiersep> component <identifiersep> factory f = ( plugin <identifiersep> component <identifiersep> factory ) gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
try { if ( result == undefined <identifiersep> code ) lock . wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } } return result ; } <comment> <ect>
public void message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) { contact contact = evt . get <identifiersep> destination <identifiersep> contact ( ) ; meta <identifiersep> contact meta <identifiersep> contact = gui <identifiersep> activator . get <identifiersep> contact <identifiersep> list <identifiersep> service ( ) . find <identifiersep> meta <identifiersep> contact <identifiersep> by <identifiersep> contact ( contact ) ; <LOG> chat <identifiersep> panel chat <identifiersep> panel = chat <identifiersep> window <identifiersep> manager . get <identifiersep> contact <identifiersep> chat ( meta <identifiersep> contact , false ) ; if ( chat <identifiersep> panel != null ) { message msg = evt . get <identifiersep> source <identifiersep> message ( ) ; protocol <identifiersep> provider <identifiersep> service protocol <identifiersep> provider <ect>
<comment> <LOG> } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { custom <identifiersep> contact <identifiersep> actions <identifiersep> service < ? > custom <identifiersep> action <identifiersep> service = ( custom <identifiersep> contact <identifiersep> actions <identifiersep> service < ? > ) <ect>
<comment> public filter <identifiersep> query apply <identifiersep> filter ( contact <identifiersep> list <identifiersep> filter filter ) { <LOG> if ( current <identifiersep> filter <identifiersep> query != null && ! current <identifiersep> filter <identifiersep> query . is <identifiersep> canceled ( ) ) current <identifiersep> filter <identifiersep> query . cancel ( ) ; root <identifiersep> ui <identifiersep> group = null ; current <identifiersep> filter <identifiersep> query = new ui <identifiersep> filter <identifiersep> query ( this ) ; if ( filter <identifiersep> thread == null ) { <ect>
listener . contact <identifiersep> selected ( event ) ; break ; case contact <identifiersep> list <identifiersep> event . group <identifiersep> selected : listener . group <identifiersep> selected ( event ) ; break ; default : <LOG> } } } } <comment> private void expand <identifiersep> group ( group <identifiersep> node group <identifiersep> node ) { <ect>
{ logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } if ( o instanceof collection ) { chat <identifiersep> panel chat <identifiersep> panel = get <identifiersep> chat <identifiersep> panel ( ) ; if ( chat <identifiersep> panel != null ) { collection < file > files = ( collection < file > ) o ; <ect>
{ logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } if ( o instanceof contact <identifiersep> node && comp instanceof tree <identifiersep> contact <identifiersep> list ) { ui <identifiersep> contact transferred <identifiersep> contact = ( ( contact <identifiersep> node ) o ) . get <identifiersep> contact <identifiersep> descriptor ( ) ; <comment> <ect>
try { o = t . get <identifiersep> transfer <identifiersep> data ( ui <identifiersep> contact <identifiersep> data <identifiersep> flavor ) ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } if ( o instanceof contact <identifiersep> node ) { <ect>
finally { reader . close ( ) ; } } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } } if ( callee == null ) return false ; <ect>
= gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ise ) { ser <identifiersep> refs = null ; <LOG> } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; <ect>
{ try { telephony . transfer ( peer , target ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> + <string_literal> + target , ex ) ; } } } <comment> <ect>
try { quality <identifiersep> control . set <identifiersep> preferred <identifiersep> remote <identifiersep> send <identifiersep> max <identifiersep> preset ( quality <identifiersep> preset ) ; } catch ( exception e ) { <LOG> resource <identifiersep> management <identifiersep> service resources = gui <identifiersep> activator . get <identifiersep> resources ( ) ; new error <identifiersep> dialog ( null , resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , resources . get <identifiersep> i18n <identifiersep> string ( <ect>
exception = e ; } catch ( parse <identifiersep> exception e ) { exception = e ; } if ( exception != null ) { <LOG> new error <identifiersep> dialog ( null , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , exception . get <identifiersep> message ( ) , error <identifiersep> dialog . error ) <ect>
try { telephony . put <identifiersep> off <identifiersep> hold ( call <identifiersep> peer ) ; thread . sleep ( <number_literal> ) ; } catch ( exception ofe ) { <LOG> } } } } @ override public void run ( ) { <comment> <ect>
if ( ! initial <identifiersep> frame ) { call <identifiersep> desktop <identifiersep> frames . put ( call , frame ) ; add <identifiersep> call <identifiersep> listener ( call , frame ) ; add <identifiersep> frame <identifiersep> listener ( call , frame , sharing <identifiersep> region ) ; add <identifiersep> desktop <identifiersep> sharing <identifiersep> listener ( call , frame ) ; <LOG> if ( sharing <identifiersep> region <identifiersep> width > - 1 && sharing <identifiersep> region <identifiersep> height > - 1 ) sharing <identifiersep> region . set <identifiersep> preferred <identifiersep> size ( new dimension ( sharing <identifiersep> region <identifiersep> width , sharing <identifiersep> region <identifiersep> height ) ) ; frame . pack ( ) ; if ( initial <identifiersep> frame <identifiersep> x != - 1 || initial <identifiersep> frame <identifiersep> y != - 1 ) frame . set <identifiersep> location ( initial <identifiersep> frame <identifiersep> x , initial <identifiersep> frame <identifiersep> y ) ; <ect>
error <identifiersep> dialog <identifiersep> message , e ) ; } } ) ; return ; } systray <identifiersep> service systray = gui <identifiersep> activator . get <identifiersep> systray <identifiersep> service ( ) ; if ( systray == null ) { <LOG> return ; } if ( listener == null ) { listener = new systray <identifiersep> popup <identifiersep> message <identifiersep> listener ( ) { public void popup <identifiersep> message <identifiersep> clicked ( systray <identifiersep> popup <identifiersep> message <identifiersep> event evt ) <ect>
new thread ( ) { @ override public void run ( ) { <LOG> bundle <identifiersep> context . register <identifiersep> service ( ui <identifiersep> service . class . get <identifiersep> name ( ) , ui <identifiersep> service , null ) ; logger . info ( <string_literal> ) ; <ect>
<comment> public void stop ( bundle <identifiersep> context b <identifiersep> context ) throws exception { <LOG> is <identifiersep> started = false ; gui <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . remove <identifiersep> property <identifiersep> change <identifiersep> listener ( ui <identifiersep> service ) ; b <identifiersep> context . remove <identifiersep> service <identifiersep> listener ( ui <identifiersep> service ) ; alert <identifiersep> ui <identifiersep> service . dispose ( ) ; } <comment> <ect>
{ if ( image <identifiersep> url != null ) return image <identifiersep> url . to <identifiersep> uri ( ) . to <identifiersep> string ( ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <LOG> } return null ; } <comment> <ect>
this . set <identifiersep> tool <identifiersep> tip <identifiersep> image ( icon ) ; image <identifiersep> icon image = scale <identifiersep> file <identifiersep> icon ( icon , <number_literal> , <number_literal> ) ; this . set <identifiersep> icon ( image ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <LOG> this . set <identifiersep> icon ( new image <identifiersep> icon ( image <identifiersep> loader . get <identifiersep> image ( image <identifiersep> loader . default <identifiersep> file <identifiersep> icon ) ) ) ; } } else { icon icon = file <identifiersep> utils . get <identifiersep> icon ( file ) ; if ( icon == null ) <ect>
if ( phone <identifiersep> number != null ) chat <identifiersep> transport . send <identifiersep> sms <identifiersep> message ( phone <identifiersep> number , message ) ; else chat <identifiersep> transport . send <identifiersep> sms <identifiersep> message ( message ) ; } } catch ( illegal <identifiersep> state <identifiersep> exception ex ) { <LOG> chat <identifiersep> panel . add <identifiersep> message ( phone <identifiersep> number , new date ( ) , chat . outgoing <identifiersep> message , message , <string_literal> ) ; <ect>
+ <string_literal> ) ; try { style <identifiersep> sheet . load <identifiersep> rules ( r , null ) ; } catch ( io <identifiersep> exception ex ) { <LOG> } finally { try { r . close ( ) ; } catch ( io <identifiersep> exception ex ) <ect>
try { image = image <identifiersep> io . read ( path ) ; loaded <identifiersep> images . put ( image <identifiersep> id , image ) ; } catch ( exception ex ) { <LOG> } } } return image ; } <comment> <ect>
{ logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } if ( o instanceof collection ) { iterator < ? > c = ( ( collection < ? > ) o ) . iterator ( ) ; while ( c . has <identifiersep> next ( ) ) { object next <identifiersep> o = c . next ( ) ; <ect>
+ container . container <identifiersep> id + <string_literal> + container <identifiersep> id . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception exc ) { <LOG> } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory = ( plugin <identifiersep> component <identifiersep> factory ) <ect>
local <identifiersep> host = address ; done = true ; break ; } } } } } } catch ( exception e ) { <comment> <LOG> logger . trace ( <string_literal> + local <identifiersep> host + <string_literal> ) ; return local <identifiersep> host ; } <comment> <ect>
{ logger . info ( <string_literal> + laddr + <string_literal> + port ) ; <LOG> } } port ++ ; if ( port > max <identifiersep> port ) port = min <identifiersep> port ; } throw new bind <identifiersep> exception ( <string_literal> + min <identifiersep> port + <string_literal> + ( port - 1 ) ) ; } <comment> <ect>
{ try { check <identifiersep> network <identifiersep> interfaces ( false , 0 , true ) ; } catch ( socket <identifiersep> exception e ) { <LOG> } } <comment> void add <identifiersep> network <identifiersep> configuration <identifiersep> change <identifiersep> listener ( <ect>
{ try { check <identifiersep> network <identifiersep> interfaces ( true , 0 , true ) ; } catch ( socket <identifiersep> exception e ) { <LOG> } } else if ( event . get <identifiersep> event <identifiersep> id ( ) == system <identifiersep> activity <identifiersep> event . event <identifiersep> dns <identifiersep> change ) { try { event <identifiersep> dispatcher . fire <identifiersep> change <identifiersep> event ( new change <identifiersep> event ( event . get <identifiersep> source ( ) , change <identifiersep> event . dns <identifiersep> change ) ) ; <ect>
<comment> <LOG> + <string_literal> + en . get <identifiersep> value ( ) ) ; } for ( map . entry < string , list < inet <identifiersep> address > > en : current <identifiersep> active <identifiersep> interfaces . entry <identifiersep> set ( ) ) { logger . info ( <string_literal> + en . get <identifiersep> key ( ) + <string_literal> + en . get <identifiersep> value ( ) ) ; <ect>
{ is <identifiersep> after <identifiersep> standby = false ; } <comment> <LOG> } synchronized ( this ) { try { wait ( check <identifiersep> interval ) ; } catch ( exception e ) { } } } } } <ect>
muc <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { protocol <identifiersep> provider . get <identifiersep> protocol <identifiersep> display <identifiersep> name ( ) } ) , ex ) ; } catch ( operation <identifiersep> not <identifiersep> supported <identifiersep> exception ex ) { <LOG> muc <identifiersep> activator . get <identifiersep> alert <identifiersep> ui <identifiersep> service ( ) . show <identifiersep> alert <identifiersep> dialog ( muc <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , muc <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { protocol <identifiersep> provider . get <identifiersep> protocol <identifiersep> display <identifiersep> name ( ) } ) , ex ) ; <ect>
. get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> multi <identifiersep> user <identifiersep> chat . class ) ; if ( multi <identifiersep> user <identifiersep> chat <identifiersep> op <identifiersep> set != null ) { this . add <identifiersep> chat <identifiersep> provider ( protocol <identifiersep> provider ) ; } } } catch ( invalid <identifiersep> syntax <identifiersep> exception e ) { <LOG> } } <comment> <ect>
<comment> public string get <identifiersep> color <identifiersep> string ( string key ) { string res = get <identifiersep> color <identifiersep> resources ( ) . get ( key ) ; if ( res == null ) { <LOG> return <string_literal> ; } else return res ; } <comment> <ect>
public url get <identifiersep> image <identifiersep> url ( string url <identifiersep> key ) { string path = get <identifiersep> image <identifiersep> path ( url <identifiersep> key ) ; if ( path == null || path . length ( ) == 0 ) { <LOG> return null ; } return get <identifiersep> image <identifiersep> url <identifiersep> for <identifiersep> path ( path ) ; } <comment> <ect>
try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return image ; } <comment> <ect>
{ try { password = crypto . decrypt ( get <identifiersep> encrypted ( account <identifiersep> prefix ) ) ; } catch ( exception ex ) { <LOG> <comment> <ect>
set <identifiersep> master <identifiersep> password ( master ) ; } return correct ; } catch ( crypto <identifiersep> exception e ) { if ( e . get <identifiersep> error <identifiersep> code ( ) == crypto <identifiersep> exception . wrong <identifiersep> key ) { <LOG> return false ; } else { <comment> <ect>
{ set <identifiersep> encrypted ( account <identifiersep> prefix , crypto . encrypt ( password ) ) ; set <identifiersep> unencrypted ( account <identifiersep> prefix , null ) ; return true ; } catch ( crypto <identifiersep> exception cex ) { <LOG> } } <comment> <ect>
<comment> set <identifiersep> master <identifiersep> password ( master ) ; } move <identifiersep> all <identifiersep> password <identifiersep> properties ( ) ; } else { <LOG> <comment> set <identifiersep> master <identifiersep> password ( null ) ; <ect>
throw ( thread <identifiersep> death ) thr ; arg <identifiersep> delegation <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( <string_literal> + uri <identifiersep> arg , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; <LOG> } } <comment> <ect>
port = get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> int ( proxy <identifiersep> info . connection <identifiersep> proxy <identifiersep> forward <identifiersep> dns <identifiersep> port <identifiersep> property <identifiersep> name , simple <identifiersep> resolver . default <identifiersep> port ) ; } catch ( number <identifiersep> format <identifiersep> exception ne ) { <LOG> } <comment> <ect>
<comment> <LOG> } } <comment> <ect>
catch ( socket <identifiersep> timeout <identifiersep> exception exc ) { logger . info ( <string_literal> ) ; exception = exc ; } catch ( throwable exc ) { <LOG> exception = exc ; } <comment> <ect>
else if ( exception instanceof socket <identifiersep> timeout <identifiersep> exception ) { logger . warn ( <string_literal> ) ; throw ( io <identifiersep> exception ) exception ; } else if ( exception instanceof io <identifiersep> exception ) { <LOG> throw ( io <identifiersep> exception ) exception ; } else if ( exception instanceof runtime <identifiersep> exception ) { logger . warn ( <string_literal> , exception ) ; throw ( runtime <identifiersep> exception ) exception ; <ect>
packet <identifiersep> logging <identifiersep> service . start ( ) ; bundle <identifiersep> context . register <identifiersep> service ( packet <identifiersep> logging <identifiersep> service . class . get <identifiersep> name ( ) , packet <identifiersep> logging <identifiersep> service , null ) ; <LOG> } } <comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) <ect>
<comment> if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; else <LOG> } } } } <comment> public synchronized void stop <identifiersep> running ( ) { stopped = true ; <ect>
{ try { dbus <identifiersep> conn = d <identifiersep> bus <identifiersep> connection . get <identifiersep> connection ( d <identifiersep> bus <identifiersep> connection . system ) ; } catch ( d <identifiersep> bus <identifiersep> exception e ) { <LOG> } } <comment> @ suppress <identifiersep> warnings ( <string_literal> ) public void start ( ) { <ect>
dbus <identifiersep> conn . remove <identifiersep> sig <identifiersep> handler ( d <identifiersep> bus <identifiersep> network <identifiersep> manager . state <identifiersep> change . class , this ) ; dbus <identifiersep> conn . remove <identifiersep> sig <identifiersep> handler ( d <identifiersep> bus <identifiersep> network <identifiersep> manager . state <identifiersep> changed . class , this ) ; } catch ( d <identifiersep> bus <identifiersep> exception e ) { <LOG> } } <comment> public void handle ( d <identifiersep> bus <identifiersep> signal d <identifiersep> bus <identifiersep> signal ) { <ect>
catch ( unsatisfied <identifiersep> link <identifiersep> error t ) { logger . error ( <string_literal> , t ) ; return ; } catch ( throwable t ) { <LOG> } } } <comment> <ect>
{ system <identifiersep> activity <identifiersep> event evt = new system <identifiersep> activity <identifiersep> event ( this , system <identifiersep> activity <identifiersep> event . event <identifiersep> system <identifiersep> idle ) ; <LOG> try { listener . activity <identifiersep> changed ( evt ) ; } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) <ect>
{ system <identifiersep> activity <identifiersep> event evt = new system <identifiersep> activity <identifiersep> event ( this , system <identifiersep> activity <identifiersep> event . event <identifiersep> system <identifiersep> idle <identifiersep> end ) ; <LOG> try { listener . activity <identifiersep> changed ( evt ) ; } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) <ect>
class <identifiersep> name = system <identifiersep> activity <identifiersep> manager <identifiersep> android <identifiersep> class ; } if ( class <identifiersep> name != null ) current <identifiersep> running <identifiersep> manager = ( system <identifiersep> activity <identifiersep> manager ) class . for <identifiersep> name ( class <identifiersep> name ) . new <identifiersep> instance ( ) ; } catch ( throwable t ) { <LOG> } } return current <identifiersep> running <identifiersep> manager ; } } <ect>
event <identifiersep> to <identifiersep> process . get <identifiersep> key ( ) , listeners <identifiersep> copy . get ( i ) ) ; } } event <identifiersep> to <identifiersep> process = null ; listeners <identifiersep> copy = null ; } } catch ( throwable t ) { <LOG> } } } <ect>
linux <identifiersep> loaded = true ; } } } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; else <LOG> } } <comment> private static native long alloc <identifiersep> and <identifiersep> init ( ) ; <ect>
event <identifiersep> object o = convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , ( chat <identifiersep> room ) descriptor ) ; result . add ( o ) ; } break ; } } catch ( io <identifiersep> exception ex ) { <LOG> } } return result ; } <comment> <ect>
{ result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , item ) ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } } <comment> <ect>
public void set <identifiersep> history <identifiersep> service ( history <identifiersep> service history <identifiersep> service ) throws illegal <identifiersep> argument <identifiersep> exception , io <identifiersep> exception { synchronized ( this . sync <identifiersep> root <identifiersep> history <identifiersep> service ) { this . history <identifiersep> service = history <identifiersep> service ; <LOG> } } <comment> public void unset <identifiersep> history <identifiersep> service ( history <identifiersep> service history <identifiersep> service ) <ect>
<comment> public void service <identifiersep> changed ( service <identifiersep> event service <identifiersep> event ) { object s <identifiersep> service = bundle <identifiersep> context . get <identifiersep> service ( service <identifiersep> event . get <identifiersep> service <identifiersep> reference ( ) ) ; <LOG> <comment> <ect>
return ; } logger . debug ( <string_literal> ) ; if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { <LOG> this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } else if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . unregistering ) { this . handle <identifiersep> provider <identifiersep> removed ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } } <comment> <ect>
op <identifiersep> set <identifiersep> sms . add <identifiersep> message <identifiersep> listener ( this ) ; if ( this . message <identifiersep> source <identifiersep> service != null ) op <identifiersep> set <identifiersep> sms . add <identifiersep> message <identifiersep> listener ( message <identifiersep> source <identifiersep> service ) ; } else { <LOG> } operation <identifiersep> set <identifiersep> multi <identifiersep> user <identifiersep> chat op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat = provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> multi <identifiersep> user <identifiersep> chat . class ) ; if ( op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat != null ) { iterator < chat <identifiersep> room > iter = op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat . get <identifiersep> currently <identifiersep> joined <identifiersep> chat <identifiersep> rooms ( ) . iterator ( ) ; <ect>
try { history history = this . get <identifiersep> history ( null , item ) ; readers . put ( item , history . get <identifiersep> reader ( ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } return readers ; } <comment> <ect>
while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( reader ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return result ; } <comment> <ect>
while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( reader ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return result ; } <comment> <ect>
{ result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( reader ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return result ; } <comment> <ect>
{ result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } collections . sort ( result , new chat <identifiersep> room <identifiersep> message <identifiersep> event <identifiersep> comparator < event <identifiersep> object > ( ) ) ; int to <identifiersep> index = count ; if ( to <identifiersep> index > result . size ( ) ) to <identifiersep> index = result . size ( ) ; return result . sub <identifiersep> list ( 0 , to <identifiersep> index ) ; <ect>
get <identifiersep> history <identifiersep> for <identifiersep> ad <identifiersep> hoc <identifiersep> multi <identifiersep> chat ( evt . get <identifiersep> source <identifiersep> ad <identifiersep> hoc <identifiersep> chat <identifiersep> room ( ) ) ; write <identifiersep> message ( history , <string_literal> , evt . get <identifiersep> message ( ) , evt . get <identifiersep> timestamp ( ) , false ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } public void message <identifiersep> delivery <identifiersep> failed ( ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { <comment> <ect>
&& timestamp . before ( after ) ) continue ; if ( record <identifiersep> provider . equals ( provider ) ) res . add ( contact ) ; } } } catch ( io <identifiersep> exception ex ) { <LOG> } return res ; } <comment> <ect>
else if ( prop <identifiersep> name . equals ( structure <identifiersep> names [ <number_literal> ] ) ) map . put ( prop <identifiersep> name , recent <identifiersep> msgs <identifiersep> ver ) ; } return map ; } } ) ; } catch ( io <identifiersep> exception ex ) { <LOG> return ; } } } @ override public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) { if ( is <identifiersep> sms <identifiersep> enabled && evt . get <identifiersep> event <identifiersep> type ( ) != message <identifiersep> received <identifiersep> event . sms <identifiersep> message <identifiersep> received ) <ect>
if ( caller == null ) throw new null <identifiersep> pointer <identifiersep> exception ( <string_literal> ) ; this . pending <identifiersep> searches . put ( query , new ldap <identifiersep> pending <identifiersep> search ( servers , caller ) ) ; for ( ldap <identifiersep> directory server : servers ) { if ( server == null ) <LOG> server . search <identifiersep> person ( query , this , search <identifiersep> settings ) ; } } <comment> <ect>
<comment> private initial <identifiersep> dir <identifiersep> context connect ( ) throws naming <identifiersep> exception { <LOG> long time0 = system . current <identifiersep> time <identifiersep> millis ( ) ; initial <identifiersep> dir <identifiersep> context dir <identifiersep> context = new initial <identifiersep> dir <identifiersep> context ( this . env ) ; long time1 = system . current <identifiersep> time <identifiersep> millis ( ) ; logger . trace ( <string_literal> + this + <string_literal> + ( time1 - time0 ) + <string_literal> ) ; <ect>
string [ ] returning <identifiersep> attributes = { <string_literal> } ; <comment> final search <identifiersep> controls search <identifiersep> ctl = new search <identifiersep> controls ( ) ; search <identifiersep> ctl . set <identifiersep> search <identifiersep> scope ( search <identifiersep> controls . object <identifiersep> scope ) ; search <identifiersep> ctl . set <identifiersep> returning <identifiersep> attributes ( returning <identifiersep> attributes ) ; search <identifiersep> ctl . set <identifiersep> time <identifiersep> limit ( <number_literal> ) ; <LOG> try { dir <identifiersep> context = connect ( ) ; naming <identifiersep> enumeration < ? > result = dir <identifiersep> context . search ( dn , <string_literal> , search <identifiersep> ctl ) ; while ( result . has <identifiersep> more ( ) ) <ect>
disconnect ( dir <identifiersep> context ) ; } } else { <comment> final search <identifiersep> controls search <identifiersep> ctl = new search <identifiersep> controls ( ) ; search <identifiersep> ctl . set <identifiersep> search <identifiersep> scope ( search <identifiersep> controls . onelevel <identifiersep> scope ) ; <LOG> try { dir <identifiersep> context = connect ( ) ; naming <identifiersep> enumeration < ? > result = dir <identifiersep> context . search ( dn , <string_literal> , search <identifiersep> ctl ) ; while ( result . has <identifiersep> more ( ) ) <ect>
{ history <identifiersep> record hr = rs . next ( ) ; result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> call <identifiersep> record ( hr ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( history <identifiersep> reader ) ; } catch ( io <identifiersep> exception ex ) { <LOG> } return result ; } <comment> <ect>
while ( rs . has <identifiersep> next ( ) ) { history <identifiersep> record hr = rs . next ( ) ; result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> call <identifiersep> record ( hr ) ) ; } } catch ( io <identifiersep> exception ex ) { <LOG> } return result ; } <comment> <ect>
{ if ( stt . sval != null ) { result . add ( stt . sval . trim ( ) ) ; } } } catch ( io <identifiersep> exception e ) { <LOG> } return result ; } <comment> <ect>
call <identifiersep> peer <identifiersep> names . to <identifiersep> string ( ) , call <identifiersep> peer <identifiersep> secondary <identifiersep> i <identifiersep> ds . to <identifiersep> string ( ) } , new date ( ) ) ; <comment> <LOG> } } <comment> <ect>
synchronized ( this . sync <identifiersep> root <identifiersep> history <identifiersep> service ) { if ( this . history <identifiersep> service == h <identifiersep> service ) { this . history <identifiersep> service = null ; <LOG> } } } <comment> <ect>
return ; } logger . debug ( <string_literal> ) ; if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { <LOG> this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } else if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . unregistering ) { this . handle <identifiersep> provider <identifiersep> removed ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } } <comment> <ect>
if ( op <identifiersep> set <identifiersep> telephony != null ) { op <identifiersep> set <identifiersep> telephony . add <identifiersep> call <identifiersep> listener ( this ) ; } else { <LOG> } } <comment> <ect>
try { if ( ! sdf . parse ( date <identifiersep> string ) . equals ( date ) ) return false ; } catch ( parse <identifiersep> exception e ) { <LOG> return false ; } string secondary <identifiersep> id = get <identifiersep> cs <identifiersep> vs ( property <identifiersep> vlaues [ peer <identifiersep> secondary <identifiersep> id <identifiersep> index ] ) . get ( i ) ; if ( secondary <identifiersep> id != null ) return false ; return true ; <ect>
bundle <identifiersep> context . register <identifiersep> service ( call <identifiersep> history <identifiersep> service . class . get <identifiersep> name ( ) , call <identifiersep> history <identifiersep> service , null ) ; bundle <identifiersep> context . register <identifiersep> service ( contact <identifiersep> source <identifiersep> service . class . get <identifiersep> name ( ) , new call <identifiersep> history <identifiersep> contact <identifiersep> source ( ) , null ) ; <LOG> } finally { logger . log <identifiersep> exit ( ) ; } } <comment> <ect>
, null ) ; bc . register <identifiersep> service ( popup <identifiersep> message <identifiersep> handler . class . get <identifiersep> name ( ) , new none <identifiersep> popup <identifiersep> message <identifiersep> handler <identifiersep> impl ( ) , null ) ; <LOG> } public void stop ( bundle <identifiersep> context arg0 ) throws exception { } <comment> <ect>
{ contactlist <identifiersep> trans = fa <identifiersep> service . create <identifiersep> fail <identifiersep> safe <identifiersep> transaction ( this . contactlist <identifiersep> file ) ; contactlist <identifiersep> trans . restore <identifiersep> file ( ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) { <LOG> } catch ( illegal <identifiersep> state <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } try { <comment> <ect>
{ try { contact <identifiersep> list <identifiersep> document = builder . parse ( contactlist <identifiersep> file ) ; } catch ( throwable ex ) { <LOG> logger . error ( <string_literal> ) ; <comment> <ect>
<comment> <LOG> } mcl <identifiersep> serv <identifiersep> impl . add <identifiersep> meta <identifiersep> contact <identifiersep> list <identifiersep> listener ( this ) ; this . mcl <identifiersep> service <identifiersep> impl = mcl <identifiersep> serv <identifiersep> impl ; started = true ; this . launch <identifiersep> storage <identifiersep> thread ( ) ; } <comment> <ect>
<comment> <LOG> } } } <comment> private void launch <identifiersep> storage <identifiersep> thread ( ) <ect>
catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; started = false ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> started = false ; } } } . start ( ) ; } <comment> public void store <identifiersep> contact <identifiersep> list <identifiersep> and <identifiersep> stop <identifiersep> storage <identifiersep> manager ( ) <ect>
&& proto <identifiersep> contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) == null ) { logger . info ( <string_literal> + proto <identifiersep> contact ) ; <LOG> } if ( proto <identifiersep> contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) == null ) return null ; proto <identifiersep> contact <identifiersep> element . set <identifiersep> attribute ( parent <identifiersep> proto <identifiersep> group <identifiersep> uid <identifiersep> attr <identifiersep> name , proto <identifiersep> contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) . get <identifiersep> uid ( ) ) ; <comment> <ect>
<comment> <LOG> } <comment> <ect>
op <identifiersep> set <identifiersep> presence . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ) ; else op <identifiersep> set <identifiersep> presence . move <identifiersep> contact <identifiersep> to <identifiersep> group ( proto <identifiersep> contact , proto <identifiersep> group ) ; } } } catch ( exception ex ) { <LOG> <comment> <ect>
logger . error ( <string_literal> + provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> unique <identifiersep> id ( ) , exc ) ; } synchronize <identifiersep> op <identifiersep> set <identifiersep> with <identifiersep> local <identifiersep> contact <identifiersep> list ( op <identifiersep> set <identifiersep> pers <identifiersep> presence ) ; } else { <LOG> } <comment> <comment> <ect>
+ s <identifiersep> service . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; <comment> <LOG> protocol <identifiersep> provider <identifiersep> service provider = ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ; <comment> <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { <LOG> <comment> <ect>
, proto <identifiersep> contact <identifiersep> event . proto <identifiersep> contact <identifiersep> moved , current <identifiersep> meta <identifiersep> contact , new <identifiersep> meta <identifiersep> contact ) ; } } } public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { <LOG> } <comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) <ect>
<comment> public void group <identifiersep> created ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { <LOG> <comment> <ect>
<comment> public void group <identifiersep> name <identifiersep> changed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { <LOG> meta <identifiersep> contact <identifiersep> group meta <identifiersep> contact <identifiersep> group = find <identifiersep> meta <identifiersep> contact <identifiersep> group <identifiersep> by <identifiersep> contact <identifiersep> group ( evt . get <identifiersep> source <identifiersep> group ( ) ) ; if ( meta <identifiersep> contact <identifiersep> group . count <identifiersep> contact <identifiersep> groups ( ) == 1 ) { <comment> <ect>
+ <string_literal> ) ; } parent <identifiersep> group . add <identifiersep> meta <identifiersep> contact ( new <identifiersep> meta <identifiersep> contact ) ; fire <identifiersep> meta <identifiersep> contact <identifiersep> event ( new <identifiersep> meta <identifiersep> contact , parent <identifiersep> group , meta <identifiersep> contact <identifiersep> event . meta <identifiersep> contact <identifiersep> added ) ; <LOG> return new <identifiersep> meta <identifiersep> contact ; } <comment> <ect>
mcl <identifiersep> service <identifiersep> impl = new meta <identifiersep> contact <identifiersep> list <identifiersep> service <identifiersep> impl ( ) ; <comment> <LOG> } <comment> <ect>
if ( st . execute ( ) ) { return ; } } catch ( exception e ) { this . connection = null ; <LOG> } } string filename ; try { file f = fas . get <identifiersep> private <identifiersep> persistent <identifiersep> file ( <string_literal> , file <identifiersep> category . profile ) ; <ect>
<comment> <LOG> } } } <ect>
{ bundle <identifiersep> context . register <identifiersep> service ( phone <identifiersep> number <identifiersep> i18n <identifiersep> service . class . get <identifiersep> name ( ) , new phone <identifiersep> number <identifiersep> i18n <identifiersep> service <identifiersep> impl ( ) , null ) ; <LOG> } @ override public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { } } <ect>
meta <identifiersep> history <identifiersep> service = new meta <identifiersep> history <identifiersep> service <identifiersep> impl ( ) ; meta <identifiersep> history <identifiersep> service . start ( bundle <identifiersep> context ) ; bundle <identifiersep> context . register <identifiersep> service ( meta <identifiersep> history <identifiersep> service . class . get <identifiersep> name ( ) , meta <identifiersep> history <identifiersep> service , null ) ; <LOG> } finally { logger . log <identifiersep> exit ( ) ; } } <comment> <ect>
<comment> try { delete <identifiersep> on <identifiersep> halt <identifiersep> hook . run <identifiersep> hooks ( ) ; } catch ( throwable t ) { <LOG> } logger . error ( <string_literal> ) ; runtime . get <identifiersep> runtime ( ) . halt ( system <identifiersep> exit <identifiersep> code ) ; } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context context ) throws exception { <LOG> } <comment> <ect>
{ parent . children . add ( peer ) ; gtk . gtk <identifiersep> menu <identifiersep> shell <identifiersep> append ( parent . gtk <identifiersep> menu , peer . gtk <identifiersep> menu <identifiersep> item ) ; } } } private void create <identifiersep> gtk <identifiersep> menu <identifiersep> item ( popup <identifiersep> menu <identifiersep> peer peer ) { j <identifiersep> menu <identifiersep> item m = ( j <identifiersep> menu <identifiersep> item ) peer . menu <identifiersep> item ; <LOG> + m . get <identifiersep> text ( ) ) ; if ( m instanceof j <identifiersep> check <identifiersep> box <identifiersep> menu <identifiersep> item ) { peer . gtk <identifiersep> menu <identifiersep> item = gtk . gtk <identifiersep> check <identifiersep> menu <identifiersep> item <identifiersep> new <identifiersep> with <identifiersep> label ( m . get <identifiersep> text ( ) ) ; j <identifiersep> check <identifiersep> box <identifiersep> menu <identifiersep> item cb = ( j <identifiersep> check <identifiersep> box <identifiersep> menu <identifiersep> item ) m ; <ect>
extracted <identifiersep> files . put ( ii . get <identifiersep> description ( ) , f . get <identifiersep> absolute <identifiersep> path ( ) ) ; } return f . get <identifiersep> absolute <identifiersep> path ( ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } return null ; } buffered <identifiersep> image get <identifiersep> buffered <identifiersep> image ( image <identifiersep> icon ii ) { image img = ii . get <identifiersep> image ( ) ; if ( img == null ) { <ect>
{ gtk . gdk <identifiersep> threads <identifiersep> leave ( ) ; } break ; } } @ override public void state <identifiersep> changed ( change <identifiersep> event e ) { <LOG> gtk . gdk <identifiersep> threads <identifiersep> enter ( ) ; try { gtk . gtk <identifiersep> check <identifiersep> menu <identifiersep> item <identifiersep> set <identifiersep> active ( peer . gtk <identifiersep> menu <identifiersep> item , menu . is <identifiersep> selected ( ) ? 1 : 0 ) ; <ect>
logger . debug ( <string_literal> + menu . get <identifiersep> text ( ) ) ; if ( menu . is <identifiersep> selected ( ) == is <identifiersep> gtk <identifiersep> selected ( ) ) { return ; } } for ( action <identifiersep> listener l : menu . get <identifiersep> action <identifiersep> listeners ( ) ) { <LOG> l . action <identifiersep> performed ( new action <identifiersep> event ( menu , 0 , <string_literal> ) ) ; } } private boolean is <identifiersep> gtk <identifiersep> selected ( ) { gtk . gdk <identifiersep> threads <identifiersep> enter ( ) ; try { <ect>
if ( em instanceof j <identifiersep> popup <identifiersep> menu . separator ) { logger . debug ( p + <string_literal> ) ; } if ( em instanceof j <identifiersep> menu <identifiersep> item ) { j <identifiersep> menu <identifiersep> item m = ( j <identifiersep> menu <identifiersep> item ) em ; <LOG> } if ( em instanceof j <identifiersep> menu ) { j <identifiersep> menu m = ( j <identifiersep> menu ) em ; print <identifiersep> menu ( m . get <identifiersep> menu <identifiersep> components ( ) , indent + 1 ) ; } } } <ect>
case <string_literal> : try { system <identifiersep> tray = new app <identifiersep> indicator <identifiersep> tray ( true ) ; } catch ( exception ex ) { <LOG> } break ; case <string_literal> : try { system <identifiersep> tray = new app <identifiersep> indicator <identifiersep> tray ( false ) ; } catch ( exception ex ) <ect>
<comment> <LOG> bundle <identifiersep> context . register <identifiersep> service ( systray <identifiersep> service . class . get <identifiersep> name ( ) , systray <identifiersep> service , null ) ; logger . info ( <string_literal> ) ; <ect>
null ) ; logger . info ( <string_literal> ) ; <comment> <LOG> bundle <identifiersep> context . register <identifiersep> service ( desktop <identifiersep> service . class . get <identifiersep> name ( ) , desktop <identifiersep> service , null ) ; logger . info ( <string_literal> ) ; <ect>
cnx = null ; } } } else { cnx = null ; } } catch ( exception e ) { <LOG> return null ; } return ( google <identifiersep> contacts <identifiersep> connection <identifiersep> impl ) cnx ; } <comment> <ect>
{ public void service <identifiersep> changed ( service <identifiersep> event service <identifiersep> event ) { google <identifiersep> contacts <identifiersep> activator . this . service <identifiersep> changed ( service <identifiersep> event ) ; } } ) ; <LOG> } <comment> <ect>
if ( credential == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + <string_literal> ) ; } if ( ! credential . refresh <identifiersep> token ( ) ) { <LOG> throw new failed <identifiersep> token <identifiersep> refresh <identifiersep> exception ( ) ; } } <comment> <ect>
+ <string_literal> ) ; { logger . debug ( <string_literal> + content . to <identifiersep> string ( ) ) ; } } else { <LOG> } } } ) ; builder . add <identifiersep> refresh <identifiersep> listener ( new credential <identifiersep> refresh <identifiersep> listener ( ) { @ override public void on <identifiersep> token <identifiersep> response ( credential credential , token <identifiersep> response token <identifiersep> response ) throws io <identifiersep> exception <ect>
return ret ; } try { contact <identifiersep> feed = cnx <identifiersep> impl . query ( query ) ; } catch ( exception e ) { <LOG> return ret ; } if ( contact <identifiersep> feed . get <identifiersep> entries ( ) . size ( ) == 0 ) { end <identifiersep> of <identifiersep> contacts = true ; break ; } for ( int i = 0 ; i < contact <identifiersep> feed . get <identifiersep> entries ( ) . size ( ) ; i ++ ) <ect>
byte [ ] buffer = new byte [ <number_literal> ] ; for ( int read = 0 ; ( read = in . read ( buffer ) ) != - 1 ; out . write ( buffer , 0 , read ) ) ; return out . to <identifiersep> byte <identifiersep> array ( ) ; } } catch ( exception e ) { <LOG> } return null ; } } <ect>
<comment> public google <identifiersep> contacts <identifiersep> config <identifiersep> form ( ) { super ( new border <identifiersep> layout ( ) ) ; <LOG> init <identifiersep> components ( ) ; } <comment> private void init <identifiersep> components ( ) { <ect>
icon <identifiersep> static <identifiersep> is <identifiersep> implemented ? get <identifiersep> icon ( popup <identifiersep> message ) : null , popup <identifiersep> message . get <identifiersep> message <identifiersep> title ( ) , popup <identifiersep> message . get <identifiersep> message ( ) , - 1 ) ; } catch ( d <identifiersep> bus <identifiersep> exception dbe ) { <LOG> } } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { metacafe <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } } <ect>
hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> dailymotion <identifiersep> impl . dailymotion <identifiersep> config <identifiersep> label ) ; dailymotion <identifiersep> source = new replacement <identifiersep> service <identifiersep> dailymotion <identifiersep> impl ( ) ; dailymotion <identifiersep> source <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , dailymotion <identifiersep> source , hashtable ) ; <LOG> } <comment> <ect>
hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> flickr <identifiersep> impl . flickr <identifiersep> config <identifiersep> label ) ; flickr <identifiersep> source = new replacement <identifiersep> service <identifiersep> flickr <identifiersep> impl ( ) ; flickr <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , flickr <identifiersep> source , hashtable ) ; <LOG> } <comment> <ect>
public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> flickr <identifiersep> impl ( ) { <LOG> } <comment> <ect>
hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> viddler <identifiersep> impl . viddler <identifiersep> config <identifiersep> label ) ; viddler <identifiersep> source = new replacement <identifiersep> service <identifiersep> viddler <identifiersep> impl ( ) ; viddler <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , viddler <identifiersep> source , hashtable ) ; <LOG> } <comment> <ect>
public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> viddler <identifiersep> impl ( ) { <LOG> } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { direct <identifiersep> image <identifiersep> source <identifiersep> serv <identifiersep> reg . unregister ( ) ; conf <identifiersep> service = null ; bundle <identifiersep> context = null ; <LOG> } <comment> <ect>
ftp . disconnect ( ) ; } if ( length > img <identifiersep> max <identifiersep> size ) { length = - 1 ; } } catch ( exception e ) { <LOG> } return length ; } <comment> <ect>
string thumb <identifiersep> url = ( string ) wrapper . get ( <string_literal> ) ; if ( thumb <identifiersep> url != null ) { return thumb <identifiersep> url ; } } catch ( throwable e ) { <LOG> } return source <identifiersep> string ; } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { hulu <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } } <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { youtube <identifiersep> source <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } } <ect>
string video <identifiersep> id = <string_literal> ; try { video <identifiersep> id = matcher . group ( 1 ) ; } catch ( exception e ) { <LOG> return thumb <identifiersep> url ; } thumb <identifiersep> url = <string_literal> + video <identifiersep> id + <string_literal> ; } return thumb <identifiersep> url ; } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { smiley <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } <comment> <ect>
string thumb <identifiersep> url = ( string ) wrapper . get ( <string_literal> ) ; if ( thumb <identifiersep> url != null ) { return thumb <identifiersep> url ; } } catch ( throwable e ) { <LOG> } return source <identifiersep> string ; } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { bliptv <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } } <ect>
{ thumb <identifiersep> url = ( string ) ( ( json <identifiersep> object ) result . get ( 0 ) ) . get ( <string_literal> ) ; } } catch ( throwable e ) { <LOG> } } return thumb <identifiersep> url ; } <comment> <ect>
private void fire <identifiersep> contact <identifiersep> removed ( contact <identifiersep> group parent <identifiersep> group , contact contact ) { <comment> <LOG> return ; } <comment> <ect>
<comment> contact <identifiersep> icq <identifiersep> impl create <identifiersep> unresolved <identifiersep> contact ( contact <identifiersep> group <identifiersep> icq <identifiersep> impl parent <identifiersep> group , screenname screenname ) { <LOG> contact <identifiersep> icq <identifiersep> impl existing <identifiersep> contact = find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( screenname . get <identifiersep> formatted ( ) ) ; if ( existing <identifiersep> contact != null ) { return existing <identifiersep> contact ; } <comment> <ect>
existing <identifiersep> contact , find <identifiersep> contact <identifiersep> group ( existing <identifiersep> contact ) , subscription <identifiersep> event . subscription <identifiersep> created ) ; } } . start ( ) ; return ; } <LOG> <comment> <ect>
public void create <identifiersep> group ( string group <identifiersep> name ) { logger . trace ( <string_literal> + group <identifiersep> name ) ; buddy <identifiersep> list . add <identifiersep> group ( group <identifiersep> name ) ; <LOG> } <comment> public void remove <identifiersep> group ( contact <identifiersep> group <identifiersep> icq <identifiersep> impl group <identifiersep> to <identifiersep> remove ) { <ect>
group group , list < ? extends buddy > buddies ) { logger . trace ( <string_literal> + group . get <identifiersep> name ( ) ) ; <LOG> contact <identifiersep> group <identifiersep> icq <identifiersep> impl new <identifiersep> group = find <identifiersep> contact <identifiersep> group ( group . get <identifiersep> name ( ) ) ; <comment> <ect>
logger . trace ( <string_literal> + group . get <identifiersep> name ( ) ) ; int index = find <identifiersep> contact <identifiersep> group <identifiersep> index ( group ) ; if ( index == - 1 ) { <LOG> return ; } contact <identifiersep> group removed <identifiersep> group = root <identifiersep> group . get <identifiersep> group ( index ) ; group . remove <identifiersep> group <identifiersep> listener ( jsim <identifiersep> group <identifiersep> change <identifiersep> listener ) ; root <identifiersep> group . remove <identifiersep> sub <identifiersep> group ( index ) ; fire <identifiersep> group <identifiersep> event ( removed <identifiersep> group , server <identifiersep> stored <identifiersep> group <identifiersep> event . group <identifiersep> removed <identifiersep> event ) ; <ect>
<comment> public void group <identifiersep> name <identifiersep> changed ( group group , string old <identifiersep> name , string new <identifiersep> name ) { <LOG> + old <identifiersep> name + <string_literal> + new <identifiersep> name ) ; contact <identifiersep> group <identifiersep> icq <identifiersep> impl contact <identifiersep> group = find <identifiersep> contact <identifiersep> group ( group ) ; if ( contact <identifiersep> group == null ) { logger . debug ( <ect>
<comment> public void screenname <identifiersep> changed ( buddy buddy , screenname old <identifiersep> screenname , screenname new <identifiersep> screenname ) { <comment> <LOG> logger . debug ( <string_literal> + buddy ) ; } <comment> <ect>
<comment> public void alert <identifiersep> action <identifiersep> changed ( buddy buddy , int old <identifiersep> alert <identifiersep> action , int new <identifiersep> alert <identifiersep> action ) { <comment> <LOG> } <comment> <ect>
<comment> public void alert <identifiersep> time <identifiersep> changed ( buddy buddy , int old <identifiersep> alert <identifiersep> event , int new <identifiersep> alert <identifiersep> event ) { <comment> <LOG> } <comment> <ect>
<comment> public void buddy <identifiersep> comment <identifiersep> changed ( buddy buddy , string old <identifiersep> comment , string new <identifiersep> comment ) { <comment> <LOG> } public void awaiting <identifiersep> auth <identifiersep> changed ( buddy simple <identifiersep> buddy , boolean old <identifiersep> awaiting <identifiersep> auth , boolean new <identifiersep> awaiting <identifiersep> auth ) { <comment> <ect>
+ <string_literal> + item . get <identifiersep> data ( ) . to <identifiersep> string ( ) ) ; } public void handle <identifiersep> item <identifiersep> deleted ( ssi <identifiersep> item item ) { <comment> <LOG> } public void handle <identifiersep> item <identifiersep> modified ( ssi <identifiersep> item item ) { <comment> logger . debug ( <string_literal> + item + <string_literal> + item . get <identifiersep> data ( ) . to <identifiersep> string ( ) ) ; <ect>
property <identifiersep> display <identifiersep> name , contact , old <identifiersep> nickname , nick <identifiersep> name ) ; } else contact . set <identifiersep> nickname ( old <identifiersep> nickname ) ; } } } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
offline <identifiersep> msg <identifiersep> cmd . get <identifiersep> contents ( ) ) ; fire <identifiersep> message <identifiersep> event ( msg <identifiersep> received <identifiersep> evt ) ; } } else if ( snac instanceof offline <identifiersep> msg <identifiersep> done <identifiersep> cmd ) { <LOG> offline <identifiersep> msg <identifiersep> icq <identifiersep> ack <identifiersep> cmd offline <identifiersep> msg <identifiersep> delete <identifiersep> req = new offline <identifiersep> msg <identifiersep> icq <identifiersep> ack <identifiersep> cmd ( long . parse <identifiersep> long ( icq <identifiersep> provider . get <identifiersep> aim <identifiersep> session ( ) . get <identifiersep> screenname ( ) . get <identifiersep> normal ( ) ) , request <identifiersep> id <ect>
+ evt . get <identifiersep> old <identifiersep> state ( ) + <string_literal> + evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) == registration <identifiersep> state . finalizing <identifiersep> registration ) { <LOG> icq <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> icbm <identifiersep> service ( ) . add <identifiersep> icbm <identifiersep> listener ( joust <identifiersep> sim <identifiersep> icbm <identifiersep> listener ) ; op <identifiersep> set <identifiersep> pers <identifiersep> presence = ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence <identifiersep> icq <identifiersep> impl ) icq <identifiersep> provider . get <identifiersep> operation <identifiersep> set ( <ect>
if ( tomorrow . after ( msg <identifiersep> date ) ) msg <identifiersep> date = current ; message <identifiersep> received <identifiersep> event msg <identifiersep> received <identifiersep> evt = new message <identifiersep> received <identifiersep> event ( new <identifiersep> message , source <identifiersep> contact , msg <identifiersep> date ) ; <comment> <LOG> fire <identifiersep> message <identifiersep> event ( msg <identifiersep> received <identifiersep> evt ) ; } public void sent <identifiersep> other <identifiersep> event ( conversation conversation , conversation <identifiersep> event <identifiersep> info event ) { } public void can <identifiersep> send <identifiersep> message <identifiersep> changed ( conversation conv , boolean can <identifiersep> send ) { } <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
{ assert <identifiersep> connected ( ) ; if ( ! ( status instanceof icq <identifiersep> status <identifiersep> enum || status instanceof aim <identifiersep> status <identifiersep> enum ) ) throw new illegal <identifiersep> argument <identifiersep> exception ( status + <string_literal> ) ; <LOG> main <identifiersep> bos <identifiersep> service bos <identifiersep> service = parent <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> bos <identifiersep> service ( ) ; if ( ! parent <identifiersep> provider . using <identifiersep> icq ) { if ( status . equals ( aim <identifiersep> status <identifiersep> enum . away ) ) { <ect>
else if ( snac instanceof snac <identifiersep> error ) { <comment> <LOG> synchronized ( this ) { this . notify <identifiersep> all ( ) ; } } } @ override public void handle <identifiersep> timeout ( snac <identifiersep> request <identifiersep> timeout <identifiersep> event event ) { synchronized ( this ) { if ( ran ) return ; <ect>
<comment> public void handle <identifiersep> your <identifiersep> extra <identifiersep> info ( list < extra <identifiersep> info <identifiersep> block > extra <identifiersep> infos ) { <LOG> <comment> <ect>
string status <identifiersep> message = extra <identifiersep> info <identifiersep> data . read <identifiersep> available <identifiersep> message ( block . get <identifiersep> extra <identifiersep> data ( ) ) ; logger . debug ( <string_literal> + status <identifiersep> message ) ; if ( get <identifiersep> current <identifiersep> status <identifiersep> message ( ) . equals ( status <identifiersep> message ) ) { <LOG> return ; } string old <identifiersep> status <identifiersep> message = get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; current <identifiersep> status <identifiersep> message = status <identifiersep> message ; fire <identifiersep> provider <identifiersep> status <identifiersep> message <identifiersep> change <identifiersep> event ( old <identifiersep> status <identifiersep> message , get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ) ; } } } <comment> <ect>
public void handle <identifiersep> your <identifiersep> info ( main <identifiersep> bos <identifiersep> service service , full <identifiersep> user <identifiersep> info user <identifiersep> info ) { logger . debug ( <string_literal> + user <identifiersep> info ) ; <LOG> logger . debug ( <string_literal> + user <identifiersep> info . get <identifiersep> icq <identifiersep> status ( ) ) ; <comment> <ect>
<comment> public void got <identifiersep> buddy <identifiersep> status ( buddy <identifiersep> service service , screenname buddy , full <identifiersep> user <identifiersep> info info ) { <LOG> logger . debug ( <string_literal> + info ) ; contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( buddy . get <identifiersep> formatted ( ) ) ; if ( source <identifiersep> contact == null ) { logger . warn ( <string_literal> + buddy ) ; <ect>
logger . debug ( <string_literal> + info ) ; contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( buddy . get <identifiersep> formatted ( ) ) ; if ( source <identifiersep> contact == null ) { <LOG> return ; } presence <identifiersep> status old <identifiersep> status = source <identifiersep> contact . get <identifiersep> presence <identifiersep> status ( ) ; presence <identifiersep> status new <identifiersep> status = null ; if ( ! parent <identifiersep> provider . using <identifiersep> icq ) { <ect>
string status = extra <identifiersep> info <identifiersep> data . read <identifiersep> available <identifiersep> message ( block . get <identifiersep> extra <identifiersep> data ( ) ) ; logger . info ( <string_literal> + status + <string_literal> ) ; source <identifiersep> contact . set <identifiersep> status <identifiersep> message ( status ) ; } } } <LOG> fire <identifiersep> contact <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event ( source <identifiersep> contact , parent , old <identifiersep> status , new <identifiersep> status ) ; } <comment> <ect>
@ override public void received <identifiersep> status <identifiersep> update ( buddy <identifiersep> info <identifiersep> manager manager , screenname buddy , buddy <identifiersep> info info ) { string status <identifiersep> message = info . get <identifiersep> status <identifiersep> message ( ) ; <LOG> logger . debug ( <string_literal> + info . get <identifiersep> away <identifiersep> message ( ) ) ; logger . debug ( <string_literal> + info . get <identifiersep> online <identifiersep> since ( ) ) ; logger . debug ( <string_literal> + status <identifiersep> message ) ; <ect>
string status <identifiersep> message = info . get <identifiersep> status <identifiersep> message ( ) ; logger . debug ( <string_literal> + buddy ) ; logger . debug ( <string_literal> + info . get <identifiersep> away <identifiersep> message ( ) ) ; <LOG> logger . debug ( <string_literal> + status <identifiersep> message ) ; contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( buddy . get <identifiersep> formatted ( ) ) ; if ( source <identifiersep> contact != null ) { <ect>
private class auth <identifiersep> listener implements buddy <identifiersep> authorization <identifiersep> listener { public void authorization <identifiersep> denied ( screenname screenname , string reason ) { <LOG> contact src <identifiersep> contact = find <identifiersep> contact <identifiersep> by <identifiersep> id ( screenname . get <identifiersep> formatted ( ) ) ; authorization <identifiersep> handler . process <identifiersep> authorization <identifiersep> response ( new authorization <identifiersep> response ( authorization <identifiersep> response . reject , reason ) , src <identifiersep> contact ) ; try { <ect>
} catch ( operation <identifiersep> failed <identifiersep> exception ex ) { logger . error ( <string_literal> + src <identifiersep> contact , ex ) ; } } public void authorization <identifiersep> accepted ( screenname screenname , string reason ) { <LOG> contact src <identifiersep> contact = find <identifiersep> contact <identifiersep> by <identifiersep> id ( screenname . get <identifiersep> formatted ( ) ) ; authorization <identifiersep> handler . process <identifiersep> authorization <identifiersep> response ( new authorization <identifiersep> response ( authorization <identifiersep> response . accept , reason ) , src <identifiersep> contact ) ; } public void authorization <identifiersep> request <identifiersep> received ( screenname screenname , string reason ) <ect>
screenname , auth <identifiersep> response . get <identifiersep> response <identifiersep> code ( ) == authorization <identifiersep> response . accept , auth <identifiersep> response . get <identifiersep> reason ( ) ) ; } public boolean authorization <identifiersep> required ( screenname screenname , group parent <identifiersep> group ) { <LOG> logger . trace ( <string_literal> + screenname ) ; contact <identifiersep> icq <identifiersep> impl src <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( screenname . get <identifiersep> formatted ( ) ) ; if ( src <identifiersep> contact == null ) { <ect>
request <identifiersep> buddy <identifiersep> authorization ( screenname , auth <identifiersep> request . get <identifiersep> reason ( ) ) ; return true ; } public void future <identifiersep> authorization <identifiersep> granted ( screenname screenname , string reason ) { <LOG> } public void you <identifiersep> were <identifiersep> added ( screenname screenname ) { logger . trace ( <string_literal> + screenname ) ; } } <comment> <ect>
logger . trace ( <string_literal> ) ; read <identifiersep> user <identifiersep> about <identifiersep> info ( ( meta <identifiersep> notes <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> interests <identifiersep> info <identifiersep> cmd ) { <LOG> read <identifiersep> interests <identifiersep> user <identifiersep> info ( ( meta <identifiersep> interests <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> affiliations <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; read <identifiersep> affilations <identifiersep> user <identifiersep> info ( ( meta <identifiersep> affiliations <identifiersep> info <identifiersep> cmd ) snac ) ; <ect>
<comment> public void invite ( string user <identifiersep> address , string reason ) { assert <identifiersep> connected ( ) ; <LOG> if ( chat <identifiersep> room <identifiersep> session . get <identifiersep> state ( ) . equals ( chat <identifiersep> session <identifiersep> state . inroom ) ) chat <identifiersep> room <identifiersep> session . invite ( new screenname ( user <identifiersep> address ) , reason ) ; else invite <identifiersep> user <identifiersep> list . put ( user <identifiersep> address , reason ) ; } <comment> <ect>
string event <identifiersep> reason ) { ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> participant <identifiersep> presence <identifiersep> change <identifiersep> event evt = new ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> participant <identifiersep> presence <identifiersep> change <identifiersep> event ( this , member , event <identifiersep> id , event <identifiersep> reason ) ; <LOG> iterator < ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> participant <identifiersep> presence <identifiersep> listener > listeners = null ; synchronized ( member <identifiersep> listeners ) { listeners = new array <identifiersep> list < ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> participant <identifiersep> presence <identifiersep> listener > ( member <identifiersep> listeners ) . iterator ( ) ; <ect>
{ conv . add <identifiersep> conversation <identifiersep> listener ( joust <identifiersep> sim <identifiersep> typing <identifiersep> listener ) ; } public void buddy <identifiersep> info <identifiersep> updated ( icbm <identifiersep> service service , screenname buddy , icbm <identifiersep> buddy <identifiersep> info info ) { <LOG> } public void send <identifiersep> automatically <identifiersep> failed ( icbm <identifiersep> service service , net . kano . joustsim . oscar . oscar . service . icbm . message message , set < conversation > tried <identifiersep> conversations ) { } } <comment> <ect>
public void handle <identifiersep> state <identifiersep> change ( state <identifiersep> event event ) { state new <identifiersep> state = event . get <identifiersep> new <identifiersep> state ( ) ; state old <identifiersep> state = event . get <identifiersep> old <identifiersep> state ( ) ; aim <identifiersep> connection conn = event . get <identifiersep> aim <identifiersep> connection ( ) ; <LOG> + <string_literal> + old <identifiersep> state + <string_literal> + new <identifiersep> state ) ; int reason <identifiersep> code = registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> not <identifiersep> specified ; string reason <identifiersep> str = null ; if ( new <identifiersep> state == state . online ) { <ect>
<comment> public void new <identifiersep> conversation ( icbm <identifiersep> service service , conversation conv ) { <LOG> conv . add <identifiersep> conversation <identifiersep> listener ( new aim <identifiersep> conversation <identifiersep> listener ( ) ) ; } <comment> <ect>
implements conversation <identifiersep> listener { public void sent <identifiersep> other <identifiersep> event ( conversation conversation , conversation <identifiersep> event <identifiersep> info event ) { <LOG> } <comment> <ect>
logger . debug ( <string_literal> ) ; } public void got <identifiersep> other <identifiersep> event ( conversation conversation , conversation <identifiersep> event <identifiersep> info event ) { <LOG> if ( event instanceof typing <identifiersep> info ) { typing <identifiersep> info ti = ( typing <identifiersep> info ) event ; logger . debug ( <string_literal> + ti . get <identifiersep> typing <identifiersep> state ( ) ) ; <ect>
message <identifiersep> info ti = ( message <identifiersep> info ) event ; logger . debug ( <string_literal> + ti . get <identifiersep> message ( ) ) ; } } public void can <identifiersep> send <identifiersep> message <identifiersep> changed ( conversation con , boolean can <identifiersep> send ) { <LOG> } <comment> <ect>
logger . debug ( <string_literal> ) ; } <comment> <LOG> } <comment> <ect>
<comment> void reregister ( int auth <identifiersep> reason <identifiersep> code ) { try { <LOG> <comment> <ect>
disconnect <identifiersep> and <identifiersep> clean <identifiersep> connection ( ) ; fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( get <identifiersep> registration <identifiersep> state ( ) , registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , null ) ; } catch ( xmpp <identifiersep> exception ex ) { <LOG> event <identifiersep> during <identifiersep> login = null ; fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( ex ) ; } finally { synchronized ( connect <identifiersep> and <identifiersep> login <identifiersep> lock ) { <ect>
addrs = network <identifiersep> utils . get <identifiersep> aand <identifiersep> aaaa <identifiersep> records ( server <identifiersep> address <identifiersep> user <identifiersep> setting , server <identifiersep> port ) ; } catch ( parse <identifiersep> exception e ) { <LOG> } catch ( dnssec <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; set <identifiersep> dnssec <identifiersep> login <identifiersep> failure ( ) ; return ; } if ( addrs == null || addrs . length == 0 ) <ect>
{ logger . error ( <string_literal> , e ) ; set <identifiersep> dnssec <identifiersep> login <identifiersep> failure ( ) ; return ; } if ( addrs == null || addrs . length == 0 ) { <LOG> event <identifiersep> during <identifiersep> login = null ; fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( get <identifiersep> registration <identifiersep> state ( ) , registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> server <identifiersep> not <identifiersep> found , <string_literal> ) ; <ect>
. get <identifiersep> srv <identifiersep> records ( <string_literal> , <string_literal> , domain ) ; } catch ( parse <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( dnssec <identifiersep> exception e ) { <LOG> dnssec <identifiersep> state [ 0 ] = true ; } if ( srv <identifiersep> records != null ) { for ( srv <identifiersep> record srv : srv <identifiersep> records ) { inet <identifiersep> socket <identifiersep> address [ ] addrs = null ; <ect>
) ; } catch ( parse <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( dnssec <identifiersep> exception e ) { <LOG> dnssec <identifiersep> state [ 0 ] = true ; } if ( addrs == null || addrs . length == 0 ) { logger . error ( <string_literal> + srv . get <identifiersep> target ( ) ) ; continue ; <ect>
try { srv <identifiersep> records = network <identifiersep> utils . get <identifiersep> srv <identifiersep> records ( <string_literal> , <string_literal> , domain ) ; } catch ( parse <identifiersep> exception e ) { <LOG> return false ; } catch ( dnssec <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; return false ; } if ( srv <identifiersep> records == null ) <ect>
{ int dscp <identifiersep> int = integer . parse <identifiersep> int ( dscp ) < < <number_literal> ; if ( dscp <identifiersep> int > 0 ) s . set <identifiersep> traffic <identifiersep> class ( dscp <identifiersep> int ) ; } catch ( exception e ) { <LOG> } } } } <comment> <ect>
acc <identifiersep> id . get <identifiersep> display <identifiersep> name ( ) , credentials , security <identifiersep> authority . authentication <identifiersep> required ) ; <comment> <LOG> return null ; } <comment> <ect>
stun <identifiersep> candidate <identifiersep> harvester auto <identifiersep> harvester = nam <identifiersep> ser . discover <identifiersep> stun <identifiersep> server ( acc <identifiersep> id . get <identifiersep> service ( ) , string <identifiersep> utils . get <identifiersep> utf8bytes ( username ) , string <identifiersep> utils . get <identifiersep> utf8bytes ( password ) ) ; <LOG> if ( auto <identifiersep> harvester != null ) { at <identifiersep> least <identifiersep> one <identifiersep> stun <identifiersep> server = true ; agent . add <identifiersep> candidate <identifiersep> harvester ( auto <identifiersep> harvester ) ; } } <comment> <ect>
desc . get <identifiersep> password ( ) ) ) ; } else { <comment> <LOG> at <identifiersep> least <identifiersep> one <identifiersep> stun <identifiersep> server = true ; agent . add <identifiersep> candidate <identifiersep> harvester ( harvester ) ; } if ( ! at <identifiersep> least <identifiersep> one <identifiersep> stun <identifiersep> server && acc <identifiersep> id . is <identifiersep> use <identifiersep> default <identifiersep> stun <identifiersep> server ( ) ) { <comment> <ect>
port <identifiersep> tracker . set <identifiersep> next <identifiersep> port ( next <identifiersep> port ) ; logger . debug ( <string_literal> + next <identifiersep> port ) ; } } catch ( throwable t ) { <comment> <LOG> } return stream ; } <comment> private int get <identifiersep> max <identifiersep> allocated <identifiersep> port ( ice <identifiersep> media <identifiersep> stream ice <identifiersep> stream , int min , int max ) <ect>
<comment> if ( candidate . get <identifiersep> generation ( ) != generation ) continue ; if ( candidate . get <identifiersep> ip ( ) == null || <string_literal> . equals ( candidate . get <identifiersep> ip ( ) ) ) { <LOG> continue ; } component component = stream . get <identifiersep> component ( candidate . get <identifiersep> component ( ) ) ; string rel <identifiersep> addr ; int rel <identifiersep> port ; transport <identifiersep> address related <identifiersep> address = null ; <ect>
room <identifiersep> name = <string_literal> + string <identifiersep> utils . random <identifiersep> string ( <number_literal> ) ; else room = find <identifiersep> room ( room <identifiersep> name ) ; if ( room == null ) { <LOG> <comment> <ect>
else { form = new form ( form . type <identifiersep> submit ) ; } muc . send <identifiersep> configuration <identifiersep> form ( form ) ; } catch ( xmpp <identifiersep> exception e ) { <LOG> } room = create <identifiersep> local <identifiersep> chat <identifiersep> room <identifiersep> instance ( muc ) ; <comment> <ect>
chat <identifiersep> room , inviter , reason , null ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { logger . error ( <string_literal> + room , e ) ; } catch ( operation <identifiersep> not <identifiersep> supported <identifiersep> exception e ) { <LOG> } } } <comment> private class smack <identifiersep> invitation <identifiersep> rejection <identifiersep> listener implements invitation <identifiersep> rejection <identifiersep> listener <ect>
<comment> void fire <identifiersep> group <identifiersep> event ( contact <identifiersep> group <identifiersep> jabber <identifiersep> impl group , int event <identifiersep> id ) { <comment> <LOG> return ; } server <identifiersep> stored <identifiersep> group <identifiersep> event evt = new server <identifiersep> stored <identifiersep> group <identifiersep> event ( group , event <identifiersep> id , parent <identifiersep> operation <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , jabber <identifiersep> provider <ect>
void fire <identifiersep> contact <identifiersep> removed ( contact <identifiersep> group parent <identifiersep> group , contact <identifiersep> jabber <identifiersep> impl contact ) { <comment> <LOG> return ; logger . trace ( <string_literal> + contact . get <identifiersep> address ( ) + <string_literal> + parent <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) ) ; <comment> <ect>
contact <identifiersep> group new <identifiersep> parent <identifiersep> group , contact <identifiersep> jabber <identifiersep> impl contact ) { <comment> <LOG> return ; } <comment> <ect>
<comment> public void create <identifiersep> group ( string group <identifiersep> name ) throws operation <identifiersep> failed <identifiersep> exception { <LOG> contact <identifiersep> group <identifiersep> jabber <identifiersep> impl existing <identifiersep> group = find <identifiersep> contact <identifiersep> group ( group <identifiersep> name ) ; if ( existing <identifiersep> group != null && existing <identifiersep> group . is <identifiersep> persistent ( ) ) { logger . debug ( <string_literal> + group <identifiersep> name + <string_literal> ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <ect>
new array <identifiersep> list < roster <identifiersep> entry > ( ) . iterator ( ) , this , true ) ; root <identifiersep> group . add <identifiersep> sub <identifiersep> group ( new <identifiersep> group ) ; fire <identifiersep> group <identifiersep> event ( new <identifiersep> group , server <identifiersep> stored <identifiersep> group <identifiersep> event . group <identifiersep> created <identifiersep> event ) ; <LOG> } <comment> public void remove <identifiersep> group ( contact <identifiersep> group <identifiersep> jabber <identifiersep> impl group <identifiersep> to <identifiersep> remove ) throws operation <identifiersep> failed <identifiersep> exception <ect>
try { add <identifiersep> contact ( new <identifiersep> parent , contact <identifiersep> address ) ; return ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( ex . get <identifiersep> message ( ) , operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error , ex ) ; } } try { <comment> <ect>
contact , old <identifiersep> image , img <identifiersep> bytes ) ; } else <comment> <LOG> } } <comment> <ect>
{ discover <identifiersep> info discover <identifiersep> info = parent <identifiersep> provider . get <identifiersep> discovery <identifiersep> manager ( ) . discover <identifiersep> info ( to ) ; if ( ! discover <identifiersep> info . contains <identifiersep> feature ( protocol <identifiersep> provider <identifiersep> service <identifiersep> jabber <identifiersep> impl . urn <identifiersep> xmpp <identifiersep> jingle <identifiersep> coin ) ) { <LOG> call <identifiersep> peer <identifiersep> jabber . set <identifiersep> conf <identifiersep> info <identifiersep> scheduled ( false ) ; return ; } } catch ( xmpp <identifiersep> exception xmppe ) { logger . warn ( <string_literal> + to , xmppe ) ; } conference <identifiersep> info <identifiersep> document current <identifiersep> conf <identifiersep> info <ect>
{ super . registration <identifiersep> state <identifiersep> changed ( evt ) ; registration <identifiersep> state registration <identifiersep> state = evt . get <identifiersep> new <identifiersep> state ( ) ; if ( registration <identifiersep> state . registered . equals ( registration <identifiersep> state ) ) { <LOG> subscribe <identifiersep> for <identifiersep> coin <identifiersep> packets ( ) ; } else if ( registration <identifiersep> state . unregistered . equals ( registration <identifiersep> state ) ) { logger . debug ( <string_literal> ) ; unsubscribe <identifiersep> for <identifiersep> coin <identifiersep> packets ( ) ; <ect>
xmpp <identifiersep> error error = coin <identifiersep> iq . get <identifiersep> error ( ) ; if ( error != null ) { string msg = error . get <identifiersep> message ( ) ; error <identifiersep> message = ( ( msg != null ) ? ( msg + <string_literal> ) : <string_literal> ) + <string_literal> + error . get <identifiersep> code ( ) ; } <LOG> } string sid = coin <identifiersep> iq . get <identifiersep> sid ( ) ; if ( sid != null ) { call <identifiersep> peer <identifiersep> jabber <identifiersep> impl call <identifiersep> peer = get <identifiersep> basic <identifiersep> telephony ( ) . get <identifiersep> active <identifiersep> calls <identifiersep> repository ( ) . find <identifiersep> call <identifiersep> peer ( sid ) ; <ect>
if ( message . get <identifiersep> error ( ) != null ) fire <identifiersep> typing <identifiersep> notifications <identifiersep> delivery <identifiersep> failed <identifiersep> event ( source <identifiersep> contact , evt <identifiersep> code ) ; else if ( evt <identifiersep> code != state <identifiersep> unknown ) fire <identifiersep> typing <identifiersep> notifications <identifiersep> event ( source <identifiersep> contact , evt <identifiersep> code ) ; else <LOG> } @ override public void process <identifiersep> packet ( packet packet ) { message msg = ( message ) packet ; chat <identifiersep> state <identifiersep> extension ext = ( chat <identifiersep> state <identifiersep> extension ) msg . get <identifiersep> extension ( <string_literal> ) ; <ect>
try { smack <identifiersep> multi <identifiersep> user <identifiersep> chat . send <identifiersep> configuration <identifiersep> form ( smack <identifiersep> submit <identifiersep> form ) ; } catch ( xmpp <identifiersep> exception e ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error ) ; } } } <ect>
catch ( xmpp <identifiersep> exception e ) { logger . error ( e ) ; return null ; } if ( data == null ) { <LOG> return null ; } iterator < column > columns = data . get <identifiersep> columns ( ) ; iterator < row > rows = data . get <identifiersep> rows ( ) ; if ( columns == null || rows == null ) { logger . error ( <string_literal> ) ; <ect>
if ( tmp <identifiersep> collumn . get <identifiersep> type ( ) . equals ( form <identifiersep> field . type <identifiersep> jid <identifiersep> single ) ) { jid <identifiersep> column = tmp <identifiersep> collumn ; break ; } } if ( jid <identifiersep> column == null ) { <LOG> return null ; } list < string > result = new array <identifiersep> list < string > ( ) ; while ( rows . has <identifiersep> next ( ) ) { row row = rows . next ( ) ; result . add ( ( string ) row . get <identifiersep> values ( jid <identifiersep> column . get <identifiersep> variable ( ) ) . next ( ) ) ; <ect>
int id = - 1 ; try { id = integer . value <identifiersep> of ( ext . get <identifiersep> id ( ) ) ; } catch ( number <identifiersep> format <identifiersep> exception nfe ) { <LOG> return ; } rtp <identifiersep> header <identifiersep> extensions . remove ( id ) ; } <comment> <ect>
colibri <identifiersep> conference <identifiersep> iq . channel <identifiersep> bundle local <identifiersep> bundle ; if ( local <identifiersep> channels <identifiersep> info . get <identifiersep> channel <identifiersep> bundles ( ) . size ( ) > 0 ) { local <identifiersep> bundle = local <identifiersep> channels <identifiersep> info . get <identifiersep> channel <identifiersep> bundles ( ) . get ( 0 ) ; if ( local <identifiersep> channels <identifiersep> info . get <identifiersep> channel <identifiersep> bundles ( ) . size ( ) > 1 ) { <LOG> } } else { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } colibri <identifiersep> conference <identifiersep> iq . channel <identifiersep> bundle bundle <identifiersep> update = new colibri <identifiersep> conference <identifiersep> iq . channel <identifiersep> bundle ( <ect>
+ parent <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; waiting <identifiersep> for <identifiersep> packet <identifiersep> with <identifiersep> id = ping . get <identifiersep> packet <identifiersep> id ( ) ; parent <identifiersep> provider . get <identifiersep> connection ( ) . send <identifiersep> packet ( ping ) ; } catch ( throwable t ) { <LOG> waiting <identifiersep> for <identifiersep> packet <identifiersep> with <identifiersep> id = null ; } } } } } <ect>
{ logger . debug ( <string_literal> , e ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { <LOG> } return null ; } } <ect>
else { { logger . trace ( <string_literal> + event <identifiersep> type ) ; <LOG> } } event <identifiersep> type = parser . next ( ) ; } return mailbox <identifiersep> iq ; } } <ect>
<comment> public iq parse <identifiersep> iq ( final xml <identifiersep> pull <identifiersep> parser parser ) throws exception { <LOG> new <identifiersep> mail <identifiersep> notification <identifiersep> iq iq = new new <identifiersep> mail <identifiersep> notification <identifiersep> iq ( ) ; return iq ; } } <ect>
<comment> @ override public string get <identifiersep> child <identifiersep> element <identifiersep> xml ( ) { <LOG> string total <identifiersep> string = total <identifiersep> estimate ? <string_literal> : <string_literal> ; return <string_literal> + result <identifiersep> time + <string_literal> + total <identifiersep> matched + <string_literal> + total <identifiersep> string + <string_literal> ; } <comment> <ect>
{ if ( parser . get <identifiersep> name ( ) . equals ( geolocation <identifiersep> packet <identifiersep> extension <identifiersep> provider . element <identifiersep> name ) ) { done = true ; <LOG> } } } catch ( number <identifiersep> format <identifiersep> exception ex ) { ex . print <identifiersep> stack <identifiersep> trace ( ) ; } } return result ; } } <ect>
<comment> <LOG> return ; } forwarded <identifiersep> packet <identifiersep> extension forwarded <identifiersep> ext = extensions . get ( 0 ) ; msg = forwarded <identifiersep> ext . get <identifiersep> message ( ) ; if ( msg == null || msg . get <identifiersep> body ( ) == null ) return ; } object multi <identifiersep> chat <identifiersep> extension = <ect>
{ try { multi <identifiersep> user <identifiersep> chat . destroy ( reason , alternate <identifiersep> address ) ; } catch ( xmpp <identifiersep> exception e ) { <LOG> return false ; } return true ; } <comment> public void leave ( ) <ect>
{ try { multi <identifiersep> user <identifiersep> chat . change <identifiersep> subject ( subject ) ; } catch ( xmpp <identifiersep> exception ex ) { <LOG> , ex ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + get <identifiersep> name ( ) , operation <identifiersep> failed <identifiersep> exception . forbidden , ex ) ; } } <comment> <ect>
{ try { multi <identifiersep> user <identifiersep> chat . kick <identifiersep> participant ( member . get <identifiersep> name ( ) , reason ) ; } catch ( xmpp <identifiersep> exception e ) { <LOG> <comment> <ect>
chat <identifiersep> room <identifiersep> member actor , string event <identifiersep> id , string event <identifiersep> reason ) { chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> change <identifiersep> event evt = new chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> change <identifiersep> event ( this , member , actor , event <identifiersep> id , event <identifiersep> reason ) ; <LOG> iterable < chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> listener > listeners ; synchronized ( member <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> listener > ( member <identifiersep> listeners ) ; <ect>
{ for ( affiliate a : multi <identifiersep> user <identifiersep> chat . get <identifiersep> members ( ) ) { res . add ( a . get <identifiersep> jid ( ) ) ; } } catch ( xmpp <identifiersep> exception e ) { <LOG> } return res ; } <comment> <ect>
msg <identifiersep> delivered <identifiersep> evt . set <identifiersep> history <identifiersep> message ( true ) ; fire <identifiersep> message <identifiersep> event ( msg <identifiersep> delivered <identifiersep> evt ) ; return ; } if ( msg . get <identifiersep> type ( ) == org . jivesoftware . smack . packet . message . type . error ) { <LOG> xmpp <identifiersep> error error = packet . get <identifiersep> error ( ) ; int error <identifiersep> code = error . get <identifiersep> code ( ) ; int error <identifiersep> result <identifiersep> code = chat <identifiersep> room <identifiersep> message <identifiersep> delivery <identifiersep> failed <identifiersep> event . unknown <identifiersep> error ; string error <identifiersep> reason = error . get <identifiersep> message ( ) ; if ( error <identifiersep> code == <number_literal> ) <ect>
boolean is <identifiersep> initial ) { chat <identifiersep> room <identifiersep> local <identifiersep> user <identifiersep> role <identifiersep> change <identifiersep> event evt = new chat <identifiersep> room <identifiersep> local <identifiersep> user <identifiersep> role <identifiersep> change <identifiersep> event ( this , previous <identifiersep> role , new <identifiersep> role , is <identifiersep> initial ) ; <LOG> iterable < chat <identifiersep> room <identifiersep> local <identifiersep> user <identifiersep> role <identifiersep> listener > listeners ; synchronized ( local <identifiersep> user <identifiersep> role <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> room <identifiersep> local <identifiersep> user <identifiersep> role <identifiersep> listener > ( local <identifiersep> user <identifiersep> role <identifiersep> listeners ) ; } for ( chat <identifiersep> room <identifiersep> local <identifiersep> user <identifiersep> role <identifiersep> listener listener : listeners ) <ect>
{ try { multi <identifiersep> user <identifiersep> chat . grant <identifiersep> voice ( nickname ) ; } catch ( xmpp <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
{ try { multi <identifiersep> user <identifiersep> chat . revoke <identifiersep> voice ( nickname ) ; } catch ( xmpp <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
try { multi <identifiersep> user <identifiersep> chat . send <identifiersep> configuration <identifiersep> form ( new form ( form . type <identifiersep> submit ) ) ; } catch ( xmpp <identifiersep> exception e ) { <LOG> } op <identifiersep> set <identifiersep> muc . add <identifiersep> smack <identifiersep> invitation <identifiersep> rejection <identifiersep> listener ( multi <identifiersep> user <identifiersep> chat , chat <identifiersep> room ) ; if ( affiliation . equals <identifiersep> ignore <identifiersep> case ( chat <identifiersep> room <identifiersep> member <identifiersep> role . owner . get <identifiersep> role <identifiersep> name ( ) . to <identifiersep> lower <identifiersep> case ( ) ) ) { set <identifiersep> local <identifiersep> user <identifiersep> role ( chat <identifiersep> room <identifiersep> member <identifiersep> role . owner , true ) ; <ect>
transfer . send <identifiersep> file ( file , <string_literal> ) ; <comment> <LOG> } return outgoing <identifiersep> transfer ; } <comment> <ect>
file <identifiersep> transfer . fire <identifiersep> status <identifiersep> change <identifiersep> event ( status , <string_literal> ) ; file <identifiersep> transfer . fire <identifiersep> progress <identifiersep> change <identifiersep> event ( system . current <identifiersep> time <identifiersep> millis ( ) , progress ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } } if ( jabber <identifiersep> transfer . get <identifiersep> error ( ) != null ) { logger . error ( <string_literal> + jabber <identifiersep> transfer . get <identifiersep> error ( ) . get <identifiersep> message ( ) ) ; } if ( jabber <identifiersep> transfer . get <identifiersep> exception ( ) != null ) { <ect>
logger . info ( <string_literal> ) ; } else if ( registration <identifiersep> state == registration <identifiersep> state . unregistered ) { unsubscribe <identifiersep> for <identifiersep> jingle <identifiersep> packets ( ) ; <LOG> } } <comment> <ect>
{ <comment> <LOG> } if ( di != null ) { logger . info ( full <identifiersep> callee <identifiersep> uri + <string_literal> ) ; } else <ect>
{ logger . info ( full <identifiersep> callee <identifiersep> uri + <string_literal> ) ; } else { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + full <identifiersep> callee <identifiersep> uri + <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error ) ; } <comment> <ect>
try { media <identifiersep> handler . start ( ) ; } catch ( undeclared <identifiersep> throwable <identifiersep> exception e ) { throwable exc = e . get <identifiersep> undeclared <identifiersep> throwable ( ) ; <LOG> <comment> <ect>
. wrapup <identifiersep> connectivity <identifiersep> establishment ( ) ; media <identifiersep> handler . process <identifiersep> answer ( contents ) ; for ( content <identifiersep> packet <identifiersep> extension c : contents ) set <identifiersep> senders ( get <identifiersep> media <identifiersep> type ( c ) , c . get <identifiersep> senders ( ) ) ; } catch ( exception e ) { <LOG> <comment> <ect>
+ <string_literal> ) ; return ; } media <identifiersep> handler . get <identifiersep> transport <identifiersep> manager ( ) . wrapup <identifiersep> connectivity <identifiersep> establishment ( ) ; <LOG> answer <identifiersep> contents = media <identifiersep> handler . generate <identifiersep> session <identifiersep> accept ( ) ; content <identifiersep> iq = null ; } catch ( exception e ) { logger . warn ( <string_literal> , e ) ; answer <identifiersep> contents = null ; <ect>
{ try { get <identifiersep> call ( ) . modify <identifiersep> video <identifiersep> content ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ofe ) { <LOG> } } } } <comment> <ect>
<comment> <LOG> } } } <comment> public void process <identifiersep> session <identifiersep> accept ( jingle <identifiersep> iq session <identifiersep> init <identifiersep> iq ) <ect>
case unhold : case active : get <identifiersep> media <identifiersep> handler ( ) . set <identifiersep> remotely <identifiersep> on <identifiersep> hold ( false ) ; reeval <identifiersep> remote <identifiersep> hold <identifiersep> status ( ) ; break ; default : <LOG> } } <comment> <ect>
if ( this . get <identifiersep> discovery <identifiersep> info ( ) == null ) { string callee <identifiersep> uri = session <identifiersep> init <identifiersep> iq . get <identifiersep> from ( ) ; retrieve <identifiersep> discovery <identifiersep> info ( callee <identifiersep> uri ) ; } <comment> <LOG> get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> connection ( ) . send <identifiersep> packet ( jingle <identifiersep> packet <identifiersep> factory . create <identifiersep> ringing ( session <identifiersep> init <identifiersep> iq ) ) ; synchronized ( session <identifiersep> initiate <identifiersep> sync <identifiersep> root ) { session <identifiersep> initiate <identifiersep> processed = true ; session <identifiersep> initiate <identifiersep> sync <identifiersep> root . notify ( ) ; <ect>
list < content <identifiersep> packet <identifiersep> extension > contents ; try { contents = get <identifiersep> media <identifiersep> handler ( ) . create <identifiersep> content <identifiersep> list ( media <identifiersep> type . video ) ; } catch ( exception exc ) { <LOG> return ; } protocol <identifiersep> provider <identifiersep> service <identifiersep> jabber <identifiersep> impl protocol <identifiersep> provider = get <identifiersep> protocol <identifiersep> provider ( ) ; jingle <identifiersep> iq content <identifiersep> iq = jingle <identifiersep> packet <identifiersep> factory . create <identifiersep> content <identifiersep> add ( protocol <identifiersep> provider . get <identifiersep> our <identifiersep> jid ( ) , <ect>
try { media <identifiersep> handler . reinit <identifiersep> content ( remote <identifiersep> content <identifiersep> name , ext , false ) ; media <identifiersep> handler . start ( ) ; } catch ( exception e ) { <LOG> } return ( new <identifiersep> senders != senders ) ; } <comment> public void send <identifiersep> modify <identifiersep> video <identifiersep> resolution <identifiersep> content ( ) <ect>
<comment> <LOG> return ; } <comment> <ect>
new operation <identifiersep> set <identifiersep> file <identifiersep> transfer <identifiersep> jabber <identifiersep> impl . file <identifiersep> transfer <identifiersep> progress <identifiersep> thread ( jabber <identifiersep> transfer , incoming <identifiersep> transfer , get <identifiersep> file <identifiersep> size ( ) ) . start ( ) ; } catch ( xmpp <identifiersep> exception e ) { <LOG> } return incoming <identifiersep> transfer ; } <comment> public void reject <identifiersep> file ( ) { <ect>
connection . login ( <string_literal> , <string_literal> , resource ) ; return true ; } catch ( xmpp <identifiersep> exception ex ) { if ( ex . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <LOG> return false ; } throw ex ; } } } <ect>
try { handler <identifiersep> provider . register ( jabber <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> default <identifiersep> security <identifiersep> authority ( handler <identifiersep> provider ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception exc ) { <LOG> logger . warn ( exc . get <identifiersep> message ( ) , exc ) ; } } <comment> <ect>
= get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> discovery <identifiersep> manager ( ) . discover <identifiersep> info ( callee <identifiersep> uri ) ; if ( discovery <identifiersep> info != null ) set <identifiersep> discovery <identifiersep> info ( discovery <identifiersep> info ) ; } catch ( xmpp <identifiersep> exception xmppex ) { <LOG> } } <comment> <ect>
<comment> <LOG> supported = true ; } else { { logger . info ( <ect>
{ if ( call <identifiersep> peers . contains ( call <identifiersep> peer . get <identifiersep> address ( ) ) != enables ) { if ( is <identifiersep> remote <identifiersep> control <identifiersep> available ( call <identifiersep> peer ) ) { <LOG> input <identifiersep> evt <identifiersep> iq input <identifiersep> iq = new input <identifiersep> evt <identifiersep> iq ( ) ; if ( enables ) { input <identifiersep> iq . set <identifiersep> action ( input <identifiersep> evt <identifiersep> action . start ) ; } else { <ect>
contact <identifiersep> property <identifiersep> change <identifiersep> event . property <identifiersep> image , source <identifiersep> contact , current <identifiersep> avatar , new <identifiersep> avatar ) ; } } catch ( xmpp <identifiersep> exception ex ) { <LOG> logger . trace ( <string_literal> , ex ) ; } } } <comment> <ect>
this . resource <identifiersep> priority <identifiersep> available = integer . parse <identifiersep> int ( parent <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> property <identifiersep> string ( protocol <identifiersep> provider <identifiersep> factory . resource <identifiersep> priority ) ) ; } catch ( number <identifiersep> format <identifiersep> exception ex ) { <LOG> } add <identifiersep> default <identifiersep> value ( jabber <identifiersep> status <identifiersep> enum . away , - <number_literal> ) ; add <identifiersep> default <identifiersep> value ( jabber <identifiersep> status <identifiersep> enum . extended <identifiersep> away , - <number_literal> ) ; add <identifiersep> default <identifiersep> value ( jabber <identifiersep> status <identifiersep> enum . on <identifiersep> the <identifiersep> phone , - <number_literal> ) ; add <identifiersep> default <identifiersep> value ( jabber <identifiersep> status <identifiersep> enum . in <identifiersep> a <identifiersep> meeting , - <number_literal> ) ; add <identifiersep> default <identifiersep> value ( jabber <identifiersep> status <identifiersep> enum . do <identifiersep> not <identifiersep> disturb , - <number_literal> ) ; add <identifiersep> default <identifiersep> value ( jabber <identifiersep> status <identifiersep> enum . free <identifiersep> for <identifiersep> chat , + <number_literal> ) ; <ect>
connection , <number_literal> , <number_literal> , <number_literal> , jingle <identifiersep> channel <identifiersep> iq . udp , account <identifiersep> id . is <identifiersep> jingle <identifiersep> nodes <identifiersep> search <identifiersep> buddies <identifiersep> enabled ( ) , account <identifiersep> id . is <identifiersep> jingle <identifiersep> nodes <identifiersep> auto <identifiersep> discovery <identifiersep> enabled ( ) , search <identifiersep> nodes <identifiersep> with <identifiersep> prefix ) ; { <LOG> logger . info ( <string_literal> + ( nodes != null ? nodes . get <identifiersep> relay <identifiersep> entries ( ) . size ( ) : <string_literal> ) + <string_literal> + account <identifiersep> id . get <identifiersep> account <identifiersep> address ( ) + <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - start ) + <string_literal> ) ; } if ( nodes != null ) <ect>
else if ( packet <identifiersep> extension . class . is <identifiersep> assignable <identifiersep> from ( provider ) ) { add <identifiersep> extension <identifiersep> provider ( element <identifiersep> name , namespace , provider ) ; } } catch ( throwable t ) { <LOG> } } } <ect>
<comment> protected call create <identifiersep> outgoing <identifiersep> video <identifiersep> call ( string callee <identifiersep> address ) throws operation <identifiersep> failed <identifiersep> exception { <LOG> if ( parent <identifiersep> provider . get <identifiersep> connection ( ) == null ) { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error ) ; <ect>
return new byte [ 0 ] ; byte [ ] icon = null ; try { icon = new byte [ is . available ( ) ] ; is . read ( icon ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return icon ; } <comment> <ect>
{ logger . info ( <string_literal> + ip + <string_literal> + port + <string_literal> + ciq . get <identifiersep> localport ( ) ) ; } if ( ip == null || ciq . get <identifiersep> remoteport ( ) == 0 ) { <LOG> return candidates ; } <comment> <ect>
final string value = state . get <identifiersep> server <identifiersep> options ( ) . get <identifiersep> key ( param . name ( ) ) ; if ( value == null ) { return null ; } { <LOG> + value ) ; } return new integer ( value ) ; } <comment> <ect>
if ( limit != null && this . joined . size ( ) >= limit ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + <string_literal> + this . isupport <identifiersep> chan <identifiersep> limit . to <identifiersep> string ( ) + <string_literal> + <string_literal> ) ; } <LOG> final result < object , exception > join <identifiersep> signal = new result < object , exception > ( ) ; synchronized ( join <identifiersep> signal ) { logger . trace ( <string_literal> + <string_literal> ) ; <ect>
logger . trace ( <string_literal> + chatroom . get <identifiersep> identifier ( ) + <string_literal> ) ; <comment> <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( e . get <identifiersep> message ( ) , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , e ) ; } } } <comment> <ect>
if ( this . isupport <identifiersep> topic <identifiersep> len != null && subject . length ( ) > this . isupport <identifiersep> topic <identifiersep> len ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + <string_literal> + this . isupport <identifiersep> topic <identifiersep> len + <string_literal> ) ; } <LOG> this . irc . change <identifiersep> topic ( chatroom . get <identifiersep> identifier ( ) , subject == null ? <string_literal> : subject ) ; } <comment> <ect>
throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } try { this . irc . leave <identifiersep> channel ( chat <identifiersep> room <identifiersep> name ) ; } catch ( api <identifiersep> exception e ) { <LOG> } } <comment> <ect>
<comment> private void leave <identifiersep> chat <identifiersep> room ( ) { this . presence <identifiersep> task <identifiersep> timer . cancel ( ) ; this . irc . delete <identifiersep> listener ( this ) ; channel <identifiersep> manager . this . joined . remove ( this . chatroom . get <identifiersep> identifier ( ) ) ; <LOG> + <string_literal> ) ; channel <identifiersep> manager . this . provider . get <identifiersep> muc ( ) . fire <identifiersep> local <identifiersep> user <identifiersep> presence <identifiersep> event ( this . chatroom , local <identifiersep> user <identifiersep> chat <identifiersep> room <identifiersep> presence <identifiersep> change <identifiersep> event . local <identifiersep> user <identifiersep> left , null ) ; } <comment> <ect>
{ <comment> <LOG> this . nick <identifiersep> watch <identifiersep> list . add ( nick ) ; this . irc . raw <identifiersep> message ( <string_literal> + nick ) ; } @ override public void remove ( final string nick ) { logger . trace ( <string_literal> + nick + <string_literal> ) ; <ect>
<comment> public protocol <identifiersep> provider <identifiersep> service <identifiersep> irc <identifiersep> impl ( ) { { <LOG> } } <comment> <ect>
throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . illegal <identifiersep> argument ) ; } try { this . irc . message ( target , message ) ; <LOG> } catch ( runtime <identifiersep> exception e ) { logger . trace ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; throw e ; } } <comment> <ect>
<comment> @ override public void rename <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( final contact <identifiersep> group group , final string new <identifiersep> name ) { <LOG> ( ( contact <identifiersep> group <identifiersep> irc <identifiersep> impl ) group ) . set <identifiersep> group <identifiersep> name ( new <identifiersep> name ) ; } <comment> <ect>
private integer parse <identifiersep> i <identifiersep> support <identifiersep> away <identifiersep> len ( final iirc <identifiersep> state state ) { final string value = state . get <identifiersep> server <identifiersep> options ( ) . get <identifiersep> key ( i <identifiersep> support . awaylen . name ( ) ) ; if ( value == null ) { <LOG> + <string_literal> ) ; return null ; { logger . debug ( <string_literal> + i <identifiersep> support . awaylen . name ( ) + <string_literal> + value ) ; <ect>
private integer parse <identifiersep> i <identifiersep> support <identifiersep> monitor ( final iirc <identifiersep> state state ) { final string value = state . get <identifiersep> server <identifiersep> options ( ) . get <identifiersep> key ( i <identifiersep> support . monitor . name ( ) ) ; if ( value == null ) { <LOG> + <string_literal> ) ; return null ; { logger . debug ( <string_literal> + i <identifiersep> support . monitor . name ( ) + <string_literal> + value ) ; <ect>
private integer parse <identifiersep> i <identifiersep> support <identifiersep> watch ( final iirc <identifiersep> state state ) { final string value = state . get <identifiersep> server <identifiersep> options ( ) . get <identifiersep> key ( i <identifiersep> support . watch . name ( ) ) ; if ( value == null ) { <LOG> + <string_literal> ) ; return null ; { logger . debug ( <string_literal> + i <identifiersep> support . watch . name ( ) + <string_literal> + value ) ; <ect>
+ <string_literal> + value ) ; } try { return new integer ( value ) ; } catch ( runtime <identifiersep> exception e ) { <LOG> return null ; } } <comment> <ect>
this . operation <identifiersep> set = operation <identifiersep> set ; if ( nick <identifiersep> watch <identifiersep> list == null ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } this . nick <identifiersep> watch <identifiersep> list = nick <identifiersep> watch <identifiersep> list ; set <identifiersep> up <identifiersep> presence <identifiersep> watcher ( server <identifiersep> identity ) ; <LOG> } <comment> private void set <identifiersep> up <identifiersep> presence <identifiersep> watcher ( final atomic <identifiersep> reference < string > server <identifiersep> identity ) { <ect>
context . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , irc <identifiersep> provider <identifiersep> factory , hashtable ) ; { <LOG> } } <comment> <ect>
{ @ override public void on <identifiersep> success ( final iirc <identifiersep> state state ) { synchronized ( result ) { <LOG> result . set <identifiersep> done ( state ) ; result . notify <identifiersep> all ( ) ; } } @ override public void on <identifiersep> failure ( final exception e ) { synchronized ( result ) <ect>
{ this . irc . disconnect ( ) ; } catch ( runtime <identifiersep> exception e ) { <comment> <LOG> } } <comment> public irc <identifiersep> api get <identifiersep> client ( ) <ect>
<comment> private boolean away <identifiersep> notify = false ; @ override public void acknowledge ( capability cap ) { <LOG> if ( away <identifiersep> notify . equals ( cap . get <identifiersep> id ( ) ) ) { this . away <identifiersep> notify = true ; } } @ override public void reject ( capability cap ) { <ect>
<comment> public void set <identifiersep> role ( final chat <identifiersep> room <identifiersep> member <identifiersep> role chat <identifiersep> room <identifiersep> member <identifiersep> role ) { <comment> <LOG> return ; } <comment> <ect>
{ <comment> <LOG> this . nick <identifiersep> watch <identifiersep> list . add ( nick ) ; this . irc . raw <identifiersep> message ( <string_literal> + nick ) ; } @ override public void remove ( final string nick ) { logger . trace ( <string_literal> + nick + <string_literal> ) ; <ect>
try { irc . add <identifiersep> listener ( listener ) ; irc . raw <identifiersep> message ( <string_literal> + state . get <identifiersep> nickname ( ) ) ; } catch ( final runtime <identifiersep> exception e ) { <LOG> } } ; } . start ( ) ; } <comment> <ect>
registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> not <identifiersep> specified ) ; throw e ; } catch ( exception e ) { <comment> <LOG> this . provider . set <identifiersep> current <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error ) ; throw e ; } } <comment> <ect>
<comment> @ override public void on <identifiersep> message ( final i <identifiersep> message a <identifiersep> message ) { <LOG> } } <comment> private static final class server <identifiersep> parameters <ect>
try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } return image ; } } <ect>
{ logger . trace ( <string_literal> ) ; } { <comment> <LOG> + <string_literal> ) ; } return collections . unmodifiable <identifiersep> list ( list ) ; } } <comment> <ect>
logger . trace ( <string_literal> + <string_literal> ) ; return null ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <comment> <LOG> return null ; } } <comment> <ect>
try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return image ; } } <ect>
public void add <identifiersep> call <identifiersep> peer ( final call <identifiersep> peer <identifiersep> gibberish <identifiersep> impl call <identifiersep> peer ) { if ( ! do <identifiersep> add <identifiersep> call <identifiersep> peer ( call <identifiersep> peer ) ) return ; call <identifiersep> peer . add <identifiersep> call <identifiersep> peer <identifiersep> listener ( this ) ; <LOG> fire <identifiersep> call <identifiersep> peer <identifiersep> event ( call <identifiersep> peer , call <identifiersep> peer <identifiersep> event . call <identifiersep> peer <identifiersep> added ) ; call <identifiersep> peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . alerting <identifiersep> remote <identifiersep> side , <string_literal> ) ; timer timer1 = new timer ( false ) ; timer1 . schedule ( new timer <identifiersep> task ( ) <ect>
<comment> public protocol <identifiersep> provider <identifiersep> service <identifiersep> gibberish <identifiersep> impl ( ) { <LOG> } <comment> <ect>
<comment> <LOG> } <comment> public static bundle <identifiersep> context get <identifiersep> bundle <identifiersep> context ( ) <ect>
{ account <identifiersep> image = get <identifiersep> image <identifiersep> detail ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { { <LOG> } } return account <identifiersep> image ; } <comment> <ect>
to . set <identifiersep> tag ( local <identifiersep> dialog <identifiersep> tag ) ; } catch ( parse <identifiersep> exception e ) { <comment> <LOG> } } <comment> <ect>
<comment> private void attach <identifiersep> to <identifiersep> tag ( response response , dialog containing <identifiersep> dialog ) { to <identifiersep> header to = ( to <identifiersep> header ) response . get <identifiersep> header ( to <identifiersep> header . name ) ; if ( to == null ) { <LOG> return ; } if ( containing <identifiersep> dialog != null && containing <identifiersep> dialog . get <identifiersep> local <identifiersep> tag ( ) != null ) { logger . debug ( <string_literal> <ect>
return sess <identifiersep> descr ; } catch ( sdp <identifiersep> exception exc ) { <comment> <LOG> <comment> <ect>
update . set <identifiersep> media <identifiersep> descriptions ( complete <identifiersep> media <identifiersep> desc <identifiersep> list ) ; } catch ( sdp <identifiersep> exception e ) { <comment> <LOG> } return update ; } <comment> <ect>
{ pt = byte . parse <identifiersep> byte ( pt <identifiersep> str ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <comment> <LOG> continue ; } attribute rtpmap = null ; try { rtpmap = find <identifiersep> payload <identifiersep> type <identifiersep> specific <identifiersep> attribute ( media <identifiersep> desc . get <identifiersep> attributes ( false ) , sdp <identifiersep> constants . rtpmap , <ect>
catch ( sdp <identifiersep> exception e ) { <comment> <LOG> continue ; } if ( media <identifiersep> format != null ) { <comment> <ect>
public static url get <identifiersep> call <identifiersep> info <identifiersep> url ( session <identifiersep> description sess <identifiersep> desc ) { javax . sdp . uri sdp <identifiersep> uri <identifiersep> field = sess <identifiersep> desc . get <identifiersep> uri ( ) ; if ( sdp <identifiersep> uri <identifiersep> field == null ) { <LOG> return null ; } try { return sdp <identifiersep> uri <identifiersep> field . get ( ) ; } catch ( sdp <identifiersep> parse <identifiersep> exception exc ) { <ect>
{ attr <identifiersep> name = attribute . get <identifiersep> name ( ) ; } catch ( sdp <identifiersep> parse <identifiersep> exception e ) { <comment> <LOG> } for ( media <identifiersep> direction value : media <identifiersep> direction . values ( ) ) if ( value . to <identifiersep> string ( ) . equals ( attr <identifiersep> name ) ) return value ; } return media <identifiersep> direction . sendrecv ; } <comment> <ect>
media <identifiersep> description md = ( media <identifiersep> description ) o ; <comment> <LOG> } <comment> <ect>
too <identifiersep> many <identifiersep> listeners <identifiersep> exception { string context = ( secure ? <string_literal> : <string_literal> ) ; if ( retries < 0 ) { <comment> <LOG> return ; } listening <identifiersep> point tls <identifiersep> lp = null ; listening <identifiersep> point udp <identifiersep> lp = null ; listening <identifiersep> point tcp <identifiersep> lp = null ; try { <ect>
this . clear <identifiersep> jain <identifiersep> sip <identifiersep> provider = this . stack . create <identifiersep> sip <identifiersep> provider ( udp <identifiersep> lp ) ; this . clear <identifiersep> jain <identifiersep> sip <identifiersep> provider . add <identifiersep> listening <identifiersep> point ( tcp <identifiersep> lp ) ; this . clear <identifiersep> jain <identifiersep> sip <identifiersep> provider . add <identifiersep> sip <identifiersep> listener ( this ) ; } <LOG> } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <comment> <ect>
it = lpoints <identifiersep> to <identifiersep> remove . iterator ( ) ; while ( it . has <identifiersep> next ( ) ) { this . stack . delete <identifiersep> listening <identifiersep> point ( it . next ( ) ) ; } this . stack . stop ( ) ; <LOG> } catch ( object <identifiersep> in <identifiersep> use <identifiersep> exception ex ) { logger . fatal ( <string_literal> , ex ) ; } } <comment> <ect>
{ logger . error ( <string_literal> + <string_literal> ) ; } else { <LOG> recipient . process <identifiersep> dialog <identifiersep> terminated ( event ) ; } } catch ( throwable exc ) { <comment> <ect>
public void process <identifiersep> request ( request <identifiersep> event event ) { try { request request = event . get <identifiersep> request ( ) ; <LOG> <comment> if ( event . get <identifiersep> server <identifiersep> transaction ( ) == null ) <ect>
<comment> <LOG> return null ; } uri request <identifiersep> uri = request . get <identifiersep> request <identifiersep> uri ( ) ; if ( request <identifiersep> uri . is <identifiersep> sip <identifiersep> uri ( ) ) { string request <identifiersep> user = ( ( sip <identifiersep> uri ) request <identifiersep> uri ) . get <identifiersep> user ( ) ; list < protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl > candidates = <ect>
string our <identifiersep> host = our <identifiersep> uri . get <identifiersep> host ( ) ; uri to <identifiersep> uri = ( ( to <identifiersep> header ) request . get <identifiersep> header ( to <identifiersep> header . name ) ) . get <identifiersep> address ( ) . get <identifiersep> uri ( ) ; if ( to <identifiersep> uri . is <identifiersep> sip <identifiersep> uri ( ) == false ) continue ; string to <identifiersep> host = ( ( sip <identifiersep> uri ) to <identifiersep> uri ) . get <identifiersep> host ( ) ; <LOG> if ( to <identifiersep> host . equals ( our <identifiersep> host ) ) { logger . trace ( <string_literal> + candidate . get <identifiersep> account <identifiersep> id ( ) + <string_literal> + <string_literal> ) ; <ect>
logger . debug ( <string_literal> + target . get <identifiersep> account <identifiersep> id ( ) + <string_literal> + <string_literal> ) ; <LOG> return target ; } else { logger . error ( <string_literal> ) ; } return null ; } <comment> <ect>
= ( protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) sip <identifiersep> application <identifiersep> data . get <identifiersep> application <identifiersep> data ( transaction . get <identifiersep> request ( ) , sip <identifiersep> application <identifiersep> data . key <identifiersep> service ) ; if ( service != null ) { <LOG> return service ; } service = ( protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) sip <identifiersep> application <identifiersep> data . get <identifiersep> application <identifiersep> data ( transaction . get <identifiersep> dialog ( ) , sip <identifiersep> application <identifiersep> data . key <identifiersep> service ) ; if ( service != null ) <ect>
max <identifiersep> forwards <identifiersep> header max <identifiersep> forwards = sip <identifiersep> factory . get <identifiersep> instance ( ) . create <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> max <identifiersep> forwards <identifiersep> header ( <number_literal> ) ; request . set <identifiersep> header ( max <identifiersep> forwards ) ; } } catch ( throwable ex ) { <LOG> } try { <comment> <ect>
if ( request . get <identifiersep> method ( ) . equals ( request . notify ) && request . get <identifiersep> header ( subscription <identifiersep> state <identifiersep> header . name ) == null ) { return true ; } } catch ( throwable ex ) { <LOG> } return false ; } <comment> map < string , timer <identifiersep> task > reset <identifiersep> listening <identifiersep> points <identifiersep> timers <ect>
operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure ) ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure ) ; } } <comment> <ect>
sipe <identifiersep> tag <identifiersep> header et <identifiersep> header = ( sipe <identifiersep> tag <identifiersep> header ) response . get <identifiersep> header ( sipe <identifiersep> tag <identifiersep> header . name ) ; <comment> <LOG> return false ; } this . distant <identifiersep> paet = et <identifiersep> header . get <identifiersep> e <identifiersep> tag ( ) ; <comment> <ect>
process <identifiersep> authentication <identifiersep> challenge ( client <identifiersep> transaction , response , ( sip <identifiersep> provider ) response <identifiersep> event . get <identifiersep> source ( ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> return false ; } <comment> <ect>
{ transac = this . parent <identifiersep> provider . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( req ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception e ) { <LOG> return false ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) { <ect>
request req = null ; try { req = create <identifiersep> publish ( this . subscription <identifiersep> duration , true ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> return false ; } client <identifiersep> transaction transac = null ; try { transac = this . parent <identifiersep> provider . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) <ect>
if ( pres <identifiersep> list . get <identifiersep> length ( ) == 0 ) { logger . error ( <string_literal> ) ; return ; } } if ( pres <identifiersep> list . get <identifiersep> length ( ) > 1 ) { <LOG> } node pres <identifiersep> node = pres <identifiersep> list . item ( 0 ) ; if ( pres <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) != node . element <identifiersep> node ) { logger . error ( <string_literal> ) ; return ; } element presence = ( element ) pres <identifiersep> node ; <ect>
<comment> <LOG> <comment> <ect>
if ( ! contact <identifiersep> already <identifiersep> listed ) { sipcontact . add ( tab ) ; } } } if ( sipcontact . is <identifiersep> empty ( ) ) { <LOG> continue ; } <comment> <ect>
break ; } index -- ; } while ( index >= 0 ) ; if ( basic <identifiersep> node == null ) { <LOG> } else { basic = ( element ) basic <identifiersep> node ; } } <comment> <ect>
logger . warn ( <string_literal> ) ; return ; } document doc = convert <identifiersep> document ( watcher <identifiersep> info <identifiersep> doc ) ; if ( doc == null ) return ; <LOG> <comment> <ect>
if ( watch <identifiersep> list . get <identifiersep> length ( ) == 0 ) { logger . error ( <string_literal> ) ; return ; } } if ( watch <identifiersep> list . get <identifiersep> length ( ) > 1 ) { <LOG> } node watcher <identifiersep> info <identifiersep> node = watch <identifiersep> list . item ( 0 ) ; if ( watcher <identifiersep> info <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) != node . element <identifiersep> node ) { logger . error ( <string_literal> ) ; return ; } element watcher <identifiersep> info = ( element ) watcher <identifiersep> info <identifiersep> node ; <ect>
try { current <identifiersep> version = integer . parse <identifiersep> int ( watcher <identifiersep> info . get <identifiersep> attribute ( version <identifiersep> attribute ) ) ; } catch ( throwable t ) { <LOG> } if ( current <identifiersep> version != - 1 && current <identifiersep> version < = subscriber . version ) { logger . warn ( <string_literal> ) ; return ; } else subscriber . version = current <identifiersep> version ; <ect>
watcher <identifiersep> info , watcherlist <identifiersep> element , resource <identifiersep> attribute , parent <identifiersep> provider . get <identifiersep> registrar <identifiersep> connection ( ) . get <identifiersep> address <identifiersep> of <identifiersep> record ( ) . get <identifiersep> uri ( ) . to <identifiersep> string ( ) ) ; if ( wlist == null || ! wlist . get <identifiersep> attribute ( package <identifiersep> attribute ) . equals ( presence <identifiersep> element ) ) { <LOG> return ; } node <identifiersep> list watcher <identifiersep> list = wlist . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name <identifiersep> ns ( any <identifiersep> ns , watcher <identifiersep> element ) ; for ( int i = 0 ; i < watcher <identifiersep> list . get <identifiersep> length ( ) ; i ++ ) { node watcher <identifiersep> node = watcher <identifiersep> list . item ( i ) ; <ect>
string status = watcher . get <identifiersep> attribute ( status <identifiersep> element ) ; string contact <identifiersep> id = get <identifiersep> text <identifiersep> content ( watcher ) ; <comment> <LOG> continue ; } if ( status . equals ( <string_literal> ) || status . equals ( <string_literal> ) ) { contact <identifiersep> sip <identifiersep> impl contact = resolve <identifiersep> contact <identifiersep> id ( contact <identifiersep> id ) ; if ( contact != null ) { <ect>
<comment> <LOG> } } <comment> public void unsubscribe <identifiersep> to <identifiersep> all <identifiersep> contact ( ) { <ect>
{ try { unsubscribe ( contact , false ) ; } catch ( throwable ex ) { <LOG> } } } <comment> private void unsubscribe <identifiersep> to <identifiersep> all <identifiersep> event <identifiersep> subscribers ( ) { <ect>
try { transac = parent <identifiersep> provider . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( req ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception e ) { <LOG> return ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) { <ect>
<comment> <LOG> } } } } } <comment> <ect>
try { publish <identifiersep> presence <identifiersep> status ( sip <identifiersep> status <identifiersep> enum . get <identifiersep> status ( sip <identifiersep> status <identifiersep> enum . offline ) , <string_literal> ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> } stop <identifiersep> events ( ) ; } else if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { { logger . debug ( <string_literal> ) ; <ect>
else if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . connection <identifiersep> failed ) || evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . authentication <identifiersep> failed ) ) { { <LOG> } <comment> <ect>
<comment> @ override protected void process <identifiersep> failure <identifiersep> response ( response <identifiersep> event response <identifiersep> event , int status <identifiersep> code ) { <LOG> } <comment> <ect>
process <identifiersep> refer ( server <identifiersep> transaction , request , jain <identifiersep> sip <identifiersep> provider ) ; processed = true ; } <comment> <LOG> processed = process <identifiersep> notify ( server <identifiersep> transaction , request ) ; } else if ( request <identifiersep> method . equals ( request . update ) ) { logger . debug ( <string_literal> ) ; processed = process <identifiersep> update ( server <identifiersep> transaction , request ) ; <ect>
client <identifiersep> transaction client <identifiersep> transaction = response <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; response response = response <identifiersep> event . get <identifiersep> response ( ) ; c <identifiersep> seq <identifiersep> header cseq = ( ( c <identifiersep> seq <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> seq <identifiersep> header . name ) ) ; if ( cseq == null ) { <LOG> return false ; } string method = cseq . get <identifiersep> method ( ) ; sip <identifiersep> provider source <identifiersep> provider = ( sip <identifiersep> provider ) response <identifiersep> event . get <identifiersep> source ( ) ; int response <identifiersep> status <identifiersep> code = response . get <identifiersep> status <identifiersep> code ( ) ; boolean processed = false ; switch ( response <identifiersep> status <identifiersep> code ) <ect>
string reason = response . get <identifiersep> reason <identifiersep> phrase ( ) ; warning <identifiersep> header warning <identifiersep> header = ( warning <identifiersep> header ) response . get <identifiersep> header ( warning <identifiersep> header . name ) ; if ( warning <identifiersep> header != null ) { reason = warning <identifiersep> header . get <identifiersep> text ( ) ; <LOG> + <string_literal> + response . get <identifiersep> reason <identifiersep> phrase ( ) + <string_literal> + warning <identifiersep> header . get <identifiersep> text ( ) + <string_literal> + warning <identifiersep> header . get <identifiersep> agent ( ) + <string_literal> + warning <identifiersep> header . get <identifiersep> name ( ) ) ; } else { <ect>
dialog dialog = client <identifiersep> transaction . get <identifiersep> dialog ( ) ; <comment> <LOG> return ; } <comment> <ect>
client <identifiersep> transaction . get <identifiersep> branch <identifiersep> id ( ) , ok . get <identifiersep> header ( call <identifiersep> id <identifiersep> header . name ) ) ; if ( call <identifiersep> peer == null ) { <comment> <LOG> return ; } <comment> <ect>
<comment> <LOG> client <identifiersep> transaction retry <identifiersep> tran = protocol <identifiersep> provider . get <identifiersep> sip <identifiersep> security <identifiersep> manager ( ) . handle <identifiersep> challenge ( response , client <identifiersep> transaction , jain <identifiersep> sip <identifiersep> provider ) ; if ( retry <identifiersep> tran == null ) { <ect>
transaction = timeout <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; } call <identifiersep> peer <identifiersep> sip <identifiersep> impl call <identifiersep> peer = active <identifiersep> calls <identifiersep> repository . find <identifiersep> call <identifiersep> peer ( transaction . get <identifiersep> dialog ( ) ) ; if ( call <identifiersep> peer == null ) { <LOG> return false ; } <comment> <ect>
{ protocol <identifiersep> provider . say <identifiersep> error ( server <identifiersep> transaction , response . session <identifiersep> not <identifiersep> acceptable , warning ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> } return true ; } return false ; } <comment> <ect>
<comment> private void process <identifiersep> stray <identifiersep> invite ( server <identifiersep> transaction server <identifiersep> transaction ) { <LOG> request invite <identifiersep> request = server <identifiersep> transaction . get <identifiersep> request ( ) ; <comment> <ect>
call <identifiersep> peer <identifiersep> sip <identifiersep> impl call <identifiersep> peer = active <identifiersep> calls <identifiersep> repository . find <identifiersep> call <identifiersep> peer ( server <identifiersep> transaction . get <identifiersep> dialog ( ) ) ; if ( call <identifiersep> peer == null ) { <LOG> return ; } call <identifiersep> peer . process <identifiersep> cancel ( server <identifiersep> transaction ) ; } <comment> <ect>
decline <identifiersep> response = protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . decline , refer <identifiersep> request ) ; } catch ( parse <identifiersep> exception e ) { <LOG> return ; } try { server <identifiersep> transaction . send <identifiersep> response ( decline <identifiersep> response ) ; } catch ( exception e ) { <ect>
return false ; } dialog dialog = server <identifiersep> transaction . get <identifiersep> dialog ( ) ; call <identifiersep> peer <identifiersep> sip <identifiersep> impl peer = active <identifiersep> calls <identifiersep> repository . find <identifiersep> call <identifiersep> peer ( dialog ) ; if ( peer == null ) { <LOG> return false ; } <comment> <ect>
long start <identifiersep> time = ( long ) tone <identifiersep> info [ 1 ] ; say <identifiersep> info ( call <identifiersep> peer , ( dtmf <identifiersep> tone ) tone <identifiersep> info [ 0 ] , system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> } } } <comment> <ect>
<comment> <LOG> } catch ( sip <identifiersep> exception ex ) { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , ex ) ; <ect>
else { response response = response <identifiersep> event . get <identifiersep> response ( ) ; if ( response == null ) { <LOG> } else { <comment> <ect>
else { request request = client <identifiersep> transaction . get <identifiersep> request ( ) ; if ( request == null ) { <LOG> } else { content <identifiersep> type <identifiersep> header content <identifiersep> type <identifiersep> header = ( content <identifiersep> type <identifiersep> header ) request . get <identifiersep> header ( content <identifiersep> type <identifiersep> header . name ) ; if ( ( content <identifiersep> type <identifiersep> header != null ) <ect>
{ for ( dtmf <identifiersep> listener listener : listeners ) { listener . tone <identifiersep> received ( evt ) ; } } catch ( throwable e ) { <LOG> } } <comment> <ect>
current <identifiersep> conf <identifiersep> info . set <identifiersep> version ( new <identifiersep> version ) ; call <identifiersep> peer . set <identifiersep> last <identifiersep> conference <identifiersep> info <identifiersep> sent ( current <identifiersep> conf <identifiersep> info ) ; call <identifiersep> peer . set <identifiersep> last <identifiersep> conference <identifiersep> info <identifiersep> sent <identifiersep> timestamp ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; } catch ( sip <identifiersep> exception sex ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , sex ) ; } } if ( subscription <identifiersep> state . terminated . equals ( subscription <identifiersep> state ) ) <ect>
<comment> private string get <identifiersep> text <identifiersep> content ( element node ) { string res = xml <identifiersep> utils . get <identifiersep> text ( node ) ; if ( res == null ) { <LOG> return <string_literal> ; } return res ; } <comment> <ect>
return false ; } <comment> <LOG> return true ; } contact from = op <identifiersep> set <identifiersep> pers <identifiersep> presence . resolve <identifiersep> contact <identifiersep> id ( from <identifiersep> header . get <identifiersep> address ( ) . get <identifiersep> uri ( ) . to <identifiersep> string ( ) ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
response ok = parent <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response , request <identifiersep> event . get <identifiersep> request ( ) ) ; sip <identifiersep> stack <identifiersep> sharing . get <identifiersep> or <identifiersep> create <identifiersep> server <identifiersep> transaction ( request <identifiersep> event ) . send <identifiersep> response ( ok ) ; } catch ( parse <identifiersep> exception exc ) { <LOG> } catch ( sip <identifiersep> exception exc ) { logger . error ( <string_literal> + exc . get <identifiersep> message ( ) , exc ) ; } catch ( invalid <identifiersep> argument <identifiersep> exception exc ) <ect>
return <identifiersep> hop = new hop <identifiersep> impl ( input <identifiersep> address . get <identifiersep> host ( ) , message <identifiersep> processor . get <identifiersep> default <identifiersep> port ( transport ) , transport ) ; } <LOG> return return <identifiersep> hop ; } } <ect>
= protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> event <identifiersep> header ( event <identifiersep> package ) ; } catch ( parse <identifiersep> exception e ) { <comment> <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , e ) ; } <comment> <ect>
{ c <identifiersep> type <identifiersep> header = protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> content <identifiersep> type <identifiersep> header ( <string_literal> , content <identifiersep> sub <identifiersep> type ) ; } catch ( parse <identifiersep> exception e ) { <comment> <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , e ) ; } req . set <identifiersep> header ( max <identifiersep> forwards ) ; <ect>
call <identifiersep> id = dialog . get <identifiersep> call <identifiersep> id ( ) . get <identifiersep> call <identifiersep> id ( ) ; try { dialog . send <identifiersep> request ( transac ) ; } catch ( sip <identifiersep> exception sex ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , sex ) ; } } if ( subscription <identifiersep> state . terminated . equals ( subscription <identifiersep> state ) ) <ect>
= protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> min <identifiersep> expires <identifiersep> header ( subscribe <identifiersep> min <identifiersep> expire ) ; } catch ( invalid <identifiersep> argument <identifiersep> exception e ) { <comment> <LOG> return false ; } response . set <identifiersep> header ( min ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) <ect>
try { response = protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . ok , request ) ; } catch ( exception e ) { <LOG> return false ; } <comment> <ect>
response . set <identifiersep> header ( exp <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) { <LOG> return false ; } return true ; } else { <comment> <ect>
remove <identifiersep> subscription ( call <identifiersep> id , subscription ) ; try { dialog . send <identifiersep> request ( transac ) ; } catch ( exception e ) { <LOG> return false ; } } } if ( subscription == null ) { from <identifiersep> header from <identifiersep> header = ( from <identifiersep> header ) request . get <identifiersep> header ( from <identifiersep> header . name ) ; address from <identifiersep> address = from <identifiersep> header . get <identifiersep> address ( ) ; <ect>
try { exp <identifiersep> header = protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> expires <identifiersep> header ( 0 ) ; } catch ( invalid <identifiersep> argument <identifiersep> exception e ) { <LOG> return false ; } response . set <identifiersep> header ( exp <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) <ect>
process <identifiersep> authentication <identifiersep> challenge ( client <identifiersep> transaction , response , ( sip <identifiersep> provider ) response <identifiersep> event . get <identifiersep> source ( ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> <comment> <ect>
else sdp <identifiersep> answer = get <identifiersep> media <identifiersep> handler ( ) . create <identifiersep> offer ( ) ; response . set <identifiersep> content ( sdp <identifiersep> answer , get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> content <identifiersep> type <identifiersep> header ( <string_literal> , <string_literal> ) ) ; <LOG> server <identifiersep> transaction . send <identifiersep> response ( response ) ; logger . debug ( <string_literal> ) ; } catch ( exception ex ) <comment> <ect>
server <identifiersep> transaction . send <identifiersep> response ( response ) ; logger . debug ( <string_literal> ) ; } catch ( exception ex ) <comment> <LOG> set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . failed , <string_literal> + ex . get <identifiersep> message ( ) ) ; get <identifiersep> protocol <identifiersep> provider ( ) . say <identifiersep> error <identifiersep> silently ( server <identifiersep> transaction , response . server <identifiersep> internal <identifiersep> error ) ; return ; } reeval <identifiersep> remote <identifiersep> hold <identifiersep> status ( ) ; <ect>
<comment> } if ( ok != null ) try { bye <identifiersep> tran . send <identifiersep> response ( ok ) ; <LOG> } catch ( exception ex ) { <comment> <ect>
<comment> <LOG> return ; } server <identifiersep> transaction invite <identifiersep> tran = ( server <identifiersep> transaction ) tran ; request invite = get <identifiersep> latest <identifiersep> invite <identifiersep> transaction ( ) . get <identifiersep> request ( ) ; response request <identifiersep> terminated = message <identifiersep> factory . create <identifiersep> response ( response . request <identifiersep> terminated , invite ) ; <ect>
info . set <identifiersep> content <identifiersep> length ( cl ) ; try { info . set <identifiersep> content ( content . get <identifiersep> bytes ( ) , ct ) ; } catch ( parse <identifiersep> exception ex ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , ex ) ; } <comment> <ect>
else if ( peer <identifiersep> state . equals ( call <identifiersep> peer <identifiersep> state . failed ) ) { set <identifiersep> disconnected <identifiersep> state ( failed , reason ) ; } else { set <identifiersep> disconnected <identifiersep> state ( failed , reason ) ; <LOG> } } <comment> <ect>
server <identifiersep> transaction server <identifiersep> transaction = ( server <identifiersep> transaction ) get <identifiersep> latest <identifiersep> invite <identifiersep> transaction ( ) ; try { server <identifiersep> transaction . send <identifiersep> response ( busy <identifiersep> here ) ; <LOG> } catch ( exception ex ) { protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl . throw <identifiersep> operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , ex , logger ) ; } } <comment> <ect>
request cancel = client <identifiersep> transaction . create <identifiersep> cancel ( ) ; client <identifiersep> transaction cancel <identifiersep> transaction = get <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( cancel ) ; cancel <identifiersep> transaction . send <identifiersep> request ( ) ; <LOG> } catch ( sip <identifiersep> exception ex ) { protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl . throw <identifiersep> operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , ex , logger ) ; } } <comment> <ect>
set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . failed , ex . get <identifiersep> message ( ) ) ; return ; } try { server <identifiersep> transaction . send <identifiersep> response ( ok ) ; <LOG> } catch ( exception ex ) { set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . disconnected ) ; protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl . throw <identifiersep> operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , ex , logger ) ; <ect>
<comment> <LOG> } else { <comment> <ect>
{ string callid = call . get <identifiersep> call <identifiersep> id ( ) ; cached <identifiersep> credentials . cache <identifiersep> authorization <identifiersep> header ( callid , authorization ) ; } reoriginated <identifiersep> request . add <identifiersep> header ( authorization ) ; } <LOG> return retry <identifiersep> tran ; } <comment> <ect>
request . set <identifiersep> header ( new <identifiersep> via <identifiersep> header ) ; } catch ( exception exc ) { <comment> <LOG> } } <comment> <ect>
. show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( message , title , popup <identifiersep> dialog . error <identifiersep> message ) ; } catch ( throwable t ) { <LOG> } } <comment> <ect>
provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> allow <identifiersep> header ( method ) ) ; } add <identifiersep> allow <identifiersep> events <identifiersep> header ( options <identifiersep> ok ) ; } catch ( parse <identifiersep> exception ex ) { <comment> <LOG> return false ; } try { sip <identifiersep> stack <identifiersep> sharing . get <identifiersep> or <identifiersep> create <identifiersep> server <identifiersep> transaction ( request <identifiersep> event ) . send <identifiersep> response ( options <identifiersep> ok ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception ex ) <ect>
logger . trace ( <string_literal> , ex ) ; return false ; } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <comment> <LOG> return false ; } catch ( sip <identifiersep> exception ex ) { <comment> <ect>
else if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { string keep <identifiersep> alive <identifiersep> method = provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> property <identifiersep> string ( protocol <identifiersep> provider <identifiersep> factory . keep <identifiersep> alive <identifiersep> method ) ; <LOG> <comment> <ect>
keep <identifiersep> alive <identifiersep> task = new cr <identifiersep> lf <identifiersep> keep <identifiersep> alive <identifiersep> task ( ) ; } else { <comment> <LOG> keep <identifiersep> alive <identifiersep> timer . schedule ( keep <identifiersep> alive <identifiersep> task , 0 , keep <identifiersep> alive <identifiersep> interval * <number_literal> ) ; } } } } } <ect>
{ try { re <identifiersep> invite ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ofe ) { <LOG> } finally { super . conference <identifiersep> focus <identifiersep> changed ( old <identifiersep> value , new <identifiersep> value ) ; } } <comment> <ect>
+ <string_literal> + get <identifiersep> call <identifiersep> peer <identifiersep> count ( ) + <string_literal> ) ; } for ( call <identifiersep> peer <identifiersep> sip <identifiersep> impl call <identifiersep> peer : get <identifiersep> call <identifiersep> peer <identifiersep> list ( ) ) { if ( call <identifiersep> peer . get <identifiersep> dialog ( ) == dialog ) { <LOG> return call <identifiersep> peer ; } else { logger . trace ( <string_literal> + call <identifiersep> peer + <string_literal> + call <identifiersep> peer . get <identifiersep> dialog ( ) + <string_literal> + dialog ) ; <ect>
{ sip <identifiersep> uri  <identifiersep> callee <identifiersep> uri = ( sip <identifiersep> uri ) callee <identifiersep> uri ; <comment> <LOG> } } <comment> <ect>
{ logger . trace ( <string_literal> + force <identifiersep> transport ) ; jain <identifiersep> sip <identifiersep> provider = get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> jain <identifiersep> sip <identifiersep> provider ( force <identifiersep> transport ) ; } else { <LOG> jain <identifiersep> sip <identifiersep> provider = get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) ; } try { invite <identifiersep> transaction = jain <identifiersep> sip <identifiersep> provider . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( invite ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception ex ) <ect>
{ delay += interval ; timer . schedule ( new ringing <identifiersep> response <identifiersep> task ( response , server <identifiersep> tran , peer , timer ) , delay ) ; interval *= <number_literal> ; } } <LOG> } } catch ( exception ex ) { logger . error ( <string_literal> , ex ) ; peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . failed , <string_literal> + ex . get <identifiersep> message ( ) ) ; return peer ; <ect>
request . set <identifiersep> header ( protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> header ( name , value ) ) ; } else request . add <identifiersep> header ( new custom <identifiersep> header <identifiersep> list ( name , value ) ) ; } catch ( exception e ) { <LOG> } } } <comment> <ect>
try { local <identifiersep> md . set <identifiersep> attribute ( <string_literal> , local <identifiersep> attr . encode ( ) ) ; return true ; } catch ( sdp <identifiersep> exception e ) { <LOG> } } else { <comment> <ect>
<comment> b = true ; } } } catch ( sdp <identifiersep> exception ex ) { <LOG> } } return b ; } <comment> <ect>
if ( media <identifiersep> description . get <identifiersep> attribute ( sdp <identifiersep> utils . zrtp <identifiersep> hash <identifiersep> attr ) != null ) { add <identifiersep> advertised <identifiersep> encryption <identifiersep> method ( srtp <identifiersep> control <identifiersep> type . zrtp ) ; } } catch ( sdp <identifiersep> parse <identifiersep> exception e ) { <LOG> } <comment> <ect>
{ accept = header <identifiersep> factory . create <identifiersep> accept <identifiersep> header ( <string_literal> , content <identifiersep> sub <identifiersep> type ) ; } catch ( parse <identifiersep> exception e ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , e ) ; } req . set <identifiersep> header ( accept ) ; <ect>
<comment> return false ; } if ( ! request . notify . equals ( request . get <identifiersep> method ( ) ) ) return false ; <LOG> subscription <identifiersep> state <identifiersep> header sstate <identifiersep> header = ( subscription <identifiersep> state <identifiersep> header ) request . get <identifiersep> header ( subscription <identifiersep> state <identifiersep> header . name ) ; <comment> <ect>
subscription subscription = get <identifiersep> subscription ( call <identifiersep> id ) ; <comment> <LOG> <comment> <ect>
return false ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( sip <identifiersep> exception e ) { <LOG> } catch ( invalid <identifiersep> argument <identifiersep> exception e ) { <comment> <ect>
= protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> accept <identifiersep> header ( <string_literal> , content <identifiersep> sub <identifiersep> type ) ; } catch ( parse <identifiersep> exception e ) { <comment> <LOG> return false ; } response . set <identifiersep> header ( accept <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( sip <identifiersep> exception e ) <ect>
process <identifiersep> authentication <identifiersep> challenge ( client <identifiersep> transaction , response , source <identifiersep> provider ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> remove <identifiersep> subscription ( call <identifiersep> id , subscription ) ; subscription . process <identifiersep> failure <identifiersep> response ( response <identifiersep> event , status <identifiersep> code ) ; } <comment> <ect>
{ subscribe <identifiersep> transaction = create <identifiersep> subscription ( subscription , dialog , 0 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> throw e ; } <comment> <ect>
= create <identifiersep> subscription ( subscription , dialog , subscription <identifiersep> duration ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> return ; } try { dialog . send <identifiersep> request ( transac ) ; } catch ( sip <identifiersep> exception e ) { <ect>
id . get <identifiersep> account <identifiersep> property <identifiersep> string ( protocol <identifiersep> provider <identifiersep> factory . user <identifiersep> id ) ; int index = user <identifiersep> id . index <identifiersep> of ( ' @ ' ) ; if ( index > - 1 ) { identities . add ( user <identifiersep> id . substring ( index + 1 ) ) ; <LOG> + <string_literal> ) ; } return certificate <identifiersep> verification . get <identifiersep> ssl <identifiersep> context ( id . get <identifiersep> account <identifiersep> property <identifiersep> string ( protocol <identifiersep> provider <identifiersep> factory . client <identifiersep> tls <identifiersep> certificate ) , certificate <identifiersep> verification . get <identifiersep> trust <identifiersep> manager ( identities , <ect>
int tc = get <identifiersep> dscp ( ) ; try { s . set <identifiersep> traffic <identifiersep> class ( tc ) ; } catch ( socket <identifiersep> exception e ) { <LOG> } } <comment> private int get <identifiersep> dscp ( ) <ect>
<comment> <LOG> <comment> <ect>
{ for ( list < ? > alt <identifiersep> name : subj <identifiersep> alt <identifiersep> names ) { if ( alt <identifiersep> name . get ( 0 ) . equals ( dns <identifiersep> name <identifiersep> type ) ) { <LOG> cert <identifiersep> identities . add ( alt <identifiersep> name . get ( 1 ) . to <identifiersep> string ( ) ) ; } } } } else { <comment> <ect>
if ( lookups . length == 0 ) { lookups = null ; return false ; } } catch ( parse <identifiersep> exception e ) { <LOG> return false ; } } <comment> <ect>
? listening <identifiersep> point . port <identifiersep> <number_literal> : listening <identifiersep> point . port <identifiersep> <number_literal> ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <comment> <LOG> return false ; } transport = default <identifiersep> transport ; return true ; } return false ; case naptr : naptr <identifiersep> records = nu . get <identifiersep> naptr <identifiersep> records ( address ) ; <ect>
{ try { message <identifiersep> waiting <identifiersep> subscriber . subscribe ( default <identifiersep> subscriber ) ; } catch ( throwable e ) { <LOG> } } } else if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistering ) ) { if ( message <identifiersep> waiting <identifiersep> subscriber != null ) { try { <ect>
1 , 0 , 0 , 0 ) ; } } catch ( io <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
<comment> @ override protected void process <identifiersep> success <identifiersep> response ( response <identifiersep> event response <identifiersep> event , int status <identifiersep> code ) { <LOG> } <comment> <ect>
cp <identifiersep> dtmf <identifiersep> method = dtmf <identifiersep> method . inband <identifiersep> dtmf ; } } <comment> <LOG> } ( ( audio <identifiersep> media <identifiersep> stream ) cp . get <identifiersep> media <identifiersep> handler ( ) . get <identifiersep> stream ( media <identifiersep> type . audio ) ) . start <identifiersep> sending <identifiersep> dtmf ( tone , cp <identifiersep> dtmf <identifiersep> method , minimal <identifiersep> tone <identifiersep> duration , maximal <identifiersep> tone <identifiersep> duration , <ect>
sip <identifiersep> provider jain <identifiersep> sip <identifiersep> provider ) throws operation <identifiersep> failed <identifiersep> exception { try { <LOG> client <identifiersep> transaction retry <identifiersep> tran = protocol <identifiersep> provider . get <identifiersep> sip <identifiersep> security <identifiersep> manager ( ) . handle <identifiersep> challenge ( response , client <identifiersep> transaction , <ect>
response = provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . not <identifiersep> implemented , request ) ; } catch ( parse <identifiersep> exception e ) { <LOG> return false ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) { <ect>
<comment> public void start ( bundle <identifiersep> context context ) throws exception { <LOG> sip <identifiersep> activator . bundle <identifiersep> context = context ; sip <identifiersep> provider <identifiersep> factory = create <identifiersep> protocol <identifiersep> provider <identifiersep> factory ( ) ; <comment> <ect>
add <identifiersep> contact <identifiersep> to <identifiersep> rule ( white <identifiersep> rule , contact ) ; update <identifiersep> rules = true ; } } if ( update <identifiersep> rules ) update <identifiersep> pres <identifiersep> rules ( ) ; } } catch ( x <identifiersep> cap <identifiersep> exception e ) { <LOG> <comment> <ect>
try { if ( add <identifiersep> contact <identifiersep> to <identifiersep> block <identifiersep> list ( contact ) ) update <identifiersep> pres <identifiersep> rules ( ) ; } catch ( x <identifiersep> cap <identifiersep> exception ex ) { <LOG> } } <comment> @ override public void authorization <identifiersep> ignored ( contact <identifiersep> sip <identifiersep> impl contact ) <ect>
contact <identifiersep> type <identifiersep> element <identifiersep> name ) ; any <identifiersep> elements . add ( type <identifiersep> element ) ; } type <identifiersep> element . set <identifiersep> text <identifiersep> content ( contact <identifiersep> type ) ; contact <identifiersep> sip . set <identifiersep> any ( any <identifiersep> elements ) ; } catch ( throwable t ) { <LOG> } } } <ect>
sip <identifiersep> security <identifiersep> manager . set <identifiersep> security <identifiersep> authority ( authority ) ; init <identifiersep> registrar <identifiersep> connection ( ) ; <comment> <LOG> fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state . registering , registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> server <identifiersep> not <identifiersep> found , <string_literal> ) ; } } <comment> <ect>
<comment> <LOG> + <string_literal> + method ) ; for ( method <identifiersep> processor processor : processors ) if ( processor . process <identifiersep> response ( response <identifiersep> event ) ) break ; } } <comment> <ect>
logger . debug ( <string_literal> ) ; return ; } early <identifiersep> process <identifiersep> message ( timeout <identifiersep> event ) ; request request = transaction . get <identifiersep> request ( ) ; <LOG> <comment> <ect>
<comment> <LOG> + <string_literal> + method ) ; for ( method <identifiersep> processor processor : processors ) { if ( processor . process <identifiersep> transaction <identifiersep> terminated ( transaction <identifiersep> terminated <identifiersep> event ) ) { <ect>
try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; return ; } catch ( sip <identifiersep> exception e ) { <LOG> } catch ( invalid <identifiersep> argument <identifiersep> exception e ) { <comment> <ect>
<comment> public void run ( ) { <LOG> <comment> <ect>
if ( service instanceof protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) instances . add ( ( protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) service ) ; } return instances ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> <comment> <ect>
logger . trace ( <string_literal> + transport + <string_literal> ) ; <comment> <LOG> transport = connection . get <identifiersep> transport ( ) ; } if ( ! is <identifiersep> valid <identifiersep> transport ( transport ) ) { transport = get <identifiersep> default <identifiersep> transport ( ) ; } listening <identifiersep> point lp = null ; if ( transport . equals <identifiersep> ignore <identifiersep> case ( listening <identifiersep> point . udp ) ) <ect>
<string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , ex , logger ) ; } try { server <identifiersep> transaction . send <identifiersep> response ( error <identifiersep> response ) ; <LOG> } catch ( exception ex ) { protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl . throw <identifiersep> operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , ex , logger ) ; } } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { <LOG> collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) ) { logger . debug ( <string_literal> ) ; <ect>
destination <identifiersep> inet <identifiersep> address = temp <identifiersep> conn . get <identifiersep> address ( ) ; else throw new illegal <identifiersep> argument <identifiersep> exception ( destination . get <identifiersep> host ( ) + <string_literal> ) ; } catch ( dnssec <identifiersep> exception e ) { <LOG> logger . debug ( <string_literal> + destination <identifiersep> inet <identifiersep> address + <string_literal> + destination . get <identifiersep> host ( ) ) ; return destination <identifiersep> inet <identifiersep> address ; } <comment> <ect>
registration <identifiersep> state . unregistered , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> user <identifiersep> request , <string_literal> ) ; return true ; } catch ( throwable e ) { <LOG> sip <identifiersep> registrar <identifiersep> connection . set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> not <identifiersep> specified , <string_literal> ) ; } <comment> <ect>
= sip <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> property <identifiersep> boolean ( protocol <identifiersep> provider <identifiersep> factory . force <identifiersep> proxy <identifiersep> bypass , false ) ; <comment> <LOG> return this . get <identifiersep> default <identifiersep> router ( ) ; } <comment> <ect>
logger . warn ( <string_literal> , ex ) ; content = new string ( req . get <identifiersep> raw <identifiersep> content ( ) ) ; } <comment> <LOG> return false ; } contact to = op <identifiersep> set <identifiersep> pers <identifiersep> presence . resolve <identifiersep> contact <identifiersep> id ( to <identifiersep> header . get <identifiersep> address ( ) . get <identifiersep> uri ( ) . to <identifiersep> string ( ) ) ; message failed <identifiersep> message = null ; if ( to == null ) { logger . error ( <ect>
try { content = new string ( req . get <identifiersep> raw <identifiersep> content ( ) , get <identifiersep> charset ( req ) ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception ex ) { <LOG> content = new string ( request <identifiersep> event . get <identifiersep> request ( ) . get <identifiersep> raw <identifiersep> content ( ) ) ; } <comment> <ect>
response ok = sip <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . ok , request <identifiersep> event . get <identifiersep> request ( ) ) ; sip <identifiersep> stack <identifiersep> sharing . get <identifiersep> or <identifiersep> create <identifiersep> server <identifiersep> transaction ( request <identifiersep> event ) . send <identifiersep> response ( ok ) ; } catch ( parse <identifiersep> exception exc ) { <LOG> } catch ( sip <identifiersep> exception exc ) { logger . error ( <string_literal> + exc . get <identifiersep> message ( ) , exc ) ; } catch ( invalid <identifiersep> argument <identifiersep> exception exc ) <ect>
<comment> <LOG> return false ; } contact to = op <identifiersep> set <identifiersep> pers <identifiersep> presence . resolve <identifiersep> contact <identifiersep> id ( to <identifiersep> header . get <identifiersep> address ( ) . get <identifiersep> uri ( ) . to <identifiersep> string ( ) ) ; if ( to == null ) { logger . error ( <ect>
{ process <identifiersep> authentication <identifiersep> challenge ( client <identifiersep> transaction , response <identifiersep> event . get <identifiersep> response ( ) , source <identifiersep> provider ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> <comment> <ect>
, client <identifiersep> transaction , jain <identifiersep> sip <identifiersep> provider , seq <identifiersep> n ++ ) ; } if ( retry <identifiersep> tran == null ) { <LOG> return ; } retry <identifiersep> tran . send <identifiersep> request ( ) ; return ; } catch ( exception exc ) { logger . error ( <string_literal> , <ect>
. create <identifiersep> header ( desktop <identifiersep> sharing <identifiersep> call <identifiersep> sip <identifiersep> impl . dssid <identifiersep> header , dssid ) ; res . get <identifiersep> request ( ) . set <identifiersep> header ( dssid <identifiersep> header ) ; } catch ( parse <identifiersep> exception ex ) { <LOG> } } return res ; } } ; } <comment> <ect>
<comment> public void log <identifiersep> stack <identifiersep> trace ( int trace <identifiersep> level ) { <LOG> } <comment> public int get <identifiersep> line <identifiersep> count ( ) <ect>
<comment> public void log <identifiersep> exception ( throwable ex ) { logger . warn ( <string_literal> + ex . get <identifiersep> message ( ) ) ; <LOG> } <comment> <ect>
<comment> public void log <identifiersep> fatal <identifiersep> error ( string message ) { <LOG> } <comment> public void log <identifiersep> error ( string message ) <ect>
<comment> public void log <identifiersep> error ( string message , exception ex ) { <LOG> } <comment> public void log <identifiersep> warning ( string string ) <ect>
<comment> public void log <identifiersep> info ( string string ) { <LOG> } <comment> public void disable <identifiersep> logging ( ) { } <comment> <ect>
{ try { log <identifiersep> packet ( message , sender ) ; } catch ( throwable e ) { <LOG> } } <comment> <ect>
try { connect ( server <identifiersep> address ) ; } catch ( throwable ex ) { show <identifiersep> error ( ex , null , null ) ; <LOG> return ; } thread thread = new thread ( this , this . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; thread . set <identifiersep> daemon ( true ) ; thread . start ( ) ; if ( ! login ( username ) ) { <ect>
show <identifiersep> error ( null , null , <string_literal> ) ; logger . error ( <string_literal> ) ; return ; } } catch ( throwable t ) { <LOG> } } <comment> <ect>
try { connection <identifiersep> reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( connection . get <identifiersep> input <identifiersep> stream ( ) ) ) ; if ( ! connection <identifiersep> reader . read <identifiersep> line ( ) . contains ( <string_literal> ) ) { <LOG> destroy ( ) ; return ; } string line ; while ( ( line = connection <identifiersep> reader . read <identifiersep> line ( ) ) != null || ! stopped ) { try <ect>
obj . put ( <string_literal> , <string_literal> ) ; obj . put ( <string_literal> , sha1crypto . encode ( session <identifiersep> id + <string_literal> + password ) ) ; return send ( obj ) ; } catch ( exception e ) { <LOG> return false ; } } <comment> <ect>
{ obj . put ( <string_literal> , <string_literal> ) ; obj . put ( <string_literal> , astid + <string_literal> + xivo <identifiersep> user <identifiersep> id ) ; return send ( obj ) ; } catch ( exception e ) { <LOG> return false ; } } <comment> @ suppress <identifiersep> warnings ( <string_literal> ) <ect>
<comment> private boolean send ( json <identifiersep> object obj ) { if ( connection == null || connection <identifiersep> writer == null ) return false ; <LOG> connection <identifiersep> writer . println ( obj ) ; return true ; } <comment> <ect>
fire <identifiersep> contact <identifiersep> resolved ( parent <identifiersep> group , contact ) ; } } catch ( throwable t ) { logger . error ( <string_literal> + phone ) ; } } } catch ( throwable t ) { <LOG> } } <comment> static void show <identifiersep> error ( throwable ex , string title , string message ) { <ect>
, exc . get <identifiersep> message ( ) ) ; return ; } if ( sip <identifiersep> provider . register <identifiersep> using <identifiersep> next <identifiersep> address ( ) ) return ; } <comment> <LOG> set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , exc . get <identifiersep> message ( ) ) ; if ( exc instanceof operation <identifiersep> failed <identifiersep> exception ) throw ( operation <identifiersep> failed <identifiersep> exception ) exc ; else <ect>
private void unregister <identifiersep> internal ( boolean send <identifiersep> unregister , boolean user <identifiersep> request ) throws operation <identifiersep> failed <identifiersep> exception { if ( get <identifiersep> registration <identifiersep> state ( ) == registration <identifiersep> state . unregistered ) { <LOG> return ; } cancel <identifiersep> pending <identifiersep> registrations ( ) ; if ( this . register <identifiersep> request == null ) { logger . error ( <string_literal> ) ; set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed <ect>
try { unregister <identifiersep> request = sip <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> un <identifiersep> register <identifiersep> request ( register <identifiersep> request , get <identifiersep> next <identifiersep> c <identifiersep> seq <identifiersep> value ( ) ) ; } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <LOG> <comment> <ect>
<comment> <LOG> set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . unregistered , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> user <identifiersep> request , null ) ; <comment> <ect>
< = transaction <identifiersep> state . proceeding . get <identifiersep> value ( ) ) { logger . trace ( <string_literal> ) ; reg <identifiersep> trans . terminate ( ) ; <LOG> } } } catch ( sip <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error <ect>
try { if ( get <identifiersep> registration <identifiersep> state ( ) == registration <identifiersep> state . registered ) register ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , <string_literal> ) ; } } } <comment> <ect>
retry <identifiersep> tran = sip <identifiersep> provider . get <identifiersep> sip <identifiersep> security <identifiersep> manager ( ) . handle <identifiersep> forbidden <identifiersep> response ( response , client <identifiersep> transaction , jain <identifiersep> sip <identifiersep> provider ) ; } if ( retry <identifiersep> tran == null ) { <LOG> unregister ( false ) ; return ; } <comment> <ect>
try { register ( ) ; return ; } catch ( throwable e ) { <LOG> set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> not <identifiersep> specified , <string_literal> + <string_literal> ) ; return ; <ect>
address addr = parent <identifiersep> provider . parse <identifiersep> address <identifiersep> string ( call <identifiersep> peer . get <identifiersep> address ( ) ) ; subscriber . unsubscribe ( addr , false ) ; } catch ( parse <identifiersep> exception ex ) { <LOG> } catch ( operation <identifiersep> failed <identifiersep> exception ofe ) { logger . error ( <string_literal> , ofe ) ; return ; <ect>
( user <identifiersep> set <identifiersep> data <identifiersep> directory == null ) ? data <identifiersep> directory : user <identifiersep> set <identifiersep> data <identifiersep> directory , file <identifiersep> category . profile ) ; find <identifiersep> dat <identifiersep> files ( vect , hist <identifiersep> dir ) ; } catch ( exception e ) { <LOG> } db <identifiersep> struct <identifiersep> serializer struct <identifiersep> parse = new db <identifiersep> struct <identifiersep> serializer ( this ) ; for ( file f : vect ) { synchronized ( this . histories ) { try <ect>
file new <identifiersep> dir = get <identifiersep> dir <identifiersep> for <identifiersep> history ( new <identifiersep> id ) ; <comment> <LOG> throw new io <identifiersep> exception ( <string_literal> ) ; } histories . remove ( old <identifiersep> id ) ; } <comment> <ect>
{ hist <identifiersep> dir = get <identifiersep> file <identifiersep> access <identifiersep> service ( ) . get <identifiersep> private <identifiersep> persistent <identifiersep> directory ( data <identifiersep> directory , file <identifiersep> category . profile ) ; } catch ( exception e ) { <LOG> } if ( hist <identifiersep> dir == null || ! hist <identifiersep> dir . exists ( ) ) return new array <identifiersep> list < history <identifiersep> id > ( ) ; string <identifiersep> builder folder <identifiersep> path = new string <identifiersep> builder ( ) ; for ( string id : rawid ) folder <identifiersep> path . append ( id ) . append ( file . separator ) ; file src <identifiersep> folder = new file ( hist <identifiersep> dir , folder <identifiersep> path . to <identifiersep> string ( ) ) ; <ect>
<comment> private void handle <identifiersep> provider <identifiersep> added ( protocol <identifiersep> provider <identifiersep> service provider ) { <LOG> <comment> <ect>
try { history history = this . get <identifiersep> history ( null , item ) ; readers . put ( item , history . get <identifiersep> reader ( ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } return readers ; } private file <identifiersep> record create <identifiersep> file <identifiersep> record <identifiersep> from <identifiersep> history <identifiersep> record ( history <identifiersep> record hr , contact contact ) { string file = null ; string dir = null ; <ect>
<comment> <LOG> if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { logger . debug ( <string_literal> ) ; this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } else if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . unregistering ) <ect>
history <identifiersep> writer . update <identifiersep> record ( structure <identifiersep> names [ <number_literal> ] , ft . get <identifiersep> id ( ) , structure <identifiersep> names [ <number_literal> ] , status ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } private static string get <identifiersep> direction ( int direction ) { switch ( direction ) { case file <identifiersep> transfer . in : return file <identifiersep> record . in ; <ect>
sdf . format ( event . get <identifiersep> timestamp ( ) ) , file <identifiersep> transfer <identifiersep> active , file <identifiersep> transfer . get <identifiersep> id ( ) } ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } } <comment> <ect>
req . get <identifiersep> id ( ) , structure <identifiersep> names [ <number_literal> ] , file <identifiersep> record . canceled ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } <comment> <ect>
return ; set <identifiersep> visible ( window , window . is <identifiersep> visible ( ) ) ; } } } } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; <LOG> } } <comment> <ect>
try { system . load <identifiersep> library ( <string_literal> ) ; ptr = init ( ) ; } catch ( exception e ) { <LOG> ptr = 0 ; } } } <ect>
system . out . println ( <string_literal> ) ; } } ; awt <identifiersep> key <identifiersep> stroke ks = awt <identifiersep> key <identifiersep> stroke . get <identifiersep> awt <identifiersep> key <identifiersep> stroke ( <string_literal> ) ; awt <identifiersep> key <identifiersep> stroke ks2 = awt <identifiersep> key <identifiersep> stroke . get <identifiersep> awt <identifiersep> key <identifiersep> stroke ( <string_literal> ) ; if ( ks == null ) { <LOG> system . out . println ( <string_literal> ) ; return ; } this . register <identifiersep> shortcut ( l , ks ) ; this . register <identifiersep> shortcut ( l , ks2 ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } this . unregister <identifiersep> shortcut ( l , ks ) ; <ect>
this . unregister <identifiersep> shortcut ( l , ks ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } this . unregister <identifiersep> shortcut ( l , ks2 ) ; <comment> <LOG> system . out . println ( <string_literal> ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } system . out . println ( <string_literal> ) ; keyboard <identifiersep> hook . unregister <identifiersep> shortcut ( ks . get <identifiersep> key <identifiersep> code ( ) , get <identifiersep> modifiers ( ks ) ) ; system . out . println ( <string_literal> ) ; <ect>
<comment> <LOG> <comment> } } <ect>
if ( change <identifiersep> call <identifiersep> dir <identifiersep> text <identifiersep> field ) call <identifiersep> dir <identifiersep> text <identifiersep> field . set <identifiersep> text ( saved <identifiersep> calls <identifiersep> dir ) ; neomedia <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . set <identifiersep> property ( recorder . saved <identifiersep> calls <identifiersep> path , saved <identifiersep> calls <identifiersep> dir ) ; <LOG> return true ; } else { logger . debug ( <string_literal> ) ; return false ; <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <LOG> neomedia <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; <comment> <ect>
media <identifiersep> configuration = new media <identifiersep> configuration <identifiersep> impl ( ) ; bundle <identifiersep> context . register <identifiersep> service ( media <identifiersep> configuration <identifiersep> service . class . get <identifiersep> name ( ) , get <identifiersep> media <identifiersep> configuration ( ) , null ) ; <LOG> configuration <identifiersep> service cfg = neomedia <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) ; dictionary < string , string > media <identifiersep> props = new hashtable < string , string > ( ) ; media <identifiersep> props . put ( configuration <identifiersep> form . form <identifiersep> type , configuration <identifiersep> form . general <identifiersep> type ) ; <comment> <ect>
{ try { presence . publish <identifiersep> presence <identifiersep> status ( status , <string_literal> ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e1 ) { <LOG> } catch ( illegal <identifiersep> state <identifiersep> exception e1 ) { logger . error ( <string_literal> , e1 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { if ( e1 . get <identifiersep> error <identifiersep> code ( ) <ect>
global <identifiersep> display <identifiersep> details <identifiersep> activator . get <identifiersep> alert <identifiersep> ui <identifiersep> service ( ) . show <identifiersep> alert <identifiersep> dialog ( global <identifiersep> display <identifiersep> details <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , msg <identifiersep> text , e1 ) ; } <LOG> } } } } <ect>
public void test <identifiersep> failed ( int status , test test , throwable t ) { logger . debug ( <string_literal> + test . to <identifiersep> string ( ) + <string_literal> ) ; } @ override public void test <identifiersep> started ( string test <identifiersep> name ) { <LOG> } @ override public void test <identifiersep> ended ( string test <identifiersep> name ) { logger . debug ( <string_literal> + test <identifiersep> name ) ; } <comment> <ect>
{ if ( args [ i ] . equals ( <string_literal> ) ) wait = true ; else if ( args [ i ] . equals ( <string_literal> ) ) test <identifiersep> case = extract <identifiersep> class <identifiersep> name ( args [ ++ i ] ) ; else if ( args [ i ] . equals ( <string_literal> ) ) <LOG> else test <identifiersep> case = args [ i ] ; } if ( test <identifiersep> case . equals ( <string_literal> ) ) throw new exception ( <string_literal> ) ; try { test suite = get <identifiersep> test ( test <identifiersep> case ) ; <ect>
credentials <identifiersep> storage <identifiersep> service <identifiersep> lick . bc = bundle <identifiersep> context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test <identifiersep> suite ( test <identifiersep> credentials <identifiersep> storage <identifiersep> service . class ) ; bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; <LOG> } <comment> <ect>
<comment> <LOG> wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ 1 ] ) ; wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; test <identifiersep> msg <identifiersep> history <identifiersep> service <identifiersep> multi <identifiersep> chat . control <identifiersep> date2 = new date ( ) ; <ect>
wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { fail ( <string_literal> + ex . get <identifiersep> message ( ) ) ; <LOG> } catch ( operation <identifiersep> not <identifiersep> supported <identifiersep> exception ex ) { fail ( <string_literal> + ex . get <identifiersep> message ( ) ) ; logger . error ( <string_literal> , ex ) ; } } <comment> <ect>
set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test ( test <identifiersep> msg <identifiersep> history <identifiersep> service . suite ( ) ) ; add <identifiersep> test ( test <identifiersep> msg <identifiersep> history <identifiersep> service <identifiersep> multi <identifiersep> chat . suite ( ) ) ; bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; <LOG> } <comment> <ect>
} ; } <comment> public void write <identifiersep> records ( ) { <LOG> assert <identifiersep> not <identifiersep> null ( <string_literal> , test <identifiersep> meta <identifiersep> contact ) ; <comment> <ect>
logger . info ( <string_literal> + control <identifiersep> date1 . get <identifiersep> time ( ) ) ; wait <identifiersep> write ( <number_literal> ) ; mock <identifiersep> b <identifiersep> im <identifiersep> op <identifiersep> set . deliver <identifiersep> message ( test <identifiersep> contact <identifiersep> name <identifiersep> 1 , messages <identifiersep> to <identifiersep> send [ 1 ] ) ; mock <identifiersep> b <identifiersep> im <identifiersep> op <identifiersep> set . deliver <identifiersep> message ( test <identifiersep> contact <identifiersep> name <identifiersep> <number_literal> , messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; test <identifiersep> msg <identifiersep> history <identifiersep> service . control <identifiersep> date2 = new date ( ) ; <LOG> wait <identifiersep> write ( <number_literal> ) ; mock <identifiersep> b <identifiersep> im <identifiersep> op <identifiersep> set . deliver <identifiersep> message ( test <identifiersep> contact <identifiersep> name <identifiersep> 1 , messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; mock <identifiersep> b <identifiersep> im <identifiersep> op <identifiersep> set . deliver <identifiersep> message ( test <identifiersep> contact <identifiersep> name <identifiersep> <number_literal> , messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; } <comment> <ect>
<comment> <LOG> <comment> <ect>
call <identifiersep> history <identifiersep> service <identifiersep> lick . bc = bundle <identifiersep> context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test ( test <identifiersep> call <identifiersep> history <identifiersep> service . suite ( ) ) ; bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; <LOG> } <comment> <ect>
participant <identifiersep> addresses . add ( <string_literal> ) ; } <comment> private void write <identifiersep> records ( ) { <LOG> generate <identifiersep> call ( participant <identifiersep> addresses . get ( 0 ) ) ; wait <identifiersep> seconds ( 1 ) ; control <identifiersep> date1 = new date ( ) ; generate <identifiersep> call ( participant <identifiersep> addresses . get ( 1 ) ) ; generate <identifiersep> call ( participant <identifiersep> addresses . get ( <number_literal> ) ) ; wait <identifiersep> seconds ( 1 ) ; <ect>
participant = rec . get <identifiersep> peer <identifiersep> records ( ) . get ( 0 ) ; assert <identifiersep> true ( <string_literal> , participant . get <identifiersep> peer <identifiersep> address ( ) . equals ( participant <identifiersep> addresses . get ( 1 ) ) ) ; } public void check <identifiersep> record <identifiersep> completeness ( ) { <LOG> string [ ] part <identifiersep> addresses = new string [ ] { <string_literal> , <string_literal> } ; try { call new <identifiersep> call = mock <identifiersep> b <identifiersep> telphony <identifiersep> op <identifiersep> set . place <identifiersep> call ( part <identifiersep> addresses [ 0 ] ) ; <ect>
public void start ( bundle <identifiersep> context context ) { mcl <identifiersep> slick <identifiersep> fixture . bundle <identifiersep> context = context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > slick <identifiersep> service <identifiersep> properties = new hashtable < string , string > ( ) ; slick <identifiersep> service <identifiersep> properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; <LOG> <comment> <ect>
<string_literal> ) ; service <identifiersep> registration osgi <identifiersep> registration = mcl <identifiersep> slick <identifiersep> fixture . bundle <identifiersep> context . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , provider , mock <identifiersep> prov <identifiersep> properties ) ; <LOG> return osgi <identifiersep> registration ; } <comment> <ect>
public void test <identifiersep> contact <identifiersep> list <identifiersep> retrieving ( ) { mock <identifiersep> contact <identifiersep> group expected <identifiersep> root = ( mock <identifiersep> contact <identifiersep> group ) mcl <identifiersep> slick <identifiersep> fixture . mock <identifiersep> pres <identifiersep> op <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . info ( <string_literal> ) ; <LOG> + <string_literal> + expected <identifiersep> root . count <identifiersep> contacts ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> subgroups ( ) + <string_literal> + expected <identifiersep> root . to <identifiersep> string ( ) ) ; meta <identifiersep> contact <identifiersep> group actual <identifiersep> root = fixture . meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) ; logger . info ( <string_literal> ) ; logger . info ( <string_literal> + actual <identifiersep> root . get <identifiersep> group <identifiersep> name ( ) <ect>
logger . info ( <string_literal> + expected <identifiersep> root . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> contacts ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> subgroups ( ) + <string_literal> + expected <identifiersep> root . to <identifiersep> string ( ) ) ; meta <identifiersep> contact <identifiersep> group actual <identifiersep> root = fixture . meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) ; logger . info ( <string_literal> ) ; <LOG> + <string_literal> + actual <identifiersep> root . count <identifiersep> child <identifiersep> contacts ( ) + <string_literal> + actual <identifiersep> root . count <identifiersep> subgroups ( ) + <string_literal> + actual <identifiersep> root . to <identifiersep> string ( ) ) ; mcl <identifiersep> slick <identifiersep> fixture . assert <identifiersep> group <identifiersep> equals ( expected <identifiersep> root , actual <identifiersep> root , false ) ; <comment> <ect>
private static final logger logger = logger . get <identifiersep> logger ( predictable <identifiersep> transform <identifiersep> layer . class ) ; public message <identifiersep> delivered <identifiersep> event message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) { logger . debug ( <string_literal> ) ; <LOG> message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <string_literal> ) ; logger . debug ( <string_literal> + transformed <identifiersep> message . get <identifiersep> content ( ) ) ; return new message <identifiersep> delivered <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) ; <ect>
. get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) ; } public message <identifiersep> delivery <identifiersep> failed <identifiersep> event message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { logger . debug ( <string_literal> ) ; <LOG> message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <string_literal> ) ; logger . debug ( <string_literal> + transformed <identifiersep> message . get <identifiersep> content ( ) ) ; return new message <identifiersep> delivery <identifiersep> failed <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> error <identifiersep> code ( ) ) ; <ect>
. get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> error <identifiersep> code ( ) ) ; } public message <identifiersep> delivered <identifiersep> event [ ] message <identifiersep> delivery <identifiersep> pending ( message <identifiersep> delivered <identifiersep> event evt ) { logger . debug ( <string_literal> ) ; <LOG> message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <string_literal> ) ; logger . debug ( <string_literal> + transformed <identifiersep> message . get <identifiersep> content ( ) ) ; return new message <identifiersep> delivered <identifiersep> event [ ] { new message <identifiersep> delivered <identifiersep> event ( transformed <identifiersep> message , <ect>
{ new message <identifiersep> delivered <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) } ; } public message <identifiersep> received <identifiersep> event message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) { logger . debug ( <string_literal> ) ; <LOG> message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> source <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <string_literal> ) ; logger . debug ( <string_literal> + transformed <identifiersep> message . get <identifiersep> content ( ) ) ; return new message <identifiersep> received <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> source <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) ; <ect>
<comment> public void test <identifiersep> send <identifiersep> and <identifiersep> receive ( ) throws exception { if ( ! enable <identifiersep> test <identifiersep> send <identifiersep> and <identifiersep> receive ( ) ) return ; <LOG> file file <identifiersep> to <identifiersep> transfer = get <identifiersep> temp <identifiersep> file <identifiersep> to <identifiersep> transfer ( <number_literal> ) ; operation <identifiersep> set <identifiersep> file <identifiersep> transfer ft <identifiersep> op <identifiersep> set1 = get <identifiersep> op <identifiersep> set <identifiersep> fil <identifiersep> transfer1 ( ) ; operation <identifiersep> set <identifiersep> file <identifiersep> transfer ft <identifiersep> op <identifiersep> set2 = get <identifiersep> op <identifiersep> set <identifiersep> fil <identifiersep> transfer2 ( ) ; file <identifiersep> transfer <identifiersep> status <identifiersep> event <identifiersep> collector sender <identifiersep> status <identifiersep> listener = new file <identifiersep> transfer <identifiersep> status <identifiersep> event <identifiersep> collector ( <string_literal> ) ; file <identifiersep> transfer <identifiersep> event <identifiersep> collector sender <identifiersep> ft <identifiersep> listerner = <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { <ect>
if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for , int events <identifiersep> num ) { this . events <identifiersep> num = events <identifiersep> num ; <LOG> synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > ( events <identifiersep> num - 1 ) ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; <ect>
logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > ( events <identifiersep> num - 1 ) ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <ect>
{ logger . trace ( <string_literal> + req + <string_literal> + source <identifiersep> contact ) ; return new authorization <identifiersep> response ( authorization <identifiersep> response . accept , <string_literal> ) ; } public authorization <identifiersep> request create <identifiersep> authorization <identifiersep> request ( contact contact ) { <LOG> return new authorization <identifiersep> request ( ) ; } public void process <identifiersep> authorization <identifiersep> response ( authorization <identifiersep> response response , contact source <identifiersep> contact ) { logger . debug ( <string_literal> + source <identifiersep> contact . get <identifiersep> address ( ) + <string_literal> + <ect>
<comment> public void message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
return ; try { wait ( wait <identifiersep> for ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } } } <ect>
<comment> <LOG> } catch ( array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception ex ) { throw new runtime <identifiersep> exception ( <string_literal> , ex ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { <ect>
throw new runtime <identifiersep> exception ( <string_literal> , ex ) ; } catch ( class <identifiersep> cast <identifiersep> exception ex ) { throw new runtime <identifiersep> exception ( <string_literal> , ex ) ; } <LOG> <comment> <ect>
{ synchronized ( registration <identifiersep> lock ) { registration <identifiersep> lock . notify <identifiersep> all ( ) ; } } catch ( exception e ) { <LOG> } } } } ) ; provider2 . register ( new security <identifiersep> authority ( ) { public user <identifiersep> credentials obtain <identifiersep> credentials ( string realm , user <identifiersep> credentials default <identifiersep> values , int reason <identifiersep> code ) { return obtain <identifiersep> credentials ( realm , default <identifiersep> values ) ; <ect>
public boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ( ) { return false ; } } ) ; synchronized ( registration <identifiersep> lock ) { logger . info ( <string_literal> ) ; registration <identifiersep> lock . wait ( <number_literal> ) ; <LOG> } fixture . provider . add <identifiersep> registration <identifiersep> state <identifiersep> change <identifiersep> listener ( new registration <identifiersep> state <identifiersep> change <identifiersep> listener ( ) { public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { try <ect>
synchronized ( response <identifiersep> retriever . waiting <identifiersep> for <identifiersep> response <identifiersep> lock ) { try { logger . debug ( <string_literal> + screenname ) ; response <identifiersep> retriever . waiting <identifiersep> for <identifiersep> response <identifiersep> lock . wait ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } logger . debug ( <string_literal> + response <identifiersep> retriever . status ) ; return response <identifiersep> retriever . status == null ? icq <identifiersep> status <identifiersep> enum . offline : response <identifiersep> retriever . status ; } <comment> <ect>
private boolean ran = false ; private icq <identifiersep> status <identifiersep> enum status = null ; public object waiting <identifiersep> for <identifiersep> response <identifiersep> lock = new object ( ) ; @ override public void handle <identifiersep> response ( snac <identifiersep> response <identifiersep> event e ) { snac <identifiersep> command snac = e . get <identifiersep> snac <identifiersep> command ( ) ; <LOG> synchronized ( this ) { if ( ran ) return ; ran = true ; } if ( snac instanceof user <identifiersep> info <identifiersep> cmd ) { user <identifiersep> info <identifiersep> cmd uic = ( user <identifiersep> info <identifiersep> cmd ) snac ; <ect>
else if ( snac instanceof snac <identifiersep> error ) { <comment> <LOG> synchronized ( waiting <identifiersep> for <identifiersep> response <identifiersep> lock ) { waiting <identifiersep> for <identifiersep> response <identifiersep> lock . notify <identifiersep> all ( ) ; } } } @ override public void handle <identifiersep> timeout ( snac <identifiersep> request <identifiersep> timeout <identifiersep> event event ) { synchronized ( this ) { if ( ran ) return ; <ect>
synchronized ( bos <identifiersep> event <identifiersep> notifier . info <identifiersep> lock ) { conn . get <identifiersep> bos <identifiersep> service ( ) . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac ( new set <identifiersep> extra <identifiersep> info <identifiersep> cmd ( icq <identifiersep> status ) ) ; try { bos <identifiersep> event <identifiersep> notifier . info <identifiersep> lock . wait ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> ) ; } conn . get <identifiersep> bos <identifiersep> service ( ) . remove <identifiersep> main <identifiersep> bos <identifiersep> service <identifiersep> listener ( bos <identifiersep> event <identifiersep> notifier ) ; if ( bos <identifiersep> event <identifiersep> notifier . last <identifiersep> user <identifiersep> info == null ) { <LOG> return false ; } return true ; } } <comment> <ect>
<comment> public void handle <identifiersep> your <identifiersep> info ( main <identifiersep> bos <identifiersep> service service , full <identifiersep> user <identifiersep> info user <identifiersep> info ) { <LOG> synchronized ( info <identifiersep> lock ) { last <identifiersep> user <identifiersep> info = user <identifiersep> info ; info <identifiersep> lock . notify <identifiersep> all ( ) ; } } } <comment> <ect>
synchronized ( this . added <identifiersep> groups ) { if ( ! added <identifiersep> groups . is <identifiersep> empty ( ) ) { return ; } try { this . added <identifiersep> groups . wait ( milliseconds ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } } public void wait <identifiersep> for <identifiersep> removed <identifiersep> buddy ( int milliseconds ) { synchronized ( this . removed <identifiersep> buddies ) { if ( ! removed <identifiersep> buddies . is <identifiersep> empty ( ) ) { <ect>
public void group <identifiersep> added ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group , list < ? extends buddy > buddies ) { <LOG> synchronized ( this . added <identifiersep> groups ) { this . added <identifiersep> groups . add ( group ) ; this . added <identifiersep> groups . notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> <LOG> } <comment> <ect>
<comment> <LOG> } <comment> <ect>
logger . debug ( <string_literal> + group . get <identifiersep> name ( ) ) ; } } <comment> <LOG> + <string_literal> + info . get <identifiersep> icq <identifiersep> status ( ) ) ; list < extra <identifiersep> info <identifiersep> block > e <identifiersep> info <identifiersep> blocks = info . get <identifiersep> extra <identifiersep> info <identifiersep> blocks ( ) ; if ( e <identifiersep> info <identifiersep> blocks != null ) { system . out . println ( <string_literal> + e <identifiersep> info <identifiersep> blocks . size ( ) + <string_literal> ) ; <ect>
{ system . out . println ( <string_literal> + e <identifiersep> info <identifiersep> blocks . size ( ) + <string_literal> ) ; for ( extra <identifiersep> info <identifiersep> block block : e <identifiersep> info <identifiersep> blocks ) system . out . println ( <string_literal> + block ) ; } else <LOG> } public void buddy <identifiersep> offline ( buddy <identifiersep> service service , screenname buddy ) { system . out . println ( <string_literal> + buddy . to <identifiersep> string ( ) ) ; } } private class global <identifiersep> buddy <identifiersep> listener implements global <identifiersep> buddy <identifiersep> info <identifiersep> listener { public void buddy <identifiersep> info <identifiersep> changed ( buddy <identifiersep> info <identifiersep> manager manager , screenname buddy , <ect>
system . out . println ( <string_literal> + <string_literal> + event . get <identifiersep> property <identifiersep> name ( ) + <string_literal> + buddy . to <identifiersep> string ( ) + <string_literal> + info . is <identifiersep> online ( ) + <string_literal> + info . get <identifiersep> status <identifiersep> message ( ) + <string_literal> + info . get <identifiersep> away <identifiersep> message ( ) ) ; <LOG> } public void new <identifiersep> buddy <identifiersep> info ( buddy <identifiersep> info <identifiersep> manager manager , screenname buddy , buddy <identifiersep> info info ) { system . out . println ( <string_literal> + buddy . to <identifiersep> string ( ) + <string_literal> + info . is <identifiersep> online ( ) <ect>
{ system . out . println ( <string_literal> + buddy . to <identifiersep> string ( ) + <string_literal> + info . is <identifiersep> online ( ) + <string_literal> + info . get <identifiersep> status <identifiersep> message ( ) + <string_literal> + info . get <identifiersep> away <identifiersep> message ( ) ) ; <LOG> } } <comment> <ect>
public void group <identifiersep> added ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group , list < ? extends buddy > buddies ) { <LOG> system . out . println ( <string_literal> + group . get <identifiersep> name ( ) ) ; system . out . println ( <string_literal> + new <identifiersep> items . index <identifiersep> of ( group ) ) ; for ( int i = 0 ; i < buddies . size ( ) ; i ++ ) { system . out . println ( <string_literal> + buddies . get ( i ) . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) ) ; <ect>
list < ? extends group > new <identifiersep> items , group group , list < ? extends buddy > buddies ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + group . get <identifiersep> name ( ) ) ; <LOG> for ( int i = 0 ; i < buddies . size ( ) ; i ++ ) { system . out . println ( <string_literal> + buddies . get ( i ) . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) ) ; buddy b = buddies . get ( i ) ; conn . get <identifiersep> buddy <identifiersep> info <identifiersep> tracker ( ) . add <identifiersep> tracker ( b . get <identifiersep> screenname ( ) , <ect>
public void buddy <identifiersep> added ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> items , list < ? extends buddy > new <identifiersep> items , buddy buddy ) { <LOG> } public void buddy <identifiersep> removed ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> items , list < ? extends buddy > new <identifiersep> items , buddy buddy ) { <ect>
if ( buddy . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) . equals ( <string_literal> ) ) moved <identifiersep> buddy = buddy ; } } if ( buddy <identifiersep> to <identifiersep> move == moved <identifiersep> buddy ) system . out . println ( <string_literal> ) ; } public void delete <identifiersep> buddy ( string screenname ) { <LOG> mutable <identifiersep> buddy <identifiersep> list joust <identifiersep> sim <identifiersep> buddy <identifiersep> list = conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; layout <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new layout <identifiersep> event <identifiersep> collector ( ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; list < ? extends group > gr <identifiersep> list = joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . get <identifiersep> groups ( ) ; boolean is <identifiersep> deleted = false ; <ect>
= conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; list < ? extends group > gr <identifiersep> list = joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . get <identifiersep> groups ( ) ; iterator < ? extends group > iter = gr <identifiersep> list . iterator ( ) ; while ( iter . has <identifiersep> next ( ) ) { mutable <identifiersep> group item = ( mutable <identifiersep> group ) iter . next ( ) ; <LOG> list < ? extends buddy > bs = item . get <identifiersep> buddies <identifiersep> copy ( ) ; iterator < ? extends buddy > iter1 = bs . iterator ( ) ; while ( iter1 . has <identifiersep> next ( ) ) { object b = iter1 . next ( ) ; logger . debug ( <string_literal> + b ) ; <ect>
{ object b = iter1 . next ( ) ; logger . debug ( <string_literal> + b ) ; } } mutable <identifiersep> group target <identifiersep> group = null ; if ( gr <identifiersep> list . size ( ) < 1 ) { <LOG> layout <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new layout <identifiersep> event <identifiersep> collector ( ) ; string group <identifiersep> name = <string_literal> ; logger . debug ( <string_literal> + group <identifiersep> name ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> group ( group <identifiersep> name ) ; <comment> <ect>
<comment> <LOG> send <identifiersep> authorization <identifiersep> replay ( string . value <identifiersep> of ( cmd . uin ) , response <identifiersep> reason <identifiersep> str , accept ) ; return cmd ; } else if ( command == <number_literal> ) <comment> <ect>
= conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; layout <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new layout <identifiersep> event <identifiersep> collector ( ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac ( add <identifiersep> cmd ) ; evt <identifiersep> collector . wait <identifiersep> for <identifiersep> a <identifiersep> new <identifiersep> buddy ( <number_literal> ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . remove <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; <LOG> <comment> <ect>
byte <identifiersep> array <identifiersep> output <identifiersep> stream o = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; new tlv ( 0x0066 ) . write ( o ) ; byte <identifiersep> block block = byte <identifiersep> block . wrap ( o . to <identifiersep> byte <identifiersep> array ( ) ) ; return block ; } catch ( io <identifiersep> exception ex ) { <LOG> return null ; } } } } <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; <LOG> + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = icq <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; logger . debug ( <string_literal> ) ; <ect>
<comment> public void post <identifiersep> test <identifiersep> persistent <identifiersep> subscribe ( ) throws exception { <LOG> <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> create <identifiersep> group ( ) { <LOG> <comment> <ect>
<comment> <LOG> } group <identifiersep> change <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> pers <identifiersep> presence . remove <identifiersep> server <identifiersep> stored <identifiersep> group <identifiersep> change <identifiersep> listener ( group <identifiersep> change <identifiersep> collector ) ; <comment> <ect>
public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { <LOG> return ; } try { wait ( wait <identifiersep> for ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <ect>
<comment> public void group <identifiersep> name <identifiersep> changed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> resolved ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
{ logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { <LOG> return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <ect>
return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <LOG> } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void got <identifiersep> message ( conversation c , message <identifiersep> info minfo ) { <LOG> + c . get <identifiersep> buddy ( ) ) ; synchronized ( this ) { collected <identifiersep> message <identifiersep> info . add ( minfo ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subtest <identifiersep> state <identifiersep> transition ( icq <identifiersep> status <identifiersep> enum new <identifiersep> status ) throws exception { <LOG> presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = operation <identifiersep> set <identifiersep> presence . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; string new <identifiersep> status <identifiersep> message = status <identifiersep> message <identifiersep> root + new <identifiersep> status ; logger . debug ( <string_literal> + old <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) + <string_literal> + new <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) ) ; <comment> <ect>
status <identifiersep> event <identifiersep> collector . wait <identifiersep> for <identifiersep> stat <identifiersep> msg <identifiersep> event ( <number_literal> ) ; <comment> <LOG> operation <identifiersep> set <identifiersep> presence . query <identifiersep> contact <identifiersep> status ( icq <identifiersep> slick <identifiersep> fixture . icq <identifiersep> account <identifiersep> id . get <identifiersep> user <identifiersep> id ( ) ) ; status <identifiersep> event <identifiersep> collector . wait <identifiersep> for <identifiersep> pres <identifiersep> event ( <number_literal> ) ; } operation <identifiersep> set <identifiersep> presence . remove <identifiersep> provider <identifiersep> presence <identifiersep> status <identifiersep> listener ( status <identifiersep> event <identifiersep> collector ) ; assert <identifiersep> equals ( <string_literal> , 1 , status <identifiersep> event <identifiersep> collector . collected <identifiersep> pres <identifiersep> events . size ( ) ) ; <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
<comment> <LOG> subtest <identifiersep> query <identifiersep> contact <identifiersep> status ( full <identifiersep> user <identifiersep> info . icqstatus <identifiersep> na , icq <identifiersep> status <identifiersep> enum . not <identifiersep> available ) ; pause <identifiersep> between <identifiersep> state <identifiersep> changes ( ) ; <comment> <ect>
<comment> <LOG> subtest <identifiersep> query <identifiersep> contact <identifiersep> status ( full <identifiersep> user <identifiersep> info . icqstatus <identifiersep> ffc , icq <identifiersep> status <identifiersep> enum . free <identifiersep> for <identifiersep> chat ) ; pause <identifiersep> between <identifiersep> state <identifiersep> changes ( ) ; <comment> <ect>
<comment> <LOG> subtest <identifiersep> query <identifiersep> contact <identifiersep> status ( full <identifiersep> user <identifiersep> info . icqstatus <identifiersep> occupied , icq <identifiersep> status <identifiersep> enum . occupied ) ; pause <identifiersep> between <identifiersep> state <identifiersep> changes ( ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception { <LOG> <comment> <ect>
operation <identifiersep> set <identifiersep> presence . subscribe ( icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> icq <identifiersep> uin ( ) ) ; <comment> <LOG> auth <identifiersep> event <identifiersep> collector . wait <identifiersep> for <identifiersep> auth <identifiersep> response ( <number_literal> ) ; assert <identifiersep> true ( <string_literal> + icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> icq <identifiersep> uin ( ) + <string_literal> , auth <identifiersep> event <identifiersep> collector . is <identifiersep> authorization <identifiersep> request <identifiersep> sent ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , <ect>
= new unsubscribe <identifiersep> wait ( ) ; operation <identifiersep> set <identifiersep> presence . add <identifiersep> subscription <identifiersep> listener ( unsubscribe <identifiersep> evt <identifiersep> collector ) ; synchronized ( unsubscribe <identifiersep> evt <identifiersep> collector ) { operation <identifiersep> set <identifiersep> presence . unsubscribe ( c ) ; logger . debug ( <string_literal> ) ; unsubscribe <identifiersep> evt <identifiersep> collector . wait <identifiersep> for <identifiersep> unsubscribre ( <number_literal> ) ; <LOG> <comment> <ect>
<comment> <LOG> } sub <identifiersep> evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; <comment> <ect>
icq <identifiersep> slick <identifiersep> fixture . icq <identifiersep> account <identifiersep> id . get <identifiersep> user <identifiersep> id ( ) , icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . response <identifiersep> reason <identifiersep> str , icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . accept ) ; object obj = new object ( ) ; synchronized ( obj ) { <LOG> obj . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } tester <identifiersep> agent <identifiersep> old <identifiersep> status = icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> presnece <identifiersep> status ( ) ; tester <identifiersep> agent <identifiersep> new <identifiersep> status <identifiersep> long = full <identifiersep> user <identifiersep> info . icqstatus <identifiersep> ffc ; <comment> <ect>
assert <identifiersep> not <identifiersep> null ( <string_literal> , reported <identifiersep> old <identifiersep> status ) ; <comment> <comment> object obj = new object ( ) ; synchronized ( obj ) { <LOG> obj . wait ( <number_literal> ) ; } } <comment> <ect>
assert <identifiersep> same ( <string_literal> , fixture . provider , sub <identifiersep> evt . get <identifiersep> source <identifiersep> provider ( ) ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . clear ( ) ; <comment> <LOG> icq <identifiersep> status <identifiersep> enum tester <identifiersep> agent <identifiersep> old <identifiersep> status = icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> presnece <identifiersep> status ( ) ; icq <identifiersep> status <identifiersep> enum tester <identifiersep> agent <identifiersep> new <identifiersep> status = icq <identifiersep> status <identifiersep> enum . free <identifiersep> for <identifiersep> chat ; long tester <identifiersep> agent <identifiersep> new <identifiersep> status <identifiersep> long = full <identifiersep> user <identifiersep> info . icqstatus <identifiersep> ffc ; <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> pres <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> pres <identifiersep> events ) ; return ; } try { <ect>
if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> pres <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
&& ! evt . get <identifiersep> source <identifiersep> contact ( ) . get <identifiersep> address ( ) . equals ( tracked <identifiersep> screen <identifiersep> name ) ) return ; if ( status != null && status != evt . get <identifiersep> new <identifiersep> status ( ) ) return ; <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
lock . wait ( <number_literal> ) ; } catch ( exception ex ) { } } return response <identifiersep> to <identifiersep> request ; } } public authorization <identifiersep> request create <identifiersep> authorization <identifiersep> request ( contact contact ) { <LOG> authorization <identifiersep> request auth <identifiersep> req = new authorization <identifiersep> request ( ) ; auth <identifiersep> req . set <identifiersep> reason ( authorization <identifiersep> request <identifiersep> reason ) ; is <identifiersep> authorization <identifiersep> request <identifiersep> sent = true ; return auth <identifiersep> req ; } public void process <identifiersep> authorization <identifiersep> response ( authorization <identifiersep> response response , contact source <identifiersep> contact ) <ect>
notify <identifiersep> all ( ) ; } } } <comment> public void post <identifiersep> test <identifiersep> receive <identifiersep> authorizatinon <identifiersep> request ( ) { <LOG> <comment> <ect>
protocol <identifiersep> names . icq + <string_literal> + <string_literal> + protocol <identifiersep> provider <identifiersep> factory . user <identifiersep> id + <string_literal> + uin + <string_literal> + <string_literal> ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> } <comment> <ect>
<comment> <LOG> registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) <ect>
{ logger . debug ( <string_literal> ) ; registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { <LOG> } catch ( throwable t ) { logger . debug ( <string_literal> , t ) ; } assert <identifiersep> true ( <string_literal> + <string_literal> + reg <identifiersep> failed <identifiersep> evt <identifiersep> collector . collected <identifiersep> new <identifiersep> states <ect>
protocol <identifiersep> names . icq + <string_literal> + <string_literal> + protocol <identifiersep> provider <identifiersep> factory . user <identifiersep> id + <string_literal> + icq <identifiersep> account <identifiersep> id . get <identifiersep> user <identifiersep> id ( ) + <string_literal> + <string_literal> ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex1 ) { <LOG> } <comment> <ect>
<comment> <LOG> registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) <ect>
{ logger . debug ( <string_literal> ) ; registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { <LOG> } catch ( throwable t ) { logger . debug ( <string_literal> , t ) ; } assert <identifiersep> true ( <string_literal> + <string_literal> + reg <identifiersep> failed <identifiersep> evt <identifiersep> collector . collected <identifiersep> new <identifiersep> states <ect>
{ collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . authentication <identifiersep> failed ) ) { failed <identifiersep> code = evt . get <identifiersep> reason <identifiersep> code ( ) ; failed <identifiersep> reason = evt . get <identifiersep> reason ( ) ; <LOG> synchronized ( registration <identifiersep> lock ) { logger . debug ( <string_literal> ) ; registration <identifiersep> lock . notify <identifiersep> all ( ) ; logger . debug ( <string_literal> ) ; } } } } <comment> <ect>
failed <identifiersep> reason = evt . get <identifiersep> reason ( ) ; logger . debug ( <string_literal> + failed <identifiersep> code + <string_literal> + failed <identifiersep> reason ) ; synchronized ( registration <identifiersep> lock ) { logger . debug ( <string_literal> ) ; registration <identifiersep> lock . notify <identifiersep> all ( ) ; <LOG> } } } } <comment> public class security <identifiersep> authority <identifiersep> impl implements security <identifiersep> authority <ect>
<comment> <LOG> } <comment> <ect>
<comment> <LOG> } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) { logger . debug ( <string_literal> , t ) ; } <comment> <ect>
registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) { <LOG> } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { <LOG> collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { logger . debug ( <string_literal> ) ; synchronized ( registration <identifiersep> lock ) { registration <identifiersep> lock . notify <identifiersep> all ( ) ; <ect>
<comment> <LOG> lock . wait ( <number_literal> ) ; } catch ( exception ex ) { } } tester <identifiersep> agent . unregister ( ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> <ect>
<comment> <LOG> <comment> <ect>
{ op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . remove <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( test <identifiersep> group <identifiersep> name2 ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> } group <identifiersep> change <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . remove <identifiersep> server <identifiersep> stored <identifiersep> group <identifiersep> change <identifiersep> listener ( group <identifiersep> change <identifiersep> collector ) ; <comment> <ect>
<comment> <LOG> op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . create <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , group <identifiersep> name ) ; contact <identifiersep> group newly <identifiersep> created <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( group <identifiersep> name ) ; iterator < string > contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group = contact <identifiersep> list <identifiersep> to <identifiersep> create . get ( group <identifiersep> name ) . iterator ( ) ; <ect>
<comment> public void group <identifiersep> created ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> removed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; <ect>
{ logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
system . get <identifiersep> property ( jabber <identifiersep> protocol <identifiersep> provider <identifiersep> service <identifiersep> lick . account <identifiersep> <number_literal> <identifiersep> prefix + protocol <identifiersep> provider <identifiersep> factory . password ) . to <identifiersep> char <identifiersep> array ( ) ) ) ; <comment> <LOG> reg <identifiersep> evt <identifiersep> collector1 . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; reg <identifiersep> evt <identifiersep> collector2 . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; reg <identifiersep> evt <identifiersep> collector3 . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; <comment> <ect>
public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { logger . debug ( <string_literal> + evt ) ; collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { <LOG> synchronized ( this ) { notify <identifiersep> all ( ) ; } } } <comment> <ect>
try { op <identifiersep> set <identifiersep> presence3 . subscribe ( fixture . user <identifiersep> id2 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex1 ) { <comment> <LOG> synchronized ( o ) { o . wait ( <number_literal> ) ; } } <comment> <ect>
chat <identifiersep> room <identifiersep> member member = message <identifiersep> event . get <identifiersep> source <identifiersep> chat <identifiersep> room <identifiersep> member ( ) ; assert <identifiersep> equals ( <string_literal> , op <identifiersep> set1room . get <identifiersep> user <identifiersep> nickname ( ) , member . get <identifiersep> name ( ) ) ; assert <identifiersep> equals ( <string_literal> , message1 , message <identifiersep> event . get <identifiersep> message ( ) . get <identifiersep> content ( ) ) ; <LOG> } <comment> public void test <identifiersep> member <identifiersep> ban ( ) throws operation <identifiersep> failed <identifiersep> exception , <ect>
catch ( exception ex ) { <comment> <LOG> } <comment> public void test <identifiersep> member <identifiersep> kick ( ) throws operation <identifiersep> failed <identifiersep> exception , <ect>
op <identifiersep> set2room . join ( ) ; assert <identifiersep> true ( <string_literal> , op <identifiersep> set2room . is <identifiersep> joined ( ) ) ; op <identifiersep> set1room <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; assert <identifiersep> true ( <string_literal> , name <identifiersep> is <identifiersep> on <identifiersep> member <identifiersep> list ( fixture . user <identifiersep> id2 , op <identifiersep> set1room . get <identifiersep> members ( ) ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id3 , role <identifiersep> event <identifiersep> user2 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user2 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . silent <identifiersep> member , role <identifiersep> event <identifiersep> user2 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id3 , role <identifiersep> event <identifiersep> user2 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . silent <identifiersep> member , role <identifiersep> event <identifiersep> user2 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user2 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . administrator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . administrator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . owner , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . guest , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . moderator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . administrator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . moderator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . owner , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . administrator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> class muc <identifiersep> event <identifiersep> collector implements chat <identifiersep> room <identifiersep> invitation <identifiersep> rejection <identifiersep> listener , chat <identifiersep> room <identifiersep> invitation <identifiersep> listener , <ect>
logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > wait <identifiersep> count ) { wait <identifiersep> count ++ ; <LOG> return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > wait <identifiersep> count ) { <ect>
contact <identifiersep> to <identifiersep> notify , operation <identifiersep> set <identifiersep> typing <identifiersep> notifications . state <identifiersep> stopped ) ; evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> typing <identifiersep> notifs1 . remove <identifiersep> typing <identifiersep> notifications <identifiersep> listener ( evt <identifiersep> collector ) ; <comment> <LOG> + <string_literal> ) ; logger . trace ( <string_literal> + evt <identifiersep> collector . collected <identifiersep> events ) ; evt = ( typing <identifiersep> notification <identifiersep> event ) evt <identifiersep> collector . collected <identifiersep> events . get ( 0 ) ; assert <identifiersep> equals ( <string_literal> , fixture . user <identifiersep> id2 , evt . get <identifiersep> source <identifiersep> contact ( ) . get <identifiersep> address ( ) ) ; <ect>
<comment> public void typing <identifiersep> notification <identifiersep> received ( typing <identifiersep> notification <identifiersep> event event ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( event ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
try { op <identifiersep> set <identifiersep> presence2 . subscribe ( fixture . user <identifiersep> id1 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex1 ) { <comment> <LOG> synchronized ( o ) { o . wait ( <number_literal> ) ; } } <comment> <ect>
<comment> public void then <identifiersep> test <identifiersep> send <identifiersep> message ( ) { <LOG> contact <identifiersep> group root <identifiersep> group1 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence1 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + root <identifiersep> group1 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) <ect>
{ logger . debug ( <string_literal> ) ; contact <identifiersep> group root <identifiersep> group1 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence1 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; <LOG> + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence2 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; <ect>
+ <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence2 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; <LOG> + <string_literal> + root <identifiersep> group2 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group2 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group2 . to <identifiersep> string ( ) ) ; string body = <string_literal> + <string_literal> + new date ( ) . to <identifiersep> string ( ) ; <comment> <ect>
<comment> public void message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
jabber <identifiersep> status <identifiersep> enum . do <identifiersep> not <identifiersep> disturb ) ; <comment> <LOG> subtest <identifiersep> query <identifiersep> contact <identifiersep> status ( jabber <identifiersep> status <identifiersep> enum . available , jabber <identifiersep> status <identifiersep> enum . available ) ; } <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception { logger . debug ( <string_literal> ) ; <LOG> operation <identifiersep> set <identifiersep> presence1 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector1 ) ; operation <identifiersep> set <identifiersep> presence2 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector2 ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> unsubscribe ( ) throws exception { <LOG> <comment> <ect>
. remove <identifiersep> contact <identifiersep> presence <identifiersep> status <identifiersep> listener ( contact <identifiersep> pres <identifiersep> evt <identifiersep> collector ) ; } assert <identifiersep> equals ( <string_literal> , 0 , contact <identifiersep> pres <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . size ( ) ) ; } public void clear <identifiersep> lists ( ) throws exception { <LOG> fixture . clear <identifiersep> providers <identifiersep> lists ( ) ; object o = new object ( ) ; synchronized ( o ) { o . wait ( <number_literal> ) ; } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> pres <identifiersep> event ( long wait <identifiersep> for ) { <LOG> test <identifiersep> operation <identifiersep> set <identifiersep> presence . wait <identifiersep> for <identifiersep> event ( this , wait <identifiersep> for , collected <identifiersep> pres <identifiersep> events ) ; } <comment> <ect>
. equals ( tracked <identifiersep> screen <identifiersep> name ) ) return ; if ( status == null ) return ; if ( status != evt . get <identifiersep> new <identifiersep> status ( ) ) return ; <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
lock . wait ( <number_literal> ) ; } catch ( exception ex ) { } } return response <identifiersep> to <identifiersep> request ; } } public authorization <identifiersep> request create <identifiersep> authorization <identifiersep> request ( contact contact ) { <LOG> authorization <identifiersep> request auth <identifiersep> req = new authorization <identifiersep> request ( ) ; is <identifiersep> authorization <identifiersep> request <identifiersep> sent = true ; return auth <identifiersep> req ; } public void process <identifiersep> authorization <identifiersep> response ( authorization <identifiersep> response response , contact source <identifiersep> contact ) { <ect>
public void wait <identifiersep> for <identifiersep> auth <identifiersep> request ( long wait <identifiersep> for ) { synchronized ( this ) { if ( is <identifiersep> authorization <identifiersep> request <identifiersep> received ) { <LOG> return ; } try { wait ( wait <identifiersep> for ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <ect>
public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { <LOG> listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <ect>
return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <LOG> listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( listened <identifiersep> call . get <identifiersep> call <identifiersep> state ( ) == awaited <identifiersep> state ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; <LOG> logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = gibberish <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; <ect>
logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = gibberish <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; <LOG> logger . debug ( expected <identifiersep> contact <identifiersep> list ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> remove <identifiersep> group ( ) { <LOG> <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> rename <identifiersep> group ( ) { <LOG> contact <identifiersep> group group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( test <identifiersep> group <identifiersep> name ) ; <comment> <ect>
op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( group <identifiersep> name ) ; iterator < string > contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group = contact <identifiersep> list <identifiersep> to <identifiersep> create . get ( group <identifiersep> name ) . iterator ( ) ; while ( contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . has <identifiersep> next ( ) ) { string id = contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . next ( ) ; <LOG> op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . subscribe ( newly <identifiersep> created <identifiersep> group , id ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void contact <identifiersep> modified ( contact <identifiersep> property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } } <ect>
<comment> <comment> <LOG> <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { <LOG> collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { logger . debug ( <string_literal> ) ; synchronized ( this ) { <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> new <identifiersep> states . contains ( registration <identifiersep> state . registered ) ) { logger . trace ( <string_literal> + collected <identifiersep> new <identifiersep> states ) ; <ect>
<comment> public void then <identifiersep> test <identifiersep> send <identifiersep> message ( ) { <LOG> contact <identifiersep> group root <identifiersep> group1 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence1 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + root <identifiersep> group1 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) <ect>
{ logger . debug ( <string_literal> ) ; contact <identifiersep> group root <identifiersep> group1 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence1 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; <LOG> + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence2 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; <ect>
+ <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence2 ) . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; <LOG> + <string_literal> + root <identifiersep> group2 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group2 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group2 . to <identifiersep> string ( ) ) ; string body = <string_literal> + <string_literal> + new date ( ) . to <identifiersep> string ( ) ; <comment> <ect>
<comment> public void message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subtest <identifiersep> state <identifiersep> transition ( presence <identifiersep> status new <identifiersep> status ) throws exception { <LOG> presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; string new <identifiersep> status <identifiersep> message = status <identifiersep> message <identifiersep> root + new <identifiersep> status ; logger . debug ( <string_literal> + old <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) + <string_literal> + new <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) ) ; <comment> <ect>
status <identifiersep> event <identifiersep> collector . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . get ( 0 ) ) . get <identifiersep> new <identifiersep> value ( ) ) ; <comment> <LOG> } <comment> private void pause <identifiersep> after <identifiersep> state <identifiersep> changes ( ) { try <ect>
<comment> public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception { <LOG> logger . trace ( <string_literal> ) ; operation <identifiersep> set <identifiersep> presence1 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector1 ) ; operation <identifiersep> set <identifiersep> presence2 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector2 ) ; <comment> <ect>
assert <identifiersep> same ( <string_literal> , fixture . provider1 , sub <identifiersep> evt . get <identifiersep> source <identifiersep> provider ( ) ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . clear ( ) ; <comment> <LOG> presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> presence <identifiersep> status ( ) ; presence <identifiersep> status new <identifiersep> status = get <identifiersep> sample <identifiersep> status1 ( ) ; <comment> <ect>
assert <identifiersep> same ( <string_literal> , fixture . provider1 , sub <identifiersep> evt . get <identifiersep> source <identifiersep> provider ( ) ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . clear ( ) ; <comment> <LOG> presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> presence <identifiersep> status ( ) ; presence <identifiersep> status new <identifiersep> status = get <identifiersep> sample <identifiersep> status1 ( ) ; <comment> <ect>
public array <identifiersep> list < event <identifiersep> object > collected <identifiersep> pres <identifiersep> events = new array <identifiersep> list < event <identifiersep> object > ( ) ; public array <identifiersep> list < event <identifiersep> object > collected <identifiersep> stat <identifiersep> msg <identifiersep> events = new array <identifiersep> list < event <identifiersep> object > ( ) ; public void provider <identifiersep> status <identifiersep> changed ( provider <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> pres <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } public void provider <identifiersep> status <identifiersep> message <identifiersep> changed ( property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) { <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
<comment> <LOG> synchronized ( this ) { logger . trace ( <string_literal> + req + <string_literal> + source <identifiersep> contact ) ; is <identifiersep> authorization <identifiersep> request <identifiersep> received = true ; notify <identifiersep> all ( ) ; <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group = this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; <LOG> logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = sip <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; <ect>
logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = sip <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; <LOG> logger . debug ( expected <identifiersep> contact <identifiersep> list ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> remove <identifiersep> group ( ) { <LOG> <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> rename <identifiersep> group ( ) { <LOG> contact <identifiersep> group group = this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( test <identifiersep> group <identifiersep> name ) ; <comment> <ect>
. get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( group <identifiersep> name ) ; iterator < string > contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group = contact <identifiersep> list <identifiersep> to <identifiersep> create . get ( group <identifiersep> name ) . iterator ( ) ; while ( contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . has <identifiersep> next ( ) ) { string id = contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . next ( ) ; <LOG> this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . subscribe ( newly <identifiersep> created <identifiersep> group , id ) ; } } <comment> <ect>
<comment> public void group <identifiersep> name <identifiersep> changed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> resolved ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } } <ect>
im <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new im <identifiersep> event <identifiersep> collector ( ) ; <comment> <LOG> op <identifiersep> set <identifiersep> basic <identifiersep> im2 . send <identifiersep> instant <identifiersep> message ( tester <identifiersep> agent <identifiersep> contact , op <identifiersep> set <identifiersep> basic <identifiersep> im2 . create <identifiersep> message ( body ) ) ; evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> basic <identifiersep> im1 . remove <identifiersep> message <identifiersep> listener ( evt <identifiersep> collector ) ; <comment> <ect>
<comment> public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subtest <identifiersep> state <identifiersep> transition ( presence <identifiersep> status new <identifiersep> status ) throws exception { <LOG> presence <identifiersep> status old <identifiersep> status = this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; string new <identifiersep> status <identifiersep> message = this . status <identifiersep> message <identifiersep> root + new <identifiersep> status ; <ect>
new <identifiersep> status , this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> presence <identifiersep> status ( ) ) ; <comment> <LOG> lock . wait ( <number_literal> ) ; } presence <identifiersep> status actual <identifiersep> status = this . operation <identifiersep> set <identifiersep> presence1 . query <identifiersep> contact <identifiersep> status ( this . fixture . user <identifiersep> id2 ) ; <comment> <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> pres <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( this . collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + this . collected <identifiersep> pres <identifiersep> events ) ; return ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> stat <identifiersep> msg <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( this . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + this . collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; return ; <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void contact <identifiersep> modified ( contact <identifiersep> property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) { <LOG> + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
&& ! evt . get <identifiersep> source <identifiersep> contact ( ) . get <identifiersep> address ( ) . equals ( this . tracked <identifiersep> screen <identifiersep> name ) ) return ; if ( this . status != null && this . status != evt . get <identifiersep> new <identifiersep> status ( ) ) return ; <LOG> + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } } <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { <LOG> collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { logger . debug ( <string_literal> ) ; synchronized ( this ) { <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> new <identifiersep> states . contains ( registration <identifiersep> state . registered ) ) { logger . trace ( <string_literal> + collected <identifiersep> new <identifiersep> states ) ; <ect>
public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { logger . debug ( <string_literal> + evt ) ; collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) ) { <LOG> synchronized ( this ) { notify <identifiersep> all ( ) ; } } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; return ; <ect>
logger . trace ( <string_literal> + collected <identifiersep> events ) ; listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <ect>
. remove <identifiersep> call <identifiersep> peer <identifiersep> listener ( this ) ; return ; } } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; listened <identifiersep> call <identifiersep> peer . remove <identifiersep> call <identifiersep> peer <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) <ect>
listened <identifiersep> call . remove <identifiersep> call <identifiersep> change <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; listened <identifiersep> call . remove <identifiersep> call <identifiersep> change <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) { <ect>
set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test <identifiersep> suite ( test <identifiersep> file <identifiersep> access <identifiersep> service . class ) ; add <identifiersep> test <identifiersep> suite ( test <identifiersep> fail <identifiersep> safe <identifiersep> transaction . class ) ; bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; <LOG> } <comment> <ect>
} catch ( exception e ) { <comment> <LOG> } else { system . out . println ( <string_literal> + <string_literal> ) ; try { print <identifiersep> stream temp = new print <identifiersep> stream ( applet <identifiersep> file , <string_literal> ) ; temp . print ( out <identifiersep> string ) ; <ect>
} else { sadness ( <string_literal> + filename + <string_literal> ) ; } } catch ( io <identifiersep> exception e ) { sadness ( <string_literal> ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } static void sadness ( string msg ) { <LOG> } <comment> <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { rgb <identifiersep> value < < = <number_literal> ; if ( values [ i ] . ends <identifiersep> with ( <string_literal> ) ) { rgb <identifiersep> value | = ( int ) ( p <identifiersep> applet . constrain ( <number_literal> * parse <identifiersep> float <identifiersep> or <identifiersep> percent ( values [ i ] ) , 0 , <number_literal> ) ) ; } else { rgb <identifiersep> value | = p <identifiersep> applet . constrain ( p <identifiersep> applet . parse <identifiersep> int ( values [ i ] ) , 0 , <number_literal> ) ; } } <LOG> return rgb <identifiersep> value ; } <comment> <ect>
} else if ( name . equals ( <string_literal> ) ) { <comment> <LOG> } } } protected void draw <identifiersep> shape ( ) { <comment> <ect>
font <identifiersep> glyph fg = unicode <identifiersep> glyphs . get ( character . value <identifiersep> of ( c [ i ] ) ) ; if ( fg != null ) { fg . draw ( g ) ; <comment> <LOG> } } g . pop <identifiersep> matrix ( ) ; } public void draw <identifiersep> char ( p <identifiersep> graphics g , char c , float x , float y , float size ) { g . push <identifiersep> matrix ( ) ; float s = size / face . units <identifiersep> per <identifiersep> em ; g . translate ( x , y ) ; g . scale ( s , - s ) ; <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> long sleep <identifiersep> time = ( frame <identifiersep> rate <identifiersep> period - time <identifiersep> diff ) - over <identifiersep> sleep <identifiersep> time ; if ( sleep <identifiersep> time > 0 ) { <comment> <ect>
} else { while ( ( big /= <number_literal> ) != 0 ) digits ++ ; <comment> <LOG> p <identifiersep> applet . nfs ( m11 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m12 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m13 , digits , <number_literal> ) ) ; system . out . println ( p <identifiersep> applet . nfs ( m20 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m21 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m22 , digits , <number_literal> ) + <string_literal> + <ect>
p <identifiersep> applet . nfs ( m12 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m13 , digits , <number_literal> ) ) ; system . out . println ( p <identifiersep> applet . nfs ( m20 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m21 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m22 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m23 , digits , <number_literal> ) ) ; <LOG> p <identifiersep> applet . nfs ( m31 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m32 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m33 , digits , <number_literal> ) ) ; system . out . println ( ) ; } <comment> <ect>
boolean inside <identifiersep> settings ( string method , object . . . args ) { if ( inside <identifiersep> settings ) { return true ; } final string url = <string_literal> + method + <string_literal> ; if ( ! external ) { <comment> <LOG> system . err . println ( <string_literal> + method + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + method + <string_literal> + arg <identifiersep> list . join ( <string_literal> ) + <string_literal> ) ; system . err . println ( <string_literal> ) ; } throw new illegal <identifiersep> state <identifiersep> exception ( method + <string_literal> + url ) ; } void handle <identifiersep> settings ( ) { <ect>
return true ; } final string url = <string_literal> + method + <string_literal> ; if ( ! external ) { <comment> <LOG> system . err . println ( <string_literal> + method + <string_literal> + arg <identifiersep> list . join ( <string_literal> ) + <string_literal> ) ; system . err . println ( <string_literal> ) ; } throw new illegal <identifiersep> state <identifiersep> exception ( method + <string_literal> + url ) ; } void handle <identifiersep> settings ( ) { inside <identifiersep> settings = true ; <comment> <ect>
if ( ! external ) { <comment> <LOG> } throw new illegal <identifiersep> state <identifiersep> exception ( method + <string_literal> + url ) ; } void handle <identifiersep> settings ( ) { inside <identifiersep> settings = true ; <comment> <ect>
} else { graphics <identifiersep> device [ ] devices = env . get <identifiersep> screen <identifiersep> devices ( ) ; if ( display > 0 && display < = devices . length ) { device = devices [ display - 1 ] ; } else { if ( devices . length == 1 ) { <LOG> } else { system . err . format ( <string_literal> + <string_literal> , 1 , devices . length ) ; } throw new runtime <identifiersep> exception ( <string_literal> + display + <string_literal> ) ; } } try { field field = device . get <identifiersep> class ( ) . get <identifiersep> declared <identifiersep> field ( <string_literal> ) ; <ect>
<comment> <LOG> <comment> <ect>
register <identifiersep> no <identifiersep> args ( <string_literal> , o ) ; } @ deprecated public void register <identifiersep> dispose ( object o ) { register <identifiersep> no <identifiersep> args ( <string_literal> , o ) ; } @ deprecated public void unregister <identifiersep> size ( object o ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
string . format ( <string_literal> + <string_literal> , w , h , renderer , path ) ; throw new runtime <identifiersep> exception ( msg ) ; } else { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> <comment> <comment> <ect>
<comment> static public void print <identifiersep> array ( object what ) { if ( what == null ) { <comment> <LOG> } else { string name = what . get <identifiersep> class ( ) . get <identifiersep> name ( ) ; if ( name . char <identifiersep> at ( 0 ) == ' [ ' ) { switch ( name . char <identifiersep> at ( 1 ) ) { case ' [ ' : <comment> <ect>
<comment> <LOG> } } break ; case 'z' : <comment> <ect>
for ( int i = 0 ; i < zz . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + zz [ i ] ) ; } break ; case 'b' : <comment> <LOG> } break ; case 'c' : <comment> <ect>
for ( int i = 0 ; i < cc . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + cc [ i ] + <string_literal> ) ; } break ; case 'i' : <comment> <LOG> } break ; case 'j' : <comment> <ect>
for ( int i = 0 ; i < jj . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + jj [ i ] ) ; } break ; case 'f' : <comment> <LOG> } break ; case 'd' : <comment> <ect>
<comment> <LOG> return null ; } public p <identifiersep> image request <identifiersep> image ( string filename ) { <comment> <ect>
format = rgb ; } else if ( ( ( header [ <number_literal> ] == <number_literal> ) || ( header [ <number_literal> ] == <number_literal> ) ) && ( header [ <number_literal> ] == <number_literal> ) && ( ( header [ <number_literal> ] == 0x8 ) || ( header [ <number_literal> ] == 0x28 ) ) ) { <comment> <LOG> <comment> <ect>
try { class < ? > callback <identifiersep> class = callback <identifiersep> object . get <identifiersep> class ( ) ; method select <identifiersep> method = callback <identifiersep> class . get <identifiersep> method ( callback <identifiersep> method , new class [ ] { file . class } ) ; select <identifiersep> method . invoke ( callback <identifiersep> object , new object [ ] { selected <identifiersep> file } ) ; } catch ( illegal <identifiersep> access <identifiersep> exception iae ) { <LOG> } catch ( invocation <identifiersep> target <identifiersep> exception ite ) { ite . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception nsme ) { system . err . println ( callback <identifiersep> method + <string_literal> ) ; } } <comment> <ect>
<comment> public input <identifiersep> stream create <identifiersep> input <identifiersep> raw ( string filename ) { if ( filename == null ) return null ; if ( sketch <identifiersep> path == null ) { <LOG> throw new runtime <identifiersep> exception ( <string_literal> ) ; } if ( filename . length ( ) == 0 ) { <comment> <ect>
} catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception fnfe ) { <comment> <LOG> return null ; <comment> <ect>
input <identifiersep> stream input = new file <identifiersep> input <identifiersep> stream ( file ) ; final string lower = file . get <identifiersep> name ( ) . to <identifiersep> lower <identifiersep> case ( ) ; if ( lower . ends <identifiersep> with ( <string_literal> ) || lower . ends <identifiersep> with ( <string_literal> ) ) { return new buffered <identifiersep> input <identifiersep> stream ( new gzip <identifiersep> input <identifiersep> stream ( input ) ) ; } return new buffered <identifiersep> input <identifiersep> stream ( input ) ; } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; return null ; } } <comment> <ect>
input = new buffered <identifiersep> input <identifiersep> stream ( new gzip <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( file ) ) ) ; } else { long len = file . length ( ) ; <comment> <LOG> return null ; } length = ( int ) len ; input = new buffered <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( file ) ) ; } byte [ ] buffer = new byte [ length ] ; int count ; int offset = 0 ; <ect>
output <identifiersep> stream output = create <identifiersep> output ( temp <identifiersep> file ) ; save <identifiersep> bytes ( output , data ) ; output . close ( ) ; output = null ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { <LOG> } } if ( ! temp <identifiersep> file . rename <identifiersep> to ( file ) ) { system . err . println ( <string_literal> + temp <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + file ) ; if ( temp <identifiersep> file != null ) { <ect>
return p <identifiersep> graphics . lerp <identifiersep> color ( c1 , c2 , amt , rgb ) ; } static public int blend <identifiersep> color ( int c1 , int c2 , int mode ) { return p <identifiersep> image . blend <identifiersep> color ( c1 , c2 , mode ) ; } <comment> <LOG> system . err . flush ( ) ; <comment> <ect>
<comment> <LOG> system . exit ( 1 ) ; } <comment> <ect>
system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } <comment> <LOG> system . exit ( 1 ) ; } boolean external = false ; int [ ] location = null ; int [ ] editor <identifiersep> location = null ; string name = null ; int window <identifiersep> color = 0 ; <ect>
<comment> <LOG> <comment> <ect>
application . set <identifiersep> quit <identifiersep> handler ( null ) ; } <comment> <LOG> application . set <identifiersep> dock <identifiersep> icon <identifiersep> image ( image ) ; } <comment> <ect>
digits = <number_literal> ; } else { while ( ( big /= <number_literal> ) != 0 ) digits ++ ; <comment> <LOG> p <identifiersep> applet . nfs ( m11 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m12 , digits , <number_literal> ) ) ; system . out . println ( ) ; } <comment> <ect>
s . begin <identifiersep> contour ( ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> protected void default <identifiersep> settings ( ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
public void text <identifiersep> size ( float size ) { <comment> <LOG> <string_literal> ) ; return ; } if ( text <identifiersep> font == null ) { default <identifiersep> font <identifiersep> or <identifiersep> death ( <string_literal> , size ) ; } text <identifiersep> size <identifiersep> impl ( size ) ; } <comment> <ect>
int count = ( ( tiff [ <number_literal> ] & 0xff ) < < <number_literal> ) | ( ( tiff [ <number_literal> ] & 0xff ) < < <number_literal> ) | ( ( tiff [ <number_literal> ] & 0xff ) < < <number_literal> ) | ( tiff [ <number_literal> ] & 0xff ) ; if ( count != width * height * <number_literal> ) { <LOG> return null ; } <comment> <ect>
iio <identifiersep> metadata <identifiersep> node root = new iio <identifiersep> metadata <identifiersep> node ( <string_literal> ) ; root . append <identifiersep> child ( dim ) ; try { metadata . merge <identifiersep> tree ( <string_literal> , root ) ; return metadata ; } catch ( iio <identifiersep> invalid <identifiersep> tree <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } return null ; } protected string [ ] save <identifiersep> image <identifiersep> formats ; <comment> <ect>
filename += <string_literal> ; } os = new buffered <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( filename ) , <number_literal> ) ; success = save <identifiersep> tiff ( os ) ; <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; success = false ; } return success ; } } <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> pw . set <identifiersep> pixels ( 0 , 0 , source . pixel <identifiersep> width , source . pixel <identifiersep> height , argb <identifiersep> format , source . pixels , 0 , source . pixel <identifiersep> width ) ; } this . tinted = tint ; this . tinted <identifiersep> color = tint <identifiersep> color ; <comment> <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; smooth = 0 ; } scene <identifiersep> antialiasing scene <identifiersep> antialiasing = ( smooth == 0 ) ? scene <identifiersep> antialiasing . disabled : scene <identifiersep> antialiasing . balanced ; stage . set <identifiersep> scene ( new scene ( stack <identifiersep> pane , width , height , false , scene <identifiersep> antialiasing ) ) ; <comment> <ect>
public void run ( ) { application . launch ( p <identifiersep> application <identifiersep> fx . class ) ; } } ) . start ( ) ; <comment> <LOG> thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } } start <identifiersep> exception <identifiersep> handler <identifiersep> thread ( ) ; set <identifiersep> processing <identifiersep> icon ( stage ) ; } private void start <identifiersep> exception <identifiersep> handler <identifiersep> thread ( ) { thread exception <identifiersep> handler <identifiersep> thread = new thread ( ( ) - > { <ect>
indent <identifiersep> factor = - 1 ; } else if ( opt . starts <identifiersep> with ( <string_literal> ) ) { indent <identifiersep> factor = p <identifiersep> applet . parse <identifiersep> int ( opt . substring ( <number_literal> ) , - <number_literal> ) ; if ( indent <identifiersep> factor == - <number_literal> ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + opt ) ; } } else { <LOG> } } } output . print ( format ( indent <identifiersep> factor ) ) ; output . flush ( ) ; return true ; } <comment> <ect>
<comment> <LOG> if ( next <identifiersep> line == null ) { <comment> <ect>
temp [ c . length ] = ' \\ n' ; next <identifiersep> line . get <identifiersep> chars ( 0 , next <identifiersep> line . length ( ) , temp , c . length + 1 ) ; <comment> <LOG> <comment> <ect>
xml [ ] rows = sheet . get <identifiersep> children ( <string_literal> ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> set <identifiersep> string ( row <identifiersep> index , column <identifiersep> index , cell <identifiersep> data ) ; } column <identifiersep> index ++ ; if ( cell <identifiersep> data != null ) { <comment> <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; } field [ ] fields = target . get <identifiersep> declared <identifiersep> fields ( ) ; array <identifiersep> list < field > inuse = new array <identifiersep> list < > ( ) ; for ( field field : fields ) { string name = field . get <identifiersep> name ( ) ; if ( get <identifiersep> column <identifiersep> index ( name , false ) != - 1 ) { <LOG> if ( ! field . is <identifiersep> accessible ( ) ) { <comment> <ect>
output . write <identifiersep> boolean ( true ) ; for ( string title : column <identifiersep> titles ) { output . write <identifiersep> utf ( title ) ; } } else { output . write <identifiersep> boolean ( false ) ; } for ( int i = 0 ; i < get <identifiersep> column <identifiersep> count ( ) ; i ++ ) { <LOG> output . write <identifiersep> int ( column <identifiersep> types [ i ] ) ; } for ( int i = 0 ; i < get <identifiersep> column <identifiersep> count ( ) ; i ++ ) { if ( column <identifiersep> types [ i ] == category ) { column <identifiersep> categories [ i ] . write ( output ) ; } } if ( missing <identifiersep> string == null ) { output . write <identifiersep> boolean ( false ) ; <ect>
try { thread . sleep ( <number_literal> ) ; <comment> <LOG> } } row <identifiersep> count = new <identifiersep> count ; } <comment> <ect>
void read ( data <identifiersep> input <identifiersep> stream input ) throws io <identifiersep> exception { int count = input . read <identifiersep> int ( ) ; <comment> <LOG> data <identifiersep> to <identifiersep> index . put ( str , i ) ; index <identifiersep> to <identifiersep> data . add ( str ) ; } } } <comment> <ect>
framebuffer <identifiersep> renderbuffer ( framebuffer , color <identifiersep> attachment0 , renderbuffer , gl <identifiersep> multi <identifiersep> color . get ( 0 ) ) ; <comment> <LOG> req <identifiersep> num <identifiersep> samples = 1 ; destroy <identifiersep> fbo <identifiersep> layer ( ) ; <comment> <ect>
int program = create <identifiersep> program ( ) ; if ( program != 0 ) { attach <identifiersep> shader ( program , vertex <identifiersep> shader ) ; attach <identifiersep> shader ( program , fragment <identifiersep> shader ) ; link <identifiersep> program ( program ) ; if ( ! linked ( program ) ) { <LOG> system . err . println ( get <identifiersep> program <identifiersep> info <identifiersep> log ( program ) ) ; delete <identifiersep> program ( program ) ; program = 0 ; } } return program ; } protected boolean compiled ( int shader ) { int <identifiersep> buffer . rewind ( ) ; <ect>
this . rindex = 0 ; this . started = false ; this . join <identifiersep> segment = false ; this . prev = line <identifiersep> path . seg <identifiersep> moveto ; } boolean join <identifiersep> segment = false ; public void line <identifiersep> join ( ) { <LOG> this . join <identifiersep> segment = true ; } public void line <identifiersep> to ( int x1 , int y1 , int c1 ) { <comment> <ect>
} else if ( 0 < awt <identifiersep> devices . length ) { awt <identifiersep> display <identifiersep> device = awt <identifiersep> devices [ 0 ] ; } if ( awt <identifiersep> display <identifiersep> device == null ) { awt <identifiersep> display <identifiersep> device = graphics <identifiersep> environment . get <identifiersep> local <identifiersep> graphics <identifiersep> environment ( ) . get <identifiersep> default <identifiersep> screen <identifiersep> device ( ) ; } display <identifiersep> rect = awt <identifiersep> display <identifiersep> device . get <identifiersep> default <identifiersep> configuration ( ) . get <identifiersep> bounds ( ) ; } protected void init <identifiersep> gl ( ) { <LOG> if ( profile == null ) { if ( pjogl . profile == 1 ) { try { profile = gl <identifiersep> profile . get <identifiersep> gl2es1 ( ) ; } catch ( gl <identifiersep> exception ex ) { profile = gl <identifiersep> profile . get <identifiersep> max <identifiersep> fixed <identifiersep> func ( true ) ; <ect>
<comment> sketch <identifiersep> width = sketch . sketch <identifiersep> width ( ) ; sketch <identifiersep> height = sketch . sketch <identifiersep> height ( ) ; <LOG> boolean full <identifiersep> screen = sketch . sketch <identifiersep> full <identifiersep> screen ( ) ; <comment> <ect>
while ( draw <identifiersep> exception == null ) { draw <identifiersep> exception <identifiersep> mutex . wait ( ) ; } <comment> <LOG> <comment> <ect>
int w = window . get <identifiersep> width ( ) + window . get <identifiersep> insets ( ) . get <identifiersep> total <identifiersep> width ( ) ; int h = window . get <identifiersep> height ( ) + window . get <identifiersep> insets ( ) . get <identifiersep> total <identifiersep> height ( ) ; if ( location != null ) { <comment> <LOG> int location <identifiersep> x = editor <identifiersep> location [ 0 ] - <number_literal> ; int location <identifiersep> y = editor <identifiersep> location [ 1 ] ; if ( location <identifiersep> x - w > <number_literal> ) { <comment> <ect>
native <identifiersep> mouse <identifiersep> event ( e , mouse <identifiersep> event . move ) ; } @ override public void mouse <identifiersep> wheel <identifiersep> moved ( com . jogamp . newt . event . mouse <identifiersep> event e ) { native <identifiersep> mouse <identifiersep> event ( e , mouse <identifiersep> event . wheel ) ; } @ override public void mouse <identifiersep> entered ( com . jogamp . newt . event . mouse <identifiersep> event e ) { <LOG> native <identifiersep> mouse <identifiersep> event ( e , mouse <identifiersep> event . enter ) ; } @ override public void mouse <identifiersep> exited ( com . jogamp . newt . event . mouse <identifiersep> event e ) { <comment> <ect>
public void paint ( graphics screen ) { <comment> <LOG> <comment> <comment> <ect>
} else { if ( graphics . image != null ) { buffered <identifiersep> image graphics <identifiersep> image = ( buffered <identifiersep> image ) graphics . image ; if ( offscreen == null || offscreen . get <identifiersep> width ( ) != graphics <identifiersep> image . get <identifiersep> width ( ) || offscreen . get <identifiersep> height ( ) != graphics <identifiersep> image . get <identifiersep> height ( ) ) { <LOG> offscreen = ( buffered <identifiersep> image ) canvas . create <identifiersep> image ( graphics <identifiersep> image . get <identifiersep> width ( ) , graphics <identifiersep> image . get <identifiersep> height ( ) ) ; <comment> <ect>
public void mouse <identifiersep> pressed ( java . awt . event . mouse <identifiersep> event e ) { sketch . exit ( ) ; } } ) ; frame . add ( label ) ; dimension label <identifiersep> size = label . get <identifiersep> preferred <identifiersep> size ( ) ; <comment> <LOG> label <identifiersep> size = new dimension ( <number_literal> , label <identifiersep> size . height ) ; label . set <identifiersep> size ( label <identifiersep> size ) ; label . set <identifiersep> location ( <number_literal> , screen <identifiersep> rect . height - label <identifiersep> size . height - <number_literal> ) ; } <comment> <ect>
<comment> <LOG> } <comment> <ect>
float len = ( float ) math . sqrt ( nx * nx + ny * ny ) ; if ( len != 0 ) { nx /= len ; ny /= len ; } int span = ( int ) p <identifiersep> applet . dist ( tx1 , ty1 , tx2 , ty2 ) * accuracy ; if ( span < = 0 ) { <LOG> <comment> <ect>
for ( int j = prev ; j < = last ; j ++ ) { float btwn = p <identifiersep> applet . norm ( j , prev , last ) ; interp [ j ] [ 0 ] = ( int ) p <identifiersep> applet . lerp ( ( c0 > > <number_literal> ) & 0xff , ( c1 > > <number_literal> ) & 0xff , btwn ) ; interp [ j ] [ 1 ] = ( int ) p <identifiersep> applet . lerp ( ( c0 > > <number_literal> ) & 0xff , ( c1 > > <number_literal> ) & 0xff , btwn ) ; interp [ j ] [ <number_literal> ] = ( int ) p <identifiersep> applet . lerp ( c0 & 0xff , c1 & 0xff , btwn ) ; interp [ j ] [ <number_literal> ] = ( int ) ( p <identifiersep> applet . lerp ( ( c0 > > <number_literal> ) & 0xff , ( c1 > > <number_literal> ) & 0xff , btwn ) * opacity ) ; <LOG> } prev = last ; } int index = 0 ; for ( int j = 0 ; j < h ; j ++ ) { for ( int i = 0 ; i < w ; i ++ ) { <comment> <ect>
data [ index ++ ] = interp [ which ] [ <number_literal> ] ; data [ index ++ ] = interp [ which ] [ <number_literal> ] ; } } raster . set <identifiersep> pixels ( 0 , 0 , w , h , data ) ; return raster ; } } } protected paint calc <identifiersep> gradient <identifiersep> paint ( gradient gradient ) { if ( gradient instanceof linear <identifiersep> gradient ) { <LOG> linear <identifiersep> gradient grad = ( linear <identifiersep> gradient ) gradient ; return new linear <identifiersep> gradient <identifiersep> paint ( grad . x1 , grad . y1 , grad . x2 , grad . y2 , grad . offset , grad . color , grad . count , opacity ) ; } else if ( gradient instanceof radial <identifiersep> gradient ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> graphics <identifiersep> environment ge = graphics <identifiersep> environment . get <identifiersep> local <identifiersep> graphics <identifiersep> environment ( ) ; gc = ge . get <identifiersep> default <identifiersep> screen <identifiersep> device ( ) . get <identifiersep> default <identifiersep> configuration ( ) ; } <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> } else { <comment> <ect>
protected void default <identifiersep> settings ( ) { <comment> <LOG> <comment> <ect>
stroke <identifiersep> mode = arc2d . chord ; } if ( fill ) { <comment> <LOG> arc . set <identifiersep> arc ( x , y , w , h , start , sweep , stroke <identifiersep> mode ) ; stroke <identifiersep> shape ( arc ) ; } } <comment> <ect>
<comment> <LOG> <comment> <ect>
buffered <identifiersep> image . type <identifiersep> int <identifiersep> argb ) ; } writable <identifiersep> raster wr = image . get <identifiersep> raster ( ) ; if ( tint ) { if ( tinted <identifiersep> temp == null || tinted <identifiersep> temp . length != source . pixel <identifiersep> width ) { tinted <identifiersep> temp = new int [ source . pixel <identifiersep> width ] ; } int a2 = ( tint <identifiersep> color > > <number_literal> ) & 0xff ; <LOG> <comment> <ect>
g2 . set <identifiersep> font ( font ) ; text <identifiersep> font . set <identifiersep> native ( font ) ; font <identifiersep> object = font ; <comment> <LOG> <comment> } <comment> <ect>
} catch ( throwable e ) { <comment> <LOG> return - 1 ; } } } <ect>
static public string <identifiersep> dict read <identifiersep> settings ( file input <identifiersep> file ) { if ( ! input <identifiersep> file . exists ( ) ) { messages . loge ( input <identifiersep> file + <string_literal> ) ; return null ; } string lines [ ] = p <identifiersep> applet . load <identifiersep> strings ( input <identifiersep> file ) ; if ( lines == null ) { <LOG> return null ; } return read <identifiersep> settings ( input <identifiersep> file . to <identifiersep> string ( ) , lines ) ; } <comment> <ect>
line = line . trim ( ) ; if ( line . length ( ) != 0 ) { int equals = line . index <identifiersep> of ( ' = ' ) ; if ( equals == - 1 ) { if ( filename != null ) { system . err . println ( <string_literal> + filename ) ; <LOG> } } else { string attr = line . substring ( 0 , equals ) . trim ( ) ; string valu = line . substring ( equals + 1 ) . trim ( ) ; settings . set ( attr , valu ) ; } } } return settings ; } static public void copy <identifiersep> file ( file source <identifiersep> file , <ect>
system . err . println ( <string_literal> + child . get <identifiersep> absolute <identifiersep> path ( ) ) ; } result & = deleted ; } else if ( child . is <identifiersep> directory ( ) ) { result & = remove <identifiersep> dir ( child , print <identifiersep> error <identifiersep> messages ) ; } } } } boolean deleted = dir . delete ( ) ; if ( ! deleted && print <identifiersep> error <identifiersep> messages ) { <LOG> } result & = deleted ; return result ; } <comment> <ect>
p <identifiersep> applet . split ( path , file . path <identifiersep> separator <identifiersep> char ) ; for ( int i = 0 ; i < pieces . length ; i ++ ) { <comment> <LOG> package <identifiersep> list <identifiersep> from <identifiersep> zip ( pieces [ i ] , list ) ; } else { <comment> <ect>
<comment> <LOG> <comment> <ect>
file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( font <identifiersep> file ) ; buffered <identifiersep> input <identifiersep> stream input = new buffered <identifiersep> input <identifiersep> stream ( fis ) ; font font = font . create <identifiersep> font ( font . truetype <identifiersep> font , input ) ; input . close ( ) ; font <identifiersep> list . add ( font ) ; } catch ( exception e ) { <LOG> <comment> string [ ] font <identifiersep> list = new string [ fonts . length ] ; table = new hash <identifiersep> map < string , font > ( ) ; <ect>
try { font <identifiersep> list [ index ++ ] = fonts [ i ] . get <identifiersep> ps <identifiersep> name ( ) ; table . put ( fonts [ i ] . get <identifiersep> ps <identifiersep> name ( ) , fonts [ i ] ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> sample . set <identifiersep> font ( font ) ; string filename <identifiersep> suggestion = list [ selection ] . replace ( ' ' , ' <identifiersep> ' ) ; filename <identifiersep> suggestion += <string_literal> + fontsize ; filename <identifiersep> field . set <identifiersep> text ( filename <identifiersep> suggestion ) ; } } public void build ( ) { int fontsize = 0 ; <ect>
textarea . set <identifiersep> editable ( false ) ; textarea . set <identifiersep> highlighter ( null ) ; textarea . set <identifiersep> font ( new font ( <string_literal> , font . plain , <number_literal> ) ) ; pain . add ( textarea ) ; action <identifiersep> listener listener = new action <identifiersep> listener ( ) { public void action <identifiersep> performed ( action <identifiersep> event e ) { <LOG> <comment> <ect>
template <identifiersep> folder = get <identifiersep> template <identifiersep> folder ( ) ; } if ( template <identifiersep> folder . exists ( ) ) { util . copy <identifiersep> dir ( template <identifiersep> folder , sketch <identifiersep> folder ) ; file template <identifiersep> file = new file ( sketch <identifiersep> folder , <string_literal> + get <identifiersep> default <identifiersep> extension ( ) ) ; if ( ! template <identifiersep> file . rename <identifiersep> to ( newbie <identifiersep> file ) ) { <LOG> } } else { if ( ! newbie <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ) { system . err . println ( newbie <identifiersep> file + <string_literal> ) ; } } } catch ( exception e ) { <comment> <ect>
protected void rebuild <identifiersep> toolbar <identifiersep> menu ( ) { <comment> <LOG> <comment> <ect>
supposedly not needed , because anything besides 'true' ( ignoring case ) will just be false . . so if malformed - > false if ( value == null ) return default <identifiersep> value ; try { return ( new boolean ( value ) ) . boolean <identifiersep> value ( ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> <comment> } static public void set <identifiersep> boolean ( string attribute , boolean value ) { set ( attribute , value ? <string_literal> : <string_literal> ) ; <comment> <ect>
file export <identifiersep> settings = new file ( library <identifiersep> folder , <string_literal> ) ; string <identifiersep> dict export <identifiersep> table = export <identifiersep> settings . exists ( ) ? util . read <identifiersep> settings ( export <identifiersep> settings ) : new string <identifiersep> dict ( ) ; export <identifiersep> list = new hash <identifiersep> map < string , string [ ] > ( ) ; <comment> <LOG> <comment> <ect>
string host <identifiersep> platform = platform . get <identifiersep> name ( ) ; <comment> <LOG> <comment> <ect>
export <identifiersep> list . put ( platform <identifiersep> name64 , platform <identifiersep> list64 ) ; } if ( platform <identifiersep> list <identifiersep> armv6hf != null ) { export <identifiersep> list . put ( platform <identifiersep> name <identifiersep> armv6hf , platform <identifiersep> list <identifiersep> armv6hf ) ; } if ( platform <identifiersep> list <identifiersep> arm64 != null ) { export <identifiersep> list . put ( platform <identifiersep> name <identifiersep> arm64 , platform <identifiersep> list <identifiersep> arm64 ) ; } } } <comment> <LOG> <comment> <ect>
<comment> <LOG> throw e ; } } finally { process . destroy ( ) ; process <identifiersep> registry . unwatch ( process ) ; } } static public boolean ffs ( final string . . . cmd ) { try { <ect>
for ( final line <identifiersep> processor out : outs ) { try { out . process <identifiersep> line ( line ) ; } catch ( final exception e ) { } } } } catch ( final io <identifiersep> exception e ) { if ( base . debug ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( system . err ) ; <comment> <ect>
} catch ( exception e ) { <comment> <LOG> } <comment> <ect>
runtime . get <identifiersep> runtime ( ) . add <identifiersep> shutdown <identifiersep> hook ( new thread ( ) { @ override public void run ( ) { synchronized ( registry ) { for ( final process p : registry ) { try { <LOG> p . destroy ( ) ; } catch ( final exception drop ) { } } } } } ) ; } <comment> <ect>
return file . exists ( ) ; } protected boolean file <identifiersep> read <identifiersep> only ( ) { return ! file . can <identifiersep> write ( ) ; } protected boolean delete <identifiersep> file ( ) { return file . delete ( ) ; } protected boolean rename <identifiersep> to ( file what , string ext ) { <LOG> <comment> <ect>
<comment> public void load ( ) throws io <identifiersep> exception { program = util . load <identifiersep> file ( file ) ; if ( program == null ) { <LOG> system . err . println ( <string_literal> ) ; throw new io <identifiersep> exception ( <string_literal> + file ) ; } <comment> <ect>
if ( program . index <identifiersep> of ( ' \\ 0' ) != - 1 ) { program = program . replace <identifiersep> all ( <string_literal> , <string_literal> ) ; } saved <identifiersep> program = program ; <comment> <LOG> system . err . println ( <string_literal> + file . get <identifiersep> name ( ) + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( ) ; } set <identifiersep> last <identifiersep> modified ( ) ; <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( ) ; } set <identifiersep> last <identifiersep> modified ( ) ; set <identifiersep> modified ( false ) ; } <comment> <ect>
if ( c instanceof j <identifiersep> popup <identifiersep> menu ) c = ( ( j <identifiersep> popup <identifiersep> menu ) c ) . get <identifiersep> invoker ( ) ; else c = c . get <identifiersep> parent ( ) ; } } } <comment> <LOG> system . err . println ( <string_literal> ) ; return null ; } <comment> <ect>
tool <identifiersep> tip <identifiersep> manager . shared <identifiersep> instance ( ) . register <identifiersep> component ( this ) ; current <identifiersep> line = new segment ( ) ; current <identifiersep> line <identifiersep> index = - 1 ; set <identifiersep> cursor ( cursor . get <identifiersep> predefined <identifiersep> cursor ( cursor . text <identifiersep> cursor ) ) ; <comment> <LOG> <comment> <ect>
gfx . set <identifiersep> color ( defaults . bracket <identifiersep> highlight <identifiersep> color ) ; <comment> <LOG> if ( text <identifiersep> area . is <identifiersep> caret <identifiersep> visible ( ) ) { <comment> <ect>
int caret <identifiersep> x = text <identifiersep> area .  <identifiersep> offset <identifiersep> to <identifiersep> x ( line , offset ) ; int caret <identifiersep> width = ( ( defaults . block <identifiersep> caret || text <identifiersep> area . is <identifiersep> overwrite <identifiersep> enabled ( ) ) ? fm . char <identifiersep> width ( 'w' ) : 1 ) ; y += fm . get <identifiersep> leading ( ) + fm . get <identifiersep> max <identifiersep> descent ( ) ; int height = fm . get <identifiersep> height ( ) ; <LOG> gfx . set <identifiersep> color ( defaults . caret <identifiersep> color ) ; if ( text <identifiersep> area . is <identifiersep> overwrite <identifiersep> enabled ( ) ) { gfx . fill <identifiersep> rect ( caret <identifiersep> x , y + height - 1 , caret <identifiersep> width , 1 ) ; } else { <comment> <ect>
add <identifiersep> mouse <identifiersep> wheel <identifiersep> listener ( new mouse <identifiersep> wheel <identifiersep> listener ( ) { @ override public void mouse <identifiersep> wheel <identifiersep> moved ( mouse <identifiersep> wheel <identifiersep> event e ) { if ( scroll <identifiersep> bars <identifiersep> initialized ) { if ( e . get <identifiersep> scroll <identifiersep> type ( ) == mouse <identifiersep> wheel <identifiersep> event . wheel <identifiersep> unit <identifiersep> scroll ) { int scroll <identifiersep> amount = e . get <identifiersep> units <identifiersep> to <identifiersep> scroll ( ) ; <LOG> <comment> <ect>
if ( scroll <identifiersep> bars <identifiersep> initialized ) { if ( e . get <identifiersep> scroll <identifiersep> type ( ) == mouse <identifiersep> wheel <identifiersep> event . wheel <identifiersep> unit <identifiersep> scroll ) { int scroll <identifiersep> amount = e . get <identifiersep> units <identifiersep> to <identifiersep> scroll ( ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
for ( int i = 0 ; i < repeat <identifiersep> count ; i ++ ) { sb . append ( selection ) ; } selection = sb . to <identifiersep> string ( ) ; set <identifiersep> selected <identifiersep> text ( selection ) ; } catch ( exception e ) { get <identifiersep> toolkit ( ) . beep ( ) ; <LOG> data <identifiersep> flavor [ ] flavors = clipboard . get <identifiersep> available <identifiersep> data <identifiersep> flavors ( ) ; for ( data <identifiersep> flavor f : flavors ) { try { object o = clipboard . get <identifiersep> contents ( this ) . get <identifiersep> transfer <identifiersep> data ( f ) ; system . out . println ( f + <string_literal> + o ) ; } catch ( exception ex ) { <ect>
<comment> <LOG> <comment> <ect>
case <number_literal> : do <identifiersep> triple <identifiersep> click ( event , line , offset , dot ) ; break ; } <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
if ( modifiers == 0 ) return key <identifiersep> stroke . get <identifiersep> key <identifiersep> stroke ( ch ) ; else return key <identifiersep> stroke . get <identifiersep> key <identifiersep> stroke ( ch , modifiers ) ; } else if ( key . length ( ) == 0 ) { <LOG> return null ; } else { int ch ; try { <ect>
try { contrib <identifiersep> modes . add ( new mode <identifiersep> contribution ( this , folder , null ) ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> error nsme ) { system . err . println ( folder . get <identifiersep> name ( ) + <string_literal> ) ; if ( debug ) nsme . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { <LOG> if ( debug ) ncdfe . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ite ) { system . err . println ( folder . get <identifiersep> name ( ) + <string_literal> ) ; if ( debug ) ite . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( ignorable <identifiersep> exception ig ) { messages . log ( ig . get <identifiersep> message ( ) ) ; <ect>
system . err . println ( folder . get <identifiersep> name ( ) + <string_literal> ) ; if ( debug ) ite . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( ignorable <identifiersep> exception ig ) { messages . log ( ig . get <identifiersep> message ( ) ) ; if ( debug ) ig . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( throwable e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } else { known . remove ( folder ) ; <comment> <ect>
contrib <identifiersep> modes . add ( mc ) ; file key = get <identifiersep> file <identifiersep> for <identifiersep> contrib ( mc , known ) ; if ( key != null ) { known . remove ( key ) ; } } if ( known . size ( ) != 0 ) { for ( mode <identifiersep> contribution mc : known . values ( ) ) { <LOG> } } } static private file get <identifiersep> file <identifiersep> for <identifiersep> contrib ( mode <identifiersep> contribution contrib , map < file , mode <identifiersep> contribution > known ) { for ( entry < file , mode <identifiersep> contribution > entry : known . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> value ( ) == contrib ) { return entry . get <identifiersep> key ( ) ; } } return null ; <ect>
<comment> <LOG> <string_literal> ) ; system . err . println ( <string_literal> + nsme . get <identifiersep> message ( ) + <string_literal> ) ; messages . loge ( <string_literal> , nsme ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; <ect>
} catch ( no <identifiersep> such <identifiersep> method <identifiersep> error nsme ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; system . err . println ( <string_literal> + nsme . get <identifiersep> message ( ) + <string_literal> ) ; messages . loge ( <string_literal> , nsme ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { <LOG> <string_literal> ) ; system . err . println ( <string_literal> + ncdfe . get <identifiersep> message ( ) + <string_literal> ) ; messages . loge ( <string_literal> , ncdfe ) ; } catch ( abstract <identifiersep> method <identifiersep> error ame ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; <ect>
} catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; system . err . println ( <string_literal> + ncdfe . get <identifiersep> message ( ) + <string_literal> ) ; messages . loge ( <string_literal> , ncdfe ) ; } catch ( abstract <identifiersep> method <identifiersep> error ame ) { <LOG> <string_literal> ) ; <comment> <ect>
<string_literal> ) ; <comment> <LOG> ex . print <identifiersep> stack <identifiersep> trace ( ) ; } } } protected void init <identifiersep> internal <identifiersep> tool ( string class <identifiersep> name ) { try { class < ? > tool <identifiersep> class = class . for <identifiersep> name ( class <identifiersep> name ) ; final tool tool = ( tool ) tool <identifiersep> class . get <identifiersep> declared <identifiersep> constructor ( ) . new <identifiersep> instance ( ) ; <ect>
<comment> public editor handle <identifiersep> open ( string path , boolean untitled ) { return handle <identifiersep> open ( path , untitled , new editor <identifiersep> state ( editors ) ) ; } protected editor handle <identifiersep> open ( string path , boolean untitled , editor <identifiersep> state state ) { try { <LOG> final file file = new file ( path ) ; if ( ! file . exists ( ) ) { return null ; } <comment> <ect>
result == j <identifiersep> option <identifiersep> pane . closed <identifiersep> option ) { return false ; } } } preferences . unset ( <string_literal> ) ; <comment> <LOG> <comment> <ect>
system . err . println ( language . interpolate ( <string_literal> , contrib . get <identifiersep> name ( ) ) ) ; } } editor . get <identifiersep> text <identifiersep> area ( ) . set <identifiersep> editable ( true ) ; editor . status <identifiersep> empty ( ) ; system . out . println ( language . text ( <string_literal> ) ) ; for ( string l : installed <identifiersep> lib <identifiersep> list ) { <LOG> } } <comment> <ect>
url <identifiersep> list [ j ] = extra <identifiersep> urls . get ( j ) ; } for ( int k = 0 ; k < archives . length ; k ++ , j ++ ) { messages . log ( <string_literal> + archives [ k ] + <string_literal> + get <identifiersep> name ( ) ) ; url <identifiersep> list [ j ] = archives [ k ] . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ; } loader = new url <identifiersep> class <identifiersep> loader ( url <identifiersep> list ) ; messages . log ( <string_literal> + loader ) ; <LOG> <comment> <ect>
sentence = properties . get ( <string_literal> ) ; paragraph = properties . get ( <string_literal> ) ; try { version = integer . parse <identifiersep> int ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + name + <string_literal> ) ; <LOG> } set <identifiersep> pretty <identifiersep> version ( properties . get ( <string_literal> ) ) ; try { last <identifiersep> updated = long . parse <identifiersep> long ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { last <identifiersep> updated = 0 ; <comment> <ect>
try { last <identifiersep> updated = long . parse <identifiersep> long ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { last <identifiersep> updated = 0 ; <comment> <LOG> } string min <identifiersep> rev = properties . get ( <string_literal> ) ; if ( min <identifiersep> rev != null ) { min <identifiersep> revision = p <identifiersep> applet . parse <identifiersep> int ( min <identifiersep> rev , 0 ) ; } string max <identifiersep> rev = properties . get ( <string_literal> ) ; if ( max <identifiersep> rev != null ) { max <identifiersep> revision = p <identifiersep> applet . parse <identifiersep> int ( max <identifiersep> rev , 0 ) ; <ect>
boolean is <identifiersep> update <identifiersep> flagged ( ) { return is <identifiersep> update <identifiersep> flagged ( get <identifiersep> folder ( ) ) ; } static boolean is <identifiersep> update <identifiersep> flagged ( file folder ) { return is <identifiersep> flagged ( folder , update <identifiersep> flagged ) ; } <comment> <LOG> return set <identifiersep> flag ( restart <identifiersep> flag , true ) ; } @ override boolean is <identifiersep> restart <identifiersep> flagged ( ) { <comment> <ect>
zip <identifiersep> file zip <identifiersep> file = new zip <identifiersep> file ( file ) ; enumeration < ? > entries = zip <identifiersep> file . entries ( ) ; while ( entries . has <identifiersep> more <identifiersep> elements ( ) ) { zip <identifiersep> entry entry = ( zip <identifiersep> entry ) entries . next <identifiersep> element ( ) ; if ( ! entry . is <identifiersep> directory ( ) ) { string name = entry . get <identifiersep> name ( ) ; <LOG> if ( name . ends <identifiersep> with ( class <identifiersep> file <identifiersep> name ) ) { <comment> <ect>
boolean has <identifiersep> focus , int row , int column ) { contribution contribution = ( contribution ) value ; j <identifiersep> label label = new j <identifiersep> label ( ) ; if ( value == null ) { <comment> <LOG> <comment> <ect>
} catch ( io <identifiersep> exception e ) { messages . show <identifiersep> warning ( language . text ( <string_literal> ) , language . interpolate ( <string_literal> , new <identifiersep> file , folder . get <identifiersep> absolute <identifiersep> path ( ) ) , e ) ; return ; } sketch <identifiersep> code new <identifiersep> code = new sketch <identifiersep> code ( new <identifiersep> file , new <identifiersep> extension ) ; <LOG> insert <identifiersep> code ( new <identifiersep> code ) ; } <comment> <ect>
public void handle <identifiersep> next <identifiersep> code ( ) { set <identifiersep> current <identifiersep> code ( ( current <identifiersep> index + 1 ) % code <identifiersep> count ) ; } <comment> public void set <identifiersep> modified ( boolean state ) { <LOG> <comment> <ect>
current = null ; <comment> <LOG> <comment> <comment> <ect>
<comment> static public void show <identifiersep> message ( string title , string message ) { if ( title == null ) title = <string_literal> ; if ( base . is <identifiersep> command <identifiersep> line ( ) ) { <LOG> } else { j <identifiersep> option <identifiersep> pane . show <identifiersep> message <identifiersep> dialog ( new frame ( ) , message , title , j <identifiersep> option <identifiersep> pane . information <identifiersep> message ) ; } } <comment> <ect>
static public void show <identifiersep> warning <identifiersep> tiered ( string title , string primary , string secondary , throwable e ) { if ( title == null ) title = <string_literal> ; final string message = primary + <string_literal> + secondary ; if ( base . is <identifiersep> command <identifiersep> line ( ) ) { <LOG> } else { <comment> <ect>
<comment> static public void show <identifiersep> trace ( string title , string message , throwable t , boolean fatal ) { if ( title == null ) title = fatal ? <string_literal> : <string_literal> ; if ( base . is <identifiersep> command <identifiersep> line ( ) ) { <LOG> if ( t != null ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; } } else { string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; t . print <identifiersep> stack <identifiersep> trace ( new print <identifiersep> writer ( sw ) ) ; <comment> <ect>
if ( e instanceof form <identifiersep> submit <identifiersep> event ) { string result = ( ( form <identifiersep> submit <identifiersep> event ) e ) . get <identifiersep> data ( ) ; string <identifiersep> dict dict = new string <identifiersep> dict ( ) ; if ( result . trim ( ) . length ( ) != 0 ) { string [ ] pairs = result . split ( <string_literal> ) ; for ( string pair : pairs ) { <LOG> string [ ] pieces = pair . split ( <string_literal> ) ; string attr = p <identifiersep> applet . url <identifiersep> decode ( pieces [ 0 ] ) ; string valu = p <identifiersep> applet . url <identifiersep> decode ( pieces [ 1 ] ) ; dict . set ( attr , valu ) ; } } <comment> <ect>
<comment> static public image <identifiersep> icon get <identifiersep> lib <identifiersep> icon ( string filename ) { file file = platform . get <identifiersep> content <identifiersep> file ( <string_literal> + filename ) ; if ( ! file . exists ( ) ) { <LOG> return null ; } return new image <identifiersep> icon ( file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } static public image <identifiersep> icon get <identifiersep> icon <identifiersep> x ( file dir , string base ) { return get <identifiersep> icon <identifiersep> x ( dir , base , 0 ) ; } <comment> <ect>
double w = font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) ; if ( w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) && w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) && w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) ) { <comment> <LOG> <comment> <ect>
if ( platform . is <identifiersep> mac <identifiersep> os ( ) ) { row . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; } else { row . add ( create <identifiersep> fixed <identifiersep> label ( <string_literal> ) ) ; } j <identifiersep> button button = new j <identifiersep> button ( button <identifiersep> name ) ; button . add <identifiersep> action <identifiersep> listener ( button <identifiersep> listener ) ; <LOG> row . add ( button ) ; row . add ( box . create <identifiersep> horizontal <identifiersep> glue ( ) ) ; box . add ( row ) ; row = box . create <identifiersep> horizontal <identifiersep> box ( ) ; if ( platform . is <identifiersep> mac <identifiersep> os ( ) ) { row . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; <ect>
update <identifiersep> menu ( toolbar <identifiersep> menu ) ; } static protected void save ( ) { file . set <identifiersep> writable ( true , false ) ; print <identifiersep> writer writer = p <identifiersep> applet . create <identifiersep> writer ( file ) ; writer . println ( version ) ; for ( record record : records ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
try { memory <identifiersep> max = integer . parse <identifiersep> int ( memory <identifiersep> field . get <identifiersep> text ( ) . trim ( ) ) ; <comment> <LOG> } <comment> <ect>
textarea . set <identifiersep> caret <identifiersep> position ( caret ) ; textarea . scroll <identifiersep> to <identifiersep> caret ( ) ; } catch ( exception ignore ) { } try { undo . undo ( ) ; } catch ( cannot <identifiersep> undo <identifiersep> exception ex ) { <LOG> <comment> <ect>
case ' \\ t' : case ' \\ n' : case ' \\ r' : index ++ ; break ; default : <LOG> return false ; } } <comment> <ect>
int stop = textarea . get <identifiersep> selection <identifiersep> stop ( ) ; if ( stop < start ) { int temp = stop ; stop = start ; start = temp ; } char [ ] c = textarea . get <identifiersep> text ( ) . to <identifiersep> char <identifiersep> array ( ) ; <LOG> if ( start == stop ) { while ( start > 0 && functionable ( c [ start - 1 ] ) ) { start -- ; } while ( stop < c . length && functionable ( c [ stop ] ) ) { stop ++ ; } <comment> <ect>
while ( start > 0 && functionable ( c [ start - 1 ] ) ) { start -- ; } while ( stop < c . length && functionable ( c [ stop ] ) ) { stop ++ ; } <comment> <LOG> if ( check <identifiersep> paren ( c , stop , c . length ) ) { text += <string_literal> ; } string ref = mode . lookup <identifiersep> reference ( text ) ; if ( select <identifiersep> if <identifiersep> found ) { textarea . select ( start , stop ) ; } return ref ; <ect>
char [ ] c = textarea . get <identifiersep> text ( ) . to <identifiersep> char <identifiersep> array ( ) ; int after = math . max ( textarea . get <identifiersep> selection <identifiersep> start ( ) , textarea . get <identifiersep> selection <identifiersep> stop ( ) ) ; if ( check <identifiersep> paren ( c , after , c . length ) ) { text += <string_literal> ; system . out . println ( <string_literal> + text ) ; } string reference <identifiersep> file = mode . lookup <identifiersep> reference ( text ) ; <LOG> if ( reference <identifiersep> file == null ) { status <identifiersep> notice ( <string_literal> + text + <string_literal> ) ; } else { show <identifiersep> reference ( reference <identifiersep> file + <string_literal> ) ; } } } protected void handle <identifiersep> find <identifiersep> reference ( ) { string text = textarea . get <identifiersep> selected <identifiersep> text ( ) . trim ( ) ; <ect>
<comment> <LOG> } <comment> public void handle <identifiersep> print ( ) { status <identifiersep> notice ( language . text ( <string_literal> ) ) ; string <identifiersep> builder html = new string <identifiersep> builder ( <string_literal> ) ; <ect>
<comment> public void status <identifiersep> error ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> rebuild <identifiersep> menu ( ) ; repaint ( ) ; } public void rebuild <identifiersep> menu ( ) { <comment> <ect>
<comment> public void sketchbook <identifiersep> callback ( file folder ) { if ( folder != null ) { if ( base != null ) { base . set <identifiersep> sketchbook <identifiersep> folder ( folder ) ; } else { <LOG> } } } <comment> public void handle <identifiersep> close ( ) { preferences . save ( ) ; <comment> <ect>
protected void restore <identifiersep> expanded ( j <identifiersep> tree tree ) { string pref = <string_literal> + get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> ; string value = preferences . get ( pref ) ; if ( value != null ) { string [ ] paths = p <identifiersep> applet . split ( value , file . path <identifiersep> separator ) ; for ( string path : paths ) { <LOG> string [ ] items = p <identifiersep> applet . split ( path , file . separator ) ; default <identifiersep> mutable <identifiersep> tree <identifiersep> node [ ] nodes = new default <identifiersep> mutable <identifiersep> tree <identifiersep> node [ items . length ] ; expand <identifiersep> tree ( tree , null , items , nodes , 0 ) ; } } } void expand <identifiersep> tree ( j <identifiersep> tree tree , object object , string [ ] items , default <identifiersep> mutable <identifiersep> tree <identifiersep> node [ ] nodes , int index ) { <comment> <ect>
tree <identifiersep> node example <identifiersep> node = sub <identifiersep> node . get <identifiersep> child <identifiersep> at ( example <identifiersep> node <identifiersep> number ) ; sub <identifiersep> node . remove ( example <identifiersep> node <identifiersep> number ) ; int count = example <identifiersep> node . get <identifiersep> child <identifiersep> count ( ) ; for ( int j = 0 ; j < count ; j ++ ) { sub <identifiersep> node . add ( ( default <identifiersep> mutable <identifiersep> tree <identifiersep> node ) example <identifiersep> node . get <identifiersep> child <identifiersep> at ( 0 ) ) ; } } <comment> <LOG> <comment> <ect>
toolkit . set <identifiersep> icon ( this ) ; <comment> <LOG> find <identifiersep> field . select <identifiersep> all ( ) ; } } ) ; pack ( ) ; set <identifiersep> resizable ( true ) ; set <identifiersep> location <identifiersep> relative <identifiersep> to ( null ) ; } public void handle <identifiersep> close ( ) { <ect>
<comment> <LOG> } else { throw new build <identifiersep> exception ( <string_literal> + location . size ( ) + <string_literal> ) ; } list < string > cookies = headers . get ( <string_literal> ) ; conn = ( http <identifiersep> url <identifiersep> connection ) new url ( url ) . open <identifiersep> connection ( ) ; if ( cookies != null ) { for ( string cookie : cookies ) { <ect>
if ( copyright == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } if ( main <identifiersep> class <identifiersep> name == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <comment> <LOG> <comment> <ect>
return null ; } else { cannot <identifiersep> read ( file ) ; return null ; } } else { if ( image . get <identifiersep> width ( ) < = 0 || image . get <identifiersep> height ( ) < = 0 ) { <LOG> return null ; } } return image ; <comment> <ect>
<comment> <LOG> long count = 0 ; byte [ ] audio <identifiersep> buffer = new byte [ as <identifiersep> size * nb <identifiersep> of <identifiersep> frames <identifiersep> in <identifiersep> buffer ] ; for ( int bytes <identifiersep> read = audio <identifiersep> in . read ( audio <identifiersep> buffer ) ; bytes <identifiersep> read != - 1 ; bytes <identifiersep> read = audio <identifiersep> in . read ( audio <identifiersep> buffer ) ) { if ( bytes <identifiersep> read != 0 ) { <ect>
<comment> <LOG> <comment> <ect>
header <identifiersep> data . write <identifiersep> u <identifiersep> int ( size ( ) ) ; header <identifiersep> data . write <identifiersep> type ( type ) ; seek <identifiersep> relative ( pointer ) ; finished = true ; long size <identifiersep> after = size ( ) ; if ( size <identifiersep> before != size <identifiersep> after ) { <LOG> } } } @ override public long size ( ) { return <number_literal> + data . size ( ) ; } } <comment> <ect>
for ( ; ymax > ymin ; ymax -= scanline <identifiersep> stride ) { int xy = ymax - scanline <identifiersep> stride ; int xymax = ymax - scanline <identifiersep> stride + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } <LOG> <comment> <ect>
for ( ; ymax > ymin ; ymax -= scanline <identifiersep> stride ) { int xy = ymax - scanline <identifiersep> stride ; int xymax = ymax - scanline <identifiersep> stride + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { break scanline ; } } } <LOG> <comment> <ect>
try { enc . write <identifiersep> key24 ( buf , data , w - <number_literal> , h , 1 , w ) ; buf . close ( ) ; byte [ ] result = buf . to <identifiersep> byte <identifiersep> array ( ) ; int full <identifiersep> size = ( w - <number_literal> ) * h * <number_literal> ; system . out . println ( <string_literal> + full <identifiersep> size ) ; <LOG> system . out . println ( <string_literal> + ( <number_literal> * ( result . length / ( float ) full <identifiersep> size ) ) ) ; <comment> <ect>
apple <identifiersep> rle <identifiersep> encoder enc = new apple <identifiersep> rle <identifiersep> encoder ( ) ; try { <comment> <LOG> system . out . println ( arrays . to <identifiersep> string ( result ) ) ; system . out . print ( <string_literal> ) ; for ( int i = 0 ; i < result . length ; i ++ ) { if ( i != 0 ) { system . out . print ( ' , ' ) ; } string hex = <string_literal> + integer . to <identifiersep> hex <identifiersep> string ( result [ i ] ) ; <ect>
public void close ( ) { } public void flush ( ) { } public void write ( byte b [ ] ) { <comment> <LOG> this . message <identifiersep> consumer . message ( new string ( b , offset , length ) ) ; } public void write ( int b ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> static private void check <identifiersep> local <identifiersep> host ( ) throws sketch <identifiersep> exception { try { inet <identifiersep> address address = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( <string_literal> ) ; if ( ! address . get <identifiersep> host <identifiersep> address ( ) . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + platform . get <identifiersep> name ( ) ) ; throw new sketch <identifiersep> exception ( <string_literal> + <string_literal> , false ) ; } } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <ect>
try { inet <identifiersep> address address = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( <string_literal> ) ; if ( ! address . get <identifiersep> host <identifiersep> address ( ) . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> + platform . get <identifiersep> name ( ) ) ; throw new sketch <identifiersep> exception ( <string_literal> + <string_literal> , false ) ; } } catch ( unknown <identifiersep> host <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } public virtual <identifiersep> machine launch ( string [ ] args ) { <ect>
<comment> <LOG> <comment> <ect>
system . err . println ( <string_literal> + run <identifiersep> display + <string_literal> ) ; } run <identifiersep> device = editor <identifiersep> device ; for ( int i = 0 ; i < devices . length ; i ++ ) { if ( devices [ i ] == run <identifiersep> device ) { <comment> <LOG> } run <identifiersep> display = i + 1 ; <comment> <ect>
reference <identifiersep> type rt = or . reference <identifiersep> type ( ) ; string exception <identifiersep> name = rt . name ( ) ; <comment> <LOG> <comment> <ect>
<comment> protected sketch <identifiersep> exception find <identifiersep> exception ( string message , object <identifiersep> reference or , thread <identifiersep> reference thread ) { try { <comment> <LOG> <comment> <ect>
return rex ; } } <comment> <LOG> or . invoke <identifiersep> method ( thread , method , new array <identifiersep> list < value > ( ) , object <identifiersep> reference . invoke <identifiersep> single <identifiersep> threaded ) ; } catch ( exception e ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
string nums = s . substring ( s . index <identifiersep> of ( ' ' ) + 1 ) . trim ( ) ; int space = nums . index <identifiersep> of ( ' ' ) ; int left = integer . parse <identifiersep> int ( nums . substring ( 0 , space ) ) ; int top = integer . parse <identifiersep> int ( nums . substring ( space + 1 ) ) ; <comment> <LOG> return ; } <comment> <ect>
<comment> <LOG> sketch <identifiersep> err . flush ( ) ; } } <ect>
int offset = 0 ; boolean found = false ; do { m = import <identifiersep> pattern . matcher ( scrubbed ) ; found = m . find ( offset ) ; if ( found ) { <LOG> string before = m . group ( 1 ) ; string piece = m . group ( <number_literal> ) + m . group ( <number_literal> ) + m . group ( <number_literal> ) ; <comment> <ect>
if ( ! ignore <identifiersep> import ( m . group ( <number_literal> ) ) ) { program <identifiersep> imports . add ( m . group ( <number_literal> ) ) ; <comment> <LOG> <comment> <ect>
program = program . substring ( 0 , start ) + program . substring ( stop ) ; scrubbed = scrubbed . substring ( 0 , start ) + scrubbed . substring ( stop ) ; <comment> <LOG> <comment> <ect>
super ( base , path , state , mode ) ; jmode = ( java <identifiersep> mode ) mode ; debugger = new debugger ( this ) ; inspector = new variable <identifiersep> inspector ( this ) ; <comment> <LOG> debugger . set <identifiersep> breakpoint ( line <identifiersep> id ) ; } <comment> <ect>
<comment> <LOG> string old <identifiersep> name = get <identifiersep> sketch ( ) . get <identifiersep> code ( 0 ) . get <identifiersep> file <identifiersep> name ( ) ; <comment> <ect>
boolean saved = super . handle <identifiersep> save <identifiersep> as ( ) ; if ( saved ) { <comment> <LOG> for ( line <identifiersep> breakpoint bp : bps ) { line <identifiersep> id line = new line <identifiersep> id ( new <identifiersep> name , bp . line <identifiersep> id ( ) . line <identifiersep> idx ( ) ) ; <comment> <ect>
<comment> @ override public void dispose ( ) { <LOG> <comment> <ect>
messages . loge ( <string_literal> + tab <identifiersep> filename ) ; return ; } list < line <identifiersep> breakpoint > bps = debugger . get <identifiersep> breakpoints ( tab . get <identifiersep> file <identifiersep> name ( ) ) ; <comment> <LOG> try { tab . load ( ) ; string code = tab . get <identifiersep> program ( ) ; <comment> <ect>
try { tab . load ( ) ; string code = tab . get <identifiersep> program ( ) ; <comment> <LOG> lines [ bp . line <identifiersep> id ( ) . line <identifiersep> idx ( ) ] += breakpoint <identifiersep> marker <identifiersep> comment ; } code = p <identifiersep> applet . join ( lines , <string_literal> ) ; <comment> <ect>
<comment> public void remove <identifiersep> breakpointed <identifiersep> line ( int line <identifiersep> idx ) { line <identifiersep> id line = get <identifiersep> line <identifiersep> id <identifiersep> in <identifiersep> current <identifiersep> tab ( line <identifiersep> idx ) ; <LOG> line <identifiersep> highlight found <identifiersep> line = null ; for ( line <identifiersep> highlight hl : breakpointed <identifiersep> lines ) { if ( hl . get <identifiersep> line <identifiersep> id ( ) . equals ( line ) ) { found <identifiersep> line = hl ; break ; } } if ( found <identifiersep> line != null ) { <ect>
class <identifiersep> member scope <identifiersep> parent ; simple <identifiersep> type stp ; if ( ast <identifiersep> node instanceof simple <identifiersep> name ) { ast <identifiersep> node decl = find <identifiersep> declaration2 ( ( ( simple <identifiersep> name ) ast <identifiersep> node ) , nearest <identifiersep> node ) ; if ( decl != null ) { <comment> <LOG> { if ( decl . get <identifiersep> node <identifiersep> type ( ) == ast <identifiersep> node . type <identifiersep> declaration ) { type <identifiersep> declaration td = ( type <identifiersep> declaration ) decl ; return new class <identifiersep> member ( ps , td ) ; } } { <comment> <ect>
class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , fa . get <identifiersep> expression ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <LOG> return null ; } log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( stp ) ) ; scope <identifiersep> parent = defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) , <string_literal> ) ; } else { scope <identifiersep> parent = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , fa . get <identifiersep> expression ( ) , no <identifiersep> compare ) ; <ect>
return null ; } log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( stp ) ) ; scope <identifiersep> parent = defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) , <string_literal> ) ; } else { scope <identifiersep> parent = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , fa . get <identifiersep> expression ( ) , no <identifiersep> compare ) ; } <LOG> return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , scope <identifiersep> parent , fa . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } case ast <identifiersep> node . method <identifiersep> invocation : method <identifiersep> invocation mi = ( method <identifiersep> invocation ) ast <identifiersep> node ; ast <identifiersep> node temp = find <identifiersep> declaration2 ( mi . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; if ( temp instanceof method <identifiersep> declaration ) { <comment> <ect>
class < ? > array <identifiersep> class = get <identifiersep> array <identifiersep> class ( name , ps . class <identifiersep> loader ) ; return array <identifiersep> class == null ? null : new class <identifiersep> member ( array <identifiersep> class ) ; } } return new class <identifiersep> member ( ps , extrac <identifiersep> type <identifiersep> info ( temp ) ) ; } if ( mi . get <identifiersep> expression ( ) == null ) { <comment> <LOG> return null ; } else { if ( mi . get <identifiersep> expression ( ) instanceof simple <identifiersep> name ) { ast <identifiersep> node decl = find <identifiersep> declaration2 ( ( simple <identifiersep> name ) mi . get <identifiersep> expression ( ) , nearest <identifiersep> node ) ; if ( decl != null ) { <ect>
<comment> <LOG> ast <identifiersep> node type <identifiersep> dec = find <identifiersep> declaration2 ( stp . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; if ( type <identifiersep> dec == null ) { log ( stp . get <identifiersep> name ( ) + <string_literal> ) ; class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <ect>
. get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } <comment> <LOG> <comment> <ect>
break ; case ast <identifiersep> node . qualified <identifiersep> name : qualified <identifiersep> name qn = ( qualified <identifiersep> name ) ast <identifiersep> node ; ast <identifiersep> node temp2 = find <identifiersep> declaration2 ( qn . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; if ( temp2 instanceof field <identifiersep> declaration ) { <comment> <LOG> return new class <identifiersep> member ( ps , extrac <identifiersep> type <identifiersep> info ( temp2 ) ) ; } if ( qn . get <identifiersep> qualifier ( ) == null ) { log ( <string_literal> ) ; return null ; } else { if ( qn . get <identifiersep> qualifier ( ) instanceof simple <identifiersep> name ) { <ect>
<comment> class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , qn . get <identifiersep> qualifier ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <LOG> return null ; } log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( stp ) ) ; <comment> <ect>
log ( <string_literal> + qn . get <identifiersep> qualifier ( ) ) ; return null ; } log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( stp ) ) ; <comment> <LOG> class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <ect>
return null ; } return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( ps , type <identifiersep> dec ) , qn . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } else { scope <identifiersep> parent = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , qn . get <identifiersep> qualifier ( ) , no <identifiersep> compare ) ; <LOG> return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , scope <identifiersep> parent , qn . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } } case ast <identifiersep> node . array <identifiersep> access : array <identifiersep> access arac = ( array <identifiersep> access ) ast <identifiersep> node ; return resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , arac . get <identifiersep> array ( ) , no <identifiersep> compare ) ; default : log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( ast <identifiersep> node ) ) ; <ect>
public static array <identifiersep> list < completion <identifiersep> candidate > get <identifiersep> members <identifiersep> for <identifiersep> type ( preprocessed <identifiersep> sketch ps , string type <identifiersep> name , string child , boolean no <identifiersep> compare , boolean static <identifiersep> only ) { array <identifiersep> list < completion <identifiersep> candidate > candidates = new array <identifiersep> list < > ( ) ; <LOG> + <string_literal> + type <identifiersep> name + <string_literal> + no <identifiersep> compare + <string_literal> + static <identifiersep> only ) ; class < ? > probable <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , type <identifiersep> name ) ; if ( probable <identifiersep> class == null ) { log ( <string_literal> ) ; return candidates ; <ect>
candidates . add ( new completion <identifiersep> candidate ( method ) ) ; } else if ( method . get <identifiersep> name ( ) . to <identifiersep> string ( ) . to <identifiersep> lower <identifiersep> case ( ) . starts <identifiersep> with ( child ) ) candidates . add ( new completion <identifiersep> candidate ( method ) ) ; } } array <identifiersep> list < completion <identifiersep> candidate > super <identifiersep> class <identifiersep> candidates ; if ( td . get <identifiersep> superclass <identifiersep> type ( ) != null ) { <LOG> super <identifiersep> class <identifiersep> candidates = get <identifiersep> members <identifiersep> for <identifiersep> type ( ps , new class <identifiersep> member ( ps , td . get <identifiersep> superclass <identifiersep> type ( ) ) , child <identifiersep> to <identifiersep> look <identifiersep> for , no <identifiersep> compare , static <identifiersep> only ) ; } else { super <identifiersep> class <identifiersep> candidates = get <identifiersep> members <identifiersep> for <identifiersep> type ( ps , new class <identifiersep> member ( object . class ) , <ect>
probable <identifiersep> class = teh <identifiersep> class . get <identifiersep> class <identifiersep>  ( ) ; } else { probable <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , teh <identifiersep> class . get <identifiersep> type <identifiersep> as <identifiersep> string ( ) ) ; if ( probable <identifiersep> class == null ) { log ( <string_literal> + teh <identifiersep> class . get <identifiersep> type <identifiersep> as <identifiersep> string ( ) ) ; return candidates ; } <LOG> } for ( method method : probable <identifiersep> class . get <identifiersep> methods ( ) ) { if ( ! modifier . is <identifiersep> static ( method . get <identifiersep> modifiers ( ) ) && static <identifiersep> only ) { continue ; } string <identifiersep> builder label = new string <identifiersep> builder ( method . get <identifiersep> name ( ) + <string_literal> ) ; for ( int i = 0 ; i < method . get <identifiersep> parameter <identifiersep> types ( ) . length ; i ++ ) { label . append ( method . get <identifiersep> parameter <identifiersep> types ( ) [ i ] . get <identifiersep> simple <identifiersep> name ( ) ) ; <ect>
} catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> return null ; } if ( member <identifiersep> name . equals ( <string_literal> ) ) { return new class <identifiersep> member ( probable <identifiersep> class ) ; } else { return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( probable <identifiersep> class ) , member <identifiersep> name ) ; } } public static class <identifiersep> member defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( preprocessed <identifiersep> sketch ps , class <identifiersep> member teh <identifiersep> class , string member <identifiersep> name ) { <ect>
return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( object . class ) , member <identifiersep> name ) ; } } class < ? > probable <identifiersep> class ; if ( teh <identifiersep> class . get <identifiersep> class <identifiersep>  ( ) != null ) { probable <identifiersep> class = teh <identifiersep> class . get <identifiersep> class <identifiersep>  ( ) ; } else { probable <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , teh <identifiersep> class . get <identifiersep> type <identifiersep> as <identifiersep> string ( ) ) ; <LOG> } for ( method method : probable <identifiersep> class . get <identifiersep> methods ( ) ) { if ( method . get <identifiersep> name ( ) . equals <identifiersep> ignore <identifiersep> case ( member <identifiersep> name ) ) { return new class <identifiersep> member ( method ) ; } } for ( field field : probable <identifiersep> class . get <identifiersep> fields ( ) ) { if ( field . get <identifiersep> name ( ) . equals <identifiersep> ignore <identifiersep> case ( member <identifiersep> name ) ) { return new class <identifiersep> member ( field ) ; <ect>
if ( get <identifiersep> line <identifiersep> number ( cnode ) < = line <identifiersep> number && line <identifiersep> number < = c <identifiersep> line <identifiersep> num ) { return find <identifiersep> closest <identifiersep> parent <identifiersep> node ( line <identifiersep> number , cnode ) ; } } } } return node ; } protected static ast <identifiersep> node find <identifiersep> closest <identifiersep> node ( int line <identifiersep> number , ast <identifiersep> node node ) { log ( <string_literal> + line <identifiersep> number ) ; ast <identifiersep> node parent = find <identifiersep> closest <identifiersep> parent <identifiersep> node ( line <identifiersep> number , node ) ; <LOG> if ( parent == null ) return null ; if ( get <identifiersep> line <identifiersep> number ( parent ) == line <identifiersep> number ) { log ( parent + <string_literal> + get <identifiersep> line <identifiersep> number ( parent ) + <string_literal> + line <identifiersep> number ) ; return parent ; } list < ast <identifiersep> node > nodes ; <ect>
ast <identifiersep> node testnode = parser . create <identifiersep> ast ( null ) ; <comment> <LOG> } <comment> <ect>
for ( completion <identifiersep> candidate type : types ) { if ( type . get <identifiersep> element <identifiersep> name ( ) . to <identifiersep> lower <identifiersep> case ( ) . starts <identifiersep> with ( phrase . to <identifiersep> lower <identifiersep> case ( ) ) ) candidates . add ( type ) ; } } } } } nearest <identifiersep> node = nearest <identifiersep> node . get <identifiersep> parent ( ) ; } <comment> <LOG> class <identifiersep> path class <identifiersep> path = ps . class <identifiersep> path ; if ( class <identifiersep> path != null ) { reg <identifiersep> exp <identifiersep> resource <identifiersep> filter reg <identifiersep> exp <identifiersep> resource <identifiersep> filter = new reg <identifiersep> exp <identifiersep> resource <identifiersep> filter ( pattern . compile ( <string_literal> ) , pattern . compile ( phrase + <string_literal> , pattern . case <identifiersep> insensitive ) ) ; <ect>
} else { <comment> <LOG> log ( <string_literal> + child <identifiersep> expr ) ; if ( ! no <identifiersep> compare ) { log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; testnode = get <identifiersep> parent <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; } class <identifiersep> member expr = <ect>
messages . loge ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; log ( <string_literal> ) ; ast <identifiersep> node child <identifiersep> expr = get <identifiersep> child <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> parent <identifiersep> expression ( testnode ) ) ; log ( <string_literal> + child <identifiersep> expr ) ; if ( ! no <identifiersep> compare ) { <LOG> testnode = get <identifiersep> parent <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; } class <identifiersep> member expr = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , testnode , no <identifiersep> compare ) ; if ( expr == null ) { log ( <string_literal> ) ; <ect>
log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; testnode = get <identifiersep> parent <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; } class <identifiersep> member expr = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , testnode , no <identifiersep> compare ) ; if ( expr == null ) { <LOG> } else { boolean is <identifiersep> array = expr . thisclass != null && expr . thisclass . is <identifiersep> array ( ) ; boolean is <identifiersep> simple <identifiersep> type = ( expr . ast <identifiersep> node != null ) && expr . ast <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) == ast <identifiersep> node . simple <identifiersep> type ; boolean is <identifiersep> method = expr . method != null ; boolean static <identifiersep> only = ! is <identifiersep> method && ! is <identifiersep> array && ! is <identifiersep> simple <identifiersep> type ; <ect>
default <identifiersep> list <identifiersep> model < completion <identifiersep> candidate > def <identifiersep> list <identifiersep> model = new default <identifiersep> list <identifiersep> model < > ( ) ; if ( candidates . is <identifiersep> empty ( ) ) return def <identifiersep> list <identifiersep> model ; <comment> <LOG> for ( int i = 0 ; i < candidates . size ( ) ; i ++ ) { completion <identifiersep> candidate cc = candidates . get ( i ) . with <identifiersep> regenerated <identifiersep> comp <identifiersep> string ( ) ; candidates . set ( i , cc ) ; def <identifiersep> list <identifiersep> model . add <identifiersep> element ( cc ) ; } } else { boolean ignored <identifiersep> some = false ; <ect>
+ ele . html ( ) + <string_literal> ; <comment> <LOG> } public void update <identifiersep> java <identifiersep> doc ( final completion <identifiersep> candidate candidate ) { string methodmatch = candidate . to <identifiersep> string ( ) ; if ( methodmatch . index <identifiersep> of ( ' ( ' ) != - 1 ) { methodmatch = methodmatch . substring ( 0 , methodmatch . index <identifiersep> of ( ' ( ' ) ) ; } <comment> <ect>
public library get <identifiersep> core <identifiersep> library ( ) { if ( core <identifiersep> library == null ) { file core <identifiersep> folder = platform . get <identifiersep> content <identifiersep> file ( <string_literal> ) ; core <identifiersep> library = new library ( core <identifiersep> folder ) ; <comment> <LOG> <comment> <ect>
java <identifiersep> build build = new java <identifiersep> build ( sketch ) ; log ( <string_literal> + sketch . get <identifiersep> name ( ) ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> if ( main <identifiersep> class <identifiersep> name != null ) { <comment> <ect>
if ( is <identifiersep> started ( ) && ! is <identifiersep> paused ( ) ) { return ; } <comment> <LOG> } <comment> synchronized void remove <identifiersep> breakpoint ( ) { remove <identifiersep> breakpoint ( editor . get <identifiersep> current <identifiersep> line <identifiersep> id ( ) . line <identifiersep> idx ( ) ) ; } <comment> <ect>
breakpoints . remove ( bp ) ; log ( <string_literal> + bp ) ; } } <comment> synchronized void clear <identifiersep> breakpoints ( ) { <comment> <LOG> return ; } for ( line <identifiersep> breakpoint bp : breakpoints ) { bp . remove ( ) ; } breakpoints . clear ( ) ; } <comment> <ect>
protected boolean has <identifiersep> breakpoint ( line <identifiersep> id line ) { line <identifiersep> breakpoint bp = breakpoint <identifiersep> on <identifiersep> line ( line ) ; return bp != null ; } <comment> <LOG> <comment> <ect>
virtual <identifiersep> machine vm = vm ( ) ; if ( vm != null && vm != es . virtual <identifiersep> machine ( ) ) { <comment> <LOG> if ( e instanceof vm <identifiersep> start <identifiersep> event ) { vm <identifiersep> start <identifiersep> event ( ) ; } else if ( e instanceof class <identifiersep> prepare <identifiersep> event ) { vm <identifiersep> class <identifiersep> prepare <identifiersep> event ( ( class <identifiersep> prepare <identifiersep> event ) e ) ; } else if ( e instanceof breakpoint <identifiersep> event ) { vm <identifiersep> break <identifiersep> point <identifiersep> event ( ( breakpoint <identifiersep> event ) e ) ; <ect>
log ( <string_literal> + main <identifiersep> class <identifiersep> name ) ; create <identifiersep> class <identifiersep> prepare <identifiersep> request ( main <identifiersep> class <identifiersep> name ) ; create <identifiersep> class <identifiersep> prepare <identifiersep> request ( main <identifiersep> class <identifiersep> name + <string_literal> ) ; <comment> <LOG> string name = tab . get <identifiersep> pretty <identifiersep> name ( ) ; create <identifiersep> class <identifiersep> prepare <identifiersep> request ( name ) ; create <identifiersep> class <identifiersep> prepare <identifiersep> request ( name + <string_literal> ) ; } } runtime . vm ( ) . resume ( ) ; } private void vm <identifiersep> class <identifiersep> prepare <identifiersep> event ( class <identifiersep> prepare <identifiersep> event ce ) { reference <identifiersep> type rt = ce . reference <identifiersep> type ( ) ; <ect>
main <identifiersep> class = rt ; classes . add ( rt ) ; log ( <string_literal> + rt . name ( ) ) ; started = true ; <comment> <LOG> } <comment> <ect>
stack <identifiersep> frame sf = t . frame ( 0 ) ; list < local <identifiersep> variable > locals = sf . visible <identifiersep> variables ( ) ; if ( locals . is <identifiersep> empty ( ) ) { system . out . println ( <string_literal> ) ; return ; } for ( local <identifiersep> variable lv : locals ) { <LOG> } } } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { logitse ( ex ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { log ( <string_literal> ) ; } } <comment> <ect>
protected void update <identifiersep> variable <identifiersep> inspector ( thread <identifiersep> reference t ) { if ( ! t . is <identifiersep> suspended ( ) ) { return ; } try { if ( t . frame <identifiersep> count ( ) == 0 ) { <comment> <LOG> } else { final variable <identifiersep> inspector vi = editor . variable <identifiersep> inspector ( ) ; <comment> <ect>
<comment> protected list < variable <identifiersep> node > get <identifiersep> locals ( thread <identifiersep> reference t , int depth ) { <LOG> list < variable <identifiersep> node > vars = new array <identifiersep> list < > ( ) ; try { if ( t . frame <identifiersep> count ( ) > 0 ) { stack <identifiersep> frame sf = t . frame ( 0 ) ; for ( local <identifiersep> variable lv : sf . visible <identifiersep> variables ( ) ) { <comment> <ect>
protected void print <identifiersep> this ( thread <identifiersep> reference t ) { if ( ! t . is <identifiersep> suspended ( ) ) { return ; } try { if ( t . frame <identifiersep> count ( ) == 0 ) { <comment> <LOG> } else { stack <identifiersep> frame sf = t . frame ( 0 ) ; object <identifiersep> reference this <identifiersep> object = sf . this <identifiersep> object ( ) ; if ( this <identifiersep> object != null ) { reference <identifiersep> type type = this <identifiersep> object . reference <identifiersep> type ( ) ; system . out . println ( <string_literal> + type . name ( ) + <string_literal> ) ; <ect>
stack <identifiersep> frame sf = t . frame ( 0 ) ; object <identifiersep> reference this <identifiersep> object = sf . this <identifiersep> object ( ) ; if ( this <identifiersep> object != null ) { reference <identifiersep> type type = this <identifiersep> object . reference <identifiersep> type ( ) ; system . out . println ( <string_literal> + type . name ( ) + <string_literal> ) ; for ( field f : type . visible <identifiersep> fields ( ) ) { <LOG> } } else { system . out . println ( <string_literal> ) ; } } } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { logitse ( ex ) ; } } <comment> <ect>
<comment> protected void print <identifiersep> source <identifiersep> location ( thread <identifiersep> reference t ) { try { if ( t . frame <identifiersep> count ( ) == 0 ) { <comment> <LOG> } else { location l = t . frame ( 0 ) . location ( ) ; <comment> <ect>
<comment> protected void print <identifiersep> source <identifiersep> location ( location l ) { try { <comment> <LOG> system . out . println ( get <identifiersep> source <identifiersep> line ( l . source <identifiersep> path ( ) , l . line <identifiersep> number ( ) , <number_literal> ) ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { log ( <string_literal> , ex ) ; } } <comment> <ect>
<comment> protected string get <identifiersep> source <identifiersep> line ( string file <identifiersep> path , int line <identifiersep> no , int radius ) { if ( line <identifiersep> no == - 1 ) { loge ( <string_literal> + line <identifiersep> no , null ) ; return <string_literal> ; } <LOG> file f = new file ( src <identifiersep> path + file . separator + file <identifiersep> path ) ; string output = <string_literal> ; try { buffered <identifiersep> reader r = new buffered <identifiersep> reader ( new file <identifiersep> reader ( f ) ) ; int i = 1 ; <comment> <ect>
<comment> protected void print <identifiersep> type ( reference <identifiersep> type rt ) { system . out . println ( <string_literal> + rt ) ; <LOG> try { system . out . println ( <string_literal> + rt . source <identifiersep> name ( ) ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { system . out . println ( <string_literal> ) ; } system . out . println ( <string_literal> ) ; for ( method m : rt . methods ( ) ) { <ect>
protected void print <identifiersep> type ( reference <identifiersep> type rt ) { system . out . println ( <string_literal> + rt ) ; system . out . println ( <string_literal> + rt . name ( ) ) ; try { system . out . println ( <string_literal> + rt . source <identifiersep> name ( ) ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { <LOG> } system . out . println ( <string_literal> ) ; for ( method m : rt . methods ( ) ) { system . out . println ( m . to <identifiersep> string ( ) ) ; } } <comment> <ect>
for ( int i = 0 ; i < tab . get <identifiersep> line <identifiersep> count ( ) ; i ++ ) { line <identifiersep> id old = new line <identifiersep> id ( tab . get <identifiersep> file <identifiersep> name ( ) , i ) ; line <identifiersep> id tracked = new line <identifiersep> id ( tab . get <identifiersep> file <identifiersep> name ( ) , i ) ; tracked . start <identifiersep> tracking ( editor . current <identifiersep> document ( ) ) ; runtime <identifiersep> line <identifiersep> changes . put ( old , tracked ) ; } runtime <identifiersep> tabs <identifiersep> tracked . add ( tab . get <identifiersep> file <identifiersep> name ( ) ) ; <LOG> } <comment> protected void stop <identifiersep> tracking <identifiersep> line <identifiersep> changes ( ) { <comment> <ect>
@ override public void run ( ) { try { while ( true ) { event <identifiersep> set event <identifiersep> set = event <identifiersep> queue . remove ( ) ; listener . vm <identifiersep> event ( event <identifiersep> set ) ; <LOG> } } catch ( vm <identifiersep> disconnected <identifiersep> exception e ) { messages . log ( <string_literal> ) ; } catch ( exception e ) { messages . loge ( <string_literal> , e ) ; } } } } <ect>
tree . set <identifiersep> column <identifiersep> hiding <identifiersep> allowed ( false ) ; <comment> <LOG> <comment> <ect>
return variable <identifiersep> node . class ; } return string . class ; } @ override public boolean is <identifiersep> cell <identifiersep> editable ( object o , int i ) { if ( i == 0 && o instanceof variable <identifiersep> node ) { variable <identifiersep> node var = ( variable <identifiersep> node ) o ; <LOG> for ( int type : editable <identifiersep> types ) { if ( var . get <identifiersep> type ( ) == type ) { return true ; } } } return false ; } @ override public void set <identifiersep> value <identifiersep> for ( object o , int i , object o1 ) { <ect>
var . add <identifiersep> children ( filter <identifiersep> nodes ( editor . get <identifiersep> debugger ( ) . get <identifiersep> fields ( var . get <identifiersep> value ( ) , 0 , true ) , new this <identifiersep> filter ( ) ) ) ; } @ override public void tree <identifiersep> will <identifiersep> collapse ( tree <identifiersep> expansion <identifiersep> event tee ) throws expand <identifiersep> veto <identifiersep> exception { <comment> <LOG> if ( ! expanded <identifiersep> nodes . contains ( tee . get <identifiersep> path ( ) ) ) { expanded <identifiersep> nodes . add ( tee . get <identifiersep> path ( ) ) ; } } @ override public void tree <identifiersep> collapsed ( tree <identifiersep> expansion <identifiersep> event tee ) { <comment> <ect>
for ( tree <identifiersep> path path : removal <identifiersep> list ) { expanded <identifiersep> nodes . remove ( path ) ; } <comment> <LOG> <comment> <ect>
return str . length ( ) - 1 ; } <comment> protected void edit <identifiersep> event ( document <identifiersep> event de ) { <LOG> if ( de . get <identifiersep> offset ( ) < = pos . get <identifiersep> offset ( ) ) { update <identifiersep> position ( ) ; <comment> <ect>
<comment> protected boolean attach ( reference <identifiersep> type the <identifiersep> class ) { if ( the <identifiersep> class == null || class <identifiersep> name == null || ! class <identifiersep> name . equals ( parse <identifiersep> top <identifiersep> level <identifiersep> class <identifiersep> name ( the <identifiersep> class . name ( ) ) ) ) { return false ; } <LOG> if ( ! dbg . is <identifiersep> paused ( ) ) { log ( <string_literal> ) ; return false ; } <comment> <ect>
if ( ! dbg . is <identifiersep> paused ( ) ) { log ( <string_literal> ) ; return false ; } <comment> <LOG> return false ; } try { log ( <string_literal> + the <identifiersep> class + <string_literal> + ( java <identifiersep> line . line <identifiersep> idx ( ) + 1 ) ) ; list < location > locations = the <identifiersep> class . locations <identifiersep> of <identifiersep> line ( java <identifiersep> line . line <identifiersep> idx ( ) + 1 ) ; if ( locations . is <identifiersep> empty ( ) ) { log ( <string_literal> + line + <string_literal> + java <identifiersep> line ) ; <ect>
log ( <string_literal> + line + <string_literal> ) ; return false ; } try { log ( <string_literal> + the <identifiersep> class + <string_literal> + ( java <identifiersep> line . line <identifiersep> idx ( ) + 1 ) ) ; list < location > locations = the <identifiersep> class . locations <identifiersep> of <identifiersep> line ( java <identifiersep> line . line <identifiersep> idx ( ) + 1 ) ; if ( locations . is <identifiersep> empty ( ) ) { <LOG> return false ; } <comment> <ect>
<comment> public void remove ( ) { dbg . remove <identifiersep> class <identifiersep> load <identifiersep> listener ( this ) ; <LOG> dbg . get <identifiersep> editor ( ) . remove <identifiersep> breakpointed <identifiersep> line ( line . line <identifiersep> idx ( ) ) ; if ( dbg . is <identifiersep> paused ( ) ) { <comment> <ect>
<comment> <LOG> error <identifiersep> line -= sketch . get <identifiersep> code ( error <identifiersep> file ) . get <identifiersep> preproc <identifiersep> offset ( ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
int error <identifiersep> file = find <identifiersep> error <identifiersep> file ( error <identifiersep> line ) ; <comment> <LOG> string msg = re . get <identifiersep> message ( ) ; <comment> <ect>
throw new sketch <identifiersep> exception ( msg , error <identifiersep> file , error <identifiersep> line , re . get <identifiersep> column ( ) , false ) ; } catch ( antlr . token <identifiersep> stream <identifiersep> recognition <identifiersep> exception tsre ) { <comment> <LOG> <comment> <ect>
imported <identifiersep> libraries = new array <identifiersep> list < > ( ) ; library core = mode . get <identifiersep> core <identifiersep> library ( ) ; if ( core != null ) { imported <identifiersep> libraries . add ( core ) ; class <identifiersep> path += core . get <identifiersep> class <identifiersep> path ( ) ; java <identifiersep> library <identifiersep> path += file . path <identifiersep> separator + core . get <identifiersep> native <identifiersep> path ( ) ; } <LOG> for ( string item : result . extra <identifiersep> imports ) { <comment> <ect>
if ( item . starts <identifiersep> with ( <string_literal> ) ) { <comment> <LOG> library library = mode . get <identifiersep> library ( entry ) ; <comment> <ect>
if ( pkg . equals ( item <identifiersep> pkg ) ) { found = true ; break ; } } } if ( ignorable <identifiersep> import ( entry + ' . ' ) ) { found = true ; } if ( ! found ) { <LOG> } } } <comment> <ect>
public sketch <identifiersep> exception place <identifiersep> exception ( string message , string dot <identifiersep> java <identifiersep> filename , int dot <identifiersep> java <identifiersep> line ) { int code <identifiersep> index = 0 ; <comment> <LOG> <comment> <ect>
<comment> <LOG> if ( code . get <identifiersep> preproc <identifiersep> offset ( ) < = dot <identifiersep> java <identifiersep> line ) { code <identifiersep> index = i ; <comment> <ect>
zos . close ( ) ; jar <identifiersep> list . append ( sketch . get <identifiersep> name ( ) + <string_literal> ) ; <comment> <LOG> string export <identifiersep> name = export <identifiersep> file . get <identifiersep> name ( ) ; if ( ! export <identifiersep> file . exists ( ) ) { system . err . println ( export <identifiersep> file . get <identifiersep> name ( ) + <string_literal> + <string_literal> ) ; } else if ( export <identifiersep> file . is <identifiersep> directory ( ) ) { <ect>
zos . write ( contents . get <identifiersep> bytes ( ) ) ; zos . close <identifiersep> entry ( ) ; } protected void add <identifiersep> classes ( zip <identifiersep> output <identifiersep> stream zos , file dir ) throws io <identifiersep> exception { string path = dir . get <identifiersep> absolute <identifiersep> path ( ) ; if ( ! path . ends <identifiersep> with ( <string_literal> ) && ! path . ends <identifiersep> with ( <string_literal> ) ) { path += ' / ' ; } <LOG> add <identifiersep> classes ( zos , dir , path ) ; } protected void add <identifiersep> classes ( zip <identifiersep> output <identifiersep> stream zos , file dir , string root <identifiersep> path ) throws io <identifiersep> exception { file files [ ] = dir . list <identifiersep> files ( new filename <identifiersep> filter ( ) { public boolean accept ( file dir , string name ) { return ( name . char <identifiersep> at ( 0 ) != ' . ' ) ; } } ) ; <ect>
} else { exception . set <identifiersep> message ( <string_literal> + <string_literal> + what + <string_literal> ) ; string suggestion = import <identifiersep> suggestions . get ( what ) ; if ( suggestion != null ) { system . err . println ( <string_literal> + suggestion + <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; } } } else if ( error <identifiersep> message . ends <identifiersep> with ( <string_literal> ) ) { <comment> <ect>
<comment> <LOG> return ; } private void consume <identifiersep> first ( ) throws token <identifiersep> stream <identifiersep> exception { consume ( ) ; <comment> <ect>
if ( prev != monitored ) { <comment> <LOG> prev = last <identifiersep> hidden <identifiersep> token = la ( 1 ) ; } consume ( ) ; } <comment> <ect>
public void pre ( ) { if ( serial <identifiersep> available <identifiersep> method != null && invoke <identifiersep> serial <identifiersep> available ) { invoke <identifiersep> serial <identifiersep> available = false ; try { serial <identifiersep> available <identifiersep> method . invoke ( parent , this ) ; } catch ( exception e ) { <LOG> system . err . println ( e . get <identifiersep> localized <identifiersep> message ( ) ) ; serial <identifiersep> available <identifiersep> method = null ; } } } <comment> <ect>
<comment> <LOG> system . err . println ( e . get <identifiersep> localized <identifiersep> message ( ) ) ; serial <identifiersep> event <identifiersep> method = null ; } } } invoke <identifiersep> serial <identifiersep> available = true ; } } catch ( serial <identifiersep> port <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( <string_literal> + e . get <identifiersep> port <identifiersep> name ( ) + <string_literal> + e . get <identifiersep> exception <identifiersep> type ( ) ) ; } } } <comment> <ect>
values . clear ( pin ) ; out = <string_literal> ; } else if ( value == high ) { values . set ( pin ) ; out = <string_literal> ; } else { <LOG> throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( native <identifiersep> interface . is <identifiersep> simulated ( ) ) { return ; } string fn = string . format ( <string_literal> , pin ) ; int ret = native <identifiersep> interface . write <identifiersep> file ( fn , out ) ; if ( ret < 0 ) { <ect>
return ; } <comment> <LOG> } if ( ret == - <number_literal> ) { <comment> <ect>
if ( t == null ) { return ; } t . interrupt ( ) ; try { t . join ( ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } t = null ; irq <identifiersep> threads . remove ( pin ) ; disable <identifiersep> interrupt ( pin ) ; } <comment> <ect>
} catch ( interrupted <identifiersep> exception e ) { } return true ; } string fn = string . format ( <string_literal> , pin ) ; int ret = native <identifiersep> interface . poll <identifiersep> device ( fn , timeout ) ; if ( ret < 0 ) { if ( ret == - <number_literal> ) { <comment> <LOG> } throw new runtime <identifiersep> exception ( native <identifiersep> interface . get <identifiersep> error ( ret ) ) ; } else if ( ret == 0 ) { <comment> <ect>
<comment> public void write ( float angle ) { if ( attached ( ) == false ) { <LOG> throw new runtime <identifiersep> exception ( <string_literal> ) ; } if ( angle < 0 || <number_literal> < angle ) { system . err . println ( <string_literal> ) ; throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } pulse = ( int ) ( min <identifiersep> pulse + ( angle / <number_literal> . 0 ) * ( max <identifiersep> pulse - min <identifiersep> pulse ) ) ; if ( handle < 0 ) { <ect>
throw new runtime <identifiersep> exception ( <string_literal> ) ; } <comment> <LOG> } throw new runtime <identifiersep> exception ( native <identifiersep> interface . get <identifiersep> error ( ret ) ) ; } } <comment> <ect>
<comment> public void begin <identifiersep> transmission ( int slave ) { <comment> <LOG> throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } this . slave = slave ; transmitting = true ; out = null ; } <comment> <ect>
return in ; } int ret = native <identifiersep> interface . transfer <identifiersep> i2c ( handle , slave , out , in ) ; transmitting = false ; out = null ; if ( ret < 0 ) { if ( ret == - <number_literal> ) { <comment> <LOG> } throw new runtime <identifiersep> exception ( native <identifiersep> interface . get <identifiersep> error ( ret ) ) ; } return in ; } <comment> <ect>
return ; } <comment> <LOG> } <comment> <ect>
<comment> <LOG> } <comment> <ect>
<comment> public byte [ ] transfer ( int out ) { if ( out < - <number_literal> || <number_literal> < out ) { <LOG> throw new runtime <identifiersep> exception ( <string_literal> ) ; } byte [ ] tmp = new byte [ 1 ] ; tmp [ 0 ] = ( byte ) out ; return transfer ( tmp ) ; } <comment> <ect>
<string_literal> ) ; } else if ( text <identifiersep> mode != shape ) { if ( text <identifiersep> font . is <identifiersep> stream ( ) ) { throw new runtime <identifiersep> exception ( <string_literal> + <string_literal> ) ; } else if ( mapper . get <identifiersep> aliases ( ) . get ( text <identifiersep> font . get <identifiersep> name ( ) ) == null ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; <comment> <LOG> stop ( ) ; return ; } synchronized ( buffer <identifiersep> lock ) { int free <identifiersep> back = buffer . length - buffer <identifiersep> last ; if ( read <identifiersep> count > free <identifiersep> back ) { <comment> <ect>
if ( buffer [ k ] == what ) { found = k ; break ; } } if ( found == - 1 ) return 0 ; int length = found - buffer <identifiersep> index + 1 ; if ( length > byte <identifiersep> buffer . length ) { <LOG> <string_literal> + length + <string_literal> + interesting ) ; return - 1 ; } <comment> <ect>
if ( e instanceof invocation <identifiersep> target <identifiersep> exception && e . get <identifiersep> cause ( ) != null ) { cause = e . get <identifiersep> cause ( ) ; } cause . print <identifiersep> stack <identifiersep> trace ( ) ; server <identifiersep> event <identifiersep> method = null ; } } } } catch ( socket <identifiersep> exception e ) { <comment> <LOG> thread = null ; } catch ( io <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
dispose ( ) ; } public void end <identifiersep> raw ( ) { system . out . println ( <string_literal> ) ; super . end <identifiersep> raw ( ) ; system . out . println ( <string_literal> ) ; dispose ( ) ; <LOG> <comment> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> } <comment> <ect>
<comment> void finished ( ) { date timeout = short <identifiersep> timeout ( ) lock . lock ( ) try { <LOG> while ( ! threads . is <identifiersep> empty ( ) ) { if ( ! threads <identifiersep> changed . await <identifiersep> until ( timeout ) ) { failed ( new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ) break ; } } threads . each { thread - > thread . interrupt ( ) <ect>
this . owner = owner this . action = action this . lock = lock this . state <identifiersep> changed = lock . new <identifiersep> condition ( ) } @ override void start ( ) { <LOG> lock . lock ( ) try { owner . on <identifiersep> thread <identifiersep> start ( this ) state <identifiersep> changed . signal <identifiersep> all ( ) } finally { lock . unlock ( ) <ect>
try { log . info ( <string_literal> ) while ( ! complete ) { if ( ! state <identifiersep> changed . await <identifiersep> until ( timeout ) ) { interrupt ( ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) } } <LOG> } finally { lock . unlock ( ) } } @ override void run ( ) { throwable failure = null try { <ect>
assert <identifiersep> nested <identifiersep> task <identifiersep> output <identifiersep> tracked ( ) } def <string_literal> ( ) { when : build <identifiersep> file < < <string_literal> <string_literal> <LOG> } } <string_literal> <string_literal> t <string_literal> - d <string_literal> <ect>
when : write <identifiersep> to <identifiersep> file <identifiersep> multiple <identifiersep> times ( instant , testfile ) and : def timestamp <identifiersep> for <identifiersep> last <identifiersep> change = system . nano <identifiersep> time ( ) logger . log ( <string_literal> ) testfile < < <string_literal> <LOG> then : wait <identifiersep> for . done math . round ( ( system . nano <identifiersep> time ( ) - timestamp <identifiersep> for <identifiersep> last <identifiersep> change ) / 1000000l ) >= quiet <identifiersep> period continuous <identifiersep> execution <identifiersep> gate . wait <identifiersep> for <identifiersep> open ( ) cleanup : w . stop ( ) <ect>
w . stop ( ) } private void write <identifiersep> to <identifiersep> file <identifiersep> multiple <identifiersep> times ( instant , testfile ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { instant . assert <identifiersep> not <identifiersep> reached ( 'done' ) logger . log ( <string_literal> ) testfile < < <string_literal> <LOG> sleep ( <number_literal> ) } } class logging <identifiersep> file <identifiersep> watch <identifiersep> event <identifiersep> listener implements file <identifiersep> watcher <identifiersep> event <identifiersep> listener { @ override void on <identifiersep> change ( file <identifiersep> watcher <identifiersep> event event ) { logger . log ( event ) } @ override <ect>
@ option ( option = <string_literal> , description = <string_literal> ) public void set <identifiersep> prop3 ( string prop3 ) { this . prop3 = prop3 ; } @ task <identifiersep> action public void render <identifiersep> option <identifiersep> value ( ) { system . out . println ( <string_literal> + prop1 ) ; <LOG> system . out . println ( <string_literal> + prop3 ) ; } } <string_literal> <string_literal> <ect>
this . my <identifiersep> prop = my <identifiersep> prop ; } @ option <identifiersep> values ( <string_literal> ) public list < string > get <identifiersep> available <identifiersep> my <identifiersep> prop <identifiersep> values ( ) { return my <identifiersep> prop <identifiersep> values ; } @ task <identifiersep> action public void render <identifiersep> option <identifiersep> value ( ) { <LOG> } } <string_literal> <string_literal> <ect>
public void execute ( worker <identifiersep> process <identifiersep> context worker <identifiersep> process <identifiersep> context ) { final count <identifiersep> down <identifiersep> latch latch = new count <identifiersep> down <identifiersep> latch ( 1 ) ; new thread ( new runnable ( ) { public void run ( ) { latch . count <identifiersep> down ( ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> } } } ) . start ( ) ; try { latch . await ( ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } } } <ect>
public string convert ( string param1 , long param2 ) { if ( param1 == null ) { return null ; } return string . format ( <string_literal> , param1 , param2 ) ; } @ override public void do <identifiersep> something ( ) { <LOG> } } <ect>
for ( task dep <identifiersep> task : dep <identifiersep> tasks ) { names . add ( dep <identifiersep> task . get <identifiersep> name ( ) ) ; } boolean matches = matcher . matches ( names ) ; if ( ! matches ) { string <identifiersep> description description = new string <identifiersep> description ( ) ; matcher . describe <identifiersep> to ( description ) ; <LOG> } return matches ; } public void describe <identifiersep> to ( description description ) { description . append <identifiersep> text ( <string_literal> ) . append <identifiersep> description <identifiersep> of ( matcher ) ; } } ; } } <ect>
file <identifiersep> collection actual = ( file <identifiersep> collection ) o ; list < ? extends file <identifiersep> collection > actual <identifiersep> collections = unpack ( actual ) ; list < ? extends file <identifiersep> collection > expected <identifiersep> collections = unpack ( expected ) ; boolean equals = actual <identifiersep> collections . equals ( expected <identifiersep> collections ) ; if ( ! equals ) { system . out . println ( <string_literal> + expected <identifiersep> collections ) ; <LOG> } return equals ; } private list < ? extends file <identifiersep> collection > unpack ( file <identifiersep> collection expected ) { if ( expected instanceof union <identifiersep> file <identifiersep> collection ) { union <identifiersep> file <identifiersep> collection collection = ( union <identifiersep> file <identifiersep> collection ) expected ; return new array <identifiersep> list < file <identifiersep> collection > ( collection . get <identifiersep> sources ( ) ) ; } if ( expected instanceof default <identifiersep> configurable <identifiersep> file <identifiersep> collection ) { <ect>
lock . lock ( ) ; try { active . remove ( thread ) ; matcher < ? extends throwable > matcher = expected <identifiersep> failure . get ( ) ; if ( failure != null ) { if ( matcher != null && matcher . matches ( failure ) ) { <LOG> } else { logger . error ( string . format ( <string_literal> , thread ) , failure ) ; failures . add ( failure ) ; } } else { if ( matcher != null ) { string message = string . format ( <string_literal> , thread ) ; <ect>
} else { if ( matcher != null ) { string message = string . format ( <string_literal> , thread ) ; logger . error ( message ) ; failures . add ( new assertion <identifiersep> failed <identifiersep> error ( message ) ) ; } else { <LOG> } } condition . signal <identifiersep> all ( ) ; } finally { lock . unlock ( ) ; } } <comment> <ect>
boolean signaled = condition . await <identifiersep> until ( expiry ) ; if ( ! signaled ) { failures . add ( new runtime <identifiersep> exception ( <string_literal> ) ) ; break ; } } } catch ( interrupted <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } <LOG> if ( ! failures . is <identifiersep> empty ( ) ) { throwable failure = failures . get ( 0 ) ; failures . clear ( ) ; if ( failure instanceof runtime <identifiersep> exception ) { throw ( runtime <identifiersep> exception ) failure ; } if ( failure instanceof error ) { <ect>
clock <identifiersep> tick ) ) ; } if ( clock <identifiersep> tick . is <identifiersep> immediately <identifiersep> after ( current <identifiersep> tick ) ) { current <identifiersep> tick = clock <identifiersep> tick ; synching . clear ( ) ; } } finally { lock . unlock ( ) ; } <LOG> } <comment> <ect>
public build <identifiersep> logger ( logger logger , styled <identifiersep> text <identifiersep> output <identifiersep> factory text <identifiersep> output <identifiersep> factory , start <identifiersep> parameter start <identifiersep> parameter , build <identifiersep> request <identifiersep> meta <identifiersep> data request <identifiersep> meta <identifiersep> data , build <identifiersep> started <identifiersep> time build <identifiersep> started <identifiersep> time , clock clock ) { this . logger = logger ; result <identifiersep> loggers . add ( new build <identifiersep> exception <identifiersep> reporter ( text <identifiersep> output <identifiersep> factory , start <identifiersep> parameter , request <identifiersep> meta <identifiersep> data . get <identifiersep> client ( ) ) ) ; result <identifiersep> loggers . add ( new build <identifiersep> result <identifiersep> logger ( text <identifiersep> output <identifiersep> factory , build <identifiersep> started <identifiersep> time , clock , new terse <identifiersep> pretty <identifiersep> duration <identifiersep> formatter ( ) ) ) ; } public void build <identifiersep> started ( gradle gradle ) { start <identifiersep> parameter start <identifiersep> parameter = gradle . get <identifiersep> start <identifiersep> parameter ( ) ; <LOG> logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> current <identifiersep> dir ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> settings <identifiersep> file ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> build <identifiersep> file ( ) ) ; } } public void settings <identifiersep> evaluated ( settings settings ) { <ect>
result <identifiersep> loggers . add ( new build <identifiersep> result <identifiersep> logger ( text <identifiersep> output <identifiersep> factory , build <identifiersep> started <identifiersep> time , clock , new terse <identifiersep> pretty <identifiersep> duration <identifiersep> formatter ( ) ) ) ; } public void build <identifiersep> started ( gradle gradle ) { start <identifiersep> parameter start <identifiersep> parameter = gradle . get <identifiersep> start <identifiersep> parameter ( ) ; logger . info ( <string_literal> ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( ) ) ; <LOG> logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> settings <identifiersep> file ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> build <identifiersep> file ( ) ) ; } } public void settings <identifiersep> evaluated ( settings settings ) { settings <identifiersep> internal settings <identifiersep> internal = ( settings <identifiersep> internal ) settings ; logger . info ( <string_literal> , <ect>
start <identifiersep> parameter start <identifiersep> parameter = gradle . get <identifiersep> start <identifiersep> parameter ( ) ; logger . info ( <string_literal> ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> current <identifiersep> dir ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> settings <identifiersep> file ( ) ) ; <LOG> } } public void settings <identifiersep> evaluated ( settings settings ) { settings <identifiersep> internal settings <identifiersep> internal = ( settings <identifiersep> internal ) settings ; logger . info ( <string_literal> , settings <identifiersep> internal . get <identifiersep> settings <identifiersep> script ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; <ect>
project <identifiersep> internal project <identifiersep> internal = ( project <identifiersep> internal ) gradle . get <identifiersep> root <identifiersep> project ( ) ; logger . info ( <string_literal> , project <identifiersep> internal . get <identifiersep> build <identifiersep> script <identifiersep> source ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; logger . info ( <string_literal> , project <identifiersep> internal . get <identifiersep> allprojects ( ) ) ; } } public void projects <identifiersep> evaluated ( gradle gradle ) { <LOG> } public void graph <identifiersep> populated ( task <identifiersep> execution <identifiersep> graph graph ) { logger . info ( <string_literal> , graph . get <identifiersep> all <identifiersep> tasks ( ) ) ; } } public void build <identifiersep> finished ( build <identifiersep> result result ) { for ( build <identifiersep> listener logger : result <identifiersep> loggers ) { logger . build <identifiersep> finished ( result ) ; <ect>
set <identifiersep> current <identifiersep> build <identifiersep> operation ( new <identifiersep> operation ) ; try { listener . started ( descriptor , new operation <identifiersep> start <identifiersep> event ( new <identifiersep> operation . get <identifiersep> start <identifiersep> time ( ) ) ) ; progress <identifiersep> logger progress <identifiersep> logger = create <identifiersep> progress <identifiersep> logger ( new <identifiersep> operation ) ; throwable failure = null ; default <identifiersep> build <identifiersep> operation <identifiersep> context context = new default <identifiersep> build <identifiersep> operation <identifiersep> context ( ) ; <LOG> try { worker . execute ( build <identifiersep> operation , context ) ; } catch ( throwable t ) { context . thrown ( t ) ; failure = t ; } logger . debug ( <string_literal> , descriptor . get <identifiersep> display <identifiersep> name ( ) ) ; <ect>
assert <identifiersep> parent <identifiersep> running ( <string_literal> , descriptor , parent ) ; if ( failure != null ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( failure , true ) ; } } finally { set <identifiersep> current <identifiersep> build <identifiersep> operation ( parent <identifiersep> operation ) ; new <identifiersep> operation . set <identifiersep> running ( false ) ; <LOG> } } private void fail <identifiersep> if <identifiersep> in <identifiersep> resource <identifiersep> lock <identifiersep> transform ( ) { if ( resource <identifiersep> lock <identifiersep> coordination <identifiersep> service . get <identifiersep> current ( ) != null ) { throw new resource <identifiersep> deadlock <identifiersep> exception ( <string_literal> ) ; } } private build <identifiersep> operation <identifiersep> descriptor create <identifiersep> descriptor ( build <identifiersep> operation <identifiersep> descriptor . builder descriptor <identifiersep> builder , build <identifiersep> operation <identifiersep> state parent ) { operation <identifiersep> identifier id = new operation <identifiersep> identifier ( build <identifiersep> operation <identifiersep> id <identifiersep> factory . next <identifiersep> id ( ) ) ; build <identifiersep> operation <identifiersep> state current = maybe <identifiersep> start <identifiersep> unmanaged <identifiersep> thread <identifiersep> operation ( parent ) ; <ect>
public file <identifiersep> visit <identifiersep> result pre <identifiersep> visit <identifiersep> directory ( path path , basic <identifiersep> file <identifiersep> attributes attrs ) throws io <identifiersep> exception { if ( ! path . equals ( dir <identifiersep> path ) ) { if ( delta . should <identifiersep> watch ( path . to <identifiersep> file ( ) ) ) { watch <identifiersep> dir ( path ) ; return file <identifiersep> visit <identifiersep> result . continue ; } else { <LOG> return file <identifiersep> visit <identifiersep> result . skip <identifiersep> subtree ; } } else { return file <identifiersep> visit <identifiersep> result . continue ; } } } ) ; } log . debug ( <string_literal> , dir ) ; } log . debug ( <string_literal> , file <identifiersep> system <identifiersep> subset ) ; <ect>
log . debug ( <string_literal> , path ) ; return file <identifiersep> visit <identifiersep> result . skip <identifiersep> subtree ; } } else { return file <identifiersep> visit <identifiersep> result . continue ; } } } ) ; } log . debug ( <string_literal> , dir ) ; } <LOG> } finally { lock . unlock ( ) ; } } private iterable < file > get <identifiersep> current <identifiersep> watch <identifiersep> points ( ) { list < file > current <identifiersep> watch <identifiersep> points = new linked <identifiersep> list < file > ( ) ; for ( map . entry < path , watch <identifiersep> key > entry : watch <identifiersep> keys . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> value ( ) . is <identifiersep> valid ( ) ) { <ect>
if ( entry . get <identifiersep> value ( ) . is <identifiersep> valid ( ) ) { current <identifiersep> watch <identifiersep> points . add ( entry . get <identifiersep> key ( ) . to <identifiersep> file ( ) ) ; } } return current <identifiersep> watch <identifiersep> points ; } protected void watch <identifiersep> dir ( path dir ) throws io <identifiersep> exception { log . debug ( <string_literal> , dir ) ; if ( thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ) { <LOG> } <comment> <ect>
while ( retry <identifiersep> count ++ < <number_literal> ) { try { watch <identifiersep> key watch <identifiersep> key = dir . register ( watch <identifiersep> service , watch <identifiersep> kinds , watch <identifiersep> modifiers ) ; watch <identifiersep> keys . put ( dir , watch <identifiersep> key ) ; return ; } catch ( io <identifiersep> exception e ) { <LOG> last <identifiersep> exception = e ; if ( e instanceof no <identifiersep> such <identifiersep> file <identifiersep> exception ) { log . debug ( <string_literal> ) ; return ; } if ( e instanceof file <identifiersep> system <identifiersep> exception && e . get <identifiersep> message ( ) != null && e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <comment> <ect>
last <identifiersep> exception = e ; if ( e instanceof no <identifiersep> such <identifiersep> file <identifiersep> exception ) { log . debug ( <string_literal> ) ; return ; } if ( e instanceof file <identifiersep> system <identifiersep> exception && e . get <identifiersep> message ( ) != null && e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <comment> <LOG> continue ; } <comment> <ect>
<comment> <LOG> throw last <identifiersep> exception ; } @ override public void on <identifiersep> change ( file <identifiersep> watcher watcher , file <identifiersep> watcher <identifiersep> event event ) { lock . lock ( ) ; try { if ( event . get <identifiersep> type ( ) . equals ( file <identifiersep> watcher <identifiersep> event . type . undefined ) || event . get <identifiersep> file ( ) == null ) { <ect>
} catch ( runtime <identifiersep> exception e ) { if ( throwables . get <identifiersep> root <identifiersep> cause ( e ) instanceof interrupted <identifiersep> exception ) { <comment> <LOG> } } private void maybe <identifiersep> fire ( file <identifiersep> watcher watcher , file <identifiersep> watcher <identifiersep> event event ) { if ( watch <identifiersep> points <identifiersep> registry . should <identifiersep> fire ( event . get <identifiersep> file ( ) ) ) { log . debug ( <string_literal> , event ) ; deliver <identifiersep> event <identifiersep> to <identifiersep> delegate ( watcher , event ) ; } else { log . debug ( <string_literal> , event ) ; <ect>
log . debug ( <string_literal> ) ; } } private void maybe <identifiersep> fire ( file <identifiersep> watcher watcher , file <identifiersep> watcher <identifiersep> event event ) { if ( watch <identifiersep> points <identifiersep> registry . should <identifiersep> fire ( event . get <identifiersep> file ( ) ) ) { log . debug ( <string_literal> , event ) ; deliver <identifiersep> event <identifiersep> to <identifiersep> delegate ( watcher , event ) ; } else { <LOG> } } private void maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( file <identifiersep> watcher watcher , file dir ) throws io <identifiersep> exception { log . debug ( <string_literal> , dir ) ; if ( is <identifiersep> stop <identifiersep> requested ( watcher ) ) { log . debug ( <string_literal> ) ; return ; } if ( ! watch <identifiersep> points <identifiersep> registry . should <identifiersep> watch ( dir ) ) { <ect>
deliver <identifiersep> event <identifiersep> to <identifiersep> delegate ( watcher , event ) ; } else { log . debug ( <string_literal> , event ) ; } } private void maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( file <identifiersep> watcher watcher , file dir ) throws io <identifiersep> exception { log . debug ( <string_literal> , dir ) ; if ( is <identifiersep> stop <identifiersep> requested ( watcher ) ) { <LOG> return ; } if ( ! watch <identifiersep> points <identifiersep> registry . should <identifiersep> watch ( dir ) ) { log . debug ( <string_literal> , dir ) ; return ; } if ( dir . exists ( ) ) { if ( ! file <identifiersep> tree <identifiersep> watching <identifiersep> supported ) { <ect>
if ( ! file <identifiersep> tree <identifiersep> watching <identifiersep> supported ) { watch <identifiersep> dir ( dir . to <identifiersep> path ( ) ) ; } file [ ] contents = dir . list <identifiersep> files ( ) ; if ( contents != null ) { for ( file file : contents ) { if ( is <identifiersep> stop <identifiersep> requested ( watcher ) ) { <LOG> return ; } maybe <identifiersep> fire ( watcher , file <identifiersep> watcher <identifiersep> event . create ( file ) ) ; if ( file . is <identifiersep> directory ( ) ) { maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( watcher , file ) ; } } } } log . debug ( <string_literal> , dir ) ; } private boolean is <identifiersep> stop <identifiersep> requested ( file <identifiersep> watcher watcher ) { <ect>
while ( is <identifiersep> running ( ) ) { try { list < file <identifiersep> watcher <identifiersep> event > events = poller . take <identifiersep> events ( ) ; if ( events != null ) { deliver <identifiersep> events ( events ) ; } } catch ( closed <identifiersep> watch <identifiersep> service <identifiersep> exception e ) { <LOG> stop ( ) ; } } } private void deliver <identifiersep> events ( list < file <identifiersep> watcher <identifiersep> event > events ) { for ( file <identifiersep> watcher <identifiersep> event event : events ) { if ( ! is <identifiersep> running ( ) ) { logger . debug ( <string_literal> ) ; <ect>
private void deliver <identifiersep> events ( list < file <identifiersep> watcher <identifiersep> event > events ) { for ( file <identifiersep> watcher <identifiersep> event event : events ) { if ( ! is <identifiersep> running ( ) ) { logger . debug ( <string_literal> ) ; break ; } <LOG> } watch <identifiersep> service <identifiersep> registrar . on <identifiersep> change ( file <identifiersep> watcher , event ) ; } } private boolean is <identifiersep> running ( ) { return running . get ( ) && ! thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ; } private void stop ( ) { if ( stopped . compare <identifiersep> and <identifiersep> set ( false , true ) ) { if ( running . compare <identifiersep> and <identifiersep> set ( true , false ) ) { <ect>
private void interrupt <identifiersep> poller <identifiersep> thread ( ) { soft <identifiersep> reference < thread > thread <identifiersep> soft <identifiersep> reference = poller <identifiersep> thread <identifiersep> reference . get <identifiersep> and <identifiersep> set ( null ) ; if ( thread <identifiersep> soft <identifiersep> reference != null ) { thread poller <identifiersep> thread = thread <identifiersep> soft <identifiersep> reference . get ( ) ; if ( poller <identifiersep> thread != null && poller <identifiersep> thread != thread . current <identifiersep> thread ( ) ) { <comment> <LOG> poller <identifiersep> thread . interrupt ( ) ; } } } } <ect>
public single <identifiersep> fire <identifiersep> pending <identifiersep> changes <identifiersep> listener ( pending <identifiersep> changes <identifiersep> listener delegate ) { this . delegate = delegate ; } @ override public void on <identifiersep> pending <identifiersep> changes ( ) { <comment> <LOG> delegate . on <identifiersep> pending <identifiersep> changes ( ) ; seen <identifiersep> changes = true ; } else { logger . debug ( <string_literal> ) ; } } } <ect>
private final task <identifiersep> executer executer ; public execute <identifiersep> at <identifiersep> most <identifiersep> once <identifiersep> task <identifiersep> executer ( task <identifiersep> executer executer ) { this . executer = executer ; } public void execute ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { if ( state . get <identifiersep> executed ( ) ) { return ; } <LOG> try { executer . execute ( task , state , context ) ; } finally { logger . debug ( <string_literal> , task ) ; } } } <ect>
this . task <identifiersep> output <identifiersep> changes <identifiersep> listener = task <identifiersep> output <identifiersep> changes <identifiersep> listener ; this . build <identifiersep> cache <identifiersep> command <identifiersep> factory = build <identifiersep> cache <identifiersep> command <identifiersep> factory ; this . build <identifiersep> cache = build <identifiersep> cache ; this . delegate = delegate ; } @ override public void execute ( final task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { <LOG> task <identifiersep> properties task <identifiersep> properties = context . get <identifiersep> task <identifiersep> properties ( ) ; task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key cache <identifiersep> key = context . get <identifiersep> build <identifiersep> cache <identifiersep> key ( ) ; boolean task <identifiersep> output <identifiersep> caching <identifiersep> enabled = state . get <identifiersep> task <identifiersep> output <identifiersep> caching ( ) . is <identifiersep> enabled ( ) ; sorted <identifiersep> set < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > output <identifiersep> properties = null ; if ( task <identifiersep> output <identifiersep> caching <identifiersep> enabled ) { if ( task . is <identifiersep> has <identifiersep> custom <identifiersep> actions ( ) ) { <ect>
output <identifiersep> type type = output <identifiersep> property . get <identifiersep> output <identifiersep> type ( ) ; for ( file output : output <identifiersep> property . get <identifiersep> property <identifiersep> files ( ) ) { ensure <identifiersep> output ( output <identifiersep> property , output , type ) ; } } executer . execute ( task , state , context ) ; } private static void ensure <identifiersep> output ( task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec output <identifiersep> property , file output , output <identifiersep> type type ) { if ( output == null ) { <LOG> return ; } switch ( type ) { case directory : logger . debug ( <string_literal> , output <identifiersep> property , output ) ; mkdirs ( output ) ; break ; <ect>
switch ( type ) { case directory : logger . debug ( <string_literal> , output <identifiersep> property , output ) ; mkdirs ( output ) ; break ; case file : <LOG> mkdirs ( output . get <identifiersep> parent <identifiersep> file ( ) ) ; break ; default : throw new assertion <identifiersep> error ( ) ; } } } <ect>
task <identifiersep> properties task <identifiersep> properties = default <identifiersep> task <identifiersep> properties . resolve ( property <identifiersep> walker , resolver , task ) ; context . set <identifiersep> task <identifiersep> properties ( task <identifiersep> properties ) ; task <identifiersep> artifact <identifiersep> state task <identifiersep> artifact <identifiersep> state = repository . get <identifiersep> state <identifiersep> for ( task , task <identifiersep> properties ) ; task <identifiersep> outputs <identifiersep> internal outputs = task . get <identifiersep> outputs ( ) ; context . set <identifiersep> task <identifiersep> artifact <identifiersep> state ( task <identifiersep> artifact <identifiersep> state ) ; outputs . set <identifiersep> history ( task <identifiersep> artifact <identifiersep> state . get <identifiersep> execution <identifiersep> history ( ) ) ; <LOG> try { executer . execute ( task , state , context ) ; } finally { outputs . set <identifiersep> history ( null ) ; context . set <identifiersep> task <identifiersep> artifact <identifiersep> state ( null ) ; context . set <identifiersep> task <identifiersep> properties ( null ) ; <ect>
task <identifiersep> output <identifiersep> changes <identifiersep> listener . before <identifiersep> task <identifiersep> output <identifiersep> changed ( ) ; build <identifiersep> operation <identifiersep> executor . run ( new runnable <identifiersep> build <identifiersep> operation ( ) { @ override public void run ( build <identifiersep> operation <identifiersep> context context ) { for ( file file : files <identifiersep> to <identifiersep> delete ) { if ( file . exists ( ) ) { <LOG> g <identifiersep> file <identifiersep> utils . force <identifiersep> delete ( file ) ; } } } @ override public build <identifiersep> operation <identifiersep> descriptor . builder description ( ) { return build <identifiersep> operation <identifiersep> descriptor . display <identifiersep> name ( clean <identifiersep> stale <identifiersep> outputs <identifiersep> display <identifiersep> name ) . progress <identifiersep> display <identifiersep> name ( <string_literal> ) ; <ect>
if ( output <identifiersep> files . is <identifiersep> empty ( ) ) { state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . no <identifiersep> source ) ; logger . info ( <string_literal> , task ) ; } else { boolean cleanup <identifiersep> directories = execution <identifiersep> history . get <identifiersep> overlapping <identifiersep> outputs ( ) == null ; if ( ! cleanup <identifiersep> directories ) { <LOG> } task <identifiersep> output <identifiersep> changes <identifiersep> listener . before <identifiersep> task <identifiersep> output <identifiersep> changed ( ) ; boolean deleted <identifiersep> files = false ; for ( file file : output <identifiersep> files ) { if ( file . exists ( ) && build <identifiersep> output <identifiersep> cleanup <identifiersep> registry . is <identifiersep> output <identifiersep> owned <identifiersep> by <identifiersep> build ( file ) ) { if ( ! cleanup <identifiersep> directories && file . is <identifiersep> directory ( ) ) { <ect>
continue ; } if ( debug <identifiersep> enabled ) { logger . debug ( <string_literal> , file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } g <identifiersep> file <identifiersep> utils . force <identifiersep> delete ( file ) ; deleted <identifiersep> files = true ; } } if ( deleted <identifiersep> files ) { <LOG> state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . executed ) ; } else { state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . no <identifiersep> source ) ; } task <identifiersep> artifact <identifiersep> state . snapshot <identifiersep> after <identifiersep> task <identifiersep> execution ( null , build <identifiersep> invocation <identifiersep> scope <identifiersep> id . get <identifiersep> id ( ) , context ) ; } task <identifiersep> inputs <identifiersep> listener . on <identifiersep> execute ( task , cast . cast ( file <identifiersep> collection <identifiersep> internal . class , source <identifiersep> files ) ) ; return ; <ect>
public class skip <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> task <identifiersep> executer implements task <identifiersep> executer { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( skip <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> task <identifiersep> executer . class ) ; private final task <identifiersep> executer executer ; public skip <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> task <identifiersep> executer ( task <identifiersep> executer executer ) { this . executer = executer ; } public void execute ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { <LOG> task <identifiersep> artifact <identifiersep> state task <identifiersep> artifact <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; list < string > messages = new array <identifiersep> list < string > ( task <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> state . max <identifiersep> out <identifiersep> of <identifiersep> date <identifiersep> messages ) ; if ( task <identifiersep> artifact <identifiersep> state . is <identifiersep> up <identifiersep> to <identifiersep> date ( messages ) ) { logger . info ( <string_literal> , task ) ; state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . up <identifiersep> to <identifiersep> date ) ; context . set <identifiersep> origin <identifiersep> execution <identifiersep> metadata ( task <identifiersep> artifact <identifiersep> state . get <identifiersep> execution <identifiersep> history ( ) . get <identifiersep> origin <identifiersep> execution <identifiersep> metadata ( ) ) ; <ect>
) ; } context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) . snapshot <identifiersep> after <identifiersep> task <identifiersep> execution ( failure , build <identifiersep> invocation <identifiersep> scope <identifiersep> id . get <identifiersep> id ( ) , context ) ; } finally { state . set <identifiersep> executing ( false ) ; listener . after <identifiersep> actions ( task ) ; } } private gradle <identifiersep> exception execute <identifiersep> actions ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { <LOG> final list < context <identifiersep> aware <identifiersep> task <identifiersep> action > actions = new array <identifiersep> list < context <identifiersep> aware <identifiersep> task <identifiersep> action > ( task . get <identifiersep> task <identifiersep> actions ( ) ) ; for ( context <identifiersep> aware <identifiersep> task <identifiersep> action action : actions ) { state . set <identifiersep> did <identifiersep> work ( true ) ; task . get <identifiersep> standard <identifiersep> output <identifiersep> capture ( ) . start ( ) ; try { execute <identifiersep> action ( action . get <identifiersep> display <identifiersep> name ( ) , task , action , context ) ; <ect>
try { execute <identifiersep> action ( action . get <identifiersep> display <identifiersep> name ( ) , task , action , context ) ; } catch ( stop <identifiersep> action <identifiersep> exception e ) { <comment> <LOG> break ; } catch ( throwable t ) { return new task <identifiersep> execution <identifiersep> exception ( task , t ) ; } finally { task . get <identifiersep> standard <identifiersep> output <identifiersep> capture ( ) . stop ( ) ; } } return null ; <ect>
while ( it . has <identifiersep> next ( ) ) { object class <identifiersep> info = it . next ( ) ; if ( class <identifiersep> info != null ) { class clazz = ( class ) clazz <identifiersep> field . get ( class <identifiersep> info ) ; remove <identifiersep> from <identifiersep> global <identifiersep> class <identifiersep> value . invoke ( global <identifiersep> class <identifiersep> value , clazz ) ; <LOG> } } } } catch ( exception e ) { throw new gradle <identifiersep> exception ( <string_literal> + leaking <identifiersep> loader , e ) ; } } @ override public void discard <identifiersep> types <identifiersep> from ( class <identifiersep> loader class <identifiersep> loader ) { if ( class <identifiersep> loader == leaking <identifiersep> loader ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; <ect>
@ override public uri get <identifiersep> source <identifiersep> uri ( ) { return script <identifiersep> resource . get <identifiersep> uri ( ) ; } @ override public class <identifiersep> loader get <identifiersep> class <identifiersep> loader ( ) { if ( ! class <identifiersep> loader <identifiersep> scope . is <identifiersep> locked ( ) ) { <LOG> } return class <identifiersep> loader <identifiersep> scope . get <identifiersep> local <identifiersep> class <identifiersep> loader ( ) ; } @ override public dynamic <identifiersep> object get <identifiersep> as <identifiersep> dynamic <identifiersep> object ( ) { if ( dynamic <identifiersep> object == null ) { dynamic <identifiersep> object = new bean <identifiersep> dynamic <identifiersep> object ( this ) ; } return dynamic <identifiersep> object ; <ect>
import org . slf4j . logger <identifiersep> factory ; import java . io . file ; public class rebuild <identifiersep> incremental <identifiersep> task <identifiersep> inputs extends stateful <identifiersep> incremental <identifiersep> task <identifiersep> inputs { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( rebuild <identifiersep> incremental <identifiersep> task <identifiersep> inputs . class ) ; private final file <identifiersep> collection input <identifiersep> files ; public rebuild <identifiersep> incremental <identifiersep> task <identifiersep> inputs ( task task , task <identifiersep> properties task <identifiersep> properties ) { <LOG> this . input <identifiersep> files = task <identifiersep> properties . get <identifiersep> input <identifiersep> files ( ) ; } public boolean is <identifiersep> incremental ( ) { return false ; } public void do <identifiersep> out <identifiersep> of <identifiersep> date ( action < ? super input <identifiersep> file <identifiersep> details > out <identifiersep> of <identifiersep> date <identifiersep> action ) { for ( file file : input <identifiersep> files ) { out <identifiersep> of <identifiersep> date <identifiersep> action . execute ( new rebuild <identifiersep> input <identifiersep> file ( file ) ) ; <ect>
class < ? extends task <identifiersep> internal > task <identifiersep> class = task . get <identifiersep> class ( ) ; list < context <identifiersep> aware <identifiersep> task <identifiersep> action > task <identifiersep> actions = task . get <identifiersep> task <identifiersep> actions ( ) ; implementation <identifiersep> snapshot task <identifiersep> implementation = new implementation <identifiersep> snapshot ( task <identifiersep> class . get <identifiersep> name ( ) , class <identifiersep> loader <identifiersep> hierarchy <identifiersep> hasher . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( task <identifiersep> class . get <identifiersep> class <identifiersep> loader ( ) ) ) ; immutable <identifiersep> list < implementation <identifiersep> snapshot > task <identifiersep> action <identifiersep> implementations = collect <identifiersep> action <identifiersep> implementations ( task <identifiersep> actions , class <identifiersep> loader <identifiersep> hierarchy <identifiersep> hasher ) ; logger . debug ( <string_literal> , task , task <identifiersep> implementation ) ; <LOG> } immutable <identifiersep> sorted <identifiersep> map < string , value <identifiersep> snapshot > previous <identifiersep> input <identifiersep> properties = previous <identifiersep> execution == null ? immutable <identifiersep> sorted <identifiersep> map . < string , value <identifiersep> snapshot > of ( ) : previous <identifiersep> execution . get <identifiersep> input <identifiersep> properties ( ) ; immutable <identifiersep> sorted <identifiersep> map < string , value <identifiersep> snapshot > input <identifiersep> properties = snapshot <identifiersep> task <identifiersep> input <identifiersep> properties ( task , task <identifiersep> properties , previous <identifiersep> input <identifiersep> properties , value <identifiersep> snapshotter ) ; immutable <identifiersep> sorted <identifiersep> set < string > output <identifiersep> property <identifiersep> names = get <identifiersep> output <identifiersep> property <identifiersep> names <identifiersep> for <identifiersep> cache <identifiersep> key ( task <identifiersep> properties ) ; immutable <identifiersep> set < string > declared <identifiersep> output <identifiersep> file <identifiersep> paths = get <identifiersep> declared <identifiersep> output <identifiersep> file <identifiersep> paths ( task <identifiersep> properties , string <identifiersep> interner ) ; immutable <identifiersep> sorted <identifiersep> map < string , file <identifiersep> collection <identifiersep> snapshot > input <identifiersep> files = snapshot <identifiersep> task <identifiersep> files ( task , <string_literal> , normalization <identifiersep> strategy , task <identifiersep> properties . get <identifiersep> input <identifiersep> file <identifiersep> properties ( ) , snapshotter <identifiersep> registry ) ; immutable <identifiersep> sorted <identifiersep> map < string , file <identifiersep> collection <identifiersep> snapshot > output <identifiersep> files = snapshot <identifiersep> task <identifiersep> files ( task , <string_literal> , normalization <identifiersep> strategy , task <identifiersep> properties . get <identifiersep> output <identifiersep> file <identifiersep> properties ( ) , snapshotter <identifiersep> registry ) ; <ect>
current <identifiersep> execution . set <identifiersep> discovered <identifiersep> input <identifiersep> files <identifiersep> snapshot ( discovered <identifiersep> files <identifiersep> snapshot ) ; } private static file <identifiersep> collection <identifiersep> snapshot snapshot <identifiersep> discovered <identifiersep> inputs ( task task , input <identifiersep> normalization <identifiersep> strategy normalization <identifiersep> strategy , collection < file > discovered <identifiersep> inputs , file <identifiersep> collection <identifiersep> snapshotter <identifiersep> registry snapshotter <identifiersep> registry , file <identifiersep> collection <identifiersep> factory file <identifiersep> collection <identifiersep> factory ) { file <identifiersep> collection <identifiersep> snapshotter snapshotter = snapshotter <identifiersep> registry . get <identifiersep> snapshotter ( generic <identifiersep> file <identifiersep> normalizer . class ) ; if ( discovered <identifiersep> inputs . is <identifiersep> empty ( ) ) { logger . debug ( <string_literal> , task ) ; return empty <identifiersep> file <identifiersep> collection <identifiersep> snapshot . instance ; } <LOG> try { return snapshotter . snapshot ( file <identifiersep> collection <identifiersep> factory . fixed ( <string_literal> , discovered <identifiersep> inputs ) , absolute , normalization <identifiersep> strategy ) ; } catch ( exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( string . format ( <string_literal> , task ) , e ) ; } } <comment> <ect>
public void after <identifiersep> lock <identifiersep> acquire ( file <identifiersep> lock . state current <identifiersep> cache <identifiersep> state ) { boolean out <identifiersep> of <identifiersep> date = false ; file <identifiersep> lock . state previous <identifiersep> state = file <identifiersep> lock <identifiersep> state <identifiersep> reference . get ( ) ; if ( previous <identifiersep> state == null ) { out <identifiersep> of <identifiersep> date = true ; } else if ( current <identifiersep> cache <identifiersep> state . has <identifiersep> been <identifiersep> updated <identifiersep> since ( previous <identifiersep> state ) ) { <LOG> out <identifiersep> of <identifiersep> date = true ; } if ( out <identifiersep> of <identifiersep> date ) { in <identifiersep> memory <identifiersep> cache . invalidate <identifiersep> all ( ) ; } delegate . after <identifiersep> lock <identifiersep> acquire ( current <identifiersep> cache <identifiersep> state ) ; } @ override public void finish <identifiersep> work ( ) { <ect>
caches = cache <identifiersep> factory . new <identifiersep> cache ( ) ; } public cache <identifiersep> decorator decorator ( final int max <identifiersep> entries <identifiersep> to <identifiersep> keep <identifiersep> in <identifiersep> memory , final boolean cache <identifiersep> in <identifiersep> memory <identifiersep> for <identifiersep> short <identifiersep> lived <identifiersep> processes ) { return new in <identifiersep> memory <identifiersep> cache <identifiersep> decorator ( max <identifiersep> entries <identifiersep> to <identifiersep> keep <identifiersep> in <identifiersep> memory , cache <identifiersep> in <identifiersep> memory <identifiersep> for <identifiersep> short <identifiersep> lived <identifiersep> processes ) ; } private < k , v > multi <identifiersep> process <identifiersep> safe <identifiersep> async <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > apply <identifiersep> in <identifiersep> memory <identifiersep> caching ( string cache <identifiersep> id , multi <identifiersep> process <identifiersep> safe <identifiersep> async <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > backing <identifiersep> cache , int max <identifiersep> entries <identifiersep> to <identifiersep> keep <identifiersep> in <identifiersep> memory , boolean cache <identifiersep> in <identifiersep> memory <identifiersep> for <identifiersep> short <identifiersep> lived <identifiersep> processes ) { if ( ! long <identifiersep> living <identifiersep> process && ! cache <identifiersep> in <identifiersep> memory <identifiersep> for <identifiersep> short <identifiersep> lived <identifiersep> processes ) { <comment> <LOG> return backing <identifiersep> cache ; } int target <identifiersep> size = cache <identifiersep> sizer . scale <identifiersep> cache <identifiersep> size ( max <identifiersep> entries <identifiersep> to <identifiersep> keep <identifiersep> in <identifiersep> memory ) ; cache <identifiersep> details cache <identifiersep> details = get <identifiersep> cache ( cache <identifiersep> id , target <identifiersep> size ) ; return new in <identifiersep> memory <identifiersep> decorated <identifiersep> cache < k , v > ( backing <identifiersep> cache , cache <identifiersep> details . entries , cache <identifiersep> id , cache <identifiersep> details . lock <identifiersep> state ) ; } private cache <identifiersep> details get <identifiersep> cache ( final string cache <identifiersep> id , final int max <identifiersep> size ) { cache <identifiersep> details cache <identifiersep> details = caches . get ( cache <identifiersep> id , new transformer < cache <identifiersep> details , string > ( ) { <ect>
} finally { lock . unlock ( ) ; } try { entry . clear ( ) ; entry . cleanup ( mode ) ; } catch ( exception ex ) { <LOG> } } public reference <identifiersep> queue < cached <identifiersep> class <identifiersep> loader > get <identifiersep> reference <identifiersep> queue ( ) { return reference <identifiersep> queue ; } public void exit ( ) { stopped . set ( true ) ; interrupt ( ) ; lock . lock ( ) ; <ect>
gradle <identifiersep> internal gradle = context . get <identifiersep> gradle ( ) ; task <identifiersep> graph <identifiersep> executer executer = gradle . get <identifiersep> task <identifiersep> graph ( ) ; list < task <identifiersep> execution <identifiersep> request > task <identifiersep> parameters = gradle . get <identifiersep> start <identifiersep> parameter ( ) . get <identifiersep> task <identifiersep> requests ( ) ; for ( task <identifiersep> execution <identifiersep> request task <identifiersep> parameter : task <identifiersep> parameters ) { list < task <identifiersep> selector . task <identifiersep> selection > task <identifiersep> selections = command <identifiersep> line <identifiersep> task <identifiersep> parser . parse <identifiersep> tasks ( task <identifiersep> parameter ) ; for ( task <identifiersep> selector . task <identifiersep> selection task <identifiersep> selection : task <identifiersep> selections ) { <LOG> executer . add <identifiersep> tasks ( task <identifiersep> selection . get <identifiersep> tasks ( ) ) ; } } context . proceed ( ) ; } } <ect>
project <identifiersep> configurer . configure ( project ) ; list < string > default <identifiersep> tasks = project . get <identifiersep> default <identifiersep> tasks ( ) ; if ( default <identifiersep> tasks . size ( ) == 0 ) { default <identifiersep> tasks = collections . singleton <identifiersep> list ( project <identifiersep> internal . help <identifiersep> task ) ; logger . info ( <string_literal> , g <identifiersep> util . to <identifiersep> string ( default <identifiersep> tasks ) ) ; } else { <LOG> } start <identifiersep> parameter . set <identifiersep> task <identifiersep> names ( default <identifiersep> tasks ) ; context . proceed ( ) ; } } <ect>
boolean more <identifiersep> tasks <identifiersep> to <identifiersep> execute = true ; while ( more <identifiersep> tasks <identifiersep> to <identifiersep> execute ) { more <identifiersep> tasks <identifiersep> to <identifiersep> execute = task <identifiersep> execution <identifiersep> plan . execute <identifiersep> with <identifiersep> task ( child <identifiersep> lease , new action < task <identifiersep> internal > ( ) { @ override public void execute ( task <identifiersep> internal task ) { final string task <identifiersep> path = task . get <identifiersep> path ( ) ; <LOG> task <identifiersep> timer . reset ( ) ; task <identifiersep> worker . execute ( task ) ; long task <identifiersep> duration = task <identifiersep> timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; busy . add <identifiersep> and <identifiersep> get ( task <identifiersep> duration ) ; logger . info ( <string_literal> , task <identifiersep> path , thread . current <identifiersep> thread ( ) , time <identifiersep> formatting . format <identifiersep> duration <identifiersep> verbose ( task <identifiersep> duration ) ) ; <ect>
busy . add <identifiersep> and <identifiersep> get ( task <identifiersep> duration ) ; logger . info ( <string_literal> , task <identifiersep> path , thread . current <identifiersep> thread ( ) , time <identifiersep> formatting . format <identifiersep> duration <identifiersep> verbose ( task <identifiersep> duration ) ) ; } } } ) ; } long total = total <identifiersep> timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; <LOG> } } } } <ect>
public void execute ( ) { timer clock = time . start <identifiersep> timer ( ) ; ensure <identifiersep> populated ( ) ; graph <identifiersep> listeners . get <identifiersep> source ( ) . graph <identifiersep> populated ( this ) ; try { task <identifiersep> plan <identifiersep> executor . process ( task <identifiersep> execution <identifiersep> plan , new event <identifiersep> firing <identifiersep> task <identifiersep> worker ( task <identifiersep> executer . create ( ) , build <identifiersep> operation <identifiersep> executor . get <identifiersep> current <identifiersep> operation ( ) ) ) ; <LOG> } finally { task <identifiersep> execution <identifiersep> plan . clear ( ) ; } } public void add <identifiersep> task <identifiersep> execution <identifiersep> graph <identifiersep> listener ( task <identifiersep> execution <identifiersep> graph <identifiersep> listener listener ) { graph <identifiersep> listeners . add ( listener ) ; } public void remove <identifiersep> task <identifiersep> execution <identifiersep> graph <identifiersep> listener ( task <identifiersep> execution <identifiersep> graph <identifiersep> listener listener ) { graph <identifiersep> listeners . remove ( listener ) ; <ect>
g <identifiersep> file <identifiersep> utils . delete <identifiersep> directory ( metadata <identifiersep> dir ) ; throw e ; } logger . debug ( <string_literal> , classes <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) , clock . get <identifiersep> elapsed ( ) ) ; } private void compile <identifiersep> script ( final script <identifiersep> source source , class <identifiersep> loader class <identifiersep> loader , compiler <identifiersep> configuration configuration , file metadata <identifiersep> dir , final compile <identifiersep> operation < ? > extracting <identifiersep> transformer , final action < ? super class <identifiersep> node > custom <identifiersep> verifier ) { final transformer transformer = extracting <identifiersep> transformer != null ? extracting <identifiersep> transformer . get <identifiersep> transformer ( ) : null ; <LOG> final empty <identifiersep> script <identifiersep> detector empty <identifiersep> script <identifiersep> detector = new empty <identifiersep> script <identifiersep> detector ( ) ; final package <identifiersep> statement <identifiersep> detector package <identifiersep> detector = new package <identifiersep> statement <identifiersep> detector ( ) ; groovy <identifiersep> class <identifiersep> loader groovy <identifiersep> class <identifiersep> loader = new groovy <identifiersep> class <identifiersep> loader ( class <identifiersep> loader , configuration , false ) { @ override protected compilation <identifiersep> unit create <identifiersep> compilation <identifiersep> unit ( compiler <identifiersep> configuration compiler <identifiersep> configuration , code <identifiersep> source code <identifiersep> source ) { <ect>
public void stop ( ) { lock . lock ( ) ; try { logger . debug ( <string_literal> , deployments . size ( ) ) ; composite <identifiersep> stoppable . stoppable ( deployments . values ( ) ) . stop ( ) ; } finally { <LOG> stopped = true ; deployments . clear ( ) ; lock . unlock ( ) ; } pending <identifiersep> changes <identifiersep> manager . remove <identifiersep> listener ( this ) ; } private void fail <identifiersep> if <identifiersep> stopped ( ) { if ( stopped ) { <ect>
private void add <identifiersep> properties <identifiersep> to <identifiersep> project ( project project , caching <identifiersep> property <identifiersep> applicator applicator ) { properties project <identifiersep> properties = new properties ( ) ; file project <identifiersep> properties <identifiersep> file = new file ( project . get <identifiersep> project <identifiersep> dir ( ) , project . gradle <identifiersep> properties ) ; logger . debug ( <string_literal> , project <identifiersep> properties <identifiersep> file ) ; if ( project <identifiersep> properties <identifiersep> file . is <identifiersep> file ( ) ) { project <identifiersep> properties = g <identifiersep> util . load <identifiersep> properties ( project <identifiersep> properties <identifiersep> file ) ; <LOG> project <identifiersep> properties . key <identifiersep> set ( ) ) ; } else { logger . debug ( <string_literal> ) ; } <comment> <ect>
return result ; } private map < string , string > get <identifiersep> system <identifiersep> project <identifiersep> properties ( map < string , string > system <identifiersep> properties ) { map < string , string > system <identifiersep> project <identifiersep> properties = new hash <identifiersep> map < string , string > ( ) ; for ( map . entry < string , string > entry : system <identifiersep> properties . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> key ( ) . starts <identifiersep> with ( system <identifiersep> project <identifiersep> properties <identifiersep> prefix ) && entry . get <identifiersep> key ( ) . length ( ) > system <identifiersep> project <identifiersep> properties <identifiersep> prefix . length ( ) ) { system <identifiersep> project <identifiersep> properties . put ( entry . get <identifiersep> key ( ) . substring ( system <identifiersep> project <identifiersep> properties <identifiersep> prefix . length ( ) ) , entry . get <identifiersep> value ( ) ) ; } } <LOG> return system <identifiersep> project <identifiersep> properties ; } private map < string , string > get <identifiersep> env <identifiersep> project <identifiersep> properties ( map < string , string > env <identifiersep> properties ) { map < string , string > env <identifiersep> project <identifiersep> properties = new hash <identifiersep> map < string , string > ( ) ; for ( map . entry < string , string > entry : env <identifiersep> properties . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> key ( ) . starts <identifiersep> with ( env <identifiersep> project <identifiersep> properties <identifiersep> prefix ) && entry . get <identifiersep> key ( ) . length ( ) > env <identifiersep> project <identifiersep> properties <identifiersep> prefix . length ( ) ) { env <identifiersep> project <identifiersep> properties . put ( entry . get <identifiersep> key ( ) . substring ( env <identifiersep> project <identifiersep> properties <identifiersep> prefix . length ( ) ) , entry . get <identifiersep> value ( ) ) ; <ect>
class <identifiersep> path classpath = create <identifiersep> build <identifiersep> source <identifiersep> classpath ( gradle , build <identifiersep> src <identifiersep> dir , containing <identifiersep> build <identifiersep> parameters ) ; return class <identifiersep> loader <identifiersep> scope . create <identifiersep> child ( build <identifiersep> src <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) ) . export ( classpath ) . lock ( ) ; } private class <identifiersep> path create <identifiersep> build <identifiersep> source <identifiersep> classpath ( final gradle <identifiersep> internal gradle , file build <identifiersep> src <identifiersep> dir , final start <identifiersep> parameter containing <identifiersep> build <identifiersep> parameters ) { if ( ! build <identifiersep> src <identifiersep> dir . is <identifiersep> directory ( ) ) { <LOG> return class <identifiersep> path . empty ; } final start <identifiersep> parameter build <identifiersep> src <identifiersep> start <identifiersep> parameter = containing <identifiersep> build <identifiersep> parameters . new <identifiersep> build ( ) ; build <identifiersep> src <identifiersep> start <identifiersep> parameter . set <identifiersep> current <identifiersep> dir ( build <identifiersep> src <identifiersep> dir ) ; build <identifiersep> src <identifiersep> start <identifiersep> parameter . set <identifiersep> project <identifiersep> properties ( containing <identifiersep> build <identifiersep> parameters . get <identifiersep> project <identifiersep> properties ( ) ) ; build <identifiersep> src <identifiersep> start <identifiersep> parameter . set <identifiersep> search <identifiersep> upwards ( false ) ; build <identifiersep> src <identifiersep> start <identifiersep> parameter . set <identifiersep> profile ( containing <identifiersep> build <identifiersep> parameters . is <identifiersep> profile ( ) ) ; <ect>
start <identifiersep> parameter start <identifiersep> parameter ) { timer settings <identifiersep> processing <identifiersep> clock = time . start <identifiersep> timer ( ) ; map < string , string > properties = properties <identifiersep> loader . merge <identifiersep> properties ( collections . < string , string > empty <identifiersep> map ( ) ) ; settings <identifiersep> internal settings = settings <identifiersep> factory . create <identifiersep> settings ( gradle , settings <identifiersep> location . get <identifiersep> settings <identifiersep> dir ( ) , settings <identifiersep> location . get <identifiersep> settings <identifiersep> script <identifiersep> source ( ) , properties , start <identifiersep> parameter , build <identifiersep> root <identifiersep> class <identifiersep> loader <identifiersep> scope ) ; apply <identifiersep> settings <identifiersep> script ( settings <identifiersep> location , settings ) ; <LOG> return settings ; } private void apply <identifiersep> settings <identifiersep> script ( settings <identifiersep> location settings <identifiersep> location , final settings <identifiersep> internal settings ) { script <identifiersep> source settings <identifiersep> script <identifiersep> source = settings <identifiersep> location . get <identifiersep> settings <identifiersep> script <identifiersep> source ( ) ; class <identifiersep> loader <identifiersep> scope settings <identifiersep> class <identifiersep> loader <identifiersep> scope = settings . get <identifiersep> class <identifiersep> loader <identifiersep> scope ( ) ; script <identifiersep> plugin configurer = configurer <identifiersep> factory . create ( settings <identifiersep> script <identifiersep> source , settings . get <identifiersep> buildscript ( ) , settings <identifiersep> class <identifiersep> loader <identifiersep> scope , settings . get <identifiersep> root <identifiersep> class <identifiersep> loader <identifiersep> scope ( ) , true ) ; configurer . apply ( settings ) ; <ect>
final timer clock = time . start <identifiersep> timer ( ) ; try { script <identifiersep> plugin configurer = configurer <identifiersep> factory . create ( project . get <identifiersep> build <identifiersep> script <identifiersep> source ( ) , project . get <identifiersep> buildscript ( ) , project . get <identifiersep> class <identifiersep> loader <identifiersep> scope ( ) , project . get <identifiersep> base <identifiersep> class <identifiersep> loader <identifiersep> scope ( ) , true ) ; configurer . apply ( project ) ; } finally { <LOG> } } } } <ect>
container <identifiersep> node . set <identifiersep> private <identifiersep> data ( container <identifiersep> type , container ) ; container . all ( new action < i > ( ) { public void execute ( final i item ) { final string name = namer . determine <identifiersep> name ( item ) ; <comment> <LOG> return ; } if ( ! container <identifiersep> node . has <identifiersep> link ( name ) ) { model <identifiersep> registration item <identifiersep> registration = model <identifiersep> registrations . unmanaged <identifiersep> instance <identifiersep> of ( model <identifiersep> reference . of ( container <identifiersep> path . child ( name ) , new dsl <identifiersep> object ( item ) . get <identifiersep> declared <identifiersep> type ( ) ) , new extract <identifiersep> from <identifiersep> parent <identifiersep> container < i , c > ( name , container <identifiersep> type ) <ect>
public debugging <identifiersep> task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder ( task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder delegate ) { this . delegate = delegate ; } @ override public void append <identifiersep> task <identifiersep> implementation ( implementation <identifiersep> snapshot task <identifiersep> implementation ) { log ( <string_literal> , task <identifiersep> implementation . get <identifiersep> type <identifiersep> name ( ) ) ; if ( ! task <identifiersep> implementation . has <identifiersep> unknown <identifiersep> class <identifiersep> loader ( ) ) { <LOG> } delegate . append <identifiersep> task <identifiersep> implementation ( task <identifiersep> implementation ) ; } @ override public void append <identifiersep> task <identifiersep> action <identifiersep> implementations ( collection < implementation <identifiersep> snapshot > task <identifiersep> action <identifiersep> implementations ) { for ( implementation <identifiersep> snapshot action <identifiersep> impl : task <identifiersep> action <identifiersep> implementations ) { log ( <string_literal> , action <identifiersep> impl . get <identifiersep> type <identifiersep> name ( ) ) ; log ( <string_literal> , action <identifiersep> impl . has <identifiersep> unknown <identifiersep> class <identifiersep> loader ( ) ? null : action <identifiersep> impl . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( ) ) ; <ect>
log ( <string_literal> , task <identifiersep> implementation . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( ) ) ; } delegate . append <identifiersep> task <identifiersep> implementation ( task <identifiersep> implementation ) ; } @ override public void append <identifiersep> task <identifiersep> action <identifiersep> implementations ( collection < implementation <identifiersep> snapshot > task <identifiersep> action <identifiersep> implementations ) { for ( implementation <identifiersep> snapshot action <identifiersep> impl : task <identifiersep> action <identifiersep> implementations ) { log ( <string_literal> , action <identifiersep> impl . get <identifiersep> type <identifiersep> name ( ) ) ; <LOG> } delegate . append <identifiersep> task <identifiersep> action <identifiersep> implementations ( task <identifiersep> action <identifiersep> implementations ) ; } @ override public void append <identifiersep> input <identifiersep> property <identifiersep> hash ( string property <identifiersep> name , hash <identifiersep> code hash <identifiersep> code ) { logger . lifecycle ( <string_literal> , property <identifiersep> name , hash <identifiersep> code ) ; delegate . append <identifiersep> input <identifiersep> property <identifiersep> hash ( property <identifiersep> name , hash <identifiersep> code ) ; } @ override <ect>
lock . lock ( ) ; try { set <identifiersep> state ( new <identifiersep> state ) ; this . exec <identifiersep> result = new <identifiersep> result ; } finally { lock . unlock ( ) ; } <LOG> } @ nullable private exec <identifiersep> exception exec <identifiersep> exception <identifiersep> for ( throwable failure <identifiersep> cause , exec <identifiersep> handle <identifiersep> state current <identifiersep> state ) { return failure <identifiersep> cause != null ? new exec <identifiersep> exception ( failure <identifiersep> message <identifiersep> for ( current <identifiersep> state ) , failure <identifiersep> cause ) : null ; } private string failure <identifiersep> message <identifiersep> for ( exec <identifiersep> handle <identifiersep> state current <identifiersep> state ) { <ect>
if ( ! state <identifiersep> in ( exec <identifiersep> handle <identifiersep> state . init ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( format ( <string_literal> , display <identifiersep> name ) ) ; } set <identifiersep> state ( exec <identifiersep> handle <identifiersep> state . starting ) ; exec <identifiersep> handle <identifiersep> runner = new exec <identifiersep> handle <identifiersep> runner ( this , new composite <identifiersep> streams <identifiersep> handler ( ) , process <identifiersep> launcher , executor ) ; executor . execute ( new current <identifiersep> build <identifiersep> operation <identifiersep> preserving <identifiersep> runnable ( exec <identifiersep> handle <identifiersep> runner ) ) ; while ( state <identifiersep> in ( exec <identifiersep> handle <identifiersep> state . starting ) ) { <LOG> try { state <identifiersep> changed . await ( ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
private class gradle <identifiersep> shutdown <identifiersep> hook implements runnable { public void run ( ) { for ( final runnable shutdown <identifiersep> hook <identifiersep> action : shutdown <identifiersep> hook <identifiersep> actions ) { try { shutdown <identifiersep> hook <identifiersep> action . run ( ) ; } catch ( throwable t ) { <LOG> t . print <identifiersep> stack <identifiersep> trace ( system . err ) ; } } } } } <ect>
return new file ( cache . get <identifiersep> base <identifiersep> dir ( ) , <string_literal> ) ; } private static class cache <identifiersep> initializer implements action < persistent <identifiersep> cache > { private final worker <identifiersep> class <identifiersep> remapper remapper = new worker <identifiersep> class <identifiersep> remapper ( ) ; public void execute ( persistent <identifiersep> cache cache ) { try { file jar <identifiersep> file = jar <identifiersep> file ( cache ) ; <LOG> <comment> <ect>
thread . current <identifiersep> thread ( ) . set <identifiersep> context <identifiersep> class <identifiersep> loader ( action . get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> loader ( ) ) ; native <identifiersep> services . initialize ( gradle <identifiersep> user <identifiersep> home <identifiersep> dir , false ) ; try { action . execute ( context ) ; } finally { thread . current <identifiersep> thread ( ) . set <identifiersep> context <identifiersep> class <identifiersep> loader ( context <identifiersep> class <identifiersep> loader ) ; } <LOG> } } <ect>
} ) ; worker <identifiersep> process . start <identifiersep> accepting ( acceptor ) ; address local <identifiersep> address = acceptor . get <identifiersep> address ( ) ; <comment> <LOG> logger . debug ( <string_literal> , application <identifiersep> classpath ) ; logger . debug ( <string_literal> , implementation <identifiersep> class <identifiersep> path ) ; java <identifiersep> exec <identifiersep> handle <identifiersep> builder java <identifiersep> command = get <identifiersep> java <identifiersep> command ( ) ; java <identifiersep> command . set <identifiersep> display <identifiersep> name ( display <identifiersep> name ) ; worker <identifiersep> implementation <identifiersep> factory . prepare <identifiersep> java <identifiersep> command ( id , display <identifiersep> name , this , implementation <identifiersep> class <identifiersep> path , local <identifiersep> address , java <identifiersep> command , should <identifiersep> publish <identifiersep> jvm <identifiersep> memory <identifiersep> info ) ; java <identifiersep> command . args ( <string_literal> + display <identifiersep> name + <string_literal> ) ; <ect>
address local <identifiersep> address = acceptor . get <identifiersep> address ( ) ; <comment> <LOG> java <identifiersep> exec <identifiersep> handle <identifiersep> builder java <identifiersep> command = get <identifiersep> java <identifiersep> command ( ) ; java <identifiersep> command . set <identifiersep> display <identifiersep> name ( display <identifiersep> name ) ; worker <identifiersep> implementation <identifiersep> factory . prepare <identifiersep> java <identifiersep> command ( id , display <identifiersep> name , this , implementation <identifiersep> class <identifiersep> path , local <identifiersep> address , java <identifiersep> command , should <identifiersep> publish <identifiersep> jvm <identifiersep> memory <identifiersep> info ) ; java <identifiersep> command . args ( <string_literal> + display <identifiersep> name + <string_literal> ) ; exec <identifiersep> handle exec <identifiersep> handle = java <identifiersep> command . build ( ) ; worker <identifiersep> process . set <identifiersep> exec <identifiersep> handle ( exec <identifiersep> handle ) ; <ect>
output <identifiersep> stream . write ( buffer , 0 , nread ) ; output <identifiersep> stream . flush ( ) ; } composite <identifiersep> stoppable . stoppable ( input <identifiersep> stream , output <identifiersep> stream ) . stop ( ) ; } catch ( throwable t ) { if ( was <identifiersep> interrupted ( t ) ) { return ; } <LOG> } } <comment> private boolean was <identifiersep> interrupted ( throwable t ) { return t instanceof io <identifiersep> exception && <string_literal> . equals ( t . get <identifiersep> message ( ) ) ; <ect>
given : log . start ( ) when : log . operation <identifiersep> success ( <string_literal> , <string_literal> ) then : 1 * logger . log ( debug , <string_literal> ) <LOG> log <identifiersep> output ( ) == <string_literal> <string_literal> <string_literal> cleanup : log . done ( ) <ect>
given : log . start ( ) when : log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) then : 1 * logger . log ( debug , <string_literal> ) <LOG> log <identifiersep> output ( ) == <string_literal> <string_literal> <string_literal> cleanup : log . done ( ) <ect>
when : log . start ( ) <number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <LOG> <number_literal> * logger . log ( error , <string_literal> ) 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
<number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <number_literal> * logger . log ( debug , <string_literal> ) <number_literal> * logger . log ( error , <string_literal> ) <LOG> log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
when : log . start ( ) <number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <LOG> <number_literal> * logger . log ( error , <string_literal> ) 1 * logger . log ( error , <string_literal> ) 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
<number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <number_literal> * logger . log ( debug , <string_literal> ) <number_literal> * logger . log ( error , <string_literal> ) <LOG> 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
with ( config ( ) ) { ! enabled disabled attributes . is this . attributes } } def <string_literal> ( ) { when : <LOG> then : thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception when : config ( <string_literal> ) then : not <identifiersep> thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception <ect>
thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception when : config ( <string_literal> ) then : not <identifiersep> thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception when : <LOG> then : not <identifiersep> thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception } def <string_literal> ( ) { given : attributes . is <identifiersep> root <identifiersep> project <identifiersep> has <identifiersep> vcs <identifiersep> mappings ( ) > > true when : <ect>
public class test1 { @ before <identifiersep> class public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { <LOG> } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { <LOG> } } <ect>
private static final long serial <identifiersep> version <identifiersep> uid = 1l ; } @ before <identifiersep> class public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { <LOG> } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { <LOG> } } <ect>
@ test public void a ( ) { system . out . println ( <string_literal> ) ; } @ category ( category <identifiersep> b . class ) @ test public void b ( ) { <LOG> } <ect>
package org . gradle . sample ; import org . junit . test ; import java . lang . system ; public class core <identifiersep> test { @ test public void ok ( ) { <LOG> } } <ect>
package org . gradle ; import java . lang . string ; public class my <identifiersep> main { public static void main ( string . . . args ) { new my <identifiersep> main ( ) . some <identifiersep> method ( ) ; } private void some <identifiersep> method ( ) { <LOG> } <ect>
package org . gradle . junitplatform ; import org . junit . * ; public class j <identifiersep> unit4test { @ test public void ok ( ) { <LOG> } } <ect>
package org . gradle . junitplatform ; import static org . junit . jupiter . api . assertions . * ; import org . junit . jupiter . api . * ; public class jupiter <identifiersep> test { @ test public void ok ( ) { <LOG> } @ repeated <identifiersep> test ( <number_literal> ) public void repeated ( ) { system . out . println ( <string_literal> ) ; } @ before <identifiersep> each public void before <identifiersep> each ( ) { system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } @ repeated <identifiersep> test ( <number_literal> ) public void repeated ( ) { system . out . println ( <string_literal> ) ; } @ before <identifiersep> each public void before <identifiersep> each ( ) { <LOG> } @ before <identifiersep> all public static void before <identifiersep> all ( ) { system . out . println ( <string_literal> ) ; } @ disabled @ test public void disabled ( ) { <ect>
package org . gradle . api . services ; import org . gradle . sample . api . person ; import org . gradle . sample . shared . helper ; public class person <identifiersep> service { boolean check <identifiersep> person ( person person ) { <LOG> if ( person . get <identifiersep> firstname ( ) . length ( ) < <number_literal> ) { return false ; } return true ; } <ect>
public class hello { public static void main ( string [ ] args ) { <LOG> } } <ect>
import org . apache . log4j . logger ; public class main { private static final logger logger = logger . get <identifiersep> logger ( main . class ) ; public static void main ( string args [ ] ) { <LOG> } } <ect>
import org . apache . log4j . logger ; public class main { private static final logger logger = logger . get <identifiersep> logger ( main . class ) ; public static void main ( string args [ ] ) { <LOG> } } <ect>
method . release <identifiersep> connection ( ) ; } return null ; } <comment> <LOG> } return status <identifiersep> code ; } } <comment> <ect>
connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> for ( string task : model . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task ) ; } } finally { <comment> <ect>
system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { <LOG> system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; <ect>
for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { <LOG> } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; <ect>
system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { <LOG> } system . out . println ( <string_literal> ) ; for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> dependency dependency : module . get <identifiersep> dependencies ( ) ) { system . out . println ( <string_literal> + dependency ) ; <ect>
system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { <LOG> } } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> dependency dependency : module . get <identifiersep> dependencies ( ) ) { system . out . println ( <string_literal> + dependency ) ; } } } finally { <comment> <ect>
system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> dependency dependency : module . get <identifiersep> dependencies ( ) ) { <LOG> } } } finally { <comment> <ect>
connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> for ( task task : project . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } } finally { <comment> <ect>
connector . use <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( new file ( args [ 1 ] ) ) ; } } connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> system . out . println ( <string_literal> + project . get <identifiersep> project <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( eclipse <identifiersep> source <identifiersep> directory src <identifiersep> dir : project . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( src <identifiersep> dir . get <identifiersep> path ( ) ) ; } system . out . println ( <string_literal> ) ; for ( external <identifiersep> dependency external <identifiersep> dependency : project . get <identifiersep> classpath ( ) ) { <ect>
project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> for ( eclipse <identifiersep> source <identifiersep> directory src <identifiersep> dir : project . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( src <identifiersep> dir . get <identifiersep> path ( ) ) ; } system . out . println ( <string_literal> ) ; for ( external <identifiersep> dependency external <identifiersep> dependency : project . get <identifiersep> classpath ( ) ) { system . out . println ( external <identifiersep> dependency . get <identifiersep> file ( ) . get <identifiersep> name ( ) ) ; } system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; for ( eclipse <identifiersep> source <identifiersep> directory src <identifiersep> dir : project . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( src <identifiersep> dir . get <identifiersep> path ( ) ) ; } system . out . println ( <string_literal> ) ; for ( external <identifiersep> dependency external <identifiersep> dependency : project . get <identifiersep> classpath ( ) ) { system . out . println ( external <identifiersep> dependency . get <identifiersep> file ( ) . get <identifiersep> name ( ) ) ; } <LOG> system . out . println ( project . get <identifiersep> gradle <identifiersep> project ( ) ) ; } finally { <comment> <ect>
package org . gradle . sample ; import org . apache . commons . collections . list . growth <identifiersep> list ; public class main { public static void main ( string [ ] args ) { growth <identifiersep> list l = new growth <identifiersep> list ( ) ; if ( system . get <identifiersep> property ( <string_literal> ) . equals ( <string_literal> ) ) { <LOG> } else { system . out . println ( <string_literal> ) ; } } <ect>
@ unroll def <string_literal> ( ) { given : temporary <identifiersep> folder . file ( <string_literal> ) < < ''' <comment> <LOG> system . err . println ( <string_literal> ) ''' when : system . out . println ( <string_literal> ) system . err . println ( <string_literal> ) def result1 = executer <ect>
<comment> <LOG> system . err . println ( <string_literal> ) def result1 = executer . in <identifiersep> directory ( temporary <identifiersep> folder . test <identifiersep> directory ) . with <identifiersep> tasks ( <string_literal> ) . with <identifiersep> console ( console ) . run ( ) <ect>
system . err . println ( <string_literal> ) def result1 = executer . in <identifiersep> directory ( temporary <identifiersep> folder . test <identifiersep> directory ) . with <identifiersep> tasks ( <string_literal> ) . with <identifiersep> console ( console ) . run ( ) <LOG> system . err . println ( <string_literal> ) def result2 = executer . in <identifiersep> directory ( temporary <identifiersep> folder . test <identifiersep> directory ) . with <identifiersep> tasks ( <string_literal> ) . with <identifiersep> console ( console ) . run ( ) <ect>
received . add ( path ) ; if ( pending . is <identifiersep> empty ( ) ) { condition . signal <identifiersep> all ( ) ; } while ( ! pending . is <identifiersep> empty ( ) && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; if ( wait <identifiersep> ms < 0 ) { <LOG> failure = new assertion <identifiersep> error ( string . format ( <string_literal> , pending . key <identifiersep> set ( ) , received ) ) ; condition . signal <identifiersep> all ( ) ; throw failure ; } system . out . println ( string . format ( <string_literal> , id , pending . key <identifiersep> set ( ) ) ) ; condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } if ( failure != null ) { <ect>
condition . signal <identifiersep> all ( ) ; throw failure ; } system . out . println ( string . format ( <string_literal> , id , pending . key <identifiersep> set ( ) ) ) ; condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } if ( failure != null ) { <comment> <LOG> throw failure ; } } finally { lock . unlock ( ) ; } <comment> <ect>
} finally { lock . unlock ( ) ; } } @ override public void handle ( http <identifiersep> exchange http <identifiersep> exchange ) throws io <identifiersep> exception { try { int id = counter . increment <identifiersep> and <identifiersep> get ( ) ; <LOG> resource <identifiersep> handler resource <identifiersep> handler = select <identifiersep> handler ( id , http <identifiersep> exchange ) ; if ( resource <identifiersep> handler != null ) { system . out . println ( string . format ( <string_literal> , id ) ) ; try { resource <identifiersep> handler . write <identifiersep> to ( id , http <identifiersep> exchange ) ; } catch ( throwable e ) { <ect>
connected = true ; lock . notify <identifiersep> all ( ) ; long expiry = monotonic <identifiersep> clock <identifiersep> millis ( ) + <number_literal> ; while ( ! released && ! stopped ) { long delay = expiry - monotonic <identifiersep> clock <identifiersep> millis ( ) ; if ( delay < = 0 ) { <LOG> output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; return ; } try { lock . wait ( delay ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; <ect>
system . out . println ( <string_literal> ) ; output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; return ; } connected = false ; released = false ; lock . notify <identifiersep> all ( ) ; } <LOG> output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; } } ) ; } void stop ( ) { system . out . println ( <string_literal> ) ; synchronized ( lock ) { stopped = true ; <ect>
string message = string . format ( <string_literal> , get <identifiersep> uri ( ) ) ; if ( fail <identifiersep> at <identifiersep> timeout ) { throw new assertion <identifiersep> failed <identifiersep> error ( message ) ; } else { system . out . println ( message ) ; return false ; } } <LOG> try { lock . wait ( delay ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } } if ( stopped ) { throw new assertion <identifiersep> failed <identifiersep> error ( string . format ( <string_literal> , get <identifiersep> uri ( ) ) ) ; <ect>
throw new runtime <identifiersep> exception ( e ) ; } } <comment> public string call <identifiersep> from <identifiersep> build ( string resource ) { uri uri = uri ( resource ) ; <LOG> } <comment> public string call <identifiersep> from <identifiersep> build <identifiersep> using <identifiersep> expression ( string expression ) { string uri <identifiersep> expression = <string_literal> + get <identifiersep> uri ( ) + <string_literal> + expression ; return <string_literal> + uri <identifiersep> expression + <string_literal> + uri <identifiersep> expression + <string_literal> ; <ect>
if ( waiting <identifiersep> for == 0 ) { condition . signal <identifiersep> all ( ) ; } while ( ! released . contains ( path ) && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - clock . get <identifiersep> current <identifiersep> time ( ) ; if ( wait <identifiersep> ms < 0 ) { if ( waiting <identifiersep> for > 0 ) { <LOG> throw timeout <identifiersep> waiting <identifiersep> for <identifiersep> requests ( ) ; } system . out . println ( string . format ( <string_literal> , id ) ) ; failure = new assertion <identifiersep> error ( string . format ( <string_literal> , waiting <identifiersep> for , received , released , expected . key <identifiersep> set ( ) ) ) ; condition . signal <identifiersep> all ( ) ; throw failure ; } system . out . println ( string . format ( <string_literal> , id , waiting <identifiersep> for , received ) ) ; <ect>
system . out . println ( string . format ( <string_literal> , id ) ) ; throw timeout <identifiersep> waiting <identifiersep> for <identifiersep> requests ( ) ; } system . out . println ( string . format ( <string_literal> , id ) ) ; failure = new assertion <identifiersep> error ( string . format ( <string_literal> , waiting <identifiersep> for , received , released , expected . key <identifiersep> set ( ) ) ) ; condition . signal <identifiersep> all ( ) ; throw failure ; } <LOG> condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } if ( failure != null ) { <comment> <ect>
lock . lock ( ) ; try { if ( ! received . contains ( path ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } if ( released . contains ( path ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <LOG> released . add ( path ) ; all . get ( path ) . released ( ) ; do <identifiersep> release ( 1 ) ; } finally { lock . unlock ( ) ; } } @ override <ect>
lock . lock ( ) ; try { int release <identifiersep> count = 0 ; for ( int i = 0 ; release <identifiersep> count < count && i < received . size ( ) ; i ++ ) { string path = received . get ( i ) ; if ( ! released . contains ( path ) ) { <LOG> released . add ( path ) ; all . get ( path ) . released ( ) ; release <identifiersep> count ++ ; } } if ( release <identifiersep> count != count ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } do <identifiersep> release ( count ) ; <ect>
long now = clock . get <identifiersep> current <identifiersep> time ( ) ; if ( most <identifiersep> recent <identifiersep> event < now ) { most <identifiersep> recent <identifiersep> event = now ; } while ( waiting <identifiersep> for > 0 && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - clock . get <identifiersep> current <identifiersep> time ( ) ; if ( wait <identifiersep> ms < 0 ) { <LOG> throw timeout <identifiersep> waiting <identifiersep> for <identifiersep> requests ( ) ; } system . out . println ( string . format ( <string_literal> , test <identifiersep> id , waiting <identifiersep> for , received , released , expected . key <identifiersep> set ( ) ) ) ; try { condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; <ect>
try { condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } } if ( failure != null ) { throw failure ; } <LOG> } finally { lock . unlock ( ) ; } } private assertion <identifiersep> error timeout <identifiersep> waiting <identifiersep> for <identifiersep> requests ( ) { failure = new assertion <identifiersep> error ( string . format ( <string_literal> , waiting <identifiersep> for , received , released , expected . key <identifiersep> set ( ) ) ) ; condition . signal <identifiersep> all ( ) ; throw failure ; <ect>
if ( sample <identifiersep> name != null ) { string hint <identifiersep> for <identifiersep> missing <identifiersep> sample = string . format ( <string_literal> , sample <identifiersep> name ) ; test <identifiersep> file src <identifiersep> dir = new integration <identifiersep> test <identifiersep> build <identifiersep> context ( ) . get <identifiersep> samples <identifiersep> dir ( ) . file ( sample <identifiersep> name ) . assert <identifiersep> is <identifiersep> dir ( hint <identifiersep> for <identifiersep> missing <identifiersep> sample ) ; logger . debug ( <string_literal> , sample <identifiersep> name ) ; src <identifiersep> dir . copy <identifiersep> to ( get <identifiersep> dir ( ) ) ; } else { <LOG> } base . evaluate ( ) ; } } ; } private string get <identifiersep> sample <identifiersep> name ( framework <identifiersep> method method ) { uses <identifiersep> sample annotation = method . get <identifiersep> annotation ( uses <identifiersep> sample . class ) ; return annotation != null ? annotation . value ( ) <ect>
public void maybe <identifiersep> copy ( string resource ) { test <identifiersep> file dir = resources . find <identifiersep> resource ( resource ) ; if ( dir != null ) { logger . debug ( <string_literal> , resource , dir ) ; dir . copy <identifiersep> to ( get <identifiersep> dir ( ) ) ; } else { <LOG> } } } <ect>
import org . gradle . api . internal . tasks . userinput . build <identifiersep> scan <identifiersep> user <identifiersep> input <identifiersep> handler ; public class build <identifiersep> scan <identifiersep> plugin implements plugin < project > { @ override public void apply ( project project ) { build <identifiersep> scan <identifiersep> user <identifiersep> input <identifiersep> handler user <identifiersep> input <identifiersep> handler = ( ( project <identifiersep> internal ) project ) . get <identifiersep> services ( ) . get ( build <identifiersep> scan <identifiersep> user <identifiersep> input <identifiersep> handler . class ) ; boolean accepted = user <identifiersep> input <identifiersep> handler . ask <identifiersep> yes <identifiersep> no <identifiersep> question ( <string_literal> ) ; <LOG> } } <string_literal> <string_literal> <string_literal> apply plugin : build <identifiersep> scan <identifiersep> plugin task $dummy <identifiersep> task <identifiersep> name <string_literal> <string_literal> <ect>
collections . sort ( jvms , new comparator < jvm <identifiersep> installation > ( ) { public int compare ( jvm <identifiersep> installation o1 , jvm <identifiersep> installation o2 ) { return o2 . get <identifiersep> version ( ) . compare <identifiersep> to ( o1 . get <identifiersep> version ( ) ) ; } } ) ; } system . out . println ( <string_literal> ) ; for ( jvm <identifiersep> installation jvm : jvms ) { <LOG> } return jvms ; } private static class dev <identifiersep> infrastructure <identifiersep> jvm <identifiersep> locator { final file <identifiersep> canonicalizer file <identifiersep> canonicalizer ; private dev <identifiersep> infrastructure <identifiersep> jvm <identifiersep> locator ( file <identifiersep> canonicalizer file <identifiersep> canonicalizer ) { this . file <identifiersep> canonicalizer = file <identifiersep> canonicalizer ; } public list < jvm <identifiersep> installation > find <identifiersep> jvms ( ) { <ect>
connection . set <identifiersep> use <identifiersep> caches ( false ) ; string credentials = base64 . encode <identifiersep> base64string ( ( username + <string_literal> + password ) . get <identifiersep> bytes ( <string_literal> ) ) . trim ( ) ; connection . set <identifiersep> request <identifiersep> property ( <string_literal> , <string_literal> + credentials ) ; final output <identifiersep> stream output <identifiersep> stream = connection . get <identifiersep> output <identifiersep> stream ( ) ; io <identifiersep> utils . write ( <string_literal> + url <identifiersep> encoder . encode ( message , <string_literal> ) , output <identifiersep> stream ) ; io <identifiersep> utils . close <identifiersep> quietly ( output <identifiersep> stream ) ; <LOG> final input <identifiersep> stream input <identifiersep> stream = connection . get <identifiersep> input <identifiersep> stream ( ) ; logger . debug ( io <identifiersep> utils . to <identifiersep> string ( input <identifiersep> stream , <string_literal> ) ) ; io <identifiersep> utils . close <identifiersep> quietly ( input <identifiersep> stream ) ; } } catch ( exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; <ect>
@ override public void send ( string title , string message ) { try { announcer . send ( title , message ) ; } catch ( announcer <identifiersep> unavailable <identifiersep> exception e ) { <comment> <LOG> } } } <ect>
} else { logger . debug ( <string_literal> , candidate ) ; } } else { if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { logger . debug ( <string_literal> , candidate ) ; } else { <LOG> remote . add ( candidate ) ; is <identifiersep> remote = true ; } } } if ( is <identifiersep> multicast ) { <comment> <ect>
if ( is <identifiersep> multicast ) { <comment> <LOG> multicast <identifiersep> interfaces . add ( network <identifiersep> interface ) ; } } } catch ( socket <identifiersep> exception e ) { <comment> <ect>
} catch ( socket <identifiersep> exception e ) { <comment> <LOG> enumeration < network <identifiersep> interface > network <identifiersep> interfaces = network <identifiersep> interface . get <identifiersep> network <identifiersep> interfaces ( ) ; while ( network <identifiersep> interfaces . has <identifiersep> more <identifiersep> elements ( ) ) { multicast <identifiersep> interfaces . add ( network <identifiersep> interfaces . next <identifiersep> element ( ) ) ; } } public list < inet <identifiersep> address > get <identifiersep> loopback ( ) { return loopback ; } public list < inet <identifiersep> address > get <identifiersep> remote ( ) { <ect>
try { while ( true ) { final socket <identifiersep> channel socket = server <identifiersep> socket . accept ( ) ; inet <identifiersep> socket <identifiersep> address remote <identifiersep> socket <identifiersep> address = ( inet <identifiersep> socket <identifiersep> address ) socket . socket ( ) . get <identifiersep> remote <identifiersep> socket <identifiersep> address ( ) ; inet <identifiersep> address remote <identifiersep> inet <identifiersep> address = remote <identifiersep> socket <identifiersep> address . get <identifiersep> address ( ) ; if ( ! allow <identifiersep> remote && ! address <identifiersep> factory . is <identifiersep> communication <identifiersep> address ( remote <identifiersep> inet <identifiersep> address ) ) { <LOG> socket . close ( ) ; continue ; } logger . debug ( <string_literal> , socket . socket ( ) . get <identifiersep> remote <identifiersep> socket <identifiersep> address ( ) , socket . socket ( ) . get <identifiersep> local <identifiersep> socket <identifiersep> address ( ) ) ; try { action . execute ( new socket <identifiersep> connect <identifiersep> completion ( socket ) ) ; } catch ( throwable t ) { <ect>
} catch ( throwable t ) { socket . close ( ) ; throw t ; } } } catch ( closed <identifiersep> channel <identifiersep> exception e ) { <comment> <LOG> } } finally { composite <identifiersep> stoppable . stoppable ( server <identifiersep> socket ) . stop ( ) ; } } } } <ect>
<comment> <LOG> socket <identifiersep> channel socket <identifiersep> channel ; try { socket <identifiersep> channel = try <identifiersep> connect ( address , candidate ) ; } catch ( socket <identifiersep> exception e ) { logger . debug ( <string_literal> , candidate ) ; last <identifiersep> failure = e ; <ect>
socket <identifiersep> channel = try <identifiersep> connect ( address , candidate ) ; } catch ( socket <identifiersep> exception e ) { logger . debug ( <string_literal> , candidate ) ; last <identifiersep> failure = e ; continue ; } catch ( socket <identifiersep> timeout <identifiersep> exception e ) { <LOG> last <identifiersep> failure = e ; continue ; } logger . debug ( <string_literal> , socket <identifiersep> channel . socket ( ) . get <identifiersep> remote <identifiersep> socket <identifiersep> address ( ) ) ; return new socket <identifiersep> connect <identifiersep> completion ( socket <identifiersep> channel ) ; } throw new org . gradle . internal . remote . internal . connect <identifiersep> exception ( string . format ( <string_literal> , destination <identifiersep> address , candidate <identifiersep> addresses ) , last <identifiersep> failure ) ; <ect>
local <identifiersep> binding <identifiersep> address = openshift <identifiersep> bind <identifiersep> address ; communication <identifiersep> addresses . add ( openshift <identifiersep> bind <identifiersep> address ) ; } } private inet <identifiersep> address find <identifiersep> openshift <identifiersep> addresses ( ) { for ( string key : system . getenv ( ) . key <identifiersep> set ( ) ) { if ( key . starts <identifiersep> with ( <string_literal> ) && key . ends <identifiersep> with ( <string_literal> ) ) { string ip <identifiersep> address = system . getenv ( key ) ; <LOG> try { return inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( ip <identifiersep> address ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( string . format ( <string_literal> , ip <identifiersep> address , key ) , e ) ; } } } return null ; } private void find <identifiersep> communication <identifiersep> addresses ( ) throws unknown <identifiersep> host <identifiersep> exception { <ect>
if ( inet <identifiersep> addresses . get <identifiersep> loopback ( ) . is <identifiersep> empty ( ) ) { if ( inet <identifiersep> addresses . get <identifiersep> remote ( ) . is <identifiersep> empty ( ) ) { inet <identifiersep> address fallback = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( null ) ; logger . debug ( <string_literal> , fallback ) ; communication <identifiersep> addresses . add ( fallback ) ; } else { <LOG> communication <identifiersep> addresses . add <identifiersep> all ( inet <identifiersep> addresses . get <identifiersep> remote ( ) ) ; } } else { communication <identifiersep> addresses . add <identifiersep> all ( inet <identifiersep> addresses . get <identifiersep> loopback ( ) ) ; } } } <ect>
private set < class <identifiersep> loader > method <identifiersep> param <identifiersep> class <identifiersep> loaders = new hash <identifiersep> set < class <identifiersep> loader > ( ) ; private volatile boolean aborted ; public message <identifiersep> hub <identifiersep> backed <identifiersep> object <identifiersep> connection ( executor <identifiersep> factory executor <identifiersep> factory , connect <identifiersep> completion completion ) { action < throwable > error <identifiersep> handler = new action < throwable > ( ) { public void execute ( throwable throwable ) { if ( ! aborted ) { <LOG> } } } ; this . hub = new message <identifiersep> hub ( completion . to <identifiersep> string ( ) , executor <identifiersep> factory , error <identifiersep> handler ) ; this . completion = completion ; } @ override public void use <identifiersep> java <identifiersep> serialization <identifiersep> for <identifiersep> parameters ( class <identifiersep> loader incoming <identifiersep> message <identifiersep> class <identifiersep> loader ) { method <identifiersep> param <identifiersep> class <identifiersep> loaders . add ( incoming <identifiersep> message <identifiersep> class <identifiersep> loader ) ; <ect>
to <identifiersep> string <identifiersep> runtime <identifiersep> exec = failure ; } throwable cause <identifiersep> tmp ; try { cause <identifiersep> tmp = throwable . get <identifiersep> cause ( ) ; } catch ( throwable ignored ) { <comment> <LOG> cause <identifiersep> tmp = null ; } final throwable cause <identifiersep> final = cause <identifiersep> tmp ; stream <identifiersep> byte <identifiersep> buffer buffer = new stream <identifiersep> byte <identifiersep> buffer ( ) ; exception <identifiersep> replacing <identifiersep> object <identifiersep> output <identifiersep> stream oos = object <identifiersep> output <identifiersep> stream <identifiersep> creator . transform ( buffer . get <identifiersep> output <identifiersep> stream ( ) ) ; oos . set <identifiersep> object <identifiersep> transformer ( new transformer < object , object > ( ) { boolean seen <identifiersep> first ; <ect>
} ) ; try { return ( throwable ) ois . read <identifiersep> object ( ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ignored ) { <comment> <LOG> } } try { <comment> <ect>
import org . slf4j . logger ; public class discarding <identifiersep> failure <identifiersep> handler < t > implements dispatch <identifiersep> failure <identifiersep> handler < t > { private final logger logger ; public discarding <identifiersep> failure <identifiersep> handler ( logger logger ) { this . logger = logger ; } public void dispatch <identifiersep> failed ( t message , throwable failure ) { <LOG> } } <ect>
if ( data . contains <identifiersep> key ( <string_literal> ) ) { any <identifiersep> errors = true ; uri project <identifiersep> dir <identifiersep> uri = get <identifiersep> project ( ) . get <identifiersep> project <identifiersep> dir ( ) . to <identifiersep> uri ( ) ; @ suppress <identifiersep> warnings ( <string_literal> ) map < string , object > errors = ( map < string , object > ) data . get ( <string_literal> ) ; if ( ! errors . is <identifiersep> empty ( ) ) { uri relative <identifiersep> path = project <identifiersep> dir <identifiersep> uri . relativize ( file . to <identifiersep> uri ( ) ) ; <LOG> for ( map . entry < string , object > error <identifiersep> entry : errors . entry <identifiersep> set ( ) ) { @ suppress <identifiersep> warnings ( <string_literal> ) map < string , object > error = ( map < string , object > ) error <identifiersep> entry . get <identifiersep> value ( ) ; int line = float . value <identifiersep> of ( error . get ( <string_literal> ) . to <identifiersep> string ( ) ) . int <identifiersep> value ( ) ; int character = float . value <identifiersep> of ( error . get ( <string_literal> ) . to <identifiersep> string ( ) ) . int <identifiersep> value ( ) ; string reason = error . get ( <string_literal> ) . to <identifiersep> string ( ) ; logger . warn ( <string_literal> , new object [ ] { line , character , reason } ) ; <ect>
private static final logger logger = logging . get <identifiersep> logger ( git <identifiersep> version <identifiersep> control <identifiersep> system . class ) ; @ override public file populate ( file version <identifiersep> dir , version <identifiersep> ref ref , version <identifiersep> control <identifiersep> spec spec ) { git <identifiersep> version <identifiersep> control <identifiersep> spec git <identifiersep> spec = cast ( spec ) ; file working <identifiersep> dir = new file ( version <identifiersep> dir , git <identifiersep> spec . get <identifiersep> repo <identifiersep> name ( ) ) ; file db <identifiersep> dir = new file ( working <identifiersep> dir , <string_literal> ) ; <LOG> if ( db <identifiersep> dir . exists ( ) && db <identifiersep> dir . is <identifiersep> directory ( ) ) { update <identifiersep> repo ( working <identifiersep> dir , git <identifiersep> spec , ref ) ; } else { clone <identifiersep> repo ( working <identifiersep> dir , git <identifiersep> spec , ref ) ; } return working <identifiersep> dir ; } @ override <ect>
resolution <identifiersep> strategy { component <identifiersep> selection { all { component <identifiersep> selection selection - > logger . warn ( <string_literal> ) fired < < <string_literal> } with <identifiersep> module ( 'org : parent' ) { component <identifiersep> selection selection - > <LOG> selection . reject ( <string_literal> ) } } } } dependencies { conf <string_literal> } task resolve <identifiersep> conf { do <identifiersep> last { configurations . conf . files <ect>
<comment> public < t extends has <identifiersep> attributes > list < t > match ( attribute <identifiersep> selection <identifiersep> schema schema , collection < ? extends t > candidates , attribute <identifiersep> container <identifiersep> internal requested , @ nullable t fallback ) { if ( candidates . size ( ) == 0 ) { if ( fallback != null && is <identifiersep> matching ( schema , ( attribute <identifiersep> container <identifiersep> internal ) fallback . get <identifiersep> attributes ( ) , requested ) ) { <LOG> } return immutable <identifiersep> list . of ( fallback ) ; logger . debug ( <string_literal> , requested , fallback ) ; } return immutable <identifiersep> list . of ( ) ; } if ( candidates . size ( ) == 1 ) { t candidate = candidates . iterator ( ) . next ( ) ; <ect>
return immutable <identifiersep> list . of ( ) ; } if ( candidates . size ( ) == 1 ) { t candidate = candidates . iterator ( ) . next ( ) ; if ( is <identifiersep> matching ( schema , ( attribute <identifiersep> container <identifiersep> internal ) candidate . get <identifiersep> attributes ( ) , requested ) ) { <LOG> } return collections . singleton <identifiersep> list ( candidate ) ; logger . debug ( <string_literal> , candidates , requested ) ; } return immutable <identifiersep> list . of ( ) ; } immutable <identifiersep> attributes requested <identifiersep> attributes = requested . as <identifiersep> immutable ( ) ; <ect>
logger . debug ( <string_literal> , candidates , requested ) ; } return immutable <identifiersep> list . of ( ) ; } immutable <identifiersep> attributes requested <identifiersep> attributes = requested . as <identifiersep> immutable ( ) ; list < t > matches = new multiple <identifiersep> candidate <identifiersep> matcher < t > ( schema , candidates , requested <identifiersep> attributes ) . get <identifiersep> matches ( ) ; <LOG> } return matches ; } } <ect>
if ( meta <identifiersep> data . is <identifiersep> known <identifiersep> jar <identifiersep> packaging ( ) ) { artifact = meta <identifiersep> data . artifact ( <string_literal> , <string_literal> , null ) ; } else { artifact = meta <identifiersep> data . artifact ( meta <identifiersep> data . get <identifiersep> packaging ( ) , meta <identifiersep> data . get <identifiersep> packaging ( ) , null ) ; } if ( artifact <identifiersep> resolver . artifact <identifiersep> exists ( artifact , new default <identifiersep> resource <identifiersep> aware <identifiersep> resolve <identifiersep> result ( ) ) ) { return true ; } <LOG> return false ; } } } <ect>
} catch ( exception e ) { throw resource <identifiersep> exceptions . failure ( version <identifiersep> list <identifiersep> pattern . get <identifiersep> uri ( ) , string . format ( <string_literal> , pattern ) , e ) ; } } <comment> <LOG> return collections . empty <identifiersep> list ( ) ; } string prefix = pattern . substring ( 0 , pattern . index <identifiersep> of ( revision <identifiersep> token ) ) ; if ( revision <identifiersep> matches <identifiersep> directory <identifiersep> name ( pattern ) ) { external <identifiersep> resource <identifiersep> name parent = version <identifiersep> list <identifiersep> pattern . get <identifiersep> root ( ) . resolve ( prefix ) ; return list <identifiersep> all ( parent , result ) ; } else { <ect>
if ( ! visited <identifiersep> directories . add ( parent ) ) { return collections . empty <identifiersep> list ( ) ; } result . attempted ( parent ) ; list < string > all = repository . resource ( parent ) . list ( ) ; if ( all == null ) { return collections . empty <identifiersep> list ( ) ; } <LOG> pattern regex <identifiersep> pattern = create <identifiersep> regex <identifiersep> pattern ( pattern , parent <identifiersep> folder <identifiersep> slash <identifiersep> index ) ; list < string > ret = filter <identifiersep> matched <identifiersep> values ( all , regex <identifiersep> pattern ) ; logger . debug ( <string_literal> , ret . size ( ) , pattern ) ; return ret ; } } private list < string > filter <identifiersep> matched <identifiersep> values ( list < string > all , final pattern p ) { list < string > ret = new array <identifiersep> list < string > ( all . size ( ) ) ; <ect>
<comment> <LOG> result . attempted ( parent . to <identifiersep> string ( ) ) ; list < string > paths = repository . resource ( parent ) . list ( ) ; if ( paths == null ) { return collections . empty <identifiersep> list ( ) ; } logger . debug ( <string_literal> , paths . size ( ) ) ; return paths ; <ect>
return resolve ( new external <identifiersep> resource <identifiersep> name ( uri ) ) ; } @ nullable @ override public locally <identifiersep> available <identifiersep> external <identifiersep> resource resolve <identifiersep> resource ( external <identifiersep> resource <identifiersep> name resource ) { return resolve ( resource ) ; } private locally <identifiersep> available <identifiersep> external <identifiersep> resource resolve ( final external <identifiersep> resource <identifiersep> name resource ) { <LOG> try { return resource <identifiersep> accessor . get <identifiersep> resource ( resource , null , new cache <identifiersep> aware <identifiersep> external <identifiersep> resource <identifiersep> accessor . resource <identifiersep> file <identifiersep> store ( ) { public locally <identifiersep> available <identifiersep> resource move <identifiersep> into <identifiersep> cache ( file downloaded <identifiersep> resource ) { string key = resource . to <identifiersep> string ( ) ; return file <identifiersep> store . move ( key , downloaded <identifiersep> resource ) ; } } , null ) ; <ect>
} else if ( ! artifact <identifiersep> patterns . is <identifiersep> empty ( ) ) { destination <identifiersep> pattern = artifact <identifiersep> patterns . get ( 0 ) ; } else { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + artifact + <string_literal> + this + <string_literal> ) ; } external <identifiersep> resource <identifiersep> name destination = destination <identifiersep> pattern . get <identifiersep> location ( artifact ) ; put ( src , destination ) ; <LOG> } private void put ( file src , external <identifiersep> resource <identifiersep> name destination ) { repository . with <identifiersep> progress <identifiersep> logging ( ) . resource ( destination ) . put ( new file <identifiersep> readable <identifiersep> content ( src ) ) ; put <identifiersep> checksum ( src , destination ) ; } private void put <identifiersep> checksum ( file source , external <identifiersep> resource <identifiersep> name destination ) { byte [ ] checksum <identifiersep> file = create <identifiersep> checksum <identifiersep> file ( source , <string_literal> , <number_literal> ) ; external <identifiersep> resource <identifiersep> name checksum <identifiersep> destination = destination . append ( <string_literal> ) ; <ect>
for ( resource <identifiersep> pattern resource <identifiersep> pattern : pattern <identifiersep> list ) { if ( is <identifiersep> incomplete ( resource <identifiersep> pattern , artifact ) ) { continue ; } external <identifiersep> resource <identifiersep> name module <identifiersep> dir = resource <identifiersep> pattern . to <identifiersep> module <identifiersep> version <identifiersep> path ( artifact . get <identifiersep> component <identifiersep> id ( ) ) ; external <identifiersep> resource <identifiersep> name location = module <identifiersep> dir . resolve ( artifact . get <identifiersep> relative <identifiersep> url ( ) ) ; result . attempted ( location ) ; <LOG> locally <identifiersep> available <identifiersep> resource <identifiersep> candidates local <identifiersep> candidates = locally <identifiersep> available <identifiersep> resource <identifiersep> finder . find <identifiersep> candidates ( artifact ) ; try { locally <identifiersep> available <identifiersep> external <identifiersep> resource resource = resource <identifiersep> accessor . get <identifiersep> resource ( location , artifact . get <identifiersep> id ( ) . get <identifiersep> file <identifiersep> name ( ) , new cache <identifiersep> aware <identifiersep> external <identifiersep> resource <identifiersep> accessor . resource <identifiersep> file <identifiersep> store ( ) { public locally <identifiersep> available <identifiersep> resource move <identifiersep> into <identifiersep> cache ( file downloaded <identifiersep> resource ) { return file <identifiersep> store . move ( artifact . get <identifiersep> id ( ) , downloaded <identifiersep> resource ) ; } } , local <identifiersep> candidates ) ; <ect>
this . artifact <identifiersep> extension = <string_literal> ; this . mutable <identifiersep> module <identifiersep> metadata <identifiersep> factory = mutable <identifiersep> module <identifiersep> metadata <identifiersep> factory ; } @ override public mutable <identifiersep> module <identifiersep> component <identifiersep> resolve <identifiersep> metadata create ( string repository <identifiersep> name , component <identifiersep> resolvers component <identifiersep> resolvers , module <identifiersep> component <identifiersep> identifier module <identifiersep> component <identifiersep> identifier , component <identifiersep> override <identifiersep> metadata prescribed <identifiersep> meta <identifiersep> data , external <identifiersep> resource <identifiersep> artifact <identifiersep> resolver artifact <identifiersep> resolver , buildable <identifiersep> module <identifiersep> component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> result result ) { mutable <identifiersep> module <identifiersep> component <identifiersep> resolve <identifiersep> metadata meta <identifiersep> data <identifiersep> from <identifiersep> default <identifiersep> artifact = create <identifiersep> meta <identifiersep> data <identifiersep> from <identifiersep> dependency <identifiersep> artifact ( module <identifiersep> component <identifiersep> identifier , prescribed <identifiersep> meta <identifiersep> data , artifact <identifiersep> resolver , result ) ; if ( meta <identifiersep> data <identifiersep> from <identifiersep> default <identifiersep> artifact != null ) { <LOG> return meta <identifiersep> data <identifiersep> from <identifiersep> default <identifiersep> artifact ; } return null ; } private mutable <identifiersep> module <identifiersep> component <identifiersep> resolve <identifiersep> metadata create <identifiersep> meta <identifiersep> data <identifiersep> from <identifiersep> dependency <identifiersep> artifact ( module <identifiersep> component <identifiersep> identifier module <identifiersep> component <identifiersep> identifier , component <identifiersep> override <identifiersep> metadata override <identifiersep> metadata , external <identifiersep> resource <identifiersep> artifact <identifiersep> resolver artifact <identifiersep> resolver , resource <identifiersep> aware <identifiersep> resolve <identifiersep> result result ) { list < ivy <identifiersep> artifact <identifiersep> name > artifact <identifiersep> names = get <identifiersep> artifact <identifiersep> names ( module <identifiersep> component <identifiersep> identifier , override <identifiersep> metadata ) ; for ( ivy <identifiersep> artifact <identifiersep> name artifact : artifact <identifiersep> names ) { if ( artifact <identifiersep> resolver . artifact <identifiersep> exists ( new default <identifiersep> module <identifiersep> component <identifiersep> artifact <identifiersep> metadata ( module <identifiersep> component <identifiersep> identifier , artifact ) , result ) ) { <ect>
if ( is <identifiersep> drive <identifiersep> relative <identifiersep> windows <identifiersep> path ( file ) ) { return file . get <identifiersep> absolute <identifiersep> file ( ) ; } else { return file ; } } else { file default <identifiersep> location = new file ( system . get <identifiersep> property ( <string_literal> ) , <string_literal> ) . get <identifiersep> absolute <identifiersep> file ( ) ; <LOG> return default <identifiersep> location ; } } catch ( settings <identifiersep> building <identifiersep> exception e ) { throw new cannot <identifiersep> locate <identifiersep> local <identifiersep> maven <identifiersep> repository <identifiersep> exception ( <string_literal> , e ) ; } } private boolean is <identifiersep> drive <identifiersep> relative <identifiersep> windows <identifiersep> path ( file file ) { return ! file . is <identifiersep> absolute ( ) && file . get <identifiersep> path ( ) . starts <identifiersep> with ( file . separator ) ; } <comment> <ect>
module <identifiersep> component <identifiersep> at <identifiersep> repository <identifiersep> key key = create <identifiersep> key ( repository , id ) ; module <identifiersep> metadata <identifiersep> cache <identifiersep> entry entry = module <identifiersep> metadata <identifiersep> cache <identifiersep> entry . for <identifiersep> missing <identifiersep> module ( time <identifiersep> provider . get <identifiersep> current <identifiersep> time ( ) ) ; default <identifiersep> cached <identifiersep> metadata cached <identifiersep> meta <identifiersep> data = new default <identifiersep> cached <identifiersep> metadata ( entry , null , time <identifiersep> provider ) ; store ( key , entry , cached <identifiersep> meta <identifiersep> data ) ; return cached <identifiersep> meta <identifiersep> data ; } public cached <identifiersep> metadata cache <identifiersep> meta <identifiersep> data ( module <identifiersep> component <identifiersep> repository repository , final module <identifiersep> component <identifiersep> identifier id , final module <identifiersep> component <identifiersep> resolve <identifiersep> metadata metadata ) { <LOG> final module <identifiersep> component <identifiersep> at <identifiersep> repository <identifiersep> key key = create <identifiersep> key ( repository , id ) ; module <identifiersep> metadata <identifiersep> cache <identifiersep> entry entry = create <identifiersep> entry ( metadata ) ; default <identifiersep> cached <identifiersep> metadata cached <identifiersep> meta <identifiersep> data = new default <identifiersep> cached <identifiersep> metadata ( entry , metadata , time <identifiersep> provider ) ; store ( key , entry , cached <identifiersep> meta <identifiersep> data ) ; return cached <identifiersep> meta <identifiersep> data ; } protected void store ( module <identifiersep> component <identifiersep> at <identifiersep> repository <identifiersep> key key , module <identifiersep> metadata <identifiersep> cache <identifiersep> entry entry , cached <identifiersep> metadata cached <identifiersep> meta <identifiersep> data ) { <ect>
public module <identifiersep> component <identifiersep> repository provide <identifiersep> resolved <identifiersep> artifact <identifiersep> cache ( module <identifiersep> component <identifiersep> repository input ) { map < component <identifiersep> artifact <identifiersep> identifier , resolvable <identifiersep> artifact > caches = get <identifiersep> resolved <identifiersep> artifact <identifiersep> cache ( input ) ; return new resolved <identifiersep> artifact <identifiersep> cache <identifiersep> providing <identifiersep> module <identifiersep> component <identifiersep> repository ( caches , input ) ; } private map < component <identifiersep> artifact <identifiersep> identifier , resolvable <identifiersep> artifact > get <identifiersep> resolved <identifiersep> artifact <identifiersep> cache ( module <identifiersep> component <identifiersep> repository input ) { map < component <identifiersep> artifact <identifiersep> identifier , resolvable <identifiersep> artifact > resolved <identifiersep> artifact <identifiersep> cache = cache <identifiersep> per <identifiersep> repo . get ( input . get <identifiersep> id ( ) ) ; if ( resolved <identifiersep> artifact <identifiersep> cache == null ) { <LOG> resolved <identifiersep> artifact <identifiersep> cache = maps . new <identifiersep> concurrent <identifiersep> map ( ) ; cache <identifiersep> per <identifiersep> repo . put ( input . get <identifiersep> id ( ) , resolved <identifiersep> artifact <identifiersep> cache ) ; } else { log . debug ( <string_literal> , input . get <identifiersep> name ( ) , input . get <identifiersep> id ( ) ) ; } return resolved <identifiersep> artifact <identifiersep> cache ; } public void stop ( ) { <ect>
final list < edge <identifiersep> state > dependencies = lists . new <identifiersep> array <identifiersep> list ( ) ; final map < module <identifiersep> version <identifiersep> identifier , component <identifiersep> identifier > component <identifiersep> identifier <identifiersep> cache = maps . new <identifiersep> hash <identifiersep> map ( ) ; final pending <identifiersep> dependencies <identifiersep> handler pending <identifiersep> dependencies <identifiersep> handler = new default <identifiersep> pending <identifiersep> dependencies <identifiersep> handler ( ) ; while ( resolve <identifiersep> state . peek ( ) != null || module <identifiersep> conflict <identifiersep> handler . has <identifiersep> conflicts ( ) || capabilities <identifiersep> conflict <identifiersep> handler . has <identifiersep> conflicts ( ) ) { if ( resolve <identifiersep> state . peek ( ) != null ) { final node <identifiersep> state node = resolve <identifiersep> state . pop ( ) ; <LOG> <comment> <ect>
if ( ! c . conflict <identifiersep> exists ( ) ) { <comment> <LOG> <comment> <ect>
values <identifiersep> read ++ ; switch ( type ) { case root : <comment> <LOG> return root ; case component : component <identifiersep> result component = component <identifiersep> result <identifiersep> serializer . read ( decoder ) ; builder . visit <identifiersep> component ( component ) ; break ; case selector : <ect>
case root : id = decoder . read <identifiersep> small <identifiersep> long ( ) ; root = all <identifiersep> dependencies . get ( id ) ; if ( root == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( string . format ( <string_literal> , id , all <identifiersep> dependencies . key <identifiersep> set ( ) ) ) ; } <comment> <LOG> return new default <identifiersep> transient <identifiersep> configuration <identifiersep> results ( root , first <identifiersep> level <identifiersep> dependencies ) ; case first <identifiersep> level : id = decoder . read <identifiersep> small <identifiersep> long ( ) ; default <identifiersep> resolved <identifiersep> dependency dependency = all <identifiersep> dependencies . get ( id ) ; if ( dependency == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( string . format ( <string_literal> , id , all <identifiersep> dependencies . key <identifiersep> set ( ) ) ) ; <ect>
process <identifiersep> rules ( spec <identifiersep> rule <identifiersep> actions , with <identifiersep> inputs , selection , metadata <identifiersep> provider ) ; } } private boolean process <identifiersep> rules ( collection < spec <identifiersep> rule <identifiersep> action < ? super component <identifiersep> selection > > spec <identifiersep> rule <identifiersep> actions , spec < spec <identifiersep> rule <identifiersep> action < ? super component <identifiersep> selection > > filter , component <identifiersep> selection <identifiersep> internal selection , metadata <identifiersep> provider metadata <identifiersep> provider ) { for ( spec <identifiersep> rule <identifiersep> action < ? super component <identifiersep> selection > rule : spec <identifiersep> rule <identifiersep> actions ) { if ( filter . is <identifiersep> satisfied <identifiersep> by ( rule ) ) { process <identifiersep> rule ( rule , selection , metadata <identifiersep> provider ) ; if ( selection . is <identifiersep> rejected ( ) ) { <LOG> return false ; } } } return true ; } private void process <identifiersep> rule ( spec <identifiersep> rule <identifiersep> action < ? super component <identifiersep> selection > rule , component <identifiersep> selection selection , metadata <identifiersep> provider metadata <identifiersep> provider ) { if ( ! rule . get <identifiersep> spec ( ) . is <identifiersep> satisfied <identifiersep> by ( selection ) ) { return ; } list < object > input <identifiersep> values = get <identifiersep> input <identifiersep> values ( rule . get <identifiersep> action ( ) . get <identifiersep> input <identifiersep> types ( ) , metadata <identifiersep> provider ) ; <ect>
private void resolve <identifiersep> component <identifiersep> meta <identifiersep> data <identifiersep> from <identifiersep> cache ( module <identifiersep> component <identifiersep> identifier module <identifiersep> component <identifiersep> identifier , component <identifiersep> override <identifiersep> metadata request <identifiersep> meta <identifiersep> data , buildable <identifiersep> module <identifiersep> component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> result result ) { module <identifiersep> metadata <identifiersep> cache . cached <identifiersep> metadata cached <identifiersep> metadata = module <identifiersep> metadata <identifiersep> cache . get <identifiersep> cached <identifiersep> module <identifiersep> descriptor ( delegate , module <identifiersep> component <identifiersep> identifier ) ; if ( cached <identifiersep> metadata == null ) { return ; } if ( cached <identifiersep> metadata . is <identifiersep> missing ( ) ) { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> missing <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { <LOG> return ; } logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; result . missing ( ) ; <comment> <ect>
<comment> <LOG> return ; } logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; } else { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> module <identifiersep> version ( ) , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; return ; <ect>
if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> changing <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> module <identifiersep> version ( ) , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; return ; } logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; } else { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> module <identifiersep> version ( ) , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { <LOG> return ; } } logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; metadata = metadata . with <identifiersep> source ( new caching <identifiersep> module <identifiersep> source ( metadata . get <identifiersep> content <identifiersep> hash ( ) . as <identifiersep> big <identifiersep> integer ( ) , metadata . is <identifiersep> changing ( ) , metadata . get <identifiersep> source ( ) ) ) ; result . resolved ( metadata ) ; <comment> <ect>
big <identifiersep> integer module <identifiersep> descriptor <identifiersep> hash = cached <identifiersep> module <identifiersep> source . get <identifiersep> descriptor <identifiersep> hash ( ) ; if ( cached <identifiersep> module <identifiersep> artifacts != null ) { if ( ! cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> module <identifiersep> artifacts ( component . get <identifiersep> module <identifiersep> version <identifiersep> id ( ) , null , cached <identifiersep> module <identifiersep> artifacts . get <identifiersep> age <identifiersep> millis ( ) , cached <identifiersep> module <identifiersep> source . is <identifiersep> changing <identifiersep> module ( ) , module <identifiersep> descriptor <identifiersep> hash . equals ( cached <identifiersep> module <identifiersep> artifacts . get <identifiersep> descriptor <identifiersep> hash ( ) ) ) ) { result . resolved ( cached <identifiersep> module <identifiersep> artifacts . get <identifiersep> artifacts ( ) ) ; return ; } <LOG> } } @ override public void resolve <identifiersep> artifact ( component <identifiersep> artifact <identifiersep> metadata artifact , module <identifiersep> source module <identifiersep> source , buildable <identifiersep> artifact <identifiersep> resolve <identifiersep> result result ) { final caching <identifiersep> module <identifiersep> source cached <identifiersep> module <identifiersep> source = ( caching <identifiersep> module <identifiersep> source ) module <identifiersep> source ; <comment> <ect>
for ( string location : cached . attempted <identifiersep> locations ( ) ) { result . attempted ( location ) ; } result . not <identifiersep> found ( artifact . get <identifiersep> id ( ) ) ; } } else { file cached <identifiersep> artifact <identifiersep> file = cached . get <identifiersep> cached <identifiersep> file ( ) ; if ( ! cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> artifact ( artifact <identifiersep> identifier , cached <identifiersep> artifact <identifiersep> file , age , is <identifiersep> changing <identifiersep> module , descriptor <identifiersep> hash . equals ( cached . get <identifiersep> descriptor <identifiersep> hash ( ) ) ) ) { <LOG> result . resolved ( cached <identifiersep> artifact <identifiersep> file ) ; } } } } } private class resolve <identifiersep> and <identifiersep> cache <identifiersep> repository <identifiersep> access implements module <identifiersep> component <identifiersep> repository <identifiersep> access { @ override public string to <identifiersep> string ( ) { return <string_literal> + delegate . get <identifiersep> remote <identifiersep> access ( ) . to <identifiersep> string ( ) ; } @ override <ect>
default <identifiersep> conf <identifiersep> mapping <identifiersep> descriptor = new default <identifiersep> dependency <identifiersep> descriptor ( create <identifiersep> module <identifiersep> revision <identifiersep> id ( <string_literal> , <string_literal> , <string_literal> ) , false ) ; parse <identifiersep> deps <identifiersep> confs ( default <identifiersep> conf <identifiersep> mapping , default <identifiersep> conf <identifiersep> mapping <identifiersep> descriptor , false , false ) ; } return default <identifiersep> conf <identifiersep> mapping <identifiersep> descriptor ; } protected void add <identifiersep> error ( string msg ) { errors . add ( msg + <string_literal> + res . get <identifiersep> display <identifiersep> name ( ) ) ; } public void warning ( sax <identifiersep> parse <identifiersep> exception ex ) { <LOG> } public void error ( sax <identifiersep> parse <identifiersep> exception ex ) { add <identifiersep> error ( <string_literal> + get <identifiersep> location <identifiersep> string ( ex ) + <string_literal> + ex . get <identifiersep> message ( ) ) ; } public void fatal <identifiersep> error ( sax <identifiersep> parse <identifiersep> exception ex ) throws sax <identifiersep> exception { add <identifiersep> error ( <string_literal> + get <identifiersep> location <identifiersep> string ( ex ) + <string_literal> + ex . get <identifiersep> message ( ) ) ; } <comment> private string get <identifiersep> location <identifiersep> string ( sax <identifiersep> parse <identifiersep> exception ex ) { <ect>
conf <identifiersep> started ( attributes ) ; } else if ( <string_literal> . equals ( q <identifiersep> name ) ) { dd . add <identifiersep> dependency <identifiersep> configuration ( conf , substitute ( attributes . get <identifiersep> value ( <string_literal> ) ) ) ; } else if ( ( <string_literal> . equals ( q <identifiersep> name ) && state == state . deps ) || <string_literal> . equals ( q <identifiersep> name ) && state == state . conflict ) { logger . debug ( <string_literal> , get <identifiersep> resource ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; } else if ( <string_literal> . equals ( q <identifiersep> name ) && state == state . deps ) { <LOG> } else if ( <string_literal> . equals ( q <identifiersep> name ) && state == state . conf ) { include <identifiersep> conf <identifiersep> started ( attributes ) ; } else if ( validate && state != state . extra <identifiersep> info && state != state . description ) { add <identifiersep> error ( <string_literal> + q <identifiersep> name ) ; } } catch ( exception ex ) { if ( ex instanceof sax <identifiersep> exception ) { <ect>
parent = parse <identifiersep> other <identifiersep> ivy <identifiersep> file <identifiersep> on <identifiersep> file <identifiersep> system ( location ) ; if ( parent != null ) { <comment> <LOG> parent = null ; } } <comment> <ect>
logger . debug ( <string_literal> , configuration . get <identifiersep> name ( ) ) ; <comment> <LOG> md . add <identifiersep> dependency ( dependency <identifiersep> descriptor ) ; } } private void merge <identifiersep> description ( string description ) { string current = get <identifiersep> md ( ) . get <identifiersep> description ( ) ; if ( current == null || current . trim ( ) . length ( ) == 0 ) { get <identifiersep> md ( ) . set <identifiersep> description ( description ) ; } } private module <identifiersep> descriptor parse <identifiersep> other <identifiersep> ivy <identifiersep> file <identifiersep> on <identifiersep> file <identifiersep> system ( string location ) <ect>
parser <identifiersep> helper . parse ( url , null , parser ) ; <comment> <LOG> set <identifiersep> default <identifiersep> conf <identifiersep> mapping ( parser . get <identifiersep> default <identifiersep> conf <identifiersep> mapping ( ) ) ; } if ( parser . get <identifiersep> default <identifiersep> conf ( ) != null ) { logger . debug ( <string_literal> , parser . get <identifiersep> default <identifiersep> conf ( ) ) ; set <identifiersep> default <identifiersep> conf ( parser . get <identifiersep> default <identifiersep> conf ( ) ) ; } if ( parser . get <identifiersep> md ( ) . is <identifiersep> mapping <identifiersep> override ( ) ) { logger . debug ( <string_literal> ) ; <ect>
logger . debug ( <string_literal> , parser . get <identifiersep> default <identifiersep> conf <identifiersep> mapping ( ) ) ; set <identifiersep> default <identifiersep> conf <identifiersep> mapping ( parser . get <identifiersep> default <identifiersep> conf <identifiersep> mapping ( ) ) ; } if ( parser . get <identifiersep> default <identifiersep> conf ( ) != null ) { logger . debug ( <string_literal> , parser . get <identifiersep> default <identifiersep> conf ( ) ) ; set <identifiersep> default <identifiersep> conf ( parser . get <identifiersep> default <identifiersep> conf ( ) ) ; } if ( parser . get <identifiersep> md ( ) . is <identifiersep> mapping <identifiersep> override ( ) ) { <LOG> get <identifiersep> md ( ) . set <identifiersep> mapping <identifiersep> override ( true ) ; } } private void conf <identifiersep> started ( attributes attributes ) { string conf = substitute ( attributes . get <identifiersep> value ( <string_literal> ) ) ; switch ( state ) { case conf : configuration . visibility visibility = configuration . visibility . get <identifiersep> visibility ( elvis ( substitute ( attributes . get <identifiersep> value ( <string_literal> ) ) , <string_literal> ) ) ; <ect>
add <identifiersep> error ( <string_literal> + descriptor <identifiersep> version ) ; throw new sax <identifiersep> exception ( <string_literal> + descriptor <identifiersep> version ) ; } if ( version <identifiersep> index >= allowed <identifiersep> versions . index <identifiersep> of ( <string_literal> ) ) { logger . debug ( <string_literal> , pattern <identifiersep> matcher . exact ) ; default <identifiersep> matcher = get <identifiersep> matcher ( pattern <identifiersep> matcher . exact ) ; } else { <LOG> default <identifiersep> matcher = get <identifiersep> matcher ( pattern <identifiersep> matcher . exact <identifiersep> or <identifiersep> regexp ) ; } for ( int i = 0 ; i < attributes . get <identifiersep> length ( ) ; i ++ ) { if ( attributes . get <identifiersep> q <identifiersep> name ( i ) . starts <identifiersep> with ( <string_literal> ) ) { get <identifiersep> md ( ) . add <identifiersep> extra <identifiersep> attribute <identifiersep> namespace ( attributes . get <identifiersep> q <identifiersep> name ( i ) . substring ( <string_literal> . length ( ) ) , attributes . get <identifiersep> value ( i ) ) ; } } } private void description <identifiersep> started ( string q <identifiersep> name , attributes attributes ) { buffer . append ( <string_literal> ) . append ( q <identifiersep> name ) ; <ect>
module <identifiersep> version <identifiersep> identifier relocation = pom <identifiersep> reader . get <identifiersep> relocation ( ) ; if ( relocation != null ) { if ( group <identifiersep> id != null && artifact <identifiersep> id != null && artifact <identifiersep> id . equals ( relocation . get <identifiersep> name ( ) ) && group <identifiersep> id . equals ( relocation . get <identifiersep> group ( ) ) ) { logger . error ( <string_literal> , md <identifiersep> builder . get <identifiersep> component <identifiersep> identifier ( ) , relocation ) ; logger . warn ( <string_literal> , relocation ) ; <LOG> pom <identifiersep> reader relocated <identifiersep> module = parse <identifiersep> pom <identifiersep> for <identifiersep> id ( parser <identifiersep> settings , default <identifiersep> module <identifiersep> component <identifiersep> identifier . new <identifiersep> id ( relocation ) , maps . < string , string > new <identifiersep> hash <identifiersep> map ( ) ) ; add <identifiersep> dependencies ( md <identifiersep> builder , relocated <identifiersep> module ) ; } else { logger . info ( md <identifiersep> builder . get <identifiersep> component <identifiersep> identifier ( ) + <string_literal> + relocation + <string_literal> ) ; <ect>
final string item <identifiersep> name private static final string id = uuid . random <identifiersep> uuid ( ) . to <identifiersep> string ( ) @ inject public test <identifiersep> parallel <identifiersep> runnable ( string item <identifiersep> name ) { this . item <identifiersep> name = item <identifiersep> name } public void run ( ) { <LOG> new uri ( <string_literal> , null , <string_literal> , $ { blocking <identifiersep> http <identifiersep> server . get <identifiersep> port ( ) } , <string_literal> , null , null ) . to <identifiersep> url ( ) . text file output <identifiersep> dir = new file ( <string_literal> ) file output <identifiersep> file = new file ( output <identifiersep> dir , item <identifiersep> name ) file <identifiersep> helper . write ( id , output <identifiersep> file ) } } <string_literal> <string_literal> <ect>
logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) . warn ( <string_literal> ) ; logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) . debug ( <string_literal> ) ; logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) . error ( <string_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . warning ( <string_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . fine ( <string_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . severe ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
while ( it . has <identifiersep> next ( ) ) { worker <identifiersep> daemon <identifiersep> client candidate = it . next ( ) ; if ( candidate . is <identifiersep> compatible <identifiersep> with ( fork <identifiersep> options ) ) { it . remove ( ) ; if ( candidate . get <identifiersep> log <identifiersep> level ( ) != current <identifiersep> log <identifiersep> level ) { <comment> <LOG> candidate . stop ( ) ; } else { return candidate ; } } } return null ; } } public worker <identifiersep> daemon <identifiersep> client reserve <identifiersep> new <identifiersep> client ( class < ? extends worker <identifiersep> protocol < action <identifiersep> execution <identifiersep> spec > > worker <identifiersep> protocol <identifiersep> implementation <identifiersep> class , daemon <identifiersep> fork <identifiersep> options fork <identifiersep> options ) { <comment> <ect>
if ( ! clients <identifiersep> to <identifiersep> stop . is <identifiersep> empty ( ) ) { stop <identifiersep> workers ( clients <identifiersep> to <identifiersep> stop ) ; } } } private void stop <identifiersep> workers ( list < worker <identifiersep> daemon <identifiersep> client > clients <identifiersep> to <identifiersep> stop ) { if ( clients <identifiersep> to <identifiersep> stop . size ( ) > 0 ) { logger . debug ( <string_literal> , clients <identifiersep> to <identifiersep> stop . size ( ) ) ; composite <identifiersep> stoppable . stoppable ( clients <identifiersep> to <identifiersep> stop ) . stop ( ) ; <LOG> idle <identifiersep> clients . remove <identifiersep> all ( clients <identifiersep> to <identifiersep> stop ) ; all <identifiersep> clients . remove <identifiersep> all ( clients <identifiersep> to <identifiersep> stop ) ; } } private class stop <identifiersep> session <identifiersep> scoped <identifiersep> workers implements session <identifiersep> lifecycle <identifiersep> listener { @ override public void after <identifiersep> start ( ) { } @ override <ect>
public long attempt <identifiersep> to <identifiersep> release ( long memory <identifiersep> amount <identifiersep> bytes ) throws illegal <identifiersep> argument <identifiersep> exception { if ( memory <identifiersep> amount <identifiersep> bytes < 0 ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( boolean . value <identifiersep> of ( system . get <identifiersep> property ( disable <identifiersep> expiration <identifiersep> property <identifiersep> key , <string_literal> ) ) ) { logger . debug ( <string_literal> ) ; return 0l ; } <LOG> simple <identifiersep> memory <identifiersep> expiration <identifiersep> selector selector = new simple <identifiersep> memory <identifiersep> expiration <identifiersep> selector ( memory <identifiersep> amount <identifiersep> bytes ) ; clients <identifiersep> manager . select <identifiersep> idle <identifiersep> clients <identifiersep> to <identifiersep> stop ( selector ) ; return selector . get <identifiersep> released <identifiersep> bytes ( ) ; } <comment> <ect>
private final worker <identifiersep> process <identifiersep> factory worker <identifiersep> daemon <identifiersep> process <identifiersep> factory ; private final logging <identifiersep> manager logging <identifiersep> manager ; public worker <identifiersep> daemon <identifiersep> starter ( worker <identifiersep> process <identifiersep> factory worker <identifiersep> daemon <identifiersep> process <identifiersep> factory , logging <identifiersep> manager logging <identifiersep> manager ) { this . worker <identifiersep> daemon <identifiersep> process <identifiersep> factory = worker <identifiersep> daemon <identifiersep> process <identifiersep> factory ; this . logging <identifiersep> manager = logging <identifiersep> manager ; } public < t extends work <identifiersep> spec > worker <identifiersep> daemon <identifiersep> client start <identifiersep> daemon ( class < ? extends worker <identifiersep> protocol < action <identifiersep> execution <identifiersep> spec > > worker <identifiersep> protocol <identifiersep> implementation <identifiersep> class , daemon <identifiersep> fork <identifiersep> options fork <identifiersep> options ) { <LOG> timer clock = time . start <identifiersep> timer ( ) ; multi <identifiersep> request <identifiersep> worker <identifiersep> process <identifiersep> builder < worker <identifiersep> daemon <identifiersep> process > builder = worker <identifiersep> daemon <identifiersep> process <identifiersep> factory . multi <identifiersep> request <identifiersep> worker ( worker <identifiersep> daemon <identifiersep> process . class , worker <identifiersep> protocol . class , worker <identifiersep> protocol <identifiersep> implementation <identifiersep> class ) ; builder . set <identifiersep> base <identifiersep> name ( <string_literal> ) ; builder . set <identifiersep> log <identifiersep> level ( logging <identifiersep> manager . get <identifiersep> level ( ) ) ; <comment> <ect>
@ cacheable <identifiersep> task class custom <identifiersep> task extends default <identifiersep> task { @ output <identifiersep> file file output <identifiersep> file = new file ( temporary <identifiersep> dir , <string_literal> ) @ input string run = project . find <identifiersep> property ( <string_literal> ) ? : <string_literal> @ task <identifiersep> action void generate ( ) { <LOG> project . copy { from ( <string_literal> ) into temporary <identifiersep> dir } } } task cacheable ( type : custom <identifiersep> task ) { description = <string_literal> } <string_literal> <string_literal> <ect>
local != null && local . is <identifiersep> enabled ( ) , remote != null && remote . is <identifiersep> enabled ( ) && remote <identifiersep> access <identifiersep> mode == remote <identifiersep> access <identifiersep> mode . online , local <identifiersep> described <identifiersep> service == null ? null : local <identifiersep> described <identifiersep> service . description , remote <identifiersep> described <identifiersep> service == null ? null : remote <identifiersep> described <identifiersep> service . description ) ) ; if ( ! local <identifiersep> enabled && ! remote <identifiersep> enabled ) { <LOG> return no <identifiersep> op <identifiersep> build <identifiersep> cache <identifiersep> controller . instance ; } else { build <identifiersep> cache <identifiersep> services <identifiersep> configuration config = to <identifiersep> configuration ( local , local <identifiersep> described <identifiersep> service == null ? null : local <identifiersep> described <identifiersep> service . service , remote , remote <identifiersep> described <identifiersep> service == null ? null : remote <identifiersep> described <identifiersep> service . service ) ; <ect>
logger . warn ( description , e ) ; } else { logger . warn ( description + <string_literal> + e . get <identifiersep> message ( ) ) ; } } } @ override public void close ( ) { <LOG> if ( disabled ) { logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) ) ; } try { service . close ( ) ; } catch ( exception e ) { if ( log <identifiersep> stack <identifiersep> traces ) { <ect>
if ( disabled ) { logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) ) ; } try { service . close ( ) ; } catch ( exception e ) { if ( log <identifiersep> stack <identifiersep> traces ) { <LOG> } else { logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) , e . get <identifiersep> message ( ) ) ; } } } } <ect>
public < t extends build <identifiersep> cache > t local ( class < t > type ) { return local ( type , actions . do <identifiersep> nothing ( ) ) ; } @ override public < t extends build <identifiersep> cache > t local ( class < t > type , action < ? super t > configuration ) { if ( ! type . is <identifiersep> instance ( local ) ) { if ( local != null ) { <LOG> } local = create <identifiersep> local <identifiersep> cache <identifiersep> configuration ( instantiator , type , registrations ) ; } t configuration <identifiersep> object = cast . unchecked <identifiersep> cast ( local ) ; configuration . execute ( configuration <identifiersep> object ) ; return configuration <identifiersep> object ; } @ override public void local ( action < ? super build <identifiersep> cache > configuration ) { <ect>
return get <identifiersep> build <identifiersep> cache <identifiersep> service <identifiersep> factory <identifiersep> type ( configuration <identifiersep> type , registrations ) ; } private static < t extends build <identifiersep> cache > class < ? extends build <identifiersep> cache <identifiersep> service <identifiersep> factory < t > > get <identifiersep> build <identifiersep> cache <identifiersep> service <identifiersep> factory <identifiersep> type ( class < t > configuration <identifiersep> type , set < build <identifiersep> cache <identifiersep> service <identifiersep> registration > registrations ) { for ( build <identifiersep> cache <identifiersep> service <identifiersep> registration registration : registrations ) { class < ? extends build <identifiersep> cache > registered <identifiersep> configuration <identifiersep> type = registration . get <identifiersep> configuration <identifiersep> type ( ) ; if ( registered <identifiersep> configuration <identifiersep> type . is <identifiersep> assignable <identifiersep> from ( configuration <identifiersep> type ) ) { class < ? extends build <identifiersep> cache <identifiersep> service <identifiersep> factory < ? > > build <identifiersep> cache <identifiersep> service <identifiersep> factory <identifiersep> type = registration . get <identifiersep> factory <identifiersep> type ( ) ; <LOG> return cast . unchecked <identifiersep> cast ( build <identifiersep> cache <identifiersep> service <identifiersep> factory <identifiersep> type ) ; } } <comment> <ect>
} else { target = cache <identifiersep> scope <identifiersep> mapping . get <identifiersep> base <identifiersep> directory ( null , build <identifiersep> cache <identifiersep> key , version <identifiersep> strategy . shared <identifiersep> cache ) ; } check <identifiersep> directory ( target ) ; int remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days = configuration . get <identifiersep> remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days ( ) ; describer . type ( directory <identifiersep> build <identifiersep> cache <identifiersep> type ) . config ( <string_literal> , target . get <identifiersep> absolute <identifiersep> path ( ) ) . <LOG> path <identifiersep> key <identifiersep> file <identifiersep> store file <identifiersep> store = file <identifiersep> store <identifiersep> factory . create <identifiersep> file <identifiersep> store ( target ) ; persistent <identifiersep> cache persistent <identifiersep> cache = cache <identifiersep> repository . cache ( target ) . with <identifiersep> cleanup ( cleanup <identifiersep> action <identifiersep> factory . create ( new fixed <identifiersep> age <identifiersep> oldest <identifiersep> cache <identifiersep> cleanup ( remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days ) ) ) . with <identifiersep> display <identifiersep> name ( <string_literal> ) . with <identifiersep> lock <identifiersep> options ( mode ( none ) ) <ect>
if ( credential . handle <identifiersep> response ( request , response , supports <identifiersep> retry ) ) { <comment> <LOG> return true ; } else { return false ; } } } ) ; request . set <identifiersep> io <identifiersep> exception <identifiersep> handler ( new http <identifiersep> back <identifiersep> off <identifiersep> io <identifiersep> exception <identifiersep> handler ( new exponential <identifiersep> back <identifiersep> off ( ) ) . set <identifiersep> sleeper ( sleeper ) ) ; <ect>
public list < string > list ( uri parent ) throws resource <identifiersep> exception { logger . debug ( <string_literal> , parent ) ; return gcs <identifiersep> client . list ( parent ) ; } @ nullable @ override public external <identifiersep> resource <identifiersep> read <identifiersep> response open <identifiersep> resource ( uri location , boolean revalidate ) throws resource <identifiersep> exception { <LOG> storage <identifiersep> object gcs <identifiersep> object = gcs <identifiersep> client . get <identifiersep> resource ( location ) ; if ( gcs <identifiersep> object == null ) { return null ; } return new gcs <identifiersep> resource ( gcs <identifiersep> client , gcs <identifiersep> object , location ) ; } @ nullable @ override <ect>
storage <identifiersep> object gcs <identifiersep> object = gcs <identifiersep> client . get <identifiersep> resource ( location ) ; if ( gcs <identifiersep> object == null ) { return null ; } return to <identifiersep> external <identifiersep> resource <identifiersep> meta <identifiersep> data ( location , gcs <identifiersep> object ) ; } @ override public void upload ( readable <identifiersep> content resource , uri destination ) throws io <identifiersep> exception { <LOG> input <identifiersep> stream input <identifiersep> stream = resource . open ( ) ; try { gcs <identifiersep> client . put ( input <identifiersep> stream , resource . get <identifiersep> content <identifiersep> length ( ) , destination ) ; } finally { input <identifiersep> stream . close ( ) ; } } } <ect>
timer timer = new timer ( ) ; for ( android <identifiersep> project android <identifiersep> project : models . values ( ) ) { if ( android <identifiersep> project == null ) { continue ; } inspect ( android <identifiersep> project ) ; } timer . stop ( ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; <ect>
if ( android <identifiersep> project == null ) { continue ; } inspect ( android <identifiersep> project ) ; } timer . stop ( ) ; system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; <ect>
inspect ( android <identifiersep> project ) ; } timer . stop ( ) ; system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; <LOG> system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; <LOG> system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> ) ; } private void inspect ( android <identifiersep> project android <identifiersep> project ) { for ( variant variant : android <identifiersep> project . get <identifiersep> variants ( ) ) { <ect>
system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; <LOG> system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> ) ; } private void inspect ( android <identifiersep> project android <identifiersep> project ) { for ( variant variant : android <identifiersep> project . get <identifiersep> variants ( ) ) { inspect ( variant . get <identifiersep> main <identifiersep> artifact ( ) . get <identifiersep> dependencies ( ) ) ; for ( android <identifiersep> artifact other <identifiersep> artifact : variant . get <identifiersep> extra <identifiersep> android <identifiersep> artifacts ( ) ) { <ect>
system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; <LOG> } private void inspect ( android <identifiersep> project android <identifiersep> project ) { for ( variant variant : android <identifiersep> project . get <identifiersep> variants ( ) ) { inspect ( variant . get <identifiersep> main <identifiersep> artifact ( ) . get <identifiersep> dependencies ( ) ) ; for ( android <identifiersep> artifact other <identifiersep> artifact : variant . get <identifiersep> extra <identifiersep> android <identifiersep> artifacts ( ) ) { inspect ( other <identifiersep> artifact . get <identifiersep> dependencies ( ) ) ; } } } private void inspect ( dependencies dependencies ) { <ect>
boolean has <identifiersep> simulation = options . has ( sync ) ; if ( options . has ( sync ) || has <identifiersep> simulation ) { <comment> <LOG> system . out . println ( <string_literal> + gradle <identifiersep> version . current ( ) . get <identifiersep> version ( ) ) ; timer timer = new timer ( ) ; gradle <identifiersep> connector gradle <identifiersep> connector = gradle <identifiersep> connector . new <identifiersep> connector ( ) ; gradle <identifiersep> connector . for <identifiersep> project <identifiersep> directory ( build <identifiersep> dir ) ; ( ( default <identifiersep> gradle <identifiersep> connector ) gradle <identifiersep> connector ) . embedded ( embedded ) ; if ( gradle <identifiersep> install <identifiersep> dir != null ) { <ect>
try { for ( int i = 0 ; i < <number_literal> ; i ++ ) { sync <identifiersep> action . with <identifiersep> project <identifiersep> connection ( connect , null ) ; } } finally { connect . close ( ) ; } timer . stop ( ) ; <LOG> } } <ect>
string scheme = get <identifiersep> auth <identifiersep> scheme ( authentication ) ; password <identifiersep> credentials credentials = get <identifiersep> password <identifiersep> credentials ( authentication ) ; if ( authentication instanceof all <identifiersep> schemes <identifiersep> authentication ) { ntlm <identifiersep> credentials ntlm <identifiersep> credentials = new ntlm <identifiersep> credentials ( credentials ) ; http <identifiersep> credentials = new nt <identifiersep> credentials ( ntlm <identifiersep> credentials . get <identifiersep> username ( ) , ntlm <identifiersep> credentials . get <identifiersep> password ( ) , ntlm <identifiersep> credentials . get <identifiersep> workstation ( ) , ntlm <identifiersep> credentials . get <identifiersep> domain ( ) ) ; credentials <identifiersep> provider . set <identifiersep> credentials ( new auth <identifiersep> scope ( host , port , auth <identifiersep> scope . any <identifiersep> realm , auth <identifiersep> schemes . ntlm ) , http <identifiersep> credentials ) ; <LOG> } http <identifiersep> credentials = new username <identifiersep> password <identifiersep> credentials ( credentials . get <identifiersep> username ( ) , credentials . get <identifiersep> password ( ) ) ; credentials <identifiersep> provider . set <identifiersep> credentials ( new auth <identifiersep> scope ( host , port , auth <identifiersep> scope . any <identifiersep> realm , scheme ) , http <identifiersep> credentials ) ; logger . debug ( <string_literal> , credentials , host , port , scheme ) ; } } private boolean is <identifiersep> preemptive <identifiersep> enabled ( collection < authentication > authentications ) { return collection <identifiersep> utils . any ( authentications , new spec < authentication > ( ) { @ override <ect>
private list < uri > resolve <identifiersep> ur <identifiersep> is ( uri base <identifiersep> uri , list < string > hrefs ) { list < uri > uris = new array <identifiersep> list < uri > ( ) ; for ( string href : hrefs ) { try { uris . add ( base <identifiersep> uri . resolve ( href ) ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { <LOG> } } return uris ; } private class anchor <identifiersep> lister <identifiersep> handler extends default <identifiersep> handler { list < string > hrefs = new array <identifiersep> list < string > ( ) ; public list < string > get <identifiersep> hrefs ( ) { return hrefs ; } public void start <identifiersep> element ( string uri , string local <identifiersep> name , string q <identifiersep> name , attributes atts ) throws sax <identifiersep> exception { <ect>
private final http <identifiersep> client <identifiersep> helper http ; public http <identifiersep> resource <identifiersep> accessor ( http <identifiersep> client <identifiersep> helper http ) { this . http = http ; } @ nullable public http <identifiersep> response <identifiersep> resource open <identifiersep> resource ( final uri uri , boolean revalidate ) { string location = uri . to <identifiersep> string ( ) ; <LOG> closeable <identifiersep> http <identifiersep> response response = http . perform <identifiersep> get ( location , revalidate ) ; if ( response != null ) { return wrap <identifiersep> response ( uri , response ) ; } return null ; } <comment> <ect>
string location = uri . to <identifiersep> string ( ) ; logger . debug ( <string_literal> , location ) ; closeable <identifiersep> http <identifiersep> response response = http . perform <identifiersep> raw <identifiersep> get ( location , revalidate ) ; return wrap <identifiersep> response ( uri , response ) ; } public external <identifiersep> resource <identifiersep> meta <identifiersep> data get <identifiersep> meta <identifiersep> data ( uri uri , boolean revalidate ) { string location = uri . to <identifiersep> string ( ) ; <LOG> closeable <identifiersep> http <identifiersep> response response = http . perform <identifiersep> head ( location , revalidate ) ; external <identifiersep> resource <identifiersep> meta <identifiersep> data result = null ; if ( response != null ) { http <identifiersep> response <identifiersep> resource resource = new http <identifiersep> response <identifiersep> resource ( <string_literal> , uri , response ) ; try { result = resource . get <identifiersep> meta <identifiersep> data ( ) ; <ect>
<comment> <LOG> return null ; } if ( ! was <identifiersep> successful ( response ) ) { logger . info ( <string_literal> , method , response . get <identifiersep> status <identifiersep> line ( ) , source ) ; throw new http <identifiersep> error <identifiersep> status <identifiersep> code <identifiersep> exception ( method , source , response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> status <identifiersep> code ( ) , response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> reason <identifiersep> phrase ( ) ) ; } return response ; } private synchronized closeable <identifiersep> http <identifiersep> client get <identifiersep> client ( ) { <ect>
public class unresolved <identifiersep> ide <identifiersep> dependency <identifiersep> handler { private final logger logger = logging . get <identifiersep> logger ( unresolved <identifiersep> ide <identifiersep> dependency <identifiersep> handler . class ) ; public void log ( collection < unresolved <identifiersep> dependency <identifiersep> result > deps ) { for ( unresolved <identifiersep> dependency <identifiersep> result dep : deps ) { log ( dep ) ; } } public void log ( unresolved <identifiersep> dependency <identifiersep> result dep ) { <LOG> logger . debug ( <string_literal> + dep . get <identifiersep> attempted ( ) , dep . get <identifiersep> failure ( ) ) ; } public file as <identifiersep> file ( unresolved <identifiersep> dependency <identifiersep> result dep ) { return new file ( <string_literal> + dep . get <identifiersep> attempted ( ) . get <identifiersep> display <identifiersep> name ( ) . replace <identifiersep> all ( <string_literal> , <string_literal> ) ) ; } } <ect>
clean <identifiersep> task . depends <identifiersep> on ( clean <identifiersep> worker ) ; } } protected void on <identifiersep> apply ( project target ) { } protected void add <identifiersep> workspace ( final ide <identifiersep> workspace workspace ) { lifecycle <identifiersep> task . do <identifiersep> last ( new action < task > ( ) { @ override public void execute ( task task ) { <LOG> } } ) ; task open <identifiersep> task = project . get <identifiersep> tasks ( ) . create ( <string_literal> + string <identifiersep> utils . capitalize ( get <identifiersep> lifecycle <identifiersep> task <identifiersep> name ( ) ) ) ; open <identifiersep> task . depends <identifiersep> on ( lifecycle <identifiersep> task ) ; open <identifiersep> task . set <identifiersep> group ( <string_literal> ) ; open <identifiersep> task . set <identifiersep> description ( <string_literal> + workspace . get <identifiersep> display <identifiersep> name ( ) ) ; open <identifiersep> task . do <identifiersep> last ( new action < task > ( ) { <ect>
import org . gradle . api . * ; import org . gradle . api . tasks . * ; public class custom <identifiersep> plugin implements plugin < project > { public static class custom <identifiersep> task extends default <identifiersep> task { @ task <identifiersep> action void print <identifiersep> it ( ) { <LOG> } } @ override public void apply ( project p ) { p . get <identifiersep> tasks ( ) . create ( <string_literal> , custom <identifiersep> task . class ) ; } } ''' file ( 'build <identifiersep> src / src / main / resources / meta - <number_literal> / gradle - plugins / custom . properties' ) < < 'implementation - class = custom <identifiersep> plugin' build <identifiersep> file < < <string_literal> <ect>
public class antlr <identifiersep> executer implements antlr <identifiersep> worker { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( antlr <identifiersep> executer . class ) ; @ override public antlr <identifiersep> result run <identifiersep> antlr ( antlr <identifiersep> spec spec ) { antlr <identifiersep> tool antlr <identifiersep> tool = new antlr4tool ( ) ; if ( antlr <identifiersep> tool . available ( ) ) { <LOG> return antlr <identifiersep> tool . process ( spec ) ; } antlr <identifiersep> tool = new antlr3tool ( ) ; if ( antlr <identifiersep> tool . available ( ) ) { logger . info ( <string_literal> ) ; return antlr <identifiersep> tool . process ( spec ) ; } antlr <identifiersep> tool = new antlr2tool ( ) ; <ect>
antlr <identifiersep> tool = new antlr3tool ( ) ; if ( antlr <identifiersep> tool . available ( ) ) { logger . info ( <string_literal> ) ; return antlr <identifiersep> tool . process ( spec ) ; } antlr <identifiersep> tool = new antlr2tool ( ) ; if ( antlr <identifiersep> tool . available ( ) ) { <LOG> return antlr <identifiersep> tool . process ( spec ) ; } throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } private static class antlr3tool extends antlr <identifiersep> tool { @ override int invoke ( list < string > arguments , file input <identifiersep> directory ) throws class <identifiersep> not <identifiersep> found <identifiersep> exception { final object backed <identifiersep> object = load <identifiersep> tool ( <string_literal> , null ) ; <ect>
root . add <identifiersep> link ( registration ) ; return this ; } @ override public void register <identifiersep> node ( model <identifiersep> node <identifiersep> internal node , multimap < model <identifiersep> action <identifiersep> role , ? extends model <identifiersep> action > actions ) { <comment> <LOG> add <identifiersep> rule <identifiersep> bindings ( node , actions ) ; model <identifiersep> graph . add ( node ) ; rule <identifiersep> bindings . node <identifiersep> created ( node ) ; } private void add <identifiersep> rule <identifiersep> bindings ( model <identifiersep> node <identifiersep> internal node , multimap < model <identifiersep> action <identifiersep> role , ? extends model <identifiersep> action > actions ) { for ( map . entry < model <identifiersep> action <identifiersep> role , ? extends model <identifiersep> action > entry : actions . entries ( ) ) { model <identifiersep> action <identifiersep> role role = entry . get <identifiersep> key ( ) ; <ect>
private void fire <identifiersep> action ( rule <identifiersep> binder bound <identifiersep> mutator ) { final list < model <identifiersep> view < ? > > inputs = to <identifiersep> views ( bound <identifiersep> mutator . get <identifiersep> input <identifiersep> bindings ( ) , bound <identifiersep> mutator . get <identifiersep> action ( ) . get <identifiersep> descriptor ( ) ) ; model <identifiersep> binding subject <identifiersep> binding = bound <identifiersep> mutator . get <identifiersep> subject <identifiersep> binding ( ) ; final model <identifiersep> node <identifiersep> internal node = subject <identifiersep> binding . get <identifiersep> node ( ) ; final model <identifiersep> action mutator = bound <identifiersep> mutator . get <identifiersep> action ( ) ; model <identifiersep> rule <identifiersep> descriptor descriptor = mutator . get <identifiersep> descriptor ( ) ; <LOG> try { rule <identifiersep> context . run ( descriptor , new runnable ( ) { @ override public void run ( ) { mutator . execute ( node , inputs ) ; } } ) ; <ect>
return true ; } @ override void attach <identifiersep> to <identifiersep> cycle ( list < string > display <identifiersep> value ) { display <identifiersep> value . add ( binder . get <identifiersep> descriptor ( ) . to <identifiersep> string ( ) ) ; } @ override void apply ( ) { <LOG> fire <identifiersep> action ( binder ) ; node . notify <identifiersep> fired ( binder ) ; } } private class notify <identifiersep> discovered extends model <identifiersep> node <identifiersep> goal { protected notify <identifiersep> discovered ( model <identifiersep> path target ) { super ( target ) ; } @ override <ect>
if ( clients <identifiersep> by <identifiersep> host . is <identifiersep> empty ( ) ) { logger . debug ( <string_literal> ) ; client = create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) ; } else { client = clients <identifiersep> by <identifiersep> host . remove ( 0 ) ; if ( ! client . is <identifiersep> connected ( ) ) { <LOG> discard ( client ) ; client = reuse <identifiersep> existing <identifiersep> or <identifiersep> create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) ; } else { logger . debug ( <string_literal> ) ; } } return client ; } private lockable <identifiersep> sftp <identifiersep> client create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host sftp <identifiersep> host ) { <ect>
public class s3resource <identifiersep> connector implements external <identifiersep> resource <identifiersep> connector { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( s3resource <identifiersep> connector . class ) ; private final s3client s3client ; public s3resource <identifiersep> connector ( s3client s3client ) { this . s3client = s3client ; } public list < string > list ( uri parent ) { <LOG> return s3client . list <identifiersep> direct <identifiersep> children ( parent ) ; } public external <identifiersep> resource <identifiersep> read <identifiersep> response open <identifiersep> resource ( uri location , boolean revalidate ) { logger . debug ( <string_literal> , location ) ; s3object s3object = s3client . get <identifiersep> resource ( location ) ; if ( s3object == null ) { return null ; <ect>
logger . debug ( <string_literal> , location ) ; s3object s3object = s3client . get <identifiersep> resource ( location ) ; if ( s3object == null ) { return null ; } return new s3resource ( s3object , location ) ; } public external <identifiersep> resource <identifiersep> meta <identifiersep> data get <identifiersep> meta <identifiersep> data ( uri location , boolean revalidate ) { <LOG> s3object s3object = s3client . get <identifiersep> meta <identifiersep> data ( location ) ; if ( s3object == null ) { return null ; } try { object <identifiersep> metadata object <identifiersep> metadata = s3object . get <identifiersep> object <identifiersep> metadata ( ) ; return new default <identifiersep> external <identifiersep> resource <identifiersep> meta <identifiersep> data ( location , <ect>
string bucket <identifiersep> name = s3regional <identifiersep> resource . get <identifiersep> bucket <identifiersep> name ( ) ; string s3bucket <identifiersep> key = s3regional <identifiersep> resource . get <identifiersep> key ( ) ; configure <identifiersep> client ( s3regional <identifiersep> resource ) ; object <identifiersep> metadata object <identifiersep> metadata = new object <identifiersep> metadata ( ) ; object <identifiersep> metadata . set <identifiersep> content <identifiersep> length ( content <identifiersep> length ) ; put <identifiersep> object <identifiersep> request put <identifiersep> object <identifiersep> request = new put <identifiersep> object <identifiersep> request ( bucket <identifiersep> name , s3bucket <identifiersep> key , input <identifiersep> stream , object <identifiersep> metadata ) ; <LOG> amazon <identifiersep> s3client . put <identifiersep> object ( put <identifiersep> object <identifiersep> request ) ; } catch ( amazon <identifiersep> client <identifiersep> exception e ) { throw resource <identifiersep> exceptions . put <identifiersep> failed ( destination , e ) ; } } public s3object get <identifiersep> meta <identifiersep> data ( uri uri ) { logger . debug ( <string_literal> , uri . to <identifiersep> string ( ) ) ; <comment> <ect>
throw resource <identifiersep> exceptions . put <identifiersep> failed ( destination , e ) ; } } public s3object get <identifiersep> meta <identifiersep> data ( uri uri ) { logger . debug ( <string_literal> , uri . to <identifiersep> string ( ) ) ; <comment> <LOG> return do <identifiersep> get <identifiersep> s3object ( uri , false ) ; } public list < string > list <identifiersep> direct <identifiersep> children ( uri parent ) { s3regional <identifiersep> resource s3regional <identifiersep> resource = new s3regional <identifiersep> resource ( parent ) ; string bucket <identifiersep> name = s3regional <identifiersep> resource . get <identifiersep> bucket <identifiersep> name ( ) ; string s3bucket <identifiersep> key = s3regional <identifiersep> resource . get <identifiersep> key ( ) ; configure <identifiersep> client ( s3regional <identifiersep> resource ) ; <ect>
<comment> public < t extends task & java <identifiersep> fork <identifiersep> options > void apply <identifiersep> to ( final t task ) { final string task <identifiersep> name = task . get <identifiersep> name ( ) ; <LOG> final jacoco <identifiersep> task <identifiersep> extension extension = task . get <identifiersep> extensions ( ) . create ( task <identifiersep> extension <identifiersep> name , jacoco <identifiersep> task <identifiersep> extension . class , project , agent , task ) ; extension . set <identifiersep> destination <identifiersep> file ( project . provider ( new callable < file > ( ) { @ override public file call ( ) throws exception { return project . file ( string . value <identifiersep> of ( project . get <identifiersep> build <identifiersep> dir ( ) ) + <string_literal> + task <identifiersep> name + <string_literal> ) ; } } ) ) ; <ect>
return active && thread . current <identifiersep> thread ( ) == owner <identifiersep> thread ; } @ override protected boolean acquire <identifiersep> lock ( ) { if ( parent . grant <identifiersep> lease ( ) ) { active = true ; <LOG> } } else { logger . debug ( <string_literal> , get <identifiersep> display <identifiersep> name ( ) , root . leases <identifiersep> in <identifiersep> use ) ; } } return active ; } @ override protected void release <identifiersep> lock ( ) { <ect>
if ( thread . current <identifiersep> thread ( ) != owner <identifiersep> thread ) { <comment> <LOG> } if ( children != 0 ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } } @ override public boolean grant <identifiersep> lease ( ) { if ( children == 0 || root . grant <identifiersep> lease ( ) ) { children ++ ; <ect>
return true ; } } @ override public void unlock ( ) { fail <identifiersep> if <identifiersep> not <identifiersep> in <identifiersep> resource <identifiersep> lock <identifiersep> state <identifiersep> change ( ) ; if ( is <identifiersep> locked <identifiersep> by <identifiersep> current <identifiersep> thread ( ) ) { release <identifiersep> lock ( ) ; <LOG> unlock <identifiersep> action . execute ( this ) ; coordination <identifiersep> service . get <identifiersep> current ( ) . register <identifiersep> unlocked ( this ) ; } } @ override public boolean is <identifiersep> locked ( ) { fail <identifiersep> if <identifiersep> not <identifiersep> in <identifiersep> resource <identifiersep> lock <identifiersep> state <identifiersep> change ( ) ; return do <identifiersep> is <identifiersep> locked ( ) ; <ect>
import spock . lang . timeout @ timeout ( <number_literal> ) class http <identifiersep> build <identifiersep> cache <identifiersep> service <identifiersep> integration <identifiersep> test extends abstract <identifiersep> integration <identifiersep> spec implements http <identifiersep> build <identifiersep> cache <identifiersep> fixture { static final string original <identifiersep> hello <identifiersep> world = <string_literal> <string_literal> <LOG> } } <string_literal> <string_literal> <string_literal> public class hello { public static void main ( string . . . args ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
add <identifiersep> diagnostic <identifiersep> headers ( http <identifiersep> get ) ; closeable <identifiersep> http <identifiersep> response response = null ; try { response = http <identifiersep> client <identifiersep> helper . perform <identifiersep> http <identifiersep> request ( http <identifiersep> get ) ; status <identifiersep> line status <identifiersep> line = response . get <identifiersep> status <identifiersep> line ( ) ; <LOG> } int status <identifiersep> code = status <identifiersep> line . get <identifiersep> status <identifiersep> code ( ) ; if ( is <identifiersep> http <identifiersep> success ( status <identifiersep> code ) ) { reader . read <identifiersep> from ( response . get <identifiersep> entity ( ) . get <identifiersep> content ( ) ) ; return true ; } else if ( status <identifiersep> code == http <identifiersep> status . sc <identifiersep> not <identifiersep> found ) { return false ; <ect>
no <identifiersep> exception <identifiersep> thrown ( ) } def <string_literal> ( ) { <comment> <LOG> logger . info ( <string_literal> ) <string_literal> <string_literal> <ect>
class standard <identifiersep> streams <identifiersep> cross <identifiersep> version <identifiersep> spec extends tooling <identifiersep> api <identifiersep> logging <identifiersep> specification { @ rule redirect <identifiersep> std <identifiersep> out <identifiersep> and <identifiersep> err std <identifiersep> out <identifiersep> and <identifiersep> err = new redirect <identifiersep> std <identifiersep> out <identifiersep> and <identifiersep> err ( ) def escape <identifiersep> header = <string_literal> @ target <identifiersep> gradle <identifiersep> version ( <string_literal> ) def <string_literal> ( ) { file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> project . logger . warn ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; task log { <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> error log message <string_literal> warn log message <string_literal> lifecycle log message <string_literal> quiet log message <string_literal> info log message <string_literal> <LOG> task log { do <identifiersep> last { println <string_literal> } } <string_literal> <string_literal> <ect>
! std <identifiersep> out <identifiersep> and <identifiersep> err . std <identifiersep> out . contains ( <string_literal> ) ! std <identifiersep> out <identifiersep> and <identifiersep> err . std <identifiersep> err . contains ( <string_literal> ) } @ target <identifiersep> gradle <identifiersep> version ( <string_literal> ) def <string_literal> ( ) { file ( <string_literal> ) < < <string_literal> <string_literal> error logging <string_literal> <LOG> project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; task log { do <identifiersep> last { <ect>
if ( args . length > 0 ) { connector . use <identifiersep> installation ( new file ( args [ 0 ] ) ) ; } <comment> <LOG> <comment> <ect>
launcher . set <identifiersep> standard <identifiersep> output ( output <identifiersep> stream ) ; launcher . set <identifiersep> standard <identifiersep> error ( output <identifiersep> stream ) ; launcher . set <identifiersep> color <identifiersep> output ( $ { with <identifiersep> color } ) ; system . out . println ( <string_literal> + $ { with <identifiersep> color } ) ; <comment> <LOG> } finally { <comment> <ect>
launcher . run ( ) ; system . out . println ( <string_literal> ) ; } finally { <comment> <LOG> } } } <string_literal> <string_literal> <ect>
private final class <identifiersep> loader class <identifiersep> loader ; public default <identifiersep> tooling <identifiersep> implementation <identifiersep> loader ( ) { this ( default <identifiersep> tooling <identifiersep> implementation <identifiersep> loader . class . get <identifiersep> class <identifiersep> loader ( ) ) ; } default <identifiersep> tooling <identifiersep> implementation <identifiersep> loader ( class <identifiersep> loader class <identifiersep> loader ) { this . class <identifiersep> loader = class <identifiersep> loader ; } public consumer <identifiersep> connection create ( distribution distribution , progress <identifiersep> logger <identifiersep> factory progress <identifiersep> logger <identifiersep> factory , internal <identifiersep> build <identifiersep> progress <identifiersep> listener progress <identifiersep> listener , connection <identifiersep> parameters connection <identifiersep> parameters , build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token ) { <LOG> class <identifiersep> loader service <identifiersep> class <identifiersep> loader = create <identifiersep> implementation <identifiersep> class <identifiersep> loader ( distribution , progress <identifiersep> logger <identifiersep> factory , progress <identifiersep> listener , connection <identifiersep> parameters . get <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( ) , cancellation <identifiersep> token ) ; service <identifiersep> locator service <identifiersep> locator = new default <identifiersep> service <identifiersep> locator ( service <identifiersep> class <identifiersep> loader ) ; try { factory < connection <identifiersep> version4 > factory = service <identifiersep> locator . find <identifiersep> factory ( connection <identifiersep> version4 . class ) ; if ( factory == null ) { return new no <identifiersep> tooling <identifiersep> api <identifiersep> connection ( distribution ) ; <ect>
return delegate . run ( type , operation <identifiersep> parameters ) ; } finally { handle <identifiersep> cancellation <identifiersep> post <identifiersep> operation ( operation <identifiersep> parameters . get <identifiersep> cancellation <identifiersep> token ( ) , callback ) ; } } private runnable handle <identifiersep> cancellation <identifiersep> pre <identifiersep> operation ( build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token ) { runnable callback = new runnable ( ) { public void run ( ) { <LOG> } } ; cancellation <identifiersep> token . add <identifiersep> callback ( callback ) ; return callback ; } private void handle <identifiersep> cancellation <identifiersep> post <identifiersep> operation ( build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token , runnable callback ) { cancellation <identifiersep> token . remove <identifiersep> callback ( callback ) ; } } <ect>
* builder . add <identifiersep> progress <identifiersep> listener ( listener ) ; * * <comment> <LOG> * } finally { * connection . close ( ) ; * } * < / pre > * * @ param < t > the type of model to build <ect>
* . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) * . connect ( ) ; * * try { * build <identifiersep> environment env = connection . get <identifiersep> model ( build <identifiersep> environment . class ) ; * system . out . println ( <string_literal> + env . get <identifiersep> gradle ( ) . get <identifiersep> gradle <identifiersep> version ( ) ) ; <LOG> * } finally { * connection . close ( ) ; * } * < / pre > * * @ since 1 . 0 - milestone - <number_literal> <ect>
options . annotation <identifiersep> processor <identifiersep> path = files ( ) } <string_literal> <string_literal> <LOG> } } ''' expect : succeeds <string_literal> ! file ( 'build / classes / java / main / test <identifiersep> app <identifiersep> helper . class' ) . exists ( ) } def <string_literal> ( ) { build <identifiersep> file < < <string_literal> <string_literal> <ect>
options . compiler <identifiersep> args < < <string_literal> } <string_literal> <string_literal> <LOG> } } ''' expect : succeeds <string_literal> ! file ( 'build / classes / java / main / test <identifiersep> app <identifiersep> helper . class' ) . exists ( ) } def <string_literal> ( ) { build <identifiersep> file < < <string_literal> <string_literal> <ect>
apply <identifiersep> java <identifiersep> plugin ( build <identifiersep> file ) main <identifiersep> library <identifiersep> depending <identifiersep> on <identifiersep> api ( ) file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { private string name ; public void say <identifiersep> hello ( ) { <LOG> } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' and : <ect>
succeeds ' : main <identifiersep> jar' when : update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { private string name ; public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
when : update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { private string name ; private int age ; public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
public class person { private string name ; public void say <identifiersep> hello ( @ ann2 ( b = <string_literal> , a = <string_literal> ) @ ann1 ( <string_literal> ) string intro ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { @ ann2 ( b = <string_literal> , a = <string_literal> ) @ ann1 ( <string_literal> ) public string name ; public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
logger . quiet ( builder . to <identifiersep> string ( ) ) ; } private void log <identifiersep> compiler <identifiersep> arguments ( java <identifiersep> compile <identifiersep> spec spec ) { return ; } list < string > compiler <identifiersep> args = new java <identifiersep> compiler <identifiersep> arguments <identifiersep> builder ( spec ) . include <identifiersep> launcher <identifiersep> options ( true ) . include <identifiersep> source <identifiersep> files ( true ) . build ( ) ; string joined <identifiersep> args = joiner . on ( ' ' ) . join ( compiler <identifiersep> args ) ; <LOG> } private work <identifiersep> result delegate <identifiersep> and <identifiersep> handle <identifiersep> errors ( java <identifiersep> compile <identifiersep> spec spec ) { try { return delegate . execute ( spec ) ; } catch ( compilation <identifiersep> failed <identifiersep> exception e ) { if ( spec . get <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> fail <identifiersep> on <identifiersep> error ( ) ) { throw e ; <ect>
try { list < string > processor <identifiersep> class <identifiersep> names = get <identifiersep> processor <identifiersep> class <identifiersep> names ( classes <identifiersep> dir ) ; try { map < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > processor <identifiersep> types = get <identifiersep> processor <identifiersep> types ( classes <identifiersep> dir ) ; return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , processor <identifiersep> types ) ; } catch ( exception e ) { <LOG> return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , collections . < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > empty <identifiersep> map ( ) ) ; } } catch ( exception e ) { logger . warn ( <string_literal> + classes <identifiersep> dir + <string_literal> , log <identifiersep> stack <identifiersep> traces ? e : null ) ; return collections . empty <identifiersep> list ( ) ; } } private list < string > get <identifiersep> processor <identifiersep> class <identifiersep> names ( file classes <identifiersep> dir ) throws io <identifiersep> exception { file processor <identifiersep> declaration = new file ( classes <identifiersep> dir , processor <identifiersep> declaration ) ; <ect>
try { list < string > processor <identifiersep> class <identifiersep> names = get <identifiersep> processor <identifiersep> class <identifiersep> names ( zip <identifiersep> file ) ; try { map < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > processor <identifiersep> types = get <identifiersep> processor <identifiersep> types ( zip <identifiersep> file ) ; return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , processor <identifiersep> types ) ; } catch ( exception e ) { <LOG> return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , collections . < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > empty <identifiersep> map ( ) ) ; } } finally { zip <identifiersep> file . close ( ) ; } } catch ( exception e ) { logger . warn ( <string_literal> + jar + <string_literal> , log <identifiersep> stack <identifiersep> traces ? e : null ) ; return collections . empty <identifiersep> list ( ) ; <ect>
public command <identifiersep> line <identifiersep> java <identifiersep> compiler ( exec <identifiersep> handle <identifiersep> factory exec <identifiersep> handle <identifiersep> factory ) { this . exec <identifiersep> handle <identifiersep> factory = exec <identifiersep> handle <identifiersep> factory ; } @ override public work <identifiersep> result execute ( java <identifiersep> compile <identifiersep> spec spec ) { final fork <identifiersep> options fork <identifiersep> options = spec . get <identifiersep> compile <identifiersep> options ( ) . get <identifiersep> fork <identifiersep> options ( ) ; string executable = fork <identifiersep> options . get <identifiersep> java <identifiersep> home ( ) != null ? jvm . for <identifiersep> home ( fork <identifiersep> options . get <identifiersep> java <identifiersep> home ( ) ) . get <identifiersep> javac <identifiersep> executable ( ) . get <identifiersep> absolute <identifiersep> path ( ) : fork <identifiersep> options . get <identifiersep> executable ( ) ; <LOG> exec <identifiersep> handle handle = create <identifiersep> compiler <identifiersep> handle ( executable , spec ) ; execute <identifiersep> compiler ( handle ) ; return work <identifiersep> results . did <identifiersep> work ( true ) ; } private exec <identifiersep> handle create <identifiersep> compiler <identifiersep> handle ( string executable , java <identifiersep> compile <identifiersep> spec spec ) { exec <identifiersep> handle <identifiersep> builder builder = exec <identifiersep> handle <identifiersep> factory . new <identifiersep> exec ( ) ; builder . set <identifiersep> working <identifiersep> dir ( spec . get <identifiersep> working <identifiersep> dir ( ) ) ; <ect>
this . classpath <identifiersep> jar <identifiersep> finder = classpath <identifiersep> jar <identifiersep> finder ; } @ override public void store <identifiersep> jar <identifiersep> snapshots ( iterable < file > classpath ) { maybe <identifiersep> initialize ( classpath ) ; <comment> <LOG> } @ override public jar <identifiersep> classpath <identifiersep> snapshot get <identifiersep> jar <identifiersep> classpath <identifiersep> snapshot ( iterable < file > classpath ) { maybe <identifiersep> initialize ( classpath ) ; <comment> <ect>
timer clock = time . start <identifiersep> timer ( ) ; iterable < jar <identifiersep> archive > jar <identifiersep> archives = classpath <identifiersep> jar <identifiersep> finder . find <identifiersep> jar <identifiersep> archives ( classpath ) ; jar <identifiersep> classpath <identifiersep> snapshot = classpath <identifiersep> snapshot <identifiersep> factory . create <identifiersep> snapshot ( jar <identifiersep> archives ) ; int duplicates <identifiersep> count = jar <identifiersep> classpath <identifiersep> snapshot . get <identifiersep> data ( ) . get <identifiersep> duplicate <identifiersep> classes ( ) . size ( ) ; string duplicate <identifiersep> classes <identifiersep> message = duplicates <identifiersep> count == 0 ? <string_literal> : <string_literal> + duplicates <identifiersep> count + <string_literal> ; log . info ( <string_literal> , clock . get <identifiersep> elapsed ( ) , duplicate <identifiersep> classes <identifiersep> message ) ; <LOG> } } <ect>
return new incremental <identifiersep> annotation <identifiersep> processing <identifiersep> compiler ( compilation <identifiersep> finalizer , annotation <identifiersep> processor <identifiersep> detector ) ; } private compiler < java <identifiersep> compile <identifiersep> spec > get <identifiersep> compiler ( incremental <identifiersep> task <identifiersep> inputs inputs , compilation <identifiersep> source <identifiersep> dirs source <identifiersep> dirs ) { if ( ! inputs . is <identifiersep> incremental ( ) ) { log . info ( <string_literal> , display <identifiersep> name ) ; return cleaning <identifiersep> compiler ; } if ( ! source <identifiersep> dirs . can <identifiersep> infer <identifiersep> source <identifiersep> roots ( ) ) { <LOG> return cleaning <identifiersep> compiler ; } list < annotation <identifiersep> processor <identifiersep> declaration > non <identifiersep> incremental <identifiersep> processors = get <identifiersep> non <identifiersep> incremental <identifiersep> processors ( ) ; if ( ! non <identifiersep> incremental <identifiersep> processors . is <identifiersep> empty ( ) ) { warn <identifiersep> about <identifiersep> non <identifiersep> incremental <identifiersep> processors ( non <identifiersep> incremental <identifiersep> processors ) ; return cleaning <identifiersep> compiler ; } class <identifiersep> set <identifiersep> analysis <identifiersep> data data = compile <identifiersep> caches . get <identifiersep> local <identifiersep> class <identifiersep> set <identifiersep> analysis <identifiersep> store ( ) . get ( ) ; <ect>
return non <identifiersep> incremental <identifiersep> processors ; } private void warn <identifiersep> about <identifiersep> non <identifiersep> incremental <identifiersep> processors ( list < annotation <identifiersep> processor <identifiersep> declaration > non <identifiersep> incremental <identifiersep> processors ) { string <identifiersep> builder processor <identifiersep> listing = new string <identifiersep> builder ( ) ; for ( annotation <identifiersep> processor <identifiersep> declaration processor : non <identifiersep> incremental <identifiersep> processors ) { processor <identifiersep> listing . append ( text <identifiersep> util . get <identifiersep> platform <identifiersep> line <identifiersep> separator ( ) ) . append ( ' \\ t' ) . append ( processor ) ; } <LOG> } } } <ect>
recompilation <identifiersep> spec recompilation <identifiersep> spec = recompilation <identifiersep> spec <identifiersep> provider . provide <identifiersep> recompilation <identifiersep> spec ( current <identifiersep> compilation , previous <identifiersep> compilation ) ; if ( recompilation <identifiersep> spec . is <identifiersep> full <identifiersep> rebuild <identifiersep> needed ( ) ) { log . info ( <string_literal> , recompilation <identifiersep> spec . get <identifiersep> full <identifiersep> rebuild <identifiersep> cause ( ) , clock . get <identifiersep> elapsed ( ) ) ; return cleaning <identifiersep> compiler . execute ( spec ) ; } incremental <identifiersep> compilation <identifiersep> initilizer . initialize <identifiersep> compilation ( spec , recompilation <identifiersep> spec ) ; if ( spec . get <identifiersep> source ( ) . is <identifiersep> empty ( ) && spec . get <identifiersep> classes ( ) . is <identifiersep> empty ( ) ) { <LOG> return new recompilation <identifiersep> not <identifiersep> necessary ( ) ; } try { return cleaning <identifiersep> compiler . get <identifiersep> compiler ( ) . execute ( spec ) ; } finally { collection < string > classes <identifiersep> to <identifiersep> compile = recompilation <identifiersep> spec . get <identifiersep> classes <identifiersep> to <identifiersep> compile ( ) ; log . info ( <string_literal> , classes <identifiersep> to <identifiersep> compile . size ( ) , clock . get <identifiersep> elapsed ( ) ) ; <ect>
return new recompilation <identifiersep> not <identifiersep> necessary ( ) ; } try { return cleaning <identifiersep> compiler . get <identifiersep> compiler ( ) . execute ( spec ) ; } finally { collection < string > classes <identifiersep> to <identifiersep> compile = recompilation <identifiersep> spec . get <identifiersep> classes <identifiersep> to <identifiersep> compile ( ) ; log . info ( <string_literal> , classes <identifiersep> to <identifiersep> compile . size ( ) , clock . get <identifiersep> elapsed ( ) ) ; <LOG> } } } <ect>
} else { throw new unsupported <identifiersep> operation <identifiersep> exception ( ) ; } } } return source <identifiersep> roots ; } public boolean can <identifiersep> infer <identifiersep> source <identifiersep> roots ( ) { for ( object source : sources ) { if ( ! can <identifiersep> infer <identifiersep> source <identifiersep> root ( source ) ) { <LOG> return false ; } } return true ; } private boolean can <identifiersep> infer <identifiersep> source <identifiersep> root ( object source ) { return is <identifiersep> source <identifiersep> directory <identifiersep> set ( source ) || is <identifiersep> directory <identifiersep> tree ( source ) || is <identifiersep> directory ( source ) ; <ect>
def processors = detector . detect <identifiersep> processors ( cp ) . values ( ) . as <identifiersep> list ( ) then : processors == [ new annotation <identifiersep> processor <identifiersep> declaration ( <string_literal> , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type . unknown ) , new annotation <identifiersep> processor <identifiersep> declaration ( <string_literal> , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type . unknown ) ] <LOG> } def <string_literal> ( ) { given : def jar = tmp <identifiersep> dir . file ( <string_literal> ) jar < < jar <identifiersep> utils . jar <identifiersep> with <identifiersep> contents ( ( processor <identifiersep> declaration ) : <string_literal> , ( incremental <identifiersep> processor <identifiersep> declaration ) : <string_literal> <ect>
public class $ { test <identifiersep> class <identifiersep> name } { private final $ { production <identifiersep> class <identifiersep> name } production = new $ { production <identifiersep> class <identifiersep> name } ( <string_literal> ) ; @ org . junit . test public void test <identifiersep> one ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; <LOG> } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; system . err . println ( <string_literal> + i ) ; <ect>
system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; <LOG> } string expected = < % = binding . has <identifiersep> variable ( <string_literal> ) && binding . half <identifiersep> tests <identifiersep> fail ? <string_literal> : <string_literal> % > ; assert <identifiersep> equals ( production . get <identifiersep> property ( ) , expected ) ; } } <ect>
throw new gradle <identifiersep> exception ( <string_literal> ) ; } org . sonatype . aether . repository . remote <identifiersep> repository aether <identifiersep> repo = create <identifiersep> repository ( gradle <identifiersep> repo ) ; deploy <identifiersep> request request = new deploy <identifiersep> request ( ) ; request . set <identifiersep> repository ( aether <identifiersep> repo ) ; for ( artifact artifact : artifacts ) { request . add <identifiersep> artifact ( artifact ) ; } <LOG> repository <identifiersep> system . deploy ( session , request ) ; } private org . sonatype . aether . repository . remote <identifiersep> repository create <identifiersep> repository ( remote <identifiersep> repository gradle <identifiersep> repo ) { org . sonatype . aether . repository . remote <identifiersep> repository repo = new org . sonatype . aether . repository . remote <identifiersep> repository ( <string_literal> , gradle <identifiersep> repo . get <identifiersep> layout ( ) , gradle <identifiersep> repo . get <identifiersep> url ( ) ) ; org . apache . maven . artifact . ant . authentication auth = gradle <identifiersep> repo . get <identifiersep> authentication ( ) ; if ( auth != null ) { repo . set <identifiersep> authentication ( new authentication ( auth . get <identifiersep> user <identifiersep> name ( ) , auth . get <identifiersep> password ( ) , auth . get <identifiersep> private <identifiersep> key ( ) , auth . get <identifiersep> passphrase ( ) ) ) ; <ect>
def child <identifiersep> build = new build <identifiersep> test <identifiersep> file ( test <identifiersep> directory . file ( <string_literal> ) , <string_literal> ) outer <identifiersep> build . settings <identifiersep> file < < <string_literal> <string_literal> <string_literal> outer <identifiersep> build . file ( 'build <identifiersep> src / src / main / java / thing . java' ) < < <string_literal> <string_literal> <LOG> } <string_literal> <string_literal> new thing ( ) <string_literal> root <identifiersep> project . name = 'some <identifiersep> build' <string_literal> <string_literal> class thing { thing ( ) { system . out . println ( <string_literal> ) ; } <ect>
<string_literal> <string_literal> src / main / java / org / test / library . java <string_literal> <string_literal> package org . test ; public class library { public static void print ( string who ) { <LOG> } } <string_literal> <string_literal> <string_literal> root <identifiersep> project . name = <string_literal> include <identifiersep> build <string_literal> <string_literal> <string_literal> <string_literal> <ect>
this . context = context ; this . module <identifiersep> identifier <identifiersep> factory = module <identifiersep> identifier <identifiersep> factory ; } public void build ( included <identifiersep> build <identifiersep> internal build ) { dependency <identifiersep> substitutions <identifiersep> internal substitutions = resolve <identifiersep> dependency <identifiersep> substitutions ( build ) ; if ( ! substitutions . has <identifiersep> rules ( ) ) { <comment> <LOG> context . add <identifiersep> available <identifiersep> modules ( build . get <identifiersep> available <identifiersep> modules ( ) ) ; } else { <comment> <ect>
collection < project <identifiersep> component <identifiersep> identifier > providing <identifiersep> projects = replacement <identifiersep> map . get ( candidate <identifiersep> id ) ; if ( providing <identifiersep> projects . is <identifiersep> empty ( ) ) { logger . debug ( <string_literal> + candidate <identifiersep> id + <string_literal> ) ; return null ; } if ( providing <identifiersep> projects . size ( ) == 1 ) { project <identifiersep> component <identifiersep> identifier match = providing <identifiersep> projects . iterator ( ) . next ( ) ; <LOG> return match ; } sorted <identifiersep> set < string > sorted <identifiersep> projects = sets . new <identifiersep> tree <identifiersep> set ( collection <identifiersep> utils . collect ( providing <identifiersep> projects , new transformer < string , project <identifiersep> component <identifiersep> identifier > ( ) { @ override public string transform ( project <identifiersep> component <identifiersep> identifier project <identifiersep> component <identifiersep> identifier ) { return project <identifiersep> component <identifiersep> identifier . get <identifiersep> display <identifiersep> name ( ) ; } } ) ) ; <ect>
} finally { lock . unlock ( ) ; } return collections . empty <identifiersep> set ( ) ; } private void do <identifiersep> build ( final collection < string > tasks <identifiersep> to <identifiersep> execute ) { if ( tasks <identifiersep> to <identifiersep> execute . is <identifiersep> empty ( ) ) { return ; } <LOG> included <identifiersep> build <identifiersep> execution <identifiersep> listener listener = new included <identifiersep> build <identifiersep> execution <identifiersep> listener ( tasks <identifiersep> to <identifiersep> execute ) ; included <identifiersep> build . execute ( tasks <identifiersep> to <identifiersep> execute , listener ) ; } private void task <identifiersep> completed ( string task , throwable failure ) { lock . lock ( ) ; try { task <identifiersep> state task <identifiersep> state = tasks . get ( task ) ; <ect>
this . embedded <identifiersep> executor = embedded <identifiersep> executor ; this . payload <identifiersep> serializer = payload <identifiersep> serializer ; this . shared <identifiersep> services = shared <identifiersep> services ; this . jvm <identifiersep> version <identifiersep> detector = jvm <identifiersep> version <identifiersep> detector ; } public void configure ( provider <identifiersep> connection <identifiersep> parameters parameters ) { log <identifiersep> level provider <identifiersep> log <identifiersep> level = parameters . get <identifiersep> verbose <identifiersep> logging ( ) ? log <identifiersep> level . debug : log <identifiersep> level . info ; <LOG> logging <identifiersep> manager <identifiersep> internal logging <identifiersep> manager = logging <identifiersep> services . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal . class ) ; logging <identifiersep> manager . set <identifiersep> level <identifiersep> internal ( provider <identifiersep> log <identifiersep> level ) ; logging <identifiersep> manager . start ( ) ; } public object run ( string model <identifiersep> name , build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token , provider <identifiersep> operation <identifiersep> parameters provider <identifiersep> parameters ) { list < string > tasks = provider <identifiersep> parameters . get <identifiersep> tasks ( ) ; if ( model <identifiersep> name . equals ( model <identifiersep> identifier . null <identifiersep> model ) && tasks == null ) { <ect>
@ nullable <comment> <LOG> } <comment> public void configure ( connection <identifiersep> parameters parameters ) { assert <identifiersep> using <identifiersep> java7 ( ) ; provider <identifiersep> connection <identifiersep> parameters provider <identifiersep> connection <identifiersep> parameters = new protocol <identifiersep> to <identifiersep> model <identifiersep> adapter ( ) . adapt ( provider <identifiersep> connection <identifiersep> parameters . class , parameters ) ; <ect>
public class <identifiersep> loader transform ( class <identifiersep> loader <identifiersep> details details ) { list < class <identifiersep> loader > parents = new array <identifiersep> list < class <identifiersep> loader > ( ) ; for ( class <identifiersep> loader <identifiersep> details parent <identifiersep> details : details . parents ) { parents . add ( get <identifiersep> class <identifiersep> loader ( parent <identifiersep> details ) ) ; } if ( parents . is <identifiersep> empty ( ) ) { parents . add ( class <identifiersep> loader <identifiersep> factory . get <identifiersep> class <identifiersep> loader <identifiersep> for ( system <identifiersep> class <identifiersep> loader <identifiersep> spec . instance , immutable <identifiersep> list . < class <identifiersep> loader > of ( ) ) ) ; } <LOG> return class <identifiersep> loader <identifiersep> factory . get <identifiersep> class <identifiersep> loader <identifiersep> for ( details . spec , parents ) ; } } private class details <identifiersep> to <identifiersep> class <identifiersep> loader <identifiersep> transformer implements transformer < class <identifiersep> loader <identifiersep> details , class <identifiersep> loader > { public class <identifiersep> loader <identifiersep> details transform ( class <identifiersep> loader class <identifiersep> loader ) { class <identifiersep> loader <identifiersep> spec <identifiersep> visitor visitor = new class <identifiersep> loader <identifiersep> spec <identifiersep> visitor ( class <identifiersep> loader ) ; visitor . visit ( class <identifiersep> loader ) ; if ( visitor . spec == null ) { <ect>
continue ; } class < ? > cl ; try { cl = class . for <identifiersep> name ( class <identifiersep> name , false , target <identifiersep> class <identifiersep> loader ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> continue ; } find ( cl , visited , dest ) ; } } } catch ( exception e ) { throw new gradle <identifiersep> exception ( string . format ( <string_literal> , target ) , e ) ; } } } <ect>
out . add ( d ) ; } } return out ; } finally { lock . unlock ( ) ; } } public void remove ( final address address ) { lock . lock ( ) ; <LOG> try { cache . update ( new persistent <identifiersep> state <identifiersep> cache . update <identifiersep> action < daemon <identifiersep> registry <identifiersep> content > ( ) { public daemon <identifiersep> registry <identifiersep> content update ( daemon <identifiersep> registry <identifiersep> content old <identifiersep> value ) { if ( old <identifiersep> value == null ) { return old <identifiersep> value ; } old <identifiersep> value . remove <identifiersep> info ( address ) ; <ect>
} } ) ; } finally { lock . unlock ( ) ; } } @ override public void store <identifiersep> stop <identifiersep> event ( final daemon <identifiersep> stop <identifiersep> event stop <identifiersep> event ) { lock . lock ( ) ; <LOG> try { cache . update ( new persistent <identifiersep> state <identifiersep> cache . update <identifiersep> action < daemon <identifiersep> registry <identifiersep> content > ( ) { public daemon <identifiersep> registry <identifiersep> content update ( daemon <identifiersep> registry <identifiersep> content content ) { if ( content == null ) { <comment> <ect>
return content . get <identifiersep> stop <identifiersep> events ( ) ; } finally { lock . unlock ( ) ; } } @ override public void remove <identifiersep> stop <identifiersep> events ( final collection < daemon <identifiersep> stop <identifiersep> event > events ) { lock . lock ( ) ; <LOG> try { cache . update ( new persistent <identifiersep> state <identifiersep> cache . update <identifiersep> action < daemon <identifiersep> registry <identifiersep> content > ( ) { public daemon <identifiersep> registry <identifiersep> content update ( daemon <identifiersep> registry <identifiersep> content content ) { if ( content != null ) { <comment> <ect>
file daemon <identifiersep> log = daemon <identifiersep> services . get <identifiersep> daemon <identifiersep> log <identifiersep> file ( ) ; <comment> <LOG> daemon daemon = daemon <identifiersep> services . get ( daemon . class ) ; daemon . start ( ) ; try { daemon <identifiersep> context daemon <identifiersep> context = daemon <identifiersep> services . get ( daemon <identifiersep> context . class ) ; long pid = daemon <identifiersep> context . get <identifiersep> pid ( ) ; daemon <identifiersep> started ( pid , daemon . get <identifiersep> uid ( ) , daemon . get <identifiersep> address ( ) , daemon <identifiersep> log ) ; <ect>
} catch ( io <identifiersep> exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( e ) ; } target . println ( ) ; <comment> <LOG> <comment> <ect>
string <identifiersep> writer output = new string <identifiersep> writer ( ) ; scanner scanner = new scanner ( process <identifiersep> std <identifiersep> output ) ; print <identifiersep> writer printer = new print <identifiersep> writer ( output ) ; try { while ( scanner . has <identifiersep> next ( ) ) { string line = scanner . next <identifiersep> line ( ) ; <LOG> printer . println ( line ) ; if ( startup <identifiersep> communication . contains <identifiersep> greeting ( line ) ) { break ; } } } finally { scanner . close ( ) ; } process <identifiersep> output = output . to <identifiersep> string ( ) ; <ect>
throw new no <identifiersep> usable <identifiersep> daemon <identifiersep> found <identifiersep> exception ( <string_literal> + sane <identifiersep> number <identifiersep> of <identifiersep> attempts + <string_literal> + parameters + <string_literal> , accumulated <identifiersep> exceptions ) ; } protected object execute <identifiersep> build ( build build , daemon <identifiersep> client <identifiersep> connection connection , build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token , build <identifiersep> event <identifiersep> consumer build <identifiersep> event <identifiersep> consumer ) throws daemon <identifiersep> initial <identifiersep> connect <identifiersep> exception { object result ; try { <LOG> connection . dispatch ( build ) ; result = connection . receive ( ) ; } catch ( stale <identifiersep> daemon <identifiersep> address <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; <comment> <ect>
logger . debug ( <string_literal> , e ) ; <comment> <LOG> daemon <identifiersep> diagnostics diagnostics = null ; if ( result instanceof build <identifiersep> started ) { diagnostics = ( ( build <identifiersep> started ) result ) . get <identifiersep> diagnostics ( ) ; result = monitor <identifiersep> build ( build , diagnostics , connection , cancellation <identifiersep> token , build <identifiersep> event <identifiersep> consumer ) ; } logger . debug ( <string_literal> , result , connection . get <identifiersep> daemon ( ) ) ; connection . dispatch ( new finished ( ) ) ; <ect>
result = monitor <identifiersep> build ( build , diagnostics , connection , cancellation <identifiersep> token , build <identifiersep> event <identifiersep> consumer ) ; } logger . debug ( <string_literal> , result , connection . get <identifiersep> daemon ( ) ) ; connection . dispatch ( new finished ( ) ) ; if ( result instanceof failure ) { throwable failure = ( ( failure ) result ) . get <identifiersep> value ( ) ; if ( failure instanceof daemon <identifiersep> stopped <identifiersep> exception && cancellation <identifiersep> token . is <identifiersep> cancellation <identifiersep> requested ( ) ) { <LOG> throw new build <identifiersep> cancelled <identifiersep> exception ( ) ; } throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( failure ) ; } else if ( result instanceof daemon <identifiersep> unavailable ) { throw new daemon <identifiersep> initial <identifiersep> connect <identifiersep> exception ( <string_literal> + ( ( daemon <identifiersep> unavailable ) result ) . get <identifiersep> reason ( ) ) ; } else if ( result instanceof result ) { return ( ( result ) result ) . get <identifiersep> value ( ) ; <ect>
} else if ( result instanceof success ) { returned <identifiersep> status = ( status ) result . get <identifiersep> value ( ) ; } connection . dispatch ( new finished ( ) ) ; } catch ( throwable e ) { failure = e ; } if ( failure != null ) { <LOG> } return returned <identifiersep> status ; } } <ect>
private final runnable cancellation <identifiersep> callback ; private final build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token ; public daemon <identifiersep> cancel <identifiersep> forwarder ( final dispatch < ? super cancel > dispatch , build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token ) { this . cancellation <identifiersep> token = cancellation <identifiersep> token ; cancellation <identifiersep> callback = new runnable ( ) { public void run ( ) { <LOG> dispatch . dispatch ( new cancel ( ) ) ; } } ; } public void start ( ) { cancellation <identifiersep> token . add <identifiersep> callback ( cancellation <identifiersep> callback ) ; } public void stop ( ) { cancellation <identifiersep> token . remove <identifiersep> callback ( cancellation <identifiersep> callback ) ; <ect>
logger . lifecycle ( <string_literal> ) ; <comment> <LOG> boolean stopped = stop <identifiersep> dispatcher . dispatch ( connection , new stop ( id <identifiersep> generator . generate <identifiersep> id ( ) , connection . get <identifiersep> daemon ( ) . get <identifiersep> token ( ) ) ) ; if ( stopped ) { num <identifiersep> stopped ++ ; } } finally { connection . stop ( ) ; } connection = connector . maybe <identifiersep> connect ( spec ) ; <ect>
encoder . flush ( ) ; } catch ( io <identifiersep> exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( e ) ; } input <identifiersep> stream std <identifiersep> input = buffer . get <identifiersep> input <identifiersep> stream ( ) ; return start <identifiersep> process ( daemon <identifiersep> args , daemon <identifiersep> dir . get <identifiersep> versioned <identifiersep> dir ( ) , std <identifiersep> input ) ; } private daemon <identifiersep> startup <identifiersep> info start <identifiersep> process ( list < string > args , file working <identifiersep> dir , input <identifiersep> stream std <identifiersep> input ) { <LOG> timer clock = time . start <identifiersep> timer ( ) ; try { g <identifiersep> file <identifiersep> utils . mkdirs ( working <identifiersep> dir ) ; daemon <identifiersep> output <identifiersep> consumer output <identifiersep> consumer = new daemon <identifiersep> output <identifiersep> consumer ( ) ; <comment> <ect>
default <identifiersep> exec <identifiersep> action <identifiersep> factory exec <identifiersep> action <identifiersep> factory = new default <identifiersep> exec <identifiersep> action <identifiersep> factory ( new identity <identifiersep> file <identifiersep> resolver ( ) ) ; try { exec <identifiersep> handle handle = new daemon <identifiersep> exec <identifiersep> handle <identifiersep> builder ( ) . build ( args , working <identifiersep> dir , output <identifiersep> consumer , std <identifiersep> input , exec <identifiersep> action <identifiersep> factory . new <identifiersep> exec ( ) ) ; handle . start ( ) ; logger . debug ( <string_literal> ) ; handle . wait <identifiersep> for <identifiersep> finish ( ) ; <LOG> } finally { exec <identifiersep> action <identifiersep> factory . stop ( ) ; } return daemon <identifiersep> greeter . parse <identifiersep> daemon <identifiersep> output ( output <identifiersep> consumer . get <identifiersep> process <identifiersep> output ( ) ) ; } catch ( gradle <identifiersep> exception e ) { throw e ; } catch ( exception e ) { <ect>
this . connection = connection ; this . daemon = daemon ; this . stale <identifiersep> address <identifiersep> detector = stale <identifiersep> address <identifiersep> detector ; } public daemon <identifiersep> connect <identifiersep> details get <identifiersep> daemon ( ) { return daemon ; } public void dispatch ( message message ) throws daemon <identifiersep> connection <identifiersep> exception { <LOG> try { dispatch <identifiersep> lock . lock ( ) ; try { connection . dispatch ( message ) ; connection . flush ( ) ; } finally { <ect>
throw new daemon <identifiersep> connection <identifiersep> exception ( <string_literal> , e ) ; } } @ nullable public message receive ( ) throws daemon <identifiersep> connection <identifiersep> exception { try { return connection . receive ( ) ; } catch ( message <identifiersep> io <identifiersep> exception e ) { <LOG> if ( ! has <identifiersep> received && stale <identifiersep> address <identifiersep> detector . maybe <identifiersep> stale <identifiersep> address ( e ) ) { throw new stale <identifiersep> daemon <identifiersep> address <identifiersep> exception ( <string_literal> , e ) ; } throw new daemon <identifiersep> connection <identifiersep> exception ( <string_literal> , e ) ; } finally { has <identifiersep> received = true ; } } public void stop ( ) { <ect>
public static final string expiration <identifiersep> reason = <string_literal> ; public gc <identifiersep> thrashing <identifiersep> daemon <identifiersep> expiration <identifiersep> strategy ( daemon <identifiersep> memory <identifiersep> status status ) { this . status = status ; } @ override public daemon <identifiersep> expiration <identifiersep> result check <identifiersep> expiration ( ) { if ( status . is <identifiersep> thrashing ( ) ) { <LOG> return new daemon <identifiersep> expiration <identifiersep> result ( immediate <identifiersep> expire , expiration <identifiersep> reason ) ; } else { return daemon <identifiersep> expiration <identifiersep> result . not <identifiersep> triggered ; } } } <ect>
lock . unlock ( ) ; } return daemon <identifiersep> expiration <identifiersep> result . not <identifiersep> triggered ; } @ override public void on <identifiersep> os <identifiersep> memory <identifiersep> status ( os <identifiersep> memory <identifiersep> status new <identifiersep> status ) { lock . lock ( ) ; try { <LOG> this . memory <identifiersep> status = new <identifiersep> status ; this . memory <identifiersep> threshold <identifiersep> in <identifiersep> bytes = normalize <identifiersep> threshold ( ( long ) ( memory <identifiersep> status . get <identifiersep> total <identifiersep> physical <identifiersep> memory ( ) * min <identifiersep> free <identifiersep> memory <identifiersep> percentage ) , min <identifiersep> threshold <identifiersep> bytes , max <identifiersep> threshold <identifiersep> bytes ) ; } finally { lock . unlock ( ) ; } } } <ect>
} ) ; } private boolean exceeds <identifiersep> threshold ( string pool , garbage <identifiersep> collection <identifiersep> stats gc <identifiersep> stats , spec < garbage <identifiersep> collection <identifiersep> stats > spec ) { if ( is <identifiersep> enabled ( ) && strategy != garbage <identifiersep> collector <identifiersep> monitoring <identifiersep> strategy . unknown && spec . is <identifiersep> satisfied <identifiersep> by ( gc <identifiersep> stats ) ) { if ( gc <identifiersep> stats . get <identifiersep> usage ( ) > 0 ) { <LOG> } else { logger . debug ( <string_literal> ) ; } return true ; } return false ; } private boolean is <identifiersep> enabled ( ) { string enabled <identifiersep> value = system . get <identifiersep> property ( enable <identifiersep> performance <identifiersep> monitoring , <string_literal> ) ; <ect>
garbage <identifiersep> collector <identifiersep> monitoring <identifiersep> strategy gc <identifiersep> strategy = collection <identifiersep> utils . find <identifiersep> first ( jvm <identifiersep> strategy . get <identifiersep> gc <identifiersep> strategies ( ) , new spec < garbage <identifiersep> collector <identifiersep> monitoring <identifiersep> strategy > ( ) { @ override public boolean is <identifiersep> satisfied <identifiersep> by ( garbage <identifiersep> collector <identifiersep> monitoring <identifiersep> strategy strategy ) { return garbage <identifiersep> collectors . contains ( strategy . get <identifiersep> garbage <identifiersep> collector <identifiersep> name ( ) ) ; } } ) ; if ( gc <identifiersep> strategy == null ) { <LOG> return garbage <identifiersep> collector <identifiersep> monitoring <identifiersep> strategy . unknown ; } else { return gc <identifiersep> strategy ; } } private void poll <identifiersep> for <identifiersep> values ( string garbage <identifiersep> collector <identifiersep> name , list < string > memory <identifiersep> pool <identifiersep> names ) { polling <identifiersep> executor . schedule <identifiersep> at <identifiersep> fixed <identifiersep> rate ( new garbage <identifiersep> collection <identifiersep> check ( events , memory <identifiersep> pool <identifiersep> names , garbage <identifiersep> collector <identifiersep> name ) , poll <identifiersep> delay <identifiersep> seconds , poll <identifiersep> interval <identifiersep> seconds , time <identifiersep> unit . seconds ) ; } public garbage <identifiersep> collection <identifiersep> stats get <identifiersep> tenured <identifiersep> stats ( ) { <ect>
this . token = token ; } public void on <identifiersep> start <identifiersep> activity ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , busy ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { <LOG> } } public void on <identifiersep> complete <identifiersep> activity ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , idle ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; <ect>
logger . warn ( <string_literal> ) ; } } public void on <identifiersep> complete <identifiersep> activity ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , idle ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { <LOG> } } public void on <identifiersep> cancel ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , canceled ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; <ect>
private command receive <identifiersep> command ( daemon <identifiersep> connection daemon <identifiersep> connection ) { try { command command = ( command ) daemon <identifiersep> connection . receive ( <number_literal> , time <identifiersep> unit . seconds ) ; logger . info ( <string_literal> , command ) ; return command ; } catch ( throwable e ) { <LOG> return null ; } } private void handle <identifiersep> command ( command command , daemon <identifiersep> connection daemon <identifiersep> connection ) { logger . debug ( <string_literal> , daemon <identifiersep> messages . started <identifiersep> executing <identifiersep> command , command , connection ) ; try { if ( ! arrays . equals ( command . get <identifiersep> token ( ) , token ) ) { throw new badly <identifiersep> formed <identifiersep> request <identifiersep> exception ( string . format ( <string_literal> , command , connection ) ) ; <ect>
logger . debug ( <string_literal> , daemon <identifiersep> messages . started <identifiersep> executing <identifiersep> command , command , connection ) ; try { if ( ! arrays . equals ( command . get <identifiersep> token ( ) , token ) ) { throw new badly <identifiersep> formed <identifiersep> request <identifiersep> exception ( string . format ( <string_literal> , command , connection ) ) ; } command <identifiersep> executer . execute <identifiersep> command ( daemon <identifiersep> connection , command , daemon <identifiersep> context , daemon <identifiersep> state <identifiersep> control ) ; } catch ( throwable e ) { <LOG> daemon <identifiersep> connection . completed ( new failure ( e ) ) ; } finally { logger . debug ( <string_literal> , daemon <identifiersep> messages . finished <identifiersep> executing <identifiersep> command , command ) ; } object finished = daemon <identifiersep> connection . receive ( <number_literal> , time <identifiersep> unit . seconds ) ; logger . debug ( <string_literal> , finished ) ; } } } <ect>
} catch ( throwable e ) { logger . warn ( string . format ( <string_literal> , command , connection ) , e ) ; daemon <identifiersep> connection . completed ( new failure ( e ) ) ; } finally { logger . debug ( <string_literal> , daemon <identifiersep> messages . finished <identifiersep> executing <identifiersep> command , command ) ; } object finished = daemon <identifiersep> connection . receive ( <number_literal> , time <identifiersep> unit . seconds ) ; <LOG> } } } <ect>
shutdown <identifiersep> hook <identifiersep> action <identifiersep> register . add <identifiersep> action ( new runnable ( ) { @ override public void run ( ) { try { daemon <identifiersep> registry . remove ( connector <identifiersep> address ) ; } catch ( exception e ) { <LOG> } } } ) ; runnable on <identifiersep> start <identifiersep> command = new runnable ( ) { @ override public void run ( ) { registry <identifiersep> updater . on <identifiersep> start <identifiersep> activity ( ) ; } } ; <ect>
<comment> @ override public void stop ( ) { <LOG> lifecycle <identifiersep> lock . lock ( ) ; try { if ( state <identifiersep> coordinator == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } logger . info ( daemon <identifiersep> messages . removing <identifiersep> presence <identifiersep> due <identifiersep> to <identifiersep> stop ) ; <comment> <ect>
listener <identifiersep> manager . add <identifiersep> listener ( new default <identifiersep> daemon <identifiersep> expiration <identifiersep> listener ( state <identifiersep> coordinator , registry <identifiersep> updater ) ) ; scheduled <identifiersep> executor <identifiersep> service . schedule <identifiersep> at <identifiersep> fixed <identifiersep> rate ( periodic <identifiersep> check , check <identifiersep> interval <identifiersep> mills , check <identifiersep> interval <identifiersep> mills , time <identifiersep> unit . milliseconds ) ; } <comment> private void await <identifiersep> expiration ( ) { <LOG> daemon <identifiersep> state <identifiersep> coordinator state <identifiersep> coordinator ; lifecycle <identifiersep> lock . lock ( ) ; try { if ( this . state <identifiersep> coordinator == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } state <identifiersep> coordinator = this . state <identifiersep> coordinator ; <ect>
try { logger . debug ( <string_literal> ) ; final daemon <identifiersep> expiration <identifiersep> result result = expiration <identifiersep> strategy . check <identifiersep> expiration ( ) ; if ( result . get <identifiersep> status ( ) != do <identifiersep> not <identifiersep> expire ) { listener <identifiersep> broadcast . on <identifiersep> expiration <identifiersep> event ( result ) ; } } catch ( throwable t ) { <LOG> if ( t instanceof error ) { <comment> <ect>
try { while ( true ) { try { switch ( state ) { case idle : case busy : <LOG> condition . await ( ) ; break ; case canceled : logger . debug ( <string_literal> ) ; cancel <identifiersep> now ( ) ; break ; <ect>
logger . debug ( <string_literal> ) ; cancel <identifiersep> now ( ) ; break ; case broken : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; case stop <identifiersep> requested : <LOG> condition . await ( ) ; break ; case stopped : logger . debug ( <string_literal> ) ; return true ; } } catch ( interrupted <identifiersep> exception e ) { <ect>
public void request <identifiersep> stop ( string reason ) { if ( ! ( state == state . stop <identifiersep> requested || state == state . stopped ) ) { logger . lifecycle ( daemon <identifiersep> will <identifiersep> stop <identifiersep> message + reason ) ; lock . lock ( ) ; try { if ( state == state . busy ) { <LOG> begin <identifiersep> stopping ( ) ; } else { stop <identifiersep> now ( reason ) ; } } finally { lock . unlock ( ) ; } } } @ override <ect>
} catch ( interrupted <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } } finally { lock . unlock ( ) ; } } private void cancel <identifiersep> now ( ) { countdown <identifiersep> timer timer = time . start <identifiersep> countdown <identifiersep> timer ( cancel <identifiersep> timeout <identifiersep> ms ) ; <LOG> try { cancellation <identifiersep> token . cancel ( ) ; } catch ( exception ex ) { logger . error ( <string_literal> , ex ) ; } lock . lock ( ) ; try { <ect>
lock . lock ( ) ; try { while ( ! timer . has <identifiersep> expired ( ) ) { try { switch ( state ) { case idle : <LOG> return ; case busy : case canceled : case stop <identifiersep> requested : logger . debug ( <string_literal> ) ; condition . await ( timer . get <identifiersep> remaining <identifiersep> millis ( ) , time <identifiersep> unit . milliseconds ) ; <ect>
logger . debug ( <string_literal> ) ; condition . await ( timer . get <identifiersep> remaining <identifiersep> millis ( ) , time <identifiersep> unit . milliseconds ) ; break ; case broken : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; case stopped : <LOG> return ; } } catch ( interrupted <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } logger . debug ( <string_literal> ) ; stop <identifiersep> now ( <string_literal> ) ; } finally { <ect>
try { while ( ( state == state . busy || state == state . canceled || state == state . stop <identifiersep> requested ) && result == null ) { try { condition . await ( ) ; } catch ( interrupted <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } <LOG> if ( result instanceof throwable ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( ( throwable ) result ) ; } if ( result != null ) { return ; } switch ( state ) { case stopped : <ect>
throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( throwable ) ; } } finally { lock . unlock ( ) ; } } private void on <identifiersep> finish <identifiersep> command ( ) { lock . lock ( ) ; try { <LOG> current <identifiersep> command <identifiersep> execution = null ; result = null ; stop <identifiersep> reason = null ; update <identifiersep> activity <identifiersep> timestamp ( ) ; switch ( state ) { case idle : <ect>
while ( true ) { object message ; try { message = connection . receive ( ) ; } catch ( exception e ) { <LOG> } failure = e ; return ; } if ( message == null ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) ) ; return ; } if ( message instanceof input <identifiersep> message ) { <ect>
this . diagnostics = diagnostics ; } protected void do <identifiersep> build ( final daemon <identifiersep> command <identifiersep> execution execution , build build ) { if ( boolean . get <identifiersep> boolean ( disable <identifiersep> output ) ) { execution . proceed ( ) ; return ; } dispatcher = new asynchronous <identifiersep> log <identifiersep> dispatcher ( execution . get <identifiersep> connection ( ) , build . get <identifiersep> parameters ( ) . get <identifiersep> log <identifiersep> level ( ) ) ; <LOG> dispatcher . start ( ) ; try { execution . proceed ( ) ; } finally { dispatcher . wait <identifiersep> for <identifiersep> completion ( ) ; } } private class asynchronous <identifiersep> log <identifiersep> dispatcher extends thread { <ect>
<comment> public class handle <identifiersep> cancel implements daemon <identifiersep> command <identifiersep> action { private static final logger logger = logging . get <identifiersep> logger ( handle <identifiersep> cancel . class ) ; public void execute ( final daemon <identifiersep> command <identifiersep> execution execution ) { execution . get <identifiersep> connection ( ) . on <identifiersep> cancel ( new runnable ( ) { public void run ( ) { <LOG> execution . get <identifiersep> daemon <identifiersep> state <identifiersep> control ( ) . cancel <identifiersep> build ( ) ; } } ) ; try { execution . proceed ( ) ; } finally { execution . get <identifiersep> connection ( ) . on <identifiersep> cancel ( null ) ; <ect>
try { replacement <identifiersep> stdin = new piped <identifiersep> input <identifiersep> stream ( input <identifiersep> source ) ; } catch ( io <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } execution . get <identifiersep> connection ( ) . on <identifiersep> stdin ( new stdin <identifiersep> handler ( ) { public void on <identifiersep> input ( forward <identifiersep> input input ) { <LOG> try { input <identifiersep> source . write ( input . get <identifiersep> bytes ( ) ) ; } catch ( io <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } public void on <identifiersep> end <identifiersep> of <identifiersep> input ( ) { logger . info ( <string_literal> ) ; <ect>
logger . debug ( <string_literal> ) ; try { input <identifiersep> source . write ( input . get <identifiersep> bytes ( ) ) ; } catch ( io <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } public void on <identifiersep> end <identifiersep> of <identifiersep> input ( ) { <LOG> try { input <identifiersep> source . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } finally { logger . info ( <string_literal> ) ; <ect>
logger . info ( <string_literal> ) ; try { input <identifiersep> source . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } finally { <LOG> } } } ) ; try { try { new stdin <identifiersep> swapper ( ) . swap ( replacement <identifiersep> stdin , new callable < void > ( ) { public void call ( ) { execution . proceed ( ) ; <ect>
if ( system <identifiersep> properties . get <identifiersep> instance ( ) . get <identifiersep> non <identifiersep> standard <identifiersep> important <identifiersep> properties ( ) . contains ( entry . get <identifiersep> key ( ) ) ) { continue ; } if ( entry . get <identifiersep> key ( ) . starts <identifiersep> with ( <string_literal> ) || entry . get <identifiersep> key ( ) . starts <identifiersep> with ( <string_literal> ) || entry . get <identifiersep> key ( ) . contains ( <string_literal> ) ) { continue ; } system . set <identifiersep> property ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; } <LOG> environment <identifiersep> modification <identifiersep> result set <identifiersep> environment <identifiersep> result = process <identifiersep> environment . maybe <identifiersep> set <identifiersep> environment ( build . get <identifiersep> parameters ( ) . get <identifiersep> env <identifiersep> variables ( ) ) ; if ( ! set <identifiersep> environment <identifiersep> result . is <identifiersep> success ( ) ) { logger . warn ( <string_literal> + system . get <identifiersep> property ( <string_literal> ) + <string_literal> + set <identifiersep> environment <identifiersep> result + system . get <identifiersep> property ( <string_literal> ) + <string_literal> <ect>
logger . info ( <string_literal> , build ) ; execution . get <identifiersep> connection ( ) . build <identifiersep> started ( new build <identifiersep> started ( diagnostics ) ) ; execution . proceed ( ) ; } } ; state <identifiersep> coordinator . run <identifiersep> command ( command , execution . to <identifiersep> string ( ) ) ; } catch ( daemon <identifiersep> unavailable <identifiersep> exception e ) { <LOG> execution . get <identifiersep> connection ( ) . daemon <identifiersep> unavailable ( new daemon <identifiersep> unavailable ( e . get <identifiersep> message ( ) ) ) ; } catch ( daemon <identifiersep> stopped <identifiersep> exception e ) { execution . get <identifiersep> connection ( ) . completed ( new failure ( e ) ) ; } } <ect>
private final remote <identifiersep> connection < t > delegate ; private boolean dispatching ; public synchronized <identifiersep> dispatch <identifiersep> connection ( remote <identifiersep> connection < t > delegate ) { this . delegate = delegate ; } public void dispatch ( final t message ) { if ( ! ( message instanceof output <identifiersep> message ) ) { <LOG> } synchronized ( lock ) { if ( dispatching ) { <comment> <ect>
<comment> <LOG> delegate . stop ( ) ; } public string to <identifiersep> string ( ) { return delegate . to <identifiersep> string ( ) ; } } <ect>
@ subject health <identifiersep> logger = new health <identifiersep> logger ( ) def stats = mock ( daemon <identifiersep> health <identifiersep> stats ) def logger = mock ( logger ) def <string_literal> ( ) { stats . health <identifiersep> info > > <string_literal> when : health <identifiersep> logger . log <identifiersep> health ( stats , logger ) <LOG> } def <string_literal> ( ) { system . set <identifiersep> property ( health <identifiersep> logger . health <identifiersep> message <identifiersep> property , <string_literal> ) stats . health <identifiersep> info > > <string_literal> when : health <identifiersep> logger . log <identifiersep> health ( stats , logger ) then : logger . lifecycle ( <string_literal> ) } } <ect>
} catch ( runtime <identifiersep> exception e ) { <comment> <LOG> return work <identifiersep> results . did <identifiersep> work ( false ) ; } } } <ect>
public immutable <identifiersep> sorted <identifiersep> set < file > collect <identifiersep> existing <identifiersep> header <identifiersep> dependencies ( string task <identifiersep> path , list < file > include <identifiersep> roots , incremental <identifiersep> compilation incremental <identifiersep> compilation ) { final set < file > header <identifiersep> dependencies = new hash <identifiersep> set < file > ( ) ; if ( incremental <identifiersep> compilation . is <identifiersep> unresolved <identifiersep> headers ( ) ) { logger . info ( <string_literal> , task <identifiersep> path ) ; add <identifiersep> include <identifiersep> roots ( task <identifiersep> path , include <identifiersep> roots , header <identifiersep> dependencies ) ; } else { <LOG> header <identifiersep> dependencies . add <identifiersep> all ( incremental <identifiersep> compilation . get <identifiersep> existing <identifiersep> headers ( ) ) ; } return immutable <identifiersep> sorted <identifiersep> set . copy <identifiersep> of ( header <identifiersep> dependencies ) ; } private void add <identifiersep> include <identifiersep> roots ( string task <identifiersep> path , list < file > include <identifiersep> roots , final set < file > header <identifiersep> dependencies ) { for ( final file include <identifiersep> root : include <identifiersep> roots ) { logger . info ( <string_literal> , include <identifiersep> root , task <identifiersep> path ) ; directory <identifiersep> file <identifiersep> tree <identifiersep> factory . create ( include <identifiersep> root ) . visit ( new empty <identifiersep> file <identifiersep> visitor ( ) { <ect>
include <identifiersep> file <identifiersep> resolution <identifiersep> result result = include <identifiersep> file <identifiersep> resolution <identifiersep> result . no <identifiersep> macro <identifiersep> includes ; for ( include include : file <identifiersep> details . directives . get <identifiersep> all ( ) ) { if ( include . get <identifiersep> type ( ) == include <identifiersep> type . macro && result == include <identifiersep> file <identifiersep> resolution <identifiersep> result . no <identifiersep> macro <identifiersep> includes ) { result = include <identifiersep> file <identifiersep> resolution <identifiersep> result . has <identifiersep> macro <identifiersep> includes ; } source <identifiersep> includes <identifiersep> resolver . include <identifiersep> resolution <identifiersep> result resolution <identifiersep> result = source <identifiersep> includes <identifiersep> resolver . resolve <identifiersep> include ( file , include , visible <identifiersep> macros ) ; if ( ! resolution <identifiersep> result . is <identifiersep> complete ( ) ) { <LOG> if ( is <identifiersep> source <identifiersep> file || ! ignore <identifiersep> unresolved <identifiersep> headers <identifiersep> in <identifiersep> dependencies ) { has <identifiersep> unresolved <identifiersep> headers = true ; result = include <identifiersep> file <identifiersep> resolution <identifiersep> result . unresolved <identifiersep> macro <identifiersep> includes ; } } for ( source <identifiersep> includes <identifiersep> resolver . include <identifiersep> file include <identifiersep> file : resolution <identifiersep> result . get <identifiersep> files ( ) ) { existing <identifiersep> headers . add ( include <identifiersep> file . get <identifiersep> file ( ) ) ; file <identifiersep> visit <identifiersep> result include <identifiersep> visit <identifiersep> result = visit <identifiersep> file ( include <identifiersep> file . get <identifiersep> file ( ) , include <identifiersep> file . get <identifiersep> snapshot ( ) , visible <identifiersep> macros , visited , false ) ; <ect>
public int get <identifiersep> rows ( ) { final string rows = system . getenv ( <string_literal> ) ; if ( rows != null ) { try { return integer . parse <identifiersep> int ( rows ) ; } catch ( number <identifiersep> format <identifiersep> exception ex ) { <LOG> } } return 0 ; } } <ect>
return true ; } catch ( internal <identifiersep> error e ) { if ( e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <comment> <LOG> } return false ; } catch ( io <identifiersep> exception e ) { return false ; } catch ( unsupported <identifiersep> operation <identifiersep> exception e ) { return false ; } finally { <ect>
@ override public void chmod ( file file , int mode ) throws exception { maybe <identifiersep> warn ( ) ; chmod . chmod ( file , mode ) ; } private void maybe <identifiersep> warn ( ) { if ( warned . compare <identifiersep> and <identifiersep> set ( false , true ) ) { <LOG> } } } <ect>
protected console <identifiersep> detector create <identifiersep> console <identifiersep> detector ( operating <identifiersep> system operating <identifiersep> system ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { terminals terminals = net . rubygrapefruit . platform . native . get ( terminals . class ) ; return new native <identifiersep> platform <identifiersep> console <identifiersep> detector ( terminals ) ; } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception ex ) { <LOG> } catch ( native <identifiersep> exception ex ) { logger . debug ( <string_literal> , format ( ex ) ) ; } try { if ( operating <identifiersep> system . is <identifiersep> windows ( ) ) { return new windows <identifiersep> console <identifiersep> detector ( ) ; } } catch ( linkage <identifiersep> error e ) { <ect>
logger . debug ( <string_literal> , format ( ex ) ) ; } try { if ( operating <identifiersep> system . is <identifiersep> windows ( ) ) { return new windows <identifiersep> console <identifiersep> detector ( ) ; } } catch ( linkage <identifiersep> error e ) { <comment> <LOG> } } return new no <identifiersep> op <identifiersep> console <identifiersep> detector ( ) ; } protected windows <identifiersep> registry create <identifiersep> windows <identifiersep> registry ( operating <identifiersep> system operating <identifiersep> system ) { if ( use <identifiersep> native <identifiersep> integrations && operating <identifiersep> system . is <identifiersep> windows ( ) ) { return net . rubygrapefruit . platform . native . get ( windows <identifiersep> registry . class ) ; } return not <identifiersep> available ( windows <identifiersep> registry . class ) ; } protected system <identifiersep> info create <identifiersep> system <identifiersep> info ( ) { <ect>
return not <identifiersep> available ( system <identifiersep> info . class ) ; } protected memory create <identifiersep> memory ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( memory . class ) ; } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception e ) { <LOG> } } return not <identifiersep> available ( memory . class ) ; } protected process <identifiersep> launcher create <identifiersep> process <identifiersep> launcher ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( process <identifiersep> launcher . class ) ; } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception e ) { <ect>
return new default <identifiersep> process <identifiersep> launcher ( ) ; } protected posix <identifiersep> files create <identifiersep> posix <identifiersep> files ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( posix <identifiersep> files . class ) ; } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception e ) { <LOG> } } return not <identifiersep> available ( unavailable <identifiersep> posix <identifiersep> files . class ) ; } protected file <identifiersep> metadata <identifiersep> accessor create <identifiersep> file <identifiersep> metadata <identifiersep> accessor ( operating <identifiersep> system operating <identifiersep> system ) { <comment> <ect>
os <identifiersep> memory <identifiersep> info . get <identifiersep> os <identifiersep> snapshot ( ) ; return true ; } catch ( unsupported <identifiersep> operation <identifiersep> exception ex ) { return false ; } } private void start ( ) { scheduler . schedule <identifiersep> at <identifiersep> fixed <identifiersep> rate ( new memory <identifiersep> check ( ) , status <identifiersep> interval <identifiersep> seconds , status <identifiersep> interval <identifiersep> seconds , time <identifiersep> unit . seconds ) ; <LOG> if ( os <identifiersep> memory <identifiersep> status <identifiersep> supported ) { add <identifiersep> listener ( os <identifiersep> memory <identifiersep> status <identifiersep> listener ) ; } else { logger . info ( <string_literal> ) ; } } @ override public void stop ( ) { <ect>
long free <identifiersep> memory = current <identifiersep> os <identifiersep> memory <identifiersep> status . get <identifiersep> free <identifiersep> physical <identifiersep> memory ( ) ; long new <identifiersep> free <identifiersep> memory = do <identifiersep> request <identifiersep> free <identifiersep> memory ( requested <identifiersep> free <identifiersep> memory , free <identifiersep> memory ) ; <comment> <LOG> } } } private long do <identifiersep> request <identifiersep> free <identifiersep> memory ( long requested <identifiersep> free <identifiersep> memory , long free <identifiersep> memory ) { long to <identifiersep> release <identifiersep> memory = requested <identifiersep> free <identifiersep> memory ; if ( free <identifiersep> memory < requested <identifiersep> free <identifiersep> memory ) { logger . debug ( <string_literal> , requested <identifiersep> free <identifiersep> memory , free <identifiersep> memory ) ; list < memory <identifiersep> holder > memory <identifiersep> holders ; synchronized ( holders <identifiersep> lock ) { <ect>
for ( memory <identifiersep> holder holder : memory <identifiersep> holders ) { long released = holder . attempt <identifiersep> to <identifiersep> release ( to <identifiersep> release <identifiersep> memory ) ; to <identifiersep> release <identifiersep> memory -= released ; free <identifiersep> memory += released ; if ( free <identifiersep> memory >= requested <identifiersep> free <identifiersep> memory ) { break ; } } <LOG> } return free <identifiersep> memory ; } private long get <identifiersep> memory <identifiersep> threshold <identifiersep> in <identifiersep> bytes ( long total <identifiersep> physical <identifiersep> memory ) { return math . max ( min <identifiersep> threshold <identifiersep> bytes , ( long ) ( total <identifiersep> physical <identifiersep> memory * min <identifiersep> free <identifiersep> memory <identifiersep> percentage ) ) ; } private class memory <identifiersep> check implements runnable { @ override public void run ( ) { <ect>
try { if ( os <identifiersep> memory <identifiersep> status <identifiersep> supported ) { os <identifiersep> memory <identifiersep> status os = os <identifiersep> memory <identifiersep> info . get <identifiersep> os <identifiersep> snapshot ( ) ; logger . debug ( <string_literal> , os ) ; os <identifiersep> broadcast . on <identifiersep> os <identifiersep> memory <identifiersep> status ( os ) ; } jvm <identifiersep> memory <identifiersep> status jvm = jvm <identifiersep> memory <identifiersep> info . get <identifiersep> jvm <identifiersep> snapshot ( ) ; <LOG> jvm <identifiersep> broadcast . on <identifiersep> jvm <identifiersep> memory <identifiersep> status ( jvm ) ; } catch ( exception ex ) { logger . debug ( <string_literal> , ex . get <identifiersep> message ( ) , ex ) ; } } } private class os <identifiersep> memory <identifiersep> listener implements os <identifiersep> memory <identifiersep> status <identifiersep> listener { private final boolean auto <identifiersep> free ; private os <identifiersep> memory <identifiersep> listener ( boolean auto <identifiersep> free ) { <ect>
logger . lifecycle ( 'init lifecycle log' ) logger . info ( 'init info log' ) use <identifiersep> logger ( new custom <identifiersep> logger ( ) ) class custom <identifiersep> logger extends build <identifiersep> adapter implements build <identifiersep> listener , project <identifiersep> evaluation <identifiersep> listener , task <identifiersep> execution <identifiersep> listener , task <identifiersep> action <identifiersep> listener { def logger = logging . get <identifiersep> logger ( 'init - script' ) public void build <identifiersep> finished ( build <identifiersep> result result ) { <LOG> println 'init callback quiet out' } public void before <identifiersep> evaluate ( project project ) { logger . lifecycle ( <string_literal> ) } public void after <identifiersep> evaluate ( project project , project <identifiersep> state state ) { logger . info ( <string_literal> ) } public void before <identifiersep> execute ( task task ) { <ect>
logger . lifecycle ( <string_literal> ) } public void after <identifiersep> evaluate ( project project , project <identifiersep> state state ) { logger . info ( <string_literal> ) } public void before <identifiersep> execute ( task task ) { logger . lifecycle ( <string_literal> ) } public void after <identifiersep> execute ( task task , task <identifiersep> state state ) { <LOG> } public void before <identifiersep> actions ( task task ) { logger . info ( <string_literal> ) } public void after <identifiersep> actions ( task task ) { logger . info ( <string_literal> ) } <ect>
logger . lifecycle ( <string_literal> ) } public void after <identifiersep> execute ( task task , task <identifiersep> state state ) { logger . info ( <string_literal> ) } public void before <identifiersep> actions ( task task ) { logger . info ( <string_literal> ) } public void after <identifiersep> actions ( task task ) { <LOG> } <ect>
def <string_literal> ( ) { given : build <identifiersep> file < < test <identifiersep> logging <identifiersep> standard <identifiersep> stream ( ) file ( java <identifiersep> test <identifiersep> file <identifiersep> path ) < < java <identifiersep> test <identifiersep> class { <string_literal> <string_literal> standard output <string_literal> <LOG> <string_literal> <string_literal> <ect>
def <string_literal> ( ) { given : build <identifiersep> file < < <string_literal> <string_literal> <LOG> system . err . println ( <string_literal> ) } } <string_literal> <string_literal> standard out \\ n <identifiersep> standard err <string_literal> <ect>
import org . gradle . api . tasks . task <identifiersep> action ; import org . gradle . util . deprecation <identifiersep> logger ; public class deprecated <identifiersep> task extends default <identifiersep> task { @ task <identifiersep> action void cause <identifiersep> deprecation <identifiersep> warning ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> replaced <identifiersep> task ( <string_literal> , <string_literal> ) ; <LOG> } public static void some <identifiersep> feature ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> discontinued <identifiersep> method ( <string_literal> ) ; system . out . println ( <string_literal> ) ; } void other <identifiersep> feature ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> discontinued <identifiersep> method ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } public static void some <identifiersep> feature ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> discontinued <identifiersep> method ( <string_literal> ) ; system . out . println ( <string_literal> ) ; } void other <identifiersep> feature ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> discontinued <identifiersep> method ( <string_literal> , <string_literal> ) ; <LOG> } } <string_literal> <string_literal> <string_literal> import org . gradle . api . plugin ; import org . gradle . api . project ; import org . gradle . util . deprecation <identifiersep> logger ; public class deprecated <identifiersep> plugin implements plugin < project > { <ect>
logger . warn ( <string_literal> ) then : output <identifiersep> event <identifiersep> listener . to <identifiersep> string ( ) == ' [ [ warn ] [ category ] before ] ' when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . info logging <identifiersep> manager . start ( ) <LOG> logger . warn ( <string_literal> ) then : output <identifiersep> event <identifiersep> listener . to <identifiersep> string ( ) == ' [ [ warn ] [ category ] before ] ' } def consumes <identifiersep> slf4j <identifiersep> when <identifiersep> started ( ) { standard <identifiersep> output <identifiersep> listener listener = mock ( ) given : <ect>
logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . start ( ) then : system . out != outputs . std <identifiersep> out <identifiersep> print <identifiersep> stream system . err != outputs . std <identifiersep> err <identifiersep> print <identifiersep> stream when : <LOG> system . err . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) <ect>
logging <identifiersep> manager . start ( ) when : def nested <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) nested <identifiersep> manager . capture <identifiersep> standard <identifiersep> error ( log <identifiersep> level . info ) nested <identifiersep> manager . capture <identifiersep> standard <identifiersep> output ( log <identifiersep> level . debug ) nested <identifiersep> manager . start ( ) <LOG> system . err . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : <ect>
then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : nested <identifiersep> manager . stop ( ) <LOG> system . err . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) <ect>
when : system . out . print ( <string_literal> ) system . err . print ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : <LOG> system . err . print ( <string_literal> ) system . err . println ( ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) then : <ect>
given : def logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> command <identifiersep> line <identifiersep> process <identifiersep> logging ( ) def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) when : logger . warn ( <string_literal> ) <LOG> then : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) <ect>
outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) logger . warn ( <string_literal> ) <LOG> then : outputs . std <identifiersep> out == text <identifiersep> util . to <identifiersep> platform <identifiersep> line <identifiersep> separators ( 'warning \\ n' ) outputs . std <identifiersep> err == text <identifiersep> util . to <identifiersep> platform <identifiersep> line <identifiersep> separators ( 'error \\ n' ) } def consumes <identifiersep> slf4j <identifiersep> when <identifiersep> embedded ( ) { given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> embeddable <identifiersep> logging ( ) <ect>
when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . start ( ) logger . warn ( <string_literal> ) <LOG> then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  <ect>
logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . set <identifiersep> level <identifiersep> internal ( log <identifiersep> level . info ) logging <identifiersep> manager . start ( ) when : def logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) logger . info ( <string_literal> ) <LOG> then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  <ect>
logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) def logger = logger . get <identifiersep> logger ( <string_literal> ) when : logger . info ( <string_literal> ) <LOG> logger . severe ( <string_literal> ) then : 0 * listener .  <identifiersep>  and : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) when : <LOG> logger . warning ( <string_literal> ) logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) <ect>
logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) when : logger . severe ( <string_literal> ) logger . warning ( <string_literal> ) <LOG> then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) logger . info ( <string_literal> ) logger . warning ( <string_literal> ) <ect>
logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) logger . info ( <string_literal> ) <LOG> logger . severe ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( 'error' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) <ect>
1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( 'error' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . stop ( ) <LOG> logger . warning ( <string_literal> ) logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  } def restores <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> settings <identifiersep> when <identifiersep> embedded <identifiersep> and <identifiersep> stopped ( ) { given : <ect>
1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . stop ( ) logger . severe ( <string_literal> ) logger . warning ( <string_literal> ) <LOG> then : 0 * listener .  <identifiersep>  } def restores <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> settings <identifiersep> when <identifiersep> embedded <identifiersep> and <identifiersep> stopped ( ) { given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> embeddable <identifiersep> logging ( ) def root <identifiersep> logger = logger . get <identifiersep> logger ( <string_literal> ) <ect>
logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) then : system . out != outputs . std <identifiersep> out <identifiersep> print <identifiersep> stream system . err != outputs . std <identifiersep> err <identifiersep> print <identifiersep> stream when : system . out . println ( <string_literal> ) <LOG> then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) <ect>
when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . start ( ) logger . warn ( <string_literal> ) <LOG> then : 0 * listener .  <identifiersep>  } def does <identifiersep> not <identifiersep> consume <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> when <identifiersep> nested ( ) { given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> nested <identifiersep> logging ( ) def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) <ect>
file project <identifiersep> dir = build <identifiersep> spec . get <identifiersep> working <identifiersep> directory ( ) ; perform <identifiersep> measurements ( new invocation <identifiersep> executor <identifiersep> provider ( ) { public action < measured <identifiersep> operation > runner ( final build <identifiersep> experiment <identifiersep> invocation <identifiersep> info invocation <identifiersep> info , final invocation <identifiersep> customizer invocation <identifiersep> customizer ) { return new action < measured <identifiersep> operation > ( ) { @ override public void execute ( measured <identifiersep> operation measured <identifiersep> operation ) { <LOG> list < string > clean <identifiersep> tasks = build <identifiersep> spec . get <identifiersep> clean <identifiersep> tasks ( ) ; if ( ! clean <identifiersep> tasks . is <identifiersep> empty ( ) ) { system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( build <identifiersep> spec . get <identifiersep> clean <identifiersep> tasks ( ) ) ) ; exec <identifiersep> action clean = create <identifiersep> maven <identifiersep> invocation ( build <identifiersep> spec , clean <identifiersep> tasks ) ; execute <identifiersep> with <identifiersep> file <identifiersep> logging ( experiment , clean ) ; } maven <identifiersep> invocation <identifiersep> spec invocation = invocation <identifiersep> customizer . customize ( invocation <identifiersep> info , build <identifiersep> spec ) ; <ect>
if ( ! clean <identifiersep> tasks . is <identifiersep> empty ( ) ) { system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( build <identifiersep> spec . get <identifiersep> clean <identifiersep> tasks ( ) ) ) ; exec <identifiersep> action clean = create <identifiersep> maven <identifiersep> invocation ( build <identifiersep> spec , clean <identifiersep> tasks ) ; execute <identifiersep> with <identifiersep> file <identifiersep> logging ( experiment , clean ) ; } maven <identifiersep> invocation <identifiersep> spec invocation = invocation <identifiersep> customizer . customize ( invocation <identifiersep> info , build <identifiersep> spec ) ; final exec <identifiersep> action run = create <identifiersep> maven <identifiersep> invocation ( invocation , invocation . get <identifiersep> tasks <identifiersep> to <identifiersep> run ( ) ) ; <LOG> duration <identifiersep> measurement <identifiersep> impl . measure ( measured <identifiersep> operation , new runnable ( ) { @ override public void run ( ) { execute <identifiersep> with <identifiersep> file <identifiersep> logging ( experiment , run ) ; } } ) ; } } ; <ect>
def tasks <identifiersep> to <identifiersep> run = invocation . tasks <identifiersep> to <identifiersep> run build <identifiersep> launcher build <identifiersep> launcher = configure <identifiersep> launcher ( invocation , tasks <identifiersep> to <identifiersep> run ) return { measured <identifiersep> operation measured <identifiersep> operation - > if ( clean <identifiersep> launcher != null ) { system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( clean <identifiersep> tasks ) ) ; clean <identifiersep> launcher . run ( ) } <LOG> duration <identifiersep> measurement <identifiersep> impl . measure ( measured <identifiersep> operation , new runnable ( ) { @ override void run ( ) { build <identifiersep> launcher . run ( ) } } ) } as action < measured <identifiersep> operation > <ect>
return { measured <identifiersep> operation measured <identifiersep> operation - > def clean <identifiersep> tasks = invocation . clean <identifiersep> tasks if ( clean <identifiersep> tasks ) { system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( clean <identifiersep> tasks ) ) ; run ( invocation <identifiersep> info , invocation , clean <identifiersep> tasks ) } def tasks <identifiersep> to <identifiersep> run = invocation . tasks <identifiersep> to <identifiersep> run <LOG> duration <identifiersep> measurement <identifiersep> impl . measure ( measured <identifiersep> operation ) { run ( invocation <identifiersep> info , invocation , tasks <identifiersep> to <identifiersep> run ) } } as action < measured <identifiersep> operation > } @ override void cleanup ( ) { if ( stop != null ) { <ect>
do <identifiersep> warmup ( experiment , project <identifiersep> dir , session ) ; do <identifiersep> measure ( experiment , results , project <identifiersep> dir , session ) ; } private void do <identifiersep> measure ( build <identifiersep> experiment <identifiersep> spec experiment , measured <identifiersep> operation <identifiersep> list results , file project <identifiersep> dir , invocation <identifiersep> executor <identifiersep> provider session ) { int invocation <identifiersep> count = invocations <identifiersep> for <identifiersep> experiment ( experiment ) ; for ( int i = 0 ; i < invocation <identifiersep> count ; i ++ ) { system . out . println ( ) ; <LOG> build <identifiersep> experiment <identifiersep> invocation <identifiersep> info info = new default <identifiersep> build <identifiersep> experiment <identifiersep> invocation <identifiersep> info ( experiment , project <identifiersep> dir , phase . measurement , i + 1 , invocation <identifiersep> count ) ; run <identifiersep> once ( session , results , info ) ; } } @ suppress <identifiersep> warnings ( <string_literal> ) protected invocation <identifiersep> customizer create <identifiersep> invocation <identifiersep> customizer ( final build <identifiersep> experiment <identifiersep> invocation <identifiersep> info info ) { if ( info . get <identifiersep> build <identifiersep> experiment <identifiersep> spec ( ) instanceof gradle <identifiersep> build <identifiersep> experiment <identifiersep> spec ) { return new invocation <identifiersep> customizer ( ) { <ect>
} ; } return null ; } private void do <identifiersep> warmup ( build <identifiersep> experiment <identifiersep> spec experiment , file project <identifiersep> dir , invocation <identifiersep> executor <identifiersep> provider session ) { int warm <identifiersep> up <identifiersep> count = warmups <identifiersep> for <identifiersep> experiment ( experiment ) ; for ( int i = 0 ; i < warm <identifiersep> up <identifiersep> count ; i ++ ) { system . out . println ( ) ; <LOG> build <identifiersep> experiment <identifiersep> invocation <identifiersep> info info = new default <identifiersep> build <identifiersep> experiment <identifiersep> invocation <identifiersep> info ( experiment , project <identifiersep> dir , phase . warmup , i + 1 , warm <identifiersep> up <identifiersep> count ) ; run <identifiersep> once ( session , new measured <identifiersep> operation <identifiersep> list ( ) , info ) ; } } private static string get <identifiersep> experiment <identifiersep> override ( string key ) { string value = system . get <identifiersep> property ( <string_literal> + key ) ; if ( value != null && ! <string_literal> . equals ( value ) ) { return value ; <ect>
post . set <identifiersep> header ( <string_literal> , <string_literal> ) post . set <identifiersep> header ( <string_literal> , <string_literal> ) post . set <identifiersep> entity ( new string <identifiersep> entity ( json , charsets . utf <identifiersep> <number_literal> ) ) def response = http <identifiersep> client . execute ( post ) try { if ( response . status <identifiersep> line . status <identifiersep> code != http <identifiersep> status . sc <identifiersep> ok ) { <LOG> } } finally { response . close ( ) } } static data <identifiersep> reporter < cross <identifiersep> version <identifiersep> performance <identifiersep> results > wrap ( data <identifiersep> reporter < cross <identifiersep> version <identifiersep> performance <identifiersep> results > reporter ) { def slack <identifiersep> webhook <identifiersep> url = system . getenv ( slack <identifiersep> webhook <identifiersep> url <identifiersep> env ) def slack <identifiersep> performance <identifiersep> report <identifiersep> channel = system . getenv ( slack <identifiersep> performance <identifiersep> report <identifiersep> channel <identifiersep> env ) if ( slack <identifiersep> webhook <identifiersep> url ) { <ect>
return tool <identifiersep> chain <identifiersep> restriction == null || tool <identifiersep> chain . meets ( tool <identifiersep> chain <identifiersep> restriction . value ( ) ) ; } @ override protected void assert <identifiersep> can <identifiersep> execute ( ) { assert tool <identifiersep> chain . is <identifiersep> available ( ) : string . format ( <string_literal> , tool <identifiersep> chain . get <identifiersep> display <identifiersep> name ( ) ) ; } @ override protected void before ( ) { <LOG> abstract <identifiersep> installed <identifiersep> tool <identifiersep> chain <identifiersep> integration <identifiersep> spec . set <identifiersep> tool <identifiersep> chain ( ( available <identifiersep> tool <identifiersep> chains . installed <identifiersep> tool <identifiersep> chain ) tool <identifiersep> chain ) ; } } } <ect>
private void clear <identifiersep> environment <identifiersep> vars ( mutable <identifiersep> command <identifiersep> line <identifiersep> tool <identifiersep> context invocation , string . . . names ) { <comment> <LOG> invocation . add <identifiersep> environment <identifiersep> var ( name , <string_literal> ) ; } } } private < t extends native <identifiersep> compile <identifiersep> spec > transformer < t , t > pch <identifiersep> spec <identifiersep> transforms ( final class < t > type ) { return new transformer < t , t > ( ) { @ override public t transform ( t original ) { list < transformer < t , t > > transformers = lists . new <identifiersep> array <identifiersep> list ( ) ; <ect>
<comment> <LOG> return null ; } try { string version <identifiersep> string = file <identifiersep> utils . read <identifiersep> file <identifiersep> to <identifiersep> string ( msvc <identifiersep> version <identifiersep> file ) . trim ( ) ; file visual <identifiersep> cpp <identifiersep> dir = new file ( install <identifiersep> dir , vs2017 <identifiersep> compiler <identifiersep> path <identifiersep> prefix + <string_literal> + version <identifiersep> string ) ; return new default <identifiersep> visual <identifiersep> cpp <identifiersep> metadata ( visual <identifiersep> cpp <identifiersep> dir , version <identifiersep> number . parse ( version <identifiersep> string ) ) ; } catch ( io <identifiersep> exception e ) { <ect>
try { string base <identifiersep> path = base <identifiersep> key + registry <identifiersep> rootpath <identifiersep> sdk + <string_literal> + subkey ; file sdk <identifiersep> dir = file <identifiersep> utils . canonicalize ( new file ( windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> path , registry <identifiersep> folder ) ) ) ; string version = format <identifiersep> version ( windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> path , registry <identifiersep> version ) ) ; string name = windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> path , registry <identifiersep> name ) ; if ( is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { <LOG> add <identifiersep> sdk ( sdk <identifiersep> dir , version , name ) ; } else { logger . debug ( <string_literal> , sdk <identifiersep> dir ) ; } } catch ( missing <identifiersep> registry <identifiersep> entry <identifiersep> exception e ) { <comment> <ect>
registry <identifiersep> kit <identifiersep> <number_literal> } ; for ( int i = 0 ; i != keys . length ; ++ i ) { try { file kit <identifiersep> dir = file <identifiersep> utils . canonicalize ( new file ( windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> key + registry <identifiersep> rootpath <identifiersep> kit , keys [ i ] ) ) ) ; if ( is <identifiersep> windows <identifiersep> sdk ( kit <identifiersep> dir ) ) { <LOG> add <identifiersep> sdk ( kit <identifiersep> dir , versions [ i ] , name <identifiersep> kit + <string_literal> + versions [ i ] ) ; } else { logger . debug ( <string_literal> , kit <identifiersep> dir ) ; } } catch ( missing <identifiersep> registry <identifiersep> entry <identifiersep> exception e ) { <comment> <ect>
logger . debug ( <string_literal> , kit <identifiersep> dir ) ; } } catch ( missing <identifiersep> registry <identifiersep> entry <identifiersep> exception e ) { <comment> <LOG> return ; } file sdk <identifiersep> dir = file <identifiersep> utils . canonicalize ( resource <identifiersep> compiler . get <identifiersep> parent <identifiersep> file ( ) . get <identifiersep> parent <identifiersep> file ( ) ) ; if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { sdk <identifiersep> dir = sdk <identifiersep> dir . get <identifiersep> parent <identifiersep> file ( ) ; if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { logger . debug ( <string_literal> , resource <identifiersep> compiler ) ; <ect>
return ; } file sdk <identifiersep> dir = file <identifiersep> utils . canonicalize ( resource <identifiersep> compiler . get <identifiersep> parent <identifiersep> file ( ) . get <identifiersep> parent <identifiersep> file ( ) ) ; if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { sdk <identifiersep> dir = sdk <identifiersep> dir . get <identifiersep> parent <identifiersep> file ( ) ; if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { logger . debug ( <string_literal> , resource <identifiersep> compiler ) ; } } <LOG> if ( ! found <identifiersep> sdks . contains <identifiersep> key ( sdk <identifiersep> dir ) ) { add <identifiersep> sdk ( sdk <identifiersep> dir , <string_literal> , <string_literal> ) ; } path <identifiersep> sdk = found <identifiersep> sdks . get ( sdk <identifiersep> dir ) ; } private search <identifiersep> result < windows <identifiersep> sdk <identifiersep> install > locate <identifiersep> user <identifiersep> specified <identifiersep> sdk ( file candidate ) { file sdk <identifiersep> dir = file <identifiersep> utils . canonicalize ( candidate ) ; if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { <ect>
t component = new <identifiersep> component ( windows <identifiersep> kit <identifiersep> dir , bin <identifiersep> dir , version , discovery <identifiersep> type ) ; found . add ( component ) ; } else if ( is <identifiersep> valid <identifiersep> component <identifiersep> bin <identifiersep> dir ( unversioned <identifiersep> bin <identifiersep> dir ) ) { t component = new <identifiersep> component ( windows <identifiersep> kit <identifiersep> dir , unversioned <identifiersep> bin <identifiersep> dir , version , discovery <identifiersep> type ) ; found . add ( component ) ; } } if ( found . is <identifiersep> empty ( ) ) { <LOG> } return found ; } private search <identifiersep> result < t > locate <identifiersep> user <identifiersep> specified <identifiersep> component ( file candidate ) { file windows <identifiersep> kit <identifiersep> dir = file <identifiersep> utils . canonicalize ( candidate ) ; set < t > candidates = found <identifiersep> components . get ( windows <identifiersep> kit <identifiersep> dir ) ; if ( candidates . is <identifiersep> empty ( ) ) { candidates = find <identifiersep> in ( windows <identifiersep> kit <identifiersep> dir , discovery <identifiersep> type . user ) ; <ect>
string visual <identifiersep> studio <identifiersep> display <identifiersep> version = install . get <identifiersep> version ( ) == version <identifiersep> number . unknown ? <string_literal> + source : install . get <identifiersep> version ( ) . to <identifiersep> string ( ) ; visual <identifiersep> cpp <identifiersep> install visual <identifiersep> cpp = build <identifiersep> visual <identifiersep> cpp <identifiersep> install ( <string_literal> + install . get <identifiersep> visual <identifiersep> cpp <identifiersep> version ( ) , visual <identifiersep> studio <identifiersep> dir , visual <identifiersep> cpp <identifiersep> dir , install . get <identifiersep> visual <identifiersep> cpp <identifiersep> version ( ) , install . get <identifiersep> compatibility ( ) ) ; visual <identifiersep> studio <identifiersep> install visual <identifiersep> studio = new visual <identifiersep> studio <identifiersep> install ( <string_literal> + visual <identifiersep> studio <identifiersep> display <identifiersep> version , visual <identifiersep> studio <identifiersep> dir , visual <identifiersep> studio <identifiersep> version , visual <identifiersep> cpp ) ; found <identifiersep> installs . put ( visual <identifiersep> studio <identifiersep> dir , visual <identifiersep> studio ) ; return true ; } else { <LOG> broken <identifiersep> installs . add ( visual <identifiersep> studio <identifiersep> dir ) ; return false ; } } private search <identifiersep> result < visual <identifiersep> studio <identifiersep> install > locate <identifiersep> user <identifiersep> specified <identifiersep> install ( file candidate ) { visual <identifiersep> studio <identifiersep> install <identifiersep> candidate install = version <identifiersep> determiner . get <identifiersep> visual <identifiersep> studio <identifiersep> metadata <identifiersep> from <identifiersep> install <identifiersep> dir ( candidate ) ; if ( install != null && add <identifiersep> install <identifiersep> if <identifiersep> valid ( install , <string_literal> ) ) { return new component <identifiersep> found < visual <identifiersep> studio <identifiersep> install > ( found <identifiersep> installs . get ( install . get <identifiersep> install <identifiersep> dir ( ) ) ) ; <ect>
private static class compiler { static work <identifiersep> result execute ( final iterable < file > scala <identifiersep> classpath , final iterable < file > zinc <identifiersep> classpath , file gradle <identifiersep> user <identifiersep> home , final scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { logger . info ( <string_literal> ) ; final xsbti . logger logger = new sbt <identifiersep> logger <identifiersep> adapter ( ) ; timer timer = time . start <identifiersep> timer ( ) ; com . typesafe . zinc . compiler compiler = zinc <identifiersep> scala <identifiersep> compiler <identifiersep> factory . create <identifiersep> parallel <identifiersep> safe <identifiersep> compiler ( scala <identifiersep> classpath , zinc <identifiersep> classpath , logger , gradle <identifiersep> user <identifiersep> home ) ; <LOG> list < string > scalac <identifiersep> options = new zinc <identifiersep> scala <identifiersep> compiler <identifiersep> arguments <identifiersep> generator ( ) . generate ( spec ) ; list < string > javac <identifiersep> options = new java <identifiersep> compiler <identifiersep> arguments <identifiersep> builder ( spec ) . include <identifiersep> classpath ( false ) . no <identifiersep> empty <identifiersep> source <identifiersep> path ( ) . build ( ) ; inputs inputs = inputs . create ( immutable <identifiersep> list . copy <identifiersep> of ( spec . get <identifiersep> compile <identifiersep> classpath ( ) ) , immutable <identifiersep> list . copy <identifiersep> of ( spec . get <identifiersep> source ( ) ) , spec . get <identifiersep> destination <identifiersep> dir ( ) , scalac <identifiersep> options , javac <identifiersep> options , spec . get <identifiersep> scala <identifiersep> compile <identifiersep> options ( ) . get <identifiersep> incremental <identifiersep> options ( ) . get <identifiersep> analysis <identifiersep> file ( ) , spec . get <identifiersep> analysis <identifiersep> map ( ) , <string_literal> , get <identifiersep> inc <identifiersep> options ( ) , true ) ; inputs . debug ( inputs , logger ) ; <ect>
g <identifiersep> file <identifiersep> utils . delete <identifiersep> directory ( spec . get <identifiersep> destination <identifiersep> dir ( ) ) ; } logger . info ( <string_literal> , timer . get <identifiersep> elapsed ( ) ) ; try { compiler . compile ( inputs , logger ) ; } catch ( xsbti . compile <identifiersep> failed e ) { throw new compilation <identifiersep> failed <identifiersep> exception ( e ) ; } <LOG> return work <identifiersep> results . did <identifiersep> work ( true ) ; } private static inc <identifiersep> options get <identifiersep> inc <identifiersep> options ( ) { <comment> <ect>
protected void configure <identifiersep> incremental <identifiersep> compilation ( scala <identifiersep> compile <identifiersep> spec spec ) { map < file , file > global <identifiersep> analysis <identifiersep> map = create <identifiersep> or <identifiersep> get <identifiersep> global <identifiersep> analysis <identifiersep> map ( ) ; hash <identifiersep> map < file , file > filtered <identifiersep> map = filter <identifiersep> for <identifiersep> classpath ( global <identifiersep> analysis <identifiersep> map , spec . get <identifiersep> compile <identifiersep> classpath ( ) ) ; spec . set <identifiersep> analysis <identifiersep> map ( filtered <identifiersep> map ) ; logger . debug ( <string_literal> , scala <identifiersep> compile <identifiersep> options . get <identifiersep> incremental <identifiersep> options ( ) . get <identifiersep> analysis <identifiersep> file ( ) ) ; <LOG> logger . debug ( <string_literal> , filtered <identifiersep> map ) ; } } @ suppress <identifiersep> warnings ( <string_literal> ) protected map < file , file > create <identifiersep> or <identifiersep> get <identifiersep> global <identifiersep> analysis <identifiersep> map ( ) { extra <identifiersep> properties <identifiersep> extension extra <identifiersep> properties = get <identifiersep> project ( ) . get <identifiersep> root <identifiersep> project ( ) . get <identifiersep> extensions ( ) . get <identifiersep> extra <identifiersep> properties ( ) ; map < file , file > analysis <identifiersep> map ; if ( extra <identifiersep> properties . has ( <string_literal> ) ) { <ect>
package controllers . scla ; import play . * ; import play . mvc . * ; import views . html . * ; public class mixed <identifiersep> java extends controller { public static result index ( ) { <LOG> return ok ( index . render ( <string_literal> ) ) ; } } <ect>
final play <identifiersep> app <identifiersep> lifecycle <identifiersep> update result = start ( ) ; try { client <identifiersep> protocol . update ( result ) ; while ( ! stop <identifiersep> requested ) { play <identifiersep> app <identifiersep> lifecycle <identifiersep> update update = events . take ( ) ; client <identifiersep> protocol . update ( update ) ; } <LOG> events . clear ( ) ; } catch ( interrupted <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } private play <identifiersep> app <identifiersep> lifecycle <identifiersep> update start ( ) { try { inet <identifiersep> socket <identifiersep> address address = start <identifiersep> server ( ) ; <ect>
lock . unlock ( ) ; } } @ override public result require <identifiersep> up <identifiersep> to <identifiersep> date ( ) throws interrupted <identifiersep> exception { lock . lock ( ) ; try { if ( ! stop <identifiersep> requested ) { <LOG> events . put ( play <identifiersep> app <identifiersep> lifecycle <identifiersep> update . reload <identifiersep> requested ( ) ) ; logger . debug ( <string_literal> ) ; result old <identifiersep> status = latest <identifiersep> status ; while ( latest <identifiersep> status == old <identifiersep> status && ! stop <identifiersep> requested ) { signal . await ( ) ; } logger . debug ( <string_literal> , latest <identifiersep> status ) ; <ect>
logger . debug ( <string_literal> ) ; events . put ( play <identifiersep> app <identifiersep> lifecycle <identifiersep> update . reload <identifiersep> requested ( ) ) ; logger . debug ( <string_literal> ) ; result old <identifiersep> status = latest <identifiersep> status ; while ( latest <identifiersep> status == old <identifiersep> status && ! stop <identifiersep> requested ) { signal . await ( ) ; } <LOG> return latest <identifiersep> status ; } } finally { lock . unlock ( ) ; } <comment> <ect>
if ( deployment <identifiersep> handle == null ) { play <identifiersep> run <identifiersep> spec spec = new default <identifiersep> play <identifiersep> run <identifiersep> spec ( runtime <identifiersep> classpath , changing <identifiersep> classpath , application <identifiersep> jar , assets <identifiersep> jar , assets <identifiersep> dirs , working <identifiersep> dir . get ( ) . get <identifiersep> as <identifiersep> file ( ) , get <identifiersep> fork <identifiersep> options ( ) , get <identifiersep> http <identifiersep> port ( ) ) ; play <identifiersep> application <identifiersep> runner play <identifiersep> application <identifiersep> runner = play <identifiersep> tool <identifiersep> provider . get ( play <identifiersep> application <identifiersep> runner . class ) ; deployment <identifiersep> handle = deployment <identifiersep> registry . start ( deployment <identifiersep> id , deployment <identifiersep> registry . change <identifiersep> behavior . block , play <identifiersep> application <identifiersep> deployment <identifiersep> handle . class , spec , play <identifiersep> application <identifiersep> runner ) ; inet <identifiersep> socket <identifiersep> address play <identifiersep> app <identifiersep> address = deployment <identifiersep> handle . get <identifiersep> play <identifiersep> app <identifiersep> address ( ) ; string play <identifiersep> url = <string_literal> + play <identifiersep> app <identifiersep> address . get <identifiersep> port ( ) + <string_literal> ; <LOG> } } <comment> <ect>
} catch ( exception e ) { log . debug ( <string_literal> , cache <identifiersep> display <identifiersep> name , cleanup <identifiersep> action ) ; } } if ( file <identifiersep> lock <identifiersep> held <identifiersep> by <identifiersep> owner != null ) { file <identifiersep> lock <identifiersep> held <identifiersep> by <identifiersep> owner . run ( ) ; } cross <identifiersep> process <identifiersep> cache <identifiersep> access . close ( ) ; if ( cache <identifiersep> closed <identifiersep> count != 1 ) { <LOG> } } finally { owner = null ; file <identifiersep> lock <identifiersep> held <identifiersep> by <identifiersep> owner = null ; state <identifiersep> lock . unlock ( ) ; } } @ override public < t > t with <identifiersep> file <identifiersep> lock ( factory < ? extends t > action ) { <ect>
static boolean is <identifiersep> reserved ( persistent <identifiersep> cache persistent <identifiersep> cache , file file ) { return persistent <identifiersep> cache . get <identifiersep> reserved <identifiersep> cache <identifiersep> files ( ) . contains ( file ) ; } @ visible <identifiersep> for <identifiersep> testing static void cleanup <identifiersep> files ( persistent <identifiersep> cache persistent <identifiersep> cache , list < file > files <identifiersep> for <identifiersep> deletion ) { <comment> <LOG> } private static long delete <identifiersep> files ( list < file > files ) { long removed <identifiersep> size = 0 ; for ( file file : files ) { try { long size = file . length ( ) ; if ( g <identifiersep> file <identifiersep> utils . delete <identifiersep> quietly ( file ) ) { <ect>
state <identifiersep> lock . lock ( ) ; try { if ( file <identifiersep> lock == null ) { if ( lock <identifiersep> count != 0 ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <LOG> } file <identifiersep> lock = lock <identifiersep> manager . lock ( lock <identifiersep> target , lock <identifiersep> options , cache <identifiersep> display <identifiersep> name , <string_literal> , when <identifiersep> contended ) ; try { if ( init <identifiersep> action . requires <identifiersep> initialization ( file <identifiersep> lock ) ) { file <identifiersep> lock . write <identifiersep> file ( new runnable ( ) { @ override public void run ( ) { <ect>
private class contended <identifiersep> action implements runnable { @ override public void run ( ) { state <identifiersep> lock . lock ( ) ; try { if ( lock <identifiersep> count == 0 ) { <LOG> release <identifiersep> lock <identifiersep> if <identifiersep> held ( ) ; } else { <comment> <ect>
<comment> <LOG> return false ; } else { throw e ; } } } } catch ( io <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( string . format ( <string_literal> , display <identifiersep> name , lock <identifiersep> id , owner <identifiersep> port ) , e ) ; } return true ; <ect>
public void run ( ) { try { logger . debug ( <string_literal> ) ; do <identifiersep> run ( ) ; } catch ( throwable t ) { <comment> <LOG> } finally { logger . debug ( <string_literal> ) ; } } private void do <identifiersep> run ( ) { while ( true ) { datagram <identifiersep> packet packet ; long lock <identifiersep> id ; <ect>
} ; } private void start <identifiersep> lock <identifiersep> release <identifiersep> as <identifiersep> lock <identifiersep> holder ( contended <identifiersep> action contended <identifiersep> action ) { contended <identifiersep> action . running = true ; unlock <identifiersep> action <identifiersep> executor . execute ( contended <identifiersep> action . action ) ; } private void accept <identifiersep> confirmation <identifiersep> as <identifiersep> lock <identifiersep> requester ( long lock <identifiersep> id , int port ) { unlocks <identifiersep> confirmed <identifiersep> from . put ( lock <identifiersep> id , port ) ; <LOG> } public void start ( long lock <identifiersep> id , runnable when <identifiersep> contended ) { lock . lock ( ) ; unlocks <identifiersep> requested <identifiersep> from . remove ( lock <identifiersep> id ) ; unlocks <identifiersep> confirmed <identifiersep> from . remove ( lock <identifiersep> id ) ; try { assert <identifiersep> not <identifiersep> stopped ( ) ; <ect>
close ( ) ; try { open ( ) ; } catch ( exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( e ) ; } } public void close ( ) { <LOG> try { store . close ( ) ; } catch ( exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( e ) ; } } public boolean is <identifiersep> open ( ) { return store . is <identifiersep> open ( ) ; <ect>
locked <identifiersep> files . remove ( target ) ; } } ) ; stoppable . stop ( ) ; } public lock <identifiersep> mode get <identifiersep> mode ( ) { return mode ; } private lock <identifiersep> state lock ( lock <identifiersep> mode lock <identifiersep> mode ) throws throwable { <LOG> <comment> <ect>
throw t ; } } private lock <identifiersep> info read <identifiersep> information <identifiersep> region ( exponential <identifiersep> backoff backoff ) throws io <identifiersep> exception , interrupted <identifiersep> exception { <comment> <LOG> } else { try { out = lock <identifiersep> file <identifiersep> access . read <identifiersep> lock <identifiersep> info ( ) ; } finally { information <identifiersep> region <identifiersep> lock . release ( ) ; } } return out ; <ect>
last <identifiersep> lock <identifiersep> holder <identifiersep> port = lock <identifiersep> info . port ; last <identifiersep> ping <identifiersep> time = 0 ; } if ( file <identifiersep> lock <identifiersep> contention <identifiersep> handler . maybe <identifiersep> ping <identifiersep> owner ( lock <identifiersep> info . port , lock <identifiersep> info . lock <identifiersep> id , display <identifiersep> name , backoff . timer . get <identifiersep> elapsed <identifiersep> millis ( ) - last <identifiersep> ping <identifiersep> time ) ) { last <identifiersep> ping <identifiersep> time = backoff . timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; logger . debug ( <string_literal> , lock <identifiersep> info . pid , lock <identifiersep> info . lock <identifiersep> id , lock <identifiersep> info . port ) ; } } else { <LOG> } } return null ; } } ) ; } private java . nio . channels . file <identifiersep> lock lock <identifiersep> information <identifiersep> region ( final lock <identifiersep> mode lock <identifiersep> mode , exponential <identifiersep> backoff backoff ) throws io <identifiersep> exception , interrupted <identifiersep> exception { return backoff . retry <identifiersep> until ( new io <identifiersep> query < java . nio . channels . file <identifiersep> lock > ( ) { @ override public java . nio . channels . file <identifiersep> lock run ( ) throws io <identifiersep> exception { <ect>
create <identifiersep> main <identifiersep> class ( ) populate <identifiersep> build <identifiersep> file ( ) populate <identifiersep> settings <identifiersep> file ( ) } private void create <identifiersep> main <identifiersep> class ( ) { generate <identifiersep> main <identifiersep> class <string_literal> <string_literal> app home : <string_literal> app <identifiersep> home <identifiersep> system <identifiersep> prop <string_literal> <LOG> system . out . println ( <string_literal> ) ; <string_literal> <string_literal> <string_literal> package org . gradle . test ; public class main { <ect>
then : skipped <identifiersep> tasks . contains ( <string_literal> ) } def <string_literal> ( ) { given : succeeds ( <string_literal> ) when : <LOG> succeeds ( <string_literal> ) then : skipped <identifiersep> tasks . contains ( <string_literal> ) } } <ect>
private void create <identifiersep> main <identifiersep> class ( ) { file ( 'src / main / java / org / gradle / test / main . java' ) < < <string_literal> <string_literal> app home : <string_literal> app <identifiersep> home <identifiersep> system <identifiersep> prop <string_literal> <LOG> for ( string arg : args ) { system . out . println ( <string_literal> + arg ) ; } } } <string_literal> <string_literal> <string_literal> apply plugin : 'application' <ect>
file ( src <identifiersep> dir , 'org / test / security <identifiersep> test . groovy' ) < < <string_literal> <string_literal> <LOG> set <identifiersep> up ( ) ; system . out . println ( <string_literal> + i ) ; } } } class security <identifiersep> test <identifiersep> support extends groovy <identifiersep> test <identifiersep> case { <comment> <ect>
class security <identifiersep> test <identifiersep> support extends groovy <identifiersep> test <identifiersep> case { <comment> <LOG> system . set <identifiersep> security <identifiersep> manager ( new security <identifiersep> manager ( ) ) ; } } <string_literal> <string_literal> <ect>
then : skipped <identifiersep> tasks . contains <identifiersep> all ( [ ' : compile <identifiersep> java' , ' : compile <identifiersep> groovy' ] ) when : file ( 'src / main / java / required <identifiersep> by <identifiersep> groovy . java' ) . text = <string_literal> <string_literal> <LOG> <comment> <ect>
main <identifiersep> class <identifiersep> name = 'main' <string_literal> <string_literal> src / main / java / main . java <string_literal> <string_literal> public class main { public static void main ( string [ ] args ) { system . out . println ( <string_literal> + system . get <identifiersep> property ( <string_literal> ) ) ; <LOG> } } <string_literal> <string_literal> java home : $ { file <identifiersep> utils . canonicalize ( target . java <identifiersep> home ) } <string_literal> java version : $ { version } <string_literal> can generate javadocs using target java version <string_literal> <ect>
skipped ' : b : compile <identifiersep> java' when : <comment> <LOG> public object s = <string_literal> ; public void execute ( ) { string s = to <identifiersep> string ( ) ; } } <string_literal> <string_literal> <ect>
obj . set <identifiersep> global <identifiersep> id ( obj . generate <identifiersep> gid ( gid <identifiersep> generator ) ) ; log . trace ( <string_literal> , obj ) ; } else { <comment> <LOG> return obj . get <identifiersep> global <identifiersep> id ( ) ; } else { log . trace ( <string_literal> , obj ) ; } } <comment> <ect>
logger . append ( <string_literal> ) ; progress <identifiersep> counter = progress <identifiersep> counter - progress <identifiersep> chunk ; if ( progress <identifiersep> listener != null ) { progress <identifiersep> listener . download <identifiersep> status <identifiersep> changed ( address , content <identifiersep> length , num <identifiersep> downloaded ) ; } } out . write ( buffer , 0 , num <identifiersep> read ) ; } } finally { <LOG> if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } } } <comment> <ect>
return get <identifiersep> and <identifiersep> verify <identifiersep> distribution <identifiersep> root ( dist <identifiersep> dir , dist <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; } boolean needs <identifiersep> download = ! local <identifiersep> zip <identifiersep> file . is <identifiersep> file ( ) ; uri safe <identifiersep> distribution <identifiersep> url = download . safe <identifiersep> uri ( distribution <identifiersep> url ) ; if ( needs <identifiersep> download ) { file tmp <identifiersep> zip <identifiersep> file = new file ( local <identifiersep> zip <identifiersep> file . get <identifiersep> parent <identifiersep> file ( ) , local <identifiersep> zip <identifiersep> file . get <identifiersep> name ( ) + <string_literal> ) ; tmp <identifiersep> zip <identifiersep> file . delete ( ) ; <LOG> download . download ( distribution <identifiersep> url , tmp <identifiersep> zip <identifiersep> file ) ; tmp <identifiersep> zip <identifiersep> file . rename <identifiersep> to ( local <identifiersep> zip <identifiersep> file ) ; } list < file > top <identifiersep> level <identifiersep> dirs = list <identifiersep> dirs ( dist <identifiersep> dir ) ; for ( file dir : top <identifiersep> level <identifiersep> dirs ) { logger . log ( <string_literal> + dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; delete <identifiersep> dir ( dir ) ; <ect>
tmp <identifiersep> zip <identifiersep> file . rename <identifiersep> to ( local <identifiersep> zip <identifiersep> file ) ; } list < file > top <identifiersep> level <identifiersep> dirs = list <identifiersep> dirs ( dist <identifiersep> dir ) ; for ( file dir : top <identifiersep> level <identifiersep> dirs ) { logger . log ( <string_literal> + dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; delete <identifiersep> dir ( dir ) ; } verify <identifiersep> download <identifiersep> checksum ( configuration . get <identifiersep> distribution ( ) . to <identifiersep> string ( ) , local <identifiersep> zip <identifiersep> file , distribution <identifiersep> sha256sum ) ; <LOG> unzip ( local <identifiersep> zip <identifiersep> file , dist <identifiersep> dir ) ; file root = get <identifiersep> and <identifiersep> verify <identifiersep> distribution <identifiersep> root ( dist <identifiersep> dir , safe <identifiersep> distribution <identifiersep> url . to <identifiersep> string ( ) ) ; set <identifiersep> executable <identifiersep> permissions ( root ) ; marker <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ; return root ; } } ) ; <ect>
error <identifiersep> message = stdout . to <identifiersep> string ( ) ; } } catch ( io <identifiersep> exception e ) { error <identifiersep> message = e . get <identifiersep> message ( ) ; } catch ( interrupted <identifiersep> exception e ) { error <identifiersep> message = e . get <identifiersep> message ( ) ; } if ( error <identifiersep> message != null ) { <LOG> logger . log ( <string_literal> ) ; } } private boolean is <identifiersep> windows ( ) { string os <identifiersep> name = system . get <identifiersep> property ( <string_literal> ) . to <identifiersep> lower <identifiersep> case ( locale . us ) ; if ( os <identifiersep> name . index <identifiersep> of ( <string_literal> ) > - 1 ) { return true ; } return false ; <ect>
private final static logger logger = logging . get <identifiersep> logger ( project <identifiersep> layout <identifiersep> setup <identifiersep> registry . class ) ; private final map < string , project <identifiersep> init <identifiersep> descriptor > registered <identifiersep> project <identifiersep> descriptors = new hash <identifiersep> map < string , project <identifiersep> init <identifiersep> descriptor > ( ) ; public void add ( final string descriptor <identifiersep> id , project <identifiersep> init <identifiersep> descriptor descriptor ) { if ( registered <identifiersep> project <identifiersep> descriptors . contains <identifiersep> key ( descriptor <identifiersep> id ) ) { throw new gradle <identifiersep> exception ( string . format ( <string_literal> , descriptor <identifiersep> id ) ) ; } registered <identifiersep> project <identifiersep> descriptors . put ( descriptor <identifiersep> id , descriptor ) ; <LOG> } public project <identifiersep> init <identifiersep> descriptor get ( string type ) { return registered <identifiersep> project <identifiersep> descriptors . get ( type ) ; } public list < project <identifiersep> init <identifiersep> descriptor > get <identifiersep> all ( ) { return collection <identifiersep> utils . to <identifiersep> list ( registered <identifiersep> project <identifiersep> descriptors . values ( ) ) ; } public list < string > get <identifiersep> supported <identifiersep> types ( ) { return collection <identifiersep> utils . sort ( registered <identifiersep> project <identifiersep> descriptors . key <identifiersep> set ( ) ) ; <ect>
public class some <identifiersep> more <identifiersep> local <identifiersep> tests { @ test public void some <identifiersep> more <identifiersep> test1 ( ) { system . out . println ( <string_literal> + locale <identifiersep> holder . get ( ) ) ; } @ test public void some <identifiersep> more <identifiersep> test2 ( ) { <LOG> } } <ect>
@ test public void ok1 ( ) { system . out . println ( <string_literal> + locale <identifiersep> holder . get ( ) ) ; } @ test @ category ( org . gradle . category <identifiersep> a . class ) public void ok2 ( ) { <LOG> } <ect>
<comment> package org . gradle ; public class ok <identifiersep> test { @ org . junit . test public void ok ( ) throws exception { <LOG> } @ org . junit . test public void another <identifiersep> ok ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <ect>
@ org . junit . test public void ok ( ) throws exception { system . err . println ( <string_literal> ) ; } @ org . junit . test public void another <identifiersep> ok ( ) { system . out . println ( <string_literal> ) ; <LOG> } } <ect>
@ run <identifiersep> with ( suite . class ) @ suite . suite <identifiersep> classes ( { ok <identifiersep> test . class , other <identifiersep> test . class } ) public class a <identifiersep> suite { static { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { <LOG> system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <ect>
public class a <identifiersep> suite { static { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <ect>
@ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; <LOG> } } <ect>
final test <identifiersep> suite suite = new test <identifiersep> suite ( ) ; suite . add <identifiersep> test <identifiersep> suite ( some <identifiersep> test1 . class ) ; suite . add <identifiersep> test <identifiersep> suite ( some <identifiersep> test2 . class ) ; test <identifiersep> setup wrapped <identifiersep> suite = new junit . extensions . test <identifiersep> setup ( suite ) { protected void set <identifiersep> up ( ) { system . out . println ( <string_literal> ) ; <LOG> } protected void tear <identifiersep> down ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } ; return wrapped <identifiersep> suite ; } } <ect>
test <identifiersep> setup wrapped <identifiersep> suite = new junit . extensions . test <identifiersep> setup ( suite ) { protected void set <identifiersep> up ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } protected void tear <identifiersep> down ( ) { system . out . println ( <string_literal> ) ; <LOG> } } ; return wrapped <identifiersep> suite ; } } <ect>
public class hello <identifiersep> stepdefs { @ given ( <string_literal> ) public void i <identifiersep> have <identifiersep> a <identifiersep> hello <identifiersep> app <identifiersep> with ( ) { system . out . println ( <string_literal> ) ; } @ when ( <string_literal> ) public void i <identifiersep> ask <identifiersep> it <identifiersep> to <identifiersep> say <identifiersep> hi ( ) { <LOG> } @ then ( <string_literal> ) public void it <identifiersep> should <identifiersep> answer <identifiersep> with ( ) { system . out . println ( <string_literal> ) ; } <ect>
private static string test <identifiersep> class ( string class <identifiersep> name ) { return <string_literal> <string_literal> <LOG> assert . assert <identifiersep> equals ( 1 , 1 ) ; } } <string_literal> <string_literal> <string_literal> apply plugin : 'java' $ { jcenter <identifiersep> repository ( ) } <ect>
list < thread > threads = new array <identifiersep> list < thread > ( ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { thread thread = new thread ( <string_literal> + i ) { @ override public void run ( ) { system . out . print ( <string_literal> ) ; <comment> <LOG> system . out . println ( get <identifiersep> name ( ) ) ; logger . get <identifiersep> logger ( <string_literal> ) . info ( <string_literal> + get <identifiersep> name ( ) ) ; } } ; thread . start ( ) ; threads . add ( thread ) ; } for ( thread thread : threads ) { <ect>
on <identifiersep> output { test , event - > print <string_literal> } } <string_literal> <string_literal> src / test / java / foo <identifiersep> test . java <string_literal> <string_literal> import org . testng . annotations . * ; public class foo <identifiersep> test { static { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } public foo <identifiersep> test ( ) { <LOG> } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . print ( <string_literal> ) ; <ect>
static { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } public foo <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { <LOG> } @ test public void m1 ( ) { system . out . print ( <string_literal> ) ; system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { <ect>
@ test public void m1 ( ) { system . out . print ( <string_literal> ) ; system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { <LOG> } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> attaches events to correct test descriptors of a suite <string_literal> <ect>
system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { <LOG> } } <string_literal> <string_literal> test <string_literal> <string_literal> test1 . before <identifiersep> class ( ) test1 . test1 ( ) <ect>
package org . gradle . factory ; import org . testng . annotations . test ; public class factory <identifiersep> test { private final string name ; public factory <identifiersep> test ( string name ) { this . name = name ; } @ test <LOG> } ''' . strip <identifiersep> indent ( ) file ( 'src / test / java / org / gradle / factory / test <identifiersep> ng <identifiersep> factory . java' ) < < ''' package org . gradle . factory ; import org . testng . annotations . factory ; public class test <identifiersep> ng <identifiersep> factory { @ factory <ect>
void create <identifiersep> passing <identifiersep> failing <identifiersep> test ( ) { file ( 'src / test / java / app <identifiersep> exception . java' ) < < 'public class app <identifiersep> exception extends exception { } ' file ( 'src / test / java / some <identifiersep> test . java' ) < < <string_literal> <string_literal> <LOG> assert false : <string_literal> ; } @ org . testng . annotations . test public void $ { passing <identifiersep> test <identifiersep> case <identifiersep> name } ( ) { } } <string_literal> <string_literal> <string_literal> public class some <identifiersep> other <identifiersep> test { <ect>
this . data = data ; } @ before <identifiersep> class public void before <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test public void test1 ( ) { <LOG> } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; <ect>
system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { <LOG> } } <string_literal> <string_literal> test <string_literal> <string_literal> test <identifiersep> factory [ data1 ] . before <identifiersep> class ( ) test <identifiersep> factory [ data1 ] . test1 ( ) <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> out . pass <string_literal> <LOG> } @ test public void failing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } @ test public void passing2 ( ) { system . out . println ( <string_literal> ) ; <ect>
public class mixed <identifiersep> methods <identifiersep> test { @ test public void passing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void failing ( ) { system . out . println ( <string_literal> ) ; <LOG> fail ( <string_literal> ) ; } @ test public void passing2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void failing2 ( ) { system . out . println ( <string_literal> ) ; <ect>
@ test public void failing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } @ test public void passing2 ( ) { system . out . println ( <string_literal> ) ; <LOG> } @ test public void failing2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } @ test ( enabled = false ) public void skipped ( ) { } } <string_literal> <string_literal> <ect>
fail ( <string_literal> ) ; } @ test public void passing2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void failing2 ( ) { system . out . println ( <string_literal> ) ; <LOG> fail ( <string_literal> ) ; } @ test ( enabled = false ) public void skipped ( ) { } } <string_literal> <string_literal> src / test / java / org / passing <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; public class passing <identifiersep> test { <ect>
<string_literal> <string_literal> src / test / java / org / failing <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; import static org . testng . assert . * ; public class failing <identifiersep> test { @ test public void failing ( ) { <LOG> fail ( ) ; } @ test public void failing2 ( ) { fail ( ) ; } } <string_literal> <string_literal> src / test / java / org / no <identifiersep> outputs <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> < html allowed , cdata closing token ] ] > encoded ! <string_literal> no eol , <string_literal> <LOG> system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / org / parameterized <identifiersep> test . java <string_literal> <string_literal> package org ; <ect>
public class encoding <identifiersep> test { @ test public void encodes <identifiersep> cdata ( ) { system . out . println ( <string_literal> ) ; system . out . print ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / org / parameterized <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; import static org . testng . assert . * ; <ect>
import org . testng . annotations . * ; import static org . testng . assert . * ; public class parameterized <identifiersep> test { @ test ( data <identifiersep> provider = <string_literal> ) public void p1 ( string var1 , string var2 ) { system . out . println ( <string_literal> + var1 ) ; <LOG> assert <identifiersep> equals ( var1 , <string_literal> ) ; } @ data <identifiersep> provider ( name = <string_literal> ) public object [ ] [ ] provider1 ( ) { return new object [ ] [ ] { { <string_literal> , <string_literal> } , { <string_literal> , <string_literal> } <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> constructor out <string_literal> <LOG> } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { <ect>
public output <identifiersep> lifecycle <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; <LOG> } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; <ect>
public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; <LOG> } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
) test <identifiersep> directory . file ( 'src / test / java / org / gradle / abstract <identifiersep> test . java' ) . writelns ( <string_literal> , <string_literal> , <string_literal> , <string_literal> , <LOG> <string_literal> , <string_literal> ) test <identifiersep> directory . file ( 'src / test / java / org / gradle / some <identifiersep> test . java' ) . writelns ( <string_literal> , <string_literal> , <string_literal> ) <ect>
<string_literal> ) file ( \'src / test / java / some <identifiersep> test . java\' ) < < <string_literal> <string_literal> <LOG> org . junit . assert . fail ( \\ " test failure message \\ " ) ; } @ org . junit . test public void $ { passing <identifiersep> test <identifiersep> case <identifiersep> name } ( ) { } } <string_literal> <string_literal> <string_literal> public class some <identifiersep> other <identifiersep> test { <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> < html allowed , cdata closing token ] ] > encoded ! <string_literal> no eol , <string_literal> <LOG> system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
public class encoding <identifiersep> test { @ test public void encodes <identifiersep> cdata ( ) { system . out . println ( <string_literal> ) ; system . out . print ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> <ect>
on <identifiersep> output { test , event - > print <string_literal> } } <string_literal> <string_literal> captures logging output events <string_literal> src / test / java / ok <identifiersep> test . java <string_literal> <string_literal> public class ok <identifiersep> test { static { <LOG> } public ok <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { <ect>
public class ok <identifiersep> test { static { system . out . println ( <string_literal> ) ; } public ok <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . before public void before ( ) { <ect>
public ok <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . before public void before ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <ect>
system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . before public void before ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . after public void after ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . test <ect>
@ org . junit . before public void before ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after public void after ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . test public void ok ( ) { system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . test public void ok ( ) { system . out . print ( <string_literal> ) ; system . out . println ( ) ; <LOG> } @ org . junit . test public void another <identifiersep> ok ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> <ect>
system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; } @ org . junit . test public void another <identifiersep> ok ( ) { system . out . println ( <string_literal> ) ; <LOG> } } <string_literal> <string_literal> test <string_literal> <string_literal> test class ok <identifiersep> test - > class loaded test class ok <identifiersep> test - > before class out test class ok <identifiersep> test - > before class err <ect>
! output . contains ( 'a <identifiersep> test ! ' ) output . contains ( 'b <identifiersep> test ! ' ) ! output . contains ( 'c <identifiersep> test ! ' ) } private create <identifiersep> test <identifiersep> abc ( ) { file ( 'src / test / java / a <identifiersep> test . java' ) < < <string_literal> <string_literal> <LOG> } <string_literal> <string_literal> <string_literal> import $imports ; public class b <identifiersep> test { @ test public void test ( ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <string_literal> import $imports ; <ect>
file ( 'src / test / java / b <identifiersep> test . java' ) < < <string_literal> <string_literal> b <identifiersep> test ! <string_literal> <string_literal> file ( 'src / test / java / c <identifiersep> test . java' ) < < <string_literal> <string_literal> <LOG> } <string_literal> <string_literal> <ect>
def test = file ( <string_literal> ) test < < <string_literal> <string_literal> out passing <string_literal> <LOG> assert . assert <identifiersep> true ( true ) ; } @ test public void shows <identifiersep> output <identifiersep> when <identifiersep> failing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; assert . assert <identifiersep> true ( false ) ; } } <string_literal> <string_literal> <ect>
@ test public void shows <identifiersep> output <identifiersep> when <identifiersep> passing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; assert . assert <identifiersep> true ( true ) ; } @ test public void shows <identifiersep> output <identifiersep> when <identifiersep> failing ( ) { system . out . println ( <string_literal> ) ; <LOG> assert . assert <identifiersep> true ( false ) ; } } <string_literal> <string_literal> <string_literal> apply plugin : 'java' $ { maven <identifiersep> central <identifiersep> repository ( ) } <ect>
given : def test = file ( <string_literal> ) test < < <string_literal> <string_literal> <LOG> } } <string_literal> <string_literal> <string_literal> apply plugin : 'java' $ { maven <identifiersep> central <identifiersep> repository ( ) } dependencies { test <identifiersep> compile <string_literal> } <ect>
system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / org / gradle / testing / sub <identifiersep> test . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude public class sub <identifiersep> test { @ category ( sub <identifiersep> class <identifiersep> tests . class ) @ test public void only <identifiersep> sub ( ) { <LOG> assert <identifiersep> equals ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } @ category ( sub <identifiersep> class <identifiersep> tests . class ) @ test public void passing ( ) { system . out . println ( <string_literal> + system . get <identifiersep> property ( <string_literal> ) ) ; } } <string_literal> <string_literal> src / test / java / org / gradle / testing / super <identifiersep> class <identifiersep> tests . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude <ect>
test . reports . junit <identifiersep> xml . output <identifiersep> per <identifiersep> test <identifiersep> case = true <string_literal> <string_literal> src / test / java / output <identifiersep> lifecycle <identifiersep> test . java <string_literal> <string_literal> import org . junit . * ; public class output <identifiersep> lifecycle <identifiersep> test { public output <identifiersep> lifecycle <identifiersep> test ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <ect>
public class output <identifiersep> lifecycle <identifiersep> test { public output <identifiersep> lifecycle <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ before public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { <ect>
@ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before public void before <identifiersep> test ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; } @ before public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after public void after <identifiersep> test ( ) { <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ after public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class <ect>
system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after public void after <identifiersep> test ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
@ after public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { <LOG> system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> output <identifiersep> lifecycle <identifiersep> test <string_literal> <ect>
file ( 'src / main / java / org / gradle / my <identifiersep> extension . java' ) < < ''' package org . gradle ; import org . junit . jupiter . api . extension . * ; public class my <identifiersep> extension implements test <identifiersep> instance <identifiersep> post <identifiersep> processor { @ override public void post <identifiersep> process <identifiersep> test <identifiersep> instance ( object test <identifiersep> instance , extension <identifiersep> context context ) { <LOG> } } ''' file ( 'src / test / java / org / gradle / extension <identifiersep> test . java' ) < < ''' package org . gradle ; import org . junit . jupiter . api . test ; import org . junit . jupiter . api . extension . * ; @ extend <identifiersep> with ( my <identifiersep> extension . class ) <ect>
<string_literal> ) file ( \'src / test / java / some <identifiersep> test . java\' ) < < <string_literal> <string_literal> <LOG> org . junit . jupiter . api . assertions . fail ( \\ " test failure message \\ " ) ; } @ org . junit . jupiter . api . test public void $ { passing <identifiersep> test <identifiersep> case <identifiersep> name } { } } <string_literal> <string_literal> <string_literal> public class some <identifiersep> other <identifiersep> test { <ect>
public void stop <identifiersep> now ( ) { if ( processor != null ) { processor . stop <identifiersep> now ( ) ; } } private int get <identifiersep> max <identifiersep> parallel <identifiersep> forks ( jvm <identifiersep> test <identifiersep> execution <identifiersep> spec test <identifiersep> execution <identifiersep> spec ) { int max <identifiersep> parallel <identifiersep> forks = test <identifiersep> execution <identifiersep> spec . get <identifiersep> max <identifiersep> parallel <identifiersep> forks ( ) ; if ( max <identifiersep> parallel <identifiersep> forks > max <identifiersep> worker <identifiersep> count ) { <LOG> max <identifiersep> parallel <identifiersep> forks = max <identifiersep> worker <identifiersep> count ; } return max <identifiersep> parallel <identifiersep> forks ; } } <ect>
<comment> package org . gradle ; import org . testng . assert ; public class foo <identifiersep> test { @ org . testng . annotations . test public void ok ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . testng . annotations . test public void fail ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; assert . fail ( ) ; } } <ect>
import org . testng . assert ; public class foo <identifiersep> test { @ org . testng . annotations . test public void ok ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . testng . annotations . test public void fail ( ) { <LOG> system . err . println ( <string_literal> ) ; assert . fail ( ) ; } } <ect>
<comment> package org . gradle ; import org . junit . assert ; public class other <identifiersep> test { @ org . junit . test public void other <identifiersep> ok ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . test public void other <identifiersep> fail ( ) { assert . fail ( ) ; } } <ect>
<comment> package org . gradle ; import org . junit . assert ; public class test { @ org . junit . test public void ok ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . test public void fail ( ) { assert . fail ( ) ; } } <ect>
import org . junit . runner . run <identifiersep> with ; import org . junit . runners . suite ; @ run <identifiersep> with ( suite . class ) @ suite . suite <identifiersep> classes ( { test . class , other <identifiersep> test . class } ) public class test <identifiersep> suite { @ org . junit . before <identifiersep> class public static void init ( ) { <LOG> system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <ect>
1 * progress <identifiersep> logger . progress ( '1 test completed' ) when : logger . after <identifiersep> test ( test2 , result ( true ) ) logger . after <identifiersep> suite ( root <identifiersep> suite , result ( ) ) then : 1 * progress <identifiersep> logger . progress ( '2 tests completed , 1 failed' ) <LOG> 1 * progress <identifiersep> logger . completed ( ) } def ignores <identifiersep> suites <identifiersep> other <identifiersep> than <identifiersep> the <identifiersep> root <identifiersep> suite ( ) { test <identifiersep> descriptor suite = suite ( ) logger . before <identifiersep> suite ( root <identifiersep> suite ) when : logger . before <identifiersep> suite ( suite ) <ect>
} ) ; try ( print <identifiersep> writer mapping <identifiersep> file <identifiersep> writer = new print <identifiersep> writer ( new file <identifiersep> writer ( get <identifiersep> mapping <identifiersep> dest <identifiersep> file ( ) . get <identifiersep> as <identifiersep> file ( ) . get ( ) ) ) ) { for ( map . entry < string , collection < string > > entry : simple <identifiersep> names . as <identifiersep> map ( ) . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> value ( ) . size ( ) > 1 ) { system . out . println ( string . format ( <string_literal> , entry . get <identifiersep> key ( ) ) ) ; for ( string class <identifiersep> name : entry . get <identifiersep> value ( ) ) { <LOG> } } mapping <identifiersep> file <identifiersep> writer . print ( entry . get <identifiersep> key ( ) ) ; mapping <identifiersep> file <identifiersep> writer . print ( <string_literal> ) ; for ( string class <identifiersep> name : entry . get <identifiersep> value ( ) ) { mapping <identifiersep> file <identifiersep> writer . print ( class <identifiersep> name ) ; mapping <identifiersep> file <identifiersep> writer . print ( <string_literal> ) ; } mapping <identifiersep> file <identifiersep> writer . println ( ) ; <ect>
import org . slf4j . logger <identifiersep> factory ; import java . util . linked <identifiersep> list ; public class default <identifiersep> generation <identifiersep> listener implements generation <identifiersep> listener { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( default <identifiersep> generation <identifiersep> listener . class ) ; private final linked <identifiersep> list < string > context <identifiersep> stack = new linked <identifiersep> list < string > ( ) ; public void warning ( string message ) { <LOG> } public void start ( string context ) { context <identifiersep> stack . add <identifiersep> first ( context ) ; } public void finish ( ) { context <identifiersep> stack . remove <identifiersep> first ( ) ; } } <ect>
fun exec <identifiersep> async ( action : ( ) - > unit ) { val latch = count <identifiersep> down <identifiersep> latch ( 1 ) thread ( start = true ) { try { action ( ) } catch ( e : exception ) { <LOG> } finally { latch . count <identifiersep> down ( ) } } } exec <identifiersep> async { val commit <identifiersep> id = run ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) set <identifiersep> commit <identifiersep> id ( commit <identifiersep> id ) val status = run ( <string_literal> , <string_literal> , <string_literal> ) <ect>
size <identifiersep> in <identifiersep> bytes = minimum <identifiersep> size <identifiersep> kb * <number_literal> } add <identifiersep> generated <identifiersep> uncompressed <identifiersep> jar <identifiersep> entry ( out , <string_literal> , size <identifiersep> in <identifiersep> bytes ) } } finally { out . close ( ) } } } catch ( exception ex ) { ex . print <identifiersep> stack <identifiersep> trace ( ) <LOG> } } private void add <identifiersep> jar <identifiersep> entry ( jar <identifiersep> output <identifiersep> stream out , string name , string content ) { <comment> <ect>
@ task <identifiersep> action fun kill <identifiersep> leaking <identifiersep> java <identifiersep> processes ( ) = project . run { var did <identifiersep> kill = false <comment> <LOG> pkill ( pid ) did <identifiersep> kill = true } if ( did <identifiersep> kill ) { <comment> <ect>
open fun are <identifiersep> equal <identifiersep> type <identifiersep> constructors ( a : type <identifiersep> constructor , b : type <identifiersep> constructor ) : boolean { return a == b } open fun get <identifiersep> lower <identifiersep> captured <identifiersep> type <identifiersep> policy ( sub <identifiersep> type : simple <identifiersep> type , super <identifiersep> type : new <identifiersep> captured <identifiersep> type ) = lower <identifiersep> captured <identifiersep> type <identifiersep> policy . check <identifiersep> subtype <identifiersep> and <identifiersep> lower open val same <identifiersep> constructor <identifiersep> policy get ( ) = several <identifiersep> supertypes <identifiersep> with <identifiersep> same <identifiersep> constructor <identifiersep> policy . intersect <identifiersep> arguments <identifiersep> and <identifiersep> check <identifiersep> again internal inline fun < t > run <identifiersep> with <identifiersep> arguments <identifiersep> settings ( sub <identifiersep> argument : unwrapped <identifiersep> type , f : type <identifiersep> checker <identifiersep> context . ( ) - > t ) : t { if ( arguments <identifiersep> depth > <number_literal> ) { <LOG> } arguments <identifiersep> depth ++ val result = f ( ) arguments <identifiersep> depth -- return result } private fun initialize ( ) { assert ( ! supertypes <identifiersep> locked ) <ect>
<comment> package org . jetbrains . kotlin . utils enum class report <identifiersep> level ( val description : string ) { ignore ( <string_literal> ) , <LOG> strict ( <string_literal> ) , ; companion object { fun find <identifiersep> by <identifiersep> description ( description : string ? ) : report <identifiersep> level ? = values ( ) . first <identifiersep> or <identifiersep> null { it . description == description } } val is <identifiersep> warning : boolean get ( ) = this == report <identifiersep> level . warn val is <identifiersep> ignore : boolean get ( ) = this == report <identifiersep> level . ignore <ect>
java <identifiersep> token <identifiersep> type . oreq - > <string_literal> java <identifiersep> token <identifiersep> type . gtgtgteq - > <string_literal> java <identifiersep> token <identifiersep> type . plusplus - > <string_literal> java <identifiersep> token <identifiersep> type . minusminus - > <string_literal> kt <identifiersep> tokens . eqeqeq - > <string_literal> kt <identifiersep> tokens . excleqeqeq - > <string_literal> <LOG> } } companion object { val eqeq = operator ( java <identifiersep> token <identifiersep> type . eqeq ) . assign <identifiersep> no <identifiersep> prototype ( ) val eq = operator ( java <identifiersep> token <identifiersep> type . eq ) . assign <identifiersep> no <identifiersep> prototype ( ) } } class lambda <identifiersep> expression ( val parameter <identifiersep> list : parameter <identifiersep> list ? , val block : block ) : expression ( ) { init { assign <identifiersep> prototypes <identifiersep> from ( block ) <ect>
class a { private string foo ( object o , boolean b ) { if ( b ) return ( string ) o ; return <string_literal> ; } void bar ( ) { if ( foo ( null , true ) == null ) { <LOG> } } <ect>
public class a { public void a <identifiersep> void ( ) { int i = 0 ; while ( i ++ < <number_literal> ) ; <LOG> } <ect>
public c c ( ) { return new c ( ) ; } } public void a ( ) { b b = new b ( ) ; system . out . println ( b + <string_literal> ) ; string a = 1 + <string_literal> ; <LOG> } public static void main ( string [ ] args ) { string p = new test ( ) + <string_literal> ; } <ect>
import javax . swing . * ; public class a { void foo ( ) { swing <identifiersep> utilities . invoke <identifiersep> later ( new runnable ( ) { @ override public void run ( ) { <LOG> } } ) ; } } <ect>
<comment> <LOG> } <ect>
import java . util . array <identifiersep> list ; <comment> <LOG> system . out . println ( <string_literal> ) ; <comment> <ect>
system . out . println ( <string_literal> ) ; <comment> <LOG> return ; <comment> <ect>
val br = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( `in` ) ) var str <identifiersep> line : string while ( ( str <identifiersep> line = br . read <identifiersep> line ( ) ) != null ) { println ( str <identifiersep> line ) } `in` . close ( ) } catch ( e : exception ) { <LOG> } } } <ect>
boolean my <identifiersep> boolean = true ; } class one { static container my <identifiersep> container = new container ( ) ; } class test { void test ( ) { if ( one . my <identifiersep> container . my <identifiersep> boolean ) <LOG> string s = one . my <identifiersep> container . my <identifiersep> boolean ? <string_literal> : <string_literal> ; while ( one . my <identifiersep> container . my <identifiersep> boolean ) system . out . println ( <string_literal> ) ; do { system . out . println ( <string_literal> ) ; } while ( one . my <identifiersep> container . my <identifiersep> boolean ) <ect>
if ( one . my <identifiersep> container . my <identifiersep> boolean ) system . out . println ( <string_literal> ) ; string s = one . my <identifiersep> container . my <identifiersep> boolean ? <string_literal> : <string_literal> ; while ( one . my <identifiersep> container . my <identifiersep> boolean ) system . out . println ( <string_literal> ) ; do { <LOG> } while ( one . my <identifiersep> container . my <identifiersep> boolean ) } <ect>
<comment> <LOG> else if ( b ) system . out . println ( <string_literal> ) else system . out . println ( <string_literal> ) if ( c ) { system . out . println ( <string_literal> ) <ect>
void foo ( ) { if ( a ) system . out . println ( <string_literal> ) else if ( b ) system . out . println ( <string_literal> ) else <LOG> if ( c ) { system . out . println ( <string_literal> ) } else if ( d ) { system . out . println ( <string_literal> ) } <ect>
system . out . println ( <string_literal> ) else system . out . println ( <string_literal> ) if ( c ) { system . out . println ( <string_literal> ) } else if ( d ) { <LOG> } <ect>
<comment> <LOG> if ( b ) return s . length ( ) ; return <number_literal> ; <ect>
<comment> <LOG> <ect>
<comment> <LOG> <ect>
public class a { public void a <identifiersep> void ( ) { int [ ] array = new int [ <number_literal> ] ; for ( int i : array ) ; <LOG> } <ect>
public class c { private string x = <string_literal> ; public string get <identifiersep> x ( ) { <LOG> return x ; } public void set <identifiersep> x ( string x ) { this . x = x ; } void foo ( ) { system . out . println ( <string_literal> + x ) ; } <ect>
public class c { private string my <identifiersep> x = <string_literal> ; public string get <identifiersep> x ( ) { return my <identifiersep> x ; } public void set <identifiersep> x ( string x ) { <LOG> this . my <identifiersep> x = x ; } void foo ( ) { my <identifiersep> x = <string_literal> ; } <ect>
public class c { private string x = <string_literal> ; public string get <identifiersep> x ( ) { <LOG> return this . x ; } public void set <identifiersep> x ( string x ) { this . x = x ; } <ect>
public class c { private string x = <string_literal> ; public string get <identifiersep> x ( ) { return x ; } public void set <identifiersep> x ( string x ) { <LOG> this . x = x ; } <ect>
public class c { private string x = <string_literal> ; public string get <identifiersep> x ( ) { return x ; } public void set <identifiersep> x ( string x ) { <LOG> this . x = x ; } void foo ( ) { x = <string_literal> ; } <ect>
public class c { private string x = <string_literal> ; public string get <identifiersep> x ( ) { return x ; } public void set <identifiersep> x ( string value ) { <LOG> x = value ; } <ect>
<comment> <LOG> } <ect>
' \\ \\ ' . to <identifiersep> int ( ) - > sb . append ( parse <identifiersep> escape <identifiersep> sequence ( ) ) else - > { if ( char <identifiersep> code >= ' ' . to <identifiersep> int ( ) ) { sb . append ( char <identifiersep> code . to <identifiersep> char ( ) ) advance ( ) } else { <LOG> } } } } } private fun parse <identifiersep> escape <identifiersep> sequence ( ) : char { advance ( ) return when ( char <identifiersep> code ) { ' <string_literal> ' } ' \\ \\ ' . to <identifiersep> int ( ) - > advance <identifiersep> and <identifiersep> then { ' \\ \\ ' } ' / ' . to <identifiersep> int ( ) - > advance <identifiersep> and <identifiersep> then { ' / ' } <ect>
configuration . put ( js <identifiersep> configuration <identifiersep> keys . libraries , js <identifiersep> config . js <identifiersep> stdlib ) configuration . put ( common <identifiersep> configuration <identifiersep> keys . module <identifiersep> name , <string_literal> ) val analysis <identifiersep> result = top <identifiersep> down <identifiersep> analyzer <identifiersep> facade <identifiersep> for <identifiersep> js . analyze <identifiersep> files ( list <identifiersep> of ( psi <identifiersep> file ) , js <identifiersep> config ( project , configuration ) ) val module = analysis <identifiersep> result . module <identifiersep> descriptor val root <identifiersep> package = module . get <identifiersep> package ( fq <identifiersep> name . root ) val test <identifiersep> descriptor = find <identifiersep> test <identifiersep> callable ( root <identifiersep> package , name ) ? : <LOG> val actual <identifiersep> encoding = encode <identifiersep> signature ( test <identifiersep> descriptor ) assert . assert <identifiersep> equals ( expected <identifiersep> encoding , actual <identifiersep> encoding ) } finally { disposer . dispose ( disposable ) kt <identifiersep> useful <identifiersep> test <identifiersep> case . reset <identifiersep> application <identifiersep> to <identifiersep> null ( ) } } private fun find <identifiersep> test <identifiersep> callable ( scope : member <identifiersep> scope , name : string ) : callable <identifiersep> member <identifiersep> descriptor ? { <ect>
if ( ! test <identifiersep> data <identifiersep> dir . exists ( ) && ! test <identifiersep> data <identifiersep> dir . mkdirs ( ) ) { error ( <string_literal> ) } else if ( is <identifiersep> creating <identifiersep> from <identifiersep> scratch ) { if ( test <identifiersep> data <identifiersep> dir . list <identifiersep> files ( ) ? . all { it . delete ( ) } != false ) { println ( <string_literal> ) } else { <LOG> } } for ( suite in suites ) { for ( case in suite . cases ) { <comment> <ect>
package foo fun test ( ) { throw throw exception ( <string_literal> ) } fun box ( ) : string { try { test ( ) <LOG> } catch ( e : exception ) { assert <identifiersep> equals ( <string_literal> , e . message ) } return <string_literal> <ect>
package foo var g : any ? get ( ) { log ( <string_literal> ) return null } set ( v ) { <LOG> } public inline fun array < string > . boo ( ) { var a = g for ( element in this ) ; } public inline fun iterable < string > . boo ( i : any ? ) { var a = i for ( element in this ) ; <ect>
<comment> <LOG> if ( a > b ) return a return b } fun box ( ) : string { val test = max ( fizz ( 1 ) , max ( fizz ( <number_literal> ) , buzz ( <number_literal> ) ) ) assert <identifiersep> equals ( <number_literal> , test ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) <ect>
<comment> <LOG> return { x , y - > x * y } } fun box ( ) : string { assert <identifiersep> equals ( <number_literal> , array <identifiersep> of ( multiply <identifiersep> fun ( ) , multiply <identifiersep> fun <identifiersep> inline ( ) ) [ 0 ] ( fizz ( <number_literal> ) , fizz ( <number_literal> ) ) ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
<comment> <LOG> return { x , y - > x * y } } fun box ( ) : string { assert <identifiersep> equals ( <number_literal> , multiply <identifiersep> fun ( ) ( fizz ( <number_literal> ) , buzz ( <number_literal> ) ) ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
val a : array < string > get ( ) { log ( <string_literal> ) return array <identifiersep> of ( <string_literal> ) } val aa : array < string > get ( ) { <LOG> return array <identifiersep> of ( <string_literal> ) } fun box ( ) : string { foo ( a [ 0 ] ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
return string } fun < t > fizz ( x : t ) : t { log ( <string_literal> ) return x } inline fun < t > buzz ( x : t ) : t { <LOG> return x <ect>
package foo object a { init { log ( <string_literal> ) } val x = <number_literal> } inline fun bar ( value : int ) { <LOG> log ( <string_literal> ) log ( <string_literal> ) } fun box ( ) : string { bar ( a . x ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
init { log ( <string_literal> ) } val x = <number_literal> } inline fun bar ( value : int ) { log ( <string_literal> ) log ( <string_literal> ) <LOG> } fun box ( ) : string { bar ( a . x ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
val a : a get ( ) { log ( <string_literal> ) return object : a { override val b : b get ( ) { <LOG> return object : b { override fun c ( a : any ? ) { log ( <string_literal> ) } } } } } val g : any ? get ( ) { log ( <string_literal> ) <ect>
log ( <string_literal> ) return object : b { override fun c ( a : any ? ) { log ( <string_literal> ) } } } } } val g : any ? get ( ) { <LOG> return <string_literal> } inline fun foo ( ) : any ? { log ( <string_literal> ) return g ; } inline fun bar ( ) : any ? { return g ; <ect>
return g ; } inline fun baz ( ) : any ? { return log ( <string_literal> ) ; } inline fun boo ( a : any ? ) : any ? { return log ( <string_literal> ) ; } fun box ( ) : string { <LOG> a . b . c ( g ) log ( <string_literal> ) a . b . c ( foo ( ) ) log ( <string_literal> ) a . b . c ( bar ( ) ) log ( <string_literal> ) <ect>
log ( <string_literal> ) } while ( j < <number_literal> ) log ( <string_literal> ) } while ( predicate ( i ) ) } fun box ( ) : string { bar { <LOG> it < <number_literal> } assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
<comment> <LOG> return { log ( <string_literal> ) a + it } } } inline fun < t : any > id ( x : t ) : t { log ( x . to <identifiersep> string ( ) ) return x <ect>
<comment> <LOG> } } , c ; init { log ( <string_literal> ) } } var l = <string_literal> fun log ( s : string ) { <ect>
init { log ( <string_literal> ) } } var l = <string_literal> fun log ( s : string ) { l += s + <string_literal> } fun box ( ) : string { <LOG> e . a . to <identifiersep> string ( ) log ( <string_literal> ) e . b . to <identifiersep> string ( ) log ( <string_literal> ) e . c . to <identifiersep> string ( ) if ( l != <string_literal> ) return <string_literal> <ect>
l += s + <string_literal> } fun box ( ) : string { log ( <string_literal> ) e . a . to <identifiersep> string ( ) log ( <string_literal> ) e . b . to <identifiersep> string ( ) <LOG> e . c . to <identifiersep> string ( ) if ( l != <string_literal> ) return <string_literal> return <string_literal> <ect>
private inline fun foo ( ) : string { return baz ( bar { <string_literal> } ) } private inline fun bar ( noinline x : ( ) - > string ) : string { return <string_literal> + baz ( boo { should <identifiersep> be <identifiersep> inlined ( ) ; x ( ) } ) + <string_literal> } fun boo ( x : ( ) - > string ) = x ( ) private inline fun should <identifiersep> be <identifiersep> inlined ( ) { <LOG> } fun box ( ) : string { val result = foo ( ) if ( result != <string_literal> ) return <string_literal> return <string_literal> <ect>
var l = <string_literal> fun log ( message : string ) { l += message + <string_literal> } fun baz ( x : string ) { log ( <string_literal> ) } fun baz ( x : string , i : int ) { <LOG> } inline fun bar ( ) { boo { baz ( <string_literal> ) foo ( ) } } fun boo ( x : ( ) - > unit ) = x ( ) inline fun foo ( ) { <ect>
val annotation <identifiersep> data <identifiersep> encoded = class <identifiersep> header ? . data if ( annotation <identifiersep> data <identifiersep> encoded != null ) { byte <identifiersep> array <identifiersep> input <identifiersep> stream ( bit <identifiersep> encoding . decode <identifiersep> bytes ( annotation <identifiersep> data <identifiersep> encoded ) ) . use { input - > out . write ( <string_literal> ) if ( ! class <identifiersep> header . metadata <identifiersep> version . is <identifiersep> compatible ( ) ) { <LOG> } when ( class <identifiersep> header . kind ) { kotlin <identifiersep> class <identifiersep> header . kind . file <identifiersep> facade - > out . write ( <string_literal> ) kotlin <identifiersep> class <identifiersep> header . kind . class - > out . write ( <string_literal> ) kotlin <identifiersep> class <identifiersep> header . kind . multifile <identifiersep> class <identifiersep> part - > <ect>
val script <identifiersep> def = script <identifiersep> definition <identifiersep> provider . find <identifiersep> script <identifiersep> definition ( file ) if ( script <identifiersep> def != null ) { val deps = script <identifiersep> content <identifiersep> loader . load <identifiersep> contents <identifiersep> and <identifiersep> resolve <identifiersep> dependencies ( script <identifiersep> def , file ) . dependencies ? . adjust <identifiersep> by <identifiersep> definition ( script <identifiersep> def ) if ( deps != null ) { <LOG> } cache <identifiersep> lock . write { cache . put ( path , deps ) } deps } else null } } } <ect>
add ( file ( path ) . absolute <identifiersep> file . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ) } @ jvm <identifiersep> static fun main ( args : array < string > ) { try { run ( args ) } catch ( e : runner <identifiersep> exception ) { <LOG> system . exit ( 1 ) } } private fun print <identifiersep> usage <identifiersep> and <identifiersep> exit ( ) { println ( <string_literal> <string_literal> <ect>
override fun as <identifiersep> text ( builder : class <identifiersep> builder ) = throw unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> ) override fun as <identifiersep> bytes ( builder : class <identifiersep> builder ) = throw unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> ) override fun close ( ) { } fun result ( ) : psi <identifiersep> java <identifiersep> file <identifiersep> stub { val pop = stub <identifiersep> stack . pop ( ) if ( pop != = java <identifiersep> file <identifiersep> stub ) { <LOG> } return java <identifiersep> file <identifiersep> stub } } <ect>
private fun get <identifiersep> java <identifiersep> file <identifiersep> stub ( ) : psi <identifiersep> java <identifiersep> file <identifiersep> stub = get <identifiersep> light <identifiersep> class <identifiersep> data <identifiersep> holder ( ) . java <identifiersep> file <identifiersep> stub fun get <identifiersep> descriptor ( ) : class <identifiersep> descriptor ? { return light <identifiersep> class <identifiersep> generation <identifiersep> support . get <identifiersep> instance ( project ) . resolve <identifiersep> to <identifiersep> descriptor ( class <identifiersep> or <identifiersep> object ) as ? class <identifiersep> descriptor } protected fun get <identifiersep> light <identifiersep> class <identifiersep> data <identifiersep> holder ( ) : light <identifiersep> class <identifiersep> data <identifiersep> holder . for <identifiersep> class { val light <identifiersep> class <identifiersep> data = get <identifiersep> light <identifiersep> class <identifiersep> data <identifiersep> holder ( class <identifiersep> or <identifiersep> object ) if ( light <identifiersep> class <identifiersep> data is invalid <identifiersep> light <identifiersep> class <identifiersep> data <identifiersep> holder ) { <LOG> } return light <identifiersep> class <identifiersep> data } private val  <identifiersep> containing <identifiersep> file : psi <identifiersep> file by lazy <identifiersep> pub { object : fake <identifiersep> file <identifiersep> for <identifiersep> light <identifiersep> class ( class <identifiersep> or <identifiersep> object . containing <identifiersep> kt <identifiersep> file , { if ( class <identifiersep> or <identifiersep> object . is <identifiersep> top <identifiersep> level ( ) ) this else create ( get <identifiersep> outermost <identifiersep> class <identifiersep> or <identifiersep> object ( class <identifiersep> or <identifiersep> object ) ) ! ! } , { get <identifiersep> java <identifiersep> file <identifiersep> stub ( ) } <ect>
declaration <identifiersep> origin <identifiersep> field <identifiersep> for <identifiersep> captured <identifiersep> value , field <identifiersep> descriptor ) } } private fun < k , v > mutable <identifiersep> map < k , v > . put <identifiersep> absent <identifiersep> or <identifiersep> same ( key : k , value : v ) { val current = this . get <identifiersep> or <identifiersep> put ( key , { value } ) if ( current != value ) { <LOG> } } private fun suggest <identifiersep> name <identifiersep> for <identifiersep> captured <identifiersep> value ( value <identifiersep> descriptor : value <identifiersep> descriptor ) : name = if ( value <identifiersep> descriptor . name . is <identifiersep> special ) { val old <identifiersep> name <identifiersep> str = value <identifiersep> descriptor . name . as <identifiersep> string ( ) old <identifiersep> name <identifiersep> str . substring ( 1 , old <identifiersep> name <identifiersep> str . length - 1 ) . synthesized <identifiersep> name } else value <identifiersep> descriptor . name <ect>
for ( bridge in specials ) { ir <identifiersep> class . declarations . add ( create <identifiersep> bridge ( origin , descriptor , bridge . from , bridge . to , bridge . is <identifiersep> special , bridge . is <identifiersep> delegate <identifiersep> to <identifiersep> super ) ) } } if ( ! descriptor . kind . is <identifiersep> real && is <identifiersep> abstract <identifiersep> method ( descriptor , owner <identifiersep> kind . implementation , state ) ) { descriptor . get <identifiersep> overridden <identifiersep> builtin <identifiersep> reflecting <identifiersep> jvm <identifiersep> descriptor < callable <identifiersep> member <identifiersep> descriptor > ( ) ? : <LOG> if ( ! is <identifiersep> there <identifiersep> overridden <identifiersep> in <identifiersep> kotlin <identifiersep> class ( descriptor ) ) { val flags = opcodes . acc <identifiersep> abstract or get <identifiersep> visibility <identifiersep> access <identifiersep> flag ( descriptor ) val bridge <identifiersep> descriptor = jvm <identifiersep> function <identifiersep> descriptor <identifiersep> impl ( descriptor . containing <identifiersep> declaration as class <identifiersep> descriptor , null , annotations . empty , descriptor . name , callable <identifiersep> member <identifiersep> descriptor . kind . synthesized , descriptor . source , flags ) <ect>
val extension <identifiersep> receiver = reference <identifiersep> target . extension <identifiersep> receiver <identifiersep> parameter ? : todo ( <string_literal> ) ir <identifiersep> get <identifiersep> value <identifiersep> impl ( expression . start <identifiersep> offset , expression . end <identifiersep> offset , context . symbol <identifiersep> table . reference <identifiersep> value <identifiersep> parameter ( extension <identifiersep> receiver ) ) } else - > <LOG> } } override fun visit <identifiersep> binary <identifiersep> expression ( expression : kt <identifiersep> binary <identifiersep> expression , data : nothing ? ) : ir <identifiersep> statement = operator <identifiersep> expression <identifiersep> generator ( this ) . generate <identifiersep> binary <identifiersep> expression ( expression ) override fun visit <identifiersep> prefix <identifiersep> expression ( expression : kt <identifiersep> prefix <identifiersep> expression , data : nothing ? ) : ir <identifiersep> statement = operator <identifiersep> expression <identifiersep> generator ( this ) . generate <identifiersep> prefix <identifiersep> expression ( expression ) override fun visit <identifiersep> postfix <identifiersep> expression ( expression : kt <identifiersep> postfix <identifiersep> expression , data : nothing ? ) : ir <identifiersep> statement = operator <identifiersep> expression <identifiersep> generator ( this ) . generate <identifiersep> postfix <identifiersep> expression ( expression ) <ect>
internal object check <identifiersep> receivers : resolution <identifiersep> part ( ) { private fun kotlin <identifiersep> resolution <identifiersep> candidate . check <identifiersep> receiver ( receiver <identifiersep> argument : simple <identifiersep> kotlin <identifiersep> call <identifiersep> argument ? , receiver <identifiersep> parameter : receiver <identifiersep> parameter <identifiersep> descriptor ? ) { if ( ( receiver <identifiersep> argument == null ) != ( receiver <identifiersep> parameter == null ) ) { <LOG> } if ( receiver <identifiersep> argument == null || receiver <identifiersep> parameter == null ) return resolve <identifiersep> kotlin <identifiersep> argument ( receiver <identifiersep> argument , receiver <identifiersep> parameter , is <identifiersep> receiver = true ) } override fun kotlin <identifiersep> resolution <identifiersep> candidate . process ( work <identifiersep> index : int ) { if ( work <identifiersep> index == 0 ) { check <identifiersep> receiver ( resolved <identifiersep> call . dispatch <identifiersep> receiver <identifiersep> argument , candidate <identifiersep> descriptor . dispatch <identifiersep> receiver <identifiersep> parameter ) } else { <ect>
while ( at ( comma ) ) error <identifiersep> and <identifiersep> advance ( <string_literal> ) ; parse <identifiersep> when <identifiersep> condition ( ) ; if ( ! at ( comma ) ) break ; advance ( ) ; <comment> <LOG> } else { parse <identifiersep> control <identifiersep> structure <identifiersep> body ( ) ; } <comment> <ect>
else { parse <identifiersep> expression ( ) ; } condition . done ( when <identifiersep> condition <identifiersep> in <identifiersep> range ) ; } else if ( at ( is <identifiersep> keyword ) || at ( not <identifiersep> is ) ) { advance ( ) ; <comment> <LOG> } else { my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> type <identifiersep> ref ( ) ; } condition . done ( when <identifiersep> condition <identifiersep> is <identifiersep> pattern ) ; } else { if ( at <identifiersep> set ( when <identifiersep> condition <identifiersep> recovery <identifiersep> set <identifiersep> with <identifiersep> arrow ) ) { error ( <string_literal> ) ; <ect>
<comment> private void parse <identifiersep> function <identifiersep> literal <identifiersep> parameter <identifiersep> list ( ) { psi <identifiersep> builder . marker parameter <identifiersep> list = mark ( ) ; while ( ! eof ( ) ) { psi <identifiersep> builder . marker parameter = mark ( ) ; if ( at ( colon ) ) { <LOG> } else if ( at ( lpar ) ) { psi <identifiersep> builder . marker destructuring <identifiersep> declaration = mark ( ) ; my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> multi <identifiersep> declaration <identifiersep> name ( token <identifiersep> set <identifiersep> to <identifiersep> follow <identifiersep> after <identifiersep> destructuring <identifiersep> declaration <identifiersep> in <identifiersep> lambda ) ; destructuring <identifiersep> declaration . done ( destructuring <identifiersep> declaration ) ; } else { expect ( identifier , <string_literal> , token <identifiersep> set . create ( arrow ) ) ; <ect>
parameter . done ( value <identifiersep> parameter ) ; if ( expect ( in <identifiersep> keyword , <string_literal> , token <identifiersep> set . create ( lpar , lbrace , rpar ) ) ) { psi <identifiersep> builder . marker range = mark ( ) ; parse <identifiersep> expression ( ) ; range . done ( loop <identifiersep> range ) ; } } else { <LOG> } expect <identifiersep> no <identifiersep> advance ( rpar , <string_literal> ) ; my <identifiersep> builder . restore <identifiersep> newlines <identifiersep> state ( ) ; } parse <identifiersep> loop <identifiersep> body ( ) ; loop . done ( for ) ; } private void parse <identifiersep> control <identifiersep> structure <identifiersep> body ( ) { if ( ! parse <identifiersep> annotated <identifiersep> lambda ( <comment> true ) ) { <ect>
psi <identifiersep> builder . marker parameters = mark ( ) ; expect ( lpar , <string_literal> , recovery <identifiersep> set ) ; if ( ! at <identifiersep> set ( recovery <identifiersep> set ) ) { my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> value <identifiersep> parameter ( <comment> true ) ; expect ( rpar , <string_literal> , recovery <identifiersep> set ) ; } else { <LOG> } parameters . done ( value <identifiersep> parameter <identifiersep> list ) ; } if ( at ( lbrace ) ) { my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> block ( ) ; } else { error ( <string_literal> ) ; } catch <identifiersep> block . done ( catch ) ; <ect>
catch <identifiersep> or <identifiersep> finally = true ; psi <identifiersep> builder . marker finally <identifiersep> block = mark ( ) ; advance ( ) ; <comment> <LOG> } try <identifiersep> expression . done ( try ) ; } <comment> <ect>
private void parse <identifiersep> parenthesized <identifiersep> expression ( ) { assert  <identifiersep> at ( lpar ) ; psi <identifiersep> builder . marker mark = mark ( ) ; my <identifiersep> builder . disable <identifiersep> newlines ( ) ; advance ( ) ; <comment> <LOG> } else { parse <identifiersep> expression ( ) ; } expect ( rpar , <string_literal> ) ; my <identifiersep> builder . restore <identifiersep> newlines <identifiersep> state ( ) ; mark . done ( parenthesized ) ; } <comment> <ect>
else if ( keyword <identifiersep> token == type <identifiersep> alias <identifiersep> keyword ) { decl <identifiersep> type = parse <identifiersep> type <identifiersep> alias ( ) ; } else if ( keyword <identifiersep> token == object <identifiersep> keyword ) { parse <identifiersep> object ( name <identifiersep> parsing <identifiersep> mode . required , true ) ; decl <identifiersep> type = object <identifiersep> declaration ; } else if ( at ( lbrace ) ) { <LOG> parse <identifiersep> block ( ) ; decl <identifiersep> type = fun ; } if ( decl <identifiersep> type == null ) { error <identifiersep> and <identifiersep> advance ( <string_literal> ) ; decl . drop ( ) ; } else { <ect>
annotation . rollback <identifiersep> to ( ) ; my <identifiersep> builder . restore <identifiersep> newlines <identifiersep> state ( ) ; return false ; } assert  <identifiersep> at ( lbracket ) ; advance ( ) ; <comment> <LOG> } else { while ( at ( identifier ) || at ( at ) ) { if ( at ( at ) ) { error <identifiersep> and <identifiersep> advance ( <string_literal> ) ; <comment> <ect>
<comment> <LOG> } } else { primary <identifiersep> constructor <identifiersep> marker . drop ( ) ; } if ( at ( colon ) ) { advance ( ) ; <comment> <ect>
private void parse <identifiersep> enum <identifiersep> class <identifiersep> body ( ) { if ( ! at ( lbrace ) ) return ; psi <identifiersep> builder . marker body = mark ( ) ; my <identifiersep> builder . enable <identifiersep> newlines ( ) ; advance ( ) ; <comment> <LOG> } parse <identifiersep> members ( ) ; expect ( rbrace , <string_literal> ) ; my <identifiersep> builder . restore <identifiersep> newlines <identifiersep> state ( ) ; body . done ( class <identifiersep> body ) ; } <comment> <ect>
advance ( ) ; <comment> <LOG> psi <identifiersep> builder . marker before <identifiersep> wrong <identifiersep> delegation <identifiersep> callee = null ; if ( ! at ( lpar ) ) { before <identifiersep> wrong <identifiersep> delegation <identifiersep> callee = mark ( ) ; advance ( ) ; <comment> <ect>
token <identifiersep> set recovery <identifiersep> set = token <identifiersep> set . or <identifiersep> set ( parameter <identifiersep> name <identifiersep> recovery <identifiersep> set , follow ) ; if ( ! at <identifiersep> set ( follow ) ) { while ( true ) { if ( at ( comma ) ) { error <identifiersep> and <identifiersep> advance ( <string_literal> ) ; } else if ( at ( rpar ) ) { <LOG> break ; } psi <identifiersep> builder . marker property = mark ( ) ; parse <identifiersep> modifier <identifiersep> list ( default , token <identifiersep> set . create ( comma , rpar , colon , eq ) ) ; expect ( identifier , <string_literal> , recovery <identifiersep> set ) ; if ( at ( colon ) ) { advance ( ) ; <comment> <ect>
else { error . drop ( ) ; } type <identifiersep> parameter <identifiersep> list <identifiersep> occurred = true ; } if ( at ( lpar ) ) { parse <identifiersep> value <identifiersep> parameter <identifiersep> list ( false , <comment> false , value <identifiersep> parameters <identifiersep> follow ) ; } else { <LOG> } if ( at ( colon ) ) { advance ( ) ; <comment> <ect>
<comment> private void parse <identifiersep> type <identifiersep> parameter ( ) { if ( at <identifiersep> set ( type <identifiersep> parameter <identifiersep> gt <identifiersep> recovery <identifiersep> set ) ) { <LOG> return ; } psi <identifiersep> builder . marker mark = mark ( ) ; parse <identifiersep> modifier <identifiersep> list ( default , token <identifiersep> set . create ( gt , comma , colon ) ) ; expect ( identifier , <string_literal> , token <identifiersep> set . empty ) ; if ( at ( colon ) ) { advance ( ) ; <comment> <ect>
parse <identifiersep> type <identifiersep> ref ( extra <identifiersep> recovery <identifiersep> set ) ; } projection . done ( type <identifiersep> projection ) ; if ( ! at ( comma ) ) break ; advance ( ) ; <comment> <LOG> } else { advance ( ) ; <comment> <ect>
return value != null && value == expected } private fun properties . get <identifiersep> property <identifiersep> or <identifiersep> fail ( prop <identifiersep> name : string ) : string { val value = get <identifiersep> property ( prop <identifiersep> name ) if ( value == null ) { val bytes = byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) list ( print <identifiersep> stream ( bytes ) ) <LOG> } return value } } <ect>
return path <identifiersep> manager ; } public static test <identifiersep> suite suite ( ) throws throwable { path <identifiersep> manager path <identifiersep> manager = get <identifiersep> path <identifiersep> manager ( ) ; file <identifiersep> util . copy <identifiersep> dir ( new file ( path <identifiersep> manager . get <identifiersep> android <identifiersep> module <identifiersep> root ( ) ) , new file ( path <identifiersep> manager . get <identifiersep> tmp <identifiersep> folder ( ) ) ) ; write <identifiersep> android <identifiersep> skd <identifiersep> to <identifiersep> local <identifiersep> properties ( ) ; codegen <identifiersep> tests <identifiersep> on <identifiersep> android <identifiersep> generator . generate ( path <identifiersep> manager ) ; <LOG> test <identifiersep> suite suite = codegen <identifiersep> tests <identifiersep> on <identifiersep> android <identifiersep> runner . run <identifiersep> tests <identifiersep> in <identifiersep> emulator ( path <identifiersep> manager ) ; <comment> <ect>
delete ( skd <identifiersep> tools <identifiersep> zip <identifiersep> path ) ; delete ( build <identifiersep> tools <identifiersep> zip <identifiersep> path ) ; delete ( arm <identifiersep> image ) ; delete ( x86image ) ; delete ( gradle <identifiersep> zip <identifiersep> path ) ; } private static void download ( string url <identifiersep> string , string output ) { <LOG> output <identifiersep> stream out <identifiersep> stream = null ; url <identifiersep> connection url <identifiersep> connection ; input <identifiersep> stream is ; try { url url ; byte [ ] buf ; <ect>
out <identifiersep> stream . write ( buf , 0 , read ) ; <comment> <LOG> } protected void unzip ( string path <identifiersep> to <identifiersep> file , string output <identifiersep> folder ) { system . out . println ( <string_literal> + path <identifiersep> to <identifiersep> file + <string_literal> + output <identifiersep> folder ) ; string path <identifiersep> to <identifiersep> unzip ; if ( output <identifiersep> folder . equals ( path <identifiersep> manager . get <identifiersep> platform <identifiersep> folder <identifiersep> in <identifiersep> android <identifiersep> sdk ( ) ) ) { path <identifiersep> to <identifiersep> unzip = output <identifiersep> folder ; } else { <ect>
string path <identifiersep> to <identifiersep> unzip ; if ( output <identifiersep> folder . equals ( path <identifiersep> manager . get <identifiersep> platform <identifiersep> folder <identifiersep> in <identifiersep> android <identifiersep> sdk ( ) ) ) { path <identifiersep> to <identifiersep> unzip = output <identifiersep> folder ; } else { path <identifiersep> to <identifiersep> unzip = output <identifiersep> folder + <string_literal> + file <identifiersep> util . get <identifiersep> name <identifiersep> without <identifiersep> extension ( new file ( path <identifiersep> to <identifiersep> file ) ) ; } if ( new file ( path <identifiersep> to <identifiersep> unzip ) . list <identifiersep> files ( ) != null ) { <LOG> return ; } try { byte [ ] buf = new byte [ <number_literal> ] ; zip <identifiersep> entry zip <identifiersep> entry = null ; try ( zip <identifiersep> input <identifiersep> stream zip <identifiersep> input <identifiersep> stream = new zip <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( path <identifiersep> to <identifiersep> file ) ) ) { zip <identifiersep> entry = zip <identifiersep> input <identifiersep> stream . get <identifiersep> next <identifiersep> entry ( ) ; <ect>
catch ( io <identifiersep> exception e ) { if ( zip <identifiersep> entry != null ) { system . err . println ( <string_literal> + zip <identifiersep> entry . get <identifiersep> name ( ) ) ; } e . print <identifiersep> stack <identifiersep> trace ( ) ; } } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } <LOG> } private static void delete ( string file <identifiersep> path ) { new file ( file <identifiersep> path ) . delete ( ) ; } } <ect>
close ( handler . get <identifiersep> process <identifiersep> input ( ) ) ; } catch ( execution <identifiersep> exception | io <identifiersep> exception e ) { return new run <identifiersep> result ( false , get <identifiersep> stack <identifiersep> trace ( e ) ) ; } handler . add <identifiersep> process <identifiersep> listener ( new process <identifiersep> adapter ( ) { @ override public void process <identifiersep> terminated ( process <identifiersep> event event ) { <LOG> super . process <identifiersep> terminated ( event ) ; } @ override public void on <identifiersep> text <identifiersep> available ( process <identifiersep> event event , key output <identifiersep> type ) { string str = event . get <identifiersep> text ( ) ; if ( output <identifiersep> type == process <identifiersep> output <identifiersep> types . stdout || output <identifiersep> type == process <identifiersep> output <identifiersep> types . system ) { append <identifiersep> to <identifiersep> content ( std <identifiersep> out , str ) ; <ect>
system . err . println ( <string_literal> ) ; } int timeout ; try { timeout = integer . parse <identifiersep> int ( timeout <identifiersep> as <identifiersep> string ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { timeout = <number_literal> ; <LOG> } handler . wait <identifiersep> for ( timeout * <number_literal> * <number_literal> ) ; if ( ! handler . is <identifiersep> process <identifiersep> terminated ( ) ) { system . out . println ( <string_literal> + settings . command <identifiersep> line ) ; system . out . println ( std <identifiersep> out ) ; system . err . println ( std <identifiersep> err ) ; return new run <identifiersep> result ( false , <string_literal> ) ; <ect>
string cmd <identifiersep> name = system <identifiersep> info . is <identifiersep> windows ? <string_literal> : <string_literal> ; list <identifiersep> of <identifiersep> commands . add ( path <identifiersep> manager . get <identifiersep> gradle <identifiersep> bin <identifiersep> folder ( ) + <string_literal> + cmd <identifiersep> name ) ; list <identifiersep> of <identifiersep> commands . add ( <string_literal> ) ; list <identifiersep> of <identifiersep> commands . add ( <string_literal> ) ; list <identifiersep> of <identifiersep> commands . add ( path <identifiersep> manager . get <identifiersep> tmp <identifiersep> folder ( ) + <string_literal> ) ; } public void clean ( ) { <LOG> run <identifiersep> result result = run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; output <identifiersep> utils . check <identifiersep> result ( result ) ; } public void build ( ) { system . out . println ( <string_literal> ) ; general <identifiersep> command <identifiersep> line build = generate <identifiersep> command <identifiersep> line ( <string_literal> ) ; build . add <identifiersep> parameter ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; general <identifiersep> command <identifiersep> line build = generate <identifiersep> command <identifiersep> line ( <string_literal> ) ; build . add <identifiersep> parameter ( <string_literal> ) ; run <identifiersep> result result = run <identifiersep> utils . execute ( build ) ; output <identifiersep> utils . check <identifiersep> result ( result ) ; } public void install <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { <LOG> output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ) ; output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ) ; } public void uninstall <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; <ect>
output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ) ; } public void uninstall <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; } public string connected <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { <LOG> run <identifiersep> result result = run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; return result . get <identifiersep> output ( ) ; } private general <identifiersep> command <identifiersep> line generate <identifiersep> command <identifiersep> line ( string task <identifiersep> name ) { general <identifiersep> command <identifiersep> line command <identifiersep> line = new general <identifiersep> command <identifiersep> line ( list <identifiersep> of <identifiersep> commands ) ; command <identifiersep> line . add <identifiersep> parameter ( task <identifiersep> name ) ; return command <identifiersep> line ; <ect>
string adb <identifiersep> cmd <identifiersep> name = system <identifiersep> info . is <identifiersep> windows ? <string_literal> : <string_literal> ; command <identifiersep> line . set <identifiersep> exe <identifiersep> path ( path <identifiersep> manager . get <identifiersep> platform <identifiersep> tools <identifiersep> folder <identifiersep> in <identifiersep> android <identifiersep> sdk ( ) + <string_literal> + adb <identifiersep> cmd <identifiersep> name ) ; return command <identifiersep> line ; } public void start <identifiersep> server ( ) { general <identifiersep> command <identifiersep> line command <identifiersep> line = create <identifiersep> adb <identifiersep> command ( ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; <LOG> output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( new run <identifiersep> utils . run <identifiersep> settings ( command <identifiersep> line , null , true , <string_literal> , true ) ) ) ; } public void start <identifiersep> emulator ( ) { start <identifiersep> server ( ) ; system . out . println ( <string_literal> ) ; run <identifiersep> utils . execute <identifiersep> on <identifiersep> separate <identifiersep> thread ( new run <identifiersep> utils . run <identifiersep> settings ( get <identifiersep> start <identifiersep> command ( ) , null , false , <string_literal> , true ) ) ; print <identifiersep> log ( ) ; <ect>
command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; run <identifiersep> utils . execute <identifiersep> on <identifiersep> separate <identifiersep> thread ( new run <identifiersep> utils . run <identifiersep> settings ( command <identifiersep> line , null , false , <string_literal> , true ) ) ; } public void wait <identifiersep> emulator <identifiersep> start ( ) { <LOG> output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( get <identifiersep> wait <identifiersep> command ( ) ) ) ; general <identifiersep> command <identifiersep> line boot <identifiersep> check <identifiersep> command = create <identifiersep> adb <identifiersep> command ( ) ; boot <identifiersep> check <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; boot <identifiersep> check <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; boot <identifiersep> check <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; int counter = 0 ; <ect>
run <identifiersep> result execute = run <identifiersep> utils . execute ( boot <identifiersep> check <identifiersep> command ) ; while ( counter < <number_literal> ) { string output = execute . get <identifiersep> output ( ) ; if ( output . trim ( ) . ends <identifiersep> with ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; return ; } <LOG> try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } counter ++ ; execute = run <identifiersep> utils . execute ( boot <identifiersep> check <identifiersep> command ) ; <ect>
if ( pid <identifiersep> from <identifiersep> ps <identifiersep> command != null ) { general <identifiersep> command <identifiersep> line kill <identifiersep> command = new general <identifiersep> command <identifiersep> line ( ) ; kill <identifiersep> command . set <identifiersep> exe <identifiersep> path ( <string_literal> ) ; kill <identifiersep> command . add <identifiersep> parameter ( pid <identifiersep> from <identifiersep> ps <identifiersep> command ) ; run <identifiersep> utils . execute ( kill <identifiersep> command ) ; } } } public void finish <identifiersep> emulator <identifiersep> processes ( ) { <LOG> output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( get <identifiersep> stop <identifiersep> command <identifiersep> for <identifiersep> adb ( ) ) ) ; finish <identifiersep> process ( <string_literal> ) ; stop <identifiersep> ddms <identifiersep> process ( ) ; } <comment> <ect>
command <identifiersep> line <identifiersep> for <identifiersep> list <identifiersep> of <identifiersep> devices . add <identifiersep> parameter ( <string_literal> ) ; run <identifiersep> result run <identifiersep> result = run <identifiersep> utils . execute ( command <identifiersep> line <identifiersep> for <identifiersep> list <identifiersep> of <identifiersep> devices ) ; output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> result ) ; matcher matcher = emulator <identifiersep> pattern . matcher ( run <identifiersep> result . get <identifiersep> output ( ) ) ; boolean is <identifiersep> ddms <identifiersep> stopped = false ; while ( matcher . find ( ) ) { <LOG> general <identifiersep> command <identifiersep> line command <identifiersep> line <identifiersep> for <identifiersep> stopping <identifiersep> emulators = new general <identifiersep> command <identifiersep> line ( ) ; if ( system <identifiersep> info . is <identifiersep> windows ) { command <identifiersep> line <identifiersep> for <identifiersep> stopping <identifiersep> emulators . set <identifiersep> exe <identifiersep> path ( <string_literal> ) ; command <identifiersep> line <identifiersep> for <identifiersep> stopping <identifiersep> emulators . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line <identifiersep> for <identifiersep> stopping <identifiersep> emulators . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line <identifiersep> for <identifiersep> stopping <identifiersep> emulators . add <identifiersep> parameter ( <string_literal> ) ; <ect>
public void before <identifiersep> define <identifiersep> class ( string name , int size <identifiersep> in <identifiersep> bytes ) { counter [ 0 ] ++ ; size [ 0 ] += size <identifiersep> in <identifiersep> bytes ; } @ override public void done ( ) { system . out . println ( ) ; <LOG> system . out . println ( <string_literal> + size [ 0 ] ) ; system . out . println ( ) ; instrumenter . dump ( system . out ) ; } @ override public byte [ ] instrument ( string resource <identifiersep> name , byte [ ] data ) { return instrumenter . instrument ( resource <identifiersep> name , data ) ; <ect>
private static instrumenter load <identifiersep> instrumenter ( class <identifiersep> loader with <identifiersep> instrumenter ) { service <identifiersep> loader < instrumenter > loader = service <identifiersep> loader . load ( instrumenter . class , with <identifiersep> instrumenter ) ; iterator < instrumenter > instrumenters = loader . iterator ( ) ; if ( instrumenters . has <identifiersep> next ( ) ) { instrumenter instrumenter = instrumenters . next ( ) ; if ( instrumenters . has <identifiersep> next ( ) ) { <LOG> } return instrumenter ; } else { system . err . println ( <string_literal> ) ; return instrumenter . do <identifiersep> nothing ; } } private static void print <identifiersep> usage ( print <identifiersep> stream out ) { out . println ( <string_literal> ) ; <ect>
val exit <identifiersep> code = process <identifiersep> output . exit <identifiersep> code try { assert <identifiersep> equals ( expected <identifiersep> stdout , stdout ) assert <identifiersep> equals ( expected <identifiersep> stderr , stderr ) assert <identifiersep> equals ( expected <identifiersep> exit <identifiersep> code , exit <identifiersep> code ) } catch ( e : throwable ) { <LOG> system . err . println ( <string_literal> ) system . err . println ( stdout ) system . err . println ( <string_literal> ) system . err . println ( stderr ) throw e } } private val test <identifiersep> data <identifiersep> directory : string <ect>
assert <identifiersep> equals ( expected <identifiersep> stderr , stderr ) assert <identifiersep> equals ( expected <identifiersep> exit <identifiersep> code , exit <identifiersep> code ) } catch ( e : throwable ) { system . err . println ( <string_literal> ) system . err . println ( <string_literal> ) system . err . println ( stdout ) <LOG> system . err . println ( stderr ) throw e } } private val test <identifiersep> data <identifiersep> directory : string get ( ) = kotlin <identifiersep> test <identifiersep> utils . get <identifiersep> test <identifiersep> data <identifiersep> path <identifiersep> base ( ) + <string_literal> fun test <identifiersep> kotlinc <identifiersep> simple ( ) { run <identifiersep> process ( <ect>
fun test <identifiersep> fun ( ) { <LOG> } var test <identifiersep> prop : any get ( ) { system . out . println ( <string_literal> ) return <number_literal> } set ( value ) { system . out . println ( <string_literal> ) <ect>
system . out . println ( <string_literal> ) } var test <identifiersep> prop : any get ( ) { system . out . println ( <string_literal> ) return <number_literal> } set ( value ) { <LOG> } class test <identifiersep> class { val test = when { else - > { system . out . println ( <string_literal> ) <number_literal> } } init { <ect>
class test <identifiersep> class { val test = when { else - > { system . out . println ( <string_literal> ) <number_literal> } } init { <LOG> } <ect>
abstract val name : string } val items : array <identifiersep> list < item > = array <identifiersep> list < item > ( ) fun test ( room : < ! platform <identifiersep> class <identifiersep> mapped <identifiersep> to <identifiersep> kotlin ! > object < ! > ) { for ( item : item ? in items ) { if ( item ? . room == = room ) { <comment> <LOG> } } <ect>
val prompt = string <identifiersep> builder ( ) for ( i in 0 . . <number_literal> ) { val n = rnd . next <identifiersep> int ( <number_literal> ) + 1 numbers . add ( n ) if ( i > 0 ) prompt . append ( <string_literal> ) ; prompt . append ( n ) } <LOG> system . out . println ( <string_literal> ) val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) if ( result != <number_literal> ) <ect>
system . out . println ( <string_literal> ) val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) if ( result != <number_literal> ) <LOG> else system . out . println ( <string_literal> ) ; } catch ( e : throwable ) { system . out . println ( e . message ) } } <ect>
val answer = java . util . array <identifiersep> list < t > ( ) ; for ( l in list ) { if ( filter ( l ) ) answer . add ( l ) } return answer ; } fun main ( args : array < string > ) { for ( a in filter ( args , { it . length > 1 } ) ) { <LOG> } } <ect>
public fun foo <identifiersep> not <identifiersep> null ( s : string ) { <LOG> } public fun foo ( ) { var s : string ? = <string_literal> if ( s == null ) { return } foo <identifiersep> not <identifiersep> null ( < ! debug <identifiersep> info <identifiersep> smartcast ! > s < ! > ) } <ect>
public fun bar ( s : string ) { <LOG> } public fun foo ( ) { var s : any = <string_literal> if ( s is string ) bar ( < ! debug <identifiersep> info <identifiersep> smartcast ! > s < ! > ) } <ect>
<comment> <LOG> } catch ( e : exception ) { log ( <string_literal> ) } } } fun log ( str : string ) : int { print ( <string_literal> ) return 0 } fun print ( < ! unused <identifiersep> parameter ! > obj < ! > : any ) { } <ect>
package hello fun main ( args : kotlin . array < kotlin . string > ) { <LOG> } <ect>
package hello fun main ( vararg args : kotlin . string ) { <LOG> } <ect>
<comment> <LOG> } catch ( e : exception ) { bar ( a ) } } inline fun bar ( a : int ) { my <identifiersep> run { log ( <string_literal> ) if ( a == <number_literal> ) return <ect>
catch ( e : exception ) { bar ( a ) } } inline fun bar ( a : int ) { my <identifiersep> run { log ( <string_literal> ) if ( a == <number_literal> ) return <LOG> } } var log : string = <string_literal> fun log ( s : string ) : string { log += s + <string_literal> return log } inline fun my <identifiersep> run ( f : ( ) - > unit ) = f ( ) <comment> <ect>
inline fun bar ( a : int ) { try { if ( a > 0 ) throw exception ( ) log ( <string_literal> ) } catch ( e : exception ) { my <identifiersep> run { <LOG> if ( a > 1 ) return log ( <string_literal> ) } } log ( <string_literal> ) } var log : string = <string_literal> fun log ( s : string ) : string { log += s + <string_literal> <ect>
log ( <string_literal> ) } catch ( e : exception ) { my <identifiersep> run { log ( <string_literal> ) if ( a > 1 ) return log ( <string_literal> ) } } <LOG> } var log : string = <string_literal> fun log ( s : string ) : string { log += s + <string_literal> return log } inline fun my <identifiersep> run ( f : ( ) - > unit ) = f ( ) <comment> <ect>
fun log ( x : string ) { if ( result . is <identifiersep> not <identifiersep> empty ( ) ) result += <string_literal> result += x } val future = async < string > { log ( <string_literal> ) val x = await ( foo ( ) ) <LOG> val y = foobar ( <string_literal> , await ( bar ( x ) ) ) log ( <string_literal> ) y } future . when <identifiersep> complete { value , t - > log ( <string_literal> ) } . join ( ) <ect>
val x = await ( foo ( ) ) log ( <string_literal> ) val y = foobar ( <string_literal> , await ( bar ( x ) ) ) log ( <string_literal> ) y } future . when <identifiersep> complete { value , t - > <LOG> } . join ( ) val expected <identifiersep> result = <string_literal> <string_literal> <ect>
cv , original <identifiersep> suspend <identifiersep> descriptor ) } } } private const val coroutine <identifiersep> lambda <identifiersep> parameter <identifiersep> prefix = <string_literal> private object failing <identifiersep> function <identifiersep> generation <identifiersep> strategy : function <identifiersep> generation <identifiersep> strategy ( ) { override fun skip <identifiersep> not <identifiersep> null <identifiersep> assertions <identifiersep> for <identifiersep> parameters ( ) : kotlin . boolean { <LOG> } override fun generate <identifiersep> body ( mv : method <identifiersep> visitor , frame <identifiersep> map : frame <identifiersep> map , signature : jvm <identifiersep> method <identifiersep> signature , context : method <identifiersep> context , parent <identifiersep> codegen : member <identifiersep> codegen < * > <ect>
assert ( insn . opcode == opcodes . invokespecial ) { <string_literal> } val params <identifiersep> count <identifiersep> including <identifiersep> receiver = type . get <identifiersep> argument <identifiersep> types ( ( insn as method <identifiersep> insn <identifiersep> node ) . desc ) . size + 1 val new <identifiersep> value = peek ( params <identifiersep> count <identifiersep> including <identifiersep> receiver ) as ? uninitialized <identifiersep> new <identifiersep> value ? : if ( is <identifiersep> in <identifiersep> special <identifiersep> method ) return null else <LOG> assert ( peek ( params <identifiersep> count <identifiersep> including <identifiersep> receiver - 1 ) is uninitialized <identifiersep> new <identifiersep> value ) { <string_literal> } return new <identifiersep> value } private class uninitialized <identifiersep> new <identifiersep> value ( val new <identifiersep> insn : type <identifiersep> insn <identifiersep> node , val internal <identifiersep> name : string <ect>
return insn <identifiersep> sequence ( node . instructions . first , null ) . filter <identifiersep> is <identifiersep> instance < line <identifiersep> number <identifiersep> node > ( ) . map { line <identifiersep> number - > val index = class <identifiersep> smap . intervals . binary <identifiersep> search ( range <identifiersep> mapping ( line <identifiersep> number . line , line <identifiersep> number . line , 1 ) , comparator { value , key - > if ( key . dest in value ) 0 else range <identifiersep> mapping . comparator . compare ( value , key ) } ) if ( index < 0 ) { <LOG> } label <identifiersep> and <identifiersep> mapping ( line <identifiersep> number , class <identifiersep> smap . intervals [ index ] ) } } class label <identifiersep> and <identifiersep> mapping ( val line <identifiersep> number <identifiersep> node : line <identifiersep> number <identifiersep> node , val mapper : range <identifiersep> mapping ) <ect>
p . print ( new print <identifiersep> writer ( out ) ) ; return out . to <identifiersep> string ( ) ; } @ suppress <identifiersep> warnings ( { <string_literal> , <string_literal> } ) @ test <identifiersep> only private void flush <identifiersep> current <identifiersep> state ( @ not <identifiersep> null abstract <identifiersep> insn <identifiersep> node cur <identifiersep> non <identifiersep> local ) { substitute <identifiersep> try <identifiersep> block <identifiersep> nodes ( inline <identifiersep> fun ) ; <LOG> string text = get <identifiersep> node <identifiersep> text ( inline <identifiersep> fun ) ; system . out . println ( text ) ; } } <ect>
override fun visit <identifiersep> local <identifiersep> delegated <identifiersep> property <identifiersep> reference ( expression : ir <identifiersep> local <identifiersep> delegated <identifiersep> property <identifiersep> reference ) { expression . delegate . check <identifiersep> binding ( <string_literal> , expression ) expression . getter . check <identifiersep> binding ( <string_literal> , expression ) expression . setter ? . check <identifiersep> binding ( <string_literal> , expression ) } private fun ir <identifiersep> symbol . check <identifiersep> binding ( kind : string , ir <identifiersep> element : ir <identifiersep> element ) { if ( ! is <identifiersep> bound ) { <LOG> } val other <identifiersep> symbol = symbol <identifiersep> for <identifiersep> declaration . get <identifiersep> or <identifiersep> put ( owner ) { this } if ( this != other <identifiersep> symbol ) { error ( <string_literal> ) } } override fun visit <identifiersep> class ( declaration : ir <identifiersep> class ) { visit <identifiersep> declaration ( declaration ) check <identifiersep> type <identifiersep> parameters ( declaration . descriptor , declaration , declaration . descriptor . declared <identifiersep> type <identifiersep> parameters ) <ect>
descriptor : declaration <identifiersep> descriptor , declaration : ir <identifiersep> type <identifiersep> parameters <identifiersep> container , expected <identifiersep> type <identifiersep> parameters : list < type <identifiersep> parameter <identifiersep> descriptor > ) { val declared <identifiersep> type <identifiersep> parameters = declaration . type <identifiersep> parameters . map { it . descriptor } if ( declared <identifiersep> type <identifiersep> parameters . size != expected <identifiersep> type <identifiersep> parameters . size ) { <LOG> } else { declared <identifiersep> type <identifiersep> parameters . zip ( expected <identifiersep> type <identifiersep> parameters ) . for <identifiersep> each { ( declared <identifiersep> type <identifiersep> parameter , expected <identifiersep> type <identifiersep> parameter ) - > require ( declared <identifiersep> type <identifiersep> parameter == expected <identifiersep> type <identifiersep> parameter ) { <string_literal> } } } } override fun visit <identifiersep> type <identifiersep> operator ( expression : ir <identifiersep> type <identifiersep> operator <identifiersep> call ) { expression . type <identifiersep> operand <identifiersep> classifier . check <identifiersep> binding ( <string_literal> , expression ) <ect>
boolean fail = false ; try { expected <identifiersep> load <identifiersep> errors <identifiersep> util . check <identifiersep> for <identifiersep> load <identifiersep> errors ( java <identifiersep> package , binding <identifiersep> context ) ; } catch ( comparison <identifiersep> failure e ) { <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; fail = true ; } catch ( assertion <identifiersep> error e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; fail = true ; } validate <identifiersep> and <identifiersep> compare <identifiersep> descriptor <identifiersep> with <identifiersep> file ( java <identifiersep> package , configuration , txt <identifiersep> file ) ; <ect>
public static file get <identifiersep> jdk9home <identifiersep> if <identifiersep> possible ( ) { string jdk9 = system . getenv ( <string_literal> ) ; if ( jdk9 == null ) { jdk9 = system . getenv ( <string_literal> ) ; } if ( jdk9 == null ) { <comment> <LOG> return null ; } return new file ( jdk9 ) ; } @ not <identifiersep> null private static string get <identifiersep> jre <identifiersep> home ( @ not <identifiersep> null string jdk <identifiersep> home ) { file jre = new file ( jdk <identifiersep> home , <string_literal> ) ; return jre . is <identifiersep> directory ( ) ? jre . get <identifiersep> path ( ) : jdk <identifiersep> home ; <ect>
dx <identifiersep> checker . check ( class <identifiersep> file <identifiersep> factory ) ; } } catch ( throwable e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; try { if ( class <identifiersep> file <identifiersep> factory == null ) { <LOG> } else { system . err . println ( class <identifiersep> file <identifiersep> factory . create <identifiersep> text ( ) ) ; } } catch ( throwable e1 ) { system . err . println ( <string_literal> ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; } else { system . err . println ( class <identifiersep> file <identifiersep> factory . create <identifiersep> text ( ) ) ; } } catch ( throwable e1 ) { system . err . println ( <string_literal> ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } fail ( <string_literal> ) ; } } return class <identifiersep> file <identifiersep> factory ; } protected boolean verify <identifiersep> with <identifiersep> dex ( ) { return true ; } private static boolean verify <identifiersep> all <identifiersep> files <identifiersep> with <identifiersep> asm ( class <identifiersep> file <identifiersep> factory factory , class <identifiersep> loader loader ) { boolean no <identifiersep> errors = true ; <ect>
. map { file <identifiersep> id ( it , it . last <identifiersep> modified ( ) , it . md5digest ( ) ) } . to <identifiersep> list ( ) val now <identifiersep> ms = time <identifiersep> unit . nanoseconds . to <identifiersep> millis ( system . nano <identifiersep> time ( ) ) last <identifiersep> update . set ( now <identifiersep> ms ) last <identifiersep> digest <identifiersep> update . set ( now <identifiersep> ms ) } catch ( e : io <identifiersep> exception ) { <LOG> <comment> <ect>
try { if ( ! it . file . exists ( ) ) { log . info ( <string_literal> ) true } <comment> <LOG> true } else false } catch ( e : io <identifiersep> exception ) { log . log ( level . info , <string_literal> , e ) true <comment> <ect>
<comment> <LOG> compile <identifiersep> service . call <identifiersep> result . good ( daemon <identifiersep> jvm <identifiersep> options ) } override fun register <identifiersep> client ( alive <identifiersep> flag <identifiersep> path : string ? ) : compile <identifiersep> service . call <identifiersep> result < nothing > = if <identifiersep> alive ( min <identifiersep> aliveness = aliveness . alive ) { state . add <identifiersep> client ( alive <identifiersep> flag <identifiersep> path ) log . info ( <string_literal> ) compile <identifiersep> service . call <identifiersep> result . ok ( ) } override fun get <identifiersep> clients ( ) : compile <identifiersep> service . call <identifiersep> result < list < string > > = if <identifiersep> alive { <ect>
override fun get <identifiersep> clients ( ) : compile <identifiersep> service . call <identifiersep> result < list < string > > = if <identifiersep> alive { compile <identifiersep> service . call <identifiersep> result . good ( state . get <identifiersep> clients <identifiersep> flag <identifiersep> paths ( ) ) } <comment> <LOG> } ) } override fun release <identifiersep> compile <identifiersep> session ( session <identifiersep> id : int ) = if <identifiersep> alive ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { state . sessions . remove ( session <identifiersep> id ) log . info ( <string_literal> ) rwlock . write { clear <identifiersep> jar <identifiersep> cache ( ) <ect>
compilation <identifiersep> results : compilation <identifiersep> results ? ) : compile <identifiersep> service . call <identifiersep> result < int > = if <identifiersep> alive { with <identifiersep> valid <identifiersep> client <identifiersep> or <identifiersep> session <identifiersep> proxy ( session <identifiersep> id ) { val message <identifiersep> collector = compile <identifiersep> services <identifiersep> facade <identifiersep> message <identifiersep> collector ( services <identifiersep> facade , compilation <identifiersep> options ) val daemon <identifiersep> reporter = daemon <identifiersep> message <identifiersep> reporter ( services <identifiersep> facade , compilation <identifiersep> options ) val target <identifiersep> platform = compilation <identifiersep> options . target <identifiersep> platform <LOG> @ suppress ( <string_literal> ) val compiler = when ( target <identifiersep> platform ) { compile <identifiersep> service . target <identifiersep> platform . jvm - > k2jvm <identifiersep> compiler ( ) compile <identifiersep> service . target <identifiersep> platform . js - > k2js <identifiersep> compiler ( ) compile <identifiersep> service . target <identifiersep> platform . metadata - > k2metadata <identifiersep> compiler ( ) } as cli <identifiersep> compiler < common <identifiersep> compiler <identifiersep> arguments > <ect>
private inline fun exception <identifiersep> logging <identifiersep> timer <identifiersep> thread ( body : ( ) - > unit ) { try { body ( ) } catch ( e : throwable ) { system . err . println ( <string_literal> + e . message ) e . print <identifiersep> stack <identifiersep> trace ( system . err ) <LOG> } } private fun periodic <identifiersep> and <identifiersep> after <identifiersep> session <identifiersep> check ( ) { if ( state . delayed <identifiersep> shutdown <identifiersep> queued . get ( ) ) return val any <identifiersep> dead = state . sessions . clean <identifiersep> dead ( ) || state . clean <identifiersep> dead <identifiersep> clients ( ) if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { when { <comment> <ect>
<comment> <LOG> shutdown <identifiersep> with <identifiersep> delay ( ) return } <comment> <ect>
log . info ( <string_literal> ) shutdown <identifiersep> with <identifiersep> delay ( ) return } } } if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . alive ) { when { daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds != compile <identifiersep> daemon <identifiersep> timeout <identifiersep> infinite <identifiersep> s && compilations <identifiersep> counter . get ( ) == 0 && now <identifiersep> seconds ( ) - last <identifiersep> used <identifiersep> seconds > daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds - > { <LOG> graceful <identifiersep> shutdown ( false ) } daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds != compile <identifiersep> daemon <identifiersep> timeout <identifiersep> infinite <identifiersep> s && now <identifiersep> seconds ( ) - last <identifiersep> used <identifiersep> seconds > daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds - > { log . info ( <string_literal> ) graceful <identifiersep> shutdown ( false ) } any <identifiersep> dead - > { clear <identifiersep> jar <identifiersep> cache ( ) <ect>
any <identifiersep> dead - > { clear <identifiersep> jar <identifiersep> cache ( ) } } } } private fun periodic <identifiersep> seldom <identifiersep> check ( ) { if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . alive ) { <comment> <LOG> graceful <identifiersep> shutdown ( false ) } } } <comment> <ect>
val comparator = compare <identifiersep> by <identifiersep> descending < daemon <identifiersep> with <identifiersep> metadata , daemon <identifiersep> jvm <identifiersep> options > ( daemon <identifiersep> jvm <identifiersep> options <identifiersep> memory <identifiersep> comparator ( ) , { it . jvm <identifiersep> options } ) . then <identifiersep> by ( file <identifiersep> age <identifiersep> comparator ( ) ) { it . run <identifiersep> file } alive <identifiersep> with <identifiersep> opts . max <identifiersep> with ( comparator ) ? . let { best <identifiersep> daemon <identifiersep> with <identifiersep> metadata - > val fattest <identifiersep> opts = best <identifiersep> daemon <identifiersep> with <identifiersep> metadata . jvm <identifiersep> options if ( fattest <identifiersep> opts memorywise <identifiersep> fits <identifiersep> into daemon <identifiersep> jvm <identifiersep> options && file <identifiersep> age <identifiersep> comparator ( ) . compare ( best <identifiersep> daemon <identifiersep> with <identifiersep> metadata . run <identifiersep> file , run <identifiersep> file ) < 0 ) { <comment> <LOG> alive <identifiersep> with <identifiersep> opts . for <identifiersep> each { ( daemon , run <identifiersep> file ,  <identifiersep>  ) - > try { daemon . get <identifiersep> clients ( ) . take <identifiersep> if { it . is <identifiersep> good } ? . let { it . get ( ) . for <identifiersep> each { client <identifiersep> alive <identifiersep> file - > register <identifiersep> client ( client <identifiersep> alive <identifiersep> file ) } } daemon . schedule <identifiersep> shutdown ( true ) } catch ( e : throwable ) { <ect>
<comment> <LOG> get <identifiersep> clients ( ) . take <identifiersep> if { it . is <identifiersep> good } ? . let { it . get ( ) . for <identifiersep> each { best <identifiersep> daemon <identifiersep> with <identifiersep> metadata . daemon . register <identifiersep> client ( it ) } } schedule <identifiersep> shutdown ( true ) } else { <comment> <ect>
<comment> <LOG> fun long . mb ( ) = this / ( <number_literal> * <number_literal> ) with ( runtime . get <identifiersep> runtime ( ) ) { log . info ( <string_literal> ) } state . alive . set ( aliveness . dying . ordinal ) unicast <identifiersep> remote <identifiersep> object . unexport <identifiersep> object ( this , true ) log . info ( <string_literal> ) <ect>
log . info ( <string_literal> ) fun long . mb ( ) = this / ( <number_literal> * <number_literal> ) with ( runtime . get <identifiersep> runtime ( ) ) { log . info ( <string_literal> ) } state . alive . set ( aliveness . dying . ordinal ) unicast <identifiersep> remote <identifiersep> object . unexport <identifiersep> object ( this , true ) <LOG> on <identifiersep> shutdown ( ) log . handlers . for <identifiersep> each { it . flush ( ) } } private fun shutdown <identifiersep> with <identifiersep> delay ( ) { state . delayed <identifiersep> shutdown <identifiersep> queued . set ( true ) val current <identifiersep> clients <identifiersep> count = state . clients <identifiersep> counter val current <identifiersep> session <identifiersep> id = state . sessions . last <identifiersep> session <identifiersep> id <ect>
state . delayed <identifiersep> shutdown <identifiersep> queued . set ( false ) if ( current <identifiersep> clients <identifiersep> count == state . clients <identifiersep> counter && current <identifiersep> compilations <identifiersep> count == compilations <identifiersep> counter . get ( ) && current <identifiersep> session <identifiersep> id == state . sessions . last <identifiersep> session <identifiersep> id ) { if <identifiersep> alive <identifiersep> exclusive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { <LOG> shutdown <identifiersep> now ( ) } } else { log . info ( <string_literal> ) } } } private fun graceful <identifiersep> shutdown ( on <identifiersep> another <identifiersep> thread : boolean ) : boolean { fun shutdown <identifiersep> if <identifiersep> idle ( ) = when { state . sessions . is <identifiersep> empty ( ) - > shutdown <identifiersep> with <identifiersep> delay ( ) <ect>
private fun graceful <identifiersep> shutdown ( on <identifiersep> another <identifiersep> thread : boolean ) : boolean { fun shutdown <identifiersep> if <identifiersep> idle ( ) = when { state . sessions . is <identifiersep> empty ( ) - > shutdown <identifiersep> with <identifiersep> delay ( ) else - > { daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds = time <identifiersep> unit . milliseconds . to <identifiersep> seconds ( daemon <identifiersep> options . force <identifiersep> shutdown <identifiersep> timeout <identifiersep> milliseconds ) . to <identifiersep> int ( ) daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds = daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds <LOG> log . info ( <string_literal> ) } } if ( ! state . alive . compare <identifiersep> and <identifiersep> set ( aliveness . alive . ordinal , aliveness . last <identifiersep> session . ordinal ) ) { log . info ( <string_literal> ) return false } log . info ( <string_literal> ) if ( ! on <identifiersep> another <identifiersep> thread ) { <ect>
else - > { daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds = time <identifiersep> unit . milliseconds . to <identifiersep> seconds ( daemon <identifiersep> options . force <identifiersep> shutdown <identifiersep> timeout <identifiersep> milliseconds ) . to <identifiersep> int ( ) daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds = daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds log . info ( <string_literal> ) log . info ( <string_literal> ) } } if ( ! state . alive . compare <identifiersep> and <identifiersep> set ( aliveness . alive . ordinal , aliveness . last <identifiersep> session . ordinal ) ) { <LOG> return false } log . info ( <string_literal> ) if ( ! on <identifiersep> another <identifiersep> thread ) { shutdown <identifiersep> if <identifiersep> idle ( ) } else { timer . schedule ( 1 ) { <ect>
@ jvm <identifiersep> static fun main ( args : array < string > ) { ensure <identifiersep> server <identifiersep> hostname <identifiersep> is <identifiersep> set <identifiersep> up ( ) val jvm <identifiersep> arguments = management <identifiersep> factory . get <identifiersep> runtime <identifiersep> mx <identifiersep> bean ( ) . input <identifiersep> arguments log . info ( <string_literal> + ( load <identifiersep> version <identifiersep> from <identifiersep> resource ( ) ? : <string_literal> ) ) log . info ( <string_literal> + jvm <identifiersep> arguments . join <identifiersep> to <identifiersep> string ( <string_literal> ) ) <LOG> set <identifiersep> idea <identifiersep> io <identifiersep> use <identifiersep> fallback ( ) val compiler <identifiersep> id = compiler <identifiersep> id ( ) val daemon <identifiersep> options = daemon <identifiersep> options ( ) try { val daemon <identifiersep> jvm <identifiersep> options = configure <identifiersep> daemon <identifiersep> jvm <identifiersep> options ( inherit <identifiersep> memory <identifiersep> limits = true , inherit <identifiersep> other <identifiersep> jvm <identifiersep> options = true , <ect>
timer = timer , on <identifiersep> shutdown = { if ( daemon <identifiersep> options . force <identifiersep> shutdown <identifiersep> timeout <identifiersep> milliseconds != compile <identifiersep> daemon <identifiersep> timeout <identifiersep> infinite <identifiersep> ms ) { <comment> <LOG> system . exit ( 0 ) } } else { timer . cancel ( ) } } ) println ( compile <identifiersep> daemon <identifiersep> is <identifiersep> ready <identifiersep> message ) log . info ( <string_literal> ) <ect>
<comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( system . err ) <comment> <ect>
) : message <identifiersep> collector { private val my <identifiersep> severity = compilation <identifiersep> options . report <identifiersep> severity private var has <identifiersep> errors = false override fun clear ( ) { has <identifiersep> errors = false } override fun report ( severity : compiler <identifiersep> message <identifiersep> severity , message : string , location : compiler <identifiersep> message <identifiersep> location ? ) { <LOG> when ( severity ) { compiler <identifiersep> message <identifiersep> severity . output - > { services <identifiersep> facade . report ( report <identifiersep> category . output <identifiersep> message , report <identifiersep> severity . error , message ) } compiler <identifiersep> message <identifiersep> severity . exception - > { services <identifiersep> facade . report ( report <identifiersep> category . exception , report <identifiersep> severity . error , message ) } else - > { <ect>
val substitutors = constraints <identifiersep> util . get <identifiersep> substitutors <identifiersep> for <identifiersep> conflicting <identifiersep> parameters ( inference <identifiersep> error <identifiersep> data . constraint <identifiersep> system ) for ( substitutor in substitutors ) { val substituted <identifiersep> descriptor = inference <identifiersep> error <identifiersep> data . descriptor . substitute ( substitutor ) substituted <identifiersep> descriptors . add ( substituted <identifiersep> descriptor ) } val first <identifiersep> conflicting <identifiersep> variable = constraints <identifiersep> util . get <identifiersep> first <identifiersep> conflicting <identifiersep> variable ( inference <identifiersep> error <identifiersep> data . constraint <identifiersep> system ) if ( first <identifiersep> conflicting <identifiersep> variable == null ) { <LOG> return result } result . text ( new <identifiersep> text ( ) . normal ( <string_literal> ) . strong ( first <identifiersep> conflicting <identifiersep> variable . name ) . normal ( <string_literal> ) <ect>
inference <identifiersep> error <identifiersep> data : inference <identifiersep> error <identifiersep> data , result : tabled <identifiersep> descriptor <identifiersep> renderer , system <identifiersep> without <identifiersep> weak <identifiersep> constraints : constraint <identifiersep> system ) : tabled <identifiersep> descriptor <identifiersep> renderer ? { val descriptor = inference <identifiersep> error <identifiersep> data . descriptor if ( descriptor ! is type <identifiersep> alias <identifiersep> constructor <identifiersep> descriptor ) { <LOG> return result } val inferred <identifiersep> types <identifiersep> for <identifiersep> type <identifiersep> parameters = descriptor . type <identifiersep> parameters . map { val type <identifiersep> variable = system <identifiersep> without <identifiersep> weak <identifiersep> constraints . descriptor <identifiersep> to <identifiersep> variable ( inference <identifiersep> error <identifiersep> data . call . to <identifiersep> handle ( ) , it ) system <identifiersep> without <identifiersep> weak <identifiersep> constraints . get <identifiersep> type <identifiersep> bounds ( type <identifiersep> variable ) . value } val inferred <identifiersep> type <identifiersep> substitutor = type <identifiersep> substitutor . create ( object : type <identifiersep> constructor <identifiersep> substitution ( ) { override fun get ( key : type <identifiersep> constructor ) : type <identifiersep> projection ? { <ect>
@ not <identifiersep> null @ override public argument <identifiersep> mapping get <identifiersep> argument <identifiersep> mapping ( @ not <identifiersep> null value <identifiersep> argument value <identifiersep> argument ) { argument <identifiersep> match argument <identifiersep> match = argument <identifiersep> to <identifiersep> parameter <identifiersep> map . get ( value <identifiersep> argument ) ; if ( argument <identifiersep> match == null ) { if ( argument <identifiersep> mapping <identifiersep> kt . is <identifiersep> really <identifiersep> success ( this ) ) { <LOG> } return argument <identifiersep> unmapped . instance ; } return argument <identifiersep> match ; } @ not <identifiersep> null @ override public map < type <identifiersep> parameter <identifiersep> descriptor , kotlin <identifiersep> type > get <identifiersep> type <identifiersep> arguments ( ) { return type <identifiersep> arguments ; <ect>
declaration <identifiersep> category . type <identifiersep> or <identifiersep> value is function <identifiersep> descriptor - > declaration <identifiersep> category . function is classifier <identifiersep> descriptor - > declaration <identifiersep> category . type <identifiersep> or <identifiersep> value else - > <LOG> } } <ect>
fill <identifiersep> specific <identifiersep> arguments ( ) } final override fun execute ( ) { fill <identifiersep> arguments ( ) val compiler <identifiersep> class = kotlin <identifiersep> ant <identifiersep> task <identifiersep> util . get <identifiersep> or <identifiersep> create <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( compiler <identifiersep> fq <identifiersep> name ) val compiler = compiler <identifiersep> class . new <identifiersep> instance ( ) val exec = compiler <identifiersep> class . get <identifiersep> method ( <string_literal> , print <identifiersep> stream : : class . java , array < string > : : class . java ) <LOG> val result = exec ( compiler , system . err , args . to <identifiersep> typed <identifiersep> array ( ) ) exit <identifiersep> code = ( result as enum < * > ) . ordinal if ( fail <identifiersep> on <identifiersep> error && exit <identifiersep> code != 0 ) { throw build <identifiersep> exception ( <string_literal> ) } } } <ect>
super . notify <identifiersep> text <identifiersep> available ( text , key ) } } private fun handle <identifiersep> repl <identifiersep> message ( text : string ) { if ( text . is <identifiersep> blank ( ) ) return val output = try { factory . new <identifiersep> document <identifiersep> builder ( ) . parse ( str <identifiersep> to <identifiersep> source ( text ) ) } catch ( e : exception ) { <LOG> return } val root = output . first <identifiersep> child as element val output <identifiersep> type = repl <identifiersep> escape <identifiersep> type . value <identifiersep> of <identifiersep> or <identifiersep> null ( root . get <identifiersep> attribute ( <string_literal> ) ) val content = string <identifiersep> util . replace ( root . text <identifiersep> content , xml <identifiersep> replacements , source <identifiersep> chars ) when ( output <identifiersep> type ) { initial <identifiersep> prompt - > build <identifiersep> warning <identifiersep> if <identifiersep> needed <identifiersep> before <identifiersep> init ( content ) <ect>
var i = 1 while ( file . parent . find <identifiersep> child ( new <identifiersep> name ) != null ) { new <identifiersep> name = file . name <identifiersep> without <identifiersep> extension + <string_literal> + i + std <identifiersep> script <identifiersep> ext i ++ } file . rename ( this , new <identifiersep> name ) } } if ( file . extension != std <identifiersep> script <identifiersep> suffix ) { <LOG> return } val scratch <identifiersep> panel = get <identifiersep> editor <identifiersep> with <identifiersep> scratch <identifiersep> panel ( source , file ) ? . second scratch <identifiersep> panel ? . add <identifiersep> module <identifiersep> listener { psi <identifiersep> file , module - > psi <identifiersep> file . module <identifiersep> info = get <identifiersep> module <identifiersep> info ( module ) <comment> <ect>
companion object { private val log = logger . get <identifiersep> instance ( kotlin <identifiersep> coverage <identifiersep> extension : : class . java ) fun collect <identifiersep> generated <identifiersep> class <identifiersep> qualified <identifiersep> names ( output <identifiersep> root : virtual <identifiersep> file ? , file : kt <identifiersep> file ) : list < string > ? { val existing <identifiersep> class <identifiersep> files = get <identifiersep> classes <identifiersep> generated <identifiersep> from <identifiersep> file ( output <identifiersep> root , file ) if ( existing <identifiersep> class <identifiersep> files . is <identifiersep> empty ( ) ) { return null } <LOG> return existing <identifiersep> class <identifiersep> files . map { val relative <identifiersep> path = vfs <identifiersep> util <identifiersep> core . get <identifiersep> relative <identifiersep> path ( it , output <identifiersep> root ! ! ) ! ! string <identifiersep> util . trim <identifiersep> end ( relative <identifiersep> path , <string_literal> ) . replace ( <string_literal> , <string_literal> ) } } private fun total <identifiersep> coverage <identifiersep> for <identifiersep> qualified <identifiersep> names ( coverage <identifiersep> annotator : java <identifiersep> coverage <identifiersep> annotator , qualified <identifiersep> names : list < string > <ect>
return result } private fun get <identifiersep> classes <identifiersep> generated <identifiersep> from <identifiersep> file ( output <identifiersep> root : virtual <identifiersep> file ? , file : kt <identifiersep> file ) : list < virtual <identifiersep> file > { val relative <identifiersep> path = file . package <identifiersep> fq <identifiersep> name . as <identifiersep> string ( ) . replace ( ' . ' , ' / ' ) val package <identifiersep> output <identifiersep> dir = output <identifiersep> root ? . find <identifiersep> file <identifiersep> by <identifiersep> relative <identifiersep> path ( relative <identifiersep> path ) if ( package <identifiersep> output <identifiersep> dir == null ) return list <identifiersep> of ( ) val prefixes = collect <identifiersep> class <identifiersep> file <identifiersep> prefixes ( file ) <LOG> return package <identifiersep> output <identifiersep> dir . children . filter { package <identifiersep> file - > prefixes . any { ( package <identifiersep> file . name . starts <identifiersep> with ( it + <string_literal> ) && file <identifiersep> util <identifiersep> rt . get <identifiersep> extension ( package <identifiersep> file . name ) == <string_literal> ) || package <identifiersep> file . name == it + <string_literal> } } } private fun find <identifiersep> output <identifiersep> root ( file : kt <identifiersep> file ) : virtual <identifiersep> file ? { val module = module <identifiersep> util <identifiersep> core . find <identifiersep> module <identifiersep> for <identifiersep> psi <identifiersep> element ( file ) <ect>
if ( ! new <identifiersep> file . exists ( ) ) { if ( ! jar <identifiersep> io <identifiersep> file <identifiersep> to <identifiersep> replace . rename <identifiersep> to ( new <identifiersep> file ) ) { log . info ( <string_literal> ) return null } val new <identifiersep> v <identifiersep> file = local <identifiersep> file <identifiersep> system . get <identifiersep> instance ( ) . refresh <identifiersep> and <identifiersep> find <identifiersep> file <identifiersep> by <identifiersep> io <identifiersep> file ( new <identifiersep> file ) if ( new <identifiersep> v <identifiersep> file == null ) { <LOG> return null } new <identifiersep> v <identifiersep> file . refresh ( false , true ) return new <identifiersep> v <identifiersep> file } } jar <identifiersep> file <identifiersep> to <identifiersep> replace . refresh ( false , true ) return null <ect>
new function1 < field , boolean > ( ) { @ override public boolean invoke ( field field ) { return j <identifiersep> combo <identifiersep> box . class . is <identifiersep> assignable <identifiersep> from ( field . get <identifiersep> type ( ) ) ; } } ) ; if ( lib <identifiersep> combobox <identifiersep> field == null ) { <LOG> return false ; } lib <identifiersep> combobox <identifiersep> field . set <identifiersep> accessible ( true ) ; j <identifiersep> combo <identifiersep> box combobox = ( j <identifiersep> combo <identifiersep> box ) lib <identifiersep> combobox <identifiersep> field . get ( panel ) ; return combobox . get <identifiersep> selected <identifiersep> item ( ) != null ; } return ordinal != <number_literal> ; } catch ( exception e ) { <ect>
. locations <identifiersep> of <identifiersep> line ( ref <identifiersep> type , source <identifiersep> position ) . filter { it . method ( ) . is <identifiersep> constructor || it . method ( ) . is <identifiersep> static <identifiersep> initializer } . for <identifiersep> each { val request = debug <identifiersep> process . requests <identifiersep> manager . create <identifiersep> breakpoint <identifiersep> request ( this , it ) debug <identifiersep> process . requests <identifiersep> manager . enable <identifiersep> request ( request ) <LOG> } } } } when ( breakpoint <identifiersep> type ) { breakpoint <identifiersep> type . field - > { val field = ref <identifiersep> type . field <identifiersep> by <identifiersep> name ( get <identifiersep> field <identifiersep> name ( ) ) if ( field != null ) { val manager = debug <identifiersep> process . requests <identifiersep> manager if ( properties . watch <identifiersep> modification && vm . can <identifiersep> watch <identifiersep> field <identifiersep> modification ( ) ) { <ect>
val debugger <identifiersep> session = debugger <identifiersep> context . debugger <identifiersep> session if ( ( debugger <identifiersep> session == null || debugger <identifiersep> context . suspend <identifiersep> context == null ) && ! application <identifiersep> manager . get <identifiersep> application ( ) . is <identifiersep> unit <identifiersep> test <identifiersep> mode ) { log . warn ( <string_literal> ) return @ put <identifiersep> copyable <identifiersep> user <identifiersep> data empty <identifiersep> file } val frame <identifiersep> descriptor = get <identifiersep> frame <identifiersep> info ( context <identifiersep> element , debugger <identifiersep> context ) if ( frame <identifiersep> descriptor == null ) { <LOG> return @ put <identifiersep> copyable <identifiersep> user <identifiersep> data empty <identifiersep> file } val receiver <identifiersep> type <identifiersep> reference = frame <identifiersep> descriptor . this <identifiersep> object ? . let { create <identifiersep> kotlin <identifiersep> property ( project , <string_literal> , it . type ( ) . name ( ) , it ) } ? . type <identifiersep> reference val receiver <identifiersep> type <identifiersep> text = receiver <identifiersep> type <identifiersep> reference ? . let { <string_literal> } ? : <string_literal> val kotlin <identifiersep> variables <identifiersep> text = frame <identifiersep> descriptor . visible <identifiersep> variables . entries . associate { it . key . name ( ) to it . value } . kotlin <identifiersep> variables <identifiersep> as <identifiersep> text ( project ) <ect>
fun load <identifiersep> classes <identifiersep> safely ( evaluation <identifiersep> context : evaluation <identifiersep> context <identifiersep> impl , classes : collection < class <identifiersep> to <identifiersep> load > ) : class <identifiersep> loader <identifiersep> reference ? { return try { load <identifiersep> classes ( evaluation <identifiersep> context , classes ) } catch ( e : evaluate <identifiersep> exception ) { throw e } catch ( e : throwable ) { <LOG> null } } fun load <identifiersep> classes ( evaluation <identifiersep> context : evaluation <identifiersep> context <identifiersep> impl , classes : collection < class <identifiersep> to <identifiersep> load > ) : class <identifiersep> loader <identifiersep> reference ? { if ( classes . is <identifiersep> empty ( ) ) { return null } return class <identifiersep> loading <identifiersep> adapter . load <identifiersep> classes ( evaluation <identifiersep> context , classes ) <ect>
code <identifiersep> fragment . check <identifiersep> for <identifiersep> errors ( ) val extraction <identifiersep> result = get <identifiersep> function <identifiersep> for <identifiersep> extracted <identifiersep> fragment ( code <identifiersep> fragment , source <identifiersep> position . file , source <identifiersep> position . line ) ? : throw illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) val parameters <identifiersep> descriptor = extraction <identifiersep> result . get <identifiersep> parameters <identifiersep> for <identifiersep> debugger ( code <identifiersep> fragment ) val extracted <identifiersep> function = extraction <identifiersep> result . declaration as kt <identifiersep> named <identifiersep> function <LOG> } val class <identifiersep> file <identifiersep> factory = create <identifiersep> class <identifiersep> file <identifiersep> factory ( code <identifiersep> fragment , extracted <identifiersep> function , context , parameters <identifiersep> descriptor ) val output <identifiersep> files = class <identifiersep> file <identifiersep> factory . as <identifiersep> list ( ) . filter <identifiersep> class <identifiersep> files ( ) for ( file in output <identifiersep> files ) { log . debug ( <string_literal> ) } if ( debug <identifiersep> mode ) { <ect>
. map { ( value , type ) - > <comment> <LOG> return null } } private fun run <identifiersep> eval4j ( context : evaluation <identifiersep> context <identifiersep> impl , compiled <identifiersep> data : compiled <identifiersep> data <identifiersep> descriptor ) : interpreter <identifiersep> result { val virtual <identifiersep> machine = context . debug <identifiersep> process . virtual <identifiersep> machine <identifiersep> proxy . virtual <identifiersep> machine var result <identifiersep> value : interpreter <identifiersep> result ? = null <comment> <ect>
context : evaluation <identifiersep> context <identifiersep> impl , parameters : parameters <identifiersep> descriptor ) : class <identifiersep> file <identifiersep> factory { return run <identifiersep> read <identifiersep> action { val file <identifiersep> for <identifiersep> debugger = create <identifiersep> file <identifiersep> for <identifiersep> debugger ( code <identifiersep> fragment , extracted <identifiersep> function ) <LOG> } val ( binding <identifiersep> context , module <identifiersep> descriptor , files ) = file <identifiersep> for <identifiersep> debugger . check <identifiersep> for <identifiersep> errors ( true , code <identifiersep> fragment . get <identifiersep> context <identifiersep> containing <identifiersep> file ( ) ) val generate <identifiersep> class <identifiersep> filter = object : generation <identifiersep> state . generate <identifiersep> class <identifiersep> filter ( ) { override fun should <identifiersep> generate <identifiersep> package <identifiersep> part ( kt <identifiersep> file : kt <identifiersep> file ) = kt <identifiersep> file == file <identifiersep> for <identifiersep> debugger override fun should <identifiersep> annotate <identifiersep> class ( processing <identifiersep> class <identifiersep> or <identifiersep> object : kt <identifiersep> class <identifiersep> or <identifiersep> object ) = true override fun should <identifiersep> generate <identifiersep> class ( processing <identifiersep> class <identifiersep> or <identifiersep> object : kt <identifiersep> class <identifiersep> or <identifiersep> object ) = processing <identifiersep> class <identifiersep> or <identifiersep> object . containing <identifiersep> kt <identifiersep> file == file <identifiersep> for <identifiersep> debugger override fun should <identifiersep> generate <identifiersep> script ( script : kt <identifiersep> script ) = false <ect>
val class <identifiersep> names <identifiersep> of <identifiersep> containing <identifiersep> declaration = get <identifiersep> outer <identifiersep> class <identifiersep> names <identifiersep> for <identifiersep> element ( element . relevant <identifiersep> parent <identifiersep> in <identifiersep> read <identifiersep> action ) val non <identifiersep> inline <identifiersep> classes : computed <identifiersep> class <identifiersep> names = if ( run <identifiersep> read <identifiersep> action { element . name == null || element . is <identifiersep> local } ) { val type <identifiersep> for <identifiersep> anonymous <identifiersep> class = asm <identifiersep> type <identifiersep> for <identifiersep> anonymous <identifiersep> class <identifiersep> or <identifiersep> null ( type <identifiersep> mapper . binding <identifiersep> context , element ) if ( type <identifiersep> for <identifiersep> anonymous <identifiersep> class == null ) { val parent <identifiersep> text = element . relevant <identifiersep> parent <identifiersep> in <identifiersep> read <identifiersep> action ? . text ? : <string_literal> <LOG> class <identifiersep> names <identifiersep> of <identifiersep> containing <identifiersep> declaration } else { class <identifiersep> names <identifiersep> of <identifiersep> containing <identifiersep> declaration + computed <identifiersep> class <identifiersep> names . cached ( type <identifiersep> for <identifiersep> anonymous <identifiersep> class . internal <identifiersep> name . to <identifiersep> jdi <identifiersep> name ( ) ) } } else { class <identifiersep> names <identifiersep> of <identifiersep> containing <identifiersep> declaration } if ( ! find <identifiersep> inline <identifiersep> use <identifiersep> sites || ! element . is <identifiersep> inline <identifiersep> in <identifiersep> read <identifiersep> action ) { <ect>
log . warn ( <string_literal> ) } } override fun find <identifiersep> virtual <identifiersep> file <identifiersep> with <identifiersep> header ( class <identifiersep> id : class <identifiersep> id ) : virtual <identifiersep> file ? = find <identifiersep> virtual <identifiersep> file <identifiersep> with <identifiersep> header ( class <identifiersep> id , kotlin <identifiersep> class <identifiersep> file <identifiersep> index . key ) private fun find <identifiersep> virtual <identifiersep> file <identifiersep> with <identifiersep> header ( class <identifiersep> id : class <identifiersep> id , key : id < fq <identifiersep> name , void > ) : virtual <identifiersep> file ? { val files = file <identifiersep> based <identifiersep> index . get <identifiersep> instance ( ) . get <identifiersep> containing <identifiersep> files < fq <identifiersep> name , void > ( key , class <identifiersep> id . as <identifiersep> single <identifiersep> fq <identifiersep> name ( ) , scope ) if ( files . size > 1 ) { <LOG> } return files . first <identifiersep> or <identifiersep> null ( ) } companion object { private val log = logger . get <identifiersep> instance ( ide <identifiersep> virtual <identifiersep> file <identifiersep> finder : : class . java ) } } <ect>
return kotlin <identifiersep> icons . object ; case class : return modality . abstract == get <identifiersep> modality <identifiersep> safe ( class <identifiersep> descriptor ) ? kotlin <identifiersep> icons . abstract <identifiersep> class : kotlin <identifiersep> icons . class ; default : <LOG> return null ; } } if ( descriptor instanceof value <identifiersep> parameter <identifiersep> descriptor ) { return kotlin <identifiersep> icons . parameter ; } if ( descriptor instanceof local <identifiersep> variable <identifiersep> descriptor ) { return ( ( variable <identifiersep> descriptor ) descriptor ) . is <identifiersep> var ( ) ? kotlin <identifiersep> icons . var : kotlin <identifiersep> icons . val ; } if ( descriptor instanceof property <identifiersep> descriptor ) { <ect>
is kt <identifiersep> prefix <identifiersep> expression - > precedence <identifiersep> of <identifiersep> prefix <identifiersep> expression is kt <identifiersep> postfix <identifiersep> expression - > precedence <identifiersep> of <identifiersep> postfix <identifiersep> expression is kt <identifiersep> operation <identifiersep> expression - > { val operation = expression . operation <identifiersep> reference . get <identifiersep> referenced <identifiersep> name <identifiersep> element <identifiersep> type ( ) val precedence <identifiersep> number = precedence [ operation ] if ( precedence <identifiersep> number == null ) { <LOG> precedence . size } else precedence <identifiersep> number } else - > precedence <identifiersep> of <identifiersep> atomic <identifiersep> expression } } fun is <identifiersep> tighter ( subject : int , tighter <identifiersep> than : int ) : boolean { return subject < tighter <identifiersep> than } } <ect>
tasks . push ( task ) } } private fun process <identifiersep> tasks ( ) { while ( tasks . is <identifiersep> not <identifiersep> empty ( ) ) { tasks . pop ( ) . perform ( ) } } private fun down <identifiersep> shift <identifiersep> to <identifiersep> plain <identifiersep> search ( reference : psi <identifiersep> reference ) { val message = get <identifiersep> fallback <identifiersep> diagnostics <identifiersep> message ( reference ) <LOG> test <identifiersep> log { <string_literal> } tasks . clear ( ) scopes <identifiersep> to <identifiersep> use <identifiersep> plain <identifiersep> search . clear ( ) possible <identifiersep> matches <identifiersep> in <identifiersep> scope <identifiersep> handler ( search <identifiersep> scope ) } private fun check <identifiersep> psi <identifiersep> class ( psi <identifiersep> class : psi <identifiersep> class ) : boolean { <comment> <ect>
return stub } private fun create <identifiersep> stub ( file : virtual <identifiersep> file ) : psi <identifiersep> java <identifiersep> file <identifiersep> stub ? { if ( file . file <identifiersep> type != = java <identifiersep> class <identifiersep> file <identifiersep> type . instance ) return null try { return cls <identifiersep> file <identifiersep> impl . build <identifiersep> file <identifiersep> stub ( file , file . contents <identifiersep> to <identifiersep> byte <identifiersep> array ( false ) ) } catch ( e : cls <identifiersep> format <identifiersep> exception ) { <LOG> } catch ( e : io <identifiersep> exception ) { log . error ( <string_literal> + file . canonical <identifiersep> path ! ! , e ) } return null } companion object { private val log = logger . get <identifiersep> instance ( cls <identifiersep> java <identifiersep> stub <identifiersep> by <identifiersep> virtual <identifiersep> file <identifiersep> cache : : class . java ) fun get <identifiersep> instance ( project : project ) : cls <identifiersep> java <identifiersep> stub <identifiersep> by <identifiersep> virtual <identifiersep> file <identifiersep> cache { <ect>
return ide <identifiersep> light <identifiersep> class <identifiersep> construction <identifiersep> context ( binding <identifiersep> context , resolution <identifiersep> facade . module <identifiersep> descriptor , exact ) } fun context <identifiersep> for <identifiersep> local <identifiersep> class <identifiersep> or <identifiersep> object ( class <identifiersep> or <identifiersep> object : kt <identifiersep> class <identifiersep> or <identifiersep> object ) : light <identifiersep> class <identifiersep> construction <identifiersep> context { val resolution <identifiersep> facade = class <identifiersep> or <identifiersep> object . get <identifiersep> resolution <identifiersep> facade ( ) val binding <identifiersep> context = resolution <identifiersep> facade . analyze ( class <identifiersep> or <identifiersep> object ) val descriptor = binding <identifiersep> context . get ( binding <identifiersep> context . class , class <identifiersep> or <identifiersep> object ) if ( descriptor == null ) { <LOG> return ide <identifiersep> light <identifiersep> class <identifiersep> construction <identifiersep> context ( binding <identifiersep> context , resolution <identifiersep> facade . module <identifiersep> descriptor , exact ) } force <identifiersep> resolve <identifiersep> util . force <identifiersep> resolve <identifiersep> all <identifiersep> contents ( descriptor ) return ide <identifiersep> light <identifiersep> class <identifiersep> construction <identifiersep> context ( binding <identifiersep> context , resolution <identifiersep> facade . module <identifiersep> descriptor , exact ) } fun context <identifiersep> for <identifiersep> facade ( files : list < kt <identifiersep> file > ) : light <identifiersep> class <identifiersep> construction <identifiersep> context { val resolve <identifiersep> session = files . first ( ) . get <identifiersep> resolution <identifiersep> facade ( ) . get <identifiersep> frontend <identifiersep> service ( resolve <identifiersep> session : : class . java ) force <identifiersep> resolve <identifiersep> package <identifiersep> declarations ( files , resolve <identifiersep> session ) <ect>
for ( file in files ) { if ( file . is <identifiersep> script ( ) ) continue val package <identifiersep> fq <identifiersep> name = file . package <identifiersep> fq <identifiersep> name <comment> <LOG> session . force <identifiersep> resolve <identifiersep> all ( ) continue } for ( declaration in file . declarations ) { when ( declaration ) { is kt <identifiersep> function - > { val name = declaration . name <identifiersep> as <identifiersep> safe <identifiersep> name <ect>
module <identifiersep> filter = { it == synthetic <identifiersep> file <identifiersep> module } ) } synthetic <identifiersep> file <identifiersep> module . is <identifiersep> library <identifiersep> classes ( ) - > { <comment> <LOG> val global <identifiersep> context = global <identifiersep> context ( ) make <identifiersep> project <identifiersep> resolution <identifiersep> facade ( <string_literal> , global <identifiersep> context ) } else - > throw illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) <ect>
return @ processor it ? : not <identifiersep> under <identifiersep> content <identifiersep> root <identifiersep> module <identifiersep> info } ) } ) object nullable <identifiersep> take <identifiersep> first : module <identifiersep> info <identifiersep> collector < idea <identifiersep> module <identifiersep> info ? > ( on <identifiersep> result = { it } , on <identifiersep> failure = { reason - > <LOG> null } , virtual <identifiersep> file <identifiersep> processor = processor @ { project , virtual <identifiersep> file , is <identifiersep> library <identifiersep> source - > collect <identifiersep> infos <identifiersep> by <identifiersep> virtual <identifiersep> file ( project , virtual <identifiersep> file , <ect>
is kt <identifiersep> code <identifiersep> fragment - > code <identifiersep> fragment <identifiersep> additional <identifiersep> resolve ( resolve <identifiersep> element , body <identifiersep> resolve <identifiersep> mode ) is kt <identifiersep> script - > script <identifiersep> additional <identifiersep> resolve ( resolve <identifiersep> session , resolve <identifiersep> element , body <identifiersep> resolve <identifiersep> mode . binding <identifiersep> trace <identifiersep> filter ) else - > { if ( resolve <identifiersep> element . get <identifiersep> parent <identifiersep> of <identifiersep> type < kt <identifiersep> package <identifiersep> directive > ( true ) != null ) { package <identifiersep> ref <identifiersep> additional <identifiersep> resolve ( resolve <identifiersep> session , resolve <identifiersep> element , body <identifiersep> resolve <identifiersep> mode . binding <identifiersep> trace <identifiersep> filter ) } else { <LOG> } } } val control <identifiersep> flow <identifiersep> trace = delegating <identifiersep> binding <identifiersep> trace ( trace . binding <identifiersep> context , <string_literal> , resolve <identifiersep> element , allow <identifiersep> slice <identifiersep> rewrite = true ) control <identifiersep> flow <identifiersep> information <identifiersep> provider ( resolve <identifiersep> element , control <identifiersep> flow <identifiersep> trace , resolve <identifiersep> element . language <identifiersep> version <identifiersep> settings , resolve <identifiersep> session . platform <identifiersep> diagnostic <identifiersep> suppressor ) . check <identifiersep> declaration ( ) control <identifiersep> flow <identifiersep> trace . add <identifiersep> own <identifiersep> data <identifiersep> to ( trace , null , false ) <ect>
import org . jetbrains . kotlin . descriptors . class <identifiersep> descriptor import org . jetbrains . kotlin . serialization . deserialization . error <identifiersep> reporter class logging <identifiersep> error <identifiersep> reporter ( private val log : logger ) : error <identifiersep> reporter { override fun report <identifiersep> incomplete <identifiersep> hierarchy ( descriptor : class <identifiersep> descriptor , unresolved <identifiersep> super <identifiersep> classes : list < string > ) { <comment> <LOG> } } <ect>
val intention = class . for <identifiersep> name ( intention <identifiersep> class <identifiersep> name ) . new <identifiersep> instance ( ) as ? intention <identifiersep> action ? : error ( <string_literal> ) if ( ! intention . is <identifiersep> available ( my <identifiersep> fixture . project , my <identifiersep> fixture . editor , my <identifiersep> fixture . file ) ) { if ( not <identifiersep> available ) { return } error ( <string_literal> ) } if ( not <identifiersep> available ) { <LOG> } my <identifiersep> fixture . launch <identifiersep> action ( intention ) if ( check <identifiersep> manifest ) { my <identifiersep> fixture . check <identifiersep> result <identifiersep> by <identifiersep> file ( <string_literal> , <string_literal> , true ) } else { my <identifiersep> fixture . check <identifiersep> result <identifiersep> by <identifiersep> file ( <string_literal> ) } } finally { <ect>
<comment> additional <identifiersep> resolver <identifiersep> classpath : list < file > = empty <identifiersep> list ( ) ) : list < kotlin <identifiersep> script <identifiersep> definition <identifiersep> from <identifiersep> annotated <identifiersep> template > = try { val classpath = template <identifiersep> classpath + additional <identifiersep> resolver <identifiersep> classpath <LOG> val base <identifiersep> loader = script <identifiersep> definition <identifiersep> contributor : : class . java . class <identifiersep> loader val loader = if ( classpath . is <identifiersep> empty ( ) ) base <identifiersep> loader else url <identifiersep> class <identifiersep> loader ( classpath . map { it . to <identifiersep> uri ( ) . to <identifiersep> url ( ) } . to <identifiersep> typed <identifiersep> array ( ) , base <identifiersep> loader ) template <identifiersep> class <identifiersep> names . map { kotlin <identifiersep> script <identifiersep> definition <identifiersep> from <identifiersep> annotated <identifiersep> template ( loader . load <identifiersep> class ( it ) . kotlin , environment , <ect>
descriptor : declaration <identifiersep> descriptor , use <identifiersep> receiver <identifiersep> types : boolean , qualify <identifiersep> nested <identifiersep> classes : boolean , include <identifiersep> class <identifiersep> type <identifiersep> arguments : boolean , parameters <identifiersep> and <identifiersep> type <identifiersep> grayed : boolean ) : lookup <identifiersep> element ? { <LOG> } override fun create <identifiersep> standard <identifiersep> lookup <identifiersep> elements <identifiersep> for <identifiersep> descriptor ( descriptor : declaration <identifiersep> descriptor , use <identifiersep> receiver <identifiersep> types : boolean ) : collection < lookup <identifiersep> element > { return element <identifiersep> factory . create <identifiersep> standard <identifiersep> lookup <identifiersep> elements <identifiersep> for <identifiersep> descriptor ( descriptor , use <identifiersep> receiver <identifiersep> types ) . also { it . for <identifiersep> each { element - > <ect>
val psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after = modification <identifiersep> scope ? . let { collect <identifiersep> psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after ( modification <identifiersep> scope , in <identifiersep> statement ) } val prev <identifiersep> completion <identifiersep> data = prev <identifiersep> completion <identifiersep> data <identifiersep> cache . value . data when { prev <identifiersep> completion <identifiersep> data == null - > log ( <string_literal> ) block != prev <identifiersep> completion <identifiersep> data . block - > <LOG> prev <identifiersep> statement != prev <identifiersep> completion <identifiersep> data . prev <identifiersep> statement - > log ( <string_literal> ) psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > log ( <string_literal> ) prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > log ( <string_literal> ) <ect>
log ( <string_literal> ) block != prev <identifiersep> completion <identifiersep> data . block - > log ( <string_literal> ) prev <identifiersep> statement != prev <identifiersep> completion <identifiersep> data . prev <identifiersep> statement - > log ( <string_literal> ) psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > <LOG> prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > log ( <string_literal> ) in <identifiersep> statement . is <identifiersep> too <identifiersep> complex ( ) - > log ( <string_literal> ) else - > { log ( <string_literal> <string_literal> ) <ect>
log ( <string_literal> ) psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > log ( <string_literal> ) prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > log ( <string_literal> ) in <identifiersep> statement . is <identifiersep> too <identifiersep> complex ( ) - > <LOG> else - > { log ( <string_literal> <string_literal> ) log . debug ( <string_literal> ) <comment> <ect>
prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > log ( <string_literal> ) in <identifiersep> statement . is <identifiersep> too <identifiersep> complex ( ) - > log ( <string_literal> ) else - > { log ( <string_literal> <string_literal> ) <LOG> <comment> <ect>
descriptor <identifiersep> name = descriptor <identifiersep> name . substring ( <string_literal> . length ) . trim ( ) } val descriptors = file . resolve <identifiersep> import <identifiersep> reference ( fq <identifiersep> name ( descriptor <identifiersep> name ) ) . filter ( filter ) when { descriptors . is <identifiersep> empty ( ) - > error ( <string_literal> ) descriptors . size > 1 - > <LOG> else - > { val success = import <identifiersep> insert <identifiersep> helper . get <identifiersep> instance ( project ) . import <identifiersep> descriptor ( file , descriptors . single ( ) ) != import <identifiersep> descriptor <identifiersep> result . fail if ( ! success ) { val document = psi <identifiersep> document <identifiersep> manager . get <identifiersep> instance ( project ) . get <identifiersep> document ( file ) ! ! document . replace <identifiersep> string ( 0 , document . text <identifiersep> length , <string_literal> ) psi <identifiersep> document <identifiersep> manager . get <identifiersep> instance ( project ) . commit <identifiersep> all <identifiersep> documents ( ) <ect>
val str = it . trim ( ) default <identifiersep> environment [ str ] ? : str } } switches . for <identifiersep> each { if ( it in line ) { env [ it ] = true } } } if ( env [ use <identifiersep> default <identifiersep> template ] == true && default <identifiersep> environment [ <string_literal> ] != null ) { <LOG> } env . put <identifiersep> all ( default <identifiersep> environment ) return env } private fun default <identifiersep> environment ( path : string ) : map < string , file ? > { val template <identifiersep> out <identifiersep> dir = file ( <string_literal> ) . take <identifiersep> if { it . is <identifiersep> directory } ? . let { compile <identifiersep> lib <identifiersep> to <identifiersep> dir ( it , path <identifiersep> util . kotlin <identifiersep> paths <identifiersep> for <identifiersep> dist <identifiersep> directory . script <identifiersep> runtime <identifiersep> path . path ) } val lib <identifiersep> src <identifiersep> dir = file ( <string_literal> ) . take <identifiersep> if { it . is <identifiersep> directory } <ect>
no <identifiersep> laziness , no <identifiersep> consistency } class tracker ( private val fq <identifiersep> name : string ) : stub <identifiersep> computation <identifiersep> tracker { private var level = none set ( new <identifiersep> level ) { if ( new <identifiersep> level . ordinal < = field . ordinal ) { <LOG> } if ( new <identifiersep> level . ordinal > allowed <identifiersep> level . ordinal ) { error ( <string_literal> ) } field = new <identifiersep> level } private var allowed <identifiersep> level = none enum class level { none , <ect>
else if ( system <identifiersep> info . is <identifiersep> unix ) { val unix <identifiersep> out = file ( out <identifiersep> dir , my <identifiersep> test <identifiersep> name + <string_literal> ) if ( unix <identifiersep> out . exists ( ) ) { out <identifiersep> file = unix <identifiersep> out } } } if ( ! out <identifiersep> file . exists ( ) ) { file <identifiersep> util . write <identifiersep> to <identifiersep> file ( out <identifiersep> file , actual ) <LOG> } else { val original <identifiersep> text = file <identifiersep> util <identifiersep> rt . load <identifiersep> file ( out <identifiersep> file , charset <identifiersep> toolkit . utf8 ) val expected = string <identifiersep> util <identifiersep> rt . convert <identifiersep> line <identifiersep> separators ( original <identifiersep> text ) if ( expected != actual ) { println ( <string_literal> ) println ( original <identifiersep> text ) <ect>
throw <identifiersep> exceptions <identifiersep> if <identifiersep> any ( ) ; check <identifiersep> test <identifiersep> output ( ) ; } private boolean needs <identifiersep> restart ( ) { int restart = my <identifiersep> restart . get ( ) ; return restart > 0 && restart < = <number_literal> ; } private static void delete <identifiersep> local <identifiersep> cache <identifiersep> directory ( boolean assert <identifiersep> delete <identifiersep> success ) { <LOG> boolean delete <identifiersep> result = files <identifiersep> kt . delete <identifiersep> recursively ( local <identifiersep> cache <identifiersep> dir ) ; if ( assert <identifiersep> delete <identifiersep> success ) { assert . assert <identifiersep> true ( <string_literal> , delete <identifiersep> result ) ; } } private static long cached <identifiersep> data <identifiersep> time <identifiersep> stamp ( ) { file test <identifiersep> data <identifiersep> last <identifiersep> modified <identifiersep> file = jet <identifiersep> test <identifiersep> utils <identifiersep> kt . find <identifiersep> last <identifiersep> modified <identifiersep> file ( tiny <identifiersep> app <identifiersep> src , <ect>
val insert <identifiersep> after = imports . last <identifiersep> or <identifiersep> null { val directive <identifiersep> path = it . import <identifiersep> path directive <identifiersep> path != null && import <identifiersep> path <identifiersep> comparator . compare ( directive <identifiersep> path , import <identifiersep> path ) < = 0 } import <identifiersep> list . add <identifiersep> after ( new <identifiersep> directive , insert <identifiersep> after ) as kt <identifiersep> import <identifiersep> directive } } else { <LOG> } } } } <ect>
val unmodifiable <identifiersep> file = element . containing <identifiersep> file ? . virtual <identifiersep> file ? . presentable <identifiersep> url if ( unmodifiable <identifiersep> file != null ) { val message = refactoring <identifiersep> bundle . message ( <string_literal> ) + <string_literal> + ide <identifiersep> bundle . message ( <string_literal> , unmodifiable <identifiersep> file ) messages . show <identifiersep> error <identifiersep> dialog ( project , message , common <identifiersep> bundle . get <identifiersep> error <identifiersep> title ( ) ! ! ) } else { <LOG> } return false } protected abstract fun perform <identifiersep> refactoring ( descriptors <identifiersep> for <identifiersep> change : collection < callable <identifiersep> descriptor > ) fun run ( ) : boolean { fun button <identifiersep> pressed ( code : int , dialog <identifiersep> buttons : list < string > , button : string ) : boolean { return code == dialog <identifiersep> buttons . index <identifiersep> of ( button ) && button in dialog <identifiersep> buttons } fun perform <identifiersep> for <identifiersep> whole <identifiersep> hierarchy ( dialog <identifiersep> buttons : list < string > , code : int ) : boolean { <ect>
else if ( ! descriptor . with <identifiersep> default <identifiersep> value && parameter in parameters <identifiersep> to <identifiersep> remove ) {  <identifiersep> ranges <identifiersep> to <identifiersep> remove . add ( range ) } if ( i < parameters . last <identifiersep> index ) { builder . append ( <string_literal> ) } } builder . append ( <string_literal> ) if ( added <identifiersep> range == null ) { <LOG> } } text = builder . to <identifiersep> string ( ) } } private var descriptor = original <identifiersep> descriptor private var replace <identifiersep> all <identifiersep> check <identifiersep> box : j <identifiersep> check <identifiersep> box ? = null init { init <identifiersep> form <identifiersep> components { add <identifiersep> component ( preview <identifiersep> component ) <ect>
return kotlin <identifiersep> annotations <identifiersep> index . get <identifiersep> instance ( ) . get ( name , ann <identifiersep> class . project , scope ) } return ( use <identifiersep> scope as local <identifiersep> search <identifiersep> scope ) . scope . flat <identifiersep> map { it . collect <identifiersep> descendants <identifiersep> of <identifiersep> type < kt <identifiersep> annotation <identifiersep> entry > ( ) } } ) } private fun not <identifiersep> kt <identifiersep> annotation <identifiersep> entry ( found : psi <identifiersep> element ) : boolean { if ( found is kt <identifiersep> annotation <identifiersep> entry ) return false val faulty <identifiersep> container = psi <identifiersep> util <identifiersep> core . get <identifiersep> virtual <identifiersep> file ( found ) <LOG> if ( faulty <identifiersep> container != null && faulty <identifiersep> container . is <identifiersep> valid ) { file <identifiersep> based <identifiersep> index . get <identifiersep> instance ( ) . request <identifiersep> reindex ( faulty <identifiersep> container ) } return true } } } <ect>
val lhs = evaluate <identifiersep> add ( expr , numbers ) if ( expr . length > 0 ) { val < warning > c < / warning > = expr . get ( 0 ) expr . delete <identifiersep> char <identifiersep> at ( 0 ) } return lhs } fun main ( args : array < string > ) { <LOG> val numbers = array <identifiersep> list < int > ( <number_literal> ) val rnd = random ( ) ; val prompt = string <identifiersep> builder ( ) for ( i in 0 . . <number_literal> ) { val n = rnd . next <identifiersep> int ( <number_literal> ) + 1 numbers . add ( n ) <ect>
for ( i in 0 . . <number_literal> ) { val n = rnd . next <identifiersep> int ( <number_literal> ) + 1 numbers . add ( n ) if ( i > 0 ) prompt . append ( <string_literal> ) ; prompt . append ( n ) } system . out . println ( <string_literal> + prompt ) <LOG> val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) if ( result != <number_literal> ) system . out . println ( <string_literal> + result ) <ect>
val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) if ( result != <number_literal> ) system . out . println ( <string_literal> + result ) else <LOG> } catch ( e : throwable ) { system . out . println ( e . message ) } } <ect>
fun foo ( p : any ) { if ( p ! is string ) { <LOG> } println ( < caret > p . length ( ) ) <ect>
fun foo ( p : string ? , x : boolean , y : boolean , z : boolean , t : boolean ) { if ( p == null ) { if ( x ) { print ( <string_literal> ) <LOG> } else if ( y ) { print ( <string_literal> ) if ( z ) { print ( <string_literal> ) return } else { <ect>
class a { public < selection > void foo ( int p ) < / selection > { <LOG> } <ect>
val logger = logger ( ) fun log ( s : string ) { } } class < caret > foo { companion object : klogging ( ) fun baz ( ) { logger . debug { <string_literal> } <LOG> } <ect>
class logger { fun debug ( s : ( ) - > string ) { } } class < caret > foo { companion object : klogging ( ) fun baz ( ) { logger . debug { <string_literal> } <LOG> } <ect>
override val logger = logger ( ) override fun log ( s : string ) { } } class < caret > foo { companion object : i <identifiersep> logging by klogging ( ) fun baz ( ) { logger . debug { <string_literal> } <LOG> } <ect>
package test ; class b { void bar ( ) { <LOG> } <ect>
it . return <identifiersep> type . is <identifiersep> subtype <identifiersep> of ( type <identifiersep> member <identifiersep> template ) - > yield ( it . call ( this ) as member <identifiersep> template ) it . return <identifiersep> type . is <identifiersep> subtype <identifiersep> of ( type <identifiersep> iterable <identifiersep> of <identifiersep> member <identifiersep> templates ) - > @ suppress ( <string_literal> ) yield <identifiersep> all ( it . call ( this ) as iterable < member <identifiersep> template > ) else - > <LOG> } } } } . run { if ( default <identifiersep> actions . is <identifiersep> empty ( ) ) this else on <identifiersep> each { t - > default <identifiersep> actions . for <identifiersep> each ( t : : builder ) } } private val default <identifiersep> actions = mutable <identifiersep> list <identifiersep> of < member <identifiersep> build <identifiersep> action > ( ) fun default <identifiersep> builder ( builder <identifiersep> action : member <identifiersep> build <identifiersep> action ) { default <identifiersep> actions += builder <identifiersep> action } companion object { <ect>
public static void main ( int i ) { switch ( i ) { case a . use <identifiersep> kotlin <identifiersep> const <identifiersep> in <identifiersep> switch <identifiersep> kt . i : system . out . println ( <string_literal> ) ; break ; default : <LOG> break ; } } } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; <LOG> b b = new b ( ) ; b . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + b . get <identifiersep> foo ( ) ) ; } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; <LOG> b b = new b ( ) ; b . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + b . get <identifiersep> foo ( ) ) ; } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; <LOG> b b = new b ( ) ; b . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + b . get <identifiersep> foo ( ) ) ; } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a . companion . set <identifiersep> foo ( <string_literal> ) ; a . foo = <string_literal> ; <LOG> system . out . println ( <string_literal> + a . foo ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; <LOG> a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { x . foo ( <string_literal> ) ; system . out . println ( x . get <identifiersep> a ( ) + <string_literal> + x . get <identifiersep> b ( ) ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; <LOG> a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { x . foo ( <string_literal> ) ; system . out . println ( x . get <identifiersep> a ( ) + <string_literal> + x . get <identifiersep> b ( ) ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; <LOG> a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { x . foo ( <string_literal> ) ; system . out . println ( x . get <identifiersep> a ( ) + <string_literal> + x . get <identifiersep> b ( ) ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; <LOG> a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { x . foo ( <string_literal> ) ; system . out . println ( x . get <identifiersep> a ( ) + <string_literal> + x . get <identifiersep> b ( ) ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
rect <identifiersep> evaluator ( rect ) ; <comment> <LOG> rect <identifiersep> evaluator ( rect ) ; <comment> <ect>
toast . show ( ) } } runnable { toast . < warning descr = <string_literal> > make <identifiersep> text < / warning > ( context , <string_literal> , toast . length <identifiersep> long ) } } private fun show <identifiersep> toast ( context : context ) { <comment> <LOG> val temp = <number_literal> + <number_literal> toast . show ( ) } private fun show <identifiersep> toast2 ( context : context ) { <comment> <ect>
val javac <identifiersep> plugin = ensure <identifiersep> plugin <identifiersep> after ( add <identifiersep> plugin ( maven <identifiersep> id ( <string_literal> , <string_literal> , null ) ) , kotlin <identifiersep> plugin ) val project : maven <identifiersep> project = maven <identifiersep> projects <identifiersep> manager . get <identifiersep> instance ( module . project ) . find <identifiersep> project ( module ) ? : run { if ( application <identifiersep> manager . get <identifiersep> application ( ) . is <identifiersep> unit <identifiersep> test <identifiersep> mode ) { log . warn ( <string_literal> ) return } <LOG> } val plugin = project . find <identifiersep> plugin ( <string_literal> , <string_literal> ) if ( is <identifiersep> execution <identifiersep> enabled ( plugin , <string_literal> ) ) { add <identifiersep> execution ( javac <identifiersep> plugin , <string_literal> , <string_literal> , empty <identifiersep> list ( ) ) } if ( is <identifiersep> execution <identifiersep> enabled ( plugin , <string_literal> ) ) { add <identifiersep> execution ( javac <identifiersep> plugin , <string_literal> , <string_literal> , empty <identifiersep> list ( ) ) } if ( is <identifiersep> plugin <identifiersep> execution <identifiersep> missing ( plugin , <string_literal> , <string_literal> ) ) { <ect>
protected void run ( ) throws throwable { virtual <identifiersep> file f = local <identifiersep> file <identifiersep> system . get <identifiersep> instance ( ) . refresh <identifiersep> and <identifiersep> find <identifiersep> file <identifiersep> by <identifiersep> io <identifiersep> file ( new file ( my <identifiersep> dir , <string_literal> ) ) ; if ( f != null ) f . delete ( this ) ; } } . execute ( ) . throw <identifiersep> exception ( ) ; } private static string create <identifiersep> settings <identifiersep> xml <identifiersep> content ( string content ) { if ( ! mirror <identifiersep> discoverable ) { <LOG> return <string_literal> + content + <string_literal> ; } system . out . println ( <string_literal> + maven <identifiersep> mirror <identifiersep> url ) ; return <string_literal> + content + <ect>
my <identifiersep> projects <identifiersep> manager . wait <identifiersep> for <identifiersep> resolving <identifiersep> completion ( ) ; my <identifiersep> projects <identifiersep> manager . schedule <identifiersep> import <identifiersep> in <identifiersep> tests ( files ) ; my <identifiersep> projects <identifiersep> manager . import <identifiersep> projects ( ) ; } } ) ; for ( maven <identifiersep> project each : my <identifiersep> projects <identifiersep> tree . get <identifiersep> projects ( ) ) { if ( each . has <identifiersep> reading <identifiersep> problems ( ) ) { <LOG> } } } protected void read <identifiersep> projects ( list < virtual <identifiersep> file > files , string . . . profiles ) { my <identifiersep> projects <identifiersep> manager . reset <identifiersep> managed <identifiersep> files <identifiersep> and <identifiersep> profiles <identifiersep> in <identifiersep> tests ( files , new maven <identifiersep> explicit <identifiersep> profiles ( arrays . as <identifiersep> list ( profiles ) ) ) ; wait <identifiersep> for <identifiersep> reading <identifiersep> completion ( ) ; } protected void update <identifiersep> projects <identifiersep> and <identifiersep> import ( virtual <identifiersep> file . . . files ) { read <identifiersep> projects ( files ) ; my <identifiersep> projects <identifiersep> manager . perform <identifiersep> scheduled <identifiersep> import <identifiersep> in <identifiersep> tests ( ) ; <ect>
new import <identifiersep> spec <identifiersep> builder ( my <identifiersep> project , get <identifiersep> external <identifiersep> system <identifiersep> id ( ) ) . use ( progress <identifiersep> execution <identifiersep> mode . modal <identifiersep> sync ) . callback ( new external <identifiersep> project <identifiersep> refresh <identifiersep> callback ( ) { @ override public void on <identifiersep> success ( @ nullable data <identifiersep> node < project <identifiersep> data > external <identifiersep> project ) { if ( external <identifiersep> project == null ) { <LOG> return ; } service <identifiersep> manager . get <identifiersep> service ( project <identifiersep> data <identifiersep> manager . class ) . import <identifiersep> data ( external <identifiersep> project , my <identifiersep> project , true ) ; system . out . println ( <string_literal> ) ; } @ override public void on <identifiersep> failure ( @ not <identifiersep> null string error <identifiersep> message , @ nullable string error <identifiersep> details ) { error . set ( couple . of ( error <identifiersep> message , error <identifiersep> details ) ) ; <ect>
public void run ( ) throws throwable { compiler <identifiersep> test <identifiersep> util . disable <identifiersep> external <identifiersep> compiler ( my <identifiersep> project ) ; tear <identifiersep> down <identifiersep> fixtures ( ) ; } } ) ; my <identifiersep> project = null ; if ( ! file <identifiersep> util . delete ( my <identifiersep> test <identifiersep> dir ) && my <identifiersep> test <identifiersep> dir . exists ( ) ) { <LOG> <comment> <ect>
if ( field . type == persistent <identifiersep> library <identifiersep> kind : : class . java ) { field . is <identifiersep> accessible = true field . set ( modifiable <identifiersep> model , null ) return } } log . info ( <string_literal> ) } catch ( e : exception ) { <LOG> } } companion object { val log = logger . get <identifiersep> instance ( kotlin <identifiersep> gradle <identifiersep> library <identifiersep> data <identifiersep> service : : class . java ) val non <identifiersep> jvm <identifiersep> suffixes = list <identifiersep> of ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) } } fun detect <identifiersep> platform <identifiersep> by <identifiersep> plugin ( module <identifiersep> node : data <identifiersep> node < module <identifiersep> data > ) : target <identifiersep> platform <identifiersep> kind < * > ? { return when ( module <identifiersep> node . platform <identifiersep> plugin <identifiersep> id ) { <string_literal> - > target <identifiersep> platform <identifiersep> kind . jvm [ jvm <identifiersep> target . jvm <identifiersep> 1 <identifiersep> <number_literal> ] <ect>
if ( parent <identifiersep> file . mkdirs ( ) ) { system . out . println ( <string_literal> + parent <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } else { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + parent <identifiersep> file ) ; } } if ( check <identifiersep> file <identifiersep> ignoring <identifiersep> line <identifiersep> separators ( file , new <identifiersep> text ) ) { if ( log <identifiersep> not <identifiersep> changed ) { <LOG> } return ; } boolean use <identifiersep> temp <identifiersep> file = ! system <identifiersep> info . is <identifiersep> windows ; file temp <identifiersep> file = use <identifiersep> temp <identifiersep> file ? new file ( kotlin <identifiersep> test <identifiersep> utils . tmp <identifiersep> dir ( file . get <identifiersep> name ( ) ) , file . get <identifiersep> name ( ) + <string_literal> ) : file ; files <identifiersep> kt . write <identifiersep> text ( temp <identifiersep> file , new <identifiersep> text , charsets . utf <identifiersep> <number_literal> ) ; system . out . println ( <string_literal> + temp <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; if ( use <identifiersep> temp <identifiersep> file ) { <ect>
boolean use <identifiersep> temp <identifiersep> file = ! system <identifiersep> info . is <identifiersep> windows ; file temp <identifiersep> file = use <identifiersep> temp <identifiersep> file ? new file ( kotlin <identifiersep> test <identifiersep> utils . tmp <identifiersep> dir ( file . get <identifiersep> name ( ) ) , file . get <identifiersep> name ( ) + <string_literal> ) : file ; files <identifiersep> kt . write <identifiersep> text ( temp <identifiersep> file , new <identifiersep> text , charsets . utf <identifiersep> <number_literal> ) ; system . out . println ( <string_literal> + temp <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; if ( use <identifiersep> temp <identifiersep> file ) { files . move ( temp <identifiersep> file . to <identifiersep> path ( ) , file . to <identifiersep> path ( ) , replace <identifiersep> existing ) ; <LOG> } system . out . println ( ) ; } private static boolean check <identifiersep> file <identifiersep> ignoring <identifiersep> line <identifiersep> separators ( file file , string content ) { string current <identifiersep> content ; try { current <identifiersep> content = string <identifiersep> util . convert <identifiersep> line <identifiersep> separators ( files <identifiersep> kt . read <identifiersep> text ( file , charsets . utf <identifiersep> <number_literal> ) ) ; } catch ( throwable ignored ) { <ect>
target <identifiersep> jar . close ( ) ; source <identifiersep> jar . close ( ) ; if ( assert <identifiersep> all <identifiersep> found ) { set < string > not <identifiersep> found = new hash <identifiersep> set < > ( entry <identifiersep> names <identifiersep> to <identifiersep> include ) ; not <identifiersep> found . remove <identifiersep> all ( found <identifiersep> entries ) ; if ( ! not <identifiersep> found . is <identifiersep> empty ( ) ) { <LOG> for ( string entry : not <identifiersep> found ) { system . err . println ( entry ) ; } throw new assertion <identifiersep> error ( <string_literal> ) ; } } } private static set < string > get <identifiersep> source <identifiersep> file <identifiersep> entries ( ) { set < string > entry <identifiersep> set = new hash <identifiersep> set < > ( ) ; for ( string entry : entries ) { <ect>
system . out . println ( <string_literal> ) ; super . rebuild <identifiersep> all <identifiersep> modules ( ) ; system . out . println ( <string_literal> ) ; } @ not <identifiersep> null @ override protected build <identifiersep> result build <identifiersep> all <identifiersep> modules ( ) { <LOG> build <identifiersep> result result = super . build <identifiersep> all <identifiersep> modules ( ) ; system . out . println ( <string_literal> ) ; return result ; } private void init <identifiersep> project ( ) { add <identifiersep> jdk ( jdk <identifiersep> name ) ; load <identifiersep> project ( work <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; <ect>
source <identifiersep> files : collection < file > , source <identifiersep> roots : collection < file > , libraries : list < string > , friend <identifiersep> modules : list < string > , output <identifiersep> file : file ) { <LOG> log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( k2js <identifiersep> arguments ) ) val arguments = merge <identifiersep> beans ( common <identifiersep> arguments , xml <identifiersep> serializer <identifiersep> util . create <identifiersep> copy ( k2js <identifiersep> arguments ) ) log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( arguments ) ) setup <identifiersep> k2js <identifiersep> arguments ( output <identifiersep> file , source <identifiersep> files , libraries , friend <identifiersep> modules , arguments ) if ( arguments . source <identifiersep> map ) { arguments . source <identifiersep> map <identifiersep> base <identifiersep> dirs = source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( file . path <identifiersep> separator ) { it . path } <ect>
friend <identifiersep> modules : list < string > , output <identifiersep> file : file ) { log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( common <identifiersep> arguments ) ) log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( k2js <identifiersep> arguments ) ) val arguments = merge <identifiersep> beans ( common <identifiersep> arguments , xml <identifiersep> serializer <identifiersep> util . create <identifiersep> copy ( k2js <identifiersep> arguments ) ) <LOG> setup <identifiersep> k2js <identifiersep> arguments ( output <identifiersep> file , source <identifiersep> files , libraries , friend <identifiersep> modules , arguments ) if ( arguments . source <identifiersep> map ) { arguments . source <identifiersep> map <identifiersep> base <identifiersep> dirs = source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( file . path <identifiersep> separator ) { it . path } } log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( arguments ) ) with <identifiersep> compiler <identifiersep> settings ( compiler <identifiersep> settings ) { run <identifiersep> compiler ( k2js <identifiersep> compiler , arguments , environment ) <ect>
run <identifiersep> compiler ( k2js <identifiersep> compiler , arguments , environment ) } } override fun compile <identifiersep> with <identifiersep> daemon <identifiersep> or <identifiersep> fallback ( compiler <identifiersep> class <identifiersep> name : string , compiler <identifiersep> args : common <identifiersep> compiler <identifiersep> arguments , environment : jps <identifiersep> compiler <identifiersep> environment ) : exit <identifiersep> code { <LOG> return if ( is <identifiersep> daemon <identifiersep> enabled ( ) ) { val daemon <identifiersep> exit <identifiersep> code = compile <identifiersep> with <identifiersep> daemon ( compiler <identifiersep> class <identifiersep> name , compiler <identifiersep> args , environment ) daemon <identifiersep> exit <identifiersep> code ? : fallback <identifiersep> compile <identifiersep> strategy ( compiler <identifiersep> args , compiler <identifiersep> class <identifiersep> name , environment ) } else { fallback <identifiersep> compile <identifiersep> strategy ( compiler <identifiersep> args , compiler <identifiersep> class <identifiersep> name , environment ) } } override fun compile <identifiersep> with <identifiersep> daemon ( <ect>
k2js <identifiersep> compiler - > compile <identifiersep> service . target <identifiersep> platform . js k2metadata <identifiersep> compiler - > compile <identifiersep> service . target <identifiersep> platform . metadata else - > throw illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) } log . debug ( <string_literal> ) val connection = get <identifiersep> daemon <identifiersep> connection ( environment ) if ( connection == null ) { <LOG> return null } val ( daemon , session <identifiersep> id ) = connection val compiler <identifiersep> mode = compiler <identifiersep> mode . jps <identifiersep> compiler val verbose = compiler <identifiersep> args . verbose val options = compilation <identifiersep> options ( compiler <identifiersep> mode , target <identifiersep> platform , report <identifiersep> categories ( verbose ) , report <identifiersep> severity ( verbose ) , requested <identifiersep> compilation <identifiersep> results = empty <identifiersep> array ( ) ) val res = daemon . compile ( session <identifiersep> id , with <identifiersep> additional <identifiersep> compiler <identifiersep> args ( compiler <identifiersep> args ) , options , jps <identifiersep> compiler <identifiersep> services <identifiersep> facade <identifiersep> impl ( environment ) , null ) <ect>
compiler <identifiersep> class <identifiersep> name : string , environment : jps <identifiersep> compiler <identifiersep> environment ) : exit <identifiersep> code { if ( <string_literal> == system . get <identifiersep> property ( <string_literal> ) && <string_literal> == system . get <identifiersep> property ( fail <identifiersep> on <identifiersep> fallback <identifiersep> property ) ) { error ( <string_literal> ) } <comment> <LOG> val stream = byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) val out = print <identifiersep> stream ( stream ) <comment> <ect>
|| class <identifiersep> name == <string_literal> || class <identifiersep> name == <string_literal> } } private val statistics <identifiersep> logger = teamcity <identifiersep> statistics <identifiersep> logger ( ) override fun get <identifiersep> presentable <identifiersep> name ( ) = kotlin <identifiersep> builder <identifiersep> name override fun get <identifiersep> compilable <identifiersep> file <identifiersep> extensions ( ) = array <identifiersep> list <identifiersep> of ( <string_literal> ) override fun build <identifiersep> started ( context : compile <identifiersep> context ) { <LOG> log . info ( <string_literal> ) log . info ( <string_literal> ) val history <identifiersep> label = context . get <identifiersep> builder <identifiersep> parameter ( <string_literal> ) if ( history <identifiersep> label != null ) { log . info ( <string_literal> ) } } override fun build <identifiersep> finished ( context : compile <identifiersep> context ? ) { <ect>
private val statistics <identifiersep> logger = teamcity <identifiersep> statistics <identifiersep> logger ( ) override fun get <identifiersep> presentable <identifiersep> name ( ) = kotlin <identifiersep> builder <identifiersep> name override fun get <identifiersep> compilable <identifiersep> file <identifiersep> extensions ( ) = array <identifiersep> list <identifiersep> of ( <string_literal> ) override fun build <identifiersep> started ( context : compile <identifiersep> context ) { log . debug ( <string_literal> ) log . info ( <string_literal> ) <LOG> val history <identifiersep> label = context . get <identifiersep> builder <identifiersep> parameter ( <string_literal> ) if ( history <identifiersep> label != null ) { log . info ( <string_literal> ) } } override fun build <identifiersep> finished ( context : compile <identifiersep> context ? ) { statistics <identifiersep> logger . report <identifiersep> total ( ) } override fun chunk <identifiersep> build <identifiersep> started ( context : compile <identifiersep> context , chunk : module <identifiersep> chunk ) { <ect>
val file = jvm <identifiersep> build <identifiersep> meta <identifiersep> info <identifiersep> file ( target , data <identifiersep> manager ) if ( ! file . exists ( ) ) continue val last <identifiersep> build <identifiersep> meta <identifiersep> info = try { jvm <identifiersep> build <identifiersep> meta <identifiersep> info . deserialize <identifiersep> from <identifiersep> string ( file . read <identifiersep> text ( ) ) ? : continue } catch ( e : exception ) { <LOG> continue } val last <identifiersep> build <identifiersep> lang <identifiersep> version = language <identifiersep> version . from <identifiersep> version <identifiersep> string ( last <identifiersep> build <identifiersep> meta <identifiersep> info . language <identifiersep> version <identifiersep> string ) val last <identifiersep> build <identifiersep> api <identifiersep> version = api <identifiersep> version . parse ( last <identifiersep> build <identifiersep> meta <identifiersep> info . api <identifiersep> version <identifiersep> string ) val current <identifiersep> lang <identifiersep> version = args . language <identifiersep> version ? . let { language <identifiersep> version . from <identifiersep> version <identifiersep> string ( it ) } ? : language <identifiersep> version . latest <identifiersep> stable val current <identifiersep> api <identifiersep> version = args . api <identifiersep> version ? . let { api <identifiersep> version . parse ( it ) } ? : api <identifiersep> version . create <identifiersep> by <identifiersep> language <identifiersep> version ( current <identifiersep> lang <identifiersep> version ) val reason <identifiersep> to <identifiersep> rebuild = when { <ect>
log . info ( <string_literal> ) actions . add ( cache <identifiersep> version . action . rebuild <identifiersep> all <identifiersep> kotlin ) } } } return actions } override fun chunk <identifiersep> build <identifiersep> finished ( context : compile <identifiersep> context , chunk : module <identifiersep> chunk ) { super . chunk <identifiersep> build <identifiersep> finished ( context , chunk ) if ( chunk . is <identifiersep> dummy ( context ) ) return <LOG> } override fun build ( context : compile <identifiersep> context , chunk : module <identifiersep> chunk , dirty <identifiersep> files <identifiersep> holder : dirty <identifiersep> files <identifiersep> holder < java <identifiersep> source <identifiersep> root <identifiersep> descriptor , module <identifiersep> build <identifiersep> target > , output <identifiersep> consumer : module <identifiersep> level <identifiersep> builder . output <identifiersep> consumer ) : module <identifiersep> level <identifiersep> builder . exit <identifiersep> code { <ect>
val proposed <identifiersep> exit <identifiersep> code = do <identifiersep> build ( chunk , context , dirty <identifiersep> files <identifiersep> holder , message <identifiersep> collector , output <identifiersep> consumer , fs <identifiersep> operations ) val actual <identifiersep> exit <identifiersep> code = if ( proposed <identifiersep> exit <identifiersep> code == ok && fs <identifiersep> operations . has <identifiersep> marked <identifiersep> dirty ) additional <identifiersep> pass <identifiersep> required else proposed <identifiersep> exit <identifiersep> code log . debug ( <string_literal> + actual <identifiersep> exit <identifiersep> code ) context . testing <identifiersep> context ? . build <identifiersep> logger ? . build <identifiersep> finished ( actual <identifiersep> exit <identifiersep> code ) return actual <identifiersep> exit <identifiersep> code } catch ( e : stop <identifiersep> build <identifiersep> exception ) { <LOG> throw e } catch ( e : throwable ) { log . info ( <string_literal> + e ) message <identifiersep> collector <identifiersep> util . report <identifiersep> exception ( message <identifiersep> collector , e ) return abort } } private fun do <identifiersep> build ( <ect>
val environment = create <identifiersep> compile <identifiersep> environment ( incremental <identifiersep> caches , lookup <identifiersep> tracker , context , message <identifiersep> collector ) ? : return abort val common <identifiersep> arguments = compiler <identifiersep> arguments <identifiersep> for <identifiersep> chunk ( chunk ) . apply { report <identifiersep> output <identifiersep> files = true version = true <comment> <LOG> val start = system . nano <identifiersep> time ( ) val output <identifiersep> item <identifiersep> collector = do <identifiersep> compile <identifiersep> module <identifiersep> chunk ( all <identifiersep> compiled <identifiersep> files , chunk , common <identifiersep> arguments , context , dirty <identifiersep> files <identifiersep> holder , environment , files <identifiersep> to <identifiersep> compile , incremental <identifiersep> caches , project ) statistics <identifiersep> logger . register <identifiersep> statistic ( chunk , system . nano <identifiersep> time ( ) - start ) if ( output <identifiersep> item <identifiersep> collector == null ) { return nothing <identifiersep> done <ect>
return nothing <identifiersep> done } val compilation <identifiersep> errors = utils . errors <identifiersep> detected <identifiersep> key [ context , false ] if ( compilation <identifiersep> errors ) { log . info ( <string_literal> ) return abort } else { <LOG> } val generated <identifiersep> files = get <identifiersep> generated <identifiersep> files ( chunk , environment . output <identifiersep> items <identifiersep> collector ) register <identifiersep> output <identifiersep> items ( output <identifiersep> consumer , generated <identifiersep> files ) save <identifiersep> versions ( context , chunk , common <identifiersep> arguments ) if ( targets . any { has <identifiersep> kotlin [ it ] == null } ) { fs <identifiersep> operations . mark <identifiersep> chunk ( recursively = false , kotlin <identifiersep> only = true , exclude <identifiersep> files = files <identifiersep> to <identifiersep> compile . values ( ) . to <identifiersep> set ( ) ) } for ( target in targets ) { <ect>
data <identifiersep> manager . get <identifiersep> kotlin <identifiersep> cache ( target ) . clean ( ) has <identifiersep> kotlin . clean ( target ) rebuild <identifiersep> after <identifiersep> cache <identifiersep> version <identifiersep> changed [ target ] = true } fs <identifiersep> operations . mark <identifiersep> chunk ( recursively = false , kotlin <identifiersep> only = true ) return } cache <identifiersep> version . action . clean <identifiersep> normal <identifiersep> caches - > { <LOG> for ( target in context . all <identifiersep> targets ( ) ) { data <identifiersep> manager . get <identifiersep> kotlin <identifiersep> cache ( target ) . clean ( ) } } cache <identifiersep> version . action . clean <identifiersep> data <identifiersep> container - > { log . info ( <string_literal> ) data <identifiersep> manager . clean <identifiersep> lookup <identifiersep> storage ( log ) cache <identifiersep> versions <identifiersep> provider . data <identifiersep> container <identifiersep> version ( ) . clean ( ) <ect>
cache <identifiersep> versions <identifiersep> provider . data <identifiersep> container <identifiersep> version ( ) . clean ( ) } else - > { assert ( status == cache <identifiersep> version . action . do <identifiersep> nothing ) { <string_literal> } } } } } private fun compile <identifiersep> context . all <identifiersep> targets ( ) = project <identifiersep> descriptor . build <identifiersep> target <identifiersep> index . all <identifiersep> targets . filter <identifiersep> is <identifiersep> instance <identifiersep> to < module <identifiersep> build <identifiersep> target , mutable <identifiersep> set < module <identifiersep> build <identifiersep> target > > ( hash <identifiersep> set ( ) ) private fun mark <identifiersep> all <identifiersep> kotlin <identifiersep> for <identifiersep> rebuild ( context : compile <identifiersep> context , fs <identifiersep> operations : fs <identifiersep> operations <identifiersep> helper , reason : string ) { <LOG> val project = context . project <identifiersep> descriptor . project val source <identifiersep> roots = project . modules . flat <identifiersep> map { it . source <identifiersep> roots } val data <identifiersep> manager = context . project <identifiersep> descriptor . data <identifiersep> manager val rebuild <identifiersep> after <identifiersep> cache <identifiersep> version <identifiersep> changed = rebuild <identifiersep> after <identifiersep> cache <identifiersep> version <identifiersep> change <identifiersep> marker ( data <identifiersep> manager ) for ( source <identifiersep> root in source <identifiersep> roots ) { val kt <identifiersep> files = source <identifiersep> root . file . walk ( ) . filter { kotlin <identifiersep> source <identifiersep> file <identifiersep> collector . is <identifiersep> kotlin <identifiersep> source <identifiersep> file ( it ) } <ect>
argument <identifiersep> provider . get <identifiersep> extra <identifiersep> arguments ( representative <identifiersep> target , context ) ) <comment> <LOG> return compile <identifiersep> to <identifiersep> js ( chunk , common <identifiersep> arguments , environment , project ) } if ( incremental <identifiersep> compilation . is <identifiersep> enabled ( ) ) { for ( target in chunk . targets ) { val cache = incremental <identifiersep> caches [ target ] ! ! val removed <identifiersep> and <identifiersep> dirty <identifiersep> files = files <identifiersep> to <identifiersep> compile [ target ] + dirty <identifiersep> files <identifiersep> holder . get <identifiersep> removed <identifiersep> files ( target ) . map ( : : file ) cache . mark <identifiersep> dirty ( removed <identifiersep> and <identifiersep> dirty <identifiersep> files ) <ect>
return collections . empty <identifiersep> list ( ) ; } @ override @ non <identifiersep> null public string read <identifiersep> file ( @ non <identifiersep> null final file file ) { final virtual <identifiersep> file v <identifiersep> file = local <identifiersep> file <identifiersep> system . get <identifiersep> instance ( ) . find <identifiersep> file <identifiersep> by <identifiersep> io <identifiersep> file ( file ) ; if ( v <identifiersep> file == null ) { <LOG> return <string_literal> ; } return application <identifiersep> manager . get <identifiersep> application ( ) . run <identifiersep> read <identifiersep> action ( new computable < string > ( ) { @ nullable @ override public string compute ( ) { final psi <identifiersep> file psi <identifiersep> file = psi <identifiersep> manager . get <identifiersep> instance ( my <identifiersep> project ) . find <identifiersep> file ( v <identifiersep> file ) ; <ect>
public string read <identifiersep> file ( @ non <identifiersep> null file file ) { final virtual <identifiersep> file v <identifiersep> file = local <identifiersep> file <identifiersep> system . get <identifiersep> instance ( ) . find <identifiersep> file <identifiersep> by <identifiersep> io <identifiersep> file ( file ) ; if ( v <identifiersep> file == null ) { try { return files . to <identifiersep> string ( file , charsets . utf <identifiersep> <number_literal> ) ; } catch ( io <identifiersep> exception ioe ) { <LOG> return <string_literal> ; } } final string content = get <identifiersep> file <identifiersep> content ( v <identifiersep> file ) ; if ( content == null ) { log . info ( <string_literal> + file . get <identifiersep> path ( ) + <string_literal> ) ; return <string_literal> ; } return content ; <ect>
return highlight <identifiersep> display <identifiersep> level . warning ; case informational : return highlight <identifiersep> display <identifiersep> level . weak <identifiersep> warning ; case ignore : return null ; default : <LOG> return null ; } } <comment> private static boolean is <identifiersep> single <identifiersep> file <identifiersep> scope ( enum <identifiersep> set < scope > scopes ) { if ( scopes . size ( ) != 1 ) { return false ; } final scope scope = scopes . iterator ( ) . next ( ) ; <ect>
lines = files . read <identifiersep> lines ( xml <identifiersep> file , charsets . utf <identifiersep> <number_literal> ) ; } catch ( io <identifiersep> exception e ) { client . log ( e , <string_literal> ) ; return false ; } if ( write <identifiersep> stats ) { long end = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> } try { write <identifiersep> database ( binary <identifiersep> data , lines ) ; return true ; } catch ( io <identifiersep> exception ioe ) { client . log ( ioe , <string_literal> ) ; } return false ; <ect>
buffer . put ( ( byte ) 0 ) ; next <identifiersep> entry = buffer . position ( ) ; } int size = buffer . position ( ) ; assert size < = buffer . limit ( ) ; buffer . mark ( ) ; if ( write <identifiersep> stats ) { <LOG> system . out . print ( <string_literal> + size + <string_literal> ) ; system . out . println ( string . format ( <string_literal> , size / ( <number_literal> * <number_literal> . f ) ) ) ; system . out . println ( <string_literal> + ( entry <identifiersep> count * bytes <identifiersep> per <identifiersep> entry ) + <string_literal> ) ; system . out . println ( <string_literal> + ( size / entry <identifiersep> count ) + <string_literal> ) ; } <comment> <ect>
assert size < = buffer . limit ( ) ; buffer . mark ( ) ; if ( write <identifiersep> stats ) { system . out . println ( <string_literal> + words . size ( ) + <string_literal> ) ; system . out . print ( <string_literal> + size + <string_literal> ) ; system . out . println ( string . format ( <string_literal> , size / ( <number_literal> * <number_literal> . f ) ) ) ; <LOG> system . out . println ( <string_literal> + ( size / entry <identifiersep> count ) + <string_literal> ) ; } <comment> <ect>
int middle = ( low + high ) > > > 1 ; int offset = m <identifiersep> indices [ middle ] ; if ( debug <identifiersep> search ) { string s = new string ( arrays . copy <identifiersep> of <identifiersep> range ( utf8text , begin , end ) , charsets . utf <identifiersep> <number_literal> ) ; system . out . println ( <string_literal> + s + <string_literal> + offset + <string_literal> + dump <identifiersep> entry ( offset ) ) ; <LOG> } <comment> <ect>
long begin = 0 ; if ( write <identifiersep> stats ) { begin = system . current <identifiersep> time <identifiersep> millis ( ) ; } api info = api . parse <identifiersep> api ( xml <identifiersep> file ) ; if ( write <identifiersep> stats ) { long end = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> } if ( info != null ) { try { write <identifiersep> database ( binary <identifiersep> data , info ) ; return true ; } catch ( io <identifiersep> exception ioe ) { client . log ( ioe , <string_literal> ) ; <ect>
int estimated <identifiersep> size = 0 ; for ( api <identifiersep> package pkg : packages ) { estimated <identifiersep> size += <number_literal> ; <comment> <LOG> } for ( api <identifiersep> class api <identifiersep> class : pkg . get <identifiersep> classes ( ) ) { estimated <identifiersep> size += <number_literal> ; <comment> <ect>
<comment> <LOG> + <string_literal> + offset + <string_literal> + dump <identifiersep> entry ( offset ) ) ; } int compare = compare ( m <identifiersep> data , offset , ( byte ) 0 , owner , 0 , class <identifiersep> name <identifiersep> length ) ; if ( compare == 0 ) { if ( debug <identifiersep> search ) { system . out . println ( <string_literal> + dump <identifiersep> entry ( offset ) ) ; } return middle ; <ect>
int class <identifiersep> name <identifiersep> length = owner . length ( ) ; while ( low < = high ) { int middle = ( low + high ) > > > 1 ; int offset = m <identifiersep> indices [ middle ] ; offset ++ ; <comment> <LOG> + <string_literal> + offset + <string_literal> + dump <identifiersep> entry ( offset ) ) ; } int compare = compare ( m <identifiersep> data , offset , ( byte ) 0 , owner , index + 1 , class <identifiersep> name <identifiersep> length ) ; if ( compare == 0 ) { if ( debug <identifiersep> search ) { system . out . println ( <string_literal> + dump <identifiersep> entry ( offset ) ) ; } return middle ; <ect>
return - 1 ; } int high = low + length - 1 ; while ( low < = high ) { int middle = ( low + high ) > > > 1 ; int offset = m <identifiersep> indices [ middle ] ; if ( debug <identifiersep> search ) { <LOG> <string_literal> + offset + <string_literal> + dump <identifiersep> entry ( offset ) ) ; } int compare ; if ( desc != null ) { <comment> <ect>
if ( clz != null ) { integer super <identifiersep> since = clz . get <identifiersep> field ( field , info ) ; if ( super <identifiersep> since == integer . max <identifiersep> value ) { continue ; } if ( super <identifiersep> since != null && super <identifiersep> since > since ) { string declared <identifiersep> in = clz . find <identifiersep> field <identifiersep> declaration ( info , field ) ; <LOG> + since + <string_literal> + declared <identifiersep> in + <string_literal> + super <identifiersep> since ) ; continue field <identifiersep> loop ; } } } <comment> <ect>
for ( ( key , value ) in javac <identifiersep> options ) { if ( value . is <identifiersep> not <identifiersep> empty ( ) ) { options . put ( key , value ) } else { options . put ( key , key ) } } if ( logger . is <identifiersep> verbose ) { <LOG> } file <identifiersep> manager = context . get ( java <identifiersep> file <identifiersep> manager : : class . java ) as javac <identifiersep> file <identifiersep> manager compiler = java <identifiersep> compiler . instance ( context ) as kapt <identifiersep> java <identifiersep> compiler compiler . keep <identifiersep> comments = true class <identifiersep> reader . instance ( context ) . save <identifiersep> parameter <identifiersep> names = true java <identifiersep> log = compiler . log as kapt <identifiersep> java <identifiersep> log } override fun close ( ) { <ect>
sources <identifiersep> output <identifiersep> dir == null - > <string_literal> class <identifiersep> files <identifiersep> output <identifiersep> dir == null - > <string_literal> stubs <identifiersep> output <identifiersep> dir == null - > <string_literal> else - > throw illegal <identifiersep> state <identifiersep> exception ( ) } val module <identifiersep> name = configuration . get ( common <identifiersep> configuration <identifiersep> keys . module <identifiersep> name ) ? : configuration . get ( jvm <identifiersep> configuration <identifiersep> keys . modules ) . or <identifiersep> empty ( ) . join <identifiersep> to <identifiersep> string ( ) <LOG> analysis <identifiersep> handler <identifiersep> extension . register <identifiersep> extension ( project , abort <identifiersep> analysis <identifiersep> handler <identifiersep> extension ( ) ) } return } val ap <identifiersep> options = configuration . get ( apt <identifiersep> options ) ? . let { decode <identifiersep> list ( it ) } ? : empty <identifiersep> map ( ) val javac <identifiersep> cli <identifiersep> options = configuration . get ( javac <identifiersep> cli <identifiersep> options ) ? . let { decode <identifiersep> list ( it ) } ? : empty <identifiersep> map ( ) sources <identifiersep> output <identifiersep> dir . mkdirs ( ) val content <identifiersep> roots = configuration [ jvm <identifiersep> configuration <identifiersep> keys . content <identifiersep> roots ] ? : empty <identifiersep> list ( ) <ect>
val java <identifiersep> source <identifiersep> roots = content <identifiersep> roots . filter <identifiersep> is <identifiersep> instance < java <identifiersep> source <identifiersep> root > ( ) . map { it . file } val use <identifiersep> light <identifiersep> analysis = configuration . get ( kapt3configuration <identifiersep> keys . use <identifiersep> light <identifiersep> analysis ) == <string_literal> val correct <identifiersep> error <identifiersep> types = configuration . get ( kapt3configuration <identifiersep> keys . correct <identifiersep> error <identifiersep> types ) == <string_literal> val map <identifiersep> diagnostic <identifiersep> locations = configuration . get ( kapt3configuration <identifiersep> keys . map <identifiersep> diagnostic <identifiersep> locations ) == <string_literal> if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) <LOG> logger . info ( <string_literal> + java <identifiersep> source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> ) } val kapt3analysis <identifiersep> completed <identifiersep> handler <identifiersep> extension = classpath <identifiersep> based <identifiersep> kapt3extension ( compile <identifiersep> classpath , ap <identifiersep> classpath , java <identifiersep> source <identifiersep> roots , sources <identifiersep> output <identifiersep> dir , class <identifiersep> files <identifiersep> output <identifiersep> dir , stubs <identifiersep> output <identifiersep> dir , incremental <identifiersep> data <identifiersep> output <identifiersep> dir , ap <identifiersep> options , javac <identifiersep> cli <identifiersep> options , annotation <identifiersep> processors , apt <identifiersep> mode , use <identifiersep> light <identifiersep> analysis , correct <identifiersep> error <identifiersep> types , map <identifiersep> diagnostic <identifiersep> locations , system . current <identifiersep> time <identifiersep> millis ( ) , logger , configuration ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) logger . info ( <string_literal> + java <identifiersep> source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( ) ) <LOG> } val kapt3analysis <identifiersep> completed <identifiersep> handler <identifiersep> extension = classpath <identifiersep> based <identifiersep> kapt3extension ( compile <identifiersep> classpath , ap <identifiersep> classpath , java <identifiersep> source <identifiersep> roots , sources <identifiersep> output <identifiersep> dir , class <identifiersep> files <identifiersep> output <identifiersep> dir , stubs <identifiersep> output <identifiersep> dir , incremental <identifiersep> data <identifiersep> output <identifiersep> dir , ap <identifiersep> options , javac <identifiersep> cli <identifiersep> options , annotation <identifiersep> processors , apt <identifiersep> mode , use <identifiersep> light <identifiersep> analysis , correct <identifiersep> error <identifiersep> types , map <identifiersep> diagnostic <identifiersep> locations , system . current <identifiersep> time <identifiersep> millis ( ) , logger , configuration ) analysis <identifiersep> handler <identifiersep> extension . register <identifiersep> extension ( project , kapt3analysis <identifiersep> completed <identifiersep> handler <identifiersep> extension ) } <comment> <ect>
throw kapt <identifiersep> error ( kapt <identifiersep> error . kind . exception , e . cause ? : e ) } val log = compiler <identifiersep> after <identifiersep> ap . log val filer = processing <identifiersep> environment . filer as javac <identifiersep> filer val error <identifiersep> count = log . nerrors val warning <identifiersep> count = log . nwarnings if ( logger . is <identifiersep> verbose ) { <LOG> logger . info ( <string_literal> ) wrapped <identifiersep> processors . for <identifiersep> each { processor - > val rounds = processor . rounds val round <identifiersep> ms = rounds . join <identifiersep> to <identifiersep> string { <string_literal> } val total <identifiersep> ms = rounds . sum ( ) logger . info ( <string_literal> ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) wrapped <identifiersep> processors . for <identifiersep> each { processor - > val rounds = processor . rounds val round <identifiersep> ms = rounds . join <identifiersep> to <identifiersep> string { <string_literal> } val total <identifiersep> ms = rounds . sum ( ) <LOG> } filer . display <identifiersep> state ( ) } if ( log . nerrors > 0 ) { throw kapt <identifiersep> error ( kapt <identifiersep> error . kind . error <identifiersep> raised ) } } finally { processing <identifiersep> environment . close ( ) this @ do <identifiersep> annotation <identifiersep> processing . close ( ) <ect>
) { internal var saved <identifiersep> stubs : string ? = null internal var saved <identifiersep> bindings : map < string , kapt <identifiersep> java <identifiersep> file <identifiersep> object > ? = null override fun load <identifiersep> processors ( ) = processors override fun save <identifiersep> stubs ( kapt <identifiersep> context : kapt <identifiersep> context < * > , stubs : list < kapt <identifiersep> stub > ) { if ( this . saved <identifiersep> stubs != null ) { <LOG> } this . saved <identifiersep> stubs = stubs . map { it . file . pretty <identifiersep> print ( kapt <identifiersep> context . context ) } . sorted ( ) . join <identifiersep> to <identifiersep> string ( abstract <identifiersep> kotlin <identifiersep> kapt3test . file <identifiersep> separator ) super . save <identifiersep> stubs ( kapt <identifiersep> context , stubs ) } override fun save <identifiersep> incremental <identifiersep> data ( <ect>
psi <identifiersep> manager . get <identifiersep> instance ( project ) } override fun tear <identifiersep> down ( ) { dispose <identifiersep> environment ( ) } protected abstract fun create <identifiersep> environment ( source : file ) : abstract <identifiersep> core <identifiersep> environment protected fun initialize <identifiersep> environment ( source : file ) { if ( my <identifiersep> environment != null ) { <LOG> } my <identifiersep> environment = create <identifiersep> environment ( source ) core <identifiersep> application <identifiersep> environment . register <identifiersep> extension <identifiersep> point ( extensions . get <identifiersep> root <identifiersep> area ( ) , uast <identifiersep> language <identifiersep> plugin . extension <identifiersep> point <identifiersep> name , uast <identifiersep> language <identifiersep> plugin : : class . java ) core <identifiersep> application <identifiersep> environment . register <identifiersep> extension <identifiersep> point ( <ect>
public interface sam { void run ( ) ; } <comment> <LOG> } sam { val a : string = < ! no <identifiersep> this ! > this < ! > system . out . println ( a ) } <ect>
val parceler <identifiersep> object = parcelable <identifiersep> class . find <identifiersep> parceler <identifiersep> companion <identifiersep> object ( ) ? . first ? : parcelable <identifiersep> class . get <identifiersep> or <identifiersep> create <identifiersep> companion <identifiersep> object ( ) val binding <identifiersep> context = parceler <identifiersep> object . analyze ( body <identifiersep> resolve <identifiersep> mode . partial ) val parceler <identifiersep> type <identifiersep> arg = parcelable <identifiersep> class . name ? : run { log . error ( <string_literal> ) return } val parceler <identifiersep> object <identifiersep> descriptor = binding <identifiersep> context [ binding <identifiersep> context . class , parceler <identifiersep> object ] ? : run { <LOG> return } if ( ! parceler <identifiersep> object <identifiersep> descriptor . get <identifiersep> all <identifiersep> super <identifiersep> classifiers ( ) . any { it . fq <identifiersep> name <identifiersep> safe == parceler <identifiersep> fqname } ) { val entry <identifiersep> text = parceler <identifiersep> fqname . as <identifiersep> string ( ) + <string_literal> + parceler <identifiersep> type <identifiersep> arg + <string_literal> parceler <identifiersep> object . add <identifiersep> super <identifiersep> type <identifiersep> list <identifiersep> entry ( kt <identifiersep> psi <identifiersep> factory . create <identifiersep> super <identifiersep> type <identifiersep> entry ( entry <identifiersep> text ) ) . shorten <identifiersep> references ( ) } val old <identifiersep> write <identifiersep> to <identifiersep> parcel <identifiersep> function = parcelable <identifiersep> class . find <identifiersep> write <identifiersep> to <identifiersep> parcel <identifiersep> override ( ) val old <identifiersep> create <identifiersep> from <identifiersep> parcel <identifiersep> function = parcelable <identifiersep> class . find <identifiersep> creator <identifiersep> class ( ) ? . let { find <identifiersep> create <identifiersep> from <identifiersep> parcel ( it ) } <ect>
source <identifiersep> map . sources = source <identifiersep> map . sources . collect { source <identifiersep> path - > def prefix <identifiersep> to <identifiersep> remove = source <identifiersep> map <identifiersep> base <identifiersep> paths . find { base <identifiersep> path - > source <identifiersep> path . starts <identifiersep> with ( base <identifiersep> path ) } if ( prefix <identifiersep> to <identifiersep> remove != null ) source <identifiersep> path . substring ( prefix <identifiersep> to <identifiersep> remove . length ( ) ) else source <identifiersep> path } def source <identifiersep> map <identifiersep> sources <identifiersep> base <identifiersep> dirs = [ js <identifiersep> src <identifiersep> dir , js <identifiersep> src <identifiersep> js <identifiersep> dir , js <identifiersep> src <identifiersep> generated <identifiersep> dir , builtins <identifiersep> src <identifiersep> dir , common <identifiersep> src <identifiersep> dir , project <identifiersep> dir ] source <identifiersep> map . sources <identifiersep> content = source <identifiersep> map . sources . collect { source <identifiersep> name - > def text = source <identifiersep> map <identifiersep> sources <identifiersep> base <identifiersep> dirs . collect { file ( <string_literal> ) } . find { it . exists ( ) } ? . text <LOG> text } source <identifiersep> map <identifiersep> file . text = groovy . json . json <identifiersep> output . to <identifiersep> json ( source <identifiersep> map ) } } classes . depends <identifiersep> on compile <identifiersep> js jar { enabled false } task merged <identifiersep> jar ( type : jar , depends <identifiersep> on : classes ) { <ect>
assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) assert <identifiersep> true ( e . suppressed . single ( ) is io <identifiersep> exception ) } @ test fun op <identifiersep> fails <identifiersep> close <identifiersep> fails <identifiersep> twice ( ) { val e = assert <identifiersep> fails { resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > <LOG> } } } assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) val suppressed = e . suppressed assert <identifiersep> equals ( <number_literal> , suppressed . size ) assert <identifiersep> true ( suppressed . all { it is io <identifiersep> exception } ) } @ test fun non <identifiersep> local <identifiersep> return <identifiersep> in <identifiersep> block ( ) { fun resource . operation ( non <identifiersep> local : boolean ) : string { <ect>
assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) assert <identifiersep> true ( e . suppressed . single ( ) is io <identifiersep> exception ) } @ test fun op <identifiersep> fails <identifiersep> close <identifiersep> fails <identifiersep> twice ( ) { val e = assert <identifiersep> fails { resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > <LOG> } } } assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) val suppressed = e . suppressed assert <identifiersep> equals ( <number_literal> , suppressed . size ) assert <identifiersep> true ( suppressed . all { it is io <identifiersep> exception } ) } @ test fun non <identifiersep> local <identifiersep> return <identifiersep> in <identifiersep> block ( ) { fun resource . operation ( non <identifiersep> local : boolean ) : string { <ect>
@ test fun check <identifiersep> not <identifiersep> null <identifiersep> fails ( ) { assert <identifiersep> fails <identifiersep> with < illegal <identifiersep> state <identifiersep> exception > { val s2 : string ? = null check <identifiersep> not <identifiersep> null ( s2 ) } } @ test fun error ( ) { val error = assert <identifiersep> fails <identifiersep> with < illegal <identifiersep> state <identifiersep> exception > { <LOG> } assert <identifiersep> equals ( <string_literal> , error . message ) } <ect>
} ) ; int [ ] actual <identifiersep> array = to <identifiersep> int <identifiersep> array ( map ( actual , new function1 < string , integer > ( ) { @ override public integer invoke ( string s ) { return s . length ( ) ; } } ) ) ; <LOG> assert <identifiersep> equals ( <string_literal> , join <identifiersep> to <identifiersep> string ( actual <identifiersep> array , <string_literal> , <string_literal> , <string_literal> , - 1 , <string_literal> , null ) ) ; int single = single ( distinct ( actual <identifiersep> array ) ) ; assert <identifiersep> equals ( <number_literal> , single ) ; } } <ect>
assert <identifiersep> equals ( <string_literal> , text ) ; collection < string > actual = filter ( list , new function1 < string , boolean > ( ) { @ override public boolean invoke ( string text ) { return text . starts <identifiersep> with ( <string_literal> ) ; } } ) ; <LOG> assert <identifiersep> equals ( <string_literal> , join <identifiersep> to <identifiersep> string ( actual , <string_literal> , <string_literal> , <string_literal> , - 1 , <string_literal> , null ) ) ; } } <ect>
package foo ; public class java <identifiersep> bar <identifiersep> user { public void use ( bar bar ) { <LOG> } <ect>
lateinit var logger : logger override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : boolean { logger . info ( <string_literal> ) return true } override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = test <identifiersep> command <identifiersep> line <identifiersep> processor . test <identifiersep> plugin <identifiersep> id override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { <LOG> return list <identifiersep> of ( plugin <identifiersep> option ( <string_literal> , test <identifiersep> command <identifiersep> line <identifiersep> processor . test <identifiersep> plugin <identifiersep> id , test <identifiersep> command <identifiersep> line <identifiersep> processor . my <identifiersep> test <identifiersep> option . name , <string_literal> ) ) } <ect>
catch ( e : throwable ) { log . warn ( <string_literal> ) e . print <identifiersep> stack <identifiersep> trace ( ) null } if ( connection == null ) { if ( environment is gradle <identifiersep> incremental <identifiersep> compiler <identifiersep> environment ) { <LOG> } else { log . warn ( could <identifiersep> not <identifiersep> connect <identifiersep> to <identifiersep> daemon <identifiersep> message ) } return null } val ( daemon , session <identifiersep> id ) = connection val target <identifiersep> platform = when ( compiler <identifiersep> class <identifiersep> name ) { k2jvm <identifiersep> compiler - > compile <identifiersep> service . target <identifiersep> platform . jvm <ect>
<comment> <LOG> } log <identifiersep> finish ( daemon <identifiersep> execution <identifiersep> strategy ) return exit <identifiersep> code } private fun non <identifiersep> incremental <identifiersep> compilation <identifiersep> with <identifiersep> daemon ( daemon : compile <identifiersep> service , session <identifiersep> id : int , target <identifiersep> platform : compile <identifiersep> service . target <identifiersep> platform , <ect>
<string_literal> if ( allow <identifiersep> to <identifiersep> use <identifiersep> original <identifiersep> kapt ( ) ) { project . logger . warn ( deprecation <identifiersep> message ) } else { throw gradle <identifiersep> exception ( deprecation <identifiersep> message ) } if ( project . plugins . find <identifiersep> plugin ( android <identifiersep> apt <identifiersep> plugin <identifiersep> id ) != null ) { <LOG> } val annotation <identifiersep> processor <identifiersep> fq <identifiersep> names = lookup <identifiersep> annotation <identifiersep> processors ( apt <identifiersep> files ) generate <identifiersep> annotation <identifiersep> processor <identifiersep> stubs ( java <identifiersep> task , annotation <identifiersep> processor <identifiersep> fq <identifiersep> names , wrappers <identifiersep> directory ) set <identifiersep> processor <identifiersep> path <identifiersep> in <identifiersep> java <identifiersep> task ( ) if ( apt <identifiersep> output <identifiersep> dir . exists ( ) ) { apt <identifiersep> output <identifiersep> dir . delete <identifiersep> recursively ( ) } add <identifiersep> generated <identifiersep> sources <identifiersep> output <identifiersep> to <identifiersep> compiler <identifiersep> args ( java <identifiersep> task , apt <identifiersep> output <identifiersep> dir ) <ect>
val path = kapt <identifiersep> processor <identifiersep> path <comment> <LOG> path . join <identifiersep> to <identifiersep> string ( postfix = prev <identifiersep> value ? . let { file . path <identifiersep> separator + it } . or <identifiersep> empty ( ) , separator = file . path <identifiersep> separator ) } } } private fun try <identifiersep> append <identifiersep> processor <identifiersep> path <identifiersep> property ( path : iterable < file > ) : boolean = try { val options <identifiersep> class = java <identifiersep> task . options . java <identifiersep> class val get <identifiersep> path = options <identifiersep> class . get <identifiersep> method ( <string_literal> ) val set <identifiersep> path = options <identifiersep> class . get <identifiersep> method ( <string_literal> , file <identifiersep> collection : : class . java ) <ect>
val extension = project . extensions . create ( <string_literal> , android <identifiersep> extensions <identifiersep> extension : : class . java ) extension . set <identifiersep> evaluated <identifiersep> handler { evaluated <identifiersep> extension - > if ( evaluated <identifiersep> extension . is <identifiersep> experimental ) { add <identifiersep> android <identifiersep> extensions <identifiersep> runtime <identifiersep> if <identifiersep> needed ( project ) } } } private fun add <identifiersep> android <identifiersep> extensions <identifiersep> runtime <identifiersep> if <identifiersep> needed ( project : project ) { val kotlin <identifiersep> plugin <identifiersep> wrapper = project . plugins . find <identifiersep> plugin ( kotlin <identifiersep> android <identifiersep> plugin <identifiersep> wrapper : : class . java ) ? : run { <LOG> return } val kotlin <identifiersep> plugin <identifiersep> version = kotlin <identifiersep> plugin <identifiersep> wrapper . kotlin <identifiersep> plugin <identifiersep> version project . configurations . all { configuration - > val name = configuration . name if ( name != <string_literal> && name != <string_literal> ) return @ all val android <identifiersep> plugin <identifiersep> version = load <identifiersep> android <identifiersep> plugin <identifiersep> version ( ) ? : return @ all <ect>
? . let { project . get <identifiersep> tasks <identifiersep> by <identifiersep> name ( it , false ) . single <identifiersep> or <identifiersep> null ( ) as ? kotlin2js <identifiersep> compile } ? . output <identifiersep> file ? . parent <identifiersep> file ? . let { if ( library <identifiersep> utils . is <identifiersep> kotlin <identifiersep> javascript <identifiersep> library ( it ) ) it else null } ? . absolute <identifiersep> path override fun call <identifiersep> compiler ( args : k2js <identifiersep> compiler <identifiersep> arguments , source <identifiersep> roots : source <identifiersep> roots , changed <identifiersep> files : changed <identifiersep> files ) { source <identifiersep> roots as source <identifiersep> roots . kotlin <identifiersep> only <LOG> destination <identifiersep> dir . mkdirs ( ) val dependencies = compile <identifiersep> classpath . filter { library <identifiersep> utils . is <identifiersep> kotlin <identifiersep> javascript <identifiersep> library ( it ) } . map { it . canonical <identifiersep> path } args . libraries = ( dependencies + list <identifiersep> of <identifiersep> not <identifiersep> null ( friend <identifiersep> dependency ) ) . distinct ( ) . let { if ( it . is <identifiersep> not <identifiersep> empty ( ) ) <ect>
compiler <identifiersep> message <identifiersep> severity . error , compiler <identifiersep> message <identifiersep> severity . exception - > { has <identifiersep> errors = true logger . error ( format <identifiersep> msg ( <string_literal> ) ) } compiler <identifiersep> message <identifiersep> severity . warning , compiler <identifiersep> message <identifiersep> severity . strong <identifiersep> warning - > { <LOG> } compiler <identifiersep> message <identifiersep> severity . info - > { logger . info ( format <identifiersep> msg ( <string_literal> ) ) } compiler <identifiersep> message <identifiersep> severity . logging , compiler <identifiersep> message <identifiersep> severity . output - > { logger . debug ( format <identifiersep> msg ( <string_literal> ) ) } } ! ! <comment> <ect>
compiler <identifiersep> message <identifiersep> severity . strong <identifiersep> warning - > { logger . warn ( format <identifiersep> msg ( <string_literal> ) ) } compiler <identifiersep> message <identifiersep> severity . info - > { logger . info ( format <identifiersep> msg ( <string_literal> ) ) } compiler <identifiersep> message <identifiersep> severity . logging , compiler <identifiersep> message <identifiersep> severity . output - > { <LOG> } } ! ! <comment> <ect>
kotlin <identifiersep> task . any <identifiersep> classes <identifiersep> compiled = false val gradle <identifiersep> supports <identifiersep> java <identifiersep> ic <identifiersep> with <identifiersep> classes <identifiersep> dirs = parsed <identifiersep> gradle <identifiersep> version . parse ( java <identifiersep> task . project . gradle . gradle <identifiersep> version ) ? . let { it >= parsed <identifiersep> gradle <identifiersep> version ( <number_literal> , <number_literal> ) } ? : false if ( ! gradle <identifiersep> supports <identifiersep> java <identifiersep> ic <identifiersep> with <identifiersep> classes <identifiersep> dirs ) { java <identifiersep> task . outputs . up <identifiersep> to <identifiersep> date <identifiersep> when { task - > if ( kotlin <identifiersep> task . any <identifiersep> classes <identifiersep> compiled ) { <LOG> false } else true } } <comment> <ect>
val sessions <identifiersep> dir = gradle <identifiersep> compiler <identifiersep> runner . sessions <identifiersep> dir ( root <identifiersep> project ) if ( sessions <identifiersep> dir . exists ( ) ) { val session <identifiersep> files = sessions <identifiersep> dir . list <identifiersep> files ( ) <comment> <LOG> } for ( file in session <identifiersep> files ) { file . delete ( ) log . kotlin <identifiersep> debug { deleted <identifiersep> session <identifiersep> file <identifiersep> prefix + file . relative <identifiersep> to <identifiersep> root ( root <identifiersep> project ) } } } if ( should <identifiersep> report <identifiersep> memory <identifiersep> usage ) { val start <identifiersep> mem = start <identifiersep> memory ! ! val end <identifiersep> mem = get <identifiersep> used <identifiersep> memory <identifiersep> kb ( ) ! ! <ect>
val preset <identifiersep> arg <identifiersep> name = <string_literal> } override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = noarg <identifiersep> compiler <identifiersep> plugin <identifiersep> id @ requirement lateinit var logger : logger override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) = true override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { <LOG> return list <identifiersep> of ( plugin <identifiersep> option ( <string_literal> , noarg <identifiersep> compiler <identifiersep> plugin <identifiersep> id , preset <identifiersep> arg <identifiersep> name , <string_literal> ) ) } } <ect>
val modality = when { attribute . signature in super <identifiersep> signatures - > member <identifiersep> modality . override iface . kind == generate <identifiersep> definition <identifiersep> kind . class && attribute . is <identifiersep> val - > member <identifiersep> modality . open iface . kind == generate <identifiersep> definition <identifiersep> kind . abstract <identifiersep> class - > member <identifiersep> modality . open else - > member <identifiersep> modality . final } if ( attribute . name in super <identifiersep> attributes <identifiersep> by <identifiersep> name && attribute . signature ! in super <identifiersep> signatures ) { <LOG> for ( ( super <identifiersep> type <identifiersep> name , attributes ) in all <identifiersep> super <identifiersep> types . map { it . name to it . member <identifiersep> attributes . filter { it . name == attribute . name } . distinct ( ) } ) { for ( super <identifiersep> attribute in attributes ) { system . err . println ( <string_literal> ) } } } else if ( modality == member <identifiersep> modality . override && attribute . kind <identifiersep> not <identifiersep> changed ( super <identifiersep> attributes <identifiersep> by <identifiersep> name ) && ( iface . kind == generate <identifiersep> definition <identifiersep> kind . interface || attribute . has <identifiersep> super <identifiersep> implementation ( all <identifiersep> super <identifiersep> types ) ) <ect>
if ( is <identifiersep> log <identifiersep> enabled ( ) ) { log ( get <identifiersep> message . invoke ( ) ) ; } } @ override public void report <identifiersep> compile <identifiersep> iteration ( collection < ? extends file > source <identifiersep> files , exit <identifiersep> code exit <identifiersep> code ) { compiled <identifiersep> kotlin <identifiersep> files . add <identifiersep> all ( source <identifiersep> files ) ; if ( is <identifiersep> log <identifiersep> enabled ( ) ) { <LOG> log ( <string_literal> + exit <identifiersep> code . to <identifiersep> string ( ) ) ; } } @ not <identifiersep> null @ override public string paths <identifiersep> as <identifiersep> string ( iterable < ? extends file > files ) { return ic <identifiersep> reporter . default <identifiersep> impls . paths <identifiersep> as <identifiersep> string ( this , files ) ; } @ not <identifiersep> null <ect>
public file <identifiersep> copier ( log log ) { this . log = log ; } public void sync <identifiersep> dirs ( @ not <identifiersep> null file from , @ not <identifiersep> null file to , @ not <identifiersep> null file snapshots <identifiersep> storage <identifiersep> file ) { try { sync <identifiersep> dirs <identifiersep> impl ( from , to , snapshots <identifiersep> storage <identifiersep> file ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } private void sync <identifiersep> dirs <identifiersep> impl ( @ not <identifiersep> null file source <identifiersep> base <identifiersep> file , @ not <identifiersep> null file target <identifiersep> base <identifiersep> file , @ not <identifiersep> null file snapshots <identifiersep> storage <identifiersep> file ) throws io <identifiersep> exception { <comment> <ect>
files . create <identifiersep> directories ( target . get <identifiersep> parent ( ) ) ; files . copy ( path , target ) ; } log . debug ( <string_literal> + path + <string_literal> + target ) ; } new <identifiersep> snapshots . put ( relative <identifiersep> path , snapshot ) ; } for ( string removed <identifiersep> path : previous <identifiersep> snapshots . key <identifiersep> set ( ) ) { path target = target <identifiersep> base . resolve ( removed <identifiersep> path ) ; <LOG> if ( files . is <identifiersep> regular <identifiersep> file ( target ) ) { files . delete ( target ) ; } } write <identifiersep> file <identifiersep> snapshots ( new <identifiersep> snapshots , snapshots <identifiersep> storage <identifiersep> file ) ; } private void write <identifiersep> file <identifiersep> snapshots ( @ not <identifiersep> null map < string , file <identifiersep> snapshot > snapshots , @ not <identifiersep> null file output <identifiersep> file ) { try ( object <identifiersep> output <identifiersep> stream output = new object <identifiersep> output <identifiersep> stream ( new buffered <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( output <identifiersep> file ) ) ) ) { output . write <identifiersep> int ( version ) ; <ect>
for ( int i = 0 ; i < size ; i ++ ) { string path = input . read <identifiersep> utf ( ) ; long last <identifiersep> modified = input . read <identifiersep> long ( ) ; long file <identifiersep> size = input . read <identifiersep> long ( ) ; snapshots . put ( path , new file <identifiersep> snapshot ( last <identifiersep> modified , file <identifiersep> size ) ) ; } } catch ( exception e ) { <LOG> } return snapshots ; } private static class file <identifiersep> snapshot { final long last <identifiersep> modified ; final long size ; private file <identifiersep> snapshot ( long last <identifiersep> modified , long size ) { this . last <identifiersep> modified = last <identifiersep> modified ; <ect>
zip <identifiersep> output <identifiersep> stream ( buffered <identifiersep> output <identifiersep> stream ( file <identifiersep> output <identifiersep> stream ( out <identifiersep> file ) ) ) . use { out <identifiersep> jar - > jar <identifiersep> file ( in <identifiersep> file ) . use { in <identifiersep> jar - > for ( entry in in <identifiersep> jar . entries ( ) ) { val in <identifiersep> bytes = in <identifiersep> jar . get <identifiersep> input <identifiersep> stream ( entry ) . read <identifiersep> bytes ( ) val out <identifiersep> bytes = transform ( entry . name , in <identifiersep> bytes ) if ( in <identifiersep> bytes . size < out <identifiersep> bytes . size ) { <LOG> } entry . compressed <identifiersep> size = - 1l out <identifiersep> jar . put <identifiersep> next <identifiersep> entry ( entry ) out <identifiersep> jar . write ( out <identifiersep> bytes ) out <identifiersep> jar . close <identifiersep> entry ( ) } } } logger . info ( <string_literal> ) logger . info ( <string_literal> ) <ect>
error ( <string_literal> ) } entry . compressed <identifiersep> size = - 1l out <identifiersep> jar . put <identifiersep> next <identifiersep> entry ( entry ) out <identifiersep> jar . write ( out <identifiersep> bytes ) out <identifiersep> jar . close <identifiersep> entry ( ) } } } logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) } <ect>
out <identifiersep> jar . put <identifiersep> next <identifiersep> entry ( entry ) out <identifiersep> jar . write ( out <identifiersep> bytes ) out <identifiersep> jar . close <identifiersep> entry ( ) } } } logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) } <ect>
after <identifiersep> evaluate { the < java <identifiersep> plugin <identifiersep> convention > ( ) . source <identifiersep> sets . all { source <identifiersep> set <identifiersep> param - > <comment> <LOG> val instrumented <identifiersep> classes <identifiersep> dir = file ( project . build <identifiersep> dir , <string_literal> ) ( source <identifiersep> set <identifiersep> param . output . classes <identifiersep> dirs as configurable <identifiersep> file <identifiersep> collection ) . set <identifiersep> from ( instrumented <identifiersep> classes <identifiersep> dir ) val instrument <identifiersep> task = project . tasks . create ( source <identifiersep> set <identifiersep> param . get <identifiersep> task <identifiersep> name ( <string_literal> , <string_literal> ) , intelli <identifiersep> j <identifiersep> instrument <identifiersep> code <identifiersep> task : : class . java ) instrument <identifiersep> task . apply { depends <identifiersep> on ( source <identifiersep> set <identifiersep> param . classes <identifiersep> task <identifiersep> name ) . only <identifiersep> if { ! classes <identifiersep> dirs <identifiersep> copy . is <identifiersep> empty } source <identifiersep> set = source <identifiersep> set <identifiersep> param <ect>
val classpath = instrumentation <identifiersep> classpath ! ! ant . with <identifiersep> groovy <identifiersep> builder { <string_literal> ( <string_literal> to <string_literal> , <string_literal> to classpath . as <identifiersep> path , <string_literal> to loader <identifiersep> ref , <string_literal> to <string_literal> ) } <LOG> val instrument <identifiersep> not <identifiersep> null = prepare <identifiersep> not <identifiersep> null <identifiersep> instrumenting ( classpath . as <identifiersep> path ) instrument <identifiersep> code ( source <identifiersep> dirs , instrument <identifiersep> not <identifiersep> null ) } private fun copy <identifiersep> original <identifiersep> classes ( ) { project . copy { from ( original <identifiersep> classes <identifiersep> dirs ) into ( output ) <ect>
<comment> <LOG> ant . with <identifiersep> groovy <identifiersep> builder { <string_literal> ( <string_literal> to src <identifiersep> dirs . as <identifiersep> path , <string_literal> to output , <string_literal> to instrumentation <identifiersep> classpath , <string_literal> to false , <string_literal> to instrument <identifiersep> not <identifiersep> null ) { <ect>
<comment> private fun set <identifiersep> options <identifiersep> for <identifiersep> default <identifiersep> junit <identifiersep> run <identifiersep> configuration ( project : project ) { val workspace <identifiersep> file = file ( project <identifiersep> dir , <string_literal> ) if ( ! workspace <identifiersep> file . exists ( ) ) { <LOG> return } val document = sax <identifiersep> builder ( ) . build ( workspace <identifiersep> file ) val root <identifiersep> element = document . root <identifiersep> element fun element . get <identifiersep> or <identifiersep> create <identifiersep> child ( name : string , vararg attributes : pair < string , string > ) : element { for ( child in get <identifiersep> children ( name ) ) { if ( attributes . all { ( attribute , value ) - > child . get <identifiersep> attribute <identifiersep> value ( attribute ) == value } ) { <ect>
{ return new planner <identifiersep> info ( get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , platform <identifiersep> name , registry <identifiersep> name ) ; } @ override protected void check <identifiersep> platform ( configuration conf ) { if ( ! hadoop <identifiersep> util . is <identifiersep> yarn ( conf ) ) <LOG> } } <ect>
{ try { super . configure ( job <identifiersep> conf ) ; hadoop <identifiersep> util . init <identifiersep> log4j ( job <identifiersep> conf ) ; log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; <LOG> current <identifiersep> process = new hadoop <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , job <identifiersep> conf , false ) ; timed <identifiersep> iterators = timed <identifiersep> iterator . iterators ( new timed <identifiersep> iterator < tuple > ( current <identifiersep> process , slice <identifiersep> counters . read <identifiersep> duration , slice <identifiersep> counters . tuples <identifiersep> read ) ) ; string reduce <identifiersep> node <identifiersep> state = job <identifiersep> conf . get <identifiersep> raw ( <string_literal> ) ; if ( reduce <identifiersep> node <identifiersep> state == null ) reduce <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; flow <identifiersep> node = deserialize <identifiersep> base64 ( reduce <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; <ect>
reduce <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; flow <identifiersep> node = deserialize <identifiersep> base64 ( reduce <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , flow <identifiersep> node . get <identifiersep> ordinal ( ) ) ; stream <identifiersep> graph = new hadoop <identifiersep> reduce <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , util . get <identifiersep> first ( flow <identifiersep> node . get <identifiersep> source <identifiersep> elements ( ) ) ) ; group = ( hadoop <identifiersep> group <identifiersep> gate ) stream <identifiersep> graph . get <identifiersep> heads ( ) . iterator ( ) . next ( ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) <LOG> for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) log . info ( <string_literal> + trap ) ; log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) <ect>
group = ( hadoop <identifiersep> group <identifiersep> gate ) stream <identifiersep> graph . get <identifiersep> heads ( ) . iterator ( ) . next ( ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) <LOG> log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) { report <identifiersep> if <identifiersep> local ( throwable ) ; if ( throwable instanceof cascading <identifiersep> exception ) throw ( cascading <identifiersep> exception ) throwable ; <ect>
writer . close ( ) ; } catch ( io <identifiersep> exception exception ) { throw new flow <identifiersep> exception ( <string_literal> + temp . get <identifiersep> identifier ( ) ) ; } uri uri = new path ( state <identifiersep> path ) . to <identifiersep> uri ( ) ; distributed <identifiersep> cache . add <identifiersep> cache <identifiersep> file ( uri , conf ) ; <LOG> return state <identifiersep> path ; } public static string read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf job <identifiersep> conf , string id , string kind ) throws io <identifiersep> exception { path [ ] files = distributed <identifiersep> cache . get <identifiersep> local <identifiersep> cache <identifiersep> files ( job <identifiersep> conf ) ; path step <identifiersep> state <identifiersep> path = null ; for ( path file : files ) <ect>
try { if ( reader != null ) reader . close ( ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } } <comment> <ect>
{ try { hadoop <identifiersep> util . remove <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( config , step <identifiersep> state <identifiersep> path ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } if ( temp <identifiersep> sink != null ) { try { temp <identifiersep> sink . delete <identifiersep> resource ( config ) ; } catch ( exception exception ) <ect>
try { sink . delete <identifiersep> resource ( config ) ; } catch ( exception exception ) { <comment> <LOG> } } else { clean <identifiersep> tap <identifiersep> meta <identifiersep> data ( config , sink ) ; } } private void clean <identifiersep> tap <identifiersep> meta <identifiersep> data ( job <identifiersep> conf job <identifiersep> conf , tap tap ) { try <ect>
rule <identifiersep> registry . add <identifiersep> default <identifiersep> element <identifiersep> factory ( intermediate <identifiersep> tap <identifiersep> element <identifiersep> factory . temp <identifiersep> tap , new temp <identifiersep> tap <identifiersep> element <identifiersep> factory ( ) ) ; if ( property <identifiersep> util . get <identifiersep> boolean <identifiersep> property ( get <identifiersep> default <identifiersep> properties ( ) , flow <identifiersep> connector <identifiersep> props . enable <identifiersep> decorate <identifiersep> accumulated <identifiersep> tap , true ) ) rule <identifiersep> registry . add <identifiersep> default <identifiersep> element <identifiersep> factory ( intermediate <identifiersep> tap <identifiersep> element <identifiersep> factory . accumulated <identifiersep> tap , new temp <identifiersep> tap <identifiersep> element <identifiersep> factory ( dist <identifiersep> cache <identifiersep> tap . class . get <identifiersep> name ( ) ) ) ; } protected void check <identifiersep> platform ( configuration conf ) { if ( hadoop <identifiersep> util . is <identifiersep> yarn ( conf ) ) <LOG> } @ override protected hadoop <identifiersep> flow create <identifiersep> flow ( flow <identifiersep> def flow <identifiersep> def ) { return new hadoop <identifiersep> flow ( get <identifiersep> platform <identifiersep> info ( ) , get <identifiersep> default <identifiersep> properties ( ) , get <identifiersep> default <identifiersep> config ( ) , flow <identifiersep> def ) ; } @ override public flow <identifiersep> step <identifiersep> factory < job <identifiersep> conf > get <identifiersep> flow <identifiersep> step <identifiersep> factory ( ) <ect>
if ( task <identifiersep> reports . length == 0 ) return false ; add <identifiersep> task <identifiersep> stats ( task <identifiersep> reports , false ) ; return true ; } catch ( io <identifiersep> exception exception ) { <LOG> } catch ( interrupted <identifiersep> exception exception ) { log <identifiersep> warn ( <string_literal> , counter <identifiersep> cache . counter <identifiersep> timeout <identifiersep> property , exception . get <identifiersep> message ( ) ) ; } return false ; } protected void add <identifiersep> task <identifiersep> stats ( task <identifiersep> report [ ] task <identifiersep> reports , boolean skip <identifiersep> last ) { <ect>
catch ( interrupted <identifiersep> exception exception ) { log <identifiersep> warn ( <string_literal> , counter <identifiersep> cache . counter <identifiersep> timeout <identifiersep> property , exception . get <identifiersep> message ( ) ) ; } return false ; } protected void add <identifiersep> task <identifiersep> stats ( task <identifiersep> report [ ] task <identifiersep> reports , boolean skip <identifiersep> last ) { <LOG> long last <identifiersep> fetch = system . current <identifiersep> time <identifiersep> millis ( ) ; boolean fetched <identifiersep> are <identifiersep> finished = true ; synchronized ( slice <identifiersep> stats <identifiersep> map ) { int added = 0 ; int updated = 0 ; <ect>
slice <identifiersep> stats <identifiersep> map . put ( id , slice <identifiersep> stats ) ; added ++ ; } if ( ! slice <identifiersep> stats . get <identifiersep> status ( ) . is <identifiersep> finished ( ) ) fetched <identifiersep> are <identifiersep> finished = false ; } int total = slice <identifiersep> stats <identifiersep> map . size ( ) ; string duration = format <identifiersep> duration <identifiersep> from <identifiersep> millis ( system . current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> fetch ) ; <LOG> } all <identifiersep> children <identifiersep> finished = task <identifiersep> reports . length != 0 && fetched <identifiersep> are <identifiersep> finished ; } protected void add <identifiersep> attempt ( task <identifiersep> completion <identifiersep> event event ) { <comment> <ect>
break ; add <identifiersep> attempts <identifiersep> to <identifiersep> task <identifiersep> stats ( events ) ; count += events . length ; } mark <identifiersep> detail <identifiersep> captured ( ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } private void add <identifiersep> attempts <identifiersep> to <identifiersep> task <identifiersep> stats ( task <identifiersep> completion <identifiersep> event [ ] events ) { for ( task <identifiersep> completion <identifiersep> event event : events ) { if ( event == null ) { <ect>
public synchronized void set <identifiersep> up ( ) throws io <identifiersep> exception { if ( configuration != null ) return ; if ( ! is <identifiersep> use <identifiersep> cluster ( ) ) { <LOG> configuration = new job <identifiersep> conf ( ) ; <comment> <ect>
if ( util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; new file ( system . get <identifiersep> property ( <string_literal> ) ) . mkdirs ( ) ; <comment> <LOG> configuration = conf ; ( ( job <identifiersep> conf ) configuration ) . set <identifiersep> jar ( get <identifiersep> application <identifiersep> jar ( ) ) ; if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; <ect>
if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { <LOG> configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) <ect>
if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { <LOG> configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } configuration . set ( <string_literal> , <string_literal> ) ; <comment> <ect>
try { get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( ) . connect ( sources , sinks , pipe ) ; fail ( <string_literal> ) ; } catch ( exception exception ) { <LOG> assert <identifiersep> true ( exception . get <identifiersep> message ( ) . contains ( <string_literal> ) ) ; } } @ test public void test <identifiersep> split <identifiersep> on <identifiersep> non <identifiersep> safe <identifiersep> operations ( ) { tap source = new hfs ( new text <identifiersep> line ( new fields ( <string_literal> , <string_literal> ) ) , <string_literal> ) ; tap sink1 = new hfs ( new text <identifiersep> line ( ) , <string_literal> , sink <identifiersep> mode . replace ) ; <ect>
<comment> <LOG> <comment> <ect>
perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , codec , 0 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , codec , 0 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , codec , 1 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , codec , <number_literal> ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , codec , <number_literal> ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , codec , <number_literal> ) ; <LOG> } private void perform <identifiersep> list <identifiersep> test ( int size , int threshold , compression <identifiersep> codec codec , int spills ) { configuration job <identifiersep> conf = new configuration ( ) ; job <identifiersep> conf . set ( <string_literal> , test <identifiersep> serialization . class . get <identifiersep> name ( ) + <string_literal> + writable <identifiersep> serialization . class . get <identifiersep> name ( ) ) ; <comment> <ect>
configuration job <identifiersep> conf = new configuration ( ) ; job <identifiersep> conf . set ( spillable <identifiersep> props . spill <identifiersep> codecs , <string_literal> ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; <LOG> } private void perform <identifiersep> map <identifiersep> test ( int num <identifiersep> keys , int list <identifiersep> size , int map <identifiersep> threshold , int list <identifiersep> threshold , configuration job <identifiersep> conf ) { job <identifiersep> conf . set ( <string_literal> , test <identifiersep> serialization . class . get <identifiersep> name ( ) + <string_literal> + writable <identifiersep> serialization . class . get <identifiersep> name ( ) ) ; <comment> <ect>
try { timeline <identifiersep> client <identifiersep> class = ( class < dag <identifiersep> client > ) thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( timeline <identifiersep> client <identifiersep> class ) ; return true ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { <LOG> } return false ; } public static dag <identifiersep> status get <identifiersep> dag <identifiersep> status <identifiersep> with <identifiersep> counters ( dag <identifiersep> client dag <identifiersep> client ) { if ( dag <identifiersep> client == null ) return null ; try <ect>
catch ( cascading <identifiersep> exception exception ) { throwable cause = exception . get <identifiersep> cause ( ) ; if ( cause instanceof reflective <identifiersep> operation <identifiersep> exception && cause . get <identifiersep> cause ( ) instanceof tez <identifiersep> exception ) log . warn ( <string_literal> , cause . get <identifiersep> cause ( ) ) ; else if ( cause instanceof reflective <identifiersep> operation <identifiersep> exception && cause . get <identifiersep> cause ( ) instanceof no <identifiersep> such <identifiersep> method <identifiersep> error ) <LOG> else log . warn ( <string_literal> , exception ) ; } return null ; } public static string get <identifiersep> tracking <identifiersep> url ( tez <identifiersep> client tez <identifiersep> client , dag <identifiersep> client dag <identifiersep> client ) { if ( tez <identifiersep> client == null || dag <identifiersep> client == null ) <ect>
try { application <identifiersep> id application <identifiersep> id = tez <identifiersep> client . get <identifiersep> app <identifiersep> master <identifiersep> application <identifiersep> id ( ) ; framework <identifiersep> client framework <identifiersep> client = get <identifiersep> framework <identifiersep> client ( dag <identifiersep> client ) ; if ( framework <identifiersep> client == null ) { <LOG> return null ; } application <identifiersep> report report = framework <identifiersep> client . get <identifiersep> application <identifiersep> report ( application <identifiersep> id ) ; if ( report != null ) return report . get <identifiersep> tracking <identifiersep> url ( ) ; } catch ( yarn <identifiersep> exception | io <identifiersep> exception exception ) { <ect>
application <identifiersep> report report = framework <identifiersep> client . get <identifiersep> application <identifiersep> report ( application <identifiersep> id ) ; if ( report != null ) return report . get <identifiersep> tracking <identifiersep> url ( ) ; } catch ( yarn <identifiersep> exception | io <identifiersep> exception exception ) { log . info ( <string_literal> ) ; <LOG> } return null ; } private static framework <identifiersep> client get <identifiersep> framework <identifiersep> client ( dag <identifiersep> client dag <identifiersep> client ) { if ( dag <identifiersep> client instanceof tez <identifiersep> timeline <identifiersep> client ) return ( ( tez <identifiersep> timeline <identifiersep> client ) dag <identifiersep> client ) . get <identifiersep> framework <identifiersep> client ( ) ; return util . return <identifiersep> instance <identifiersep> field <identifiersep> if <identifiersep> exists <identifiersep> safe ( dag <identifiersep> client , <string_literal> ) ; <ect>
{ log <identifiersep> warn ( <string_literal> , get <identifiersep> id ( ) ) ; return null ; } return timeline <identifiersep> client . get <identifiersep> vertex <identifiersep> children ( vertex <identifiersep> id , fetch <identifiersep> limit , start <identifiersep> task <identifiersep> id ) ; } catch ( io <identifiersep> exception | cascading <identifiersep> exception | tez <identifiersep> exception exception ) { <LOG> } return null ; } private boolean without <identifiersep> timeline <identifiersep> server ( dag <identifiersep> client dag <identifiersep> client ) { vertex <identifiersep> status vertex <identifiersep> status = update <identifiersep> progress ( dag <identifiersep> client , status <identifiersep> get <identifiersep> counters ) ; if ( vertex <identifiersep> status == null || get <identifiersep> total <identifiersep> task <identifiersep> count ( ) == 0 ) return false ; <ect>
for ( int i = 0 ; i < failed <identifiersep> task <identifiersep> count && iterator . has <identifiersep> next ( ) ; i ++ ) ( ( tez <identifiersep> slice <identifiersep> stats ) iterator . next ( ) ) . set <identifiersep> status ( status . failed ) ; for ( int i = 0 ; i < killed <identifiersep> task <identifiersep> count && iterator . has <identifiersep> next ( ) ; i ++ ) ( ( tez <identifiersep> slice <identifiersep> stats ) iterator . next ( ) ) . set <identifiersep> status ( status . stopped ) ; list < string > diagnostics = vertex <identifiersep> status . get <identifiersep> diagnostics ( ) ; for ( string diagnostic : diagnostics ) <LOG> int finished <identifiersep> task <identifiersep> count = succeeded <identifiersep> task <identifiersep> count + failed <identifiersep> task <identifiersep> count + killed <identifiersep> task <identifiersep> count ; all <identifiersep> children <identifiersep> finished = total <identifiersep> task <identifiersep> count == finished <identifiersep> task <identifiersep> count ; return true ; } private status get <identifiersep> status <identifiersep> for <identifiersep> task <identifiersep> status ( @ nullable string status ) { if ( is <identifiersep> empty ( status ) ) <ect>
if ( result <identifiersep> field <identifiersep> selectors != null ) use <identifiersep> result <identifiersep> selectors ( function <identifiersep> call . get <identifiersep> arguments ( ) , function <identifiersep> call . get <identifiersep> output <identifiersep> collector ( ) ) ; else use <identifiersep> size ( function <identifiersep> call . get <identifiersep> arguments ( ) , function <identifiersep> call . get <identifiersep> output <identifiersep> collector ( ) ) ; } private void use <identifiersep> size ( tuple <identifiersep> entry input , tuple <identifiersep> entry <identifiersep> collector output <identifiersep> collector ) { <LOG> tuple tuple = new tuple ( input . get <identifiersep> tuple ( ) ) ; <comment> <ect>
return pattern ; } private boolean match <identifiersep> whole <identifiersep> tuple ( tuple input , pattern pattern ) { if ( pattern <identifiersep> string == null ) return true ; matcher matcher = pattern . matcher ( input . to <identifiersep> string ( <string_literal> , false ) ) ; <LOG> return matcher . matches ( ) ; } @ override public void prepare ( flow <identifiersep> process flow <identifiersep> process , operation <identifiersep> call < context > operation <identifiersep> call ) { operation <identifiersep> call . set <identifiersep> context ( new context ( ) ) ; operation <identifiersep> call . get <identifiersep> context ( ) . pattern = get <identifiersep> pattern ( ) ; <ect>
string value = input . get <identifiersep> string ( i ) ; if ( value == null ) value = <string_literal> ; matcher . reset ( value ) ; boolean match <identifiersep> found = matcher . find ( ) ; <LOG> if ( match <identifiersep> found == negate <identifiersep> match ) return pos ; pos ++ ; } return - 1 ; } @ override public boolean equals ( object object ) <ect>
<comment> public static string get <identifiersep> application <identifiersep> jar <identifiersep> path ( map < object , object > properties ) { string property = property <identifiersep> util . get <identifiersep> property ( properties , dep <identifiersep> app <identifiersep> jar <identifiersep> path , ( string ) null ) ; if ( property != null ) { <LOG> return property ; } return property <identifiersep> util . get <identifiersep> property ( properties , app <identifiersep> jar <identifiersep> path , ( string ) null ) ; } public static void set <identifiersep> application <identifiersep> id ( map < object , object > properties ) { properties . put ( app <identifiersep> id , get <identifiersep> app <identifiersep> id ( ) ) ; } public static string get <identifiersep> application <identifiersep> id ( map < object , object > properties ) <ect>
public static void add <identifiersep> application <identifiersep> tag ( map < object , object > properties , string tag ) { if ( tag == null ) return ; tag = tag . trim ( ) ; if ( util . contains <identifiersep> whitespace ( tag ) ) <LOG> string tags = property <identifiersep> util . get <identifiersep> property ( properties , app <identifiersep> tags , ( string ) null ) ; if ( tags != null ) tags = join ( <string_literal> , tag , tags ) ; else tags = tag ; properties . put ( app <identifiersep> tags , tags ) ; <ect>
url update <identifiersep> check <identifiersep> url = get <identifiersep> update <identifiersep> check <identifiersep> url ( ) ; if ( update <identifiersep> check <identifiersep> url == null ) return false ; <comment> <LOG> return true ; } properties latest <identifiersep> properties = get <identifiersep> update <identifiersep> properties ( update <identifiersep> check <identifiersep> url ) ; if ( latest <identifiersep> properties . is <identifiersep> empty ( ) ) return false ; string latest <identifiersep> major = latest <identifiersep> properties . get <identifiersep> property ( version . cascading <identifiersep> release <identifiersep> major ) ; string latest <identifiersep> minor = latest <identifiersep> properties . get <identifiersep> property ( version . cascading <identifiersep> release <identifiersep> minor ) ; <ect>
if ( is <identifiersep> same <identifiersep> major <identifiersep> release && is <identifiersep> same <identifiersep> minor <identifiersep> release ) { log . debug ( <string_literal> ) ; return true ; } string version = latest <identifiersep> properties . get <identifiersep> property ( <string_literal> ) ; if ( version == null ) <LOG> else log . info ( <string_literal> , version ) ; return true ; } private static properties get <identifiersep> update <identifiersep> properties ( url update <identifiersep> url ) { try <ect>
finally { close ( input <identifiersep> stream ) ; } } catch ( io <identifiersep> exception exception ) { <comment> <LOG> return new properties ( ) ; } } private static url get <identifiersep> update <identifiersep> check <identifiersep> url ( ) { string url = build <identifiersep> url ( ) ; string connector = url . index <identifiersep> of ( ' ? ' ) > 0 ? <string_literal> : <string_literal> ; string spec = url + connector + build <identifiersep> params <identifiersep> string ( ) ; <ect>
return <string_literal> ; try { return url <identifiersep> encoder . encode ( param , <string_literal> ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception exception ) { <LOG> return null ; } } private static string get <identifiersep> property ( string prop ) { return system . get <identifiersep> property ( prop , <string_literal> ) ; } private static void close ( input <identifiersep> stream in ) { <ect>
if ( counters == null ) return ; string [ ] split = counters . split ( <string_literal> ) ; for ( string value : split ) { string counter [ ] = value . split ( <string_literal> ) ; <LOG> } } } <ect>
return exec <identifiersep> process ( null , <string_literal> , <string_literal> ) == 0 ; } public static int exec <identifiersep> process ( file parent <identifiersep> file , string . . . command ) { try { string command <identifiersep> line = join ( command , <string_literal> ) ; <LOG> process process = runtime . get <identifiersep> runtime ( ) . exec ( command <identifiersep> line , null , parent <identifiersep> file ) ; int result = process . wait <identifiersep> for ( ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( process . get <identifiersep> input <identifiersep> stream ( ) ) ) ; string line = reader . read <identifiersep> line ( ) ; while ( line != null ) { <ect>
log . warn ( <string_literal> , command [ 0 ] , line ) ; line = reader . read <identifiersep> line ( ) ; } reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( process . get <identifiersep> error <identifiersep> stream ( ) ) ) ; line = reader . read <identifiersep> line ( ) ; while ( line != null ) { <LOG> line = reader . read <identifiersep> line ( ) ; } return result ; } catch ( io <identifiersep> exception exception ) { log . warn ( <string_literal> + command [ 0 ] , exception ) ; } catch ( interrupted <identifiersep> exception exception ) <ect>
return result ; } catch ( io <identifiersep> exception exception ) { log . warn ( <string_literal> + command [ 0 ] , exception ) ; } catch ( interrupted <identifiersep> exception exception ) { <LOG> } return integer . min <identifiersep> value ; } public static string format <identifiersep> duration <identifiersep> from <identifiersep> millis ( long duration ) { if ( duration / <number_literal> / <number_literal> / <number_literal> / <number_literal> > 0 . 0 ) return format <identifiersep> duration <identifiersep> dhm <identifiersep> sms ( duration ) ; if ( duration / <number_literal> / <number_literal> / <number_literal> > 0 . 0 ) <ect>
{ return operator . operate ( ) ; } catch ( exception exception ) { if ( operator . rethrow ( exception ) ) { <LOG> throw exception ; } saved = exception ; logger . warn ( message + <string_literal> + ( i + 1 ) , exception ) ; try { thread . sleep ( seconds <identifiersep> delay * <number_literal> ) ; <ect>
for ( url resource : resources ) map . put ( resource . get <identifiersep> protocol ( ) , resource . to <identifiersep> string ( ) ) ; for ( string key : map . get <identifiersep> keys ( ) ) { set < string > values = map . get <identifiersep> values ( key ) ; if ( values . size ( ) > 1 ) <LOG> } } } <ect>
if ( hook == null ) continue ; hook . execute ( ) ; } catch ( exception exception ) { log . error ( <string_literal> , hook , exception . get <identifiersep> message ( ) ) ; <LOG> } } } finally { system . set <identifiersep> property ( shutdown <identifiersep> executing , <string_literal> ) ; } } } ; runtime . get <identifiersep> runtime ( ) . add <identifiersep> shutdown <identifiersep> hook ( shutdown <identifiersep> hook ) ; } public static void deregister <identifiersep> shutdown <identifiersep> hook ( ) <ect>
{ runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> , flushes + 1 , capacity ) ; <LOG> float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) log . info ( <string_literal> , ( int ) ( percent * <number_literal> . 0f ) ) ; } flushes ++ ; } return do <identifiersep> remove ; } } ; <ect>
if ( put <identifiersep> calls % get <identifiersep> capacity ( ) == 0 ) { runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; <LOG> log . info ( <string_literal> , get <identifiersep> capacity ( ) , put <identifiersep> calls , collisions , ( ( double ) get <identifiersep> capacity ( ) / actual <identifiersep> size ) * <number_literal> ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) log . info ( <string_literal> , ( int ) ( percent * <number_literal> . 0f ) ) ; } return previous ; <ect>
long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; log . info ( <string_literal> , get <identifiersep> capacity ( ) , put <identifiersep> calls , collisions , ( ( double ) get <identifiersep> capacity ( ) / actual <identifiersep> size ) * <number_literal> ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) <LOG> } return previous ; } private int index ( object key ) { return math . abs ( key . hash <identifiersep> code ( ) % capacity ) ; } @ override public value remove ( object key ) <ect>
{ runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> , flushes + 1 , capacity ) ; <LOG> float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) log . info ( <string_literal> , ( int ) ( percent * <number_literal> . 0f ) ) ; } flushes ++ ; } return do <identifiersep> remove ; } } ; <ect>
if ( end <identifiersep> index != - 1 ) path = path . substring ( 0 , end <identifiersep> index ) ; if ( path . ends <identifiersep> with ( <string_literal> ) ) return new url ( path ) ; } catch ( exception exception ) { <LOG> } } return null ; } private static url get <identifiersep> library <identifiersep> url ( ) { string property = default <identifiersep> properties . get <identifiersep> property ( cascading <identifiersep> services <identifiersep> jar ) ; if ( property == null ) return null ; <ect>
uri uri = uri . create ( property ) ; if ( ! uri . is <identifiersep> absolute ( ) ) uri = new uri ( <string_literal> , uri . get <identifiersep> authority ( ) , uri . get <identifiersep> path ( ) , uri . get <identifiersep> query ( ) , uri . get <identifiersep> fragment ( ) ) ; return uri . to <identifiersep> url ( ) ; } catch ( exception exception ) { <LOG> } return null ; } private static properties load <identifiersep> properties ( properties properties , string resource , class <identifiersep> loader class <identifiersep> loader ) { input <identifiersep> stream input = class <identifiersep> loader . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( resource ) ; try { <ect>
if ( input != null ) { url url = parse <identifiersep> library <identifiersep> url ( class <identifiersep> loader , resource ) ; if ( url != null ) log . info ( <string_literal> , resource , url ) ; else <LOG> properties . load ( input ) ; } } catch ( io <identifiersep> exception exception ) { log . warn ( <string_literal> , resource , exception ) ; } return properties ; } private synchronized service <identifiersep> loader get <identifiersep> service <identifiersep> util ( ) <ect>
try { service . stop <identifiersep> service ( ) ; } catch ( throwable throwable ) { <comment> <LOG> throw new cascade <identifiersep> exception ( <string_literal> , throwable ) ; } } } ) ; } <comment> public static class null <identifiersep> document <identifiersep> service implements document <identifiersep> service { @ override <ect>
try { uri = uri . create ( encode ( value . to <identifiersep> string ( ) ) ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception exception ) { log . warn ( <string_literal> , value , exception . get <identifiersep> message ( ) ) ; <LOG> if ( boolean . parse <identifiersep> boolean ( system . get <identifiersep> property ( failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ) ) { log . warn ( <string_literal> , failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ; return value . to <identifiersep> string ( ) ; } <comment> <ect>
log . debug ( <string_literal> , value , exception ) ; if ( boolean . parse <identifiersep> boolean ( system . get <identifiersep> property ( failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ) ) { log . warn ( <string_literal> , failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ; return value . to <identifiersep> string ( ) ; } <comment> <LOG> return <string_literal> ; } } if ( uri . is <identifiersep> opaque ( ) ) { switch ( visibility ) { case private : <ect>
{ service . start <identifiersep> service ( ) ; return true ; } catch ( throwable throwable ) { log . warn ( <string_literal> , service . get <identifiersep> class ( ) . get <identifiersep> name ( ) , throwable . get <identifiersep> message ( ) ) ; <LOG> return false ; } } public void stop <identifiersep> service ( ) { <comment> <ect>
public long get <identifiersep> sink <identifiersep> modified ( ) throws io <identifiersep> exception { long sink <identifiersep> modified = util . get <identifiersep> sink <identifiersep> modified ( get <identifiersep> config ( ) , sinks . values ( ) ) ; { if ( sink <identifiersep> modified == - 1l ) <LOG> if ( sink <identifiersep> modified == 0l ) log <identifiersep> info ( <string_literal> ) ; else log <identifiersep> info ( <string_literal> + new date ( sink <identifiersep> modified ) ) ; } return sink <identifiersep> modified ; } @ override <ect>
if ( sink <identifiersep> modified == - 1l ) log <identifiersep> info ( <string_literal> ) ; if ( sink <identifiersep> modified == 0l ) log <identifiersep> info ( <string_literal> ) ; else <LOG> } return sink <identifiersep> modified ; } @ override public flow <identifiersep> step <identifiersep> strategy get <identifiersep> flow <identifiersep> step <identifiersep> strategy ( ) { return flow <identifiersep> step <identifiersep> strategy ; } @ override <ect>
try { if ( ! tap . commit <identifiersep> resource ( get <identifiersep> config ( ) ) ) log <identifiersep> error ( <string_literal> + tap . get <identifiersep> full <identifiersep> identifier ( get <identifiersep> config ( ) ) ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } } @ override @ process <identifiersep> cleanup public void cleanup ( ) { <comment> <ect>
protected void initialize <identifiersep> child <identifiersep> stats ( ) { for ( flow <identifiersep> step <identifiersep> job < config > flow <identifiersep> step <identifiersep> job : jobs <identifiersep> map . values ( ) ) flow <identifiersep> stats . add <identifiersep> step <identifiersep> stats ( flow <identifiersep> step <identifiersep> job . get <identifiersep> step <identifiersep> stats ( ) ) ; } protected void internal <identifiersep> stop <identifiersep> all <identifiersep> jobs ( ) { <LOG> try { if ( jobs <identifiersep> map == null ) return ; list < flow <identifiersep> step <identifiersep> job < config > > jobs = new array <identifiersep> list < flow <identifiersep> step <identifiersep> job < config > > ( jobs <identifiersep> map . values ( ) ) ; collections . reverse ( jobs ) ; <ect>
protected void handle <identifiersep> executor <identifiersep> shutdown ( ) { if ( spawn <identifiersep> strategy == null ) return ; if ( spawn <identifiersep> strategy . is <identifiersep> completed ( this ) ) return ; <LOG> try { spawn <identifiersep> strategy . complete ( this , <number_literal> * <number_literal> , time <identifiersep> unit . seconds ) ; } catch ( interrupted <identifiersep> exception exception ) { <comment> <ect>
log <identifiersep> debug ( <string_literal> ) ; } protected void fire <identifiersep> on <identifiersep> completed ( ) { if ( has <identifiersep> listeners ( ) ) { <LOG> for ( flow <identifiersep> listener flow <identifiersep> listener : get <identifiersep> listeners ( ) ) flow <identifiersep> listener . on <identifiersep> completed ( this ) ; } } protected void fire <identifiersep> on <identifiersep> throwable ( throwable throwable ) { this . throwable = throwable ; fire <identifiersep> on <identifiersep> throwable ( ) ; <ect>
throwable = null ; } } protected void fire <identifiersep> on <identifiersep> stopping ( ) { if ( has <identifiersep> listeners ( ) ) { <LOG> for ( flow <identifiersep> listener flow <identifiersep> listener : get <identifiersep> listeners ( ) ) flow <identifiersep> listener . on <identifiersep> stopping ( this ) ; } } protected void fire <identifiersep> on <identifiersep> starting ( ) { if ( has <identifiersep> listeners ( ) ) <ect>
{ @ override public void log <identifiersep> info ( string message , object . . . arguments ) { <LOG> } @ override public void log <identifiersep> debug ( string message , object . . . arguments ) { log . debug ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> warn ( string message ) <ect>
public void log <identifiersep> debug ( string message , object . . . arguments ) { log . debug ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> warn ( string message ) { <LOG> } @ override public void log <identifiersep> warn ( string message , throwable throwable ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , throwable ) ; } @ override public void log <identifiersep> warn ( string message , object . . . arguments ) <ect>
public void log <identifiersep> warn ( string message , throwable throwable ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , throwable ) ; } @ override public void log <identifiersep> warn ( string message , object . . . arguments ) { <LOG> } @ override public void log <identifiersep> error ( string message , object . . . arguments ) { log . error ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> error ( string message , throwable throwable ) <ect>
public void log <identifiersep> error ( string message , object . . . arguments ) { log . error ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> error ( string message , throwable throwable ) { <LOG> } @ override public void write <identifiersep> dot ( string filename ) { if ( flow <identifiersep> element <identifiersep> graph == null ) throw new unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> ) ; flow <identifiersep> element <identifiersep> graph . write <identifiersep> dot ( filename ) ; <ect>
{ handle <identifiersep> throwable ( throwable ) ; } return false ; } private void handle <identifiersep> throwable ( throwable throwable ) { this . throwable = throwable ; <LOG> <comment> <ect>
{ try { return new topological <identifiersep> order <identifiersep> iterator ( duct <identifiersep> graph ) ; } catch ( runtime <identifiersep> exception exception ) { <LOG> print <identifiersep> graph <identifiersep> error ( ) ; throw exception ; } } public topological <identifiersep> order <identifiersep> iterator < duct , integer > get <identifiersep> reversed <identifiersep> topological <identifiersep> order <identifiersep> iterator ( ) { try { <ect>
return ; classifier = util . cleanse <identifiersep> path <identifiersep> name ( classifier ) ; path = string . format ( <string_literal> , path , id , classifier , discriminator ) ; print <identifiersep> graph ( path ) ; } public void print <identifiersep> graph ( string filename ) { <LOG> util . print <identifiersep> graph ( filename , duct <identifiersep> graph ) ; } public void print <identifiersep> bound <identifiersep> graph ( string id , string classifier , int discriminator ) { string path = ( string ) get <identifiersep> property ( dot <identifiersep> file <identifiersep> path ) ; if ( path == null ) return ; <ect>
catch ( interrupted <identifiersep> exception exception ) { <comment> <LOG> return throwable ; } finally { try { if ( iterator != null ) <ect>
if ( sort <identifiersep> fields != null ) { sort <identifiersep> fields [ ordinal ] = outgoing <identifiersep> scope . get <identifiersep> sorting <identifiersep> selectors ( ) . get ( incoming <identifiersep> scope . get <identifiersep> name ( ) ) ; sort <identifiersep> builder [ ordinal ] = create <identifiersep> narrow <identifiersep> builder ( incoming <identifiersep> scope . get <identifiersep> incoming <identifiersep> splice <identifiersep> fields ( ) , sort <identifiersep> fields [ ordinal ] ) ; } { <LOG> log . debug ( <string_literal> , print <identifiersep> safe ( key <identifiersep> fields [ ordinal ] ) ) ; log . debug ( <string_literal> , print <identifiersep> safe ( values <identifiersep> fields [ ordinal ] ) ) ; if ( sort <identifiersep> fields != null ) log . debug ( <string_literal> , print <identifiersep> safe ( sort <identifiersep> fields [ ordinal ] ) ) ; } } if ( role == io <identifiersep> role . sink ) { <ect>
sort <identifiersep> fields [ ordinal ] = outgoing <identifiersep> scope . get <identifiersep> sorting <identifiersep> selectors ( ) . get ( incoming <identifiersep> scope . get <identifiersep> name ( ) ) ; sort <identifiersep> builder [ ordinal ] = create <identifiersep> narrow <identifiersep> builder ( incoming <identifiersep> scope . get <identifiersep> incoming <identifiersep> splice <identifiersep> fields ( ) , sort <identifiersep> fields [ ordinal ] ) ; } { log . debug ( <string_literal> , incoming <identifiersep> scope . get <identifiersep> name ( ) , ordinal ) ; log . debug ( <string_literal> , print <identifiersep> safe ( key <identifiersep> fields [ ordinal ] ) ) ; <LOG> if ( sort <identifiersep> fields != null ) log . debug ( <string_literal> , print <identifiersep> safe ( sort <identifiersep> fields [ ordinal ] ) ) ; } } if ( role == io <identifiersep> role . sink ) { if ( sort <identifiersep> fields == null ) group <identifiersep> tuple = new key <identifiersep> tuple ( ) ; <ect>
fields sort <identifiersep> fields = splice . get <identifiersep> sorting <identifiersep> selectors ( ) . get ( incoming <identifiersep> scope . get <identifiersep> name ( ) ) ; value <identifiersep> comparators [ pos ] = new sparse <identifiersep> tuple <identifiersep> comparator ( values <identifiersep> fields [ pos ] , sort <identifiersep> fields , default <identifiersep> comparator ) ; if ( splice . is <identifiersep> sort <identifiersep> reversed ( ) ) value <identifiersep> comparators [ pos ] = null <identifiersep> safe <identifiersep> reverse <identifiersep> comparator . reverse <identifiersep> order ( value <identifiersep> comparators [ pos ] ) ; } } nulls <identifiersep> are <identifiersep> not <identifiersep> equal = ! are <identifiersep> nulls <identifiersep> equal ( ) ; if ( nulls <identifiersep> are <identifiersep> not <identifiersep> equal ) <LOG> comparator [ ] hashers = tuple <identifiersep> hasher . merge ( compare <identifiersep> fields ) ; group <identifiersep> hasher = default <identifiersep> comparator != null || ! tuple <identifiersep> hasher . is <identifiersep> null ( hashers ) ? new tuple <identifiersep> hasher ( default <identifiersep> comparator , hashers ) : null ; } protected comparator get <identifiersep> key <identifiersep> comparator ( ) { if ( group <identifiersep> comparators . length > 0 && group <identifiersep> comparators [ 0 ] != null ) return group <identifiersep> comparators [ 0 ] ; <ect>
payload = new tuple <identifiersep> entry ( fields . unknown , ( ( tap <identifiersep> exception ) cause ) . get <identifiersep> payload ( ) ) ; } else if ( tuple <identifiersep> entry != null ) { payload = tuple <identifiersep> entry ; } else { <LOG> throw new duct <identifiersep> exception ( <string_literal> , throwable ) ; } tuple <identifiersep> entry diagnostics = get <identifiersep> diagnostics ( throwable ) ; if ( diagnostics != tuple <identifiersep> entry . null ) <comment> <ect>
new scope <identifiersep> edge <identifiersep> name <identifiersep> provider ( ) , new vertex <identifiersep> attribute <identifiersep> provider ( ) , new edge <identifiersep> attribute <identifiersep> provider ( ) ) ; writer . close ( ) ; return true ; } catch ( null <identifiersep> pointer <identifiersep> exception | io <identifiersep> exception exception ) { <LOG> } return false ; } public static boolean print <identifiersep> process <identifiersep> graph ( string filename , final element <identifiersep> graph graph , final process <identifiersep> graph < ? extends process <identifiersep> model > process <identifiersep> graph ) { try { file parent <identifiersep> file = new file ( filename ) . get <identifiersep> parent <identifiersep> file ( ) ; <ect>
{ <comment> <LOG> return ; } boolean success = util . set <identifiersep> instance <identifiersep> field <identifiersep> if <identifiersep> exists <identifiersep> safe ( specifics , <string_literal> , new identity <identifiersep> hash <identifiersep> map < > ( ) ) ; if ( ! success ) log . warn ( <string_literal> ) ; } } <ect>
collection < flow <identifiersep> node <identifiersep> stats > children = flow <identifiersep> step <identifiersep> stats . get <identifiersep> children ( ) ; for ( flow <identifiersep> node <identifiersep> stats flow <identifiersep> node <identifiersep> stats : children ) flow <identifiersep> node <identifiersep> stats . mark <identifiersep> started ( ) ; } flow flow = flow <identifiersep> step . get <identifiersep> flow ( ) ; if ( flow == null ) { <LOG> return ; } flow <identifiersep> stats flow <identifiersep> stats = flow . get <identifiersep> flow <identifiersep> stats ( ) ; synchronized ( flow <identifiersep> stats ) { if ( flow <identifiersep> stats . is <identifiersep> started ( ) ) flow <identifiersep> stats . mark <identifiersep> submitted ( ) ; <ect>
public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , flow <identifiersep> element <identifiersep> graph flow <identifiersep> element <identifiersep> graph , string name ) { if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; if ( flow <identifiersep> element <identifiersep> graph == null ) { <LOG> return ; } path file = get <identifiersep> full <identifiersep> transform <identifiersep> trace <identifiersep> path ( registry <identifiersep> name ) . resolve ( name ) . normalize ( ) ; process <identifiersep> logger . log <identifiersep> info ( <string_literal> , name , file ) ; flow <identifiersep> element <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , list < ? extends element <identifiersep> graph > flow <identifiersep> element <identifiersep> graphs , plan <identifiersep> phase phase , string sub <identifiersep> name ) { <ect>
public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , list < ? extends element <identifiersep> graph > flow <identifiersep> element <identifiersep> graphs , plan <identifiersep> phase phase , string sub <identifiersep> name ) { if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; if ( flow <identifiersep> element <identifiersep> graphs == null || flow <identifiersep> element <identifiersep> graphs . is <identifiersep> empty ( ) ) { <LOG> return ; } for ( int i = 0 ; i < flow <identifiersep> element <identifiersep> graphs . size ( ) ; i ++ ) { element <identifiersep> graph flow <identifiersep> element <identifiersep> graph = flow <identifiersep> element <identifiersep> graphs . get ( i ) ; string name = string . format ( <string_literal> , phase . ordinal ( ) , phase , sub <identifiersep> name , i ) ; path file = get <identifiersep> full <identifiersep> transform <identifiersep> trace <identifiersep> path ( registry <identifiersep> name ) . resolve ( name ) . normalize ( ) ; <ect>
public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , map < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > parent <identifiersep> graphs <identifiersep> map , map < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > sub <identifiersep> graphs <identifiersep> map , plan <identifiersep> phase phase , string sub <identifiersep> name ) { if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; if ( parent <identifiersep> graphs <identifiersep> map == null || parent <identifiersep> graphs <identifiersep> map . is <identifiersep> empty ( ) ) { <LOG> return ; } int step <identifiersep> count = 0 ; for ( map . entry < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > entry : parent <identifiersep> graphs <identifiersep> map . entry <identifiersep> set ( ) ) { int node <identifiersep> count = 0 ; for ( element <identifiersep> graph element <identifiersep> graph : entry . get <identifiersep> value ( ) ) <ect>
public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , map < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > sub <identifiersep> graphs <identifiersep> map , plan <identifiersep> phase phase , string sub <identifiersep> name ) { if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; if ( sub <identifiersep> graphs <identifiersep> map == null || sub <identifiersep> graphs <identifiersep> map . is <identifiersep> empty ( ) ) { <LOG> return ; } int step <identifiersep> count = 0 ; for ( map . entry < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > entry : sub <identifiersep> graphs <identifiersep> map . entry <identifiersep> set ( ) ) { list < ? extends element <identifiersep> graph > flow <identifiersep> element <identifiersep> graphs = entry . get <identifiersep> value ( ) ; for ( int i = 0 ; i < flow <identifiersep> element <identifiersep> graphs . size ( ) ; i ++ ) <ect>
{ path path = get <identifiersep> plan <identifiersep> trace <identifiersep> path ( ) ; if ( path == null ) return ; if ( element <identifiersep> graph == null ) { <LOG> return ; } if ( registry <identifiersep> name != null ) path = path . resolve ( registry <identifiersep> name ) ; path file <identifiersep> path = path . resolve ( string . format ( <string_literal> , file <identifiersep> name , canonical <identifiersep> hash ( element <identifiersep> graph ) ) ) ; file file = file <identifiersep> path . to <identifiersep> file ( ) ; process <identifiersep> logger . log <identifiersep> info ( <string_literal> , file ) ; <ect>
{ path path = get <identifiersep> plan <identifiersep> trace <identifiersep> path ( ) ; if ( path == null ) return ; if ( step <identifiersep> graph == null ) { <LOG> return ; } if ( registry <identifiersep> name != null ) path = path . resolve ( registry <identifiersep> name ) ; path file <identifiersep> path = path . resolve ( string . format ( <string_literal> , file <identifiersep> name ) ) ; file file = file <identifiersep> path . to <identifiersep> file ( ) ; process <identifiersep> logger . log <identifiersep> info ( <string_literal> , file ) ; <ect>
process <identifiersep> logger . log <identifiersep> info ( <string_literal> , file ) ; step <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } public void write <identifiersep> trace <identifiersep> plan <identifiersep> steps ( string directory <identifiersep> name , flow <identifiersep> step <identifiersep> graph step <identifiersep> graph ) { if ( step <identifiersep> graph == null ) { <LOG> return ; } iterator < flow <identifiersep> step > iterator = step <identifiersep> graph . get <identifiersep> topological <identifiersep> iterator ( ) ; while ( iterator . has <identifiersep> next ( ) ) write <identifiersep> plan ( iterator . next ( ) , directory <identifiersep> name ) ; } private void write <identifiersep> plan ( flow <identifiersep> step flow <identifiersep> step , string directory <identifiersep> name ) { <ect>
process <identifiersep> logger . log <identifiersep> info ( <string_literal> , file ) ; try ( print <identifiersep> writer writer = new print <identifiersep> writer ( file ) ) { writer . println ( <string_literal> ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } public void write <identifiersep> stats ( planner <identifiersep> context planner <identifiersep> context , rule <identifiersep> result rule <identifiersep> result ) { path path = get <identifiersep> plan <identifiersep> stats <identifiersep> path ( ) ; if ( path == null ) return ; file file = path . resolve ( string . format ( <string_literal> , rule <identifiersep> result . get <identifiersep> registry ( ) . get <identifiersep> name ( ) , rule <identifiersep> result . get <identifiersep> result <identifiersep> status ( ) ) ) . to <identifiersep> file ( ) ; <ect>
writer . format ( <string_literal> , empty <identifiersep> or <identifiersep> value ( flow . get <identifiersep> platform <identifiersep> info ( ) ) ) ; writer . format ( <string_literal> , empty <identifiersep> or <identifiersep> value ( app <identifiersep> props . get <identifiersep> application <identifiersep> frameworks ( config <identifiersep> as <identifiersep> properties ) ) ) ; writer . println ( ) ; rule <identifiersep> result . write <identifiersep> stats ( writer ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } private static string empty <identifiersep> or <identifiersep> value ( object value ) { if ( value == null ) return <string_literal> ; if ( util . is <identifiersep> empty ( value . to <identifiersep> string ( ) ) ) return <string_literal> ; <ect>
element <identifiersep> graph = ( flow <identifiersep> element <identifiersep> graph ) element <identifiersep> graph . copy <identifiersep> element <identifiersep> graph ( ) ; scope <identifiersep> resolver . resolve <identifiersep> fields ( element <identifiersep> graph ) ; rule <identifiersep> result . set <identifiersep> level <identifiersep> results ( process <identifiersep> level . assembly , rule <identifiersep> result . initial <identifiersep> assembly , element <identifiersep> graph ) ; } public rule <identifiersep> result execute <identifiersep> rule <identifiersep> phase ( plan <identifiersep> phase phase , planner <identifiersep> context planner <identifiersep> context , rule <identifiersep> result rule <identifiersep> result ) { process <identifiersep> logger logger = planner <identifiersep> context . get <identifiersep> logger ( ) ; <LOG> linked <identifiersep> list < rule > rules = registry . get <identifiersep> rules <identifiersep> for ( phase ) ; write <identifiersep> phase <identifiersep> init <identifiersep> plan ( phase , rule <identifiersep> result ) ; try { <comment> <ect>
break ; case partition : perform <identifiersep> partition ( planner <identifiersep> context , rule <identifiersep> result , phase , rule ) ; break ; } } catch ( unsupported <identifiersep> plan <identifiersep> exception exception ) { <LOG> throw new unsupported <identifiersep> plan <identifiersep> exception ( rule , exception ) ; } catch ( planner <identifiersep> exception exception ) { logger . log <identifiersep> debug ( <string_literal> , rule , exception . get <identifiersep> message ( ) ) ; throw exception ; <comment> <ect>
catch ( planner <identifiersep> exception exception ) { logger . log <identifiersep> debug ( <string_literal> , rule , exception . get <identifiersep> message ( ) ) ; throw exception ; <comment> <LOG> throw new planner <identifiersep> exception ( registry , phase , rule , exception ) ; } finally { long end = system . current <identifiersep> time <identifiersep> millis ( ) ; rule <identifiersep> result . set <identifiersep> rule <identifiersep> duration ( rule , begin , end ) ; logger . log <identifiersep> debug ( <string_literal> , rule ) ; <ect>
long end = system . current <identifiersep> time <identifiersep> millis ( ) ; rule <identifiersep> result . set <identifiersep> rule <identifiersep> duration ( rule , begin , end ) ; logger . log <identifiersep> debug ( <string_literal> , rule ) ; } } return rule <identifiersep> result ; } finally { <LOG> write <identifiersep> phase <identifiersep> result <identifiersep> plan ( phase , rule <identifiersep> result ) ; } } protected void perform <identifiersep> mutation ( planner <identifiersep> context planner <identifiersep> context , rule <identifiersep> result rule <identifiersep> result , plan <identifiersep> phase phase , rule rule ) { if ( rule instanceof graph <identifiersep> transformer ) perform <identifiersep> transform ( planner <identifiersep> context , rule <identifiersep> result , phase , ( graph <identifiersep> transformer ) rule ) ; else if ( rule instanceof graph <identifiersep> assert ) <ect>
if ( sink <identifiersep> modified == - 1l ) log <identifiersep> info ( <string_literal> ) ; if ( sink <identifiersep> modified == 0l ) log <identifiersep> info ( <string_literal> ) ; else <LOG> } return sink <identifiersep> modified ; } protected throwable prepare <identifiersep> resources ( ) { throwable throwable = prepare <identifiersep> resources ( get <identifiersep> source <identifiersep> taps ( ) , false ) ; if ( throwable == null ) throwable = prepare <identifiersep> resources ( get <identifiersep> sink <identifiersep> taps ( ) , true ) ; <ect>
( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> completed ( this ) ; } } protected void fire <identifiersep> on <identifiersep> throwable ( throwable throwable ) { if ( has <identifiersep> listeners ( ) ) { <LOG> for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> throwable ( this , throwable ) ; } } protected void fire <identifiersep> on <identifiersep> stopping ( ) { if ( has <identifiersep> listeners ( ) ) <ect>
( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> stopping ( this ) ; } } protected void fire <identifiersep> on <identifiersep> starting ( ) { if ( has <identifiersep> listeners ( ) ) { <LOG> for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> starting ( this ) ; } } protected void fire <identifiersep> on <identifiersep> running ( ) { if ( has <identifiersep> listeners ( ) ) <ect>
{ handle <identifiersep> throwable ( throwable ) ; } return false ; } private void handle <identifiersep> throwable ( throwable throwable ) { this . throwable = throwable ; <LOG> } public boolean equals ( object object ) { if ( object instanceof base <identifiersep> flow <identifiersep> step . safe <identifiersep> flow <identifiersep> step <identifiersep> listener ) return flow <identifiersep> step <identifiersep> listener . equals ( ( ( base <identifiersep> flow <identifiersep> step . safe <identifiersep> flow <identifiersep> step <identifiersep> listener ) object ) . flow <identifiersep> step <identifiersep> listener ) ; return flow <identifiersep> step <identifiersep> listener . equals ( object ) ; } public int hash <identifiersep> code ( ) <ect>
throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + flow <identifiersep> element ) ; } } private tap make <identifiersep> temp <identifiersep> tap ( flow <identifiersep> element <identifiersep> graph graph , pipe pipe , string default <identifiersep> decorator <identifiersep> class <identifiersep> name ) { tap checkpoint <identifiersep> tap = graph . get <identifiersep> checkpoints <identifiersep> map ( ) . get ( pipe . get <identifiersep> name ( ) ) ; if ( checkpoint <identifiersep> tap != null ) { <LOG> checkpoint <identifiersep> tap = decorate <identifiersep> tap ( pipe , checkpoint <identifiersep> tap , flow <identifiersep> connector <identifiersep> props . checkpoint <identifiersep> tap <identifiersep> decorator <identifiersep> class , null ) ; } if ( checkpoint <identifiersep> tap == null ) { <comment> <ect>
writer writer = new file <identifiersep> writer ( filename ) ; new dot <identifiersep> exporter ( new integer <identifiersep> name <identifiersep> provider ( ) , new string <identifiersep> name <identifiersep> provider ( ) , new string <identifiersep> edge <identifiersep> name <identifiersep> provider ( ) ) . export ( writer , get <identifiersep> graph ( ) ) ; writer . close ( ) ; util . write <identifiersep> pdf ( filename ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } public static scope <identifiersep> expression unwind ( scope <identifiersep> expression scope <identifiersep> expression ) { if ( scope <identifiersep> expression instanceof delegate <identifiersep> scope <identifiersep> expression ) return ( ( delegate <identifiersep> scope <identifiersep> expression ) scope <identifiersep> expression ) . delegate ; return scope <identifiersep> expression ; } private static class delegate <identifiersep> scope <identifiersep> expression extends scope <identifiersep> expression <ect>
transformed . set <identifiersep> end <identifiersep> graph ( result ) ; return transformed ; } protected e transform ( process <identifiersep> logger process <identifiersep> logger , transformed < e > transformed , e graph , int max <identifiersep> depth , int current <identifiersep> depth ) { if ( current <identifiersep> depth == max <identifiersep> depth ) { <LOG> return graph ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) ) ; element <identifiersep> graph prepared = prepare <identifiersep> for <identifiersep> match ( process <identifiersep> logger , transformed , graph ) ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , prepared != null ) ; <ect>
process <identifiersep> logger . log <identifiersep> info ( <string_literal> , current <identifiersep> depth ) ; return graph ; } process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) ) ; element <identifiersep> graph prepared = prepare <identifiersep> for <identifiersep> match ( process <identifiersep> logger , transformed , graph ) ; <LOG> if ( prepared == null ) return graph ; set < flow <identifiersep> element > exclusions = add <identifiersep> exclusions ( graph ) ; match match ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , ! find <identifiersep> all <identifiersep> primaries ) ; <ect>
<comment> <LOG> process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) ) ; boolean transform <identifiersep> result = transform <identifiersep> graph <identifiersep> in <identifiersep> place <identifiersep> using <identifiersep> safe ( transformed , graph , match ) ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , transform <identifiersep> result ) ; if ( ! transform <identifiersep> result ) <ect>
process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) ) ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) ) ; boolean transform <identifiersep> result = transform <identifiersep> graph <identifiersep> in <identifiersep> place <identifiersep> using <identifiersep> safe ( transformed , graph , match ) ; <LOG> if ( ! transform <identifiersep> result ) return graph ; transformed . add <identifiersep> recursion <identifiersep> transform ( graph ) ; if ( ! requires <identifiersep> recursive <identifiersep> search ( ) ) return graph ; return transform ( process <identifiersep> logger , transformed , graph , max <identifiersep> depth , ++ current <identifiersep> depth ) ; <ect>
{ while ( prev <identifiersep> n2 < n2 && core2 [ prev <identifiersep> n2 ] != null <identifiersep> node ) prev <identifiersep> n2 ++ ; } if ( prev <identifiersep> n1 < n1 && prev <identifiersep> n2 < n2 ) { <LOG> return new pair < > ( prev <identifiersep> n1 , prev <identifiersep> n2 ) ; } return null ; } protected boolean are <identifiersep> compatible <identifiersep> edges ( int v1 , int v2 , int v3 , int v4 ) { list < scope <identifiersep> expression > matchers = match <identifiersep> graph . get <identifiersep> all <identifiersep> edges <identifiersep> list ( v1 , v2 ) ; <comment> <ect>
flow <identifiersep> element lhs = element <identifiersep> graph . get <identifiersep> delegate ( ) . get <identifiersep> edge <identifiersep> source ( result ) ; int lhs <identifiersep> index = element <identifiersep> graph . get <identifiersep> index ( lhs ) ; flow <identifiersep> element rhs = element <identifiersep> graph . get <identifiersep> delegate ( ) . get <identifiersep> edge <identifiersep> target ( result ) ; int rhs <identifiersep> index = element <identifiersep> graph . get <identifiersep> index ( rhs ) ; log . debug ( <string_literal> , lhs <identifiersep> index , lhs , rhs <identifiersep> index , rhs , result . print <identifiersep> simple ( ) ) ; } for ( scope <identifiersep> expression matcher : matchers ) <LOG> } public static collection < scope > are <identifiersep> compatible <identifiersep> edges ( planner <identifiersep> context planner <identifiersep> context , element <identifiersep> graph element <identifiersep> graph , list < scope <identifiersep> expression > matchers , list < scope > scopes ) { <comment> <ect>
if ( core2 [ other2 ] != null <identifiersep> node ) { int other1 = core2 [ other2 ] ; if ( ! match <identifiersep> graph . contains <identifiersep> edge ( node1 , other1 ) ) { <LOG> return false ; } } else { if ( in2 [ other2 ] != 0 ) termin2 ++ ; if ( out2 [ other2 ] != 0 ) <ect>
if ( out2 [ other2 ] != 0 ) termout2 ++ ; if ( in2 [ other2 ] == 0 && out2 [ other2 ] == 0 ) new2 ++ ; } } boolean is <identifiersep> feasible = termin1 < = termin2 && termout1 < = termout2 && new1 < = new2 ; <LOG> return is <identifiersep> feasible ; } public void add <identifiersep> pair ( int node1 , int node2 ) { assert node1 < n1 ; assert node2 < n2 ; assert core <identifiersep> len < n1 ; <ect>
boolean found = false ; while ( ! found && ( next = state . next <identifiersep> pair ( n1 , n2 ) ) != null ) { n1 = next . get <identifiersep> lhs ( ) ; n2 = next . get <identifiersep> rhs ( ) ; <LOG> boolean feasible <identifiersep> pair = state . is <identifiersep> feasible <identifiersep> pair ( n1 , n2 ) ; log . trace ( <string_literal> , n1 , n2 ) ; if ( feasible <identifiersep> pair ) { state copy = state . copy ( ) ; <ect>
{ for ( map . entry < integer , integer > entry : copy . get <identifiersep> vertex <identifiersep> mapping ( ) . entry <identifiersep> set ( ) ) { if ( vertex <identifiersep> map . contains <identifiersep> key ( entry . get <identifiersep> key ( ) ) && ! vertex <identifiersep> map . get ( entry . get <identifiersep> key ( ) ) . equals ( entry . get <identifiersep> value ( ) ) ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <LOG> vertex <identifiersep> map . put <identifiersep> all ( copy . get <identifiersep> vertex <identifiersep> mapping ( ) ) ; log . trace ( <string_literal> , vertex <identifiersep> map ) ; } else { <ect>
try { collector . close ( ) ; flow <identifiersep> process . increment ( counters . paths <identifiersep> closed , 1 ) ; } catch ( exception exception ) { <LOG> boolean fail <identifiersep> on <identifiersep> error = false ; object fail <identifiersep> property = flow <identifiersep> process . get <identifiersep> property ( partition <identifiersep> tap <identifiersep> props . fail <identifiersep> on <identifiersep> close ) ; if ( fail <identifiersep> property != null ) fail <identifiersep> on <identifiersep> error = boolean . parse <identifiersep> boolean ( fail <identifiersep> property . to <identifiersep> string ( ) ) ; if ( fail <identifiersep> on <identifiersep> error ) throw new tap <identifiersep> exception ( exception ) ; <ect>
cascade <identifiersep> listener . on <identifiersep> completed ( this ) ; } } private void fire <identifiersep> on <identifiersep> throwable ( ) { if ( has <identifiersep> listeners ( ) ) { <LOG> boolean is <identifiersep> handled = false ; for ( cascade <identifiersep> listener cascade <identifiersep> listener : get <identifiersep> listeners ( ) ) is <identifiersep> handled = cascade <identifiersep> listener . on <identifiersep> throwable ( this , throwable ) || is <identifiersep> handled ; if ( is <identifiersep> handled ) throwable = null ; } } protected void fire <identifiersep> on <identifiersep> stopping ( ) <ect>
cascade <identifiersep> listener . on <identifiersep> stopping ( this ) ; } } protected void fire <identifiersep> on <identifiersep> starting ( ) { if ( has <identifiersep> listeners ( ) ) { <LOG> for ( cascade <identifiersep> listener cascade <identifiersep> listener : get <identifiersep> listeners ( ) ) cascade <identifiersep> listener . on <identifiersep> starting ( this ) ; } } private cascading <identifiersep> services get <identifiersep> cascading <identifiersep> services ( ) { if ( cascading <identifiersep> services == null ) cascading <identifiersep> services = new cascading <identifiersep> services ( properties ) ; <ect>
int num <identifiersep> local <identifiersep> flows = num <identifiersep> local <identifiersep> flows ( ) ; boolean run <identifiersep> flows <identifiersep> local = num <identifiersep> local <identifiersep> flows > 1 ; if ( run <identifiersep> flows <identifiersep> local ) num <identifiersep> threads = 1 ; { <LOG> log <identifiersep> info ( <string_literal> + jobs <identifiersep> map . size ( ) ) ; log <identifiersep> info ( <string_literal> + num <identifiersep> threads ) ; } list < future < throwable > > futures = spawn <identifiersep> strategy . start ( this , num <identifiersep> threads , jobs <identifiersep> map . values ( ) ) ; for ( future < throwable > future : futures ) { throwable = future . get ( ) ; <ect>
if ( run <identifiersep> flows <identifiersep> local ) num <identifiersep> threads = 1 ; { log <identifiersep> info ( <string_literal> + ( num <identifiersep> threads != 1 ) ) ; log <identifiersep> info ( <string_literal> + jobs <identifiersep> map . size ( ) ) ; <LOG> } list < future < throwable > > futures = spawn <identifiersep> strategy . start ( this , num <identifiersep> threads , jobs <identifiersep> map . values ( ) ) ; for ( future < throwable > future : futures ) { throwable = future . get ( ) ; if ( throwable != null ) { <ect>
predecessors . add ( ( cascade <identifiersep> job ) jobs <identifiersep> map . get ( predecessor . get <identifiersep> name ( ) ) ) ; job . init ( predecessors ) ; } } } private void handle <identifiersep> executor <identifiersep> shutdown ( ) { if ( spawn <identifiersep> strategy . is <identifiersep> completed ( this ) ) return ; <LOG> try { spawn <identifiersep> strategy . complete ( this , <number_literal> * <number_literal> , time <identifiersep> unit . seconds ) ; } catch ( interrupted <identifiersep> exception exception ) { <comment> <ect>
catch ( interrupted <identifiersep> exception exception ) { <comment> <LOG> synchronized ( jobs <identifiersep> map ) { list < callable < throwable > > jobs = new array <identifiersep> list < callable < throwable > > ( jobs <identifiersep> map . values ( ) ) ; collections . reverse ( jobs ) ; for ( callable < throwable > callable : jobs ) ( ( cascade <identifiersep> job ) callable ) . stop ( ) ; <ect>
{ return object . flow . get <identifiersep> name ( ) . replace <identifiersep> all ( <string_literal> , <string_literal> ) . replace <identifiersep> all ( <string_literal> , <string_literal> ) ; <comment> <LOG> } } @ override public string to <identifiersep> string ( ) { return get <identifiersep> name ( ) ; } @ override <ect>
public void log <identifiersep> info ( string message , object . . . arguments ) { log . info ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> debug ( string message , object . . . arguments ) { <LOG> } @ override public void log <identifiersep> warn ( string message ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message ) ; } @ override public void log <identifiersep> warn ( string message , throwable throwable ) <ect>
public void log <identifiersep> warn ( string message ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message ) ; } @ override public void log <identifiersep> warn ( string message , throwable throwable ) { <LOG> } @ override public void log <identifiersep> warn ( string message , object . . . arguments ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> error ( string message , object . . . arguments ) <ect>
public void log <identifiersep> warn ( string message , object . . . arguments ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> error ( string message , object . . . arguments ) { <LOG> } @ override public void log <identifiersep> error ( string message , throwable throwable ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , throwable ) ; } <comment> protected class cascade <identifiersep> job implements callable < throwable > <ect>
return null ; } if ( stop || cascade <identifiersep> stats . is <identifiersep> finished ( ) ) return null ; try { <LOG> if ( flow <identifiersep> skip <identifiersep> strategy == null ? flow . is <identifiersep> skip <identifiersep> flow ( ) : flow <identifiersep> skip <identifiersep> strategy . skip <identifiersep> flow ( flow ) ) { log <identifiersep> info ( <string_literal> + flow . get <identifiersep> name ( ) ) ; flow . get <identifiersep> flow <identifiersep> stats ( ) . mark <identifiersep> skipped ( ) ; flows . fire <identifiersep> on <identifiersep> completed ( flow ) ; <ect>
flow . get <identifiersep> flow <identifiersep> stats ( ) . mark <identifiersep> skipped ( ) ; flows . fire <identifiersep> on <identifiersep> completed ( flow ) ; return null ; } flow . prepare ( ) ; <comment> <LOG> } catch ( throwable exception ) { failed = true ; log <identifiersep> warn ( <string_literal> + flow . get <identifiersep> name ( ) , exception ) ; cascade <identifiersep> exception cascade <identifiersep> exception = new cascade <identifiersep> exception ( <string_literal> + flow . get <identifiersep> name ( ) , exception ) ; if ( ! cascade <identifiersep> stats . is <identifiersep> finished ( ) ) <ect>
public void init ( list < cascade <identifiersep> job > predecessors ) { this . predecessors = predecessors ; } public void stop ( ) { <LOG> stop = true ; if ( flow != null ) flow . stop ( ) ; } public boolean is <identifiersep> successful ( ) { try <ect>
{ handle <identifiersep> throwable ( throwable ) ; } return false ; } private void handle <identifiersep> throwable ( throwable throwable ) { this . throwable = throwable ; <LOG> <comment> <ect>
log . debug ( <string_literal> , source ) ; list < string > sinks = graphs . successor <identifiersep> list <identifiersep> of ( identifier <identifiersep> graph , source ) ; for ( string sink : sinks ) { <LOG> flow flow = identifier <identifiersep> graph . get <identifiersep> edge ( source , sink ) . flow ; add <identifiersep> vertex ( flow ) ; set < base <identifiersep> flow . flow <identifiersep> holder > previous = identifier <identifiersep> graph . incoming <identifiersep> edges <identifiersep> of ( source ) ; for ( base <identifiersep> flow . flow <identifiersep> holder previous <identifiersep> flow : previous ) { add <identifiersep> vertex ( previous <identifiersep> flow . flow ) ; <ect>
throw ( flow <identifiersep> exception ) exception . get <identifiersep> cause ( ) ; throw new flow <identifiersep> exception ( exception . get <identifiersep> cause ( ) ) ; } catch ( timeout <identifiersep> exception exception ) { fetch <identifiersep> attempts ++ ; if ( fetch <identifiersep> attempts >= max <identifiersep> fetch <identifiersep> attempts ) <LOG> else log . warn ( <string_literal> , timeout , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) ) ; } has <identifiersep> captured <identifiersep> final <identifiersep> counters = is <identifiersep> process <identifiersep> finished && success ; return cached <identifiersep> counters ; } private counters fetch <identifiersep> counters ( job <identifiersep> status running <identifiersep> job ) throws interrupted <identifiersep> exception , execution <identifiersep> exception , timeout <identifiersep> exception { <ect>
{ if ( ! get <identifiersep> type ( ) . is <identifiersep> child ( depth ) || ! is <identifiersep> detail <identifiersep> stale ( ) ) return ; boolean success = capture <identifiersep> child <identifiersep> detail <identifiersep> internal ( ) ; mark <identifiersep> detail <identifiersep> captured ( ) ; <comment> <LOG> has <identifiersep> captured <identifiersep> final <identifiersep> detail = finished && success && all <identifiersep> children <identifiersep> finished ; if ( all <identifiersep> children <identifiersep> finished ) log <identifiersep> info ( <string_literal> , slice <identifiersep> stats <identifiersep> map . size ( ) , has <identifiersep> captured <identifiersep> final <identifiersep> detail ( ) ) ; } } <comment> <ect>
{ <comment> <LOG> } } } <ect>
pipe [ ] current ; if ( tail instanceof sub <identifiersep> assembly ) current = ( ( sub <identifiersep> assembly ) tail ) . previous ; else current = tail . get <identifiersep> previous ( ) ; if ( current == null && tail instanceof sub <identifiersep> assembly ) <LOG> set <identifiersep> parent ( stop <identifiersep> set , current ) ; } } <comment> <ect>
return make <identifiersep> result ( last <identifiersep> values ) ; } private tuple make <identifiersep> result ( tuple [ ] last <identifiersep> values ) { tuples . as <identifiersep> modifiable ( result ) ; result = result <identifiersep> builder . make <identifiersep> result ( last <identifiersep> values ) ; <LOG> return result ; } public void remove ( ) { <comment> <ect>
protected synchronized class < ? > load <identifiersep> class ( string name , boolean resolve ) throws class <identifiersep> not <identifiersep> found <identifiersep> exception { for ( string exclusion : exclusions ) { if ( name . starts <identifiersep> with ( exclusion ) ) { <LOG> return super . load <identifiersep> class ( name , resolve ) ; } } try { log . debug ( <string_literal> , name ) ; return child <identifiersep> class <identifiersep> loader . load <identifiersep> class ( name ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) <ect>
{ <comment> <LOG> return null ; } try { class < provider > type = ( class < provider > ) get <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( class <identifiersep> name ) ; return type . new <identifiersep> instance ( ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) <ect>
return type . new <identifiersep> instance ( ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { log . error ( <string_literal> , class <identifiersep> name , exception ) ; } catch ( illegal <identifiersep> access <identifiersep> exception exception ) { <LOG> } catch ( instantiation <identifiersep> exception exception ) { log . error ( <string_literal> , class <identifiersep> name , exception ) ; } return null ; } private synchronized class <identifiersep> loader get <identifiersep> class <identifiersep> loader ( ) { <ect>
return class <identifiersep> loader ; if ( library <identifiersep> url == null ) { class <identifiersep> loader = thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) ; } else { <LOG> class <identifiersep> loader = new child <identifiersep> first <identifiersep> url <identifiersep> class <identifiersep> loader ( exclusions , library <identifiersep> url ) ; } return class <identifiersep> loader ; } } <ect>
codecs = default <identifiersep> codecs ; class codec <identifiersep> class = null ; for ( string codec : codecs . split ( <string_literal> ) ) { try { <LOG> codec <identifiersep> class = thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( codec ) . as <identifiersep> subclass ( sub <identifiersep> class ) ; if ( codec <identifiersep> class != null ) { log . info ( <string_literal> , codec ) ; break ; } } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) <ect>
break ; } } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { <comment> <LOG> return null ; } return codec <identifiersep> class ; } private spill <identifiersep> strategy spill <identifiersep> strategy ; <comment> private list < file > files = collections . empty <identifiersep> list ; <comment> <ect>
else element <identifiersep> writer . write ( this , element ) ; } protected abstract void write <identifiersep> int <identifiersep> internal ( int value ) throws io <identifiersep> exception ; @ override public void close ( ) throws io <identifiersep> exception { <LOG> try { super . close ( ) ; } finally { if ( element <identifiersep> writer != null ) <ect>
{ get <identifiersep> next ( ) ; } catch ( exception exception ) { if ( permitted <identifiersep> exceptions . contains ( exception . get <identifiersep> class ( ) ) ) { <LOG> return false ; } current <identifiersep> exception = new tuple <identifiersep> exception ( <string_literal> + loggable <identifiersep> identifier . get ( ) , exception ) ; return true ; } if ( ! has <identifiersep> waiting ) is <identifiersep> complete = true ; return ! is <identifiersep> complete ; <ect>
private void assert <identifiersep> graphs ( simple <identifiersep> directed <identifiersep> graph < string , object > full , simple <identifiersep> directed <identifiersep> graph < string , object > contracted , simple <identifiersep> directed <identifiersep> graph < string , object > result ) { <comment> <LOG> simple <identifiersep> directed <identifiersep> graph < string , object > clone = new simple <identifiersep> directed <identifiersep> graph < > ( object . class ) ; graphs . add <identifiersep> graph ( clone , subgraph ) ; assert <identifiersep> equals ( result , clone ) ; } } <ect>
new object [ ] { spillable . get <identifiersep> grouping ( ) . print ( ) , num <identifiersep> files + 1 , spill <identifiersep> reason } ) ; runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; } <LOG> flow <identifiersep> process . increment ( spill . num <identifiersep> spills <identifiersep> written , 1 ) ; flow <identifiersep> process . increment ( spill . num <identifiersep> tuples <identifiersep> spilled , spill <identifiersep> size ) ; } @ override public void notify <identifiersep> write <identifiersep> spill <identifiersep> end ( spillable <identifiersep> tuple <identifiersep> list spillable <identifiersep> tuple <identifiersep> list , long duration ) { flow <identifiersep> process . increment ( spill . duration <identifiersep> millis <identifiersep> written , duration ) ; <ect>
new object [ ] { join <identifiersep> field . print <identifiersep> verbose ( ) , spillable . get <identifiersep> grouping ( ) . print ( ) , num <identifiersep> files + 1 , spill <identifiersep> reason } ) ; runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; } <LOG> flow <identifiersep> process . increment ( spill . num <identifiersep> spills <identifiersep> written , 1 ) ; flow <identifiersep> process . increment ( spill . num <identifiersep> tuples <identifiersep> spilled , spill <identifiersep> size ) ; } @ override public void notify <identifiersep> write <identifiersep> spill <identifiersep> end ( spillable <identifiersep> tuple <identifiersep> list spillable <identifiersep> tuple <identifiersep> list , long duration ) { flow <identifiersep> process . increment ( spill . duration <identifiersep> millis <identifiersep> written , duration ) ; <ect>
{ tap source = new lfs ( new text <identifiersep> line ( ) , <string_literal> ) ; tap sink = new hfs ( new text <identifiersep> line ( ) , <string_literal> , sink <identifiersep> mode . replace ) ; pipe pipe = new pipe ( <string_literal> ) ; map < object , object > props = get <identifiersep> properties ( ) ; flow flow1 = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( props ) . connect ( source , sink , pipe ) ; <LOG> assert <identifiersep> not <identifiersep> null ( <string_literal> , flow1 . get <identifiersep> id ( ) ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , flow1 . get <identifiersep> property ( <string_literal> ) ) ; flow flow2 = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( props ) . connect ( source , sink , pipe ) ; assert <identifiersep> true ( <string_literal> , ! flow1 . get <identifiersep> id ( ) . equals <identifiersep> ignore <identifiersep> case ( flow2 . get <identifiersep> id ( ) ) ) ; } @ test public void test <identifiersep> copy <identifiersep> config ( ) throws exception <ect>
assert <identifiersep> equals <identifiersep> size ( <string_literal> , <number_literal> , tap . get <identifiersep> child <identifiersep> identifiers ( job <identifiersep> conf , 1 , true ) ) ; assert <identifiersep> equals <identifiersep> size ( <string_literal> , <number_literal> , tap . get <identifiersep> child <identifiersep> identifiers ( job <identifiersep> conf , 1 , false ) ) ; assert <identifiersep> equals <identifiersep> size ( <string_literal> , 1 , tap . get <identifiersep> child <identifiersep> identifiers ( job <identifiersep> conf , 0 , true ) ) ; assert <identifiersep> equals <identifiersep> size ( <string_literal> , 1 , tap . get <identifiersep> child <identifiersep> identifiers ( job <identifiersep> conf , 0 , false ) ) ; } public void assert <identifiersep> equals <identifiersep> size ( string message , int expected , string [ ] actual ) { <LOG> if ( expected == - 1 ) return ; assert <identifiersep> equals ( expected , actual . length ) ; } private void write <identifiersep> file <identifiersep> to ( string path ) throws io <identifiersep> exception { hfs tap = new hfs ( new text <identifiersep> line ( new fields ( <string_literal> , <string_literal> ) ) , get <identifiersep> output <identifiersep> path ( path ) ) ; <ect>
pipe <identifiersep> upper = new each ( pipe <identifiersep> upper , new insert <identifiersep> test <identifiersep> text ( new fields ( <string_literal> ) , <string_literal> , false ) , fields . all ) ; pipe splice = new co <identifiersep> group ( pipe <identifiersep> lower , new fields ( <string_literal> ) , pipe <identifiersep> upper , new fields ( <string_literal> ) , fields . size ( <number_literal> ) ) ; map < object , object > properties = get <identifiersep> properties ( ) ; properties . put ( spillable <identifiersep> props . list <identifiersep> threshold , 1 ) ; <comment> <LOG> <comment> <ect>
{ test <identifiersep> text next <identifiersep> target = ( test <identifiersep> text ) iterator . next ( ) . get <identifiersep> object ( <string_literal> ) ; string next = next <identifiersep> target == null ? null : next <identifiersep> target . value ; if ( value != null && value . compare <identifiersep> to ( next ) >= 0 ) fail ( <string_literal> + value + <string_literal> + value ) ; value = next ; <LOG> } iterator . close ( ) ; } @ test public void test <identifiersep> big <identifiersep> decimal ( ) throws exception { get <identifiersep> platform ( ) . copy <identifiersep> from <identifiersep> local ( input <identifiersep> file <identifiersep> apache ) ; fields source <identifiersep> fields = new fields ( <string_literal> , <string_literal> ) . apply <identifiersep> types ( coercions . big <identifiersep> decimal , string . class ) ; <ect>
catch ( illegal <identifiersep> access <identifiersep> exception exception ) { caught <identifiersep> exception = exception ; } catch ( io <identifiersep> exception exception ) { caught <identifiersep> exception = exception ; } <LOG> return null ; } public static string encode <identifiersep> bytes ( byte [ ] bytes ) { try { return new string ( base64 . encode <identifiersep> base64 ( bytes ) , encoding ) ; <ect>
manifest manifest ; try { manifest = new manifest ( new url ( manifest <identifiersep> path ) . open <identifiersep> stream ( ) ) ; } catch ( io <identifiersep> exception exception ) { <LOG> return new platform <identifiersep> info ( platform <identifiersep> name , null , parsed <identifiersep> version ) ; } attributes attributes = manifest . get <identifiersep> attributes ( attribute <identifiersep> path ) ; if ( attributes == null ) attributes = manifest . get <identifiersep> main <identifiersep> attributes ( ) ; if ( attributes == null ) { <ect>
for ( map . entry < path , path > entry : copy <identifiersep> paths . entry <identifiersep> set ( ) ) { path local <identifiersep> path = entry . get <identifiersep> key ( ) ; path remote <identifiersep> path = entry . get <identifiersep> value ( ) ; try { <LOG> remote <identifiersep> fs . copy <identifiersep> from <identifiersep> local <identifiersep> file ( local <identifiersep> path , remote <identifiersep> path ) ; if ( ! sync <identifiersep> times ) { timestamp <identifiersep> map . put ( remote <identifiersep> path . get <identifiersep> name ( ) , remote <identifiersep> fs . get <identifiersep> file <identifiersep> status ( remote <identifiersep> path ) . get <identifiersep> modification <identifiersep> time ( ) ) ; continue ; } } catch ( io <identifiersep> exception exception ) <ect>
if ( tez <identifiersep> local != null ) return tez <identifiersep> local . equals ( <string_literal> ) ; <comment> <LOG> return false ; } return hadoop1 . equals ( <string_literal> ) ; } public static boolean is <identifiersep> yarn ( configuration conf ) { return conf . get ( <string_literal> ) != null ; } public static void set <identifiersep> local ( configuration conf ) <ect>
return new file <identifiersep> status ( length , false , 1 , get <identifiersep> default <identifiersep> block <identifiersep> size ( ) , modified , path ) ; } private void debug <identifiersep> connection ( http <identifiersep> url <identifiersep> connection connection ) throws io <identifiersep> exception { { log . debug ( <string_literal> , connection . get <identifiersep> url ( ) ) ; <LOG> log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> code ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> message ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> content <identifiersep> length ( ) ) ; } } private url make <identifiersep> url ( path path ) throws io <identifiersep> exception { if ( path . to <identifiersep> string ( ) . starts <identifiersep> with ( scheme ) ) <ect>
{ { log . debug ( <string_literal> , connection . get <identifiersep> url ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> request <identifiersep> method ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> code ( ) ) ; <LOG> log . debug ( <string_literal> , connection . get <identifiersep> content <identifiersep> length ( ) ) ; } } private url make <identifiersep> url ( path path ) throws io <identifiersep> exception { if ( path . to <identifiersep> string ( ) . starts <identifiersep> with ( scheme ) ) return uri . create ( path . to <identifiersep> string ( ) ) . to <identifiersep> url ( ) ; try <ect>
count += result ; return result ; } @ override public void close ( ) throws io <identifiersep> exception { input <identifiersep> stream . close ( ) ; <LOG> if ( digest <identifiersep> hex == null ) return ; string digest <identifiersep> hex = new string ( hex . encode <identifiersep> hex ( ( ( digest <identifiersep> input <identifiersep> stream ) input <identifiersep> stream ) . get <identifiersep> message <identifiersep> digest ( ) . digest ( ) ) ) ; if ( ! digest <identifiersep> hex . equals ( this . digest <identifiersep> hex ) ) { string message = <string_literal> + this . digest <identifiersep> hex + <string_literal> + digest <identifiersep> hex + <string_literal> ; <ect>
for ( int i = 0 ; i < keys . length ; i ++ ) config . put ( keys [ i ] , values [ i ] ) ; { log . debug ( <string_literal> ) ; for ( map . entry < string , string > entry : config . entry <identifiersep> set ( ) ) <LOG> } job <identifiersep> conf current <identifiersep> conf = hadoop <identifiersep> util . merge <identifiersep> conf ( job <identifiersep> conf , config , false ) ; try { input <identifiersep> split = ( input <identifiersep> split ) reflection <identifiersep> utils . new <identifiersep> instance ( current <identifiersep> conf . get <identifiersep> class <identifiersep> by <identifiersep> name ( split <identifiersep> type ) , current <identifiersep> conf ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exp ) { <ect>
hadoop18tap <identifiersep> util . setup <identifiersep> task ( conf ) ; int partition = conf . get <identifiersep> int ( <string_literal> , conf . get <identifiersep> int ( <string_literal> , 0 ) ) ; if ( prefix != null ) filename = string . format ( filename <identifiersep> pattern , prefix , <string_literal> , partition , sequence ) ; else filename = string . format ( filename <identifiersep> pattern , <string_literal> , <string_literal> , partition , sequence ) ; } <LOG> writer = output <identifiersep> format . get <identifiersep> record <identifiersep> writer ( null , as <identifiersep> job <identifiersep> conf <identifiersep> instance ( conf ) , filename , get <identifiersep> reporter ( ) ) ; } private reporter get <identifiersep> reporter ( ) { reporter reporter = reporter . null ; if ( flow <identifiersep> process instanceof map <identifiersep> red ) reporter = ( ( map <identifiersep> red ) flow <identifiersep> process ) . get <identifiersep> reporter ( ) ; <comment> <ect>
{ try { if ( is <identifiersep> file <identifiersep> output <identifiersep> format ) log . info ( <string_literal> , new path ( tap . get <identifiersep> identifier ( ) , filename ) ) ; else <LOG> try { writer . close ( get <identifiersep> reporter ( ) ) ; } finally { if ( is <identifiersep> file <identifiersep> output <identifiersep> format ) <ect>
<comment> <LOG> reporter reporter = reporter . null ; if ( flow <identifiersep> process instanceof map <identifiersep> red ) reporter = ( ( map <identifiersep> red ) flow <identifiersep> process ) . get <identifiersep> reporter ( ) ; <comment> <ect>
if ( workpath == null ) return ; file <identifiersep> system fs = get <identifiersep> fs <identifiersep> safe ( conf , new path ( workpath ) ) ; if ( fs == null ) return ; string task <identifiersep> id = conf . get ( <string_literal> , conf . get ( <string_literal> ) ) ; <LOG> atomic <identifiersep> integer integer = path <identifiersep> counts . get ( workpath ) ; if ( integer == null ) { integer = new atomic <identifiersep> integer ( ) ; path <identifiersep> counts . put ( workpath , integer ) ; } integer . increment <identifiersep> and <identifiersep> get ( ) ; <ect>
return uri <identifiersep> scheme ; } protected uri make <identifiersep> uri <identifiersep> scheme ( configuration configuration ) { try { uri uri <identifiersep> scheme ; <LOG> uri uri = new path ( string <identifiersep> path ) . to <identifiersep> uri ( ) ; <comment> <ect>
if ( scheme <identifiersep> string != null && authority != null ) uri <identifiersep> scheme = new uri ( scheme <identifiersep> string + <string_literal> + uri . get <identifiersep> authority ( ) ) ; else if ( scheme <identifiersep> string != null ) uri <identifiersep> scheme = new uri ( scheme <identifiersep> string + <string_literal> ) ; else uri <identifiersep> scheme = get <identifiersep> default <identifiersep> file <identifiersep> system <identifiersep> uri <identifiersep> scheme ( configuration ) ; <LOG> return uri <identifiersep> scheme ; } catch ( uri <identifiersep> syntax <identifiersep> exception exception ) { throw new tap <identifiersep> exception ( <string_literal> + get <identifiersep> path ( ) , exception ) ; } } <comment> <ect>
<comment> <LOG> return get <identifiersep> file <identifiersep> system ( conf ) . mkdirs ( get <identifiersep> path ( ) ) ; } @ override public boolean delete <identifiersep> resource ( configuration conf ) throws io <identifiersep> exception { string full <identifiersep> identifier = get <identifiersep> full <identifiersep> identifier ( conf ) ; return delete <identifiersep> full <identifiersep> identifier ( conf , full <identifiersep> identifier ) ; <ect>
public void source <identifiersep> conf <identifiersep> init ( flow <identifiersep> process < ? extends configuration > process , configuration conf ) { if ( hadoop <identifiersep> util . is <identifiersep> local ( conf ) || tap . id ( this ) . equals ( conf . get ( <string_literal> ) ) || tap . id ( this ) . equals ( conf . get ( <string_literal> ) ) ) { <LOG> super . source <identifiersep> conf <identifiersep> init ( process , conf ) ; return ; } try { register <identifiersep> hfs ( process , conf , get <identifiersep> hfs ( ) ) ; } catch ( io <identifiersep> exception exception ) <ect>
for ( path path <identifiersep> to <identifiersep> find : paths ) { for ( path path : cached <identifiersep> files ) { if ( path . to <identifiersep> string ( ) . ends <identifiersep> with ( path <identifiersep> to <identifiersep> find . get <identifiersep> name ( ) ) ) { <LOG> taps . add ( new lfs ( get <identifiersep> scheme ( ) , path . to <identifiersep> string ( ) ) ) ; } } } if ( paths . is <identifiersep> empty ( ) ) <comment> <ect>
{ register <identifiersep> uri ( conf , hfs . get <identifiersep> path ( ) ) ; } hfs . source <identifiersep> conf <identifiersep> init <identifiersep> complete ( process , conf ) ; } private void register <identifiersep> uri ( configuration conf , path path ) { uri uri = path . to <identifiersep> uri ( ) ; <LOG> add <identifiersep> local <identifiersep> cache <identifiersep> files ( conf , uri ) ; } private hfs get <identifiersep> hfs ( ) { return ( hfs ) get <identifiersep> original ( ) ; } private boolean is <identifiersep> simple <identifiersep> glob ( ) { <ect>
public boolean are <identifiersep> types <identifiersep> ignored ( ) { if ( types <identifiersep> ignored == null ) { types <identifiersep> ignored = get <identifiersep> conf ( ) . get <identifiersep> boolean ( tuple <identifiersep> serialization <identifiersep> props . ignore <identifiersep> types , false ) ; if ( types <identifiersep> ignored ) <LOG> } return types <identifiersep> ignored ; } public boolean are <identifiersep> types <identifiersep> required ( ) { if ( types <identifiersep> required == null ) { types <identifiersep> required = get <identifiersep> conf ( ) . get <identifiersep> boolean ( tuple <identifiersep> serialization <identifiersep> props . require <identifiersep> types , false ) ; <ect>
token <identifiersep> property = token <identifiersep> property . replace <identifiersep> all ( <string_literal> , <string_literal> ) ; <comment> <LOG> if ( serializations <identifiersep> string == null ) return ; string [ ] serializations = serializations <identifiersep> string . split ( <string_literal> ) ; for ( string serialization <identifiersep> name : serializations ) { try <ect>
throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + token + <string_literal> + class <identifiersep> name + <string_literal> + type . get <identifiersep> name ( ) ) ; } if ( classes <identifiersep> tokens <identifiersep> map . contains <identifiersep> key ( class <identifiersep> name ) ) { if ( type == null ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + class <identifiersep> name + <string_literal> + token + <string_literal> ) ; throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + class <identifiersep> name + <string_literal> + token + <string_literal> + type . get <identifiersep> name ( ) ) ; } <LOG> token <identifiersep> classes <identifiersep> map . put ( token , class <identifiersep> name ) ; classes <identifiersep> tokens <identifiersep> map . put ( class <identifiersep> name , token ) ; } <comment> <ect>
object object ; try { object = deserializer . deserialize ( found <identifiersep> object ) ; } catch ( io <identifiersep> exception exception ) { <LOG> throw exception ; } return object ; } public object read ( class type , data <identifiersep> input <identifiersep> stream input <identifiersep> stream ) throws io <identifiersep> exception { string class <identifiersep> name = type . get <identifiersep> name ( ) ; deserializer deserializer = get <identifiersep> deserializer <identifiersep> for ( input <identifiersep> stream , class <identifiersep> name ) ; <ect>
try { if ( class <identifiersep> name == null ) class <identifiersep> name = writable <identifiersep> utils . read <identifiersep> string ( input <identifiersep> stream ) ; } catch ( io <identifiersep> exception exception ) { <LOG> throw exception ; } return class <identifiersep> name ; } public void close ( ) { if ( deserializers . size ( ) == 0 ) return ; <ect>
serializer serializer = get <identifiersep> serializer ( output <identifiersep> stream , type ) ; try { serializer . serialize ( object ) ; } catch ( io <identifiersep> exception exception ) { <LOG> throw exception ; } } private serializer get <identifiersep> serializer ( data <identifiersep> output <identifiersep> stream output <identifiersep> stream , class < ? > type ) throws io <identifiersep> exception { serializer serializer = serializers . get ( type ) ; if ( serializer == null ) { <ect>
try { return codec <identifiersep> pool . get <identifiersep> compressor ( codec ) ; } catch ( out <identifiersep> of <identifiersep> memory <identifiersep> error error ) { system . gc ( ) ; <LOG> return codec <identifiersep> pool . get <identifiersep> compressor ( codec ) ; } } @ override protected tuple <identifiersep> input <identifiersep> stream create <identifiersep> tuple <identifiersep> input <identifiersep> stream ( file file ) { try { <ect>
for ( linked <identifiersep> blocking <identifiersep> queue < message > queue : buffers ) queue . offer ( message ) ; } private weak <identifiersep> reference < duct > started = null ; @ override public void start ( duct previous ) { <LOG> synchronized ( this ) { if ( started != null ) { log . error ( <string_literal> , started . get ( ) , previous ) ; return ; <ect>
public void complete ( duct previous ) { synchronized ( this ) { if ( completed != null ) { <LOG> return ; } completed = new weak <identifiersep> reference < > ( previous ) ; } <comment> <ect>
if ( throwable != null ) break ; } futures = collections . empty <identifiersep> list ( ) ; } catch ( throwable current <identifiersep> throwable ) { if ( ! ( current <identifiersep> throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) <LOG> throwable = current <identifiersep> throwable ; } try { attempted <identifiersep> cleanup = true ; <comment> <ect>
try { flow . complete ( ) ; fail ( <string_literal> ) ; } catch ( throwable exception ) { <LOG> exception . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
protected synchronized static set < class < ? extends test <identifiersep> platform > > get <identifiersep> platform <identifiersep> classes <identifiersep> from <identifiersep> classpath ( class <identifiersep> loader class <identifiersep> loader ) throws io <identifiersep> exception , class <identifiersep> not <identifiersep> found <identifiersep> exception { if ( cache . contains <identifiersep> key ( class <identifiersep> loader ) ) return cache . get ( class <identifiersep> loader ) ; set < class < ? extends test <identifiersep> platform > > classes = new linked <identifiersep> hash <identifiersep> set < > ( ) ; properties properties = new properties ( ) ; <LOG> enumeration < url > urls = class <identifiersep> loader . get <identifiersep> resources ( platform <identifiersep> resource ) ; while ( urls . has <identifiersep> more <identifiersep> elements ( ) ) { input <identifiersep> stream stream = urls . next <identifiersep> element ( ) . open <identifiersep> stream ( ) ; classes . add ( ( class < ? extends test <identifiersep> platform > ) get <identifiersep> platform <identifiersep> class ( class <identifiersep> loader , properties , stream ) ) ; } if ( classes . is <identifiersep> empty ( ) ) <ect>
{ input <identifiersep> stream stream = urls . next <identifiersep> element ( ) . open <identifiersep> stream ( ) ; classes . add ( ( class < ? extends test <identifiersep> platform > ) get <identifiersep> platform <identifiersep> class ( class <identifiersep> loader , properties , stream ) ) ; } if ( classes . is <identifiersep> empty ( ) ) { log . warn ( <string_literal> ) ; <LOG> log . warn ( <string_literal> ) ; } else { log . info ( <string_literal> , classes . size ( ) ) ; } cache . put ( class <identifiersep> loader , classes ) ; return classes ; <ect>
{ log . warn ( <string_literal> ) ; log . warn ( <string_literal> , platform <identifiersep> resource , test <identifiersep> platform . class . get <identifiersep> canonical <identifiersep> name ( ) ) ; log . warn ( <string_literal> ) ; } else { <LOG> } cache . put ( class <identifiersep> loader , classes ) ; return classes ; } private static class < ? > get <identifiersep> platform <identifiersep> class ( class <identifiersep> loader class <identifiersep> loader , properties properties , input <identifiersep> stream stream ) throws io <identifiersep> exception , class <identifiersep> not <identifiersep> found <identifiersep> exception { if ( stream == null ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + platform <identifiersep> resource ) ; <ect>
<comment> <LOG> return ; } log . info ( <string_literal> , java <identifiersep> class . get <identifiersep> name ( ) , platform <identifiersep> name ) ; platform <identifiersep> suite suite <identifiersep> annotation = java <identifiersep> class . get <identifiersep> annotation ( platform <identifiersep> suite . class ) ; if ( suite <identifiersep> annotation != null ) runners . add ( make <identifiersep> suite <identifiersep> runner ( java <identifiersep> class , suite <identifiersep> annotation . method ( ) , test <identifiersep> platform ) ) ; else <ect>
hash <identifiersep> map < object , object > properties = new hash <identifiersep> map < object , object > ( ) ; for ( string property <identifiersep> name : system . get <identifiersep> properties ( ) . string <identifiersep> property <identifiersep> names ( ) ) { if ( property <identifiersep> name . starts <identifiersep> with ( platform <identifiersep> prefix ) ) properties . put ( property <identifiersep> name . substring ( platform <identifiersep> prefix . length ( ) ) , system . get <identifiersep> property ( property <identifiersep> name ) ) ; } if ( ! properties . is <identifiersep> empty ( ) ) <LOG> return properties ; } protected test <identifiersep> platform ( ) { enable <identifiersep> cluster = boolean . parse <identifiersep> boolean ( system . get <identifiersep> property ( cluster <identifiersep> testing <identifiersep> property , boolean . to <identifiersep> string ( enable <identifiersep> cluster ) ) ) ; } public string get <identifiersep> name ( ) { <ect>
return new test <identifiersep> suite ( ) ; log . info ( <string_literal> , root ) ; string [ ] roots = root . split ( <string_literal> ) ; file local <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2tez <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; <LOG> log . info ( <string_literal> , hadoop2root ) ; log . info ( <string_literal> , hadoop2tez <identifiersep> root ) ; test <identifiersep> suite suite = new test <identifiersep> suite ( ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2root , suite ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2tez <identifiersep> root , suite ) ; return suite ; <ect>
string [ ] roots = root . split ( <string_literal> ) ; file local <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2tez <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; log . info ( <string_literal> , local <identifiersep> root ) ; log . info ( <string_literal> , hadoop2root ) ; <LOG> test <identifiersep> suite suite = new test <identifiersep> suite ( ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2root , suite ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2tez <identifiersep> root , suite ) ; return suite ; } private static void create <identifiersep> comparisons ( string comparison , file lhs <identifiersep> root , file rhs <identifiersep> root , test <identifiersep> suite suite ) { <ect>
return suite ; } private static void create <identifiersep> comparisons ( string comparison , file lhs <identifiersep> root , file rhs <identifiersep> root , test <identifiersep> suite suite ) { log . info ( <string_literal> , lhs <identifiersep> root , rhs <identifiersep> root ) ; linked <identifiersep> list < file > lhs <identifiersep> files = new linked <identifiersep> list < file > ( file <identifiersep> utils . list <identifiersep> files ( lhs <identifiersep> root , new regex <identifiersep> file <identifiersep> filter ( <string_literal> ) , true <identifiersep> file <identifiersep> filter . instance ) ) ; linked <identifiersep> list < file > rhs <identifiersep> files = new linked <identifiersep> list < file > ( ) ; <LOG> int root <identifiersep> length = lhs <identifiersep> root . to <identifiersep> string ( ) . length ( ) + 1 ; list <identifiersep> iterator < file > iterator = lhs <identifiersep> files . list <identifiersep> iterator ( ) ; while ( iterator . has <identifiersep> next ( ) ) { file local <identifiersep> file = iterator . next ( ) ; file file = new file ( rhs <identifiersep> root , local <identifiersep> file . to <identifiersep> string ( ) . substring ( root <identifiersep> length ) ) ; <ect>
public void tear <identifiersep> down ( ) throws exception { try { for ( string path : current <identifiersep> paths ) { <LOG> if ( get <identifiersep> platform ( ) . is <identifiersep> use <identifiersep> cluster ( ) && get <identifiersep> platform ( ) . remote <identifiersep> exists ( path ) ) get <identifiersep> platform ( ) . copy <identifiersep> to <identifiersep> local ( path ) ; } current <identifiersep> paths . clear ( ) ; } finally { get <identifiersep> platform ( ) . tear <identifiersep> down ( ) ; <ect>
system . out . println ( <string_literal> ) ; cascade . start ( ) ; assert <identifiersep> true ( <string_literal> , flow <identifiersep> listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , cascade <identifiersep> listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; while ( true ) { <LOG> if ( get <identifiersep> platform ( ) . is <identifiersep> map <identifiersep> reduce ( ) || get <identifiersep> platform ( ) . is <identifiersep> dag ( ) ) thread . sleep ( <number_literal> ) ; map < string , flow <identifiersep> step <identifiersep> job > map = flows . get <identifiersep> jobs <identifiersep> map ( first ) ; if ( map == null || map . values ( ) . size ( ) == 0 ) continue ; flow <identifiersep> step <identifiersep> job flow <identifiersep> step <identifiersep> job = map . values ( ) . iterator ( ) . next ( ) ; <ect>
set < flow <identifiersep> element > source <identifiersep> elements = new hash <identifiersep> set < > ( node . get <identifiersep> source <identifiersep> elements ( ) ) ; set < ? extends flow <identifiersep> element > accumulated = node . get <identifiersep> source <identifiersep> elements ( stream <identifiersep> mode . accumulated ) ; source <identifiersep> elements . remove <identifiersep> all ( accumulated ) ; if ( source <identifiersep> elements . size ( ) != 1 ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + util . join ( source <identifiersep> elements , <string_literal> ) ) ; streamed <identifiersep> source = util . get <identifiersep> first ( source <identifiersep> elements ) ; } <LOG> streamed <identifiersep> head = handle <identifiersep> head ( streamed <identifiersep> source , flow <identifiersep> process ) ; set < flow <identifiersep> element > accumulated = new hash <identifiersep> set < > ( node . get <identifiersep> source <identifiersep> elements ( ) ) ; accumulated . remove ( streamed <identifiersep> source ) ; hadoop2tez <identifiersep> flow <identifiersep> process tez <identifiersep> process = ( hadoop2tez <identifiersep> flow <identifiersep> process ) flow <identifiersep> process ; tez <identifiersep> configuration conf = tez <identifiersep> process . get <identifiersep> configuration ( ) ; for ( flow <identifiersep> element flow <identifiersep> element : accumulated ) <ect>
if ( logical <identifiersep> output == null ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; this . logical <identifiersep> output = ( mr <identifiersep> output ) logical <identifiersep> output ; } @ override public void prepare ( ) { <LOG> logical <identifiersep> output . start ( ) ; collector = new old <identifiersep> output <identifiersep> collector ( logical <identifiersep> output ) ; super . prepare ( ) ; } @ override public void cleanup ( ) { <ect>
thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception exception ) { <comment> <LOG> if ( -- retries == 0 ) throw exception ; } } <comment> <ect>
{ try { output . abort ( ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } } <ect>
log . info ( <string_literal> , logical <identifiersep> input . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , get <identifiersep> splice ( ) , pipe . id ( get <identifiersep> splice ( ) ) , logical <identifiersep> inputs . get <identifiersep> values ( ) . size ( ) ) ; logical <identifiersep> input . start ( ) ; } } if ( logical <identifiersep> outputs != null ) { for ( logical <identifiersep> output logical <identifiersep> output : logical <identifiersep> outputs ) { <LOG> logical <identifiersep> output . start ( ) ; } } } catch ( exception exception ) { throw new cascading <identifiersep> exception ( <string_literal> , exception ) ; } if ( role != io <identifiersep> role . source ) collector = new measured <identifiersep> output <identifiersep> collector ( flow <identifiersep> process , slice <identifiersep> counters . write <identifiersep> duration , create <identifiersep> output <identifiersep> collector ( ) ) ; <ect>
edge <identifiersep> property edge <identifiersep> property = create <identifiersep> edge <identifiersep> property ( initialized <identifiersep> config , process <identifiersep> edge ) ; vertex target <identifiersep> vertex = vertex <identifiersep> map . get ( edge <identifiersep> target <identifiersep> flow <identifiersep> node ) ; if ( source <identifiersep> nodes . size ( ) == 1 || flow <identifiersep> element instanceof co <identifiersep> group || flow <identifiersep> element instanceof boundary ) <comment> <LOG> dag . add <identifiersep> edge ( edge . create ( source <identifiersep> vertex , target <identifiersep> vertex , edge <identifiersep> property ) ) ; } else if ( flow <identifiersep> element instanceof group <identifiersep> by || flow <identifiersep> element instanceof merge ) <comment> <ect>
for ( tap tap : flow <identifiersep> node . get <identifiersep> sink <identifiersep> taps ( ) ) { int num <identifiersep> sink <identifiersep> parts = tap . get <identifiersep> scheme ( ) . get <identifiersep> num <identifiersep> sink <identifiersep> parts ( ) ; if ( num <identifiersep> sink <identifiersep> parts == 0 ) continue ; if ( parallelism != integer . max <identifiersep> value ) <LOG> parallelism = math . min ( parallelism , num <identifiersep> sink <identifiersep> parts ) ; } if ( parallelism != integer . max <identifiersep> value ) return parallelism ; return conf . get <identifiersep> int ( flow <identifiersep> runtime <identifiersep> props . gather <identifiersep> partitions , 0 ) ; } private void add <identifiersep> input <identifiersep> output <identifiersep> mapping ( job <identifiersep> conf conf , flow <identifiersep> node flow <identifiersep> node ) { <ect>
private void set <identifiersep> local <identifiersep> mode ( configuration parent , job <identifiersep> conf current , tap tap ) { <comment> <LOG> hadoop <identifiersep> util . set <identifiersep> local ( parent ) ; } private void add <identifiersep> remote <identifiersep> debug ( flow <identifiersep> node flow <identifiersep> node , vertex vertex ) { string value = system . get <identifiersep> property ( <string_literal> , null ) ; if ( util . is <identifiersep> empty ( value ) ) return ; <ect>
{ string value = system . get <identifiersep> property ( <string_literal> , null ) ; if ( util . is <identifiersep> empty ( value ) ) return ; if ( ! flow <identifiersep> node . get <identifiersep> source <identifiersep> element <identifiersep> names ( ) . contains ( value ) && as <identifiersep> int ( value ) != flow <identifiersep> node . get <identifiersep> ordinal ( ) ) return ; <LOG> string opts = vertex . get <identifiersep> task <identifiersep> launch <identifiersep> cmd <identifiersep> opts ( ) ; if ( opts == null ) opts = <string_literal> ; string path = system . get <identifiersep> property ( <string_literal> , <string_literal> ) ; if ( ! path . ends <identifiersep> with ( <string_literal> ) ) path += <string_literal> ; <ect>
string class <identifiersep> path = environment . get ( classpath . name ( ) ) ; if ( class <identifiersep> path == null ) class <identifiersep> path = <string_literal> ; else if ( ! class <identifiersep> path . starts <identifiersep> with ( class <identifiersep> path <identifiersep> separator ) ) class <identifiersep> path += class <identifiersep> path <identifiersep> separator ; class <identifiersep> path += current ; <LOG> environment . put ( classpath . name ( ) , class <identifiersep> path ) ; } } local <identifiersep> resources . put ( file <identifiersep> name , resource ) ; } public static void set <identifiersep> mr <identifiersep> properties ( processor <identifiersep> context context , configuration config , boolean is <identifiersep> mapper <identifiersep> output ) { task <identifiersep> attempt <identifiersep> id task <identifiersep> attempt <identifiersep> id = org . apache . tez . mapreduce . hadoop . mapreduce . task <identifiersep> attempt <identifiersep> context <identifiersep> impl . create <identifiersep> mock <identifiersep> task <identifiersep> attempt <identifiersep> id ( context . get <identifiersep> application <identifiersep> id ( ) . get <identifiersep> cluster <identifiersep> timestamp ( ) , <ect>
if ( type != null ) application <identifiersep> jar <identifiersep> path = util . find <identifiersep> containing <identifiersep> jar ( type ) ; app <identifiersep> props . set <identifiersep> application <identifiersep> jar <identifiersep> path ( properties , application <identifiersep> jar <identifiersep> path ) ; } if ( application <identifiersep> jar <identifiersep> path != null ) log . info ( <string_literal> , application <identifiersep> jar <identifiersep> path ) ; else <LOG> } @ override public void config <identifiersep> rule <identifiersep> registry <identifiersep> defaults ( rule <identifiersep> registry rule <identifiersep> registry ) { super . config <identifiersep> rule <identifiersep> registry <identifiersep> defaults ( rule <identifiersep> registry ) ; rule <identifiersep> registry . add <identifiersep> default <identifiersep> element <identifiersep> factory ( intermediate <identifiersep> tap <identifiersep> element <identifiersep> factory . temp <identifiersep> tap , new temp <identifiersep> tap <identifiersep> element <identifiersep> factory ( ) ) ; rule <identifiersep> registry . add <identifiersep> default <identifiersep> element <identifiersep> factory ( boundary <identifiersep> element <identifiersep> factory . boundary <identifiersep> pipe , new intermediate <identifiersep> boundary <identifiersep> element <identifiersep> factory ( ) ) ; <ect>
try { hadoop <identifiersep> util . init <identifiersep> log4j ( configuration ) ; log . info ( <string_literal> , configuration . get ( <string_literal> , <string_literal> ) ) ; current <identifiersep> process = new hadoop2tez <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , get <identifiersep> context ( ) , configuration ) ; flow <identifiersep> node = deserialize <identifiersep> base64 ( configuration . get <identifiersep> raw ( flow <identifiersep> node . cascading <identifiersep> flow <identifiersep> node ) , configuration , base <identifiersep> flow <identifiersep> node . class ) ; <LOG> log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) { if ( throwable instanceof cascading <identifiersep> exception ) throw ( cascading <identifiersep> exception ) throwable ; throw new flow <identifiersep> exception ( <string_literal> , throwable ) ; <ect>
stream <identifiersep> graph = new hadoop2tez <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , input <identifiersep> map , output <identifiersep> map ) ; all <identifiersep> heads = stream <identifiersep> graph . get <identifiersep> heads ( ) ; streamed <identifiersep> head = stream <identifiersep> graph . get <identifiersep> streamed <identifiersep> head ( ) ; for ( duct head : all <identifiersep> heads ) log . info ( <string_literal> , ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) , head == streamed <identifiersep> head , flow <identifiersep> elements . id ( ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ) ; for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) <LOG> for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) log . info ( <string_literal> , trap , flow <identifiersep> elements . id ( trap ) ) ; } catch ( throwable throwable ) { if ( throwable instanceof cascading <identifiersep> exception ) throw ( cascading <identifiersep> exception ) throwable ; <ect>
current <identifiersep> process . increment ( slice <identifiersep> counters . process <identifiersep> duration , process <identifiersep> end <identifiersep> time - process <identifiersep> begin <identifiersep> time ) ; } } } protected void wait <identifiersep> for <identifiersep> inputs <identifiersep> ready ( map < string , logical <identifiersep> input > input <identifiersep> map ) throws interrupted <identifiersep> exception { long begin <identifiersep> input <identifiersep> ready = system . current <identifiersep> time <identifiersep> millis ( ) ; hash <identifiersep> set < input > inputs = new hash <identifiersep> set < input > ( input <identifiersep> map . values ( ) ) ; get <identifiersep> context ( ) . wait <identifiersep> for <identifiersep> all <identifiersep> inputs <identifiersep> ready ( inputs ) ; <LOG> } @ override public void handle <identifiersep> events ( list < event > events ) { log . debug ( <string_literal> ) ; } @ override public void close ( ) throws exception <ect>
<comment> <LOG> configuration = new configuration ( ) ; configuration . set <identifiersep> int ( flow <identifiersep> runtime <identifiersep> props . gather <identifiersep> partitions , get <identifiersep> num <identifiersep> gather <identifiersep> partitions ( ) ) ; <comment> <ect>
public void check <identifiersep> permission ( permission permission ) { if ( ! <string_literal> . equals ( permission . get <identifiersep> name ( ) ) ) return ; stack <identifiersep> trace <identifiersep> element [ ] stack <identifiersep> trace = thread . current <identifiersep> thread ( ) . get <identifiersep> stack <identifiersep> trace ( ) ; for ( stack <identifiersep> trace <identifiersep> element stack <identifiersep> trace <identifiersep> element : stack <identifiersep> trace ) <LOG> throw new exit <identifiersep> trapped <identifiersep> exception ( ) ; } } ; system . set <identifiersep> security <identifiersep> manager ( security <identifiersep> manager ) ; } private static void enable <identifiersep> system <identifiersep> exit <identifiersep> call ( ) { security <identifiersep> manager = null ; <ect>
timed <identifiersep> jobs <identifiersep> by <identifiersep> time = new tree <identifiersep> map < long , object > ( ) ; timed <identifiersep> jobs <identifiersep> queued = new hash <identifiersep> map < job , long > ( ) ; my <identifiersep> thread = new native <identifiersep> thread ( this , <string_literal> + port <identifiersep> number , native <identifiersep> thread . max <identifiersep> priority , false ) ; my <identifiersep> thread . set <identifiersep> daemon ( true ) ; } public void start ( ) { logger . normal ( this , <string_literal> ) ; <LOG> my <identifiersep> thread . start ( ) ; } @ override public void run ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { try { real <identifiersep> run ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void real <identifiersep> run ( ) { long now = system . current <identifiersep> time <identifiersep> millis ( ) ; list < job > jobs <identifiersep> to <identifiersep> run = null ; long sleep <identifiersep> time = max <identifiersep> sleep <identifiersep> time ; synchronized ( timed <identifiersep> jobs <identifiersep> by <identifiersep> time ) { <ect>
} catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> + r , t ) ; } else try { executor . execute ( r . job , r . name , true ) ; } catch ( throwable t ) { <LOG> system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; queue <identifiersep> timed <identifiersep> job ( r . job , r . name , <number_literal> , true , false ) ; } } if ( sleep <identifiersep> time > 0 ) { try { <ect>
try { executor . execute ( r . job , r . name , true ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> queue <identifiersep> timed <identifiersep> job ( r . job , r . name , <number_literal> , true , false ) ; } } if ( sleep <identifiersep> time > 0 ) { try { sleep ( sleep <identifiersep> time ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
return ; } } } <comment> <LOG> } ran <identifiersep> jobs ++ ; } } } } <ect>
<comment> @ override public synchronized void report ( double d ) { total <identifiersep> reports ++ ; if ( log <identifiersep> debug ) <LOG> if ( cur <identifiersep> len < refs . length ) cur <identifiersep> len ++ ; else total -= pop <identifiersep> value ( ) ; push <identifiersep> value ( d ) ; total += d ; <ect>
a . report ( 0 . <number_literal> ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; <LOG> } system . out . println ( <string_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; <ect>
system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } system . out . println ( <string_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { <LOG> for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; <ect>
system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; <LOG> } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; <ect>
system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; <LOG> } } system . out . println ( <string_literal> ) ; a = new decaying <identifiersep> keyspace <identifiersep> average ( 0 . <number_literal> , <number_literal> , null ) ; a . report ( 0 . <number_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { <ect>
a . report ( 1 . 0 ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } } system . out . println ( <string_literal> ) ; a = new decaying <identifiersep> keyspace <identifiersep> average ( 0 . <number_literal> , <number_literal> , null ) ; a . report ( 0 . <number_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { <LOG> for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; <ect>
system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; <LOG> } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; <ect>
system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; <LOG> } } } } <ect>
if ( d < min ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + d , new exception ( <string_literal> ) ) ; d = min ; } if ( d > max ) { if ( log <identifiersep> debug ) <LOG> d = max ; } reports ++ ; double decay <identifiersep> factor = 1 . 0 / ( math . min ( reports , max <identifiersep> reports ) ) ; current <identifiersep> value = ( d * decay <identifiersep> factor ) + ( current <identifiersep> value * ( 1 - decay <identifiersep> factor ) ) ; } <comment> <ect>
@ override public synchronized double value <identifiersep> if <identifiersep> reported ( double d ) { if ( d < min ) { logger . error ( this , <string_literal> + d , new exception ( <string_literal> ) ) ; d = min ; } if ( d > max ) { <LOG> d = max ; } double decay <identifiersep> factor = 1 . 0 / ( math . min ( reports + 1 , max <identifiersep> reports ) ) ; return ( d * decay <identifiersep> factor ) + ( current <identifiersep> value * ( 1 - decay <identifiersep> factor ) ) ; } <comment> <ect>
<comment> <LOG> return ; } if ( double . is <identifiersep> infinite ( d ) || double . is <identifiersep> na <identifiersep> n ( d ) ) { logger . error ( this , <string_literal> + this + <string_literal> + d , new exception ( <string_literal> ) ) ; return ; } total <identifiersep> reports ++ ; if ( ! started ) { <ect>
return ; } total <identifiersep> reports ++ ; if ( ! started ) { cur <identifiersep> value = d ; started = true ; if ( log <identifiersep> debug ) <LOG> } else if ( last <identifiersep> report <identifiersep> time != - 1 ) { <comment> <ect>
last <identifiersep> report <identifiersep> time = now ; if ( time <identifiersep> skew <identifiersep> callback != null ) time <identifiersep> skew <identifiersep> callback . set <identifiersep> time <identifiersep> skew <identifiersep> detected <identifiersep> user <identifiersep> alert ( ) ; return ; } double this <identifiersep> half <identifiersep> life = half <identifiersep> life ; if ( uptime < 0 ) { <LOG> if ( time <identifiersep> skew <identifiersep> callback != null ) time <identifiersep> skew <identifiersep> callback . set <identifiersep> time <identifiersep> skew <identifiersep> detected <identifiersep> user <identifiersep> alert ( ) ; return ; <comment> <ect>
file [ ] filenames = tmp <identifiersep> dir . list <identifiersep> files ( ) ; if ( filenames != null ) { for ( int i = 0 ; i < filenames . length ; i ++ ) { wrapper <identifiersep> manager . signal <identifiersep> starting ( ( int ) minutes . to <identifiersep> millis ( <number_literal> ) ) ; if ( i % <number_literal> == 0 && i > 0 ) <comment> <LOG> file f = filenames [ i ] ; string name = f . get <identifiersep> name ( ) ; if ( ( ( ( file . separator <identifiersep> char == ' \\ \\ ' ) && name . to <identifiersep> lower <identifiersep> case ( ) . starts <identifiersep> with ( prefix . to <identifiersep> lower <identifiersep> case ( ) ) ) || name . starts <identifiersep> with ( prefix ) ) ) { wipeable <identifiersep> files ++ ; if ( ( ! f . delete ( ) ) && f . exists ( ) ) <ect>
wipeable <identifiersep> files ++ ; if ( ( ! f . delete ( ) ) && f . exists ( ) ) system . err . println ( <string_literal> + f + <string_literal> ) ; else wiped <identifiersep> files ++ ; } } long end <identifiersep> wipe = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> } } } public long make <identifiersep> random <identifiersep> filename ( ) throws io <identifiersep> exception { long random <identifiersep> filename ; <comment> <ect>
<comment> public static bucket [ ] split ( bucket orig <identifiersep> data , int split <identifiersep> size , bucket <identifiersep> factory bf , boolean free <identifiersep> data , boolean persistent ) throws io <identifiersep> exception { if ( orig <identifiersep> data instanceof file <identifiersep> bucket ) { if ( free <identifiersep> data ) { <LOG> } bucket [ ] buckets = ( ( file <identifiersep> bucket ) orig <identifiersep> data ) . split ( split <identifiersep> size ) ; if ( persistent ) return buckets ; } long length = orig <identifiersep> data . size ( ) ; if ( length > ( ( long ) integer . max <identifiersep> value ) * split <identifiersep> size ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + length + <string_literal> + split <identifiersep> size ) ; <ect>
synchronized ( fds ) { if ( lock <identifiersep> level != 0 ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; if ( raf == null ) return ; try { raf . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } raf = null ; fds . total <identifiersep> open <identifiersep> f <identifiersep> ds -- ; } } private void unlock ( ) { synchronized ( fds ) { lock <identifiersep> level -- ; if ( lock <identifiersep> level > 0 ) return ; <ect>
if ( ! delete <identifiersep> on <identifiersep> free ) return ; if ( secure <identifiersep> delete ) { try { file <identifiersep> util . secure <identifiersep> delete ( file ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + file + <string_literal> + e , e ) ; <LOG> } } else { file . delete ( ) ; } } boolean is <identifiersep> open ( ) { synchronized ( fds ) { return raf != null ; } } boolean is <identifiersep> locked ( ) { <ect>
file <identifiersep> restart <identifiersep> counter == 0 && <comment> <LOG> boolean rename = ! temp <identifiersep> file <identifiersep> already <identifiersep> exists ( ) ; file tempfile = rename ? get <identifiersep> tempfile ( ) : file ; long stream <identifiersep> number = ++ file <identifiersep> restart <identifiersep> counter ; file <identifiersep> bucket <identifiersep> output <identifiersep> stream os = new file <identifiersep> bucket <identifiersep> output <identifiersep> stream ( tempfile , stream <identifiersep> number ) ; if ( log <identifiersep> debug ) <ect>
return new null <identifiersep> input <identifiersep> stream ( ) ; } else { file <identifiersep> bucket <identifiersep> input <identifiersep> stream is = new file <identifiersep> bucket <identifiersep> input <identifiersep> stream ( file ) ; add <identifiersep> stream ( is ) ; if ( log <identifiersep> debug ) <LOG> return is ; } } public input <identifiersep> stream get <identifiersep> input <identifiersep> stream ( ) throws io <identifiersep> exception { return new buffered <identifiersep> input <identifiersep> stream ( get <identifiersep> input <identifiersep> stream <identifiersep> unbuffered ( ) ) ; } <comment> <ect>
if ( to <identifiersep> close != null ) { logger . error ( this , <string_literal> + this + <string_literal> + arrays . to <identifiersep> string ( to <identifiersep> close ) , new exception ( <string_literal> ) ) ; for ( closeable strm : to <identifiersep> close ) { try { strm . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; } } } file file = get <identifiersep> file ( ) ; if ( ( delete <identifiersep> on <identifiersep> free ( ) || force <identifiersep> free ) && file . exists ( ) ) { logger . debug ( this , <string_literal> + file , new exception ( <string_literal> ) ) ; <ect>
<comment> @ override public random <identifiersep> access <identifiersep> bucket create <identifiersep> shadow ( ) { persistent <identifiersep> temp <identifiersep> file <identifiersep> bucket ret = new persistent <identifiersep> temp <identifiersep> file <identifiersep> bucket ( filename <identifiersep> id , generator , tracker , false ) ; ret . set <identifiersep> read <identifiersep> only ( ) ; <LOG> return ret ; } @ override protected void inner <identifiersep> resume ( client <identifiersep> context context ) throws resume <identifiersep> failed <identifiersep> exception { super . inner <identifiersep> resume ( context ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; tracker = context . persistent <identifiersep> file <identifiersep> tracker ; <ect>
if ( secret != null ) { if ( real <identifiersep> size != padded <identifiersep> size ) raf = new padded <identifiersep> random <identifiersep> access <identifiersep> buffer ( raf , real <identifiersep> size ) ; try { raf = new encrypted <identifiersep> random <identifiersep> access <identifiersep> buffer ( temp <identifiersep> bucket <identifiersep> factory . crypt <identifiersep> type , raf , secret , true ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> } } return raf ; } @ override public lockable <identifiersep> random <identifiersep> access <identifiersep> buffer make <identifiersep> raf ( byte [ ] initial <identifiersep> contents , int offset , int size , boolean read <identifiersep> only ) throws io <identifiersep> exception { boolean really <identifiersep> encrypt = false ; synchronized ( this ) { <ect>
<comment> public static void close ( bucket bucket ) { if ( bucket != null ) { try { bucket . free ( ) ; } catch ( runtime <identifiersep> exception e ) { <LOG> } } } <comment> <ect>
synchronized ( this ) { if ( closed ) return ; closed = true ; } try { raf . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } @ override public raf <identifiersep> lock lock <identifiersep> open ( ) { return new raf <identifiersep> lock ( ) { @ override protected void inner <identifiersep> unlock ( ) { <comment> <ect>
close ( ) ; if ( secure <identifiersep> delete ) { try { file <identifiersep> util . secure <identifiersep> delete ( file ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + file + <string_literal> + e , e ) ; <LOG> } } else { file . delete ( ) ; } } public void set <identifiersep> secure <identifiersep> delete ( boolean secure <identifiersep> delete ) { this . secure <identifiersep> delete = secure <identifiersep> delete ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) throws resume <identifiersep> failed <identifiersep> exception { <ect>
else if ( file . separator <identifiersep> char == ' / ' ) return operating <identifiersep> system . generic <identifiersep> unix ; else if ( file . separator <identifiersep> char == ' \\ \\ ' ) return operating <identifiersep> system . windows ; logger . error ( file <identifiersep> util . class , <string_literal> + name ) ; } catch ( throwable t ) { <LOG> } return operating <identifiersep> system . unknown ; } private static cpu <identifiersep> architecture detect <identifiersep> cpu <identifiersep> architecture ( ) { <comment> <ect>
if ( ! orig . exists ( ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( ! orig . rename <identifiersep> to ( dest ) ) { <comment> <LOG> system . err . println ( <string_literal> + dest + <string_literal> ) ; } } if ( ! orig . rename <identifiersep> to ( dest ) ) { string err = <string_literal> + orig + <string_literal> + dest + ( dest . exists ( ) ? <string_literal> : <string_literal> ) + ( orig . exists ( ) ? <string_literal> : <string_literal> ) + <string_literal> ; <ect>
if ( ! orig . exists ( ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( dest . exists ( ) ) { if ( overwrite ) dest . delete ( ) ; else { <LOG> return false ; } } if ( ! orig . rename <identifiersep> to ( dest ) ) return copy <identifiersep> file ( orig , dest ) ; else return true ; } <comment> <ect>
throw new eof <identifiersep> exception ( <string_literal> ) ; } destination . write ( buffer , 0 , read ) ; if ( remaining > 0 ) remaining -= read ; } } public static boolean secure <identifiersep> delete <identifiersep> all ( file wd ) throws io <identifiersep> exception { if ( ! wd . is <identifiersep> directory ( ) ) { <LOG> try { secure <identifiersep> delete ( wd ) ; } catch ( io <identifiersep> exception e ) { logger . error ( file <identifiersep> util . class , <string_literal> + wd , e ) ; return false ; } } else { <ect>
logger . error ( file <identifiersep> util . class , <string_literal> + wd , e ) ; return false ; } } else { for ( file subfile : wd . list <identifiersep> files ( ) ) { if ( ! remove <identifiersep> all ( subfile ) ) return false ; } if ( ! wd . delete ( ) ) { <LOG> } } return true ; } <comment> public static boolean remove <identifiersep> all ( file wd ) { if ( ! wd . is <identifiersep> directory ( ) ) { system . err . println ( <string_literal> + wd ) ; <ect>
<comment> public static boolean remove <identifiersep> all ( file wd ) { if ( ! wd . is <identifiersep> directory ( ) ) { system . err . println ( <string_literal> + wd ) ; if ( ! wd . delete ( ) && wd . exists ( ) ) { <LOG> return false ; } } else { for ( file subfile : wd . list <identifiersep> files ( ) ) { if ( ! remove <identifiersep> all ( subfile ) ) return false ; } if ( ! wd . delete ( ) ) { logger . error ( file <identifiersep> util . class , <string_literal> + wd ) ; <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; said <identifiersep> so = true ; } try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e1 ) { <comment> <ect>
synchronized ( temp <identifiersep> bucket <identifiersep> factory . this ) { if ( bytes <identifiersep> in <identifiersep> use < = max <identifiersep> ram <identifiersep> used * max <identifiersep> usage <identifiersep> low ) return ; } try { if ( ! clean <identifiersep> bucket <identifiersep> queue ( system . current <identifiersep> time <identifiersep> millis ( ) , true ) ) return ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { if ( ! said <identifiersep> so ) { <LOG> system . err . println ( <string_literal> ) ; said <identifiersep> so = true ; } try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e1 ) { <comment> <ect>
for ( migratable tmp <identifiersep> bucket : to <identifiersep> migrate ) { try { tmp <identifiersep> bucket . migrate <identifiersep> to <identifiersep> disk ( ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { throw e ; } catch ( io <identifiersep> exception e ) { <LOG> } } return true ; } return false ; } private final queue < weak <identifiersep> reference < migratable > > ram <identifiersep> bucket <identifiersep> queue = new linked <identifiersep> blocking <identifiersep> queue < weak <identifiersep> reference < migratable > > ( ) ; private random <identifiersep> access <identifiersep> bucket  <identifiersep> make <identifiersep> file <identifiersep> bucket ( ) throws io <identifiersep> exception { random <identifiersep> access <identifiersep> bucket ret = new temp <identifiersep> file <identifiersep> bucket ( filename <identifiersep> generator . make <identifiersep> random <identifiersep> filename ( ) , filename <identifiersep> generator , true ) ; <comment> <ect>
<comment> <LOG> free ( ) ; } super . finalize ( ) ; } } @ override public lockable <identifiersep> random <identifiersep> access <identifiersep> buffer make <identifiersep> raf ( long size ) throws io <identifiersep> exception { if ( size < 0 ) throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; if ( size > integer . max <identifiersep> value ) return disk <identifiersep> raf <identifiersep> factory . make <identifiersep> raf ( size ) ; <ect>
return ( i < hd . length ) ? ( ( int ) hd [ i ++ ] ) & 0xff : in . read ( ) ; } @ override public int read ( byte [ ] buf , int off , int len ) throws io <identifiersep> exception { int prev = i ; for ( ; i < hd . length && len > 0 ; i ++ , len -- , off ++ ) { buf [ off ] = hd [ i ] ; } return ( i - prev ) + in . read ( buf , off , len ) ; <LOG> } @ override public long skip ( long len ) throws io <identifiersep> exception { int prev = i ; for ( ; i < hd . length && len > 0 ; i ++ , len -- ) { } return ( i - prev ) + in . skip ( len ) ; } @ override public boolean mark <identifiersep> supported ( ) { <comment> <ect>
<string_literal> ) ; datagram <identifiersep> socket ds = null ; try { try { ds = new datagram <identifiersep> socket ( ) ; } catch ( socket <identifiersep> exception e ) { <LOG> return null ; } <comment> <ect>
list < inet <identifiersep> address > output = new array <identifiersep> list < inet <identifiersep> address > ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + addrs . size ( ) + <string_literal> ) ; if ( addrs . size ( ) == 0 ) { <LOG> last <identifiersep> address <identifiersep> list = null ; return ; } else { <comment> <ect>
<comment> public static boolean is <identifiersep> valid <identifiersep> hostname ( string hn , boolean allow <identifiersep> ip <identifiersep> address ) { if ( allow <identifiersep> ip <identifiersep> address ) { <comment> <LOG> if ( ! address <identifiersep> type . to <identifiersep> string ( ) . equals ( <string_literal> ) ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + req + <string_literal> + index ) ; return ; } int target <identifiersep> block = index / block <identifiersep> size ; for ( int i = 0 ; i < blocks . length ; i ++ ) { block block = blocks [ i ] ; if ( i != ( blocks . length - 1 ) && block . reqs . length != block <identifiersep> size ) { <LOG> } for ( int j = 0 ; j < block . reqs . length ; j ++ ) { if ( x >= index ) break ; if ( block . reqs [ j ] == req ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + req + <string_literal> + this + <string_literal> + index ) ; return ; } if ( block . reqs [ j ] == null ) { <ect>
while ( true ) { int i = context . fast <identifiersep> weak <identifiersep> random . next <identifiersep> int ( index ) ; int block <identifiersep> no = i / block <identifiersep> size ; random <identifiersep> grab <identifiersep> array <identifiersep> item ret , oret ; ret = blocks [ block <identifiersep> no ] . reqs [ i % block <identifiersep> size ] ; if ( ret == null ) { <LOG> remove ( block <identifiersep> no , i ) ; continue ; } if ( ret . get <identifiersep> wakeup <identifiersep> time ( context , now ) > 0 ) { excluded ++ ; if ( excluded > max <identifiersep> excluded ) { return null ; <ect>
for ( int j = 0 ; j < block . reqs . length ; j ++ ) { random <identifiersep> grab <identifiersep> array <identifiersep> item item = block . reqs [ j ] ; if ( item == null ) continue ; item . set <identifiersep> parent <identifiersep> grab <identifiersep> array ( null ) ; existing <identifiersep> grabber . add ( item , null ) ; block . reqs [ j ] = null ; } <LOG> } } @ override public void set <identifiersep> parent ( remove <identifiersep> random <identifiersep> parent new <identifiersep> parent ) { synchronized ( root ) { this . parent = new <identifiersep> parent ; } } @ override public request <identifiersep> selection <identifiersep> tree <identifiersep> node get <identifiersep> parent <identifiersep> grab <identifiersep> array ( ) { <ect>
current = null ; return ; } } } } if ( job == null ) { try { callback . on <identifiersep> idle ( ) ; } catch ( throwable t ) { <LOG> } called <identifiersep> idle <identifiersep> callback = true ; continue ; } called <identifiersep> idle <identifiersep> callback = false ; try { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + job ) ; <ect>
if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> + job + <string_literal> + ( end - start ) + <string_literal> ) ; } if ( statistics != null ) { statistics . report <identifiersep> database <identifiersep> job ( job . to <identifiersep> string ( ) , end - start ) ; } } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <LOG> } } } finally { synchronized ( jobs ) { current = null ; running = false ; } } } private runnable check <identifiersep> queue ( ) { if ( ! invert <identifiersep> order ) { <ect>
final static int prio <identifiersep> darwin <identifiersep> bg = 0x1000 ; } public static boolean enter <identifiersep> background <identifiersep> mode ( ) { if ( ! background ) { if ( platform . is <identifiersep> windows ( ) ) { windows <identifiersep> holder lib = windows <identifiersep> holder . instance ; if ( lib . set <identifiersep> priority <identifiersep> class ( lib . get <identifiersep> current <identifiersep> process ( ) , windows <identifiersep> holder . process <identifiersep> mode <identifiersep> background <identifiersep> begin ) ) { <LOG> return background = true ; } else if ( lib . get <identifiersep> last <identifiersep> error ( ) . equals ( windows <identifiersep> holder . error <identifiersep> process <identifiersep> mode <identifiersep> already <identifiersep> background ) ) { system . err . println ( <string_literal> + lib . get <identifiersep> last <identifiersep> error ( ) ) ; return false ; } } else if ( platform . is <identifiersep> linux ( ) ) { return handle <identifiersep> return ( linux <identifiersep> holder . setpriority ( linux <identifiersep> holder . prio <identifiersep> process , linux <identifiersep> holder . myself , linux <identifiersep> holder . lower <identifiersep> priority ) ) ; <ect>
return handle <identifiersep> return ( linux <identifiersep> holder . setpriority ( linux <identifiersep> holder . prio <identifiersep> process , linux <identifiersep> holder . myself , linux <identifiersep> holder . lower <identifiersep> priority ) ) ; } else if ( platform . is <identifiersep> mac ( ) ) { return handle <identifiersep> return ( osx <identifiersep> holder . setpriority ( osx <identifiersep> holder . prio <identifiersep> darwin <identifiersep> thread , osx <identifiersep> holder . myself , osx <identifiersep> holder . prio <identifiersep> darwin <identifiersep> bg ) ) ; } } return background ; } private static boolean handle <identifiersep> return ( int ret ) { if ( ret == 0 ) { <LOG> return background = true ; } else { system . err . println ( <string_literal> + ret ) ; return false ; } } } <ect>
<comment> <LOG> read <identifiersep> line = null ; } finally { closer . close ( br ) ; } if ( null != read <identifiersep> line ) { try { string [ ] proc <identifiersep> fields = read <identifiersep> line . trim ( ) . split ( <string_literal> ) ; <ect>
int x = context . fast <identifiersep> weak <identifiersep> random . next <identifiersep> boolean ( ) ? 1 : 0 ; remove <identifiersep> random <identifiersep> with <identifiersep> object < t > rga = grab <identifiersep> arrays [ x ] ; remove <identifiersep> random <identifiersep> with <identifiersep> object < t > first <identifiersep> rga = rga ; if ( rga == null ) { logger . error ( this , <string_literal> + this ) ; if ( grab <identifiersep> arrays [ 1 - x ] == null ) { <LOG> grab <identifiersep> arrays = new <identifiersep> grabber <identifiersep> array ( 0 ) ; grab <identifiersep> clients = new <identifiersep> client <identifiersep> array ( 0 ) ; return null ; } else { logger . error ( this , <string_literal> + ( 1 - x ) + <string_literal> + x + <string_literal> ) ; grab <identifiersep> arrays = as <identifiersep> grabber <identifiersep> array ( grab <identifiersep> arrays [ 1 - x ] ) ; <ect>
logger . minor ( this , <string_literal> + item + <string_literal> + rga ) ; return new remove <identifiersep> random <identifiersep> return ( item ) ; } else { x = 1 - x ; rga = grab <identifiersep> arrays [ x ] ; if ( rga == null ) { <LOG> grab <identifiersep> arrays = as <identifiersep> grabber <identifiersep> array ( grab <identifiersep> arrays [ 1 - x ] ) ; grab <identifiersep> clients = as <identifiersep> client <identifiersep> array ( grab <identifiersep> clients [ 1 - x ] ) ; reduce <identifiersep> wakeup <identifiersep> time ( wakeup <identifiersep> time , context ) ; return new remove <identifiersep> random <identifiersep> return ( wakeup <identifiersep> time ) ; } exclude <identifiersep> time = rga . get <identifiersep> wakeup <identifiersep> time ( context , now ) ; if ( exclude <identifiersep> time > 0 ) { <ect>
for ( int i = 0 ; i < grab <identifiersep> arrays . length ; i ++ ) { if ( grab <identifiersep> arrays [ i ] == r ) { found = i ; break ; } } if ( found != - 1 ) { count ++ ; <LOG> remove <identifiersep> element ( found ) ; } else { break ; } } final <identifiersep> size = grab <identifiersep> arrays . length ; } if ( count == 0 ) { <comment> <ect>
@ override public abstract int get <identifiersep> priority ( ) ; @ override public void run ( ) { long sleep <identifiersep> time = seconds . to <identifiersep> millis ( 1 ) ; try { <LOG> iterate ( ) ; sleep <identifiersep> time = get <identifiersep> sleep <identifiersep> time ( ) ; } catch ( exception e ) { logger . error ( this , <string_literal> , e ) ; } finally { logger . debug ( this , <string_literal> + minutes . convert ( sleep <identifiersep> time , milliseconds ) + <string_literal> ) ; <ect>
logger . debug ( this , <string_literal> ) ; iterate ( ) ; sleep <identifiersep> time = get <identifiersep> sleep <identifiersep> time ( ) ; } catch ( exception e ) { logger . error ( this , <string_literal> , e ) ; } finally { <LOG> m <identifiersep> ticker . queue <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , sleep <identifiersep> time , false , true ) ; } } <comment> public void next <identifiersep> iteration ( ) { m <identifiersep> ticker . reschedule <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , 0 ) ; <ect>
m <identifiersep> ticker . reschedule <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , 0 ) ; } protected void abort <identifiersep> all <identifiersep> transfers ( ) { logger . debug ( this , <string_literal> ) ; abort <identifiersep> fetches ( ) ; abort <identifiersep> inserts ( ) ; } protected void abort <identifiersep> fetches ( ) { <LOG> if ( m <identifiersep> fetches != null ) synchronized ( m <identifiersep> fetches ) { client <identifiersep> getter [ ] fetches = m <identifiersep> fetches . to <identifiersep> array ( new client <identifiersep> getter [ m <identifiersep> fetches . size ( ) ] ) ; int fcounter = 0 ; for ( client <identifiersep> getter fetch : fetches ) { <comment> fetch . cancel ( m <identifiersep> node . client <identifiersep> core . client <identifiersep> context ) ; <ect>
for ( client <identifiersep> getter fetch : fetches ) { <comment> fetch . cancel ( m <identifiersep> node . client <identifiersep> core . client <identifiersep> context ) ; ++ fcounter ; } logger . debug ( this , <string_literal> + fcounter + <string_literal> ) ; } } protected void abort <identifiersep> inserts ( ) { <LOG> if ( m <identifiersep> inserts != null ) synchronized ( m <identifiersep> inserts ) { base <identifiersep> client <identifiersep> putter [ ] inserts = m <identifiersep> inserts . to <identifiersep> array ( new base <identifiersep> client <identifiersep> putter [ m <identifiersep> inserts . size ( ) ] ) ; int icounter = 0 ; for ( base <identifiersep> client <identifiersep> putter insert : inserts ) { <comment> insert . cancel ( m <identifiersep> node . client <identifiersep> core . client <identifiersep> context ) ; <ect>
protected void add <identifiersep> fetch ( client <identifiersep> getter g ) { synchronized ( m <identifiersep> fetches ) { m <identifiersep> fetches . add ( g ) ; } } protected void remove <identifiersep> fetch ( client <identifiersep> getter g ) { synchronized ( m <identifiersep> fetches ) { m <identifiersep> fetches . remove ( g ) ; } <LOG> } protected void add <identifiersep> insert ( base <identifiersep> client <identifiersep> putter p ) { synchronized ( m <identifiersep> inserts ) { m <identifiersep> inserts . add ( p ) ; } } protected void remove <identifiersep> insert ( base <identifiersep> client <identifiersep> putter p ) { synchronized ( m <identifiersep> inserts ) { m <identifiersep> inserts . remove ( p ) ; <ect>
synchronized ( m <identifiersep> fetches ) { return m <identifiersep> fetches . size ( ) ; } } protected int insert <identifiersep> count ( ) { synchronized ( m <identifiersep> inserts ) { return m <identifiersep> inserts . size ( ) ; } } public void terminate ( ) { <LOG> m <identifiersep> ticker . shutdown ( ) ; try { abort <identifiersep> all <identifiersep> transfers ( ) ; } catch ( runtime <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; } logger . debug ( this , <string_literal> ) ; <ect>
logger . debug ( this , <string_literal> ) ; m <identifiersep> ticker . shutdown ( ) ; try { abort <identifiersep> all <identifiersep> transfers ( ) ; } catch ( runtime <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; } <LOG> } protected abstract collection < client <identifiersep> getter > create <identifiersep> fetch <identifiersep> storage ( ) ; protected abstract collection < base <identifiersep> client <identifiersep> putter > create <identifiersep> insert <identifiersep> storage ( ) ; protected abstract long get <identifiersep> startup <identifiersep> delay ( ) ; protected abstract long get <identifiersep> sleep <identifiersep> time ( ) ; <comment> <ect>
thread <identifiersep> started = false ; } return ; } try { job . run ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <LOG> } } } finally { synchronized ( sync <identifiersep> lock ) { running <identifiersep> thread = null ; } } } } ; public serial <identifiersep> executor ( int priority ) { this ( priority , 0 ) ; <ect>
** / public class url <identifiersep> decoder { <comment> <LOG> } } <comment> <ect>
@ override public string to <identifiersep> string ( ) { string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; try { write <identifiersep> to ( sw ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return sw . to <identifiersep> string ( ) ; } public string to <identifiersep> ordered <identifiersep> string ( ) { string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; try { write <identifiersep> to <identifiersep> ordered ( sw ) ; } catch ( io <identifiersep> exception e ) { <ect>
return sw . to <identifiersep> string ( ) ; } public string to <identifiersep> ordered <identifiersep> string <identifiersep> with <identifiersep> base64 ( ) { string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; try { write <identifiersep> to <identifiersep> ordered ( sw , <string_literal> , false , true ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return sw . to <identifiersep> string ( ) ; } public string get <identifiersep> end <identifiersep> marker ( ) { return end <identifiersep> marker ; } public void set <identifiersep> end <identifiersep> marker ( string s ) { end <identifiersep> marker = s ; } public synchronized simple <identifiersep> field <identifiersep> set subset ( string key ) { <ect>
output <identifiersep> stream <identifiersep> writer osw = null ; buffered <identifiersep> writer bw = null ; bos = new buffered <identifiersep> output <identifiersep> stream ( os , buffer <identifiersep> size ) ; try { osw = new output <identifiersep> stream <identifiersep> writer ( bos , <string_literal> ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { <LOG> throw e ; } bw = new buffered <identifiersep> writer ( osw ) ; write <identifiersep> to ( bw ) ; bw . flush ( ) ; } <comment> <ect>
if ( strings == null ) return null ; short [ ] ret = new short [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { try { ret [ i ] = short . parse <identifiersep> short ( strings [ i ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return null ; } } return ret ; } public long [ ] get <identifiersep> long <identifiersep> array ( string key ) { string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; long [ ] ret = new long [ strings . length ] ; <ect>
system . err . println ( e . get <identifiersep> class ( ) ) ; system . err . println ( e . get <identifiersep> message ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <LOG> t . print <identifiersep> stack <identifiersep> trace ( system . err ) ; } } } private file rotate <identifiersep> log ( file current <identifiersep> filename , long last <identifiersep> time , long next <identifiersep> hour , gregorian <identifiersep> calendar gc ) { <comment> <ect>
logger . minor ( this , <string_literal> + olf . filename + <string_literal> + olf . size + <string_literal> + old <identifiersep> log <identifiersep> files <identifiersep> disk <identifiersep> space <identifiersep> usage + <string_literal> + max <identifiersep> old <identifiersep> logfiles <identifiersep> disk <identifiersep> usage ) ; } } } <comment> public void find <identifiersep> old <identifiersep> log <identifiersep> files ( gregorian <identifiersep> calendar gc ) { gc = ( gregorian <identifiersep> calendar ) gc . clone ( ) ; file current <identifiersep> filename = new file ( get <identifiersep> hour <identifiersep> log <identifiersep> name ( gc , - 1 , true ) ) ; <LOG> file numeric <identifiersep> same <identifiersep> date <identifiersep> filename ; int slash <identifiersep> index = base <identifiersep> filename . last <identifiersep> index <identifiersep> of ( file . separator <identifiersep> char ) ; file dir ; string prefix ; if ( slash <identifiersep> index == - 1 ) { dir = new file ( system . get <identifiersep> property ( <string_literal> ) ) ; <ect>
if ( current <identifiersep> filename != null && current <identifiersep> filename . exists ( ) ) { system . out . println ( <string_literal> + current <identifiersep> filename ) ; for ( int a = 1 ; ; a ++ ) { numeric <identifiersep> same <identifiersep> date <identifiersep> filename = new file ( get <identifiersep> hour <identifiersep> log <identifiersep> name ( gc , a , true ) ) ; if ( numeric <identifiersep> same <identifiersep> date <identifiersep> filename == null || ! numeric <identifiersep> same <identifiersep> date <identifiersep> filename . exists ( ) ) { if ( numeric <identifiersep> same <identifiersep> date <identifiersep> filename != null ) { <LOG> file <identifiersep> util . rename <identifiersep> to ( current <identifiersep> filename , numeric <identifiersep> same <identifiersep> date <identifiersep> filename ) ; } break ; } } } if ( old <identifiersep> file != null ) { long l = old <identifiersep> file . length ( ) ; old <identifiersep> log <identifiersep> file olf = new old <identifiersep> log <identifiersep> file ( old <identifiersep> file , last <identifiersep> start <identifiersep> time , system . current <identifiersep> time <identifiersep> millis ( ) , l ) ; synchronized ( log <identifiersep> files ) { <ect>
byte [ ] buf = new byte [ <number_literal> ] ; while ( written < size ) { int to <identifiersep> read = ( int ) math . min ( buf . length , ( size - written ) ) ; try { dis . read <identifiersep> fully ( buf , 0 , to <identifiersep> read ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } os . write ( buf , 0 , to <identifiersep> read ) ; written += to <identifiersep> read ; } dis . close ( ) ; fis . close ( ) ; } <comment> <ect>
temp <identifiersep> uri = temp <identifiersep> uri . ssk <identifiersep> for <identifiersep> usk ( ) ; errors . add ( <string_literal> ) ; if ( break <identifiersep> on <identifiersep> errors ) break outer ; } else { throw new malformed <identifiersep> url <identifiersep> exception ( <string_literal> ) ; } } break ; } <LOG> } } return temp <identifiersep> uri ; } } <ect>
try { j . try <identifiersep> compress ( context ) ; } catch ( insert <identifiersep> exception e ) { j . on <identifiersep> failure ( e , null , context ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
public int get <identifiersep> priority ( ) { return native <identifiersep> thread . min <identifiersep> priority ; } } , <string_literal> + j ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + j + <string_literal> ) ; } catch ( rejected <identifiersep> execution <identifiersep> exception e ) { <LOG> task = null ; } } } private static int get <identifiersep> max <identifiersep> running <identifiersep> compression <identifiersep> threads ( ) { int max <identifiersep> running <identifiersep> threads = 1 ; string os <identifiersep> name = system . get <identifiersep> property ( <string_literal> ) ; if ( ! os <identifiersep> name . contains ( <string_literal> ) && ( os <identifiersep> name . to <identifiersep> lower <identifiersep> case ( ) . index <identifiersep> of ( <string_literal> ) > 0 ) || ( ! native <identifiersep> thread . using <identifiersep> native <identifiersep> code ( ) ) ) <comment> <ect>
<comment> <LOG> } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
if ( ! dirty ) return ; } writing = true ; } try { logger . normal ( this , <string_literal> + this ) ; write <identifiersep> buffer ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } synchronized ( this ) { writing = false ; } try { raf . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + filename , e ) ; <ect>
synchronized ( this ) { if ( closed ) return ; closed = true ; } try { raf . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } finally { lock . write <identifiersep> lock ( ) . unlock ( ) ; } } private void write <identifiersep> buffer ( ) throws io <identifiersep> exception { <comment> <ect>
<comment> <LOG> } } finally { synchronized ( this ) { writing = false ; } lock . read <identifiersep> lock ( ) . unlock ( ) ; } } public boolean is <identifiersep> new ( ) { return is <identifiersep> new ; <ect>
} while ( true ) ; condition = entry <identifiersep> lock . new <identifiersep> condition ( ) ; lock <identifiersep> map . put ( offset , condition ) ; } finally { entry <identifiersep> lock . unlock ( ) ; } } catch ( interrupted <identifiersep> exception e ) { <LOG> return null ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + offset , new exception ( ) ) ; return condition ; } <comment> <ect>
return condition ; } <comment> void unlock <identifiersep> entry ( long offset , condition condition ) { if ( log <identifiersep> debug ) <LOG> entry <identifiersep> lock . lock ( ) ; try { condition cond = lock <identifiersep> map . remove ( offset ) ; assert cond == condition ; cond . signal ( ) ; } finally { <ect>
store <identifiersep> size = max <identifiersep> keys ; write <identifiersep> config <identifiersep> file ( ) ; } new <identifiersep> store | = open <identifiersep> store <identifiersep> files ( base <identifiersep> dir , name ) ; bloom <identifiersep> file = new file ( this . base <identifiersep> dir , name + <string_literal> ) ; if ( bloom <identifiersep> file . exists ( ) ) { bloom <identifiersep> file . delete ( ) ; <LOG> system . err . println ( <string_literal> ) ; } file slot <identifiersep> filter <identifiersep> file = new file ( this . base <identifiersep> dir , name + <string_literal> ) ; int size = ( int ) math . max ( store <identifiersep> size , prev <identifiersep> store <identifiersep> size ) ; slot <identifiersep> filter <identifiersep> disabled = ! enable <identifiersep> slot <identifiersep> filters ; if ( ! slot <identifiersep> filter <identifiersep> disabled ) { slot <identifiersep> filter = new resizable <identifiersep> persistent <identifiersep> int <identifiersep> buffer ( slot <identifiersep> filter <identifiersep> file , size ) ; <ect>
system . err . println ( <string_literal> ) ; } file slot <identifiersep> filter <identifiersep> file = new file ( this . base <identifiersep> dir , name + <string_literal> ) ; int size = ( int ) math . max ( store <identifiersep> size , prev <identifiersep> store <identifiersep> size ) ; slot <identifiersep> filter <identifiersep> disabled = ! enable <identifiersep> slot <identifiersep> filters ; if ( ! slot <identifiersep> filter <identifiersep> disabled ) { slot <identifiersep> filter = new resizable <identifiersep> persistent <identifiersep> int <identifiersep> buffer ( slot <identifiersep> filter <identifiersep> file , size ) ; <LOG> if ( new <identifiersep> store && slot <identifiersep> filter . is <identifiersep> new ( ) ) slot <identifiersep> filter . fill ( slot <identifiersep> checked ) ; } else { if ( slot <identifiersep> filter <identifiersep> file . exists ( ) ) { if ( slot <identifiersep> filter <identifiersep> file . delete ( ) ) { system . err . println ( <string_literal> ) ; <ect>
slot <identifiersep> filter . fill ( slot <identifiersep> checked ) ; } else { if ( slot <identifiersep> filter <identifiersep> file . exists ( ) ) { if ( slot <identifiersep> filter <identifiersep> file . delete ( ) ) { system . err . println ( <string_literal> ) ; } else { <LOG> } } slot <identifiersep> filter = null ; } if ( ( flags & flag <identifiersep> dirty ) != 0 ) system . err . println ( <string_literal> + name + <string_literal> ) ; flags | = flag <identifiersep> dirty ; <comment> <ect>
for ( int i = 0 ; i < offset . length ; i ++ ) { if ( offset [ i ] < store <identifiersep> file <identifiersep> offset <identifiersep> ready ) { long flag = get <identifiersep> flag ( offset [ i ] , false ) ; if ( ( flag & entry . entry <identifiersep> flag <identifiersep> occupied ) == 0 ) { <comment> <LOG> write <identifiersep> entry ( entry , digested <identifiersep> key , offset [ i ] ) ; key <identifiersep> count . increment <identifiersep> and <identifiersep> get ( ) ; on <identifiersep> write ( ) ; return true ; } else if ( ( ( flag & entry . entry <identifiersep> wrong <identifiersep> store ) == entry . entry <identifiersep> wrong <identifiersep> store ) ) { if ( wrong <identifiersep> store <identifiersep> count == 0 ) <ect>
else logger . minor ( this , <string_literal> ) ; } byte <identifiersep> buffer mbf = byte <identifiersep> buffer . allocate ( entry . metadata <identifiersep> length ) ; do { int status = meta <identifiersep> fc . read ( mbf , entry . metadata <identifiersep> length * offset + mbf . position ( ) ) ; if ( status == - 1 ) { <LOG> throw new eof <identifiersep> exception ( ) ; } } while ( mbf . has <identifiersep> remaining ( ) ) ; mbf . flip ( ) ; entry entry = new entry ( mbf , null ) ; entry . cur <identifiersep> offset = offset ; byte [ ] slot <identifiersep> digested <identifiersep> routing <identifiersep> key = entry . digested <identifiersep> routing <identifiersep> key ; <ect>
if ( valid <identifiersep> cache ) logger . error ( this , <string_literal> + offset + <string_literal> + cache + <string_literal> + true <identifiersep> cache ) ; slot <identifiersep> filter . put ( ( int ) offset , true <identifiersep> cache ) ; } if ( routing <identifiersep> key != null ) { if ( entry . is <identifiersep> free ( ) ) { if ( valid <identifiersep> cache && ! likely <identifiersep> match && ! slot <identifiersep> cache <identifiersep> is <identifiersep> free ( cache ) ) { <LOG> bloom <identifiersep> false <identifiersep> pos . increment <identifiersep> and <identifiersep> get ( ) ; } else if ( log <identifiersep> minor && valid <identifiersep> cache && ! likely <identifiersep> match && slot <identifiersep> cache <identifiersep> is <identifiersep> free ( cache ) ) logger . minor ( this , <string_literal> ) ; return null ; } if ( ! arrays . equals ( digested <identifiersep> routing <identifiersep> key , slot <identifiersep> digested <identifiersep> routing <identifiersep> key ) ) { if ( valid <identifiersep> cache && likely <identifiersep> match ) { <ect>
private void flush <identifiersep> and <identifiersep> close ( boolean abort ) { logger . normal ( this , <string_literal> + name ) ; try { meta <identifiersep> fc . force ( true ) ; meta <identifiersep> fc . close ( ) ; } catch ( exception e ) { <LOG> } try { hd <identifiersep> fc . force ( true ) ; hd <identifiersep> fc . close ( ) ; } catch ( exception e ) { logger . error ( this , <string_literal> , e ) ; } if ( ! slot <identifiersep> filter <identifiersep> disabled ) { <ect>
fallocate . for <identifiersep> channel ( meta <identifiersep> fc , new <identifiersep> meta <identifiersep> len ) . from <identifiersep> offset ( old <identifiersep> meta <identifiersep> len ) . execute ( ) ; fallocate . for <identifiersep> channel ( hd <identifiersep> fc , new <identifiersep> hd <identifiersep> len ) . from <identifiersep> offset ( current <identifiersep> hd <identifiersep> len ) . execute ( ) ; } } store <identifiersep> file <identifiersep> offset <identifiersep> ready = 1 + store <identifiersep> max <identifiersep> entries ; meta <identifiersep> raf . set <identifiersep> length ( new <identifiersep> meta <identifiersep> len ) ; hd <identifiersep> raf . set <identifiersep> length ( new <identifiersep> hd <identifiersep> len ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } <comment> <ect>
} catch ( unsupported <identifiersep> cipher <identifiersep> exception e ) { throw new error ( <string_literal> + e , e ) ; } cipher . initialize ( master <identifiersep> key ) ; salt = new byte [ 0x10 ] ; cipher . decipher ( disk <identifiersep> salt , salt ) ; if ( log <identifiersep> debug ) <LOG> } cipher <identifiersep> manager = new cipher <identifiersep> manager ( salt , disk <identifiersep> salt ) ; store <identifiersep> size = raf . read <identifiersep> long ( ) ; if ( store <identifiersep> size < = 0 ) throw new io <identifiersep> exception ( <string_literal> ) ; prev <identifiersep> store <identifiersep> size = raf . read <identifiersep> long ( ) ; key <identifiersep> count . set ( raf . read <identifiersep> long ( ) ) ; generation = raf . read <identifiersep> int ( ) ; <ect>
return false ; } finally { closer . close ( raf ) ; } } catch ( io <identifiersep> exception e ) { <comment> <LOG> if ( config <identifiersep> file . exists ( ) && config <identifiersep> file . delete ( ) ) { file meta <identifiersep> file = new file ( base <identifiersep> dir , name + <string_literal> ) ; meta <identifiersep> file . delete ( ) ; return load <identifiersep> config <identifiersep> file ( master <identifiersep> key ) ; } <comment> <ect>
if ( config <identifiersep> file . exists ( ) && config <identifiersep> file . delete ( ) ) { file meta <identifiersep> file = new file ( base <identifiersep> dir , name + <string_literal> ) ; meta <identifiersep> file . delete ( ) ; return load <identifiersep> config <identifiersep> file ( master <identifiersep> key ) ; } <comment> <LOG> throw e ; } } } <comment> private void write <identifiersep> config <identifiersep> file ( ) { config <identifiersep> lock . write <identifiersep> lock ( ) . lock ( ) ; <ect>
is <identifiersep> rebuilding = false ; cleaner <identifiersep> global <identifiersep> lock . unlock ( ) ; } } write <identifiersep> config <identifiersep> file ( ) ; try { cleaner <identifiersep> condition . await ( cleaner <identifiersep> period , time <identifiersep> unit . milliseconds ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } } finally { cleaner <identifiersep> lock . unlock ( ) ; } } } private static final int resize <identifiersep> memory <identifiersep> entries = <number_literal> ; <comment> <ect>
try { entry . set <identifiersep> hd ( read <identifiersep> hd ( entry . cur <identifiersep> offset ) ) ; old <identifiersep> entry <identifiersep> list . add ( entry ) ; if ( old <identifiersep> entry <identifiersep> list . size ( ) > resize <identifiersep> memory <identifiersep> entries ) old <identifiersep> entry <identifiersep> list . poll ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return null ; } int i = 0 ; @ override public boolean batch ( long entries <identifiersep> left ) { wrapper <identifiersep> manager . signal <identifiersep> starting ( ( int ) ( resize <identifiersep> memory <identifiersep> entries * seconds . to <identifiersep> millis ( <number_literal> ) + seconds . to <identifiersep> millis ( 1 ) ) ) ; if ( i ++ % <number_literal> == 0 ) <ect>
config <identifiersep> lock . write <identifiersep> lock ( ) . lock ( ) ; try { flags & = ~flag <identifiersep> rebuild <identifiersep> bloom ; write <identifiersep> config <identifiersep> file ( ) ; } finally { config <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; } <LOG> logger . normal ( this , <string_literal> + name + <string_literal> ) ; } public boolean want <identifiersep> free <identifiersep> entries ( ) { return true ; } } ; batch <identifiersep> process <identifiersep> entries ( rebuild <identifiersep> bloom <identifiersep> processor , store <identifiersep> size , false , sleep ) ; } private volatile long entries <identifiersep> left ; <ect>
thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { processor . abort ( ) ; return ; } } processor . finish ( ) ; } catch ( exception e ) { <LOG> processor . abort ( ) ; } } <comment> <ect>
buf . put ( byte <identifiersep> buffer . allocate ( entry . metadata <identifiersep> length ) ) ; key <identifiersep> count . decrement <identifiersep> and <identifiersep> get ( ) ; if ( ! slot <identifiersep> filter <identifiersep> disabled ) try { slot <identifiersep> filter . put ( ( int ) ( offset + j ) , slot <identifiersep> checked ) ; } catch ( io <identifiersep> exception e ) { <LOG> } dirty = true ; } else if ( new <identifiersep> entry == not <identifiersep> modified ) { } else { <comment> <ect>
if ( dirty ) { buf . flip ( ) ; try { while ( buf . has <identifiersep> remaining ( ) ) { meta <identifiersep> fc . write ( buf , start <identifiersep> file <identifiersep> offset + buf . position ( ) ) ; } } catch ( io <identifiersep> exception ioe ) { <LOG> } } } return true ; } finally { <comment> <ect>
if ( is <identifiersep> free ( offset ) ) { byte [ ] digested <identifiersep> key = entry . get <identifiersep> digested <identifiersep> routing <identifiersep> key ( ) ; write <identifiersep> entry ( entry , digested <identifiersep> key , offset ) ; key <identifiersep> count . increment <identifiersep> and <identifiersep> get ( ) ; return true ; } } catch ( io <identifiersep> exception e ) { <LOG> } } return false ; } finally { unlock <identifiersep> digested <identifiersep> key ( entry . get <identifiersep> digested <identifiersep> routing <identifiersep> key ( ) , false , lock <identifiersep> map ) ; } } } private final class cleaner <identifiersep> status <identifiersep> user <identifiersep> alert extends abstract <identifiersep> user <identifiersep> alert { private cleaner cleaner ; private cleaner <identifiersep> status <identifiersep> user <identifiersep> alert ( cleaner cleaner ) { <ect>
if ( shrink <identifiersep> now ) { config <identifiersep> lock . write <identifiersep> lock ( ) . lock ( ) ; try { system . err . println ( <string_literal> ) ; while ( prev <identifiersep> store <identifiersep> size == old ) { resize <identifiersep> complete <identifiersep> condition . await <identifiersep> uninterruptibly ( ) ; } <LOG> } finally { config <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; } } } <comment> <ect>
return store . fetch ( hash , null , dont <identifiersep> promote , false , false , ignore <identifiersep> old <identifiersep> blocks , meta ) ; } final private static byte [ ] empty = new byte [ 0 ] ; public void put ( byte [ ] hash , dsa <identifiersep> public <identifiersep> key key , boolean is <identifiersep> old <identifiersep> block ) throws io <identifiersep> exception { try { store . put ( key , key . as <identifiersep> padded <identifiersep> bytes ( ) , empty , false , is <identifiersep> old <identifiersep> block ) ; } catch ( key <identifiersep> collision <identifiersep> exception e ) { <LOG> } } @ override public int data <identifiersep> length ( ) { return dsa <identifiersep> public <identifiersep> key . padded <identifiersep> size ; } @ override public int full <identifiersep> key <identifiersep> length ( ) { return dsa <identifiersep> public <identifiersep> key . hash <identifiersep> length ; <ect>
public static void main ( string [ ] args ) { if ( args . length < 1 ) { system . err . println ( <string_literal> ) ; system . exit ( - 1 ) ; } final file reference = new file ( args [ 0 ] ) ; if ( ( reference == null ) || ! ( reference . is <identifiersep> file ( ) ) || ! ( reference . can <identifiersep> read ( ) ) ) { <LOG> system . exit ( - 1 ) ; } new add <identifiersep> ref ( reference ) ; } add <identifiersep> ref ( file reference ) { socket fcp <identifiersep> socket = null ; fcp <identifiersep> message fcpm ; simple <identifiersep> field <identifiersep> set sfs = new simple <identifiersep> field <identifiersep> set ( true ) ; <ect>
fcpm = fcp <identifiersep> message . create ( add <identifiersep> peer . name , sfs ) ; fcpm . send ( os ) ; os . flush ( ) ; <comment> <LOG> me . print <identifiersep> stack <identifiersep> trace ( ) ; } lis . close ( ) ; is . close ( ) ; os . close ( ) ; fcp <identifiersep> socket . close ( ) ; system . out . println ( <string_literal> ) ; <ect>
buffered <identifiersep> reader br = new buffered <identifiersep> reader ( isr ) ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; boolean changed = false ; while ( true ) { string line = br . read <identifiersep> line ( ) ; if ( line == null ) { <LOG> system . exit ( <number_literal> ) ; } int idx = line . index <identifiersep> of ( ' = ' ) ; if ( idx == - 1 ) { <comment> <ect>
if ( ! line . equals ( <string_literal> ) ) { system . err . println ( <string_literal> + f + <string_literal> + line + <string_literal> ) ; system . exit ( 1 ) ; } sw . append ( line + <string_literal> ) ; line = br . read <identifiersep> line ( ) ; if ( line != null ) { <LOG> system . exit ( <number_literal> ) ; } break ; } string before = line . substring ( 0 , idx ) ; <comment> <ect>
file <identifiersep> output <identifiersep> stream fos = new file <identifiersep> output <identifiersep> stream ( f ) ; output <identifiersep> stream <identifiersep> writer osw = new output <identifiersep> stream <identifiersep> writer ( fos , <string_literal> ) ; try { osw . write ( sw . to <identifiersep> string ( ) ) ; } finally { osw . close ( ) ; } <LOG> } } } <ect>
<comment> public static void main ( string [ ] args ) throws io <identifiersep> exception { if ( args . length < <number_literal> || args . length > <number_literal> ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; return ; } file f1 = new file ( args [ 0 ] ) ; file f2 = new file ( args [ 1 ] ) ; simple <identifiersep> field <identifiersep> set fs1 = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( f1 , false , true ) ; <ect>
<comment> public static void main ( string [ ] args ) throws io <identifiersep> exception { if ( args . length < <number_literal> || args . length > <number_literal> ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> return ; } file f1 = new file ( args [ 0 ] ) ; file f2 = new file ( args [ 1 ] ) ; simple <identifiersep> field <identifiersep> set fs1 = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( f1 , false , true ) ; simple <identifiersep> field <identifiersep> set fs2 = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( f2 , false , true ) ; fs1 . put <identifiersep> all <identifiersep> overwrite ( fs2 ) ; <ect>
if ( sent . bit <identifiersep> at ( x ) && !  <identifiersep> prb . is <identifiersep> received ( x ) ) { missing ++ ; } } if ( log <identifiersep> minor && missing != 0 ) logger . minor ( this , <string_literal> + missing ) ; } } catch ( aborted <identifiersep> exception e ) { <comment> <LOG> complete ( retrieval <identifiersep> exception . unknown , <string_literal> ) ; return ; } } else if ( m1 != null && m1 . get <identifiersep> spec ( ) . equals ( dmt . all <identifiersep> sent ) ) { synchronized ( block <identifiersep> receiver . this ) { if ( completed ) return ; if ( got <identifiersep> all <identifiersep> sent ) <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } @ override public boolean should <identifiersep> timeout ( ) { return false ; } @ override public void on <identifiersep> timeout ( ) { <LOG>  <identifiersep> timeout <identifiersep> handler . on <identifiersep> fatal <identifiersep> timeout (  <identifiersep> sender ) ; } @ override public void on <identifiersep> disconnect ( peer <identifiersep> context ctx ) { <comment> <ect>
try { send <identifiersep> aborted (  <identifiersep> prb .  <identifiersep> abort <identifiersep> reason ,  <identifiersep> prb .  <identifiersep> abort <identifiersep> description ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> callback . block <identifiersep> received ( block ) ; } dec <identifiersep> running <identifiersep> block <identifiersep> receives ( ) ; } private void complete ( byte [ ] ret ) { synchronized ( this ) { if ( completed ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <ect>
<comment> void received ( int block <identifiersep> num , byte [ ] data , int offset , int length ) { if ( block <identifiersep> num > blocks ) { <LOG> return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + block <identifiersep> num ) ; bulk <identifiersep> transmitter [ ] notify <identifiersep> b <identifiersep> ts ; long file <identifiersep> offset = ( long ) block <identifiersep> num * ( long ) block <identifiersep> size ; int bs = ( int ) math . min ( block <identifiersep> size , size - file <identifiersep> offset ) ; <ect>
blocks <identifiersep> received . set <identifiersep> bit ( block <identifiersep> num , true ) ; <comment> <LOG> abort ( retrieval <identifiersep> exception . io <identifiersep> error , t . to <identifiersep> string ( ) ) ; } if ( notify <identifiersep> b <identifiersep> ts == null ) return ; for ( bulk <identifiersep> transmitter notify <identifiersep> bt : notify <identifiersep> b <identifiersep> ts ) { <comment> <ect>
if (  <identifiersep> unsent . size ( ) == 0 ) { <comment> <LOG> continue ; } } copy =  <identifiersep> sent <identifiersep> packets . copy ( ) ;  <identifiersep> sent <identifiersep> packets . set <identifiersep> bit ( packet <identifiersep> no , true ) ; } if ( ! inner <identifiersep> run ( packet <identifiersep> no , copy ) ) return ; } } finally { synchronized ( this ) { <ect>
 <identifiersep> received <identifiersep> send <identifiersep> completion = true ;  <identifiersep> received <identifiersep> send <identifiersep> success = false ; } <comment> <LOG> abort <identifiersep> reason = <string_literal> ; } else { <comment> <ect>
 <identifiersep> unsent =  <identifiersep> prb . add <identifiersep> listener ( my <identifiersep> listener = new partially <identifiersep> received <identifiersep> block . packet <identifiersep> received <identifiersep> listener ( ) { ; @ override public void packet <identifiersep> received ( int packet <identifiersep> no ) { synchronized (  <identifiersep> sender <identifiersep> thread ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + packet <identifiersep> no + <string_literal> +  <identifiersep> uid + <string_literal> +  <identifiersep> destination ) ; if (  <identifiersep> unsent . contains ( packet <identifiersep> no ) ) { <LOG> return ; } if (  <identifiersep> sent <identifiersep> packets . bit <identifiersep> at ( packet <identifiersep> no ) ) { logger . error ( this , <string_literal> + packet <identifiersep> no + <string_literal> + this + <string_literal> +  <identifiersep> unsent + <string_literal> +  <identifiersep> sent <identifiersep> packets , new exception ( <string_literal> ) ) ; return ; }  <identifiersep> unsent . add <identifiersep> last ( packet <identifiersep> no ) ; time <identifiersep> all <identifiersep> sent = - 1 ; <ect>
<comment> public class ssl <identifiersep> network <identifiersep> interface extends network <identifiersep> interface { public static network <identifiersep> interface create ( int port , string bind <identifiersep> to , string allowed <identifiersep> hosts , executor executor , boolean ignore <identifiersep> unbindable <identifiersep> ip6 ) throws io <identifiersep> exception { network <identifiersep> interface iface = new ssl <identifiersep> network <identifiersep> interface ( port , allowed <identifiersep> hosts , executor ) ; string [ ] failed <identifiersep> bind = iface . set <identifiersep> bind <identifiersep> to ( bind <identifiersep> to , ignore <identifiersep> unbindable <identifiersep> ip6 ) ; if ( failed <identifiersep> bind != null ) { <LOG> } return iface ; } <comment> protected ssl <identifiersep> network <identifiersep> interface ( int port , string allowed <identifiersep> hosts , executor executor ) throws io <identifiersep> exception { super ( port , allowed <identifiersep> hosts , executor ) ; <ect>
packet <identifiersep> to ( peer , true ) ; } public void received <identifiersep> packet <identifiersep> from ( peer peer ) { packet <identifiersep> to ( peer , false ) ; } private void packet <identifiersep> to ( peer peer , boolean sent ) { peer peer2 = peer . drop <identifiersep> host <identifiersep> name ( ) ; if ( peer2 == null ) { <LOG> return ; } peer = peer2 ; inet <identifiersep> address ip = peer . get <identifiersep> address ( ) ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; synchronized ( this ) { peer <identifiersep> address <identifiersep> tracker <identifiersep> item peer <identifiersep> item = peer <identifiersep> trackers . get ( peer ) ; <ect>
else peer <identifiersep> item . received <identifiersep> packet ( now ) ; inet <identifiersep> address <identifiersep> address <identifiersep> tracker <identifiersep> item ip <identifiersep> item = ip <identifiersep> trackers . get ( ip ) ; if ( ip <identifiersep> item == null ) { ip <identifiersep> item = new inet <identifiersep> address <identifiersep> address <identifiersep> tracker <identifiersep> item ( time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> received <identifiersep> ip , time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> sent <identifiersep> ip , ip ) ; if ( ip <identifiersep> trackers . size ( ) > max <identifiersep> items ) { <LOG> peer <identifiersep> trackers . clear ( ) ; ip <identifiersep> trackers . clear ( ) ; time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> received <identifiersep> ip = now ; time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> sent <identifiersep> ip = now ; } ip <identifiersep> trackers . put ( ip , ip <identifiersep> item ) ; } if ( sent ) <ect>
public int hash <identifiersep> code ( ) { return  <identifiersep> name . hash <identifiersep> code ( ) ; } public static message <identifiersep> type get <identifiersep> spec ( integer spec <identifiersep> id , boolean dont <identifiersep> log ) { message <identifiersep> type id =  <identifiersep> specs . get ( spec <identifiersep> id ) ; if ( id == null ) { if ( ! dont <identifiersep> log ) <LOG> } return id ; } public string get <identifiersep> name ( ) { return  <identifiersep> name ; } public map < string , class < ? > > get <identifiersep> fields ( ) { return  <identifiersep> fields ; } public linked <identifiersep> list < string > get <identifiersep> ordered <identifiersep> fields ( ) { <ect>
address <identifiersep> identifier . address <identifiersep> type address <identifiersep> type = address <identifiersep> identifier . get <identifiersep> address <identifiersep> type ( host ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + host + <string_literal> + address <identifiersep> type + ' \\ '' ) ; if ( address <identifiersep> type != address <identifiersep> identifier . address <identifiersep> type . other ) { <comment> <LOG> if ( addr != null ) { host = null ; } else { addr = null ; } } if ( addr == null ) { if ( log <identifiersep> debug ) logger . debug ( this , ' \\ '' + host + <string_literal> ) ; <ect>
if ( host != null ) { if ( host . starts <identifiersep> with ( <string_literal> ) ) host = host . substring ( 1 ) ; host = host . trim ( ) ; } <comment> <LOG> if ( address <identifiersep> type != address <identifiersep> identifier . address <identifiersep> type . other ) { try { addr = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( host ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( ! allow <identifiersep> unknown ) throw e ; addr = null ; <ect>
addr = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( host ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( ! allow <identifiersep> unknown ) throw e ; addr = null ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + host + <string_literal> + ( addr != null ? addr . get <identifiersep> host <identifiersep> address ( ) + ' \\ '' : <string_literal> ) ) ; if ( addr != null && addr . get <identifiersep> host <identifiersep> address ( ) . equals ( host ) ) { <LOG> host = null ; } else { addr = null ; } } if ( addr == null ) { if ( log <identifiersep> debug ) logger . debug ( this , ' \\ '' + host + <string_literal> ) ; } this .  <identifiersep> address = addr ; <ect>
<comment> public freenet <identifiersep> inet <identifiersep> address drop <identifiersep> hostname ( ) { if (  <identifiersep> address == null ) { <LOG> return null ; } if ( hostname != null ) { return new freenet <identifiersep> inet <identifiersep> address (  <identifiersep> address ) ; } else return this ; } public boolean has <identifiersep> hostname <identifiersep> no <identifiersep> ip ( ) { return hostname != null && hostname . length ( ) > 0 &&  <identifiersep> address == null ; <ect>
string msg = peer . get <identifiersep> peer ( ) + <string_literal> + mspec . get <identifiersep> name ( ) ; if ( in <identifiersep> sub <identifiersep> message ) { if ( log <identifiersep> minor ) logger . minor ( message . class , msg + <string_literal> , e ) ; } else logger . error ( message . class , msg , e ) ; return null ; } catch ( io <identifiersep> exception e ) { <LOG> return null ; } if ( log <identifiersep> minor ) logger . minor ( message . class , <string_literal> + m + <string_literal> + m . get <identifiersep> source ( ) ) ; return m ; } public message ( message <identifiersep> type spec ) { this ( spec , null , 0 ) ; } private message ( message <identifiersep> type spec , peer <identifiersep> context source , int recv <identifiersep> byte <identifiersep> count ) { <ect>
dos . write <identifiersep> short ( temp . length ) ; dos . write ( temp ) ; } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new illegal <identifiersep> state <identifiersep> exception ( e . get <identifiersep> message ( ) ) ; } } } byte [ ] buf = baos . to <identifiersep> byte <identifiersep> array ( ) ; <LOG> return buf ; } @ override public string to <identifiersep> string ( ) { string <identifiersep> builder ret = new string <identifiersep> builder ( <number_literal> ) ; string comma = <string_literal> ; ret . append (  <identifiersep> spec . get <identifiersep> name ( ) ) . append ( <string_literal> ) ; <ect>
public void run ( ) { long now = system . current <identifiersep> time <identifiersep> millis ( ) ; long next <identifiersep> run = now + max <identifiersep> filter <identifiersep> remove <identifiersep> time ; try { next <identifiersep> run = remove <identifiersep> timed <identifiersep> out <identifiersep> filters ( next <identifiersep> run ) ; } catch ( throwable t ) { <LOG> } finally { ticker . queue <identifiersep> timed <identifiersep> job ( this , math . max ( min <identifiersep> filter <identifiersep> remove <identifiersep> time , next <identifiersep> run - system . current <identifiersep> time <identifiersep> millis ( ) ) ) ; } } } , min <identifiersep> filter <identifiersep> remove <identifiersep> time ) ; } <comment> <ect>
if ( log <identifiersep> minor ) { for ( list <identifiersep> iterator < message > it =  <identifiersep> unclaimed . list <identifiersep> iterator ( ) ; it . has <identifiersep> next ( ) ; ) { message m = it . next ( ) ; matched status = f . match ( m , true , t <identifiersep> start ) ; if ( status == matched . matched ) { <comment> <LOG> break ; } } } } else { if ( f . has <identifiersep> callback ( ) && next <identifiersep> timeout > f . get <identifiersep> timeout ( ) ) next <identifiersep> timeout = f . get <identifiersep> timeout ( ) ; } <comment> <ect>
message <identifiersep> filter match = null ; array <identifiersep> list < message <identifiersep> filter > timed <identifiersep> out = null ; synchronized (  <identifiersep> filters ) { for ( list <identifiersep> iterator < message <identifiersep> filter > i =  <identifiersep> filters . list <identifiersep> iterator ( ) ; i . has <identifiersep> next ( ) ; ) { message <identifiersep> filter f = i . next ( ) ; if ( f . matched ( ) ) { <LOG> i . remove ( ) ; continue ; } matched status = f . match ( m , t <identifiersep> start ) ; if ( status == matched . timed <identifiersep> out || status == matched . timed <identifiersep> out <identifiersep> and <identifiersep> matched ) { if ( timed <identifiersep> out == null ) timed <identifiersep> out = new array <identifiersep> list < message <identifiersep> filter > ( ) ; <ect>
f . set <identifiersep> message ( null ) ; f . on <identifiersep> timed <identifiersep> out (  <identifiersep> executor ) ; } } } long t <identifiersep> end = system . current <identifiersep> time <identifiersep> millis ( ) ; long d <identifiersep> t = t <identifiersep> end - t <identifiersep> start ; if ( d <identifiersep> t > <number_literal> ) { if ( d <identifiersep> t > <number_literal> ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( d <identifiersep> t ) + <string_literal> +  <identifiersep> unclaimed . size ( ) + <string_literal> + matched ) ; } } <comment> public void on <identifiersep> disconnect ( peer <identifiersep> context ctx ) { array <identifiersep> list < message <identifiersep> filter > dropped <identifiersep> filters = null ; <comment> <ect>
<comment> public message wait <identifiersep> for ( message <identifiersep> filter filter , byte <identifiersep> counter ctr ) throws disconnected <identifiersep> exception { <LOG> if ( filter . has <identifiersep> callback ( ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( filter . matched ( ) ) { logger . error ( this , <string_literal> + filter , new exception ( <string_literal> ) ) ; filter . clear <identifiersep> matched ( ) ; <ect>
i . add ( filter ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + mf . get <identifiersep> timeout ( ) + <string_literal> + filter . get <identifiersep> timeout ( ) + <string_literal> + filter ) ; break ; } } } } long t <identifiersep> end = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( t <identifiersep> end - now > <number_literal> ) { if ( t <identifiersep> end - now > <number_literal> ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( t <identifiersep> end - now ) + <string_literal> +  <identifiersep> unclaimed . size ( ) + <string_literal> + ret ) ; } <comment> <ect>
while (  <identifiersep> active ) { try { real <identifiersep> run ( packet ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( system . err ) ; <LOG> } } } private void real <identifiersep> run ( datagram <identifiersep> packet packet ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + length + <string_literal> + peer ) ; start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; low <identifiersep> level <identifiersep> filter . process ( data , offset , length , peer , now ) ; end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { <LOG> } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( end <identifiersep> time - start <identifiersep> time ) + <string_literal> ) ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + length ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> <ect>
<comment> @ override public void send <identifiersep> packet ( byte [ ] block <identifiersep> to <identifiersep> send , peer destination , boolean allow <identifiersep> local <identifiersep> addresses ) throws local <identifiersep> address <identifiersep> exception { assert ( block <identifiersep> to <identifiersep> send != null ) ; if ( !  <identifiersep> active ) { <LOG> <comment> <ect>
<comment> <LOG> return ; } } if (  <identifiersep> drop <identifiersep> probability > 0 ) { if ( drop <identifiersep> random . next <identifiersep> int ( ) %  <identifiersep> drop <identifiersep> probability == 0 ) { logger . normal ( this , <string_literal> +  <identifiersep> sock . get <identifiersep> local <identifiersep> port ( ) + <string_literal> + destination . get <identifiersep> port ( ) ) ; return ; } } inet <identifiersep> address address = destination . get <identifiersep> address ( false , allow <identifiersep> local <identifiersep> addresses ) ; <ect>
return max <identifiersep> packet <identifiersep> size ; } public int calculate <identifiersep> max <identifiersep> packet <identifiersep> size ( ) { int old <identifiersep> size = max <identifiersep> packet <identifiersep> size ; int new <identifiersep> size = inner <identifiersep> calculate <identifiersep> max <identifiersep> packet <identifiersep> size ( ) ; max <identifiersep> packet <identifiersep> size = new <identifiersep> size ; if ( old <identifiersep> size != new <identifiersep> size ) <LOG> return max <identifiersep> packet <identifiersep> size ; } <comment> int inner <identifiersep> calculate <identifiersep> max <identifiersep> packet <identifiersep> size ( ) { <comment> <ect>
new <identifiersep> address <identifiersep> matchers . add ( new inet4address <identifiersep> matcher ( allowed <identifiersep> host ) ) ; } else if ( address <identifiersep> type == address <identifiersep> type . i <identifiersep> pv6 ) { new <identifiersep> address <identifiersep> matchers . add ( new inet6address <identifiersep> matcher ( allowed <identifiersep> host ) ) ; } else if ( allowed <identifiersep> host . equals ( <string_literal> ) ) { new <identifiersep> address <identifiersep> matchers . add ( new everything <identifiersep> matcher ( ) ) ; } else { <LOG> } } synchronized ( this ) { this . address <identifiersep> matchers . clear ( ) ; this . address <identifiersep> matchers . add <identifiersep> all ( new <identifiersep> address <identifiersep> matchers ) ; } } public boolean allowed ( inet <identifiersep> address client <identifiersep> address ) { address <identifiersep> type client <identifiersep> address <identifiersep> type = address <identifiersep> identifier . get <identifiersep> address <identifiersep> type ( client <identifiersep> address . get <identifiersep> host <identifiersep> address ( ) ) ; return allowed ( client <identifiersep> address <identifiersep> type , client <identifiersep> address ) ; <ect>
return new file <identifiersep> persistent <identifiersep> config ( load ( filename , temp <identifiersep> filename ) , filename , temp <identifiersep> filename , header ) ; } static simple <identifiersep> field <identifiersep> set load ( file filename , file temp <identifiersep> filename ) throws io <identifiersep> exception { boolean filename <identifiersep> exists = filename . exists ( ) ; boolean temp <identifiersep> filename <identifiersep> exists = temp <identifiersep> filename . exists ( ) ; if ( filename <identifiersep> exists && ! filename . can <identifiersep> write ( ) ) { logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + filename ) ; <LOG> } if ( temp <identifiersep> filename <identifiersep> exists && ! temp <identifiersep> filename . can <identifiersep> write ( ) ) { logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + temp <identifiersep> filename ) ; system . err . println ( <string_literal> + temp <identifiersep> filename ) ; } if ( filename <identifiersep> exists ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { try { <ect>
boolean temp <identifiersep> filename <identifiersep> exists = temp <identifiersep> filename . exists ( ) ; if ( filename <identifiersep> exists && ! filename . can <identifiersep> write ( ) ) { logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + filename ) ; system . err . println ( <string_literal> + filename ) ; } if ( temp <identifiersep> filename <identifiersep> exists && ! temp <identifiersep> filename . can <identifiersep> write ( ) ) { logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + temp <identifiersep> filename ) ; <LOG> } if ( filename <identifiersep> exists ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { try { return initial <identifiersep> load ( filename ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> + e + <string_literal> + temp <identifiersep> filename ) ; <ect>
if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { try { return initial <identifiersep> load ( filename ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> + e + <string_literal> + temp <identifiersep> filename ) ; } catch ( eof <identifiersep> exception e ) { <LOG> } <comment> <ect>
system . err . println ( <string_literal> + filename ) ; } } if ( temp <identifiersep> filename . exists ( ) ) { if ( temp <identifiersep> filename . can <identifiersep> read ( ) && temp <identifiersep> filename . length ( ) > 0 ) { try { return initial <identifiersep> load ( temp <identifiersep> filename ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> } <comment> <ect>
} catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { system . err . println ( <string_literal> + temp <identifiersep> filename + <string_literal> + e ) ; } <comment> <LOG> return null ; } protected file <identifiersep> persistent <identifiersep> config ( simple <identifiersep> field <identifiersep> set orig <identifiersep> fs , file fnam , file temp ) throws io <identifiersep> exception { this ( orig <identifiersep> fs , fnam , temp , null ) ; } protected file <identifiersep> persistent <identifiersep> config ( simple <identifiersep> field <identifiersep> set orig <identifiersep> fs , file fnam , file temp , string header ) throws io <identifiersep> exception { super ( orig <identifiersep> fs ) ; this . filename = fnam ; <ect>
val = orig <identifiersep> config <identifiersep> file <identifiersep> contents . get ( name ) ; orig <identifiersep> config <identifiersep> file <identifiersep> contents . remove <identifiersep> value ( name ) ; if ( val == null ) return ; } try { o . set <identifiersep> initial <identifiersep> value ( val . trim ( ) ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e ) { <LOG> } } <comment> public synchronized simple <identifiersep> field <identifiersep> set get <identifiersep> simple <identifiersep> field <identifiersep> set ( ) { <ect>
} catch ( io <identifiersep> exception e ) { closer . close ( fis ) ; closer . close ( fos ) ; fis = null ; fos = null ; if ( old <identifiersep> config . exists ( ) ) new <identifiersep> config . delete ( ) ; <LOG> system . err . println ( <string_literal> + name + <string_literal> + e ) ; return false ; } finally { closer . close ( fis ) ; closer . close ( fos ) ; } if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { <ect>
fs . put <identifiersep> single ( key , o . get <identifiersep> localised <identifiersep> long <identifiersep> desc ( ) ) ; break ; case data <identifiersep> type : fs . put <identifiersep> single ( key , o . get <identifiersep> data <identifiersep> type <identifiersep> str ( ) ) ; break ; default : <LOG> break ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + prefix + ' . ' + key + <string_literal> + o . get <identifiersep> value <identifiersep> string ( ) ) ; } return fs ; } <comment> <ect>
return buf ; } public static byte crypto <identifiersep> algorithm <identifiersep> from <identifiersep> full <identifiersep> key ( byte [ ] full <identifiersep> key ) { return full <identifiersep> key [ 1 ] ; } public static byte [ ] routing <identifiersep> key <identifiersep> from <identifiersep> full <identifiersep> key ( byte [ ] key <identifiersep> buf ) { if ( key <identifiersep> buf . length == key <identifiersep> length ) return key <identifiersep> buf ; if ( key <identifiersep> buf . length != full <identifiersep> key <identifiersep> length ) { <LOG> return null ; } if ( key <identifiersep> buf [ 0 ] != 1 || ( key <identifiersep> buf [ 1 ] != key . algo <identifiersep> aes <identifiersep> pcfb <identifiersep> <number_literal> <identifiersep> sha256 && key <identifiersep> buf [ 1 ] != key . algo <identifiersep> aes <identifiersep> ctr <identifiersep> <number_literal> <identifiersep> sha256 ) ) { if ( key <identifiersep> buf [ key <identifiersep> buf . length - 1 ] == 0 && key <identifiersep> buf [ key <identifiersep> buf . length - <number_literal> ] == 0 ) { <comment> <ect>
throw new null <identifiersep> pointer <identifiersep> exception ( ) ; if ( cached <identifiersep> node <identifiersep> key == null || cached <identifiersep> node <identifiersep> key . get <identifiersep> key <identifiersep> bytes ( ) == null || cached <identifiersep> node <identifiersep> key . get <identifiersep> routing <identifiersep> key ( ) == null ) cached <identifiersep> node <identifiersep> key = new node <identifiersep> ssk ( pub <identifiersep> key <identifiersep> hash , eh <identifiersep> docname , pub <identifiersep> key , crypto <identifiersep> algorithm ) ; node <identifiersep> key = cached <identifiersep> node <identifiersep> key ; } return clone <identifiersep> key ? node <identifiersep> key . clone <identifiersep> key ( ) : node <identifiersep> key ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { <LOG> throw ( assertion <identifiersep> error ) new assertion <identifiersep> error ( <string_literal> ) . init <identifiersep> cause ( e ) ; } } public dsa <identifiersep> public <identifiersep> key get <identifiersep> pub <identifiersep> key ( ) { return pub <identifiersep> key ; } @ override public string to <identifiersep> string ( ) { return <string_literal> + get <identifiersep> uri ( ) . to <identifiersep> string ( ) ; <ect>
string k = crypto <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( crypto <identifiersep> key ) ; string e = extra == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( extra ) ; system . out . println ( <string_literal> + this ) ; system . out . println ( <string_literal> + key <identifiersep> type ) ; system . out . println ( <string_literal> + r ) ; system . out . println ( <string_literal> + k ) ; <LOG> system . out . println ( <string_literal> + ( doc <identifiersep> name == null ? <string_literal> : doc <identifiersep> name ) ) ; system . out . print ( <string_literal> ) ; if ( meta <identifiersep> str == null ) system . out . println ( <string_literal> ) ; else <ect>
return get <identifiersep> insertable <identifiersep> ssk ( site <identifiersep> name + separator + ver ) ; } public insertable <identifiersep> client <identifiersep> ssk get <identifiersep> insertable <identifiersep> ssk ( string string ) { try { return new insertable <identifiersep> client <identifiersep> ssk ( string , pub <identifiersep> key <identifiersep> hash , new dsa <identifiersep> public <identifiersep> key ( get <identifiersep> crypto <identifiersep> group ( ) , priv <identifiersep> key ) , priv <identifiersep> key , crypto <identifiersep> key , crypto <identifiersep> algorithm ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <LOG> throw new error ( e ) ; } } public insertable <identifiersep> usk priv <identifiersep> copy ( long edition ) { if ( edition == suggested <identifiersep> edition ) return this ; try { return new insertable <identifiersep> usk ( site <identifiersep> name , pub <identifiersep> key <identifiersep> hash , crypto <identifiersep> key , priv <identifiersep> key , edition , crypto <identifiersep> algorithm ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <ect>
mac sun <identifiersep> hmac = mac . get <identifiersep> instance ( algo , sun ) ; sun <identifiersep> hmac . init ( dummy <identifiersep> key ) ; <comment> <LOG> if ( log <identifiersep> minor ) { logger . minor ( clazz , algo + <string_literal> + hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + sun <identifiersep> hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; } if ( time <identifiersep> sun < time <identifiersep> def ) { hmac = sun <identifiersep> hmac ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <ect>
if ( time <identifiersep> sun < time <identifiersep> def ) { hmac = sun <identifiersep> hmac ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { logger . warning ( clazz , algo + <string_literal> + sun + <string_literal> , e ) ; <comment> <LOG> <comment> <ect>
if ( crypto <identifiersep> key != null ) enc <identifiersep> key = crypto <identifiersep> key ; else enc <identifiersep> key = md256 . digest ( data ) ; if ( crypto <identifiersep> algorithm == 0 ) { <comment> <LOG> crypto <identifiersep> algorithm = key . algo <identifiersep> aes <identifiersep> pcfb <identifiersep> <number_literal> <identifiersep> sha256 ; } if ( crypto <identifiersep> algorithm == key . algo <identifiersep> aes <identifiersep> pcfb <identifiersep> <number_literal> <identifiersep> sha256 ) return inner <identifiersep> encode ( data , data <identifiersep> length , md256 , enc <identifiersep> key , as <identifiersep> metadata , compression <identifiersep> algorithm , crypto <identifiersep> algorithm ) ; else { if ( rijndael . aes <identifiersep> ctr <identifiersep> provider == null || force <identifiersep> no <identifiersep> jca ) return encode <identifiersep> new <identifiersep> no <identifiersep> jca ( data , data <identifiersep> length , md256 , enc <identifiersep> key , as <identifiersep> metadata , compression <identifiersep> algorithm , crypto <identifiersep> algorithm , key <identifiersep> block . hash <identifiersep> sha256 ) ; <ect>
if ( ( pub <identifiersep> key == null ) || ! pub <identifiersep> key2 . equals ( pub <identifiersep> key ) ) { if ( pub <identifiersep> key2 != null ) { byte [ ] new <identifiersep> pub <identifiersep> key <identifiersep> hash = sha256 . digest ( pub <identifiersep> key2 . as <identifiersep> bytes ( ) ) ; if ( arrays . equals ( pub <identifiersep> key <identifiersep> hash , new <identifiersep> pub <identifiersep> key <identifiersep> hash ) ) { if ( pub <identifiersep> key != null ) { <comment> <LOG> throw new ssk <identifiersep> verify <identifiersep> exception ( <string_literal> + pub <identifiersep> key2 + <string_literal> + pub <identifiersep> key ) ; } <comment> <ect>
public client <identifiersep> ssk get <identifiersep> ssk ( long ver ) { return get <identifiersep> ssk ( get <identifiersep> name ( ver ) ) ; } public client <identifiersep> ssk get <identifiersep> ssk ( string string ) { try { return new client <identifiersep> ssk ( string , pub <identifiersep> key <identifiersep> hash , client <identifiersep> ssk . get <identifiersep> extra <identifiersep> bytes ( crypto <identifiersep> algorithm ) , null , crypto <identifiersep> key ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <LOG> throw new error ( e ) ; } } public string get <identifiersep> name ( long ver ) { return site <identifiersep> name + separator + ver ; } public client <identifiersep> key get <identifiersep> ssk ( ) { return get <identifiersep> ssk ( suggested <identifiersep> edition ) ; } public usk copy ( long edition ) { <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) accept <identifiersep> entropy ( seed <identifiersep> file , dis . read <identifiersep> long ( ) , <number_literal> ) ; dis . close ( ) ; } catch ( eof <identifiersep> exception f ) { <comment> <LOG> } finally { closer . close ( dis ) ; closer . close ( bis ) ; closer . close ( fis ) ; } fast <identifiersep> pool <identifiersep> reseed ( ) ; } private long time <identifiersep> last <identifiersep> wrote <identifiersep> seed = - 1 ; <ect>
slow <identifiersep> pool <identifiersep> reseed ( ) ; performed <identifiersep> pool <identifiersep> reseed = true ; break ; } } } } } } if ( debug ) <comment> <LOG> } if ( performed <identifiersep> pool <identifiersep> reseed && ( seedfile != null ) ) { <comment> <ect>
system . out . print ( '0' ) ; } } else if ( args [ 0 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) if ( ( args . length == 1 ) || args [ 1 ] . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> int ( ) ) ; <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> long ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> float ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> long ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> float ( ) ) ; <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> double ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> full <identifiersep> float ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> double ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> full <identifiersep> float ( ) ) ; <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> full <identifiersep> double ( ) ) ; } else if ( args [ 1 ] . equals ( <string_literal> ) ) for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> double ( ) ) ; } private void consume <identifiersep> string ( string str ) { <ect>
try { <comment> ka = key <identifiersep> agreement . get <identifiersep> instance ( <string_literal> ) ; selftest <identifiersep> gen <identifiersep> secret ( key , ka ) ; } catch ( throwable e ) { <comment> <LOG> kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kg . initialize ( this . spec ) ; ka = key <identifiersep> agreement . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; selftest <identifiersep> gen <identifiersep> secret ( key , ka ) ; } } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <ect>
kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , kg <identifiersep> provider ) ; kg . initialize ( spec ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( ecdh . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> algorithm <identifiersep> parameter <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } keygen <identifiersep> cached = kg ; return kg ; } public synchronized key <identifiersep> pair generate <identifiersep> key <identifiersep> pair ( ) { return get <identifiersep> key <identifiersep> pair <identifiersep> generator ( ) . generate <identifiersep> key <identifiersep> pair ( ) ; } public string to <identifiersep> string ( ) { <ect>
ka . do <identifiersep> phase ( pubkey , true ) ; return ka . generate <identifiersep> secret ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } return null ; } public ec <identifiersep> public <identifiersep> key get <identifiersep> public <identifiersep> key ( ) { return ( ec <identifiersep> public <identifiersep> key ) key . get <identifiersep> public ( ) ; } <comment> <ect>
key <identifiersep> factory kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , curve . kf <identifiersep> provider ) ; remote <identifiersep> public <identifiersep> key = ( ec <identifiersep> public <identifiersep> key ) kf . generate <identifiersep> public ( ks ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( ecdh . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> spec <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } return remote <identifiersep> public <identifiersep> key ; } <comment> <ect>
public static void main ( string [ ] args ) throws exception { if ( ( args . length == 0 ) || args [ 0 ] . equals ( <string_literal> ) ) { write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { <LOG> system . out . println ( read <identifiersep> mpi ( system . in ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( read <identifiersep> mpi ( system . in ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( read <identifiersep> mpi ( system . in ) ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { <ect>
write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; system . out . println ( read <identifiersep> mpi ( system . in ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( read <identifiersep> mpi ( system . in ) ) ; <LOG> system . out . println ( read <identifiersep> mpi ( system . in ) ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { write <identifiersep> mpi ( new big <identifiersep> integer ( args [ 1 ] ) , system . out ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { system . err . println ( read <identifiersep> mpi ( system . in ) ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { <ect>
array <identifiersep> list < digester > digesters = new array <identifiersep> list < digester > ( ) ; for ( hash <identifiersep> type type : hash <identifiersep> type . values ( ) ) { if ( ( generate <identifiersep> hashes & type . bitmask ) == type . bitmask ) { try { digesters . add ( new digester ( type ) ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <LOG> } } } this . digesters = digesters . to <identifiersep> array ( new digester [ digesters . size ( ) ] ) ; } @ override public int read ( byte [ ] buf , int off , int len ) throws io <identifiersep> exception { int ret = in . read ( buf , off , len ) ; if ( ret < = 0 ) return ret ; for ( digester d : digesters ) <ect>
throw new io <identifiersep> exception ( <string_literal> + <string_literal> ) ; } input <identifiersep> stream is = underlying . get <identifiersep> input <identifiersep> stream <identifiersep> unbuffered ( ) ; try { return new my <identifiersep> input <identifiersep> stream ( is , setup ( is ) ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> throw new io <identifiersep> exception ( e ) ; } } @ override public string get <identifiersep> name ( ) { return get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + underlying . get <identifiersep> name ( ) ; } @ override public long size ( ) { <ect>
long l = 0 ; for ( hash <identifiersep> result hash : hashes ) l | = hash . type . bitmask ; return l ; } public static boolean strict <identifiersep> equals ( hash <identifiersep> result [ ] results , hash <identifiersep> result [ ] hashes ) { if ( results . length != hashes . length ) { <LOG> return false ; } for ( int i = 0 ; i < results . length ; i ++ ) { if ( results [ i ] . type != hashes [ i ] . type ) { <comment> <ect>
if ( results [ i ] . type != hashes [ i ] . type ) { <comment> <LOG> return false ; } } return true ; } public static boolean contains ( hash <identifiersep> result [ ] hashes , hash <identifiersep> type type ) { for ( hash <identifiersep> result res : hashes ) if ( res . type == type || type . name ( ) . equals ( res . type . name ( ) ) ) return true ; <ect>
try { class < ? > c = class . for <identifiersep> name ( <string_literal> ) ; p = ( provider ) c . new <identifiersep> instance ( ) ; security . add <identifiersep> provider ( p ) ; } catch ( throwable e ) { throw e ; } <LOG> } else { logger . debug ( bouncy <identifiersep> castle <identifiersep> loader . class , <string_literal> + p ) ; } try { <comment> <ect>
constructor < ? > constructor = c . get <identifiersep> constructor ( string . class ) ; nss <identifiersep> provider = ( provider ) constructor . new <identifiersep> instance ( nss <identifiersep> file . get <identifiersep> path ( ) ) ; if ( atfirst ) security . insert <identifiersep> provider <identifiersep> at ( nss <identifiersep> provider , 1 ) ; else security . add <identifiersep> provider ( nss <identifiersep> provider ) ; <LOG> } else { logger . debug ( nss <identifiersep> loader . class , <string_literal> + nss <identifiersep> provider ) ; } return nss <identifiersep> provider ; } } static public void main ( string [ ] args ) { dump <identifiersep> loaded ( ) ; } static public void dump <identifiersep> loaded ( ) { <ect>
} else { logger . debug ( nss <identifiersep> loader . class , <string_literal> + nss <identifiersep> provider ) ; } return nss <identifiersep> provider ; } } static public void main ( string [ ] args ) { dump <identifiersep> loaded ( ) ; } static public void dump <identifiersep> loaded ( ) { <LOG> system . out . println ( <string_literal> + nss ) ; system . out . println ( <string_literal> + sun ) ; system . out . println ( <string_literal> + sun <identifiersep> jce ) ; } } <ect>
return nss <identifiersep> provider ; } } static public void main ( string [ ] args ) { dump <identifiersep> loaded ( ) ; } static public void dump <identifiersep> loaded ( ) { system . out . println ( <string_literal> + bouncy <identifiersep> castle ) ; system . out . println ( <string_literal> + nss ) ; <LOG> system . out . println ( <string_literal> + sun <identifiersep> jce ) ; } } <ect>
message <identifiersep> digest md = item . get ( ) ; if ( md != null ) { return md ; } } return message <identifiersep> digest . get <identifiersep> instance ( <string_literal> , md <identifiersep> provider ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e2 ) { <comment> <LOG> system . err . println ( <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } wrapper <identifiersep> manager . stop ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> crappy <identifiersep> jvm ) ; throw new runtime <identifiersep> exception ( ) ; } <comment> <ect>
} catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; if ( e instanceof crypt <identifiersep> format <identifiersep> exception ) throw ( crypt <identifiersep> format <identifiersep> exception ) e ; if ( e instanceof io <identifiersep> exception ) throw ( io <identifiersep> exception ) e ; <LOG> return null ; } } <comment> <ect>
private static final boolean rdebug = false ; <comment> private static final int debuglevel = rdebug ? <number_literal> : 0 ; <comment> private static final boolean trace = false ; private static void debug ( string s ) { <LOG> } private static void trace ( boolean in , string s ) { if ( trace && log <identifiersep> debug ) logger . debug ( rijndael <identifiersep> algorithm . class , ( in ? <string_literal> : <string_literal> ) + name + ' . ' + s ) ; } <comment> <ect>
} ; <comment> <LOG> system . out . println ( <string_literal> ) ; system . out . println ( ) ; } int root = 0x11b ; int i , j = 0 ; <comment> <ect>
<comment> <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( s [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( si [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
time = system . current <identifiersep> time <identifiersep> millis ( ) - time ; if ( rdebug && ( log <identifiersep> debug ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( si [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( i <identifiersep> g [ i ] [ j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t5 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t6 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t7 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t7 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t8 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( rcon [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( rcon [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> + time + <string_literal> ) ; system . out . println ( ) ; } } private static void generate <identifiersep> log <identifiersep> and <identifiersep> alog <identifiersep> tables ( int root ) { <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( rcon [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; } } private static void generate <identifiersep> log <identifiersep> and <identifiersep> alog <identifiersep> tables ( int root ) { alog [ 0 ] = 1 ; for ( int i = 1 ; i < <number_literal> ; i ++ ) { int j = ( alog [ i - 1 ] < < 1 ) ^ alog [ i - 1 ] ; if ( ( j & 0x100 ) != 0 ) j ^ = root ; <ect>
tt = ker [ <number_literal> ] ; result [ <number_literal> ] = ( byte ) ( s [ ( t3 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( s [ ( t0 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( s [ ( t1 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( s [ t2 & 0x <identifiersep> ff ] ^ tt ) ; if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; } if ( rdebug ) trace ( out , <string_literal> ) ; } <comment> <ect>
tt = ker [ <number_literal> ] ; result [ <number_literal> ] = ( byte ) ( s [ ( t7 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( s [ ( t0 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( s [ ( t2 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( s [ t3 & 0x <identifiersep> ff ] ^ tt ) ; if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; } if ( rdebug ) trace ( out , <string_literal> ) ; } <comment> <ect>
tt = kdr [ <number_literal> ] ; result [ <number_literal> ] = ( byte ) ( si [ ( t3 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( si [ ( t2 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( si [ ( t1 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( si [ t0 & 0x <identifiersep> ff ] ^ tt ) ; if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; } if ( rdebug ) trace ( out , <string_literal> ) ; } <comment> <ect>
tt = kdr [ <number_literal> ] ; result [ <number_literal> ] = ( byte ) ( si [ ( t7 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( si [ ( t6 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( si [ ( t4 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ <number_literal> ] = ( byte ) ( si [ t3 & 0x <identifiersep> ff ] ^ tt ) ; if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; } if ( rdebug ) trace ( out , <string_literal> ) ; } <comment> static boolean self <identifiersep> test ( ) { return self <identifiersep> test ( block <identifiersep> size ) ; } <comment> <ect>
tt = ke [ rounds ] [ i ] ; result [ j ++ ] = ( byte ) ( s [ ( t [ i ] > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ j ++ ] = ( byte ) ( s [ ( t [ ( i + s1 ) % bc ] > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ j ++ ] = ( byte ) ( s [ ( t [ ( i + s2 ) % bc ] > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ j ++ ] = ( byte ) ( s [ t [ ( i + s3 ) % bc ] & 0x <identifiersep> ff ] ^ tt ) ; } if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; } if ( rdebug ) trace ( out , <string_literal> ) ; } <comment> <ect>
tt = kd [ rounds ] [ i ] ; result [ j ++ ] = ( byte ) ( si [ ( t [ i ] > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ j ++ ] = ( byte ) ( si [ ( t [ ( i + s1 ) % bc ] > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ j ++ ] = ( byte ) ( si [ ( t [ ( i + s2 ) % bc ] > > > <number_literal> ) & 0x <identifiersep> ff ] ^ ( tt > > > <number_literal> ) ) ; result [ j ++ ] = ( byte ) ( si [ t [ ( i + s3 ) % bc ] & 0x <identifiersep> ff ] ^ tt ) ; } if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; } if ( rdebug ) trace ( out , <string_literal> ) ; } <comment> private static boolean self <identifiersep> test ( int keysize ) { if ( rdebug ) trace ( in , <string_literal> + keysize + ' ) ' ) ; boolean ok = false ; <ect>
kb [ i ] = ( byte ) i ; for ( i = 0 ; i < block <identifiersep> size ; i ++ ) pt [ i ] = ( byte ) i ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; <LOG> system . out . println ( <string_literal> + to <identifiersep> string ( kb ) ) ; system . out . println ( ) ; } object key = make <identifiersep> key ( kb , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> + ( <number_literal> * keysize ) ) ; system . out . println ( <string_literal> + to <identifiersep> string ( kb ) ) ; system . out . println ( ) ; } object key = make <identifiersep> key ( kb , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; system . out . println ( <string_literal> + to <identifiersep> string ( pt ) ) ; } byte [ ] ct = new byte [ block <identifiersep> size ] ; block <identifiersep> encrypt ( pt , ct , 0 , key , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> + to <identifiersep> string ( pt ) ) ; } byte [ ] ct = new byte [ block <identifiersep> size ] ; block <identifiersep> encrypt ( pt , ct , 0 , key , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { <LOG> system . out . println ( ) ; system . out . println ( <string_literal> + to <identifiersep> string ( ct ) ) ; } byte [ ] cpt = new byte [ block <identifiersep> size ] ; block <identifiersep> decrypt ( ct , cpt , 0 , key , block <identifiersep> size ) ; ok = are <identifiersep> equal ( pt , cpt ) ; if ( ! ok ) <ect>
block <identifiersep> decrypt ( ct , cpt , 0 , key , block <identifiersep> size ) ; ok = are <identifiersep> equal ( pt , cpt ) ; if ( ! ok ) throw new runtime <identifiersep> exception ( <string_literal> ) ; } catch ( exception x ) { if ( rdebug && ( debuglevel > 0 ) ) { <LOG> x . print <identifiersep> stack <identifiersep> trace ( ) ; } } if ( rdebug && ( debuglevel > 0 ) ) debug ( <string_literal> + ok ) ; if ( rdebug ) trace ( out , <string_literal> ) ; return ok ; } <comment> <ect>
bcastle <identifiersep> cipher . init ( cipher . encrypt <identifiersep> mode , k , iv ) ; provider bcastle <identifiersep> provider = bcastle <identifiersep> cipher . get <identifiersep> provider ( ) ; if ( provider != bcastle <identifiersep> provider ) { long time <identifiersep> def = benchmark ( c , k , iv ) ; long time <identifiersep> bcastle = benchmark ( bcastle <identifiersep> cipher , k , iv ) ; system . out . println ( algo + <string_literal> + provider + <string_literal> + time <identifiersep> def + <string_literal> ) ; <LOG> logger . minor ( clazz , algo + <string_literal> + provider + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + bcastle <identifiersep> provider + <string_literal> + time <identifiersep> bcastle + <string_literal> ) ; if ( time <identifiersep> bcastle < time <identifiersep> def ) { provider = bcastle <identifiersep> provider ; c = bcastle <identifiersep> cipher ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <ect>
c = bcastle <identifiersep> cipher ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <comment> <LOG> } } c = cipher . get <identifiersep> instance ( algo , provider ) ; c . init ( cipher . encrypt <identifiersep> mode , k , iv ) ; c . do <identifiersep> final ( plaintext ) ; logger . normal ( rijndael . class , <string_literal> + provider ) ; system . out . println ( <string_literal> + provider ) ; return provider ; <ect>
sig = signature . get <identifiersep> instance ( default <identifiersep> hash <identifiersep> algorithm , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; selftest <identifiersep> sign ( key , sig ) ; } } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> algorithm <identifiersep> parameter <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { throw new error ( e ) ; } catch ( invalid <identifiersep> key <identifiersep> spec <identifiersep> exception e ) { throw new error ( e ) ; } catch ( signature <identifiersep> exception e ) { <ect>
<comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( signature <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; <ect>
logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( signature <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; } <comment> <ect>
siglen = actual <identifiersep> signature <identifiersep> length ( signature , sigoffset , siglen ) ; result = sig . verify ( signature , sigoffset , siglen ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( signature <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; } public ec <identifiersep> public <identifiersep> key get <identifiersep> public <identifiersep> key ( ) { <ect>
ec <identifiersep> public <identifiersep> key remote <identifiersep> public <identifiersep> key = null ; try { x509encoded <identifiersep> key <identifiersep> spec ks = new x509encoded <identifiersep> key <identifiersep> spec ( data ) ; key <identifiersep> factory kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , curve . kf <identifiersep> provider ) ; remote <identifiersep> public <identifiersep> key = ( ec <identifiersep> public <identifiersep> key ) kf . generate <identifiersep> public ( ks ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> spec <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } return remote <identifiersep> public <identifiersep> key ; } <comment> <ect>
@ override public void run ( ) { try { real <identifiersep> run ( ) ; node . node <identifiersep> stats . report <identifiersep> announce <identifiersep> forwarded ( forwarded <identifiersep> refs , source ) ; } catch ( throwable t ) { <LOG> } finally { if ( source != null ) { source . completed <identifiersep> announce ( uid ) ; } node . tracker . completed ( uid ) ; if ( cb != null ) cb . completed ( ) ; <ect>
if ( cb != null ) cb . node <identifiersep> not <identifiersep> wanted ( ) ; if ( source != null ) { try { send <identifiersep> not <identifiersep> wanted ( ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <LOG> return ; } } continue ; } } } if ( msg . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> route <identifiersep> not <identifiersep> found ) { <comment> <ect>
try { send <identifiersep> not <identifiersep> wanted ( ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . warning ( this , <string_literal> ) ; return ; } } continue ; <comment> <LOG> } } } private int waiting <identifiersep> for <identifiersep> transfers = 0 ; <comment> <ect>
<comment> <LOG> opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; return false ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . warning ( this , <string_literal> + e , e ) ; opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; return false ; <ect>
public peer <identifiersep> manager ( node node , semi <identifiersep> ordered <identifiersep> shutdown <identifiersep> hook shutdown <identifiersep> hook ) { logger . normal ( this , <string_literal> ) ; peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reasons <identifiersep> rt = new peer <identifiersep> status <identifiersep> tracker < string > ( ) ; peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reasons <identifiersep> bulk = new peer <identifiersep> status <identifiersep> tracker < string > ( ) ; all <identifiersep> peers <identifiersep> statuses = new peer <identifiersep> status <identifiersep> tracker < integer > ( ) ; darknet <identifiersep> peers <identifiersep> statuses = new peer <identifiersep> status <identifiersep> tracker < integer > ( ) ; <LOG> my <identifiersep> peers = new peer <identifiersep> node [ 0 ] ; connected <identifiersep> peers = new peer <identifiersep> node [ 0 ] ; this . node = node ; shutdown <identifiersep> hook . add <identifiersep> early <identifiersep> job ( new thread ( ) { public void run ( ) { <comment> <ect>
simple <identifiersep> field <identifiersep> set fs ; fs = new simple <identifiersep> field <identifiersep> set ( br , false , true ) ; try { peer <identifiersep> node pn = peer <identifiersep> node . create ( fs , node , crypto , opennet , this ) ; if ( old <identifiersep> opennet <identifiersep> peers ) { if ( ! ( pn instanceof opennet <identifiersep> peer <identifiersep> node ) ) <LOG> else opennet . add <identifiersep> old <identifiersep> opennet <identifiersep> node ( ( opennet <identifiersep> peer <identifiersep> node ) pn ) ; } else add <identifiersep> peer ( pn , true , false ) ; got <identifiersep> some = true ; } catch ( fs <identifiersep> parse <identifiersep> exception e2 ) { <ect>
opennet . add <identifiersep> old <identifiersep> opennet <identifiersep> node ( ( opennet <identifiersep> peer <identifiersep> node ) pn ) ; } else add <identifiersep> peer ( pn , true , false ) ; got <identifiersep> some = true ; } catch ( fs <identifiersep> parse <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <LOG> some <identifiersep> broken = true ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; <ect>
logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <LOG> some <identifiersep> broken = true ; continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; <ect>
logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <LOG> some <identifiersep> broken = true ; continue ; } catch ( runtime <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; <ect>
logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; } catch ( runtime <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <LOG> some <identifiersep> broken = true ; continue ; <comment> <ect>
dropped <identifiersep> old <identifiersep> peers . add ( e , fs . get ( <string_literal> ) ) ; } some <identifiersep> broken = true ; continue ; } } } catch ( eof <identifiersep> exception e ) { <comment> <LOG> } try { br . close ( ) ; } catch ( io <identifiersep> exception e3 ) { logger . error ( this , <string_literal> + e3 + <string_literal> + peers <identifiersep> file , e3 ) ; } if ( some <identifiersep> broken ) { try { <ect>
} else { file <identifiersep> util . rename <identifiersep> to ( f , get <identifiersep> backup <identifiersep> filename ( filename , 0 ) ) ; } } catch ( io <identifiersep> exception e ) { try { fos . close ( ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> } logger . error ( this , <string_literal> + e , e ) ; f . delete ( ) ; return ; <comment> <ect>
public void read <identifiersep> extra <identifiersep> peer <identifiersep> data ( ) { darknet <identifiersep> peer <identifiersep> node [ ] peers = get <identifiersep> darknet <identifiersep> peers ( ) ; for ( darknet <identifiersep> peer <identifiersep> node peer : peers ) { try { peer . read <identifiersep> extra <identifiersep> peer <identifiersep> data ( ) ; } catch ( exception e ) { <LOG> } } string msg = <string_literal> ; logger . normal ( this , msg ) ; system . out . println ( msg ) ; } public void start ( ) { ua = new peer <identifiersep> manager <identifiersep> user <identifiersep> alert ( node . node <identifiersep> stats , node . node <identifiersep> updater ) ; update <identifiersep> pm <identifiersep> user <identifiersep> alert ( ) ; <ect>
int number <identifiersep> of <identifiersep> disconnecting = 0 ; int number <identifiersep> of <identifiersep> routing <identifiersep> disabled = 0 ; int number <identifiersep> of <identifiersep> no <identifiersep> load <identifiersep> stats = 0 ; peer <identifiersep> node [ ] peers = this . my <identifiersep> peers ( ) ; for ( peer <identifiersep> node peer : peers ) { if ( peer == null ) { <LOG> continue ; } int status = peer . get <identifiersep> peer <identifiersep> node <identifiersep> status ( ) ; switch ( status ) { case peer <identifiersep> node <identifiersep> status <identifiersep> connected : number <identifiersep> of <identifiersep> connected ++ ; break ; <ect>
this . darknet <identifiersep> peers <identifiersep> statuses . remove <identifiersep> status ( peer <identifiersep> node <identifiersep> status , peer <identifiersep> node , no <identifiersep> log ) ; } <comment> public void add <identifiersep> peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reason ( string peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reason , peer <identifiersep> node peer <identifiersep> node , boolean real <identifiersep> time ) { if ( peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reason == null ) { <LOG> return ; } peer <identifiersep> status <identifiersep> tracker < string > peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reasons = real <identifiersep> time ? peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reasons <identifiersep> rt : peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reasons <identifiersep> bulk ; peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reasons . add <identifiersep> status ( peer <identifiersep> node <identifiersep> routing <identifiersep> backoff <identifiersep> reason , peer <identifiersep> node , false ) ; } <comment> <ect>
<comment> <LOG> continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { throw ( io <identifiersep> exception ) new io <identifiersep> exception ( ) . init <identifiersep> cause ( e ) ; } if ( p . get <identifiersep> port ( ) == crypto . port <identifiersep> number ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn . user <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; return true ; } <comment> <LOG> return false ; } } public opennet <identifiersep> peer <identifiersep> node add <identifiersep> new <identifiersep> opennet <identifiersep> node ( simple <identifiersep> field <identifiersep> set fs , connection <identifiersep> type connection <identifiersep> type , boolean allow <identifiersep> existing ) throws fs <identifiersep> parse <identifiersep> exception , peer <identifiersep> parse <identifiersep> exception , reference <identifiersep> signature <identifiersep> verification <identifiersep> exception { try { opennet <identifiersep> peer <identifiersep> node pn = new opennet <identifiersep> peer <identifiersep> node ( fs , node , crypto , this , false ) ; if ( arrays . equals ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash , crypto . ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <ect>
peers <identifiersep> lru . push ( node <identifiersep> to <identifiersep> add <identifiersep> now ) ; old <identifiersep> peers . remove ( node <identifiersep> to <identifiersep> add <identifiersep> now ) ; } drop <identifiersep> excess <identifiersep> peers ( distance ) ; } public boolean want <identifiersep> peer ( opennet <identifiersep> peer <identifiersep> node node <identifiersep> to <identifiersep> add <identifiersep> now , boolean add <identifiersep> at <identifiersep> lru , boolean just <identifiersep> checking , boolean old <identifiersep> opennet <identifiersep> peer , connection <identifiersep> type connection <identifiersep> type ) { if ( node <identifiersep> to <identifiersep> add <identifiersep> now != null ) { if ( ! location . is <identifiersep> valid ( node <identifiersep> to <identifiersep> add <identifiersep> now . get <identifiersep> location ( ) ) ) { <LOG> return false ; } <comment> <ect>
<comment> public boolean send <identifiersep> opennet <identifiersep> ref ( boolean is <identifiersep> reply , long uid , peer <identifiersep> node peer , byte [ ] noderef , byte <identifiersep> counter ctr , all <identifiersep> sent <identifiersep> callback cb ) throws not <identifiersep> connected <identifiersep> exception { byte [ ] padded = new byte [ padded <identifiersep> size ( noderef . length ) ] ; if ( noderef . length > padded . length ) { <LOG> return false ; } system . arraycopy ( noderef , 0 , padded , 0 , noderef . length ) ; util . random <identifiersep> bytes ( node . fast <identifiersep> weak <identifiersep> random , padded , noderef . length , padded . length - noderef . length ) ; long xfer <identifiersep> uid = node . random . next <identifiersep> long ( ) ; message msg2 = is <identifiersep> reply ? dmt . create <identifiersep> fnp <identifiersep> opennet <identifiersep> connect <identifiersep> reply <identifiersep> new ( uid , xfer <identifiersep> uid , noderef . length , padded . length ) : dmt . create <identifiersep> fnp <identifiersep> opennet <identifiersep> connect <identifiersep> destination <identifiersep> new ( uid , xfer <identifiersep> uid , noderef . length , padded . length ) ; <ect>
<comment> <LOG> return null ; } if ( force <identifiersep> opennet <identifiersep> enabled ) ref . put ( <string_literal> , true ) ; if ( ! opennet <identifiersep> peer <identifiersep> node . validate <identifiersep> ref ( ref ) ) { logger . error ( opennet <identifiersep> manager . class , <string_literal> + from ) ; return null ; <ect>
override <identifiersep> ip <identifiersep> address = new freenet <identifiersep> inet <identifiersep> address ( override <identifiersep> ip <identifiersep> address <identifiersep> string , false , true ) ; } catch ( hostname <identifiersep> syntax <identifiersep> exception e ) { synchronized ( this ) { has <identifiersep> valid <identifiersep> address <identifiersep> override = false ; } string msg = <string_literal> + override <identifiersep> ip <identifiersep> address <identifiersep> string + <string_literal> + e . get <identifiersep> message ( ) ; logger . error ( this , msg ) ; <LOG> override <identifiersep> ip <identifiersep> address = null ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <comment> <ect>
@ override public void run ( ) { peer <identifiersep> node pn = ref . get ( ) ; if ( pn == null ) return ; if ( pn . cached <identifiersep> removed ( ) ) { if ( log <identifiersep> minor && pn . node . peers . have <identifiersep> peer ( pn ) ) { <LOG> } else { return ; } } if ( ! pn . node . peers . have <identifiersep> peer ( pn ) ) { if ( ! pn . cached <identifiersep> removed ( ) ) logger . error ( this , <string_literal> + pn ) ; return ; <ect>
this . dep = dep ; this . essential = essential ; this . for <identifiersep> build = for <identifiersep> build ; } @ override public void on <identifiersep> success ( ) { if ( ! essential ) { <LOG> return ; } system . out . println ( <string_literal> + dep . new <identifiersep> filename + <string_literal> + for <identifiersep> build + <string_literal> ) ; boolean to <identifiersep> deploy = false ; boolean for <identifiersep> current <identifiersep> version = false ; synchronized ( main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . this ) { downloaders . remove ( this ) ; <ect>
for <identifiersep> current <identifiersep> version = ( for <identifiersep> build == version . build <identifiersep> number ( ) ) ; } } if ( to <identifiersep> deploy ) deploy ( ) ; else if ( for <identifiersep> current <identifiersep> version ) deployer . reannounce ( ) ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { if ( ! essential ) { <LOG> } else { system . err . println ( <string_literal> + dep . new <identifiersep> filename + <string_literal> + e . get <identifiersep> short <identifiersep> message ( ) + <string_literal> ) ; synchronized ( main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . this ) { downloaders . remove ( this ) ; if ( for <identifiersep> build != build ) return ; broken = true ; <ect>
<comment> public synchronized main <identifiersep> jar <identifiersep> dependencies handle ( properties props , int build ) { try { return inner <identifiersep> handle ( props , build ) ; } catch ( runtime <identifiersep> exception e ) { broken = true ; <LOG> throw e ; } catch ( error e ) { broken = true ; logger . error ( this , <string_literal> + e , e ) ; throw e ; } } enum dependency <identifiersep> type { <ect>
outer : for ( string prop <identifiersep> name : props . string <identifiersep> property <identifiersep> names ( ) ) { if ( ! prop <identifiersep> name . contains ( <string_literal> ) ) continue ; string base <identifiersep> name = prop <identifiersep> name . split ( <string_literal> ) [ 0 ] ; if ( ! processed . add ( base <identifiersep> name ) ) continue ; string s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( s == null ) { <LOG> broken = true ; continue ; } dependency <identifiersep> type type ; try { type = dependency <identifiersep> type . value <identifiersep> of ( s ) ; if ( type == dependency <identifiersep> type . optional <identifiersep> atomic <identifiersep> multi <identifiersep> files <identifiersep> with <identifiersep> restart ) { <ect>
if ( ! matches <identifiersep> current <identifiersep> arch ( s ) ) { logger . normal ( this , <string_literal> + base <identifiersep> name + <string_literal> ) ; continue ; } } <comment> <LOG> broken = true ; continue ; } file filename = null ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; <comment> <ect>
if ( type == dependency <identifiersep> type . optional <identifiersep> classpath <identifiersep> no <identifiersep> update && filename . exists ( ) ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { system . out . println ( <string_literal> + filename ) ; dependencies . add ( new dependency ( current <identifiersep> file , filename , p , order ) ) ; continue ; } else { <LOG> filename . delete ( ) ; } } if ( valid <identifiersep> file ( filename , expected <identifiersep> hash , size , executable ) ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
if ( max <identifiersep> chk != null ) { try { fetch <identifiersep> dependency ( max <identifiersep> chk , new dependency ( current <identifiersep> file , filename , p , order ) , expected <identifiersep> hash , size , true , executable ) ; } catch ( fetch <identifiersep> exception fe ) { broken = true ; logger . error ( this , <string_literal> + fe , fe ) ; <LOG> } } else { <comment> <ect>
continue ; } for ( file f : list ) { string name = f . get <identifiersep> name ( ) ; if ( ! p . matcher ( name . to <identifiersep> lower <identifiersep> case ( ) ) . matches ( ) ) continue ; if ( valid <identifiersep> file ( f , expected <identifiersep> hash , size , executable ) ) { <comment> <LOG> dependencies . add ( new dependency ( current <identifiersep> file , f , p , order ) ) ; continue outer ; } } } if ( max <identifiersep> chk == null ) { system . err . println ( <string_literal> + base <identifiersep> name + <string_literal> ) ; broken = true ; continue ; <ect>
continue ; } <comment> <LOG> system . err . println ( <string_literal> + e ) ; } } if ( ready ( ) ) return new main <identifiersep> jar <identifiersep> dependencies ( new tree <identifiersep> set < dependency > ( dependencies ) , build ) ; else return null ; } private static boolean matches <identifiersep> current <identifiersep> os ( string s ) { <ect>
<comment> <LOG> f . delete ( ) ; } for ( string prop <identifiersep> name : props . string <identifiersep> property <identifiersep> names ( ) ) { if ( ! prop <identifiersep> name . contains ( <string_literal> ) ) continue ; string base <identifiersep> name = prop <identifiersep> name . split ( <string_literal> ) [ 0 ] ; if ( ! processed . add ( base <identifiersep> name ) ) continue ; string s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; <ect>
try { type = dependency <identifiersep> type . value <identifiersep> of ( s ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { if ( s . starts <identifiersep> with ( <string_literal> ) ) { if ( log <identifiersep> minor ) logger . minor ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + s + <string_literal> + base <identifiersep> name + <string_literal> ) ; continue ; } <LOG> continue ; } <comment> <ect>
if ( type == dependency <identifiersep> type . optional <identifiersep> atomic <identifiersep> multi <identifiersep> files <identifiersep> with <identifiersep> restart ) { parse <identifiersep> atomic <identifiersep> multi <identifiersep> files <identifiersep> with <identifiersep> restart ( props , base <identifiersep> name ) ; continue ; } <comment> <LOG> return false ; } file filename = null ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; <comment> <ect>
if ( filename == null ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> ) ; return false ; } final freenet <identifiersep> uri key ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( s == null ) { <LOG> return false ; } try { key = new freenet <identifiersep> uri ( s ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + base <identifiersep> name + <string_literal> + s + <string_literal> + e , e ) ; return false ; <ect>
return false ; } pattern p = null ; <comment> <LOG> return false ; } try { p = pattern . compile ( regex ) ; } catch ( pattern <identifiersep> syntax <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + regex + <string_literal> ) ; return false ; <ect>
p = pattern . compile ( regex ) ; } catch ( pattern <identifiersep> syntax <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + regex + <string_literal> ) ; return false ; } } final byte [ ] expected <identifiersep> hash = parse <identifiersep> expected <identifiersep> hash ( props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) , base <identifiersep> name ) ; if ( expected <identifiersep> hash == null ) { <LOG> return false ; } s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; long size = - 1 ; if ( s != null ) { try { size = long . parse <identifiersep> long ( s ) ; <ect>
try { <comment> <LOG> continue ; } } file current <identifiersep> file = null ; if ( type == dependency <identifiersep> type . classpath ) current <identifiersep> file = get <identifiersep> dependency <identifiersep> in <identifiersep> use ( p ) ; if ( type == dependency <identifiersep> type . optional <identifiersep> classpath <identifiersep> no <identifiersep> update && filename . exists ( ) ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { <ect>
current <identifiersep> file = filename ; <comment> <LOG> deployer . add <identifiersep> dependency ( expected <identifiersep> hash , current <identifiersep> file ) ; } } else if ( current <identifiersep> file != null && ! type . optional ) { <comment> <ect>
<comment> <LOG> deployer . fetch ( key , filename , size , expected <identifiersep> hash , new jar <identifiersep> fetcher <identifiersep> callback ( ) { @ override public void on <identifiersep> success ( ) { system . out . println ( <string_literal> + file + <string_literal> ) ; if ( ! type . optional ) { system . out . println ( <string_literal> + file + <string_literal> ) ; <ect>
system . out . println ( <string_literal> + filename + ( type . optional ? <string_literal> : <string_literal> ) ) ; deployer . fetch ( key , filename , size , expected <identifiersep> hash , new jar <identifiersep> fetcher <identifiersep> callback ( ) { @ override public void on <identifiersep> success ( ) { system . out . println ( <string_literal> + file + <string_literal> ) ; if ( ! type . optional ) { <LOG> deployer . add <identifiersep> dependency ( expected <identifiersep> hash , file ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + file + <string_literal> + key + <string_literal> + e , e ) ; } } , type . optional ? 0 : build , false , executable ) ; } catch ( fetch <identifiersep> exception e ) { <ect>
deployer . add <identifiersep> dependency ( expected <identifiersep> hash , file ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + file + <string_literal> + key + <string_literal> + e , e ) ; } } , type . optional ? 0 : build , false , executable ) ; } catch ( fetch <identifiersep> exception e ) { <LOG> } } if ( current <identifiersep> file == null ) continue ; <comment> <ect>
s = props . get <identifiersep> property ( file <identifiersep> base + <string_literal> ) ; if ( s != null ) { must <identifiersep> be <identifiersep> on <identifiersep> class <identifiersep> path = boolean . parse <identifiersep> boolean ( s ) ; } <comment> <LOG> atomic <identifiersep> deployer . cleanup ( ) ; return false ; } <comment> <ect>
if ( ! filename . exists ( ) ) { if ( must <identifiersep> exist != must <identifiersep> exist . false ) { system . out . println ( <string_literal> + name + <string_literal> + filename ) ; atomic <identifiersep> deployer . cleanup ( ) ; return false ; } nothing <identifiersep> to <identifiersep> do = false ; <LOG> } else if ( ! valid <identifiersep> file ( filename , expected <identifiersep> hash , size , executable ) ) { if ( must <identifiersep> exist == must <identifiersep> exist . exact ) { system . out . println ( <string_literal> + filename ) ; atomic <identifiersep> deployer . cleanup ( ) ; return false ; } system . out . println ( <string_literal> + filename + <string_literal> + name ) ; <ect>
system . out . println ( <string_literal> + filename + <string_literal> + name ) ; } else if ( ! valid <identifiersep> file ( filename , expected <identifiersep> hash , size , executable ) ) { if ( must <identifiersep> exist == must <identifiersep> exist . exact ) { system . out . println ( <string_literal> + filename ) ; atomic <identifiersep> deployer . cleanup ( ) ; return false ; } <LOG> nothing <identifiersep> to <identifiersep> do = false ; } else if ( must <identifiersep> exist == must <identifiersep> exist . exact ) continue ; if ( must <identifiersep> be <identifiersep> on <identifiersep> class <identifiersep> path ) { file f = get <identifiersep> dependency <identifiersep> in <identifiersep> use ( pattern . compile ( pattern . quote ( filename . get <identifiersep> name ( ) ) ) ) ; if ( f == null ) { <ect>
atomic <identifiersep> deployer . cleanup ( ) ; return false ; } } atomic <identifiersep> dependency dependency ; try { dependency = new atomic <identifiersep> dependency ( filename , key , size , expected <identifiersep> hash , executable ) ; } catch ( io <identifiersep> exception e ) { <LOG> atomic <identifiersep> deployer . cleanup ( ) ; return false ; } atomic <identifiersep> deployer . add ( dependency ) ; } if ( nothing <identifiersep> to <identifiersep> do ) { system . out . println ( <string_literal> + name + <string_literal> ) ; atomic <identifiersep> deployer . cleanup ( ) ; <ect>
temp <identifiersep> filename . delete <identifiersep> on <identifiersep> exit ( ) ; this . backup <identifiersep> filename = file . create <identifiersep> temp <identifiersep> file ( filename . get <identifiersep> name ( ) , updater <identifiersep> backup <identifiersep> suffix , parent ) ; } public boolean start ( atomic <identifiersep> deployer my <identifiersep> deployer ) { synchronized ( this ) { if ( this . my <identifiersep> deployer != null ) return true ; <comment> <LOG> try { jar <identifiersep> fetcher fetcher = deployer . fetch ( key , temp <identifiersep> filename , size , expected <identifiersep> hash , this , build , false , executable <comment> ) ; synchronized ( this ) { this . fetcher = fetcher ; } return true ; } catch ( fetch <identifiersep> exception e ) { <ect>
jar <identifiersep> fetcher fetcher = deployer . fetch ( key , temp <identifiersep> filename , size , expected <identifiersep> hash , this , build , false , executable <comment> ) ; synchronized ( this ) { this . fetcher = fetcher ; } return true ; } catch ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + filename + <string_literal> + key + <string_literal> + size + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( expected <identifiersep> hash ) + <string_literal> + e , e ) ; <LOG> return false ; } } @ override public void on <identifiersep> success ( ) { atomic <identifiersep> deployer d ; synchronized ( this ) { succeeded <identifiersep> fetch = true ; <ect>
succeeded <identifiersep> fetch = true ; d = my <identifiersep> deployer ; } system . out . println ( <string_literal> + filename + <string_literal> + key ) ; d . on <identifiersep> success ( this ) ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { <LOG> get <identifiersep> deployer ( ) . on <identifiersep> failure ( this , e ) ; } private synchronized atomic <identifiersep> deployer get <identifiersep> deployer ( ) { return my <identifiersep> deployer ; } public void cancel ( ) { jar <identifiersep> fetcher f ; synchronized ( this ) { <ect>
backed <identifiersep> up = true ; } if ( executable ) return backup <identifiersep> filename . set <identifiersep> executable ( true ) || backup <identifiersep> filename . can <identifiersep> execute ( ) ; return true ; } else return false ; } boolean deploy ( ) { <LOG> synchronized ( this ) { assert ( succeeded <identifiersep> fetch ) ; assert ( backed <identifiersep> up ) ; tried <identifiersep> deploy = true ; } if ( ! filename . exists ( ) ) { if ( temp <identifiersep> filename . rename <identifiersep> to ( filename ) ) { <ect>
system . out . println ( <string_literal> + backup <identifiersep> filename + <string_literal> + filename ) ; boolean nothing <identifiersep> to <identifiersep> backup ; synchronized ( this ) { nothing <identifiersep> to <identifiersep> backup = this . nothing <identifiersep> to <identifiersep> backup ; } if ( nothing <identifiersep> to <identifiersep> backup ) { if ( ! filename . delete ( ) && filename . exists ( ) ) { <LOG> temp <identifiersep> filename . delete ( ) ; return true ; <comment> <ect>
return new unix <identifiersep> restarting <identifiersep> atomic <identifiersep> deployer ( name ) ; } else if ( file <identifiersep> util . detected <identifiersep> os . is <identifiersep> windows ) { system . out . println ( <string_literal> + name + <string_literal> ) ; <comment> <LOG> return null ; } } <comment> class atomic <identifiersep> deployer { private final set < atomic <identifiersep> dependency > dependencies = new hash <identifiersep> set < atomic <identifiersep> dependency > ( ) ; private final set < atomic <identifiersep> dependency > dependencies <identifiersep> waiting = new hash <identifiersep> set < atomic <identifiersep> dependency > ( ) ; private boolean failed ; <ect>
if ( failed ) return ; } ready <identifiersep> to <identifiersep> deploy ( ) ; } private void ready <identifiersep> to <identifiersep> deploy ( ) { deployer . multi <identifiersep> file <identifiersep> replace <identifiersep> ready <identifiersep> to <identifiersep> deploy ( this ) ; } public synchronized void add ( atomic <identifiersep> dependency dependency ) { if ( started ) { <LOG> failed = true ; return ; } dependencies . add ( dependency ) ; dependencies <identifiersep> waiting . add ( dependency ) ; } public void start ( ) { for ( atomic <identifiersep> dependency dep : dependencies ( ) ) { <ect>
@ override public int get <identifiersep> priority ( ) { return native <identifiersep> thread . max <identifiersep> priority ; } } ) ; } protected boolean deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) { if ( ! inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) ) { <LOG> return false ; } else return true ; } <comment> boolean inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) { synchronized ( this ) { if ( failed || ! started ) { <ect>
if ( failed || ! started ) { logger . error ( this , <string_literal> + failed + <string_literal> + started , new exception ( <string_literal> ) ) ; return false ; } } atomic <identifiersep> dependency [ ] deps = dependencies ( ) ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . backup <identifiersep> original ( ) ) { <LOG> return false ; } } boolean failed <identifiersep> deploy = false ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . deploy ( ) ) { failed <identifiersep> deploy = true ; system . err . println ( <string_literal> + dep . filename + <string_literal> + dep . temp <identifiersep> filename + <string_literal> + name ) ; <ect>
for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . deploy ( ) ) { failed <identifiersep> deploy = true ; system . err . println ( <string_literal> + dep . filename + <string_literal> + dep . temp <identifiersep> filename + <string_literal> + name ) ; break ; } } if ( failed <identifiersep> deploy ) { <LOG> system . err . println ( <string_literal> ) ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . revert <identifiersep> from <identifiersep> backup ( ) ) { system . err . println ( <string_literal> + dep . backup <identifiersep> filename + <string_literal> + dep . filename ) ; <comment> <ect>
break ; } } if ( failed <identifiersep> deploy ) { system . err . println ( <string_literal> + name ) ; system . err . println ( <string_literal> ) ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . revert <identifiersep> from <identifiersep> backup ( ) ) { <LOG> <comment> <ect>
if ( ! wrapper <identifiersep> manager . is <identifiersep> controlled <identifiersep> by <identifiersep> native <identifiersep> wrapper ( ) ) return false ; file restart <identifiersep> script ; try { restart <identifiersep> script = create <identifiersep> restart <identifiersep> script ( ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + name + <string_literal> + e ) ; <LOG> return false ; } if ( restart <identifiersep> script == null ) return false ; file shell = find <identifiersep> shell ( ) ; if ( shell == null ) return false ; if ( inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) ) { try { <comment> <ect>
if ( sha256 == null ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + base <identifiersep> name + <string_literal> ) ; return null ; } try { return hex <identifiersep> util . hex <identifiersep> to <identifiersep> bytes ( sha256 ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return null ; } catch ( index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + sha256 + <string_literal> + e , e ) ; return null ; } } public static boolean valid <identifiersep> file ( file filename , byte [ ] expected <identifiersep> hash , long size , boolean executable ) { if ( filename == null ) return false ; <ect>
logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + sha256 + <string_literal> + e , e ) ; return null ; } } public static boolean valid <identifiersep> file ( file filename , byte [ ] expected <identifiersep> hash , long size , boolean executable ) { if ( filename == null ) return false ; if ( ! filename . exists ( ) ) return false ; if ( filename . length ( ) != size ) { <LOG> return false ; } file <identifiersep> input <identifiersep> stream fis = null ; try { fis = new file <identifiersep> input <identifiersep> stream ( filename ) ; message <identifiersep> digest md = sha256 . get <identifiersep> message <identifiersep> digest ( ) ; sha256 . hash ( fis , md ) ; <ect>
} else { return false ; } } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + filename ) ; return false ; } catch ( io <identifiersep> exception e ) { <LOG> return false ; } finally { closer . close ( fis ) ; } } private synchronized void clear ( int build ) { dependencies . clear ( ) ; broken = false ; <ect>
system . out . println ( <string_literal> + plugin <identifiersep> name + <string_literal> ) ; return true ; } else return false ; } <comment> <LOG> temp <identifiersep> blob <identifiersep> file . delete ( ) ; return false ; } system . out . println ( <string_literal> + plugin <identifiersep> name + <string_literal> ) ; <comment> <ect>
return false ; } system . out . println ( <string_literal> + plugin <identifiersep> name + <string_literal> ) ; <comment> <LOG> system . err . println ( <string_literal> + plugin <identifiersep> name + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; <comment> <ect>
private static final string required <identifiersep> node <identifiersep> version <identifiersep> prefix = <string_literal> ; @ override protected void maybe <identifiersep> parse <identifiersep> manifest ( fetch <identifiersep> result result , int build ) { required <identifiersep> node <identifiersep> version = - 1 ; parse <identifiersep> manifest ( result ) ; if ( required <identifiersep> node <identifiersep> version != - 1 ) { <LOG> logger . normal ( this , <string_literal> + plugin <identifiersep> name + <string_literal> + required <identifiersep> node <identifiersep> version ) ; } } @ override protected void parse <identifiersep> manifest <identifiersep> line ( string line ) { if ( line . starts <identifiersep> with ( required <identifiersep> node <identifiersep> version <identifiersep> prefix ) ) { required <identifiersep> node <identifiersep> version = integer . parse <identifiersep> int ( line . substring ( required <identifiersep> node <identifiersep> version <identifiersep> prefix . length ( ) ) ) ; } } @ override <ect>
system . err . println ( <string_literal> + plugin <identifiersep> name ) ; } @ override protected void process <identifiersep> success ( int build , fetch <identifiersep> result result , file blob ) { bucket old <identifiersep> result = null ; synchronized ( this ) { if ( required <identifiersep> node <identifiersep> version > version . build <identifiersep> number ( ) ) { <LOG> <comment> <ect>
this . result = result ; } if ( old <identifiersep> result != null ) old <identifiersep> result . free ( ) ; plugin <identifiersep> info <identifiersep> wrapper loaded = plugin <identifiersep> manager . get <identifiersep> plugin <identifiersep> info ( plugin <identifiersep> name ) ; if ( loaded == null ) { if ( ! node . plugin <identifiersep> manager . is <identifiersep> plugin <identifiersep> loaded <identifiersep> or <identifiersep> loading <identifiersep> or <identifiersep> want <identifiersep> load ( plugin <identifiersep> name ) ) { system . err . println ( <string_literal> + plugin <identifiersep> name ) ; <LOG> temp <identifiersep> blob <identifiersep> file . delete ( ) ; return ; } } if ( loaded . get <identifiersep> plugin <identifiersep> long <identifiersep> version ( ) >= fetched <identifiersep> version ) { temp <identifiersep> blob <identifiersep> file . delete ( ) ; return ; } <comment> <ect>
fos = new file <identifiersep> output <identifiersep> stream ( f <identifiersep> new ) ; bucket <identifiersep> tools . copy <identifiersep> to ( result . as <identifiersep> bucket ( ) , fos , - 1 ) ; fos . flush ( ) ; fos . close ( ) ; } synchronized ( this ) { written <identifiersep> version = fetched ; } <LOG> } void write <identifiersep> jar ( ) throws io <identifiersep> exception { write <identifiersep> jar <identifiersep> to ( result , plugin <identifiersep> manager . get <identifiersep> plugin <identifiersep> filename ( plugin <identifiersep> name ) ) ; user <identifiersep> alert a ; synchronized ( this ) { a = alert ; alert = null ; <ect>
public synchronized void arm ( boolean was <identifiersep> running ) { if ( was <identifiersep> running ) { deploy <identifiersep> on <identifiersep> next <identifiersep> no <identifiersep> revocation = true ; system . out . println ( <string_literal> + plugin <identifiersep> name + <string_literal> ) ; } else { deploy <identifiersep> on <identifiersep> no <identifiersep> revocation = true ; <LOG> } } @ override public request <identifiersep> client get <identifiersep> request <identifiersep> client ( ) { return plugin <identifiersep> manager . single <identifiersep> updater <identifiersep> request <identifiersep> client ; } } <ect>
try { bucket <identifiersep> tools . copy ( new file <identifiersep> bucket ( blob <identifiersep> file , true , false , false , true ) , bucket ) ; <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } <comment> <ect>
if ( cg != null ) { core . client <identifiersep> context . start ( cg ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } return was <identifiersep> running ; } catch ( fetch <identifiersep> exception e ) { if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . recently <identifiersep> failed ) { <LOG> } else { logger . error ( this , <string_literal> + e , e ) ; manager . blow ( <string_literal> + e , true ) ; } synchronized ( this ) { if ( revocation <identifiersep> getter == cg ) { revocation <identifiersep> getter = null ; <ect>
msg = <string_literal> ; } } manager . blow ( msg , false ) ; <comment> <LOG> return ; } if ( tmp <identifiersep> blob instanceof array <identifiersep> bucket ) { synchronized ( this ) { if ( tmp <identifiersep> blob == blob <identifiersep> bucket ) return ; blob <identifiersep> bucket = ( array <identifiersep> bucket ) tmp <identifiersep> blob ; } } else { <ect>
try { array <identifiersep> bucket buf = new array <identifiersep> bucket ( bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( tmp <identifiersep> blob ) ) ; synchronized ( this ) { blob <identifiersep> bucket = buf ; } } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; <LOG> <comment> <ect>
if ( file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( f ) . equals ( file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( blob <identifiersep> file ) ) ) return ; } } system . out . println ( <string_literal> + tmp <identifiersep> blob ) ; } file <identifiersep> bucket fb = new file <identifiersep> bucket ( blob <identifiersep> file , false , false , false , false ) ; try { bucket <identifiersep> tools . copy ( tmp <identifiersep> blob , fb ) ; } catch ( io <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { on <identifiersep> failure ( e , state , state . get <identifiersep> blob <identifiersep> bucket ( ) ) ; } void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state , bucket blob ) { <ect>
if ( blob <identifiersep> bucket != null ) { try { byte <identifiersep> array <identifiersep> random <identifiersep> access <identifiersep> buffer t = new byte <identifiersep> array <identifiersep> random <identifiersep> access <identifiersep> buffer ( blob <identifiersep> bucket . to <identifiersep> byte <identifiersep> array ( ) ) ; t . set <identifiersep> read <identifiersep> only ( ) ; return t ; } catch ( io <identifiersep> exception e ) { <LOG> return null ; } } } file f = get <identifiersep> blob <identifiersep> file ( ) ; if ( f == null ) return null ; try { return new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( f , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <ect>
deps = latest <identifiersep> main <identifiersep> jar <identifiersep> dependencies ; } synchronized ( deploy <identifiersep> lock ( ) ) { success = inner <identifiersep> deploy <identifiersep> update ( deps ) ; if ( success ) wait <identifiersep> forever ( ) ; } <comment> <LOG> system . err . println ( <string_literal> + t ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; fail <identifiersep> update ( t . get <identifiersep> message ( ) ) ; string error = l10n ( <string_literal> , <string_literal> , t . get <identifiersep> message ( ) ) ; <ect>
success = inner <identifiersep> deploy <identifiersep> update ( deps ) ; if ( success ) wait <identifiersep> forever ( ) ; } <comment> <LOG> system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; fail <identifiersep> update ( t . get <identifiersep> message ( ) ) ; string error = l10n ( <string_literal> , <string_literal> , t . get <identifiersep> message ( ) ) ; node . client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( false , error , error , error , user <identifiersep> alert . critical <identifiersep> error ) ) ; <ect>
static final object deploy <identifiersep> lock ( ) { return deploy <identifiersep> lock ; } <comment> static void wait <identifiersep> forever ( ) { while ( true ) { <LOG> try { thread . sleep ( <number_literal> * <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( node <identifiersep> update <identifiersep> manager . class , <string_literal> + new <identifiersep> main <identifiersep> jar ) ; write <identifiersep> jar <identifiersep> to ( new <identifiersep> main <identifiersep> jar ) ; } } else { write <identifiersep> jar <identifiersep> to ( new <identifiersep> main <identifiersep> jar ) ; } <LOG> } catch ( io <identifiersep> exception e ) { throw new update <identifiersep> failed <identifiersep> exception ( <string_literal> + ( try <identifiersep> easy <identifiersep> way ? <string_literal> : <string_literal> ) + new <identifiersep> main <identifiersep> jar ) ; } if ( try <identifiersep> easy <identifiersep> way ) { <comment> <ect>
<comment> <LOG> return false ; } } system . err . println ( <string_literal> + new <identifiersep> main <identifiersep> jar + <string_literal> + main <identifiersep> jar + <string_literal> ) ; return true ; } public void write <identifiersep> jar <identifiersep> to ( file f <identifiersep> new ) throws io <identifiersep> exception { if ( ! f <identifiersep> new . delete ( ) && f <identifiersep> new . exists ( ) ) { system . err . println ( <string_literal> + f <identifiersep> new + <string_literal> ) ; <ect>
system . err . println ( <string_literal> + main <identifiersep> jar + <string_literal> ) ; return false ; } } system . err . println ( <string_literal> + new <identifiersep> main <identifiersep> jar + <string_literal> + main <identifiersep> jar + <string_literal> ) ; return true ; } public void write <identifiersep> jar <identifiersep> to ( file f <identifiersep> new ) throws io <identifiersep> exception { if ( ! f <identifiersep> new . delete ( ) && f <identifiersep> new . exists ( ) ) { <LOG> } file <identifiersep> output <identifiersep> stream fos = null ; try { fos = new file <identifiersep> output <identifiersep> stream ( f <identifiersep> new ) ; bucket <identifiersep> tools . copy <identifiersep> to ( this . fetched <identifiersep> main <identifiersep> jar <identifiersep> data , fos , - 1 ) ; fos . flush ( ) ; } finally { <ect>
} <comment> <LOG> this . kill <identifiersep> update <identifiersep> alerts ( ) ; node . client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( true , l10n ( <string_literal> ) , l10n ( <string_literal> , <string_literal> , reason ) , l10n ( <string_literal> , <string_literal> , reason ) , user <identifiersep> alert . critical <identifiersep> error ) ) ; } private string l10n ( string key ) { <ect>
. println ( <string_literal> ) ; system . err . println ( <string_literal> + revocation <identifiersep> message ) ; } } catch ( throwable t ) { try { <LOG> } catch ( throwable t1 ) { } } } main = main <identifiersep> updater ; if ( main != null ) main . pre <identifiersep> kill ( ) ; main <identifiersep> updater = null ; } if ( main != null ) <ect>
<comment> <LOG> try <identifiersep> fetch <identifiersep> revocation ( source ) ; } else { <comment> <ect>
} else { <comment> <LOG> } catch ( not <identifiersep> connected <identifiersep> exception e ) { system . err . println ( <string_literal> + source + <string_literal> ) ; logger . error ( this , <string_literal> + source + <string_literal> ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; <comment> <ect>
} catch ( malformed <identifiersep> url <identifiersep> exception e ) { <comment> <LOG> synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; <comment> <ect>
source . failed <identifiersep> revocation <identifiersep> transfer ( ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> failed <identifiersep> transfer . add ( source ) ; } } @ override public void fatal <identifiersep> error ( ) { <comment> <LOG> } @ override public void sent ( ) { <comment> <ect>
if ( ( is <identifiersep> outdated ) || when <identifiersep> to <identifiersep> take <identifiersep> over <identifiersep> the <identifiersep> normal <identifiersep> updater < now ) { <comment> <LOG> system . out . println ( <string_literal> + how <identifiersep> long + <string_literal> ) ; } else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <comment> <ect>
try { freenet <identifiersep> uri main <identifiersep> jar <identifiersep> uri = new freenet <identifiersep> uri ( jar <identifiersep> key ) . set <identifiersep> suggested <identifiersep> edition ( main <identifiersep> jar <identifiersep> version ) ; if ( main <identifiersep> jar <identifiersep> uri . equals ( update <identifiersep> manager . get <identifiersep> uri ( ) . set <identifiersep> suggested <identifiersep> edition ( main <identifiersep> jar <identifiersep> version ) ) ) send <identifiersep> uom <identifiersep> request ( source , true ) ; else <comment> <LOG> <string_literal> + update <identifiersep> manager . get <identifiersep> uri ( ) + <string_literal> + main <identifiersep> jar <identifiersep> uri ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> } synchronized ( this ) { all <identifiersep> nodes <identifiersep> offered <identifiersep> main <identifiersep> jar . add ( source ) ; } } else { <comment> <ect>
if ( ! update <identifiersep> manager . is <identifiersep> enabled ( ) ) return ; if ( update <identifiersep> manager . has <identifiersep> new <identifiersep> main <identifiersep> jar ( ) ) return ; if ( ! update <identifiersep> manager . node . is <identifiersep> oudated ( ) ) { logger . error ( this , <string_literal> ) ; <LOG> } maybe <identifiersep> request <identifiersep> main <identifiersep> jar ( ) ; } } , when <identifiersep> to <identifiersep> take <identifiersep> over <identifiersep> the <identifiersep> normal <identifiersep> updater - now ) ; } } else { <comment> <ect>
final long length = m . get <identifiersep> long ( dmt . file <identifiersep> length ) ; string key = m . get <identifiersep> string ( dmt . revocation <identifiersep> key ) ; freenet <identifiersep> uri revocation <identifiersep> uri ; try { revocation <identifiersep> uri = new freenet <identifiersep> uri ( key ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + e + <string_literal> + key ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; synchronized ( this ) { <comment> <ect>
if ( update <identifiersep> manager . is <identifiersep> blown ( ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + source + <string_literal> + uid + <string_literal> ) ; cancel <identifiersep> send ( source , uid ) ; return true ; } if ( length > node <identifiersep> update <identifiersep> manager . max <identifiersep> revocation <identifiersep> key <identifiersep> blob <identifiersep> length ) { <LOG> logger . error ( this , <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + size <identifiersep> util . format <identifiersep> size ( length ) + <string_literal> ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . remove ( source ) ; } cancel <identifiersep> send ( source , uid ) ; maybe <identifiersep> not <identifiersep> revoked ( ) ; <ect>
nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . remove ( source ) ; } cancel <identifiersep> send ( source , uid ) ; maybe <identifiersep> not <identifiersep> revoked ( ) ; return true ; } if ( length < = 0 ) { <LOG> synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; <comment> <ect>
<comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; update <identifiersep> manager . blow ( <string_literal> + e , true ) ; cancel <identifiersep> send ( source , uid ) ; return true ; } file <identifiersep> random <identifiersep> access <identifiersep> buffer raf ; try { <ect>
raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( temp , length , false ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + e , e ) ; update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + e , true ) ; return true ; } catch ( io <identifiersep> exception e ) { <LOG> update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + e , true ) ; return true ; } <comment> <ect>
try { if ( br . receive ( ) ) <comment> <LOG> source . failed <identifiersep> revocation <identifiersep> transfer ( ) ; int count = source . count <identifiersep> failed <identifiersep> revocation <identifiersep> transfers ( ) ; boolean retry = count < <number_literal> ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> failed <identifiersep> transfer . add ( source ) ; nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . remove ( source ) ; <ect>
else nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . add ( source ) ; } } maybe <identifiersep> not <identifiersep> revoked ( ) ; if ( retry ) try <identifiersep> fetch <identifiersep> revocation ( source ) ; } } catch ( throwable t ) { logger . error ( this , <string_literal> + source + <string_literal> + t , t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; update <identifiersep> manager . blow ( <string_literal> + source + <string_literal> + t , true ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . remove ( source ) ; } } } } , <string_literal> + uid + <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) ) ; return true ; <ect>
data <identifiersep> input <identifiersep> stream dis = null ; try { dis = new data <identifiersep> input <identifiersep> stream ( temp . get <identifiersep> input <identifiersep> stream ( ) ) ; binary <identifiersep> blob . read <identifiersep> binary <identifiersep> blob ( dis , blocks , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + temp + <string_literal> + source + <string_literal> ) ; <LOG> if ( ! from <identifiersep> disk ) update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + source + <string_literal> , true ) ; return ; } catch ( eof <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> , e ) ; system . err . println ( <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> ) ; <ect>
system . err . println ( <string_literal> + temp + <string_literal> + source + <string_literal> ) ; if ( ! from <identifiersep> disk ) update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + source + <string_literal> , true ) ; return ; } catch ( eof <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> , e ) ; <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; if ( ! from <identifiersep> disk ) update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + source + <string_literal> + e , true ) ; <comment> <ect>
client <identifiersep> get <identifiersep> callback my <identifiersep> callback = new client <identifiersep> get <identifiersep> callback ( ) { @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . cancelled ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> update <identifiersep> manager . revocation <identifiersep> checker . on <identifiersep> success ( result , state , cleaned <identifiersep> blob ) ; if ( ! from <identifiersep> disk ) temp . free ( ) ; insert <identifiersep> blob ( update <identifiersep> manager . revocation <identifiersep> checker . get <identifiersep> blob <identifiersep> bucket ( ) , <string_literal> , request <identifiersep> starter . interactive <identifiersep> priority <identifiersep> class ) ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <ect>
} catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <LOG> } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { <comment> <ect>
client <identifiersep> putter putter = new client <identifiersep> putter ( callback , bucket , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri , null , ctx , priority , false , null , true , update <identifiersep> manager . node . client <identifiersep> core . client <identifiersep> context , null , - 1 ) ; try { update <identifiersep> manager . node . client <identifiersep> core . client <identifiersep> context . start ( putter ) ; } catch ( insert <identifiersep> exception e1 ) { <LOG> } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
logger . error ( this , <string_literal> + source + <string_literal> ) ; return ; } try { try { raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( data , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> return ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + name + <string_literal> + e , e ) ; return ; } final partially <identifiersep> received <identifiersep> bulk prb ; long length ; <ect>
logger . minor ( this , <string_literal> + source + <string_literal> + uid + <string_literal> ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { this . nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar . remove ( source ) ; } return true ; } if ( length > node <identifiersep> update <identifiersep> manager . max <identifiersep> main <identifiersep> jar <identifiersep> length ) { <LOG> logger . error ( this , <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + version + <string_literal> + size <identifiersep> util . format <identifiersep> size ( length ) + <string_literal> ) ; <comment> <ect>
<comment> <LOG> final file temp ; try { temp = file . create <identifiersep> temp <identifiersep> file ( <string_literal> , <string_literal> , update <identifiersep> manager . node . client <identifiersep> core . get <identifiersep> persistent <identifiersep> temp <identifiersep> dir ( ) ) ; temp . delete <identifiersep> on <identifiersep> exit ( ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; <ect>
nodes <identifiersep> sending <identifiersep> main <identifiersep> jar . add ( source ) ; } success = br . receive ( ) ; if ( success ) <comment> <LOG> system . err . println ( <string_literal> + version + <string_literal> + source ) ; temp . delete ( ) ; } } finally { synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . class ) { nodes <identifiersep> sending <identifiersep> main <identifiersep> jar . remove ( source ) ; if ( success ) <ect>
final string to <identifiersep> string = source == null ? <string_literal> : source . user <identifiersep> to <identifiersep> string ( ) ; data <identifiersep> input <identifiersep> stream dis = null ; try { dis = new data <identifiersep> input <identifiersep> stream ( new buffered <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( temp ) ) ) ; binary <identifiersep> blob . read <identifiersep> binary <identifiersep> blob ( dis , blocks , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + temp + <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> ) ; return ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; system . err . println ( <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; <comment> <ect>
binary <identifiersep> blob . read <identifiersep> binary <identifiersep> blob ( dis , blocks , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + temp + <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> ) ; system . err . println ( <string_literal> + temp + <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> ) ; return ; } catch ( io <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; <comment> <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; system . err . println ( <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; <comment> <LOG> system . err . println ( <string_literal> + to <identifiersep> string + <string_literal> + version + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
file <identifiersep> bucket b = null ; try { f = file . create <identifiersep> temp <identifiersep> file ( <string_literal> , <string_literal> , update <identifiersep> manager . node . client <identifiersep> core . get <identifiersep> persistent <identifiersep> temp <identifiersep> dir ( ) ) ; f . delete <identifiersep> on <identifiersep> exit ( ) ; b = new file <identifiersep> bucket ( f , false , false , true , true ) ; } catch ( io <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + to <identifiersep> string + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; b = null ; f = null ; } final file <identifiersep> bucket cleaned <identifiersep> blob = b ; final file cleaned <identifiersep> blob <identifiersep> file = f ; <ect>
final file cleaned <identifiersep> blob <identifiersep> file = f ; client <identifiersep> get <identifiersep> callback my <identifiersep> callback = new client <identifiersep> get <identifiersep> callback ( ) { @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . cancelled ) { <comment> <LOG> system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> + temp + <string_literal> ) ; <comment> <ect>
<comment> <LOG> system . out . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } else if ( e . is <identifiersep> fatal ( ) ) { <comment> <ect>
temp . delete ( ) ; logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; system . out . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } else if ( e . is <identifiersep> fatal ( ) ) { <comment> <LOG> system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> + e ) ; } else { logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { <ect>
} else if ( e . is <identifiersep> fatal ( ) ) { <comment> <LOG> system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; if ( result . size ( ) == 0 ) { system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> + e ) ; } else { logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { <LOG> if ( result . size ( ) == 0 ) { system . err . println ( <string_literal> ) ; return ; } node <identifiersep> updater main <identifiersep> updater = update <identifiersep> manager . get <identifiersep> main <identifiersep> updater ( ) ; if ( main <identifiersep> updater == null ) { system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; if ( result . size ( ) == 0 ) { system . err . println ( <string_literal> ) ; return ; } node <identifiersep> updater main <identifiersep> updater = update <identifiersep> manager . get <identifiersep> main <identifiersep> updater ( ) ; if ( main <identifiersep> updater == null ) { <LOG> return ; } main <identifiersep> updater . on <identifiersep> success ( result , state , cleaned <identifiersep> blob <identifiersep> file , version ) ; temp . delete ( ) ; maybe <identifiersep> insert <identifiersep> main <identifiersep> jar ( main <identifiersep> updater , source , version ) ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <ect>
try { build <identifiersep> number <identifiersep> str = main <identifiersep> build <identifiersep> number <identifiersep> matcher . group ( 1 ) ; build <identifiersep> number = integer . parse <identifiersep> int ( build <identifiersep> number <identifiersep> str ) ; if ( build <identifiersep> number < last <identifiersep> good <identifiersep> main <identifiersep> build <identifiersep> number ) return true ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return false ; } } else if ( main <identifiersep> temp <identifiersep> build <identifiersep> number <identifiersep> matcher . matches ( ) || revocation <identifiersep> temp <identifiersep> build <identifiersep> number <identifiersep> matcher . matches ( ) ) { <comment> <ect>
file <identifiersep> random <identifiersep> access <identifiersep> buffer raf ; final bulk <identifiersep> transmitter bt ; try { if ( data != null ) raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( data , true ) ; else { <LOG> fail = true ; raf = null ; } } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( buf . get <identifiersep> data ( ) ) + <string_literal> + ( e instanceof file <identifiersep> not <identifiersep> found <identifiersep> exception ? <string_literal> : <string_literal> ) + <string_literal> + e , e ) ; <ect>
prb = new partially <identifiersep> received <identifiersep> bulk ( update <identifiersep> manager . node . get <identifiersep> usm ( ) , 0 , node . packet <identifiersep> size , new byte <identifiersep> array <identifiersep> random <identifiersep> access <identifiersep> buffer ( new byte [ 0 ] ) , true ) ; fail = true ; } try { bt = new bulk <identifiersep> transmitter ( prb , source , uid , false , update <identifiersep> manager . ctr , true ) ; } catch ( disconnected <identifiersep> exception e ) { <LOG> raf . close ( ) ; decrement <identifiersep> dependencies ( source ) ; return ; } if ( fail ) { cancel <identifiersep> send ( source , uid ) ; decrement <identifiersep> dependencies ( source ) ; <ect>
<comment> <LOG> } catch ( runtime <identifiersep> exception e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( error e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; <ect>
<comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( error e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { <ect>
} catch ( runtime <identifiersep> exception e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( error e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { boolean connected = fetch <identifiersep> from . is <identifiersep> connected ( ) ; boolean add <identifiersep> failed = failed && connected ; synchronized ( uom <identifiersep> dependency <identifiersep> fetcher . this ) { if ( add <identifiersep> failed ) <ect>
public void stop ( ) { synchronized ( this ) { if ( fetched ) return ; } cg . cancel ( context ) ; } public long get <identifiersep> blob <identifiersep> size ( ) { if ( failed || ! fetched ) { <LOG> return - 1 ; } return blob <identifiersep> bucket . size ( ) ; } public file get <identifiersep> blob <identifiersep> file ( ) { if ( failed || ! fetched ) { logger . error ( this , <string_literal> + failed + <string_literal> + fetched ) ; return null ; <ect>
public synchronized boolean failed ( ) { return failed ; } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { result . as <identifiersep> bucket ( ) . free ( ) ; if ( ! file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> file , save <identifiersep> to ) ) { <LOG> } else { synchronized ( this ) { fetched = true ; } cb . on <identifiersep> success ( this ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { <ect>
<comment> <LOG> } else { <comment> <ect>
if ( main <identifiersep> rhs == null ) { throw new updater <identifiersep> parser <identifiersep> exception ( l10n ( <string_literal> , new string [ ] { <string_literal> } , new string [ ] { boolean . to <identifiersep> string ( main <identifiersep> rhs != null ) } ) ) ; } <comment> <LOG> bw . write ( <string_literal> + count + <string_literal> + d . new <identifiersep> filename ( ) + ' \\ n' ) ; count ++ ; } <comment> <ect>
if ( line . starts <identifiersep> with ( <string_literal> ) ) { try { int memory <identifiersep> limit = integer . parse <identifiersep> int ( line . substring ( <string_literal> . length ( ) ) ) ; int new <identifiersep> memory <identifiersep> limit = memory <identifiersep> limit + extra <identifiersep> memory <identifiersep> mb ; <comment> <LOG> new <identifiersep> memory <identifiersep> limit = <number_literal> ; } bw . write ( ' # ' + marker <identifiersep> comment + ' \\ n' ) ; bw . write ( <string_literal> + new <identifiersep> memory <identifiersep> limit + ' \\ n' ) ; success = true ; continue ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <ect>
closer . close ( bw ) ; closer . close ( osw ) ; closer . close ( fos ) ; } if ( success ) { if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { if ( ! old <identifiersep> config . delete ( ) ) { <LOG> return changed . fail ; } if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + new <identifiersep> config + <string_literal> + old <identifiersep> config ) ; system . exit ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> broke <identifiersep> wrapper <identifiersep> conf ) ; } } system . err . println ( <string_literal> ) ; <ect>
if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { if ( ! old <identifiersep> config . delete ( ) ) { system . err . println ( <string_literal> + new <identifiersep> config + <string_literal> + old <identifiersep> config + <string_literal> ) ; return changed . fail ; } if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { system . err . println ( <string_literal> ) ; <LOG> system . exit ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> broke <identifiersep> wrapper <identifiersep> conf ) ; } } system . err . println ( <string_literal> ) ; return changed . success ; } else { new <identifiersep> config . delete ( ) ; return changed . fail ; <ect>
void start ( ) { try { <comment> <LOG> manager . blow ( <string_literal> , true ) ; } } protected void maybe <identifiersep> process <identifiersep> old <identifiersep> blob ( ) { file old <identifiersep> blob = get <identifiersep> blob <identifiersep> file ( current <identifiersep> version ) ; if ( old <identifiersep> blob . exists ( ) ) { file temp ; try { <ect>
freenet <identifiersep> uri uri = uri . set <identifiersep> suggested <identifiersep> edition ( current <identifiersep> version ) ; uri = uri . ssk <identifiersep> for <identifiersep> usk ( ) ; try { manager . uom . process <identifiersep> main <identifiersep> jar <identifiersep> blob ( temp , null , current <identifiersep> version , uri ) ; } catch ( throwable t ) { <comment> <LOG> } temp . delete ( ) ; } else { logger . error ( this , <string_literal> + old <identifiersep> blob + <string_literal> + temp + <string_literal> ) ; } } } public request <identifiersep> client get <identifiersep> request <identifiersep> client ( ) { return this ; } @ override <ect>
synchronized ( this ) { if ( ! is <identifiersep> running ) return ; found = ( int ) key . suggested <identifiersep> edition ; real <identifiersep> available <identifiersep> version = found ; if ( found > max <identifiersep> deploy <identifiersep> version ) { <LOG> found = max <identifiersep> deploy <identifiersep> version ; } if ( found < = available <identifiersep> version ) return ; system . err . println ( <string_literal> + jar <identifiersep> name ( ) + <string_literal> + found ) ; logger . minor ( this , <string_literal> + available <identifiersep> version + <string_literal> + found + <string_literal> ) ; this . available <identifiersep> version = found ; <ect>
@ override public void run ( ) { maybe <identifiersep> update ( ) ; } } , seconds . to <identifiersep> millis ( <number_literal> ) ) ; <comment> <LOG> return ; } on <identifiersep> start <identifiersep> fetching ( ) ; logger . minor ( this , <string_literal> + jar <identifiersep> name ( ) + <string_literal> + found ) ; } protected abstract void on <identifiersep> start <identifiersep> fetching ( ) ; public void maybe <identifiersep> update ( ) { client <identifiersep> getter to <identifiersep> start = null ; <ect>
<comment> <LOG> temp <identifiersep> blob <identifiersep> file = file . create <identifiersep> temp <identifiersep> file ( blob <identifiersep> filename <identifiersep> prefix + available <identifiersep> version + <string_literal> , <string_literal> , manager . node . client <identifiersep> core . get <identifiersep> persistent <identifiersep> temp <identifiersep> dir ( ) ) ; freenet <identifiersep> uri uri = uri . set <identifiersep> suggested <identifiersep> edition ( available <identifiersep> version ) ; uri = uri . ssk <identifiersep> for <identifiersep> usk ( ) ; cg = new client <identifiersep> getter ( this , uri , ctx , request <identifiersep> starter . immediate <identifiersep> splitfile <identifiersep> priority <identifiersep> class , <ect>
null , new binary <identifiersep> blob <identifiersep> writer ( new file <identifiersep> bucket ( temp <identifiersep> blob <identifiersep> file , false , false , false , false ) ) , null ) ; to <identifiersep> start = cg ; } else { system . err . println ( <string_literal> + jar <identifiersep> name ( ) + <string_literal> + fetching <identifiersep> version + <string_literal> + available <identifiersep> version ) ; } is <identifiersep> fetching = true ; } catch ( exception e ) { <LOG> is <identifiersep> fetching = false ; } } if ( to <identifiersep> start != null ) try { node . client <identifiersep> core . client <identifiersep> context . start ( to <identifiersep> start ) ; } catch ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
protected void parse <identifiersep> dependencies ( fetch <identifiersep> result result , int build ) { input <identifiersep> stream is = null ; try { is = result . as <identifiersep> bucket ( ) . get <identifiersep> input <identifiersep> stream ( ) ; parse <identifiersep> dependencies ( parse <identifiersep> properties ( is , dependencies <identifiersep> file ) , build ) ; } catch ( io <identifiersep> exception e ) { <LOG> } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; } finally { closer . close ( is ) ; } } <comment> protected void parse <identifiersep> dependencies ( properties props , int build ) { <ect>
ticker . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { maybe <identifiersep> update ( ) ; } } , 0 ) ; } else { <LOG> system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; if ( e . is <identifiersep> fatal ( ) ) { <comment> <ect>
max <identifiersep> deploy <identifiersep> version = recommended <identifiersep> ext ; } if ( required <identifiersep> ext > - 1 ) { min <identifiersep> deploy <identifiersep> version = required <identifiersep> ext ; if ( real <identifiersep> available <identifiersep> version != available <identifiersep> version && available <identifiersep> version < required <identifiersep> ext && real <identifiersep> available <identifiersep> version >= required <identifiersep> ext ) { <comment> <LOG> call <identifiersep> finished <identifiersep> found = available <identifiersep> version = real <identifiersep> available <identifiersep> version ; } else if ( available <identifiersep> version < required <identifiersep> ext ) { <comment> <ect>
synchronized ( this ) { if ( fetched ) { temp <identifiersep> file . delete ( ) ; return ; } fetched = true ; } if ( ! main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . valid <identifiersep> file ( temp <identifiersep> file , expected <identifiersep> hash , expected <identifiersep> length , executable ) ) { <LOG> system . err . println ( <string_literal> + filename + <string_literal> ) ; if ( cb != null ) cb . on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + temp <identifiersep> file + <string_literal> + temp <identifiersep> file . length ( ) + <string_literal> ) ) ; temp <identifiersep> file . delete ( ) ; return ; } if ( ! file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> file , filename ) ) { <ect>
system . err . println ( <string_literal> + filename + <string_literal> ) ; if ( cb != null ) cb . on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + temp <identifiersep> file + <string_literal> + temp <identifiersep> file . length ( ) + <string_literal> ) ) ; temp <identifiersep> file . delete ( ) ; return ; } if ( ! file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> file , filename ) ) { <LOG> system . err . println ( <string_literal> + filename + <string_literal> + temp <identifiersep> file ) ; if ( cb != null ) cb . on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + temp <identifiersep> file + <string_literal> + filename ) ) ; temp <identifiersep> file . delete ( ) ; return ; } if ( cb != null ) cb . on <identifiersep> success ( ) ; <ect>
if ( fetched ) return ; fetched = true ; } if ( cb != null ) cb . on <identifiersep> success ( ) ; } } ) ; synchronized ( this ) { if ( uom <identifiersep> fetcher != null ) { <LOG> return ; } uom <identifiersep> fetcher = f ; } } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <comment> <ect>
@ override public jar <identifiersep> fetcher fetch ( freenet <identifiersep> uri uri , file download <identifiersep> to , long expected <identifiersep> length , byte [ ] expected <identifiersep> hash , jar <identifiersep> fetcher <identifiersep> callback cb , int build , boolean essential , boolean executable ) throws fetch <identifiersep> exception { if ( essential ) system . out . println ( <string_literal> + download <identifiersep> to + <string_literal> + build ) ; else if ( build != 0 ) <comment> <LOG> if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uri + <string_literal> + download <identifiersep> to + <string_literal> ) ; dependency <identifiersep> jar <identifiersep> fetcher fetcher = new dependency <identifiersep> jar <identifiersep> fetcher ( download <identifiersep> to , uri , expected <identifiersep> length , expected <identifiersep> hash , cb , essential , executable ) ; synchronized ( fetchers ) { fetchers . add ( fetcher ) ; if ( essential ) essential <identifiersep> fetchers . add ( fetcher ) ; <ect>
system . err . println ( <string_literal> ) ; return ; } properties props = new properties ( ) ; try { props . load ( is ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } finally { closer . close ( is ) ; } dependencies . cleanup ( props , this , version . build <identifiersep> number ( ) ) ; } @ override public void add <identifiersep> dependency ( byte [ ] expected <identifiersep> hash , file filename ) { <ect>
alerts <identifiersep> node . add <identifiersep> child ( <string_literal> , <string_literal> , alert . anchor ( ) ) ; if ( show <identifiersep> only <identifiersep> errors ) { <comment> <LOG> } } else { <comment> <ect>
status = evaluate ( ) ; last <identifiersep> checked <identifiersep> status = now ; return status ; } catch ( throwable t ) { <comment> <LOG> return status . ok ; } } @ override public html <identifiersep> node get <identifiersep> html <identifiersep> text ( ) { return new html <identifiersep> node ( <string_literal> , get <identifiersep> text ( ) ) ; } @ override public string get <identifiersep> short <identifiersep> text ( ) { <ect>
int length = ( int ) len ; try { fis = new file <identifiersep> input <identifiersep> stream ( master <identifiersep> keys <identifiersep> file ) ; data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( fis ) ; if ( len == <number_literal> ) { master <identifiersep> keys ret = read <identifiersep> old <identifiersep> format ( dis , length , hard <identifiersep> random , password ) ; <LOG> ret . change <identifiersep> password ( master <identifiersep> keys <identifiersep> file , password , hard <identifiersep> random ) ; return ret ; } if ( dis . read <identifiersep> int ( ) != version ) throw new io <identifiersep> exception ( <string_literal> ) ; long iterations = dis . read <identifiersep> long ( ) ; if ( iterations < 0 || iterations > max <identifiersep> iterations ) throw new io <identifiersep> exception ( <string_literal> + iterations + <string_literal> ) ; byte [ ] salt = new byte [ <number_literal> ] ; <ect>
byte [ ] pwd = password . get <identifiersep> bytes ( <string_literal> ) ; message <identifiersep> digest md = sha256 . get <identifiersep> message <identifiersep> digest ( ) ; md . update ( pwd ) ; md . update ( salt ) ; byte [ ] outer <identifiersep> key = md . digest ( ) ; if ( iterations > 0 ) { <LOG> for ( long i = 0 ; i < iterations ; i ++ ) { md . update ( salt ) ; md . update ( outer <identifiersep> key ) ; outer <identifiersep> key = md . digest ( ) ; } } block <identifiersep> cipher cipher ; try { <ect>
<comment> <LOG> byte [ ] data = arrays . copy <identifiersep> of ( data <identifiersep> and <identifiersep> hash , data <identifiersep> and <identifiersep> hash . length - hash <identifiersep> length ) ; byte [ ] hash = arrays . copy <identifiersep> of <identifiersep> range ( data <identifiersep> and <identifiersep> hash , data . length , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <ect>
pcfb <identifiersep> mode pcfb = pcfb <identifiersep> mode . create ( cipher , iv ) ; pcfb . block <identifiersep> decipher ( data <identifiersep> and <identifiersep> hash , 0 , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <LOG> clear ( data <identifiersep> and <identifiersep> hash ) ; byte [ ] check <identifiersep> hash = md . digest ( data ) ; <comment> <ect>
dis . read <identifiersep> fully ( database <identifiersep> key ) ; byte [ ] tempfiles <identifiersep> master <identifiersep> secret = new byte [ <number_literal> ] ; boolean must <identifiersep> write = false ; if ( data . length >= <number_literal> + <number_literal> + <number_literal> + <number_literal> ) { dis . read <identifiersep> fully ( tempfiles <identifiersep> master <identifiersep> secret ) ; } else { <LOG> hard <identifiersep> random . next <identifiersep> bytes ( tempfiles <identifiersep> master <identifiersep> secret ) ; must <identifiersep> write = true ; } master <identifiersep> keys ret = new master <identifiersep> keys ( client <identifiersep> cache <identifiersep> key , database <identifiersep> key , tempfiles <identifiersep> master <identifiersep> secret , flags ) ; clear ( data ) ; clear ( hash ) ; sha256 . return <identifiersep> message <identifiersep> digest ( md ) ; <ect>
ret . change <identifiersep> password ( master <identifiersep> keys <identifiersep> file , password , hard <identifiersep> random ) ; } return ret ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> throw new error ( e ) ; } catch ( eof <identifiersep> exception e ) { throw new master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception ( false ) ; } finally { closer . close ( fis ) ; } } system . err . println ( <string_literal> ) ; <ect>
while ( system . current <identifiersep> time <identifiersep> millis ( ) < start <identifiersep> time + iterate <identifiersep> time && iterations < max <identifiersep> iterations - <number_literal> ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { iterations ++ ; md . update ( salt ) ; md . update ( outer <identifiersep> key ) ; outer <identifiersep> key = md . digest ( ) ; } } <LOG> } data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( baos ) ; dos . write <identifiersep> int ( version ) ; dos . write <identifiersep> long ( iterations ) ; baos . write ( salt ) ; baos . write ( iv ) ; int hashed <identifiersep> start = salt . length + iv . length + <number_literal> + <number_literal> ; <ect>
<comment> <LOG> next . rejected <identifiersep> guaranteed ( real <identifiersep> time <identifiersep> flag ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; expected <identifiersep> accept <identifiersep> state = null ; dont <identifiersep> decrement <identifiersep> htl <identifiersep> this <identifiersep> time = true ; route <identifiersep> requests ( ) ; return ; <ect>
return ( real <identifiersep> time <identifiersep> flag ? search <identifiersep> timeout <identifiersep> realtime : search <identifiersep> timeout <identifiersep> bulk ) / <number_literal> ; } protected short hops <identifiersep> for <identifiersep> fatal <identifiersep> timeout <identifiersep> waiting <identifiersep> for <identifiersep> peer ( ) { return hops <identifiersep> for <identifiersep> time ( get <identifiersep> long <identifiersep> slot <identifiersep> waiter <identifiersep> timeout ( ) ) ; } private void log <identifiersep> delta ( long delta , int try <identifiersep> count , boolean waited <identifiersep> for <identifiersep> load <identifiersep> management , boolean retried <identifiersep> for <identifiersep> load <identifiersep> management ) { long long <identifiersep> timeout = get <identifiersep> long <identifiersep> slot <identifiersep> waiter <identifiersep> timeout ( ) ; if ( ( delta > long <identifiersep> timeout ) || try <identifiersep> count > <number_literal> ) <LOG> else if ( ( delta > long <identifiersep> timeout / <number_literal> ) || try <identifiersep> count > 1 ) logger . warning ( this , <string_literal> + try <identifiersep> count + <string_literal> + time <identifiersep> util . format <identifiersep> time ( delta , <number_literal> , true ) + <string_literal> + waited <identifiersep> for <identifiersep> load <identifiersep> management + <string_literal> + retried <identifiersep> for <identifiersep> load <identifiersep> management + ( real <identifiersep> time <identifiersep> flag ? <string_literal> : <string_literal> ) + ( ( source == null ) ? <string_literal> : <string_literal> ) ) ; else if ( log <identifiersep> minor && ( waited <identifiersep> for <identifiersep> load <identifiersep> management || retried <identifiersep> for <identifiersep> load <identifiersep> management ) ) logger . minor ( this , <string_literal> + try <identifiersep> count + <string_literal> + time <identifiersep> util . format <identifiersep> time ( delta , <number_literal> , true ) + <string_literal> + waited <identifiersep> for <identifiersep> load <identifiersep> management + <string_literal> + retried <identifiersep> for <identifiersep> load <identifiersep> management + ( real <identifiersep> time <identifiersep> flag ? <string_literal> : <string_literal> ) + ( ( source == null ) ? <string_literal> : <string_literal> ) ) ; node . node <identifiersep> stats . report <identifiersep> nlm <identifiersep> delay ( delta , real <identifiersep> time <identifiersep> flag , source == null ) ; } private int rejected <identifiersep> loops ; <ect>
if ( soft <identifiersep> reject <identifiersep> count == null ) soft <identifiersep> reject <identifiersep> count = new hash <identifiersep> map < peer <identifiersep> node , integer > ( ) ; integer i = soft <identifiersep> reject <identifiersep> count . get ( next ) ; if ( i == null ) soft <identifiersep> reject <identifiersep> count . put ( next , 1 ) ; else { soft <identifiersep> reject <identifiersep> count . put ( next , i + 1 ) ; if ( i > <number_literal> ) { <LOG> next . output <identifiersep> load <identifiersep> tracker ( real <identifiersep> time <identifiersep> flag ) . set <identifiersep> dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ( ) ; } } return do . wait ; } forward <identifiersep> rejected <identifiersep> overload ( ) ; next . local <identifiersep> rejected <identifiersep> overload ( <string_literal> , real <identifiersep> time <identifiersep> flag ) ; int t = time <identifiersep> since <identifiersep> sent ( ) ; node . failure <identifiersep> table . on <identifiersep> failed ( key , next , htl , t , t ) ; <ect>
<comment> private void enable <identifiersep> logger ( ) { try { pre <identifiersep> set <identifiersep> log <identifiersep> dir ( log <identifiersep> dir ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e3 ) { <LOG> e3 . print <identifiersep> stack <identifiersep> trace ( ) ; } synchronized ( enable <identifiersep> logger <identifiersep> lock ) { if ( file <identifiersep> logger <identifiersep> hook != null ) return ; logger . setup <identifiersep> chain ( ) ; try { config . force <identifiersep> update ( <string_literal> ) ; <ect>
try { hook = new file <identifiersep> logger <identifiersep> hook ( true , new file ( log <identifiersep> dir , log <identifiersep> prefix ) . get <identifiersep> absolute <identifiersep> path ( ) , <string_literal> , <string_literal> , log <identifiersep> rotate <identifiersep> interval , log <identifiersep> level . debug <comment> , false , true , max <identifiersep> zipped <identifiersep> logs <identifiersep> size <comment> , max <identifiersep> cached <identifiersep> log <identifiersep> lines ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } catch ( interval <identifiersep> parse <identifiersep> exception e ) { system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; log <identifiersep> rotate <identifiersep> interval = <string_literal> ; try { hook = <ect>
try { hook = new file <identifiersep> logger <identifiersep> hook ( true , new file ( log <identifiersep> dir , log <identifiersep> prefix ) . get <identifiersep> absolute <identifiersep> path ( ) , <string_literal> , <string_literal> , log <identifiersep> rotate <identifiersep> interval , log <identifiersep> level . debug <comment> , false , true , max <identifiersep> zipped <identifiersep> logs <identifiersep> size <comment> , max <identifiersep> cached <identifiersep> log <identifiersep> lines ) ; } catch ( interval <identifiersep> parse <identifiersep> exception e1 ) { <LOG> return ; } catch ( io <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 . get <identifiersep> message ( ) ) ; return ; } } hook . set <identifiersep> max <identifiersep> list <identifiersep> bytes ( max <identifiersep> cached <identifiersep> log <identifiersep> bytes ) ; hook . set <identifiersep> max <identifiersep> backlog <identifiersep> not <identifiersep> busy ( max <identifiersep> backlog <identifiersep> not <identifiersep> busy ) ; <ect>
string [ ] all = fs . get <identifiersep> all ( <string_literal> ) ; peer [ ] peers = new peer [ all . length ] ; for ( int i = 0 ; i < all . length ; i ++ ) peers [ i ] = new peer ( all [ i ] , false ) ; last <identifiersep> inserted <identifiersep> peers = peers ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { <LOG> } catch ( unknown <identifiersep> host <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + darknet <identifiersep> opennet <identifiersep> string + <string_literal> + e1 + <string_literal> + fs . get ( <string_literal> ) , e1 ) ; } } } } catch ( insert <identifiersep> exception e ) { on <identifiersep> failure ( e , inserter ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
start <identifiersep> inserter ( ) ; } @ override public void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + darknet <identifiersep> opennet <identifiersep> string + <string_literal> + uri ) ; long l = uri . get <identifiersep> suggested <identifiersep> edition ( ) ; if ( l < crypto . my <identifiersep> ark <identifiersep> number ) { <LOG> } else if ( l > crypto . my <identifiersep> ark <identifiersep> number ) { if ( log <identifiersep> minor ) logger . minor ( this , darknet <identifiersep> opennet <identifiersep> string + <string_literal> + crypto . my <identifiersep> ark <identifiersep> number + <string_literal> + l ) ; crypto . my <identifiersep> ark <identifiersep> number = l ; if ( crypto . is <identifiersep> opennet ) node . write <identifiersep> opennet <identifiersep> file ( ) ; else <ect>
int five <identifiersep> minutes <identifiersep> since <identifiersep> epoch = ( int ) ( now / period ) ; int base = five <identifiersep> minutes <identifiersep> since <identifiersep> epoch - was <identifiersep> online <identifiersep> week . length ; <comment> <LOG> } private void read <identifiersep> data ( file file , int base ) { file <identifiersep> input <identifiersep> stream fis = null ; try { fis = new file <identifiersep> input <identifiersep> stream ( file ) ; data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( fis ) ; try { <ect>
was <identifiersep> online [ slot <identifiersep> no % was <identifiersep> online . length ] = was <identifiersep> online <identifiersep> week [ slot <identifiersep> no ] = true ; } } catch ( eof <identifiersep> exception e ) { <comment> <LOG> } finally { closer . close ( fis ) ; } } @ override public void run ( ) { synchronized ( this ) { was <identifiersep> online <identifiersep> week [ slot ] = true ; <ect>
fos = new file <identifiersep> output <identifiersep> stream ( log <identifiersep> file , true ) ; dos = new data <identifiersep> output <identifiersep> stream ( fos ) ; dos . write <identifiersep> int ( five <identifiersep> minutes <identifiersep> since <identifiersep> epoch ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + log <identifiersep> file + <string_literal> + e , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } finally { closer . close ( dos ) ; closer . close ( fos ) ; <comment> <ect>
freenet <identifiersep> inet <identifiersep> address fa = peer . get <identifiersep> freenet <identifiersep> address ( ) . drop <identifiersep> hostname ( ) ; if ( fa == null ) continue ; inet <identifiersep> address ia = fa . get <identifiersep> address ( ) ; if ( v . contains ( ia ) ) continue ; v . add ( ia ) ; } if ( v . is <identifiersep> empty ( ) ) { <LOG> } return v . to <identifiersep> array ( new inet <identifiersep> address [ v . size ( ) ] ) ; } @ override public boolean handshake <identifiersep> unknown <identifiersep> initiator ( ) { return true ; } @ override public int handshake <identifiersep> setup <identifiersep> type ( ) { <ect>
for ( int [ ] range : acks ) { if ( range [ 1 ] < start ) continue ; if ( range [ 0 ] > end ) continue ; int to <identifiersep> add <identifiersep> start = math . max ( start , range [ 0 ] ) ; int to <identifiersep> add <identifiersep> end = math . min ( end , range [ 1 ] ) ; if ( to <identifiersep> add <identifiersep> start == to <identifiersep> add <identifiersep> end || to <identifiersep> add <identifiersep> start > to <identifiersep> add <identifiersep> end ) continue ; <LOG> + range [ 0 ] + <string_literal> + range [ 1 ] + <string_literal> + to <identifiersep> add <identifiersep> start + <string_literal> + to <identifiersep> add <identifiersep> end + <string_literal> ) ; sent . add ( to <identifiersep> add <identifiersep> start , to <identifiersep> add <identifiersep> end ) ; size -= ( to <identifiersep> add <identifiersep> end - to <identifiersep> add <identifiersep> start + 1 ) ; } } } return size ; } public int get <identifiersep> message <identifiersep> id ( ) { <ect>
public abstract long get <identifiersep> cooldown <identifiersep> wakeup ( sendable <identifiersep> request <identifiersep> item token , client <identifiersep> context context ) ; <comment> @ override public void internal <identifiersep> error ( final throwable t , final request <identifiersep> scheduler sched , client <identifiersep> context context , boolean persistent ) { <LOG> sched . call <identifiersep> failure ( this , new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error , t . get <identifiersep> message ( ) , t ) , native <identifiersep> thread . max <identifiersep> priority , persistent ) ; } @ override public final boolean is <identifiersep> insert ( ) { return false ; } @ override public void unregister ( client <identifiersep> context context , short old <identifiersep> prio ) { <ect>
public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; orig <identifiersep> tag . started <identifiersep> sender ( ) ; try { route <identifiersep> requests ( ) ; } catch ( throwable t ) { <LOG> if ( status == not <identifiersep> finished ) finish ( internal <identifiersep> error , null ) ; } finally { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; if ( status == not <identifiersep> finished ) finish ( internal <identifiersep> error , null ) ; <ect>
has <identifiersep> recently <identifiersep> collided = true ; has <identifiersep> collided = true ; notify <identifiersep> all ( ) ; } <comment> <LOG> finish ( internal <identifiersep> error , next ) ; return do . finished ; } } @ override protected message <identifiersep> filter make <identifiersep> accepted <identifiersep> rejected <identifiersep> filter ( peer <identifiersep> node next , long accepted <identifiersep> timeout , uid <identifiersep> tag tag ) { <comment> <ect>
} catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + next ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <LOG> next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; } <comment> <ect>
logger . normal ( this , <string_literal> + next + <string_literal> + this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; return ; } if ( msg == null ) { <comment> <LOG> next . fatal <identifiersep> timeout ( this <identifiersep> tag , false ) ; return ; } do action = handle <identifiersep> message ( msg , next , this <identifiersep> tag ) ; if ( action == do . finished ) return ; else if ( action == do . next <identifiersep> peer ) { <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + request <identifiersep> handler . this ) ; <comment> <LOG> node . tracker . reassign <identifiersep> tag <identifiersep> to <identifiersep> self ( tag ) ; return false ; <comment> <ect>
} , new block <identifiersep> transmitter <identifiersep> completion ( ) { @ override public void block <identifiersep> transfer <identifiersep> finished ( boolean success ) { synchronized ( request <identifiersep> handler . this ) { if ( transfer <identifiersep> completed ) { <LOG> return ; } transfer <identifiersep> completed = true ; transfer <identifiersep> success = success ; if ( ! waiting <identifiersep> for <identifiersep> transfer <identifiersep> success ) return ; } transfer <identifiersep> finished ( success ) ; } } , real <identifiersep> time <identifiersep> flag , node . node <identifiersep> stats ) ; <ect>
<comment> private synchronized boolean ready <identifiersep> to <identifiersep> finish <identifiersep> transfer ( ) { if ( waiting <identifiersep> for <identifiersep> transfer <identifiersep> success ) { <LOG> return false ; } waiting <identifiersep> for <identifiersep> transfer <identifiersep> success = true ; if ( ! transfer <identifiersep> completed ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; return false ; <comment> <ect>
return ; case request <identifiersep> sender . transfer <identifiersep> failed : case request <identifiersep> sender . get <identifiersep> offer <identifiersep> transfer <identifiersep> failed : if ( key instanceof node <identifiersep> chk ) { maybe <identifiersep> complete <identifiersep> transfer ( ) ; return ; } <LOG> return ; default : <comment> <ect>
public void disconnected ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + request <identifiersep> handler . this ) ; complete ( ) ; } @ override public void fatal <identifiersep> error ( ) { <LOG> complete ( ) ; } @ override public void sent ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + request <identifiersep> handler . this ) ; complete ( ) ; <ect>
logger . normal ( this , <string_literal> + this + <string_literal> + ref ) ; else logger . normal ( this , <string_literal> + this ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + source , e ) ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { <LOG> } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + source + <string_literal> + e , e ) ; } } <comment> <ect>
logger . normal ( this , <string_literal> + request <identifiersep> sender . this ) ; reassign <identifiersep> to <identifiersep> self <identifiersep> on <identifiersep> timeout ( from <identifiersep> offered <identifiersep> key ) ; } } , incoming <identifiersep> search <identifiersep> timeout ) ; try { real <identifiersep> run ( ) ; } catch ( throwable t ) { <LOG> finish ( internal <identifiersep> error , null , false ) ; } finally { <comment> <ect>
<comment> <LOG> return failure <identifiersep> table . reject <identifiersep> time ; } return time ; } private class main <identifiersep> loop <identifiersep> callback implements slow <identifiersep> async <identifiersep> message <identifiersep> filter <identifiersep> callback { <comment> <ect>
logger . normal ( this , <string_literal> + waiting <identifiersep> for + <string_literal> + this ) ; waiting <identifiersep> for . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return ; } if ( msg == null ) { <comment> <LOG> waiting <identifiersep> for . fatal <identifiersep> timeout ( orig <identifiersep> tag , false ) ; return ; } do action = handle <identifiersep> message ( msg , no <identifiersep> reroute , waiting <identifiersep> for , this ) ; if ( action == do . finished ) return ; else if ( action == do . next <identifiersep> peer ) { <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + status + <string_literal> + m + <string_literal> + request <identifiersep> sender . this + <string_literal> + pn ) ; } @ override public boolean should <identifiersep> timeout ( ) { return false ; } @ override public void on <identifiersep> timeout ( ) { <LOG> pn . fatal <identifiersep> timeout ( orig <identifiersep> tag , true ) ; } @ override public void on <identifiersep> disconnect ( peer <identifiersep> context ctx ) { <comment> <ect>
pk = node . usm . wait <identifiersep> for ( mf <identifiersep> pk , this ) ; } catch ( disconnected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn + <string_literal> + key ) ; return offer <identifiersep> status . try <identifiersep> another ; } if ( pk == null ) { <LOG> return offer <identifiersep> status . try <identifiersep> another ; } try { pub <identifiersep> key = dsa <identifiersep> public <identifiersep> key . create ( ( ( short <identifiersep> buffer ) pk . get <identifiersep> object ( dmt . pubkey <identifiersep> as <identifiersep> bytes ) ) . get <identifiersep> data ( ) ) ; } catch ( crypt <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> + pn + <string_literal> + key + <string_literal> + e , e ) ; return offer <identifiersep> status . try <identifiersep> another ; <ect>
} catch ( crypt <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> + pn + <string_literal> + key + <string_literal> + e , e ) ; return offer <identifiersep> status . try <identifiersep> another ; } try { ( ( node <identifiersep> ssk ) key ) . set <identifiersep> pub <identifiersep> key ( pub <identifiersep> key ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { <LOG> return offer <identifiersep> status . try <identifiersep> another ; } } if ( finish <identifiersep> ssk <identifiersep> from <identifiersep> get <identifiersep> offer ( pn , headers , ssk <identifiersep> data ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn + <string_literal> + key ) ; return offer <identifiersep> status . fetching ; } else { return offer <identifiersep> status . try <identifiersep> another ; <ect>
} catch ( key <identifiersep> verify <identifiersep> exception e1 ) { logger . normal ( this , <string_literal> + e1 , e1 ) ; if ( offers != null ) { finish ( get <identifiersep> offer <identifiersep> verify <identifiersep> failure , pn , true ) ; offers . delete <identifiersep> last <identifiersep> offer ( ) ; } } catch ( throwable t ) { <LOG> if ( offers != null ) { finish ( internal <identifiersep> error , pn , true ) ; } } finally { <comment> <ect>
node . store <identifiersep> shallow ( block , can <identifiersep> write <identifiersep> client <identifiersep> cache , can <identifiersep> write <identifiersep> datastore , try <identifiersep> offers <identifiersep> only ) ; if ( node . random . next <identifiersep> int ( random <identifiersep> reinsert <identifiersep> interval ) == 0 ) node . queue <identifiersep> random <identifiersep> reinsert ( block ) ; finish ( success , next , true ) ; return true ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { <LOG> return false ; } catch ( key <identifiersep> collision <identifiersep> exception e ) { logger . normal ( this , <string_literal> + this ) ; finish ( success , next , true ) ; return false ; } } protected message create <identifiersep> data <identifiersep> request ( ) { <ect>
logger . error ( this , <string_literal> + this + <string_literal> + current + <string_literal> ) ; break ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + current + <string_literal> + status ) ; wait ( deadline - now ) ; now = system . current <identifiersep> time <identifiersep> millis ( ) ; <comment> <LOG> <comment> <ect>
orig <identifiersep> tag . finished <identifiersep> waiting <identifiersep> for <identifiersep> opennet ( next ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + next , e ) ; ack <identifiersep> opennet ( next ) ; return false ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { <LOG> ack <identifiersep> opennet ( next ) ; return false ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + next + <string_literal> + e , e ) ; ack <identifiersep> opennet ( next ) ; return false ; <ect>
} catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
opennet <identifiersep> finished = true ; notify <identifiersep> all ( ) ; } <comment> <LOG> <comment> <ect>
if ( sent <identifiersep> received <identifiersep> reject <identifiersep> overload ) return ; sent <identifiersep> received <identifiersep> reject <identifiersep> overload = true ; for ( request <identifiersep> sender <identifiersep> listener l : listeners ) { try { l . on <identifiersep> received <identifiersep> reject <identifiersep> overload ( ) ; } catch ( throwable t ) { <LOG> } } } } private boolean sent <identifiersep> chk <identifiersep> transfer <identifiersep> begins ; private void fire <identifiersep> chk <identifiersep> transfer <identifiersep> begins ( ) { synchronized ( listeners ) { if ( sent <identifiersep> chk <identifiersep> transfer <identifiersep> begins ) return ; sent <identifiersep> chk <identifiersep> transfer <identifiersep> begins = true ; for ( request <identifiersep> sender <identifiersep> listener l : listeners ) { <ect>
private boolean sent <identifiersep> request <identifiersep> sender <identifiersep> finished ; private boolean completed <identifiersep> from <identifiersep> offered <identifiersep> key ; private void fire <identifiersep> request <identifiersep> sender <identifiersep> finished ( int status , boolean from <identifiersep> offered <identifiersep> key ) { orig <identifiersep> tag . set <identifiersep> request <identifiersep> sender <identifiersep> finished ( status ) ; synchronized ( listeners ) { if ( sent <identifiersep> request <identifiersep> sender <identifiersep> finished ) { <LOG> return ; } sent <identifiersep> request <identifiersep> sender <identifiersep> finished = true ; completed <identifiersep> from <identifiersep> offered <identifiersep> key = from <identifiersep> offered <identifiersep> key ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + listeners . size ( ) + <string_literal> + status ) ; for ( request <identifiersep> sender <identifiersep> listener l : listeners ) { try { <ect>
private string abort <identifiersep> downstream <identifiersep> transfers <identifiersep> desc ; private boolean receiving <identifiersep> async ; private void reassign <identifiersep> to <identifiersep> self <identifiersep> on <identifiersep> timeout ( boolean from <identifiersep> offered <identifiersep> key ) { request <identifiersep> sender <identifiersep> listener [ ] list ; synchronized ( listeners ) { if ( sent <identifiersep> chk <identifiersep> transfer <identifiersep> begins ) { <LOG> return ; } list = listeners . to <identifiersep> array ( new request <identifiersep> sender <identifiersep> listener [ listeners . size ( ) ] ) ; listeners . clear ( ) ; } for ( request <identifiersep> sender <identifiersep> listener l : list ) { l . on <identifiersep> request <identifiersep> sender <identifiersep> finished ( timed <identifiersep> out , from <identifiersep> offered <identifiersep> key , this ) ; } orig <identifiersep> tag . timed <identifiersep> out <identifiersep> to <identifiersep> handler <identifiersep> but <identifiersep> continued ( ) ; <ect>
on <identifiersep> accepted ( next , true , htl ) ; } } @ override public boolean should <identifiersep> timeout ( ) { return false ; } @ override public void on <identifiersep> timeout ( ) { <LOG> next . fatal <identifiersep> timeout ( orig <identifiersep> tag , false ) ; } @ override public void on <identifiersep> disconnect ( peer <identifiersep> context ctx ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; } @ override public void on <identifiersep> restarted ( peer <identifiersep> context ctx ) { <ect>
dont <identifiersep> ack = true ; continue ; } } } if ( ! recv <identifiersep> buffer . add ( fragment . fragment <identifiersep> data , fragment . fragment <identifiersep> offset ) ) { dont <identifiersep> ack = true ; continue ; } if ( fragment . fragment <identifiersep> length == 0 ) { <LOG> continue ; } recv <identifiersep> map . add ( fragment . fragment <identifiersep> offset , fragment . fragment <identifiersep> offset + fragment . fragment <identifiersep> length - 1 ) ; if ( ( recv <identifiersep> buffer . message <identifiersep> length != - 1 ) && recv <identifiersep> map . contains ( 0 , recv <identifiersep> buffer . message <identifiersep> length - 1 ) ) { receive <identifiersep> buffers . remove ( fragment . message <identifiersep> id ) ; receive <identifiersep> maps . remove ( fragment . message <identifiersep> id ) ; synchronized ( received <identifiersep> messages ) { <ect>
synchronized ( send <identifiersep> buffer <identifiersep> lock ) { receive <identifiersep> buffer <identifiersep> used -= recv <identifiersep> buffer . message <identifiersep> length ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + recv <identifiersep> buffer . message <identifiersep> length + <string_literal> + receive <identifiersep> buffer <identifiersep> used ) ; } fully <identifiersep> received . add ( recv <identifiersep> buffer . buffer ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + fragment . message <identifiersep> id + <string_literal> ) ; } else { <LOG> } } if ( ! dont <identifiersep> ack ) { int seqno = packet . get <identifiersep> sequence <identifiersep> number ( ) ; int acks <identifiersep> queued = key <identifiersep> context . queue <identifiersep> ack ( seqno ) ; boolean added <identifiersep> ack = acks <identifiersep> queued >= 0 ; if ( acks <identifiersep> queued > max <identifiersep> acks ) wake <identifiersep> up = true ; <ect>
move <identifiersep> by = highest <identifiersep> received <identifiersep> seq <identifiersep> num - old <identifiersep> highest <identifiersep> received ; } else { move <identifiersep> by = ( ( int ) ( num <identifiersep> seqnums - old <identifiersep> highest <identifiersep> received ) ) + highest <identifiersep> received <identifiersep> seq <identifiersep> num ; } if ( move <identifiersep> by > key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ) { logger . warning ( this , <string_literal> + move <identifiersep> by ) ; } else if ( move <identifiersep> by < 0 ) { <LOG> move <identifiersep> by = 0 ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + move <identifiersep> by ) ; } int seq <identifiersep> num = ( int ) ( ( 0l + key <identifiersep> context . watch <identifiersep> list <identifiersep> offset + key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ) % num <identifiersep> seqnums ) ; for ( int i = key <identifiersep> context . watch <identifiersep> list <identifiersep> pointer ; i < ( key <identifiersep> context . watch <identifiersep> list <identifiersep> pointer + move <identifiersep> by ) ; i ++ ) { key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list [ i % key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ] = encrypt <identifiersep> sequence <identifiersep> number ( seq <identifiersep> num ++ , session <identifiersep> key ) ; <ect>
if ( ! fields . byte <identifiersep> array <identifiersep> equal ( buf , key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list [ index ] , offset + hmac <identifiersep> length , 0 , key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list [ index ] . length ) ) continue ; int sequence <identifiersep> number = ( int ) ( ( 0l + key <identifiersep> context . watch <identifiersep> list <identifiersep> offset + i ) % num <identifiersep> seqnums ) ; <LOG> npf <identifiersep> packet p = decipher <identifiersep> from <identifiersep> seqnum ( buf , offset , length , session <identifiersep> key , sequence <identifiersep> number ) ; if ( p != null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + p . get <identifiersep> sequence <identifiersep> number ( ) + <string_literal> + session <identifiersep> key ) ; return p ; } } return null ; } <comment> <ect>
new <identifiersep> packet <identifiersep> format <identifiersep> key <identifiersep> context key <identifiersep> context = session <identifiersep> key . packet <identifiersep> context ; npf <identifiersep> packet packet = create <identifiersep> packet ( max <identifiersep> packet <identifiersep> size - hmac <identifiersep> length , pn . get <identifiersep> message <identifiersep> queue ( ) , session <identifiersep> key , ack <identifiersep> only ) ; if ( packet == null ) return false ; int padded <identifiersep> len = packet . get <identifiersep> length ( ) + hmac <identifiersep> length ; if ( pn . should <identifiersep> pad <identifiersep> data <identifiersep> packets ( ) ) { int packet <identifiersep> length = padded <identifiersep> len ; <LOG> if ( packet <identifiersep> length < <number_literal> ) { padded <identifiersep> len = <number_literal> + pn . padding <identifiersep> gen ( ) . next <identifiersep> int ( <number_literal> ) ; } else { padded <identifiersep> len = ( ( packet <identifiersep> length + <number_literal> ) / <number_literal> ) * <number_literal> ; if ( padded <identifiersep> len < max <identifiersep> packet <identifiersep> size ) { padded <identifiersep> len += pn . padding <identifiersep> gen ( ) . next <identifiersep> int ( math . min ( <number_literal> , max <identifiersep> packet <identifiersep> size - padded <identifiersep> len ) ) ; <ect>
sent <identifiersep> packet sent <identifiersep> packet = new sent <identifiersep> packet ( this , session <identifiersep> key ) ; boolean must <identifiersep> send = false ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; new <identifiersep> packet <identifiersep> format <identifiersep> key <identifiersep> context key <identifiersep> context = session <identifiersep> key . packet <identifiersep> context ; added <identifiersep> acks moved = key <identifiersep> context . add <identifiersep> acks ( packet , max <identifiersep> packet <identifiersep> size , now ) ; if ( moved != null && moved . any <identifiersep> urgent <identifiersep> acks ) { <LOG> must <identifiersep> send = true ; } int num <identifiersep> acks = packet . count <identifiersep> acks ( ) ; if ( num <identifiersep> acks > max <identifiersep> acks ) { must <identifiersep> send = true ; } if ( num <identifiersep> acks > 0 ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + this + <string_literal> + pn . short <identifiersep> to <identifiersep> string ( ) ) ; <ect>
if ( item != null ) { byte [ ] buf = item . get <identifiersep> data ( ) ; have <identifiersep> added <identifiersep> stats <identifiersep> rt = buf ; <comment> <LOG> } } if ( ( ! must <identifiersep> send ) && packet . get <identifiersep> length ( ) >= ( max <identifiersep> packet <identifiersep> size * <number_literal> / <number_literal> ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; <comment> <ect>
<comment> <LOG> } } } } <comment> <ect>
if ( can <identifiersep> allocate <identifiersep> id ) { int buffer <identifiersep> usage ; synchronized ( send <identifiersep> buffer <identifiersep> lock ) { buffer <identifiersep> usage = send <identifiersep> buffer <identifiersep> used ; } int max <identifiersep> send <identifiersep> buffer <identifiersep> size = max <identifiersep> send <identifiersep> buffer <identifiersep> size ( ) ; if ( ( buffer <identifiersep> usage + max <identifiersep> message <identifiersep> size ) > max <identifiersep> send <identifiersep> buffer <identifiersep> size ) { <LOG> return false ; } } if ( tracker != null && pn != null ) { packet <identifiersep> throttle throttle = pn . get <identifiersep> throttle ( ) ; if ( throttle == null ) { <comment> <ect>
return false ; } } } if ( ! can <identifiersep> allocate <identifiersep> id ) { synchronized ( send <identifiersep> buffer <identifiersep> lock ) { for ( map < integer , message <identifiersep> wrapper > started : started <identifiersep> by <identifiersep> prio ) { for ( message <identifiersep> wrapper wrapper : started . values ( ) ) { if ( ! wrapper . all <identifiersep> sent ( ) ) return true ; } } } } <LOG> return can <identifiersep> allocate <identifiersep> id ; } private long blocked <identifiersep> since = - 1 ; private int get <identifiersep> message <identifiersep> id ( ) throws blocked <identifiersep> too <identifiersep> long <identifiersep> exception { int message <identifiersep> id ; synchronized ( this ) { if ( seq <identifiersep> num <identifiersep> greater <identifiersep> than ( next <identifiersep> message <identifiersep> id , ( message <identifiersep> window <identifiersep> ptr <identifiersep> acked + msg <identifiersep> window <identifiersep> size ) % num <identifiersep> message <identifiersep> ids , <number_literal> ) ) { <ect>
message <identifiersep> wrapper removed = null ; synchronized ( npf . send <identifiersep> buffer <identifiersep> lock ) { removed = started . remove ( wrapper . get <identifiersep> message <identifiersep> id ( ) ) ; if ( removed != null ) { int size = wrapper . get <identifiersep> length ( ) ; npf . send <identifiersep> buffer <identifiersep> used -= size ; <LOG> } } if ( removed == null && log <identifiersep> minor ) { <comment> <ect>
if ( buffer . length < ( data <identifiersep> offset + data . length ) ) { if ( ! resize ( data <identifiersep> offset + data . length ) ) return false ; } system . arraycopy ( data , 0 , buffer , data <identifiersep> offset , data . length ) ; return true ; } private boolean set <identifiersep> message <identifiersep> length ( int message <identifiersep> length ) { if ( this . message <identifiersep> length != - 1 && this . message <identifiersep> length != message <identifiersep> length ) { <LOG> } this . message <identifiersep> length = message <identifiersep> length ; if ( buffer . length > message <identifiersep> length ) { logger . warning ( this , <string_literal> + buffer . length + <string_literal> + message <identifiersep> length + <string_literal> ) ; } return resize ( message <identifiersep> length ) ; } private boolean resize ( int length ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . length + <string_literal> + length ) ; <ect>
logger . warning ( this , <string_literal> ) ; } this . message <identifiersep> length = message <identifiersep> length ; if ( buffer . length > message <identifiersep> length ) { logger . warning ( this , <string_literal> + buffer . length + <string_literal> + message <identifiersep> length + <string_literal> ) ; } return resize ( message <identifiersep> length ) ; } private boolean resize ( int length ) { <LOG> synchronized ( npf . receive <identifiersep> buffer <identifiersep> size <identifiersep> lock ) { if ( ( npf . receive <identifiersep> buffer <identifiersep> used + ( length - buffer . length ) ) > max <identifiersep> receive <identifiersep> buffer <identifiersep> size ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return false ; } npf . receive <identifiersep> buffer <identifiersep> used += ( length - buffer . length ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ( length - buffer . length ) + <string_literal> + npf . receive <identifiersep> buffer <identifiersep> used ) ; <ect>
request <identifiersep> sender s = null ; synchronized ( this ) { handler <identifiersep> finished = this . handler <identifiersep> transferring ; handler <identifiersep> transferring = false ; sender <identifiersep> finished = this . sender <identifiersep> transferring ; if ( sender <identifiersep> finished ) { <LOG> k = key ; s = sender . get ( ) ; } sender <identifiersep> transferring = false ; } super . inner <identifiersep> unlock ( no <identifiersep> record <identifiersep> unlock ) ; if ( handler <identifiersep> finished ) tracker . remove <identifiersep> transferring <identifiersep> request <identifiersep> handler ( uid ) ; <ect>
synchronized ( this ) { if ( waiting <identifiersep> for <identifiersep> opennet == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return ; } peer <identifiersep> node got = waiting <identifiersep> for <identifiersep> opennet . get ( ) ; if ( got != next ) { <LOG> } waiting <identifiersep> for <identifiersep> opennet = null ; if ( ! must <identifiersep> unlock ( ) ) return ; no <identifiersep> record <identifiersep> unlock = this . no <identifiersep> record <identifiersep> unlock ; } inner <identifiersep> unlock ( no <identifiersep> record <identifiersep> unlock ) ; } @ override public synchronized boolean currently <identifiersep> routing <identifiersep> to ( peer <identifiersep> node peer ) { <ect>
node <identifiersep> config . get <identifiersep> option ( <string_literal> ) . set <identifiersep> value ( <string_literal> ) ; <comment> <LOG> } } <comment> <ect>
<comment> if ( counter . value ( ) == 0 ) { accepted . remove ( source ) ; } } } } ; } } if ( ! available <identifiersep> slot ) { <comment> <LOG> listener . on <identifiersep> error ( error . overload , null , true ) ; return ; } <comment> <ect>
<comment> if ( candidate <identifiersep> degree == 0 ) accept <identifiersep> probability = 1 . 0f ; else accept <identifiersep> probability = ( float ) degree / candidate <identifiersep> degree ; if ( log <identifiersep> debug ) logger . debug ( probe . class , <string_literal> + accept <identifiersep> probability ) ; if ( node . random . next <identifiersep> float ( ) < accept <identifiersep> probability ) { <LOG> <comment> <ect>
htl = probabilistic <identifiersep> decrement ( htl ) ; if ( htl == 0 ) return false ; } } else { if ( log <identifiersep> minor ) logger . minor ( probe . class , <string_literal> , new exception ( ) ) ; } } <comment> <LOG> } listener . on <identifiersep> error ( error . cannot <identifiersep> forward , null , true ) ; return true ; } <comment> <ect>
<comment> @ override public void on <identifiersep> matched ( message message ) { <LOG> if ( message . get <identifiersep> spec ( ) . equals ( dmt . probe <identifiersep> bandwidth ) ) { listener . on <identifiersep> output <identifiersep> bandwidth ( message . get <identifiersep> float ( dmt . output <identifiersep> bandwidth <identifiersep> upper <identifiersep> limit ) ) ; } else if ( message . get <identifiersep> spec ( ) . equals ( dmt . probe <identifiersep> build ) ) { listener . on <identifiersep> build ( message . get <identifiersep> int ( dmt . build ) ) ; } else if ( message . get <identifiersep> spec ( ) . equals ( dmt . probe <identifiersep> identifier ) ) { listener . on <identifiersep> identifier ( message . get <identifiersep> long ( dmt . probe <identifiersep> identifier ) , message . get <identifiersep> byte ( dmt . uptime <identifiersep> percent ) ) ; <ect>
this . source = source ; this . uid = uid ; } private void send ( message message ) { if ( ! source . is <identifiersep> connected ( ) ) { if ( log <identifiersep> debug ) logger . debug ( probe . class , source <identifiersep> disconnect ) ; return ; } <LOG> <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) ) ; try { source . send <identifiersep> async ( message , null , probe . this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> debug ) logger . debug ( probe . class , source <identifiersep> disconnect , e ) ; } } @ override <ect>
log <identifiersep> minor = logger . should <identifiersep> log ( log <identifiersep> level . minor , this ) ; } } ) ; } dns <identifiersep> requester ( node node ) { this . node = node ; } void start ( ) { logger . normal ( this , <string_literal> ) ; <LOG> node . executor . execute ( this , <string_literal> + node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; } @ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { try { <ect>
<comment> @ override public boolean send ( node <identifiersep> client <identifiersep> core core , final request <identifiersep> scheduler sched , final client <identifiersep> context context , final chosen <identifiersep> block req ) { object key <identifiersep> num = req . token ; final client <identifiersep> key key = req . ckey ; if ( key == null ) { <LOG> return false ; } if ( log <identifiersep> minor ) logger . minor ( sendable <identifiersep> get . class , <string_literal> + key <identifiersep> num + <string_literal> + key ) ; if ( req . is <identifiersep> cancelled ( ) ) { if ( log <identifiersep> minor ) logger . minor ( sendable <identifiersep> get . class , <string_literal> + req ) ; req . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . cancelled ) , context ) ; <ect>
try { list < detected <identifiersep> ip > v = new array <identifiersep> list < detected <identifiersep> ip > ( ) ; detected <identifiersep> ip [ ] detected = null ; try { detected = plugin . get <identifiersep> address ( ) ; } catch ( throwable t ) { <LOG> } if ( detected != null ) { for ( detected <identifiersep> ip d : detected ) v . add ( d ) ; } synchronized ( ip <identifiersep> detector <identifiersep> plugin <identifiersep> manager . this ) { last <identifiersep> detect <identifiersep> attempt <identifiersep> ended <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; boolean failed = false ; <ect>
node . executor . execute ( new runnable ( ) { @ override public void run ( ) { try { plugin . on <identifiersep> change <identifiersep> public <identifiersep> ports ( new <identifiersep> ports , ip <identifiersep> detector <identifiersep> plugin <identifiersep> manager . this ) ; } catch ( throwable t ) { <LOG> } } } , <string_literal> + plugin + <string_literal> ) ; } } @ override public void port <identifiersep> forward <identifiersep> status ( map < forward <identifiersep> port , forward <identifiersep> port <identifiersep> status > statuses ) { set < forward <identifiersep> port > current <identifiersep> ports = node . get <identifiersep> public <identifiersep> interface <identifiersep> ports ( ) ; for ( forward <identifiersep> port p : current <identifiersep> ports ) { forward <identifiersep> port <identifiersep> status status = statuses . get ( p ) ; <ect>
logger . normal ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; } else if ( status . status == forward <identifiersep> port <identifiersep> status . maybe <identifiersep> success ) { logger . normal ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; } else if ( status . status == forward <identifiersep> port <identifiersep> status . definite <identifiersep> failure ) { logger . error ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; } else if ( status . status == forward <identifiersep> port <identifiersep> status . probable <identifiersep> failure ) { <LOG> } <comment> <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { real <identifiersep> run ( ) ; } catch ( io <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + e , e ) ; } catch ( throwable t ) { <LOG> } } public void real <identifiersep> run ( ) throws io <identifiersep> exception { print <identifiersep> header ( w ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( in , encoding ) ) ; while ( true ) { try { w . write ( <string_literal> ) ; <ect>
reader . close ( ) ; return ; } } catch ( socket <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } catch ( throwable t ) { <LOG> system . out . println ( <string_literal> + t ) ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; t . print <identifiersep> stack <identifiersep> trace ( new print <identifiersep> writer ( sw ) ) ; try { w . write ( sw . to <identifiersep> string ( ) ) ; } catch ( io <identifiersep> exception e ) { <ect>
system . out . println ( <string_literal> + t ) ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; t . print <identifiersep> stack <identifiersep> trace ( new print <identifiersep> writer ( sw ) ) ; try { w . write ( sw . to <identifiersep> string ( ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } } } } private void print <identifiersep> header ( writer sw ) throws io <identifiersep> exception { string <identifiersep> builder sb = new string <identifiersep> builder ( ) ; sb . append ( <string_literal> ) ; sb . append ( <string_literal> ) ; sb . append ( <string_literal> ) . append ( version . build <identifiersep> number ( ) ) . append ( <string_literal> + version . cvs <identifiersep> revision ( ) + <string_literal> ) ; <ect>
fetch <identifiersep> result result = client . fetch ( uri ) ; client <identifiersep> metadata cm = result . get <identifiersep> metadata ( ) ; outsb . append ( <string_literal> ) . append ( cm . get <identifiersep> mime <identifiersep> type ( ) ) ; bucket data = result . as <identifiersep> bucket ( ) ; <comment> <LOG> outsb . append ( <string_literal> ) . append ( data . size ( ) ) ; outsb . append ( <string_literal> ) ; w . write ( outsb . to <identifiersep> string ( ) ) ; w . flush ( ) ; return false ; } byte [ ] data <identifiersep> bytes = bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( data ) ; <ect>
fetch <identifiersep> result result = fw . wait <identifiersep> for <identifiersep> completion ( ) ; client <identifiersep> metadata cm = result . get <identifiersep> metadata ( ) ; outsb . append ( <string_literal> ) . append ( cm . get <identifiersep> mime <identifiersep> type ( ) ) ; bucket data = result . as <identifiersep> bucket ( ) ; <comment> <LOG> outsb . append ( <string_literal> ) . append ( data . size ( ) ) ; outsb . append ( <string_literal> ) ; w . write ( outsb . to <identifiersep> string ( ) ) ; w . flush ( ) ; return false ; } byte [ ] data <identifiersep> bytes = bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( data ) ; <ect>
output <identifiersep> stream = null ; bis = output . get <identifiersep> input <identifiersep> stream ( ) ; while ( bis . available ( ) > 0 ) { outsb . append ( ( char ) bis . read ( ) ) ; } } catch ( io <identifiersep> exception e ) { outsb . append ( <string_literal> + e . get <identifiersep> message ( ) ) ; <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { outsb . append ( <string_literal> + e . get <identifiersep> message ( ) ) ; logger . error ( this , <string_literal> + e , e ) ; } finally { closer . close ( input <identifiersep> stream ) ; closer . close ( output <identifiersep> stream ) ; <ect>
else if ( uline . starts <identifiersep> with ( <string_literal> ) ) { line = line . substring ( <string_literal> . length ( ) ) ; ssk = true ; } else if ( uline . starts <identifiersep> with ( <string_literal> ) ) line = line . substring ( ( <string_literal> ) . length ( ) ) ; else { <LOG> outsb . append ( <string_literal> ) ; } line = line . trim ( ) ; if ( line . length ( ) < 1 ) { print <identifiersep> header ( w ) ; outsb . append ( <string_literal> ) ; w . write ( outsb . to <identifiersep> string ( ) ) ; <ect>
outsb . append ( <string_literal> ) . append ( key ) ; try { n . set <identifiersep> name ( key ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + key ) ; } catch ( exception e ) { <LOG> } core . store <identifiersep> config ( ) ; } else if ( uline . starts <identifiersep> with ( <string_literal> ) ) { string node <identifiersep> identifier = ( line . substring ( <string_literal> . length ( ) ) ) . trim ( ) ; if ( ! have <identifiersep> peer ( node <identifiersep> identifier ) ) { w . write ( ( <string_literal> + node <identifiersep> identifier + <string_literal> ) ) ; w . flush ( ) ; <ect>
while ( true ) { string line ; try { line = reader . read <identifiersep> line ( ) ; if ( line == null ) throw new eof <identifiersep> exception ( ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> return null ; } if ( ( ! is <identifiersep> field <identifiersep> set ) && line . equals ( <string_literal> ) ) break ; if ( is <identifiersep> field <identifiersep> set ) { <comment> <ect>
x = j + 1 ; break ; } } before = before . substring ( x ) ; line = before + ' = ' + after ; <comment> <LOG> breakflag = true ; } } } } } sb . append ( line ) . append ( <string_literal> ) ; if ( breakflag ) break ; } return sb . to <identifiersep> string ( ) ; } <comment> <ect>
private void add <identifiersep> peer ( string content ) { simple <identifiersep> field <identifiersep> set fs ; system . out . println ( <string_literal> + content ) ; try { fs = new simple <identifiersep> field <identifiersep> set ( content , false , true , false ) ; } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } peer <identifiersep> node pn ; try { pn = n . create <identifiersep> new <identifiersep> darknet <identifiersep> node ( fs , friend <identifiersep> trust . normal , friend <identifiersep> visibility . no ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e1 ) { <ect>
return ; } peer <identifiersep> node pn ; try { pn = n . create <identifiersep> new <identifiersep> darknet <identifiersep> node ( fs , friend <identifiersep> trust . normal , friend <identifiersep> visibility . no ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; <LOG> return ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { <ect>
} catch ( fs <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; <LOG> return ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e1 ) { <ect>
old <identifiersep> tag = local <identifiersep> map . get ( uid ) ; if ( old <identifiersep> tag != null ) { if ( old <identifiersep> tag == tag ) { logger . error ( this , <string_literal> + tag , new exception ( <string_literal> ) ) ; } else { <comment> <LOG> overall <identifiersep> map . remove ( uid ) ; return false ; } } local <identifiersep> map . put ( uid , tag ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + local <identifiersep> map . size ( ) ) ; } } return true ; } <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + overall <identifiersep> map . size ( ) ) ; if ( local ) { if ( local <identifiersep> map . get ( uid ) != tag ) { if ( can <identifiersep> fail ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + tag + <string_literal> + local <identifiersep> map . get ( uid ) + <string_literal> + uid ) ; } else { <LOG> } } else local <identifiersep> map . remove ( uid ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + local <identifiersep> map . size ( ) ) ; } else { assert ( local <identifiersep> map == null ) ; } } } public static class counted <identifiersep> requests { <ect>
transfers <identifiersep> in += in ; if ( counter <identifiersep> sr != null && tag . count <identifiersep> as <identifiersep> source <identifiersep> restarted ( ) ) { count <identifiersep> sr ++ ; transfers <identifiersep> out <identifiersep> sr += out ; transfers <identifiersep> in <identifiersep> sr += in ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + tag + <string_literal> + entry . get <identifiersep> key ( ) + <string_literal> + source + <string_literal> + count + <string_literal> + transfers <identifiersep> out + <string_literal> + transfers <identifiersep> in ) ; <LOG> } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + count + <string_literal> + transfers <identifiersep> in + <string_literal> + transfers <identifiersep> out ) ; counter . total += count ; counter . expected <identifiersep> transfers <identifiersep> in += transfers <identifiersep> in ; counter . expected <identifiersep> transfers <identifiersep> out += transfers <identifiersep> out ; if ( counter <identifiersep> sr != null ) { counter <identifiersep> sr . total += count <identifiersep> sr ; <ect>
public void remove <identifiersep> transferring <identifiersep> sender ( node <identifiersep> chk key , request <identifiersep> sender sender ) { hash <identifiersep> map < node <identifiersep> chk , request <identifiersep> sender > transferring <identifiersep> request <identifiersep> senders = sender . real <identifiersep> time <identifiersep> flag ? transferring <identifiersep> request <identifiersep> senders <identifiersep> rt : transferring <identifiersep> request <identifiersep> senders <identifiersep> bulk ; synchronized ( transferring <identifiersep> request <identifiersep> senders ) { <comment> <LOG> <comment> <ect>
public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { persist <identifiersep> throttle ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; } ps . queue <identifiersep> timed <identifiersep> job ( this , period ) ; } private void persist <identifiersep> throttle ( ) { if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> ) ; <ect>
try { fos = new file <identifiersep> output <identifiersep> stream ( persist <identifiersep> temp ) ; fs . write <identifiersep> to <identifiersep> big <identifiersep> buffer ( fos ) ; fos . close ( ) ; file <identifiersep> util . rename <identifiersep> to ( persist <identifiersep> temp , persist <identifiersep> target ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { persist <identifiersep> temp . delete ( ) ; } finally { closer . close ( fos ) ; } } public simple <identifiersep> field <identifiersep> set read ( ) { simple <identifiersep> field <identifiersep> set throttle <identifiersep> fs = null ; <ect>
if ( persist <identifiersep> target . length ( ) > 0 || persist <identifiersep> temp . length ( ) > 0 ) logger . error ( this , <string_literal> + persist <identifiersep> target + <string_literal> + e + <string_literal> + persist <identifiersep> temp + <string_literal> + e1 + ' ) ' ) ; } } return throttle <identifiersep> fs ; } public void start ( ) { synchronized ( this ) { if ( started ) { <LOG> return ; } started = true ; } semi <identifiersep> ordered <identifiersep> shutdown <identifiersep> hook . get ( ) . add <identifiersep> early <identifiersep> job ( new thread ( ) { public void run ( ) { system . out . println ( <string_literal> + persist <identifiersep> target + <string_literal> ) ; persist <identifiersep> throttle ( ) ; <ect>
addresses . add ( best ) ; } if ( ( second <identifiersep> best != null ) && ( second <identifiersep> best <identifiersep> popularity > 1 ) ) { if ( ! addresses . contains ( second <identifiersep> best ) ) { logger . normal ( this , <string_literal> + second <identifiersep> best + <string_literal> + second <identifiersep> best + ' ) ' ) ; addresses . add ( second <identifiersep> best ) ; } if ( best . get <identifiersep> address ( ) . equals ( second <identifiersep> best . get <identifiersep> address ( ) ) && best <identifiersep> popularity == 1 ) { <LOG> system . err . println ( <string_literal> ) ; ip <identifiersep> detector . set <identifiersep> maybe <identifiersep> symmetric ( ) ; peer p = new peer ( best . get <identifiersep> freenet <identifiersep> address ( ) , crypto . port <identifiersep> number ) ; if ( ! addresses . contains ( p ) ) addresses . add ( p ) ; } } } } } } last <identifiersep> peers = addresses . to <identifiersep> array ( new peer [ addresses . size ( ) ] ) ; <ect>
return true ; } } , false ) ; try { port <identifiersep> number = config . get <identifiersep> int ( <string_literal> ) ; } catch ( exception e ) { <comment> <LOG> system . err . println ( e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; port <identifiersep> number = - 1 ; } config . register ( <string_literal> , <string_literal> , sort <identifiersep> order ++ , true , true , <string_literal> , <string_literal> , new node <identifiersep> bindto <identifiersep> callback ( ) ) ; try { bind <identifiersep> to = new freenet <identifiersep> inet <identifiersep> address ( config . get <identifiersep> string ( <string_literal> ) , false ) ; <ect>
long now = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( now - l . get <identifiersep> location <identifiersep> set <identifiersep> time ( ) > minutes . to <identifiersep> millis ( <number_literal> ) && now - time <identifiersep> loc <identifiersep> set > minutes . to <identifiersep> millis ( <number_literal> ) ) { my <identifiersep> flag = true ; <comment> <LOG> break ; } else { logger . normal ( this , <string_literal> + pn + <string_literal> ) ; } } } } } if ( my <identifiersep> flag ) { set <identifiersep> location ( node . random . next <identifiersep> double ( ) ) ; announce <identifiersep> loc <identifiersep> change ( true , true , true ) ; <ect>
try { <comment> <LOG> <comment> <ect>
<comment> <LOG> return ; } <comment> <ect>
if ( ! java . util . arrays . equals ( rehash , his <identifiersep> hash ) ) { logger . error ( this , <string_literal> + uid ) ; return ; } <comment> <LOG> return ; } long his <identifiersep> random = his <identifiersep> buf <identifiersep> long [ 0 ] ; double his <identifiersep> loc = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ 1 ] ) ; if ( ! location . is <identifiersep> valid ( his <identifiersep> loc ) ) { logger . error ( this , <string_literal> + his <identifiersep> loc + <string_literal> + uid ) ; return ; <ect>
return ; } register <identifiersep> known <identifiersep> location ( his <identifiersep> loc ) ; double [ ] his <identifiersep> friend <identifiersep> locs = new double [ his <identifiersep> buf <identifiersep> long . length - <number_literal> ] ; for ( int i = 0 ; i < his <identifiersep> friend <identifiersep> locs . length ; i ++ ) { his <identifiersep> friend <identifiersep> locs [ i ] = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ i + <number_literal> ] ) ; if ( ! location . is <identifiersep> valid ( his <identifiersep> friend <identifiersep> locs [ i ] ) ) { <LOG> return ; } register <identifiersep> location <identifiersep> link ( his <identifiersep> loc , his <identifiersep> friend <identifiersep> locs [ i ] ) ; register <identifiersep> known <identifiersep> location ( his <identifiersep> friend <identifiersep> locs [ i ] ) ; } number <identifiersep> of <identifiersep> remote <identifiersep> peer <identifiersep> locations <identifiersep> seen <identifiersep> in <identifiersep> swaps += his <identifiersep> friend <identifiersep> locs . length ; <comment> <ect>
} catch ( disconnected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; } if ( reply == null ) { if ( pn . is <identifiersep> routable ( ) && ( system . current <identifiersep> time <identifiersep> millis ( ) - pn . time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) > timeout * <number_literal> ) ) { <comment> <LOG> } return ; } if ( reply . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> swap <identifiersep> rejected ) { <comment> <ect>
if ( reply == null ) { if ( pn . is <identifiersep> routable ( ) && ( system . current <identifiersep> time <identifiersep> millis ( ) - pn . time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) > timeout * <number_literal> ) ) { <comment> <LOG> return ; } byte [ ] his <identifiersep> buf = ( ( short <identifiersep> buffer ) reply . get <identifiersep> object ( dmt . data ) ) . get <identifiersep> data ( ) ; if ( ( his <identifiersep> buf . length % <number_literal> != 0 ) || ( his <identifiersep> buf . length < <number_literal> ) ) { logger . error ( this , <string_literal> + uid ) ; return ; } <comment> <ect>
logger . error ( this , <string_literal> + uid ) ; return false ; } if ( item . request <identifiersep> sender == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + source + <string_literal> + uid ) ; return false ; } if ( item . routed <identifiersep> to == null ) { <LOG> return false ; } if ( source != item . routed <identifiersep> to ) { logger . error ( this , <string_literal> + uid + <string_literal> + source + <string_literal> + item . routed <identifiersep> to + <string_literal> + item . request <identifiersep> sender ) ; return true ; } item . last <identifiersep> message <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + m ) ; return false ; } if ( item . request <identifiersep> sender == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + m ) ; return false ; } if ( item . routed <identifiersep> to == null ) { <LOG> return false ; } if ( source != item . routed <identifiersep> to ) { logger . error ( this , <string_literal> + uid + <string_literal> + source + <string_literal> + item . routed <identifiersep> to + <string_literal> + item . request <identifiersep> sender ) ; return true ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + source + <string_literal> + item . request <identifiersep> sender ) ; <ect>
if ( data . length < <number_literal> || data . length % <number_literal> != 0 ) { logger . error ( this , <string_literal> + data . length , new exception ( <string_literal> ) ) ; return ; } double [ ] locations = fields . bytes <identifiersep> to <identifiersep> doubles ( data , <number_literal> , data . length - <number_literal> ) ; double his <identifiersep> loc = locations [ 0 ] ; if ( ! location . is <identifiersep> valid ( his <identifiersep> loc ) ) { <LOG> return ; } if ( uids != null ) { register <identifiersep> known <identifiersep> location ( his <identifiersep> loc , uids [ 0 ] ) ; if ( swapping <identifiersep> with <identifiersep> me ) register <identifiersep> known <identifiersep> location ( my <identifiersep> loc , uids [ 0 ] ) ; } else if ( ! ignore <identifiersep> if <identifiersep> old ) <ect>
item . request <identifiersep> sender . send <identifiersep> async ( msg , null , this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { logger . normal ( this , <string_literal> + item ) ; } } } private void remove <identifiersep> recently <identifiersep> forwarded <identifiersep> item ( recently <identifiersep> forwarded <identifiersep> item item ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + item ) ; if ( item == null ) { <LOG> } synchronized ( recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds ) { recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds . remove ( item . incoming <identifiersep> id ) ; recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds . remove ( item . outgoing <identifiersep> id ) ; } } private static final long max <identifiersep> age = days . to <identifiersep> millis ( <number_literal> ) ; private final time <identifiersep> sorted <identifiersep> hashtable < double > known <identifiersep> locs = new time <identifiersep> sorted <identifiersep> hashtable < double > ( ) ; void register <identifiersep> location <identifiersep> link ( double d , double t ) { <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { this . real <identifiersep> run ( ) ; } catch ( throwable t ) { this . completed <identifiersep> transfer ( false ) ; this . received <identifiersep> notice ( false , false , true ) ; <LOG> } } private void real <identifiersep> run ( ) { bt . send <identifiersep> async ( ) ; <comment> <ect>
pn . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; synchronized ( background <identifiersep> transfers ) { <comment> <LOG> pn . fatal <identifiersep> timeout ( this <identifiersep> tag , false ) ; return false ; } return true ; } @ override public void on <identifiersep> matched ( message m ) { pn . success <identifiersep> not <identifiersep> overload ( real <identifiersep> time <identifiersep> flag ) ; <ect>
public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; orig <identifiersep> tag . started <identifiersep> sender ( ) ; try { route <identifiersep> requests ( ) ; } catch ( throwable t ) { <LOG> } finally { <comment> <ect>
private static final long timeout <identifiersep> after <identifiersep> acceptedrejected <identifiersep> timeout = minutes . to <identifiersep> millis ( 1 ) ; @ override protected void handle <identifiersep> accepted <identifiersep> rejected <identifiersep> timeout ( final peer <identifiersep> node next , final uid <identifiersep> tag tag ) { <comment> <LOG> <comment> <ect>
@ override public void sent ( ) { <comment> <LOG> next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void disconnected ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + chk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override <ect>
@ override public void disconnected ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + chk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void fatal <identifiersep> error ( ) { <LOG> next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } , chk <identifiersep> insert <identifiersep> sender . this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } } @ override public boolean should <identifiersep> timeout ( ) { <ect>
if ( all <identifiersep> transfers <identifiersep> completed ) return ; <comment> <LOG> } else if ( status != timed <identifiersep> out ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + code + <string_literal> + status ) ; } else { status = code ; } notify <identifiersep> all ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> status <identifiersep> string ( ) + <string_literal> + uid ) ; <ect>
break ; } if ( fail <identifiersep> if <identifiersep> receive <identifiersep> failed ( this <identifiersep> tag , next ) ) { <comment> <LOG> <comment> <ect>
return ; <comment> <LOG> transfer . on <identifiersep> completed ( ) ; return ; } else { <comment> <ect>
buf = msg . encode <identifiersep> to <identifiersep> packet ( ) ; if ( buf . length > new <identifiersep> packet <identifiersep> format . max <identifiersep> message <identifiersep> size ) { <comment> <LOG> } } public message <identifiersep> item ( message msg2 , async <identifiersep> message <identifiersep> callback [ ] cb2 , byte <identifiersep> counter ctr ) { this ( msg2 , cb2 , ctr , ( short ) - 1 ) ; } public message <identifiersep> item ( byte [ ] data , async <identifiersep> message <identifiersep> callback [ ] cb2 , boolean formatted , byte <identifiersep> counter ctr , short priority , boolean send <identifiersep> load <identifiersep> rt , boolean send <identifiersep> load <identifiersep> bulk ) { this . cb = cb2 ; this . msg = null ; this . buf = data ; <ect>
public void on <identifiersep> disconnect ( ) { if ( cb != null ) { for ( async <identifiersep> message <identifiersep> callback cbi : cb ) { try { cbi . disconnected ( ) ; } catch ( throwable t ) { <LOG> } } } } public void on <identifiersep> failed ( ) { if ( cb != null ) { for ( async <identifiersep> message <identifiersep> callback cbi : cb ) { try { cbi . fatal <identifiersep> error ( ) ; } catch ( throwable t ) { <ect>
public void on <identifiersep> sent <identifiersep> all ( ) { if ( cb != null ) { for ( async <identifiersep> message <identifiersep> callback cbi : cb ) { try { cbi . sent ( ) ; } catch ( throwable t ) { <LOG> } } } } <comment> public synchronized void set <identifiersep> deadline ( long time ) { <ect>
try { u = new udp <identifiersep> socket <identifiersep> handler ( port <identifiersep> no , bindto . get <identifiersep> address ( ) , node , startup <identifiersep> time , get <identifiersep> title ( port <identifiersep> no ) , node . collector ) ; port = u . get <identifiersep> port <identifiersep> number ( ) ; break ; } catch ( exception e ) { logger . normal ( this , <string_literal> + bindto + ' : ' + port <identifiersep> no + <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; continue ; } } if ( u == null ) throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> no <identifiersep> available <identifiersep> udp <identifiersep> ports , <string_literal> ) ; } else { try { <ect>
logger . error ( this , <string_literal> + e , e ) ; system . err . println ( e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> impossible <identifiersep> usm <identifiersep> port , <string_literal> + port + <string_literal> ) ; } } socket = u ; logger . normal ( this , <string_literal> + bindto + ' : ' + port ) ; <LOG> port <identifiersep> number = port ; config . set <identifiersep> port ( port ) ; socket . set <identifiersep> drop <identifiersep> probability ( config . get <identifiersep> drop <identifiersep> probability ( ) ) ; packet <identifiersep> mangler = new fnp <identifiersep> packet <identifiersep> mangler ( node , this , socket ) ; detector = new node <identifiersep> ip <identifiersep> port <identifiersep> detector ( node , node . ip <identifiersep> detector , this , enable <identifiersep> ar <identifiersep> ks ) ; anon <identifiersep> setup <identifiersep> cipher = new rijndael ( <number_literal> , <number_literal> ) ; <ect>
byte [ ] sig = ecdsa <identifiersep> p256 . sign ( ref ) ; if ( log <identifiersep> minor && ! ecdsa . verify ( curves . p256 , get <identifiersep> ecdsap256pubkey ( ) , sig , ref ) ) throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> exception <identifiersep> to <identifiersep> debug , my <identifiersep> signed <identifiersep> reference ) ; return base64 . encode ( sig ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { <comment> <LOG> system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> crappy <identifiersep> jvm , <string_literal> ) ; } } private byte [ ] my <identifiersep> compressed <identifiersep> ref ( boolean setup , boolean heavy <identifiersep> setup , boolean for <identifiersep> ark ) { simple <identifiersep> field <identifiersep> set fs = export <identifiersep> public <identifiersep> field <identifiersep> set ( setup , heavy <identifiersep> setup , for <identifiersep> ark ) ; byte <identifiersep> array <identifiersep> output <identifiersep> stream baos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; <ect>
byte <identifiersep> array <identifiersep> output <identifiersep> stream baos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; deflater <identifiersep> output <identifiersep> stream gis ; gis = new deflater <identifiersep> output <identifiersep> stream ( baos ) ; try { fs . write <identifiersep> to ( gis ) ; } catch ( io <identifiersep> exception e ) { <LOG> } finally { closer . close ( gis ) ; closer . close ( baos ) ; } byte [ ] buf = baos . to <identifiersep> byte <identifiersep> array ( ) ; if ( buf . length >= <number_literal> ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + buf . length + <string_literal> ) ; <ect>
<comment> <LOG> } node . peers . disconnect <identifiersep> and <identifiersep> remove ( pn , true , true , pn . is <identifiersep> opennet ( ) ) ; } } } <comment> public block <identifiersep> cipher get <identifiersep> anon <identifiersep> setup <identifiersep> cipher ( ) { return anon <identifiersep> setup <identifiersep> cipher ; <ect>
<comment> <LOG> return ; } if ( tag . should <identifiersep> slow <identifiersep> down ( ) ) { try { source . send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> rejected <identifiersep> overload ( uid , false , false , real <identifiersep> time <identifiersep> flag ) , null , this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <LOG> return ; } can <identifiersep> commit = true ; finish ( status ) ; return ; } if ( status == chk <identifiersep> insert <identifiersep> sender . receive <identifiersep> failed ) { <comment> <ect>
logger . error ( this , <string_literal> + msg + <string_literal> + source ) ; return ; } can <identifiersep> commit = true ; finish ( status ) ; return ; } <comment> <LOG> msg = dmt . create <identifiersep> fnp <identifiersep> rejected <identifiersep> overload ( uid , true , true , real <identifiersep> time <identifiersep> flag ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
source . send <identifiersep> sync ( m , this , real <identifiersep> time <identifiersep> flag ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + m + <string_literal> + this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + source + <string_literal> + this ) ; <comment> <LOG> <comment> <ect>
if ( ! prb . all <identifiersep> received ( ) ) return null ; block = new chk <identifiersep> block ( prb . get <identifiersep> block ( ) , headers , key ) ; } catch ( chk <identifiersep> verify <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( headers ) , e ) ; to <identifiersep> send = dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> verify <identifiersep> failed ) ; } catch ( aborted <identifiersep> exception e ) { <LOG> <comment> <ect>
<comment> @ override public void on <identifiersep> fatal <identifiersep> timeout ( peer <identifiersep> context receiving <identifiersep> from ) { <LOG> ( ( peer <identifiersep> node ) receiving <identifiersep> from ) . fatal <identifiersep> timeout ( ) ; } } ; } <ect>
old <identifiersep> ssk = ssk <identifiersep> datastore ; old <identifiersep> chk <identifiersep> cache = chk <identifiersep> datastore ; old <identifiersep> pk <identifiersep> cache = pub <identifiersep> key <identifiersep> datastore ; old <identifiersep> ssk <identifiersep> cache = ssk <identifiersep> datastore ; } } @ override public void run ( ) { <LOG> if ( client <identifiersep> cache ) { migrate <identifiersep> old <identifiersep> store ( old <identifiersep> chk <identifiersep> client <identifiersep> cache , chk <identifiersep> clientcache , true ) ; store <identifiersep> callback < ? extends storable <identifiersep> block > old ; synchronized ( node . this ) { old = old <identifiersep> chk <identifiersep> client <identifiersep> cache ; old <identifiersep> chk <identifiersep> client <identifiersep> cache = null ; <ect>
freenet <identifiersep> store < t > store = old . get <identifiersep> store ( ) ; if ( store instanceof ram <identifiersep> freenet <identifiersep> store ) { ram <identifiersep> freenet <identifiersep> store < t > ramstore = ( ram <identifiersep> freenet <identifiersep> store < t > ) store ; try { ramstore . migrate <identifiersep> to ( new <identifiersep> store , can <identifiersep> read <identifiersep> client <identifiersep> cache ) ; } catch ( io <identifiersep> exception e ) { <LOG> } ramstore . clear ( ) ; } else if ( store instanceof salted <identifiersep> hash <identifiersep> freenet <identifiersep> store ) { logger . error ( this , <string_literal> ) ; } } public < t extends storable <identifiersep> block > void close <identifiersep> old <identifiersep> store ( store <identifiersep> callback < t > old ) { freenet <identifiersep> store < t > store = old . get <identifiersep> store ( ) ; if ( store instanceof salted <identifiersep> hash <identifiersep> freenet <identifiersep> store ) { <ect>
} catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e1 ) { set <identifiersep> client <identifiersep> cache <identifiersep> awaiting <identifiersep> password ( ) ; throw new invalid <identifiersep> config <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } try { init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( suffix , true , key ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
for ( string udp <identifiersep> addr : udp ) { <comment> <LOG> system . err . println ( <string_literal> + udp <identifiersep> addr ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { throw ( io <identifiersep> exception ) new io <identifiersep> exception ( ) . init <identifiersep> cause ( e ) ; } if ( p . get <identifiersep> port ( ) == get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) { <comment> <ect>
try { <comment> <LOG> system . out . println ( <string_literal> ) ; if ( file . separator <identifiersep> char == ' / ' ) { if ( new file ( <string_literal> ) . exists ( ) ) system . out . println ( <string_literal> ) ; else system . out . println ( <string_literal> ) ; <ect>
if ( is <identifiersep> prng <identifiersep> ready ) return ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; if ( file . separator <identifiersep> char == ' / ' ) { if ( new file ( <string_literal> ) . exists ( ) ) <LOG> else system . out . println ( <string_literal> ) ; } extend <identifiersep> timeouts ( ) ; for ( file root : file . list <identifiersep> roots ( ) ) { if ( is <identifiersep> prng <identifiersep> ready ) return ; <ect>
} else { keys = master <identifiersep> keys . read ( master <identifiersep> keys <identifiersep> file , secure <identifiersep> random , <string_literal> ) ; } client <identifiersep> cache <identifiersep> key = keys . client <identifiersep> cache <identifiersep> master <identifiersep> key ; persistent <identifiersep> secret = keys . get <identifiersep> persistent <identifiersep> master <identifiersep> secret ( ) ; database <identifiersep> key = keys . create <identifiersep> database <identifiersep> key ( secure <identifiersep> random ) ; if ( security <identifiersep> levels . get <identifiersep> physical <identifiersep> threat <identifiersep> level ( ) == physical <identifiersep> threat <identifiersep> level . high ) { <LOG> security <identifiersep> levels . reset <identifiersep> physical <identifiersep> threat <identifiersep> level ( physical <identifiersep> threat <identifiersep> level . normal ) ; } break ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { break ; } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e ) { system . err . println ( <string_literal> + master <identifiersep> keys <identifiersep> file + <string_literal> + e . size <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; <ect>
} catch ( number <identifiersep> format <identifiersep> exception e ) { old <identifiersep> boot <identifiersep> id = - 1 ; } raf . seek ( 0 ) ; } string s = hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( fields . long <identifiersep> to <identifiersep> bytes ( boot <identifiersep> id ) ) ; byte [ ] buf = s . get <identifiersep> bytes ( <string_literal> ) ; if ( buf . length != boot <identifiersep> file <identifiersep> length ) <LOG> raf . write ( buf ) ; } catch ( io <identifiersep> exception e ) { old <identifiersep> boot <identifiersep> id = - 1 ; <comment> <ect>
<comment> <LOG> read <identifiersep> node <identifiersep> file ( node <identifiersep> file <identifiersep> backup . get <identifiersep> path ( ) ) ; } catch ( io <identifiersep> exception e1 ) { if ( node <identifiersep> file . exists ( ) || node <identifiersep> file <identifiersep> backup . exists ( ) ) { system . err . println ( <string_literal> ) ; system . err . println ( e1 . to <identifiersep> string ( ) ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
read <identifiersep> node <identifiersep> file ( node <identifiersep> file <identifiersep> backup . get <identifiersep> path ( ) ) ; } catch ( io <identifiersep> exception e1 ) { if ( node <identifiersep> file . exists ( ) || node <identifiersep> file <identifiersep> backup . exists ( ) ) { system . err . println ( <string_literal> ) ; system . err . println ( e1 . to <identifiersep> string ( ) ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> system . err . println ( e . to <identifiersep> string ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } else { system . err . println ( <string_literal> ) ; } init <identifiersep> node <identifiersep> file <identifiersep> settings ( ) ; } } <comment> <ect>
toadlets . set <identifiersep> core ( client <identifiersep> core ) ; if ( jvm <identifiersep> version . is <identifiersep> eol ( ) ) { client <identifiersep> core . alerts . register ( new jvm <identifiersep> version <identifiersep> alert ( ) ) ; } if ( show <identifiersep> friends <identifiersep> visibility <identifiersep> alert ) register <identifiersep> friends <identifiersep> visibility <identifiersep> alert ( ) ; <comment> <LOG> try { node <identifiersep> updater = node <identifiersep> update <identifiersep> manager . maybe <identifiersep> create ( this , config ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> could <identifiersep> not <identifiersep> start <identifiersep> updater , <string_literal> + e ) ; } <comment> <ect>
synchronized ( node . this ) { if ( opennet == null ) { try { o = opennet = new opennet <identifiersep> manager ( node . this , opennet <identifiersep> crypto <identifiersep> config , system . current <identifiersep> time <identifiersep> millis ( ) , is <identifiersep> allowed <identifiersep> to <identifiersep> connect <identifiersep> to <identifiersep> seednodes ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { opennet = null ; <LOG> client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( false , l10n ( <string_literal> ) , l10n ( <string_literal> , <string_literal> , e . get <identifiersep> localized <identifiersep> message ( ) ) , l10n ( <string_literal> , <string_literal> , e . get <identifiersep> localized <identifiersep> message ( ) ) , user <identifiersep> alert . error ) ) ; } } } if ( o != null ) { o . start ( ) ; ip <identifiersep> detector . ip <identifiersep> detector <identifiersep> manager . notify <identifiersep> port <identifiersep> change ( get <identifiersep> public <identifiersep> interface <identifiersep> ports ( ) ) ; } } node . this . config . store ( ) ; } } ) ; <ect>
pub <identifiersep> key <identifiersep> datacache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> datastore . set <identifiersep> max <identifiersep> keys ( max <identifiersep> store <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> datacache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } <comment> <ect>
client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . disable <identifiersep> write ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . wait <identifiersep> for <identifiersep> not <identifiersep> writing ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . delete <identifiersep> all <identifiersep> files ( ) ; } catch ( io <identifiersep> exception e ) { master <identifiersep> keys <identifiersep> file . delete ( ) ; logger . error ( this , <string_literal> + master <identifiersep> keys <identifiersep> file ) ; <LOG> client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( true , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , user <identifiersep> alert . critical <identifiersep> error ) ) ; } } if ( old <identifiersep> level == physical <identifiersep> threat <identifiersep> level . maximum && new <identifiersep> level != physical <identifiersep> threat <identifiersep> level . high ) { <comment> <ect>
master <identifiersep> keys keys ; synchronized ( this ) { keys = node . this . keys ; } keys . change <identifiersep> password ( master <identifiersep> keys <identifiersep> file , <string_literal> , secure <identifiersep> random ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + master <identifiersep> keys <identifiersep> file + <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } } ) ; if ( security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level == physical <identifiersep> threat <identifiersep> level . maximum ) { try { kill <identifiersep> master <identifiersep> keys <identifiersep> file ( ) ; } catch ( io <identifiersep> exception e ) { <ect>
caching <identifiersep> freenet <identifiersep> store <identifiersep> period = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size > 0 && caching <identifiersep> freenet <identifiersep> store <identifiersep> period > 0 ) { caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker = new caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size , caching <identifiersep> freenet <identifiersep> store <identifiersep> period , ticker ) ; } boolean should <identifiersep> write <identifiersep> config = false ; if ( store <identifiersep> type . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; store <identifiersep> type = <string_literal> ; should <identifiersep> write <identifiersep> config = true ; delete <identifiersep> old <identifiersep> bdb <identifiersep> index <identifiersep> store <identifiersep> files ( ) ; } if ( store <identifiersep> type . equals ( <string_literal> ) ) { init <identifiersep> ramfs ( ) ; <ect>
try { chk <identifiersep> clientcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> client <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; pub <identifiersep> key <identifiersep> clientcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> client <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> clientcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> client <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> system . err . println ( <string_literal> + e + <string_literal> ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } , true ) ; max <identifiersep> total <identifiersep> client <identifiersep> cache <identifiersep> size = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( max <identifiersep> total <identifiersep> client <identifiersep> cache <identifiersep> size < min <identifiersep> client <identifiersep> cache <identifiersep> size ) { throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> invalid <identifiersep> store <identifiersep> size , <string_literal> ) ; <ect>
if ( max <identifiersep> total <identifiersep> client <identifiersep> cache <identifiersep> size < min <identifiersep> client <identifiersep> cache <identifiersep> size ) { throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> invalid <identifiersep> store <identifiersep> size , <string_literal> ) ; } max <identifiersep> client <identifiersep> cache <identifiersep> keys = max <identifiersep> total <identifiersep> client <identifiersep> cache <identifiersep> size / size <identifiersep> per <identifiersep> key ; boolean started <identifiersep> client <identifiersep> cache = false ; if ( client <identifiersep> cache <identifiersep> type . equals ( <string_literal> ) ) { if ( client <identifiersep> cache <identifiersep> key == null ) { <LOG> set <identifiersep> client <identifiersep> cache <identifiersep> awaiting <identifiersep> password ( ) ; } else { init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( suffix , false , client <identifiersep> cache <identifiersep> key ) ; started <identifiersep> client <identifiersep> cache = true ; } } else if ( client <identifiersep> cache <identifiersep> type . equals ( <string_literal> ) ) { init <identifiersep> no <identifiersep> client <identifiersep> cache <identifiersep> fs ( ) ; <ect>
try { late <identifiersep> setup <identifiersep> database ( database <identifiersep> key ) ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e2 ) { <LOG> e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( io <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } } node <identifiersep> config . register ( <string_literal> , true , sort <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , new boolean <identifiersep> callback ( ) { @ override <ect>
try { chk <identifiersep> slashdotcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; pub <identifiersep> key <identifiersep> slashdotcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> slashdotcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> system . err . println ( <string_literal> + e + <string_literal> ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } , true ) ; max <identifiersep> slashdot <identifiersep> cache <identifiersep> size = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> size < min <identifiersep> slashdot <identifiersep> cache <identifiersep> size ) { throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> invalid <identifiersep> store <identifiersep> size , <string_literal> ) ; <ect>
try { if ( ! client <identifiersep> core . late <identifiersep> init <identifiersep> database ( database <identifiersep> key ) ) fail <identifiersep> late <identifiersep> init <identifiersep> database ( ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { fail <identifiersep> late <identifiersep> init <identifiersep> database ( ) ; } } private void fail <identifiersep> late <identifiersep> init <identifiersep> database ( ) { <LOG> } public void kill <identifiersep> master <identifiersep> keys <identifiersep> file ( ) throws io <identifiersep> exception { master <identifiersep> keys . kill <identifiersep> master <identifiersep> keys ( master <identifiersep> keys <identifiersep> file ) ; } private void set <identifiersep> client <identifiersep> cache <identifiersep> awaiting <identifiersep> password ( ) { create <identifiersep> password <identifiersep> user <identifiersep> alert ( ) ; synchronized ( this ) { client <identifiersep> cache <identifiersep> awaiting <identifiersep> password = true ; <ect>
system . err . println ( <string_literal> ) ; init <identifiersep> ramfs ( ) ; final runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( false ) ; this . get <identifiersep> ticker ( ) . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { <LOG> try { chk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; chk <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; <ect>
pubkey <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } node . this . chk <identifiersep> datastore = chk <identifiersep> datastore ; node . this . chk <identifiersep> datacache = chk <identifiersep> datacache ; node . this . pub <identifiersep> key <identifiersep> datastore = pub <identifiersep> key <identifiersep> datastore ; node . this . pub <identifiersep> key <identifiersep> datacache = pub <identifiersep> key <identifiersep> datacache ; <ect>
get <identifiersep> pub <identifiersep> key . set <identifiersep> data <identifiersep> store ( pub <identifiersep> key <identifiersep> datastore , pub <identifiersep> key <identifiersep> datacache ) ; node . this . ssk <identifiersep> datastore = ssk <identifiersep> datastore ; node . this . ssk <identifiersep> datacache = ssk <identifiersep> datacache ; finish <identifiersep> init <identifiersep> salt <identifiersep> hash <identifiersep> fs ( suffix , client <identifiersep> core ) ; } } , <string_literal> , 0 , true , false ) ; } } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> store <identifiersep> other , e . get <identifiersep> message ( ) ) ; } } private void init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( final string suffix , boolean dont <identifiersep> resize <identifiersep> on <identifiersep> start , byte [ ] client <identifiersep> cache <identifiersep> master <identifiersep> key ) throws node <identifiersep> init <identifiersep> exception { try { final chk <identifiersep> store chk <identifiersep> clientcache = new chk <identifiersep> store ( ) ; final freenet <identifiersep> store < chk <identifiersep> block > chk <identifiersep> data <identifiersep> fs = make <identifiersep> clientcache ( <string_literal> , true , chk <identifiersep> clientcache , dont <identifiersep> resize <identifiersep> on <identifiersep> start , client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; <ect>
system . err . println ( <string_literal> ) ; init <identifiersep> ram <identifiersep> client <identifiersep> cache <identifiersep> fs ( ) ; final runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( true ) ; get <identifiersep> ticker ( ) . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { <LOG> try { chk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
try { chk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } node . this . chk <identifiersep> clientcache = chk <identifiersep> clientcache ; node . this . pub <identifiersep> key <identifiersep> clientcache = pub <identifiersep> key <identifiersep> clientcache ; get <identifiersep> pub <identifiersep> key . set <identifiersep> local <identifiersep> data <identifiersep> store ( pub <identifiersep> key <identifiersep> clientcache ) ; node . this . ssk <identifiersep> clientcache = ssk <identifiersep> clientcache ; <ect>
} else { node . this . chk <identifiersep> clientcache = chk <identifiersep> clientcache ; node . this . pub <identifiersep> key <identifiersep> clientcache = pub <identifiersep> key <identifiersep> clientcache ; get <identifiersep> pub <identifiersep> key . set <identifiersep> local <identifiersep> data <identifiersep> store ( pub <identifiersep> key <identifiersep> clientcache ) ; node . this . ssk <identifiersep> clientcache = ssk <identifiersep> clientcache ; } } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> store <identifiersep> other , e . get <identifiersep> message ( ) ) ; } } private < t extends storable <identifiersep> block > freenet <identifiersep> store < t > make <identifiersep> clientcache ( string type , boolean is <identifiersep> store , store <identifiersep> callback < t > cb , boolean dont <identifiersep> resize <identifiersep> on <identifiersep> start , byte [ ] client <identifiersep> cache <identifiersep> master <identifiersep> key ) throws io <identifiersep> exception { freenet <identifiersep> store < t > store = make <identifiersep> store ( type , <string_literal> , max <identifiersep> client <identifiersep> cache <identifiersep> keys , cb , dont <identifiersep> resize <identifiersep> on <identifiersep> start , client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; return store ; } private < t extends storable <identifiersep> block > freenet <identifiersep> store < t > make <identifiersep> store ( string type , boolean is <identifiersep> store , store <identifiersep> callback < t > cb , boolean dont <identifiersep> resize <identifiersep> on <identifiersep> start , byte [ ] client <identifiersep> cache <identifiersep> master <identifiersep> key ) throws io <identifiersep> exception { <ect>
ps . start ( node <identifiersep> stats ) ; ticker . start ( ) ; schedule <identifiersep> version <identifiersep> transition ( ) ; usm . start ( ticker ) ; if ( is <identifiersep> using <identifiersep> wrapper ( ) ) { logger . normal ( this , <string_literal> + node <identifiersep> starter ) ; <LOG> } else { logger . error ( this , <string_literal> ) ; system . out . println ( <string_literal> ) ; } logger . normal ( this , <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; logger . normal ( this , <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; <ect>
usm . start ( ticker ) ; if ( is <identifiersep> using <identifiersep> wrapper ( ) ) { logger . normal ( this , <string_literal> + node <identifiersep> starter ) ; system . out . println ( <string_literal> + node <identifiersep> starter ) ; } else { logger . error ( this , <string_literal> ) ; <LOG> } logger . normal ( this , <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; logger . normal ( this , <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; system . out . println ( <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; <comment> <ect>
} else { logger . error ( this , <string_literal> ) ; system . out . println ( <string_literal> ) ; } logger . normal ( this , <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; logger . normal ( this , <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; <LOG> <comment> <ect>
pub <identifiersep> key = get <identifiersep> pub <identifiersep> key . get <identifiersep> key ( ssk <identifiersep> key . get <identifiersep> pub <identifiersep> key <identifiersep> hash ( ) , can <identifiersep> read <identifiersep> client <identifiersep> cache , offers <identifiersep> only , null ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pub <identifiersep> key ) ; try { ssk <identifiersep> key . set <identifiersep> pub <identifiersep> key ( pub <identifiersep> key ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { <LOG> } } if ( pub <identifiersep> key != null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pub <identifiersep> key ) ; kb = fetch ( ssk <identifiersep> key , can <identifiersep> read <identifiersep> client <identifiersep> cache , can <identifiersep> write <identifiersep> client <identifiersep> cache , can <identifiersep> write <identifiersep> datastore , false , null ) ; } else { if ( log <identifiersep> minor ) <ect>
node <identifiersep> stats . avg <identifiersep> client <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> client <identifiersep> cache <identifiersep> ssk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> client <identifiersep> cache <identifiersep> ssk <identifiersep> success = dist ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key + <string_literal> ) ; return block ; } } catch ( io <identifiersep> exception e ) { <LOG> } } if ( for <identifiersep> ulpr || use <identifiersep> slashdot <identifiersep> cache || can <identifiersep> read <identifiersep> client <identifiersep> cache ) { try { ssk <identifiersep> block block = ssk <identifiersep> slashdotcache . fetch ( key , dont <identifiersep> promote , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , false , meta ) ; if ( block != null ) { node <identifiersep> stats . avg <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success ) <ect>
node <identifiersep> stats . avg <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success = dist ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key + <string_literal> ) ; return block ; } } catch ( io <identifiersep> exception e ) { <LOG> } } boolean ignore <identifiersep> old <identifiersep> blocks = ! write <identifiersep> local <identifiersep> to <identifiersep> datastore ; if ( can <identifiersep> read <identifiersep> client <identifiersep> cache ) ignore <identifiersep> old <identifiersep> blocks = false ; if ( log <identifiersep> minor ) dump <identifiersep> store <identifiersep> hits ( ) ; try { node <identifiersep> stats . avg <identifiersep> request <identifiersep> location . report ( loc ) ; ssk <identifiersep> block block = ssk <identifiersep> datastore . fetch ( key , dont <identifiersep> promote || ! can <identifiersep> write <identifiersep> datastore , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , ignore <identifiersep> old <identifiersep> blocks , meta ) ; <ect>
if ( store != null ) block = store . fetch ( key , dont <identifiersep> promote || ! can <identifiersep> write <identifiersep> datastore , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , ignore <identifiersep> old <identifiersep> blocks , meta ) ; } if ( block != null ) { node <identifiersep> stats . avg <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> cache <identifiersep> ssk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> cache <identifiersep> ssk <identifiersep> success = dist ; <LOG> } return block ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return null ; } } public chk <identifiersep> block fetch ( node <identifiersep> chk key , boolean dont <identifiersep> promote , boolean can <identifiersep> read <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore , boolean for <identifiersep> ulpr , block <identifiersep> metadata meta ) { double loc = key . to <identifiersep> normalized <identifiersep> double ( ) ; <ect>
if ( block != null ) { node <identifiersep> stats . avg <identifiersep> client <identifiersep> cache <identifiersep> chk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> client <identifiersep> cache <identifiersep> chk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> client <identifiersep> cache <identifiersep> chk <identifiersep> success = dist ; return block ; } } catch ( io <identifiersep> exception e ) { <LOG> } } if ( for <identifiersep> ulpr || use <identifiersep> slashdot <identifiersep> cache || can <identifiersep> read <identifiersep> client <identifiersep> cache ) { try { chk <identifiersep> block block = chk <identifiersep> slashdotcache . fetch ( key , dont <identifiersep> promote , false , meta ) ; if ( block != null ) { node <identifiersep> stats . avg <identifiersep> slashdot <identifiersep> cache <identifiersep> chk <identifiersep> sucess . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> chk <identifiersep> success ) <ect>
if ( block != null ) { node <identifiersep> stats . avg <identifiersep> cache <identifiersep> chk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> cache <identifiersep> chk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> cache <identifiersep> chk <identifiersep> success = dist ; } return block ; } catch ( io <identifiersep> exception e ) { <LOG> return null ; } } chk <identifiersep> store get <identifiersep> chk <identifiersep> datacache ( ) { return chk <identifiersep> datacache ; } chk <identifiersep> store get <identifiersep> chk <identifiersep> datastore ( ) { return chk <identifiersep> datastore ; } ssk <identifiersep> store get <identifiersep> ssk <identifiersep> datacache ( ) { <ect>
return ; } if ( fs . get ( <string_literal> ) != null ) { fs . remove <identifiersep> value ( <string_literal> ) ; } try { src . process <identifiersep> diff <identifiersep> noderef ( fs ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <LOG> return ; } } } ; private node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener fproxy <identifiersep> n2nm <identifiersep> listener = new node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener ( ) { @ override public void handle <identifiersep> message ( byte [ ] data , boolean from <identifiersep> darknet , peer <identifiersep> node src , int type ) { if ( ! from <identifiersep> darknet ) { <ect>
simple <identifiersep> field <identifiersep> set fs = null ; try { fs = new simple <identifiersep> field <identifiersep> set ( new string ( data , <string_literal> ) , false , true , false ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { throw new error ( <string_literal> + e , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } fs . put <identifiersep> overwrite ( <string_literal> , integer . to <identifiersep> string ( type ) ) ; fs . put <identifiersep> overwrite ( <string_literal> , long . to <identifiersep> string ( system . current <identifiersep> time <identifiersep> millis ( ) ) ) ; fs . put <identifiersep> overwrite ( <string_literal> , <string_literal> ) ; int file <identifiersep> number = dark <identifiersep> source . write <identifiersep> new <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( fs , extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> n2ntm ) ; if ( file <identifiersep> number == - 1 ) { <ect>
logger . minor ( this , <string_literal> + fs ) ; int overall <identifiersep> type = fs . get <identifiersep> int ( <string_literal> ) ; fs . remove <identifiersep> value ( <string_literal> ) ; if ( overall <identifiersep> type == node . n2n <identifiersep> message <identifiersep> type <identifiersep> fproxy ) { handle <identifiersep> fproxy <identifiersep> node <identifiersep> to <identifiersep> node <identifiersep> text <identifiersep> message <identifiersep> simple <identifiersep> field <identifiersep> set ( fs , source , file <identifiersep> number ) ; } else { <LOG> } } private void handle <identifiersep> fproxy <identifiersep> node <identifiersep> to <identifiersep> node <identifiersep> text <identifiersep> message <identifiersep> simple <identifiersep> field <identifiersep> set ( simple <identifiersep> field <identifiersep> set fs , darknet <identifiersep> peer <identifiersep> node source , int file <identifiersep> number ) throws fs <identifiersep> parse <identifiersep> exception { int type = fs . get <identifiersep> int ( <string_literal> ) ; if ( type == node . n2n <identifiersep> text <identifiersep> message <identifiersep> type <identifiersep> useralert ) { source . handle <identifiersep> fproxy <identifiersep> n2ntm ( fs , file <identifiersep> number ) ; } else if ( type == node . n2n <identifiersep> text <identifiersep> message <identifiersep> type <identifiersep> file <identifiersep> offer ) { source . handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer ( fs , file <identifiersep> number ) ; <ect>
activate <identifiersep> passworded <identifiersep> client <identifiersep> cache ( keys ) ; if ( want <identifiersep> database ) late <identifiersep> setup <identifiersep> database ( keys . create <identifiersep> database <identifiersep> key ( secure <identifiersep> random ) ) ; } private void activate <identifiersep> passworded <identifiersep> client <identifiersep> cache ( master <identifiersep> keys keys ) { synchronized ( this ) { if ( client <identifiersep> cache <identifiersep> type . equals ( <string_literal> ) ) { <LOG> return ; } if ( ! client <identifiersep> cache <identifiersep> type . equals ( <string_literal> ) ) { system . err . println ( <string_literal> + client <identifiersep> cache <identifiersep> type ) ; return ; } } runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( true ) ; string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; <ect>
return ; } } runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( true ) ; string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; try { init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( suffix , true , keys . client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } synchronized ( this ) { client <identifiersep> cache <identifiersep> awaiting <identifiersep> password = false ; } executor . execute ( migrate , <string_literal> ) ; <ect>
return ; } synchronized ( this ) { client <identifiersep> cache <identifiersep> awaiting <identifiersep> password = false ; } executor . execute ( migrate , <string_literal> ) ; } public void change <identifiersep> master <identifiersep> password ( string old <identifiersep> password , string new <identifiersep> password , boolean in <identifiersep> first <identifiersep> time <identifiersep> wizard ) throws master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception , master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception , io <identifiersep> exception , already <identifiersep> set <identifiersep> password <identifiersep> exception { if ( security <identifiersep> levels . get <identifiersep> physical <identifiersep> threat <identifiersep> level ( ) == physical <identifiersep> threat <identifiersep> level . maximum ) <LOG> if ( master <identifiersep> keys <identifiersep> file . exists ( ) ) { keys . change <identifiersep> password ( master <identifiersep> keys <identifiersep> file , new <identifiersep> password , secure <identifiersep> random ) ; set <identifiersep> password <identifiersep> inner ( keys , in <identifiersep> first <identifiersep> time <identifiersep> wizard ) ; } else { set <identifiersep> master <identifiersep> password ( new <identifiersep> password , in <identifiersep> first <identifiersep> time <identifiersep> wizard ) ; } } public static class already <identifiersep> set <identifiersep> password <identifiersep> exception extends exception { <ect>
client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . panic ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . kill <identifiersep> and <identifiersep> wait <identifiersep> for <identifiersep> not <identifiersep> running ( ) ; try { master <identifiersep> keys . kill <identifiersep> master <identifiersep> keys ( get <identifiersep> master <identifiersep> password <identifiersep> file ( ) ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; <LOG> + <string_literal> ) ; } <comment> <ect>
if ( ssl ) { network <identifiersep> interface = ssl <identifiersep> network <identifiersep> interface . create ( port , bind <identifiersep> to , allowed <identifiersep> hosts , n . executor , true ) ; } else { network <identifiersep> interface = network <identifiersep> interface . create ( port , bind <identifiersep> to , allowed <identifiersep> hosts , n . executor , true ) ; } } void start ( ) { logger . normal ( core , <string_literal> + network <identifiersep> interface . get <identifiersep> allowed <identifiersep> hosts ( ) + ' : ' + port ) ; <LOG> n . executor . execute ( this , <string_literal> ) ; } public static text <identifiersep> mode <identifiersep> client <identifiersep> interface <identifiersep> server maybe <identifiersep> create ( node node , node <identifiersep> client <identifiersep> core core , config config ) throws io <identifiersep> exception { text <identifiersep> mode <identifiersep> client <identifiersep> interface <identifiersep> server server = null ; sub <identifiersep> config tmci <identifiersep> config = config . create <identifiersep> sub <identifiersep> config ( <string_literal> ) ; tmci <identifiersep> config . register ( <string_literal> , false , 1 , true , true <comment> , <string_literal> , <string_literal> , new tmci <identifiersep> enabled <identifiersep> callback ( core ) ) ; tmci <identifiersep> config . register ( <string_literal> , false , 1 , true , true , <string_literal> , <string_literal> , new tmcissl <identifiersep> callback ( ) ) ; <ect>
int cur <identifiersep> port = port ; string temp <identifiersep> bind <identifiersep> to = this . bind <identifiersep> to ; try { network <identifiersep> interface . set <identifiersep> so <identifiersep> timeout ( <number_literal> ) ; } catch ( socket <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 , e1 ) ; <LOG> e1 . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } while ( is <identifiersep> enabled ) { <comment> <ect>
text <identifiersep> mode <identifiersep> client <identifiersep> interface tmci = new text <identifiersep> mode <identifiersep> client <identifiersep> interface ( this , in , out ) ; n . executor . execute ( tmci , <string_literal> + s . get <identifiersep> port ( ) ) ; } catch ( socket <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } try { network <identifiersep> interface . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; } } } public void set <identifiersep> port ( int val ) { port = val ; <ect>
add <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> forward ( list ) ; items <identifiersep> by <identifiersep> id . put ( id , list ) ; if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; } else { if ( list . items . is <identifiersep> empty ( ) ) { if ( list . get <identifiersep> parent ( ) == non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <LOG> } else { assert ( list . get <identifiersep> parent ( ) == empty <identifiersep> items <identifiersep> with <identifiersep> id ) ; <comment> <ect>
if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; } private void move <identifiersep> from <identifiersep> empty <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> forward ( items list ) { <comment> <LOG> return ; } } if ( empty <identifiersep> items <identifiersep> with <identifiersep> id != null ) empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( list ) ; add <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> forward ( list ) ; } private void add <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> forward ( items list ) { if ( non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id == null ) <ect>
prev <identifiersep> items = items ; } } if ( items <identifiersep> non <identifiersep> urgent != null ) { long prev = - 1 ; message <identifiersep> item prev <identifiersep> item = null ; for ( message <identifiersep> item item : items <identifiersep> non <identifiersep> urgent ) { if ( item . submitted < prev ) <LOG> prev = item . submitted ; prev <identifiersep> item = item ; } } } <comment> <ect>
<comment> <LOG> } else if ( parent == empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <comment> <ect>
logger . error ( this , <string_literal> ) ; non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( tracker ) ; } else assert ( false ) ; add <identifiersep> to <identifiersep> empty <identifiersep> backward ( tracker ) ; } else { <LOG> if ( non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id == null ) non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id = new doubly <identifiersep> linked <identifiersep> list <identifiersep> impl < items > ( ) ; if ( parent == null ) { logger . error ( this , <string_literal> ) ; } else if ( parent == non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <comment> <ect>
if ( parent == null ) { logger . error ( this , <string_literal> ) ; } else if ( parent == non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <comment> <LOG> empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( tracker ) ; } else assert ( false ) ; add <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> backward ( tracker ) ; } } } if ( must <identifiersep> send <identifiersep> load <identifiersep> rt && item . send <identifiersep> load <identifiersep> rt && ! add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> rt . value ) { add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> rt . value = true ; <ect>
else if ( old != list ) logger . error ( this , <string_literal> + old + <string_literal> + list + <string_literal> + list . id ) ; empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( list ) ; removed ++ ; } else { if ( log <identifiersep> debug && removed > 0 ) <LOG> break ; } } } public void clear ( ) { empty <identifiersep> items <identifiersep> with <identifiersep> id = null ; non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id = null ; items <identifiersep> by <identifiersep> id = null ; items <identifiersep> non <identifiersep> urgent = null ; <ect>
<comment> while ( true ) { last <identifiersep> received <identifiersep> packet <identifiersep> from <identifiersep> any <identifiersep> node = last <identifiersep> reported <identifiersep> no <identifiersep> packets ; try { real <identifiersep> run ( ) ; } catch ( throwable t ) { <LOG> system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } } } <comment> <ect>
else handshake <identifiersep> peers = new array <identifiersep> list < peer <identifiersep> node > ( ) ; } if ( handshake <identifiersep> time < = lowest <identifiersep> handshake <identifiersep> time ) handshake <identifiersep> peers . add ( pn ) ; } long temp <identifiersep> now = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( temp <identifiersep> now - old <identifiersep> temp <identifiersep> now ) > seconds . to <identifiersep> millis ( <number_literal> ) ) <LOG> old <identifiersep> temp <identifiersep> now = temp <identifiersep> now ; } <comment> <ect>
} else if ( to <identifiersep> send <identifiersep> ack <identifiersep> only != null ) { try { if ( to <identifiersep> send <identifiersep> ack <identifiersep> only . maybe <identifiersep> send <identifiersep> packet ( now , true ) ) { <comment> <LOG> to <identifiersep> send <identifiersep> ack <identifiersep> only . force <identifiersep> disconnect ( ) ; } } <comment> <ect>
opennet <identifiersep> manager om = node . get <identifiersep> opennet ( ) ; if ( om != null && node . get <identifiersep> uptime ( ) > seconds . to <identifiersep> millis ( <number_literal> ) ) { opennet <identifiersep> peer <identifiersep> node [ ] peers = om . get <identifiersep> old <identifiersep> peers ( ) ; for ( opennet <identifiersep> peer <identifiersep> node pn : peers ) { long last <identifiersep> connected = pn . time <identifiersep> last <identifiersep> connected ( now ) ; if ( last <identifiersep> connected < = 0 ) <LOG> <comment> <ect>
if ( ( after <identifiersep> handshake <identifiersep> time - before <identifiersep> handshake <identifiersep> time ) > seconds . to <identifiersep> millis ( <number_literal> ) ) logger . error ( this , <string_literal> + ( after <identifiersep> handshake <identifiersep> time - before <identifiersep> handshake <identifiersep> time ) + <string_literal> + pn . user <identifiersep> to <identifiersep> string ( ) ) ; } } } long old <identifiersep> now = now ; <comment> <LOG> long sleep <identifiersep> time = next <identifiersep> action <identifiersep> time - now ; <comment> <ect>
wait ( sleep <identifiersep> time ) ; } } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> } } <comment> void wake <identifiersep> up ( ) { <comment> <ect>
public integer start ( string [ ] args ) { synchronized ( node <identifiersep> starter . class ) { if ( is <identifiersep> started ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; is <identifiersep> started = true ; is <identifiersep> testing <identifiersep> vm = false ; } if ( args . length > 1 ) { <LOG> return integer . value <identifiersep> of ( - 1 ) ; } string built <identifiersep> with <identifiersep> message = <string_literal> + ext <identifiersep> version . build <identifiersep> number + <string_literal> + ext <identifiersep> version . cvs <identifiersep> revision + <string_literal> + ext <identifiersep> build <identifiersep> number + <string_literal> + ext <identifiersep> revision <identifiersep> number ; logger . normal ( this , built <identifiersep> with <identifiersep> message ) ; system . out . println ( built <identifiersep> with <identifiersep> message ) ; file config <identifiersep> filename ; if ( args . length == 0 ) { <ect>
config <identifiersep> filename = new file ( args [ 0 ] ) ; <comment> <LOG> cfg = freenet <identifiersep> file <identifiersep> persistent <identifiersep> config . construct <identifiersep> freenet <identifiersep> file <identifiersep> persistent <identifiersep> config ( config <identifiersep> filename ) ; } catch ( io <identifiersep> exception e ) { system . out . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return integer . value <identifiersep> of ( - 1 ) ; } <comment> <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; return integer . value <identifiersep> of ( - 1 ) ; } <comment> <LOG> log <identifiersep> config <identifiersep> handler = new logging <identifiersep> config <identifiersep> handler ( logging <identifiersep> config , executor ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e ) { system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return integer . value <identifiersep> of ( - <number_literal> ) ; } system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; log <identifiersep> config <identifiersep> handler = new logging <identifiersep> config <identifiersep> handler ( logging <identifiersep> config , executor ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e ) { system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return integer . value <identifiersep> of ( - <number_literal> ) ; } <LOG> executor . start ( ) ; <comment> <ect>
<comment> <LOG> } catch ( node <identifiersep> init <identifiersep> exception e ) { system . err . println ( <string_literal> + e . exit <identifiersep> code + <string_literal> + e . get <identifiersep> message ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( e . exit <identifiersep> code ) ; } return null ; } <comment> <ect>
<comment> @ override public int stop ( int exit <identifiersep> code ) { <LOG> node . park ( ) ; <comment> <ect>
try { thread . sleep ( minutes . to <identifiersep> millis ( <number_literal> ) ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> } catch ( throwable t1 ) { <comment> <ect>
<string_literal> , <string_literal> , node <identifiersep> config ) ; <comment> <LOG> try { file <identifiersep> util . secure <identifiersep> delete <identifiersep> all ( old <identifiersep> temp ) ; } catch ( io <identifiersep> exception e ) { <comment> <ect>
} ) ; shutdown <identifiersep> hook . add <identifiersep> early <identifiersep> job ( new native <identifiersep> thread ( <string_literal> , native <identifiersep> thread . high <identifiersep> priority , true ) { @ override public void real <identifiersep> run ( ) { <LOG> client <identifiersep> layer <identifiersep> persister . shutdown ( ) ; } } ) ; shutdown <identifiersep> hook . add <identifiersep> late <identifiersep> job ( new native <identifiersep> thread ( <string_literal> , native <identifiersep> thread . high <identifiersep> priority , true ) { @ override <ect>
if ( status == request <identifiersep> sender . success ) <comment> <LOG> listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ) ; return ; case request <identifiersep> sender . data <identifiersep> not <identifiersep> found : listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found ) ) ; return ; case request <identifiersep> sender . recently <identifiersep> failed : <ect>
if ( rs . uid != uid ) tag . unlock <identifiersep> handler ( ) ; <comment> <LOG> listener . on <identifiersep> not <identifiersep> started ( true ) ; } catch ( error e ) { logger . error ( this , <string_literal> + e , e ) ; listener . on <identifiersep> not <identifiersep> started ( true ) ; } } public client <identifiersep> key <identifiersep> block real <identifiersep> get <identifiersep> key ( client <identifiersep> key key , boolean local <identifiersep> only , boolean ignore <identifiersep> store , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> get <identifiersep> exception { if ( key instanceof client <identifiersep> chk ) <ect>
<comment> client <identifiersep> chk <identifiersep> block real <identifiersep> get <identifiersep> chk ( client <identifiersep> chk key , boolean local <identifiersep> only , boolean ignore <identifiersep> store , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> get <identifiersep> exception { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; long uid = make <identifiersep> uid ( ) ; request <identifiersep> tag tag = new request <identifiersep> tag ( false , request <identifiersep> tag . start . local , null , real <identifiersep> time <identifiersep> flag , uid , node ) ; if ( ! tracker . lock <identifiersep> uid ( uid , false , false , false , true , real <identifiersep> time <identifiersep> flag , tag ) ) { <LOG> throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } tag . set <identifiersep> accepted ( ) ; request <identifiersep> sender rs = null ; try { object o = node . make <identifiersep> request <identifiersep> sender ( key . get <identifiersep> node <identifiersep> chk ( ) , node . max <identifiersep> htl ( ) , uid , tag , null , local <identifiersep> only , ignore <identifiersep> store , false , true , can <identifiersep> write <identifiersep> client <identifiersep> cache , real <identifiersep> time <identifiersep> flag ) ; if ( o instanceof chk <identifiersep> block ) <ect>
if ( status == request <identifiersep> sender . success ) { logger . minor ( this , <string_literal> + rtt ) ; } } if ( status == request <identifiersep> sender . success ) try { return new client <identifiersep> chk <identifiersep> block ( rs . get <identifiersep> prb ( ) . get <identifiersep> block ( ) , rs . get <identifiersep> headers ( ) , key , true ) ; } catch ( chk <identifiersep> verify <identifiersep> exception e ) { <LOG> throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . decode <identifiersep> failed ) ; } catch ( aborted <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } else { switch ( status ) { <ect>
} catch ( aborted <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } else { switch ( status ) { case request <identifiersep> sender . not <identifiersep> finished : <LOG> throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; case request <identifiersep> sender . data <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found ) ; case request <identifiersep> sender . recently <identifiersep> failed : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . recently <identifiersep> failed ) ; case request <identifiersep> sender . route <identifiersep> not <identifiersep> found : <ect>
tag . unlock <identifiersep> handler ( ) ; } } client <identifiersep> ssk <identifiersep> block real <identifiersep> get <identifiersep> ssk ( client <identifiersep> ssk key , boolean local <identifiersep> only , boolean ignore <identifiersep> store , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> get <identifiersep> exception { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; long uid = make <identifiersep> uid ( ) ; request <identifiersep> tag tag = new request <identifiersep> tag ( true , request <identifiersep> tag . start . local , null , real <identifiersep> time <identifiersep> flag , uid , node ) ; if ( ! tracker . lock <identifiersep> uid ( uid , true , false , false , true , real <identifiersep> time <identifiersep> flag , tag ) ) { <LOG> throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } tag . set <identifiersep> accepted ( ) ; request <identifiersep> sender rs = null ; try { object o = node . make <identifiersep> request <identifiersep> sender ( key . get <identifiersep> node <identifiersep> key ( true ) , node . max <identifiersep> htl ( ) , uid , tag , null , local <identifiersep> only , ignore <identifiersep> store , false , true , can <identifiersep> write <identifiersep> client <identifiersep> cache , real <identifiersep> time <identifiersep> flag ) ; if ( o instanceof ssk <identifiersep> block ) <ect>
if ( rs . get <identifiersep> status ( ) == request <identifiersep> sender . success ) try { ssk <identifiersep> block block = rs . get <identifiersep> ssk <identifiersep> block ( ) ; key . set <identifiersep> public <identifiersep> key ( block . get <identifiersep> pub <identifiersep> key ( ) ) ; return client <identifiersep> ssk <identifiersep> block . construct ( block , key ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { <LOG> throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . decode <identifiersep> failed ) ; } else switch ( rs . get <identifiersep> status ( ) ) { case request <identifiersep> sender . not <identifiersep> finished : logger . error ( this , <string_literal> + rs ) ; throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; <ect>
case request <identifiersep> sender . recently <identifiersep> failed : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . recently <identifiersep> failed ) ; case request <identifiersep> sender . route <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . route <identifiersep> not <identifiersep> found ) ; case request <identifiersep> sender . transfer <identifiersep> failed : case request <identifiersep> sender . get <identifiersep> offer <identifiersep> transfer <identifiersep> failed : <LOG> throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . transfer <identifiersep> failed ) ; case request <identifiersep> sender . verify <identifiersep> failure : case request <identifiersep> sender . get <identifiersep> offer <identifiersep> verify <identifiersep> failure : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . verify <identifiersep> failed ) ; case request <identifiersep> sender . generated <identifiersep> rejected <identifiersep> overload : case request <identifiersep> sender . timed <identifiersep> out : <ect>
byte [ ] headers = block . get <identifiersep> headers ( ) ; partially <identifiersep> received <identifiersep> block prb = new partially <identifiersep> received <identifiersep> block ( node . packets <identifiersep> in <identifiersep> block , node . packet <identifiersep> size , data ) ; chk <identifiersep> insert <identifiersep> sender is ; long uid = make <identifiersep> uid ( ) ; insert <identifiersep> tag tag = new insert <identifiersep> tag ( false , insert <identifiersep> tag . start . local , null , real <identifiersep> time <identifiersep> flag , uid , node ) ; if ( ! tracker . lock <identifiersep> uid ( uid , false , true , false , true , real <identifiersep> time <identifiersep> flag , tag ) ) { <LOG> throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; } tag . set <identifiersep> accepted ( ) ; try { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; is = node . make <identifiersep> insert <identifiersep> sender ( block . get <identifiersep> key ( ) , node . max <identifiersep> htl ( ) , uid , tag , null , headers , prb , false , can <identifiersep> write <identifiersep> client <identifiersep> cache , fork <identifiersep> on <identifiersep> cacheable , prefer <identifiersep> insert , ignore <identifiersep> low <identifiersep> backoff , real <identifiersep> time <identifiersep> flag ) ; <ect>
throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> not <identifiersep> found ) ; case chk <identifiersep> insert <identifiersep> sender . route <identifiersep> really <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> really <identifiersep> not <identifiersep> found ) ; case chk <identifiersep> insert <identifiersep> sender . internal <identifiersep> error : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; default : <LOG> throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; } } } finally { tag . unlock <identifiersep> handler ( ) ; } } public void real <identifiersep> put <identifiersep> ssk ( ssk <identifiersep> block block , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean fork <identifiersep> on <identifiersep> cacheable , boolean prefer <identifiersep> insert , boolean ignore <identifiersep> low <identifiersep> backoff , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> put <identifiersep> exception { ssk <identifiersep> insert <identifiersep> sender is ; long uid = make <identifiersep> uid ( ) ; <ect>
node . store <identifiersep> insert ( block , deep , false , can <identifiersep> write <identifiersep> client <identifiersep> cache , false ) ; } catch ( key <identifiersep> collision <identifiersep> exception e ) { low <identifiersep> level <identifiersep> put <identifiersep> exception failed = new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . collision ) ; node <identifiersep> ssk key = block . get <identifiersep> key ( ) ; key <identifiersep> block collided = node . fetch ( key , true , can <identifiersep> write <identifiersep> client <identifiersep> cache , false , false , null ) ; if ( collided == null ) { <LOG> <comment> <ect>
if ( is . get <identifiersep> status ( ) != ssk <identifiersep> insert <identifiersep> sender . route <identifiersep> not <identifiersep> found ) logger . error ( this , msg ) ; else logger . normal ( this , msg ) ; switch ( is . get <identifiersep> status ( ) ) { case ssk <identifiersep> insert <identifiersep> sender . not <identifiersep> finished : <LOG> throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; case ssk <identifiersep> insert <identifiersep> sender . generated <identifiersep> rejected <identifiersep> overload : case ssk <identifiersep> insert <identifiersep> sender . timed <identifiersep> out : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . rejected <identifiersep> overload ) ; case ssk <identifiersep> insert <identifiersep> sender . route <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> not <identifiersep> found ) ; <ect>
synchronized ( this ) { if ( download <identifiersep> allowed <identifiersep> everywhere ) return true ; if ( include <identifiersep> download <identifiersep> dir && file <identifiersep> util . is <identifiersep> parent ( get <identifiersep> downloads <identifiersep> dir ( ) , filename ) ) return true ; for ( file dir : download <identifiersep> allowed <identifiersep> dirs ) { if ( dir == null ) { <comment> <LOG> continue ; } if ( file <identifiersep> util . is <identifiersep> parent ( dir , filename ) ) return true ; } return false ; } } public synchronized boolean allow <identifiersep> upload <identifiersep> from ( file filename ) { if ( upload <identifiersep> allowed <identifiersep> everywhere ) return true ; for ( file dir : upload <identifiersep> allowed <identifiersep> dirs ) { <ect>
<comment> public abstract void on <identifiersep> success ( sendable <identifiersep> request <identifiersep> item key <identifiersep> num , client <identifiersep> key key , client <identifiersep> context context ) ; <comment> public abstract void on <identifiersep> failure ( low <identifiersep> level <identifiersep> put <identifiersep> exception e , sendable <identifiersep> request <identifiersep> item key <identifiersep> num , client <identifiersep> context context ) ; @ override public void internal <identifiersep> error ( throwable t , request <identifiersep> scheduler sched , client <identifiersep> context context , boolean persistent ) { <LOG> sched . call <identifiersep> failure ( this , new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error , t . get <identifiersep> message ( ) , t ) , native <identifiersep> thread . max <identifiersep> priority , persistent ) ; } @ override public final boolean is <identifiersep> insert ( ) { return true ; } @ override public client <identifiersep> request <identifiersep> scheduler get <identifiersep> scheduler ( client <identifiersep> context context ) { <ect>
@ override public void on <identifiersep> remove ( ) { long last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time = last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time ( ) ; if ( last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time < = 0 && time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) > 0 ) system . err . println ( this . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> ) ; else if ( time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) < = 0 ) <LOG> else system . err . println ( this . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> ) ; super . on <identifiersep> remove ( ) ; } public fate get <identifiersep> fate ( ) { long last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time = last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time ( ) ; if ( is <identifiersep> connected ( ) ) { <ect>
statuses = new hash <identifiersep> map < k , weak <identifiersep> hash <identifiersep> set < peer <identifiersep> node > > ( ) ; } public synchronized void add <identifiersep> status ( k peer <identifiersep> node <identifiersep> status , peer <identifiersep> node peer <identifiersep> node , boolean no <identifiersep> log ) { weak <identifiersep> hash <identifiersep> set < peer <identifiersep> node > status <identifiersep> set = statuses . get ( peer <identifiersep> node <identifiersep> status ) ; if ( status <identifiersep> set != null ) { if ( status <identifiersep> set . contains ( peer <identifiersep> node ) ) { if ( ! no <identifiersep> log ) <LOG> return ; } statuses . remove ( peer <identifiersep> node <identifiersep> status ) ; } else status <identifiersep> set = new weak <identifiersep> hash <identifiersep> set < peer <identifiersep> node > ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + peer <identifiersep> node . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + peer <identifiersep> node <identifiersep> status + <string_literal> ) ; <ect>
return true ; } else if ( spec == dmt . fnp <identifiersep> peer <identifiersep> load <identifiersep> status <identifiersep> byte || spec == dmt . fnp <identifiersep> peer <identifiersep> load <identifiersep> status <identifiersep> short || spec == dmt . fnp <identifiersep> peer <identifiersep> load <identifiersep> status <identifiersep> int ) { <comment> <LOG> if ( spec == dmt . fnpchk <identifiersep> data <identifiersep> request ) { reject <identifiersep> request ( m , node . node <identifiersep> stats . chk <identifiersep> request <identifiersep> ctr ) ; } else if ( spec == dmt . fnpssk <identifiersep> data <identifiersep> request ) { reject <identifiersep> request ( m , node . node <identifiersep> stats . ssk <identifiersep> request <identifiersep> ctr ) ; } else if ( spec == dmt . fnp <identifiersep> insert <identifiersep> request ) { reject <identifiersep> request ( m , node . node <identifiersep> stats . chk <identifiersep> insert <identifiersep> ctr ) ; <ect>
boolean remove = m . get <identifiersep> boolean ( dmt . remove ) ; if ( remove ) { node . peers . disconnect <identifiersep> and <identifiersep> remove ( source , false , false , false ) ; if ( source instanceof darknet <identifiersep> peer <identifiersep> node ) <comment> <LOG> } <comment> <ect>
if ( ! node . enable <identifiersep> routed <identifiersep> ping ( ) ) return true ; long id = m . get <identifiersep> long ( dmt . uid ) ; long lid = long . value <identifiersep> of ( id ) ; routed <identifiersep> context rc = routed <identifiersep> contexts . get ( lid ) ; if ( rc == null ) { <comment> <LOG> return false ; <comment> <ect>
if ( ! node . enable <identifiersep> routed <identifiersep> ping ( ) ) return true ; long id = m . get <identifiersep> long ( dmt . uid ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + m ) ; long lid = long . value <identifiersep> of ( id ) ; routed <identifiersep> context ctx = routed <identifiersep> contexts . get ( lid ) ; if ( ctx == null ) { <LOG> return false ; } peer <identifiersep> node pn = ctx . source ; if ( pn == null ) return false ; try { pn . send <identifiersep> async ( m . clone <identifiersep> and <identifiersep> drop <identifiersep> sub <identifiersep> messages ( ) , null , node <identifiersep> stats . routed <identifiersep> message <identifiersep> ctr ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + m . get <identifiersep> spec ( ) + <string_literal> + node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; <comment> <LOG> return true ; } } return true ; } } <comment> private message pre <identifiersep> forward ( message m , short new <identifiersep> htl ) { <ect>
system . err . println ( <string_literal> ) ; synchronized ( this ) { register <identifiersep> event ( status <identifiersep> loading ) ; started = true ; } connect <identifiersep> some <identifiersep> seednodes ( ) ; } else { <LOG> <comment> <ect>
private void connect <identifiersep> some <identifiersep> seednodes ( ) { if ( ! node . is <identifiersep> opennet <identifiersep> enabled ( ) ) return ; boolean announce <identifiersep> now = false ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; list < simple <identifiersep> field <identifiersep> set > seeds = announcer . read <identifiersep> seednodes ( node <identifiersep> file . seednodes . get <identifiersep> file ( node ) ) ; <LOG> long now = system . current <identifiersep> time <identifiersep> millis ( ) ; synchronized ( this ) { if ( now - time <identifiersep> added <identifiersep> seeds < min <identifiersep> added <identifiersep> seeds <identifiersep> interval ) return ; time <identifiersep> added <identifiersep> seeds = now ; if ( seeds . size ( ) == 0 ) { register <identifiersep> event ( status <identifiersep> no <identifiersep> seednodes ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + seed ) ; } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + seed ) ; } } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <LOG> continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; <ect>
logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { <LOG> continue ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + count ) ; return count ; <ect>
simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( br , false , false , true , false ) ; if ( ! fs . is <identifiersep> empty ( ) ) list . add ( fs ) ; } catch ( eof <identifiersep> exception e ) { return list ; } catch ( io <identifiersep> exception e ) { <LOG> <comment> <ect>
if ( killed <identifiersep> announcement <identifiersep> too <identifiersep> old ) return true ; } if ( node . peers . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> size ( peer <identifiersep> manager . peer <identifiersep> node <identifiersep> status <identifiersep> too <identifiersep> new , false ) > <number_literal> ) { synchronized ( this ) { if ( killed <identifiersep> announcement <identifiersep> too <identifiersep> old ) return true ; killed <identifiersep> announcement <identifiersep> too <identifiersep> old = true ; kill <identifiersep> announcement = true ; } <LOG> system . err . println ( <string_literal> ) ; if ( node . client <identifiersep> core != null ) node . client <identifiersep> core . alerts . register ( announcement <identifiersep> disabled <identifiersep> alert ) ; } } if ( kill <identifiersep> announcement ) { node . executor . execute ( new runnable ( ) { @ override <ect>
node . get <identifiersep> ticker ( ) . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { try { maybe <identifiersep> send <identifiersep> announcement ( ) ; } catch ( throwable t ) { <LOG> } } } , ( time <identifiersep> added <identifiersep> seeds + min <identifiersep> added <identifiersep> seeds <identifiersep> interval ) - now ) ; return ; } } connect <identifiersep> some <identifiersep> seednodes ( ) ; } private synchronized void add <identifiersep> announced <identifiersep> i <identifiersep> ps ( inet <identifiersep> address [ ] addrs ) { for ( inet <identifiersep> address addr : addrs ) announced <identifiersep> to <identifiersep> i <identifiersep> ps . add ( addr ) ; <ect>
@ override public void added <identifiersep> node ( peer <identifiersep> node pn ) { synchronized ( announcer . this ) { announcement <identifiersep> added <identifiersep> nodes ++ ; total <identifiersep> added ++ ; } logger . normal ( this , <string_literal> + seed . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + pn + <string_literal> + announcement <identifiersep> added <identifiersep> nodes + <string_literal> + total <identifiersep> added + <string_literal> ) ; <LOG> return ; } @ override public void bogus <identifiersep> noderef ( string reason ) { logger . normal ( this , <string_literal> + seed . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + reason , new exception ( <string_literal> ) ) ; } @ override public void completed ( ) { <ect>
<comment> <LOG> if ( announce <identifiersep> now ) maybe <identifiersep> send <identifiersep> announcement ( ) ; } @ override public void node <identifiersep> failed ( peer <identifiersep> node pn , string reason ) { logger . normal ( this , <string_literal> + pn . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + reason ) ; } @ override <ect>
return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + key ) ; } protected string l10n ( string key , string [ ] patterns , string [ ] values ) { return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + key , patterns , values ) ; } private string l10n ( string key , string pattern , string value ) { return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + key , pattern , value ) ; } public void reannounce ( ) { <LOG> maybe <identifiersep> send <identifiersep> announcement <identifiersep> off <identifiersep> thread ( ) ; } public boolean is <identifiersep> waiting <identifiersep> for <identifiersep> updater ( ) { synchronized ( this ) { return killed <identifiersep> announcement <identifiersep> too <identifiersep> old ; } } } <ect>
int opennet <identifiersep> conns = node . peers . count <identifiersep> connected <identifiersep> opennet <identifiersep> peers ( ) ; system . err . println ( <string_literal> + seconds + <string_literal> + seeds + <string_literal> + seed <identifiersep> conns + <string_literal> + opennet <identifiersep> peers + <string_literal> + opennet <identifiersep> conns ) ; seconds ++ ; if ( opennet <identifiersep> conns >= target <identifiersep> peers ) { long time <identifiersep> taken = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ; <LOG> node . park ( ) ; system . exit ( 0 ) ; } } system . err . println ( <string_literal> + target <identifiersep> peers + <string_literal> ) ; node . park ( ) ; system . exit ( exit <identifiersep> failed <identifiersep> target ) ; } catch ( throwable t ) { <ect>
int no <identifiersep> swaps = location <identifiersep> manager . no <identifiersep> swaps ; system . err . println ( <string_literal> + ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ; system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <string_literal> + ( double ) no <identifiersep> swaps / ( double ) new <identifiersep> swaps + <string_literal> + ( ( total <identifiersep> started * <number_literal> ) - ( no <identifiersep> swaps + new <identifiersep> swaps ) ) ) ; system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; <ect>
system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <string_literal> + ( double ) no <identifiersep> swaps / ( double ) new <identifiersep> swaps + <string_literal> + ( ( total <identifiersep> started * <number_literal> ) - ( no <identifiersep> swaps + new <identifiersep> swaps ) ) ) ; system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; double total <identifiersep> swap <identifiersep> time = 0 . 0 ; for ( int i = 0 ; i < nodes . length ; i ++ ) { <ect>
system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; double total <identifiersep> swap <identifiersep> time = 0 . 0 ; for ( int i = 0 ; i < nodes . length ; i ++ ) { total <identifiersep> swap <identifiersep> interval += nodes [ i ] . lm . get <identifiersep> send <identifiersep> swap <identifiersep> interval ( ) ; total <identifiersep> swap <identifiersep> time += nodes [ i ] . lm . get <identifiersep> average <identifiersep> swap <identifiersep> time ( ) ; <ect>
system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; double total <identifiersep> swap <identifiersep> time = 0 . 0 ; for ( int i = 0 ; i < nodes . length ; i ++ ) { total <identifiersep> swap <identifiersep> interval += nodes [ i ] . lm . get <identifiersep> send <identifiersep> swap <identifiersep> interval ( ) ; total <identifiersep> swap <identifiersep> time += nodes [ i ] . lm . get <identifiersep> average <identifiersep> swap <identifiersep> time ( ) ; } <LOG> system . err . println ( <string_literal> + ( total <identifiersep> swap <identifiersep> interval / nodes . length ) ) ; wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; last <identifiersep> swaps = new <identifiersep> swaps ; <comment> <ect>
pings ++ ; if ( hops <identifiersep> taken < 0 ) { failures ++ ; avg . report ( 0 . 0 ) ; avg2 . report ( 0 . 0 ) ; double ratio = ( double ) successes / ( ( double ) ( failures + successes ) ) ; <LOG> } else { total <identifiersep> hops <identifiersep> taken += hops <identifiersep> taken ; successes ++ ; avg . report ( 1 . 0 ) ; avg2 . report ( 1 . 0 ) ; double ratio = ( double ) successes / ( ( double ) ( failures + successes ) ) ; <ect>
successes ++ ; avg . report ( 1 . 0 ) ; avg2 . report ( 1 . 0 ) ; double ratio = ( double ) successes / ( ( double ) ( failures + successes ) ) ; system . err . println ( <string_literal> + pings + <string_literal> + hops <identifiersep> taken + ' ' + random <identifiersep> node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + random <identifiersep> node2 . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + ratio + <string_literal> + avg . current <identifiersep> value ( ) + <string_literal> + avg2 . current <identifiersep> value ( ) + ' ) ' ) ; } } catch ( throwable t ) { <LOG> } } system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; <ect>
system . err . println ( <string_literal> + pings + <string_literal> + hops <identifiersep> taken + ' ' + random <identifiersep> node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + random <identifiersep> node2 . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + ratio + <string_literal> + avg . current <identifiersep> value ( ) + <string_literal> + avg2 . current <identifiersep> value ( ) + ' ) ' ) ; } } catch ( throwable t ) { logger . error ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + t , t ) ; } } system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; <LOG> system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; <ect>
system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; <LOG> system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; <ect>
system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; <ect>
system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; return ; } } system . exit ( exit <identifiersep> ping <identifiersep> target <identifiersep> not <identifiersep> reached ) ; <ect>
system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; return ; } } system . exit ( exit <identifiersep> ping <identifiersep> target <identifiersep> not <identifiersep> reached ) ; } } <ect>
system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; <LOG> return ; } } system . exit ( exit <identifiersep> ping <identifiersep> target <identifiersep> not <identifiersep> reached ) ; } } <ect>
while ( true ) { logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> + ping <identifiersep> id ) ; boolean success ; try { success = pn . ping ( ping <identifiersep> id ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { <LOG> continue ; } if ( success ) logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> + ping <identifiersep> id + <string_literal> ) ; else logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> + ping <identifiersep> id ) ; try { <ect>
} catch ( not <identifiersep> connected <identifiersep> exception e1 ) { logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> ) ; continue ; } if ( success ) logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> + ping <identifiersep> id + <string_literal> ) ; else <LOG> try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
if ( args . length < 1 || args . length > <number_literal> ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; boolean dump <identifiersep> only = args . length == <number_literal> && <string_literal> . equals <identifiersep> ignore <identifiersep> case ( args [ 1 ] ) ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( ) ; <LOG> csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; <ect>
final file dir = new file ( <string_literal> + uid ) ; if ( ! dump <identifiersep> only ) { file <identifiersep> util . remove <identifiersep> all ( dir ) ; random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . error , <string_literal> , false ) ; file seednodes = new file ( <string_literal> ) ; if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { <LOG> system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } final file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port1 ) ) ; inner <identifiersep> dir . mkdir ( ) ; fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; fis . close ( ) ; <ect>
system . err . println ( <string_literal> + successes ) ; else system . err . println ( <string_literal> + successes ) ; uri = null ; <comment> <LOG> uri = null ; block = new insert <identifiersep> block ( mhks [ i ] , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri this <identifiersep> uri = client . insert ( block , false , null ) ; uri = this <identifiersep> uri ; <ect>
csv <identifiersep> line . add ( uri . to <identifiersep> ascii <identifiersep> string ( ) ) ; successes ++ ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; <LOG> } } if ( successes == <number_literal> ) system . err . println ( <string_literal> + successes ) ; else if ( successes != 0 ) system . err . println ( <string_literal> + successes ) ; else system . err . println ( <string_literal> + successes ) ; <ect>
csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + e + <string_literal> + i ) ; } } if ( successes == <number_literal> ) system . err . println ( <string_literal> + successes ) ; else if ( successes != 0 ) <LOG> else system . err . println ( <string_literal> + successes ) ; uri = null ; } <comment> <ect>
int lines <identifiersep> too <identifiersep> short = 0 , lines <identifiersep> broken = 0 , lines <identifiersep> no <identifiersep> number = 0 , lines <identifiersep> no <identifiersep> url = 0 , lines <identifiersep> no <identifiersep> fetch = 0 ; int total = 0 , single <identifiersep> keys <identifiersep> succeeded = 0 , mhk <identifiersep> succeeded = 0 ; int total <identifiersep> single <identifiersep> key <identifiersep> fetches = 0 , total <identifiersep> single <identifiersep> key <identifiersep> successes = 0 ; while ( ( line = br . read <identifiersep> line ( ) ) != null ) { single <identifiersep> uri = null ; for ( int i = 0 ; i < mhk <identifiersep> ur <identifiersep> is . length ; i ++ ) mhk <identifiersep> ur <identifiersep> is [ i ] = null ; <LOG> string [ ] split = line . split ( <string_literal> ) ; date date = date <identifiersep> format . parse ( split [ 0 ] ) ; gregorian <identifiersep> calendar calendar = new gregorian <identifiersep> calendar ( time <identifiersep> zone . get <identifiersep> time <identifiersep> zone ( <string_literal> ) ) ; calendar . set <identifiersep> time ( date ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; gregorian <identifiersep> calendar target = ( gregorian <identifiersep> calendar ) today . clone ( ) ; <ect>
target . get <identifiersep> time ( ) ; try { if ( split . length < <number_literal> ) { lines <identifiersep> too <identifiersep> short ++ ; continue ; } int seed <identifiersep> time = integer . parse <identifiersep> int ( split [ <number_literal> ] ) ; <LOG> int token = <number_literal> ; if ( split . length < <number_literal> ) { lines <identifiersep> too <identifiersep> short ++ ; continue ; } for ( int i = 0 ; i < <number_literal> ; i ++ ) { int insert <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; <ect>
token ++ ; freenet <identifiersep> uri this <identifiersep> uri = new freenet <identifiersep> uri ( split [ token ] ) ; if ( single <identifiersep> uri == null ) single <identifiersep> uri = this <identifiersep> uri ; else { if ( ! single <identifiersep> uri . equals ( this <identifiersep> uri ) ) { <LOG> lines <identifiersep> broken ++ ; continue ; } } token ++ ; } system . out . println ( <string_literal> + single <identifiersep> uri ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { int insert <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; <ect>
system . out . println ( <string_literal> + single <identifiersep> uri ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { int insert <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; token ++ ; mhk <identifiersep> ur <identifiersep> is [ i ] = new freenet <identifiersep> uri ( split [ token ] ) ; token ++ ; <LOG> } } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; lines <identifiersep> no <identifiersep> number ++ ; continue ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; <ect>
system . out . println ( <string_literal> + i + <string_literal> + mhk <identifiersep> ur <identifiersep> is [ i ] + <string_literal> + insert <identifiersep> time ) ; } } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; lines <identifiersep> no <identifiersep> number ++ ; continue ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <LOG> lines <identifiersep> no <identifiersep> url ++ ; continue ; } if ( math . abs ( target . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) - calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ) < hours . to <identifiersep> millis ( <number_literal> ) ) { system . out . println ( <string_literal> + date <identifiersep> format . format ( target . get <identifiersep> time ( ) ) + <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + split [ 1 ] ) ; match = true ; <ect>
} catch ( malformed <identifiersep> url <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; lines <identifiersep> no <identifiersep> url ++ ; continue ; } if ( math . abs ( target . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) - calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ) < hours . to <identifiersep> millis ( <number_literal> ) ) { system . out . println ( <string_literal> + date <identifiersep> format . format ( target . get <identifiersep> time ( ) ) + <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; <LOG> match = true ; break ; } else if ( split . length > <number_literal> + <number_literal> + <number_literal> ) { int token = <number_literal> + <number_literal> + <number_literal> ; int single <identifiersep> key <identifiersep> fetch <identifiersep> time = - 1 ; boolean single <identifiersep> key <identifiersep> success = false ; <ect>
if ( ! single <identifiersep> key <identifiersep> success ) { try { single <identifiersep> key <identifiersep> fetch <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; single <identifiersep> key <identifiersep> success = true ; system . out . println ( <string_literal> + i + <string_literal> + date + <string_literal> + single <identifiersep> key <identifiersep> fetch <identifiersep> time + <string_literal> ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> single <identifiersep> key <identifiersep> fetch <identifiersep> time = - 1 ; } } <comment> <ect>
try { mhk <identifiersep> fetch <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; mhk <identifiersep> success = true ; total <identifiersep> single <identifiersep> key <identifiersep> successes ++ ; system . out . println ( <string_literal> + i + <string_literal> + date + <string_literal> + mhk <identifiersep> fetch <identifiersep> time + <string_literal> ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> } token ++ ; } total ++ ; if ( single <identifiersep> key <identifiersep> success ) single <identifiersep> keys <identifiersep> succeeded ++ ; if ( mhk <identifiersep> success ) mhk <identifiersep> succeeded ++ ; <ect>
if ( single <identifiersep> key <identifiersep> success ) single <identifiersep> keys <identifiersep> succeeded ++ ; if ( mhk <identifiersep> success ) mhk <identifiersep> succeeded ++ ; } else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + lines <identifiersep> too <identifiersep> short + <string_literal> + lines <identifiersep> broken + <string_literal> + lines <identifiersep> no <identifiersep> number + <string_literal> + lines <identifiersep> no <identifiersep> url + <string_literal> + lines <identifiersep> no <identifiersep> fetch ) ; <LOG> system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; <ect>
if ( mhk <identifiersep> success ) mhk <identifiersep> succeeded ++ ; } else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + lines <identifiersep> too <identifiersep> short + <string_literal> + lines <identifiersep> broken + <string_literal> + lines <identifiersep> no <identifiersep> number + <string_literal> + lines <identifiersep> no <identifiersep> url + <string_literal> + lines <identifiersep> no <identifiersep> fetch ) ; system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; <LOG> system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; system . out . println ( <string_literal> + ( ( double ) mhk <identifiersep> succeeded ) / ( ( double ) total ) ) ; fis . close ( ) ; <ect>
} else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + lines <identifiersep> too <identifiersep> short + <string_literal> + lines <identifiersep> broken + <string_literal> + lines <identifiersep> no <identifiersep> number + <string_literal> + lines <identifiersep> no <identifiersep> url + <string_literal> + lines <identifiersep> no <identifiersep> fetch ) ; system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; <LOG> system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; system . out . println ( <string_literal> + ( ( double ) mhk <identifiersep> succeeded ) / ( ( double ) total ) ) ; fis . close ( ) ; fis = null ; <comment> <ect>
system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; <LOG> system . out . println ( <string_literal> + ( ( double ) mhk <identifiersep> succeeded ) / ( ( double ) total ) ) ; fis . close ( ) ; fis = null ; <comment> <ect>
csv <identifiersep> line . add ( <string_literal> ) ; continue ; } try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( single <identifiersep> uri ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; fetched = true ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
node . start ( true ) ; long t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ! test <identifiersep> util . wait <identifiersep> for <identifiersep> nodes ( node ) ) { exit <identifiersep> code = exit <identifiersep> failed <identifiersep> target ; return ; } long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <ect>
} ) ; try { insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , uri ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . insert ( block , false , null ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( <string_literal> ) ; } data . free ( ) ; } node . park ( ) ; <ect>
<comment> <LOG> try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + i + <string_literal> + ( t2 - t1 ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <ect>
buffered <identifiersep> reader br = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( fis , encoding ) ) ; string line = null ; calendar prev <identifiersep> date = null ; tree <identifiersep> map < gregorian <identifiersep> calendar , dump <identifiersep> element > map = new tree <identifiersep> map < gregorian <identifiersep> calendar , dump <identifiersep> element > ( ) ; while ( ( line = br . read <identifiersep> line ( ) ) != null ) { dump <identifiersep> element element ; <LOG> string [ ] split = line . split ( <string_literal> ) ; date date = date <identifiersep> format . parse ( split [ 0 ] ) ; gregorian <identifiersep> calendar calendar = new gregorian <identifiersep> calendar ( time <identifiersep> zone . get <identifiersep> time <identifiersep> zone ( <string_literal> ) ) ; calendar . set <identifiersep> time ( date ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; if ( prev <identifiersep> date != null ) { <ect>
calendar . set <identifiersep> time ( date ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; if ( prev <identifiersep> date != null ) { long now = calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ; long prev = prev <identifiersep> date . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ; long dist = days . convert ( now - prev , milliseconds ) ; <LOG> } prev <identifiersep> date = calendar ; int version = integer . parse <identifiersep> int ( split [ 1 ] ) ; if ( split . length > <number_literal> ) { int [ ] push <identifiersep> times = new int [ max <identifiersep> n + 1 ] ; string [ ] push <identifiersep> failures = new string [ max <identifiersep> n + 1 ] ; for ( int i = 0 ; i < = max <identifiersep> n ; i ++ ) { <ect>
for ( entry < gregorian <identifiersep> calendar , dump <identifiersep> element > entry : map . entry <identifiersep> set ( ) ) { gregorian <identifiersep> calendar date = entry . get <identifiersep> key ( ) ; dump <identifiersep> element element = entry . get <identifiersep> value ( ) ; if ( element . pull <identifiersep> times != null ) { date = ( gregorian <identifiersep> calendar ) date . clone ( ) ; date . add ( calendar . day <identifiersep> of <identifiersep> month , - delta ) ; <LOG> dump <identifiersep> element inserted = map . get ( date ) ; if ( inserted == null ) { system . out . println ( <string_literal> ) ; no <identifiersep> match ++ ; continue ; } if ( inserted . push <identifiersep> times == null || inserted . push <identifiersep> times [ i ] == 0 ) { <ect>
dump <identifiersep> element inserted = map . get ( date ) ; if ( inserted == null ) { system . out . println ( <string_literal> ) ; no <identifiersep> match ++ ; continue ; } if ( inserted . push <identifiersep> times == null || inserted . push <identifiersep> times [ i ] == 0 ) { <LOG> if ( element . pull <identifiersep> times [ i ] != 0 ) { system . err . println ( <string_literal> + element . pull <identifiersep> times [ i ] ) ; } insert <identifiersep> failure ++ ; } if ( element . pull <identifiersep> times [ i ] == 0 ) { string failure <identifiersep> mode = element . pull <identifiersep> failures [ i ] ; integer count = failure <identifiersep> modes . get ( failure <identifiersep> mode ) ; <ect>
else failure <identifiersep> modes . put ( failure <identifiersep> mode , count + 1 ) ; failures ++ ; } else { successes ++ ; success <identifiersep> time += element . pull <identifiersep> times [ i ] ; } } } <LOG> if ( successes != 0 ) system . out . println ( <string_literal> + ( success <identifiersep> time / successes ) ) ; system . out . println ( <string_literal> + failures ) ; for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; system . out . println ( <string_literal> + no <identifiersep> match ) ; system . out . println ( <string_literal> + insert <identifiersep> failure ) ; <ect>
failures ++ ; } else { successes ++ ; success <identifiersep> time += element . pull <identifiersep> times [ i ] ; } } } system . out . println ( <string_literal> + successes ) ; if ( successes != 0 ) system . out . println ( <string_literal> + ( success <identifiersep> time / successes ) ) ; <LOG> for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; system . out . println ( <string_literal> + no <identifiersep> match ) ; system . out . println ( <string_literal> + insert <identifiersep> failure ) ; double psuccess = ( successes * 1 . 0 / ( 1 . 0 * ( successes + failures ) ) ) ; system . out . println ( <string_literal> + delta + <string_literal> + psuccess + <string_literal> + ( successes + failures ) + <string_literal> ) ; <ect>
success <identifiersep> time += element . pull <identifiersep> times [ i ] ; } } } system . out . println ( <string_literal> + successes ) ; if ( successes != 0 ) system . out . println ( <string_literal> + ( success <identifiersep> time / successes ) ) ; system . out . println ( <string_literal> + failures ) ; for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; <LOG> system . out . println ( <string_literal> + insert <identifiersep> failure ) ; double psuccess = ( successes * 1 . 0 / ( 1 . 0 * ( successes + failures ) ) ) ; system . out . println ( <string_literal> + delta + <string_literal> + psuccess + <string_literal> + ( successes + failures ) + <string_literal> ) ; if ( delta != 0 ) { double half <identifiersep> life <identifiersep> estimate = - 1 * math . log ( <number_literal> ) / ( math . log ( psuccess ) / delta ) ; system . out . println ( <string_literal> + half <identifiersep> life <identifiersep> estimate + <string_literal> ) ; <ect>
system . out . println ( <string_literal> + failures ) ; for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; system . out . println ( <string_literal> + no <identifiersep> match ) ; system . out . println ( <string_literal> + insert <identifiersep> failure ) ; double psuccess = ( successes * 1 . 0 / ( 1 . 0 * ( successes + failures ) ) ) ; <LOG> if ( delta != 0 ) { double half <identifiersep> life <identifiersep> estimate = - 1 * math . log ( <number_literal> ) / ( math . log ( psuccess ) / delta ) ; system . out . println ( <string_literal> + half <identifiersep> life <identifiersep> estimate + <string_literal> ) ; } system . out . println ( ) ; } } static class dump <identifiersep> element { public dump <identifiersep> element ( gregorian <identifiersep> calendar date , int version ) { <ect>
private static final int opennet <identifiersep> port1 = <number_literal> ; private static final int darknet <identifiersep> port2 = <number_literal> ; private static final int opennet <identifiersep> port2 = <number_literal> ; private static final int max <identifiersep> n = <number_literal> ; public static void main ( string [ ] args ) { if ( args . length != 1 ) { <LOG> system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) ) ; <ect>
system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; try { final file dir = new file ( <string_literal> + uid ) ; <ect>
node . start ( true ) ; long t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ! test <identifiersep> util . wait <identifiersep> for <identifiersep> nodes ( node ) ) { exit <identifiersep> code = exit <identifiersep> failed <identifiersep> target ; return ; } long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <ect>
system . out . println ( <string_literal> + uri ) ; try { insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , uri ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . insert ( block , false , null ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( <string_literal> ) ; } data . free ( ) ; node . park ( ) ; <ect>
<comment> <LOG> try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + i + <string_literal> + ( t2 - t1 ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <ect>
for ( int i = 0 ; i < number <identifiersep> of <identifiersep> nodes * <number_literal> ; i ++ ) { if ( i % number <identifiersep> of <identifiersep> nodes == 0 ) logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , string . value <identifiersep> of ( i ) ) ; int length = ( int ) math . pow ( number <identifiersep> of <identifiersep> nodes , random . next <identifiersep> double ( ) ) ; int node <identifiersep> a = random . next <identifiersep> int ( number <identifiersep> of <identifiersep> nodes ) ; int node <identifiersep> b = ( node <identifiersep> a + length ) %number <identifiersep> of <identifiersep> nodes ; <LOG> node a = nodes [ node <identifiersep> a ] ; node b = nodes [ node <identifiersep> b ] ; a . connect ( b , trust , visibility ) ; b . connect ( a , trust , visibility ) ; } logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> ) ; for ( node node : nodes ) <ect>
insert <identifiersep> key = fetch <identifiersep> key = block . get <identifiersep> client <identifiersep> key ( ) ; test <identifiersep> key = insert <identifiersep> key . get <identifiersep> uri ( ) ; } final key node <identifiersep> key = fetch <identifiersep> key . get <identifiersep> node <identifiersep> key ( false ) ; system . err . println ( ) ; system . err . println ( <string_literal> + test <identifiersep> key + <string_literal> + node <identifiersep> key ) ; system . err . println ( ) ; <LOG> wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; <comment> <ect>
for ( node node : nodes ) { node . set <identifiersep> dispatcher <identifiersep> hook ( cb ) ; } for ( int i = 0 ; i < nodes . length ; i ++ ) { system . out . println ( <string_literal> + i ) ; try { nodes [ i%nodes . length ] . client <identifiersep> core . real <identifiersep> get <identifiersep> key ( fetch <identifiersep> key , false , false , false , real <identifiersep> time <identifiersep> flag ) ; <LOG> system . exit ( exit <identifiersep> key <identifiersep> exists ) ; } catch ( low <identifiersep> level <identifiersep> get <identifiersep> exception e ) { switch ( e . code ) { case low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found : case low <identifiersep> level <identifiersep> get <identifiersep> exception . route <identifiersep> not <identifiersep> found : <comment> <ect>
case low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found : case low <identifiersep> level <identifiersep> get <identifiersep> exception . route <identifiersep> not <identifiersep> found : <comment> <LOG> continue ; default : system . err . println ( <string_literal> + i%nodes . length + <string_literal> + e . to <identifiersep> string ( ) ) ; system . exit ( exit <identifiersep> unknown <identifiersep> error <identifiersep> checking <identifiersep> key <identifiersep> not <identifiersep> exist ) ; } } } <comment> <ect>
for ( int i = 0 ; i < visited . length ; i ++ ) { if ( ! visited [ i ] ) continue ; visited <identifiersep> count ++ ; if ( ! first ) sb . append ( ' ' ) ; first = false ; sb . append ( i ) ; } <LOG> <comment> <ect>
if ( node . has <identifiersep> key ( fetch <identifiersep> key . get <identifiersep> node <identifiersep> key ( false ) , true , true ) ) count ++ ; } system . err . println ( <string_literal> + x + <string_literal> + count + ' / ' + nodes . length + <string_literal> + successful <identifiersep> tests + <string_literal> ) ; logger . normal ( real <identifiersep> node <identifiersep> ulpr <identifiersep> test . class , <string_literal> + x + <string_literal> + count + ' / ' + nodes . length + <string_literal> + successful <identifiersep> tests + <string_literal> ) ; if ( x > <number_literal> ) { system . err . println ( ) ; <LOG> system . exit ( exit <identifiersep> test <identifiersep> failed ) ; } if ( count == nodes . length ) { successful <identifiersep> tests ++ ; long t <identifiersep> end = system . current <identifiersep> time <identifiersep> millis ( ) ; long propagation <identifiersep> time = t <identifiersep> end - t <identifiersep> start ; system . err . println ( <string_literal> + successful <identifiersep> tests + <string_literal> + propagation <identifiersep> time + <string_literal> ) ; <ect>
if ( count == nodes . length ) { successful <identifiersep> tests ++ ; long t <identifiersep> end = system . current <identifiersep> time <identifiersep> millis ( ) ; long propagation <identifiersep> time = t <identifiersep> end - t <identifiersep> start ; system . err . println ( <string_literal> + successful <identifiersep> tests + <string_literal> + propagation <identifiersep> time + <string_literal> ) ; total <identifiersep> propagation <identifiersep> time += propagation <identifiersep> time ; <LOG> system . err . println ( ) ; break ; } if ( x % nodes . length == 0 ) { system . err . print ( <string_literal> ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) if ( nodes [ i ] . has <identifiersep> key ( fetch <identifiersep> key . get <identifiersep> node <identifiersep> key ( false ) , true , true ) ) { <ect>
number <identifiersep> of <identifiersep> nodes <identifiersep> in <identifiersep> the <identifiersep> file ++ ; seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode = node . create <identifiersep> new <identifiersep> seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node ( sfs ) ; try { node . connect <identifiersep> to <identifiersep> seednode ( seednode ) ; seed <identifiersep> nodes . add ( seednode ) ; } catch ( exception fse ) { <LOG> } } <comment> <ect>
node . start ( true ) ; <comment> <LOG> thread . sleep ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; int ping <identifiersep> id = 0 ; long deadline = system . current <identifiersep> time <identifiersep> millis ( ) + minutes . to <identifiersep> millis ( <number_literal> ) ; while ( system . current <identifiersep> time <identifiersep> millis ( ) < deadline ) { int count <identifiersep> connected <identifiersep> seednodes = 0 ; for ( seed <identifiersep> server <identifiersep> peer <identifiersep> node seednode : node . peers . get <identifiersep> connected <identifiersep> seed <identifiersep> server <identifiersep> peers <identifiersep> vector ( null ) ) { <ect>
<string_literal> + seednode . get <identifiersep> uptime ( ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( time <identifiersep> delta ) ) ; <comment> <LOG> } } map < fate , integer > totals = new enum <identifiersep> map < fate , integer > ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node . fate . class ) ; for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { fate fate = seednode . get <identifiersep> fate ( ) ; integer x = totals . get ( fate ) ; if ( x == null ) totals . put ( fate , 1 ) ; <ect>
integer x = totals . get ( fate ) ; if ( x == null ) totals . put ( fate , 1 ) ; else totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } <LOG> for ( entry < fate , integer > fate <identifiersep> entry : totals . entry <identifiersep> set ( ) ) { system . out . println ( fate <identifiersep> entry . get <identifiersep> key ( ) + <string_literal> + fate <identifiersep> entry . get <identifiersep> value ( ) ) ; } system . out . println ( <string_literal> + node . peers . count <identifiersep> connected <identifiersep> peers ( ) + <string_literal> + count <identifiersep> connected <identifiersep> seednodes + ' / ' + node . peers . count <identifiersep> seednodes ( ) ) ; thread . sleep ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; } map < fate , integer > totals = new enum <identifiersep> map < fate , integer > ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node . fate . class ) ; for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { <ect>
else totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } system . out . println ( <string_literal> ) ; for ( entry < fate , integer > fate <identifiersep> entry : totals . entry <identifiersep> set ( ) ) { system . out . println ( fate <identifiersep> entry . get <identifiersep> key ( ) + <string_literal> + fate <identifiersep> entry . get <identifiersep> value ( ) ) ; } <LOG> thread . sleep ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; } map < fate , integer > totals = new enum <identifiersep> map < fate , integer > ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node . fate . class ) ; for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { fate fate = seednode . get <identifiersep> fate ( ) ; integer x = totals . get ( fate ) ; if ( x == null ) <ect>
integer x = totals . get ( fate ) ; if ( x == null ) totals . put ( fate , 1 ) ; else totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } <LOG> for ( fate fate : totals . key <identifiersep> set ( ) ) { system . out . println ( <string_literal> + fate + <string_literal> + totals . get ( fate ) ) ; } system . out . println ( <string_literal> ) ; <comment> <ect>
else totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } system . out . println ( <string_literal> ) ; for ( fate fate : totals . key <identifiersep> set ( ) ) { system . out . println ( <string_literal> + fate + <string_literal> + totals . get ( fate ) ) ; } <LOG> <comment> <ect>
long count <identifiersep> since = write <identifiersep> time - count <identifiersep> successes <identifiersep> period ; do { line = br . read <identifiersep> line ( ) ; if ( line == null ) break ; string [ ] results = line . split ( <string_literal> ) ; if ( results . length != <number_literal> ) { <LOG> continue ; } long time = long . parse <identifiersep> long ( results [ 0 ] ) ; fate fate = fate . value <identifiersep> of ( results [ <number_literal> ] ) ; if ( first <identifiersep> sample == 0 ) first <identifiersep> sample = time ; if ( fate == fate . connected <identifiersep> success ) { if ( time >= count <identifiersep> since ) <ect>
if ( time >= count <identifiersep> since ) failures ++ ; } } while ( line != null ) ; br . close ( ) ; if ( first <identifiersep> sample < count <identifiersep> since && successes == 0 ) system . err . println ( <string_literal> + peer . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + ( last <identifiersep> success > 0 ? time <identifiersep> util . format <identifiersep> time ( write <identifiersep> time - last <identifiersep> success ) : <string_literal> ) ) ; <LOG> } node . park ( ) ; system . exit ( 0 ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; try { <ect>
try { random <identifiersep> node . client <identifiersep> core . real <identifiersep> put ( block , false , fork <identifiersep> on <identifiersep> cacheable , false , false , real <identifiersep> time <identifiersep> flag ) ; logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + node1 ) ; logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + fields . hash <identifiersep> code ( enc <identifiersep> data ) + <string_literal> + fields . hash <identifiersep> code ( enc <identifiersep> headers ) ) ; } catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + put <identifiersep> ex ) ; <LOG> system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } } <comment> <ect>
system . err . println ( <string_literal> + i + <string_literal> + insert <identifiersep> keys ) ; for ( int j = 0 ; j < nodes . length ; j ++ ) { clients [ j ] . prefetch ( key . get <identifiersep> uri ( ) , days . to <identifiersep> millis ( 1 ) , <number_literal> , null ) ; } long total <identifiersep> running <identifiersep> requests = 0 ; for ( int j = 0 ; j < nodes . length ; j ++ ) { total <identifiersep> running <identifiersep> requests += nodes [ j ] . client <identifiersep> core . count <identifiersep> queued <identifiersep> requests ( ) ; } <LOG> } <comment> <ect>
public static final int darknet <identifiersep> port <identifiersep> base = <number_literal> ; public static final int darknet <identifiersep> port <identifiersep> end = darknet <identifiersep> port <identifiersep> base + number <identifiersep> of <identifiersep> nodes ; public static void main ( string [ ] args ) throws fs <identifiersep> parse <identifiersep> exception , peer <identifiersep> parse <identifiersep> exception , chk <identifiersep> encode <identifiersep> exception , invalid <identifiersep> threshold <identifiersep> exception , node <identifiersep> init <identifiersep> exception , reference <identifiersep> signature <identifiersep> verification <identifiersep> exception , interrupted <identifiersep> exception { string name = <string_literal> ; file wd = new file ( name ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { <LOG> system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } wd . mkdir ( ) ; <comment> <ect>
logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + i ) ; } <comment> <LOG> } wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; wait <identifiersep> for <identifiersep> ping <identifiersep> average ( 0 . <number_literal> , nodes , new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) , max <identifiersep> pings , <number_literal> ) ; random = new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( ) ; <ect>
try { wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; int status = tester . insert <identifiersep> request <identifiersep> test ( ) ; if ( status == - 1 ) continue ; system . exit ( status ) ; } catch ( throwable t ) { <LOG> } } } public real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test ( node [ ] nodes , dummy <identifiersep> random <identifiersep> source random , int target <identifiersep> successes ) { this . nodes = nodes ; this . random = random ; this . target <identifiersep> successes = target <identifiersep> successes ; } private final node [ ] nodes ; private final random <identifiersep> source random ; <ect>
block = ( ( insertable <identifiersep> client <identifiersep> ssk ) insert <identifiersep> key ) . encode ( new array <identifiersep> bucket ( buf ) , false , false , ( short ) - 1 , buf . length , random , compressor <identifiersep> type . default <identifiersep> compressordescriptor , false ) ; } else { block = client <identifiersep> chk <identifiersep> block . encode ( buf , false , false , ( short ) - 1 , buf . length , compressor <identifiersep> type . default <identifiersep> compressordescriptor , false ) ; insert <identifiersep> key = fetch <identifiersep> key = block . get <identifiersep> client <identifiersep> key ( ) ; test <identifiersep> key = insert <identifiersep> key . get <identifiersep> uri ( ) ; } system . err . println ( ) ; <LOG> system . err . println ( ) ; byte [ ] data = data <identifiersep> string . get <identifiersep> bytes ( <string_literal> ) ; logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( block . memory <identifiersep> decode ( ) , <string_literal> ) ) ; logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + insert <identifiersep> key . get <identifiersep> uri ( ) ) ; logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + fetch <identifiersep> key . get <identifiersep> uri ( ) ) ; try { <ect>
logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + fetch <identifiersep> key . get <identifiersep> uri ( ) ) ; try { insert <identifiersep> attempts ++ ; random <identifiersep> node . client <identifiersep> core . real <identifiersep> put ( block . get <identifiersep> block ( ) , false , fork <identifiersep> on <identifiersep> cacheable , false , false , real <identifiersep> time <identifiersep> flag ) ; logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + node1 ) ; } catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { <LOG> system . err . println ( <string_literal> + put <identifiersep> ex ) ; return exit <identifiersep> insert <identifiersep> failed ; } <comment> <ect>
try { block = fetch <identifiersep> node . client <identifiersep> core . real <identifiersep> get <identifiersep> key ( fetch <identifiersep> key , false , false , false , real <identifiersep> time <identifiersep> flag ) ; } catch ( low <identifiersep> level <identifiersep> get <identifiersep> exception e ) { block = null ; } if ( block == null ) { int percent <identifiersep> success = <number_literal> * fetch <identifiersep> successes / insert <identifiersep> attempts ; <LOG> system . err . println ( <string_literal> + request <identifiersep> number + <string_literal> + percent <identifiersep> success + <string_literal> + node2 ) ; requests <identifiersep> avg . report ( 0 . 0 ) ; } else { byte [ ] results = block . memory <identifiersep> decode ( ) ; requests <identifiersep> avg . report ( 1 . 0 ) ; if ( arrays . equals ( results , data ) ) { <ect>
} else { byte [ ] results = block . memory <identifiersep> decode ( ) ; requests <identifiersep> avg . report ( 1 . 0 ) ; if ( arrays . equals ( results , data ) ) { fetch <identifiersep> successes ++ ; int percent <identifiersep> success = <number_literal> * fetch <identifiersep> successes / insert <identifiersep> attempts ; <LOG> system . err . println ( <string_literal> + request <identifiersep> number + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) + \' \\ " \' ) ; if ( fetch <identifiersep> successes == target <identifiersep> successes ) { system . err . println ( <string_literal> + target <identifiersep> successes + <string_literal> ) ; return 0 ; } } else { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( results ) ) ; <ect>
if ( arrays . equals ( results , data ) ) { fetch <identifiersep> successes ++ ; int percent <identifiersep> success = <number_literal> * fetch <identifiersep> successes / insert <identifiersep> attempts ; logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + request <identifiersep> number + <string_literal> + node2 + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) ) ; system . err . println ( <string_literal> + request <identifiersep> number + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) + \' \\ " \' ) ; if ( fetch <identifiersep> successes == target <identifiersep> successes ) { <LOG> return 0 ; } } else { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( results ) ) ; system . err . println ( <string_literal> + new string ( results ) ) ; return exit <identifiersep> bad <identifiersep> data ; } } string <identifiersep> builder load = new string <identifiersep> builder ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> + request <identifiersep> number + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) + \' \\ " \' ) ; if ( fetch <identifiersep> successes == target <identifiersep> successes ) { system . err . println ( <string_literal> + target <identifiersep> successes + <string_literal> ) ; return 0 ; } } else { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( results ) ) ; <LOG> return exit <identifiersep> bad <identifiersep> data ; } } string <identifiersep> builder load = new string <identifiersep> builder ( <string_literal> ) ; int total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt = 0 ; list < long > running <identifiersep> ui <identifiersep> ds <identifiersep> list = new array <identifiersep> list < long > ( ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) { load . append ( i ) ; <ect>
if ( i != nodes . length - 1 ) load . append ( ' ' ) ; } system . err . println ( load . to <identifiersep> string ( ) ) ; if ( total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt != 0 ) system . err . println ( <string_literal> + total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt ) ; if ( ! running <identifiersep> ui <identifiersep> ds <identifiersep> list . is <identifiersep> empty ( ) ) { <LOG> } return - 1 ; } } <ect>
public static void main ( string [ ] args ) { if ( args . length != 1 ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; <LOG> csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; <ect>
try { final file dir = new file ( <string_literal> + uid ) ; file <identifiersep> util . remove <identifiersep> all ( dir ) ; random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . error , <string_literal> , false ) ; file seednodes = new file ( <string_literal> ) ; if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { <LOG> system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } final file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port1 ) ) ; inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; fis . close ( ) ; <ect>
csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; freenet <identifiersep> uri todays <identifiersep> insert = null ; <comment> <LOG> try { insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri uri = client . insert ( block , false , null ) ; if ( i == 0 ) todays <identifiersep> insert = uri ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
node2 . start ( true ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ! test <identifiersep> util . wait <identifiersep> for <identifiersep> nodes ( node2 ) ) { exit <identifiersep> code = exit <identifiersep> failed <identifiersep> target ; return ; } t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <ect>
make <identifiersep> kleinberg <identifiersep> network ( nodes , start <identifiersep> with <identifiersep> ideal <identifiersep> locations , degree , force <identifiersep> neighbour <identifiersep> connections , random ) ; logger . normal ( real <identifiersep> node <identifiersep> probe <identifiersep> test . class , <string_literal> ) ; for ( int i = 0 ; i < number <identifiersep> of <identifiersep> nodes ; i ++ ) { system . err . println ( <string_literal> + i ) ; nodes [ i ] . start ( false ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; if ( do <identifiersep> insert <identifiersep> test ) { wait <identifiersep> for <identifiersep> ping <identifiersep> average ( 0 . <number_literal> , nodes , new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) , max <identifiersep> pings , <number_literal> ) ; real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test tester = new real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test ( nodes , random , <number_literal> ) ; wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; while ( true ) { <ect>
wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; int status = tester . insert <identifiersep> request <identifiersep> test ( ) ; if ( status == - 1 ) continue ; system . out . println ( <string_literal> + status ) ; break ; } catch ( throwable t ) { <LOG> } } } final number <identifiersep> format nf = number <identifiersep> format . get <identifiersep> instance ( ) ; listener print = new listener ( ) { @ override public void on <identifiersep> error ( error error , byte code , boolean local ) { system . out . print ( <string_literal> + error . name ( ) ) ; if ( local ) system . out . print ( <string_literal> ) ; <ect>
public void on <identifiersep> error ( error error , byte code , boolean local ) { system . out . print ( <string_literal> + error . name ( ) ) ; if ( local ) system . out . print ( <string_literal> ) ; system . out . println ( code == null ? <string_literal> : <string_literal> + code + <string_literal> ) ; } @ override public void on <identifiersep> refused ( ) { <LOG> } @ override public void on <identifiersep> output <identifiersep> bandwidth ( float output <identifiersep> bandwidth ) { system . out . println ( <string_literal> + nf . format ( output <identifiersep> bandwidth ) + <string_literal> ) ; } @ override public void on <identifiersep> build ( int build ) { <ect>
@ override public void on <identifiersep> output <identifiersep> bandwidth ( float output <identifiersep> bandwidth ) { system . out . println ( <string_literal> + nf . format ( output <identifiersep> bandwidth ) + <string_literal> ) ; } @ override public void on <identifiersep> build ( int build ) { <LOG> } @ override public void on <identifiersep> identifier ( long identifier , byte uptime <identifiersep> percentage ) { system . out . println ( <string_literal> + identifier + <string_literal> + uptime <identifiersep> percentage + <string_literal> ) ; } @ override public void on <identifiersep> link <identifiersep> lengths ( float [ ] link <identifiersep> lengths ) { system . out . print ( <string_literal> ) ; <ect>
public void on <identifiersep> identifier ( long identifier , byte uptime <identifiersep> percentage ) { system . out . println ( <string_literal> + identifier + <string_literal> + uptime <identifiersep> percentage + <string_literal> ) ; } @ override public void on <identifiersep> link <identifiersep> lengths ( float [ ] link <identifiersep> lengths ) { system . out . print ( <string_literal> ) ; for ( float length : link <identifiersep> lengths ) system . out . print ( length + <string_literal> ) ; <LOG> } @ override public void on <identifiersep> location ( float location ) { system . out . println ( <string_literal> + location + <string_literal> ) ; } @ override public void on <identifiersep> store <identifiersep> size ( float store <identifiersep> size ) { system . out . println ( <string_literal> + nf . format ( store <identifiersep> size ) + <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } @ override public void on <identifiersep> location ( float location ) { system . out . println ( <string_literal> + location + <string_literal> ) ; } @ override public void on <identifiersep> store <identifiersep> size ( float store <identifiersep> size ) { <LOG> } @ override public void on <identifiersep> uptime ( float uptime <identifiersep> percentage ) { system . out . print ( <string_literal> + nf . format ( uptime <identifiersep> percentage ) + <string_literal> ) ; } @ override public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { system . out . println ( <string_literal> ) ; <ect>
@ override public void on <identifiersep> uptime ( float uptime <identifiersep> percentage ) { system . out . print ( <string_literal> + nf . format ( uptime <identifiersep> percentage ) + <string_literal> ) ; } @ override public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> + stats [ 1 ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; } @ override public void on <identifiersep> overall <identifiersep> bulk <identifiersep> output <identifiersep> capacity ( byte bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage , float output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) { <ect>
system . out . print ( <string_literal> + nf . format ( uptime <identifiersep> percentage ) + <string_literal> ) ; } @ override public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + stats [ 0 ] ) ; system . out . println ( <string_literal> + stats [ 1 ] ) ; <LOG> system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; } @ override public void on <identifiersep> overall <identifiersep> bulk <identifiersep> output <identifiersep> capacity ( byte bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage , float output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) { system . out . println ( <string_literal> + nf . format ( output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) + <string_literal> + bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage + <string_literal> ) ; <ect>
system . out . println ( <string_literal> + stats [ 1 ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; } @ override public void on <identifiersep> overall <identifiersep> bulk <identifiersep> output <identifiersep> capacity ( byte bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage , float output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) { <LOG> <string_literal> + bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage + <string_literal> ) ; } } ; final type types [ ] = { type . bandwidth , type . build , type . identifier , <ect>
if ( console != null ) r = new buffered <identifiersep> reader ( console . reader ( ) ) ; else r = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( system . in ) ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
else r = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( system . in ) ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
while ( true ) { system . err . println ( <string_literal> + index + <string_literal> + htl + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; try { int selection = integer . parse <identifiersep> int ( r . read <identifiersep> line ( ) ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; try { int selection = integer . parse <identifiersep> int ( r . read <identifiersep> line ( ) ) ; if ( selection == types . length ) { system . err . print ( <string_literal> + ( number <identifiersep> of <identifiersep> nodes - 1 ) + <string_literal> ) ; <ect>
high <identifiersep> level <identifiersep> simple <identifiersep> client client = node . client <identifiersep> core . make <identifiersep> client ( ( short ) 0 , false , false ) ; int successes = 0 ; long start <identifiersep> inserts <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; insert <identifiersep> batch batch = new insert <identifiersep> batch ( client ) ; <comment> <LOG> random <identifiersep> access <identifiersep> bucket single = random <identifiersep> data ( node ) ; insert <identifiersep> block block = new insert <identifiersep> block ( single , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; batch . start <identifiersep> insert ( block ) ; } batch . wait <identifiersep> until <identifiersep> finished ( ) ; freenet <identifiersep> uri [ ] uris = batch . get <identifiersep> ur <identifiersep> is ( ) ; long [ ] times = batch . get <identifiersep> times ( ) ; <ect>
csv <identifiersep> line . add ( uris [ i ] . to <identifiersep> ascii <identifiersep> string ( ) ) ; system . out . println ( <string_literal> + i + <string_literal> + uris [ i ] + <string_literal> + times [ i ] ) ; successes ++ ; } else { csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( errors [ i ] . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; <LOG> } } long end <identifiersep> inserts <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; system . err . println ( <string_literal> + successes + <string_literal> + inserted <identifiersep> blocks + <string_literal> + ( end <identifiersep> inserts <identifiersep> time - start <identifiersep> inserts <identifiersep> time ) + <string_literal> ) ; fetch <identifiersep> context fctx = client . get <identifiersep> fetch <identifiersep> context ( ) ; fctx . max <identifiersep> non <identifiersep> splitfile <identifiersep> retries = 0 ; fctx . max <identifiersep> splitfile <identifiersep> block <identifiersep> retries = 0 ; request <identifiersep> client request <identifiersep> context = new request <identifiersep> client <identifiersep> builder ( ) . build ( ) ; <ect>
int [ ] total <identifiersep> fetches <identifiersep> by <identifiersep> delta = new int [ max <identifiersep> n + 1 ] ; int [ ] total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta = new int [ max <identifiersep> n + 1 ] ; long [ ] total <identifiersep> fetch <identifiersep> time <identifiersep> by <identifiersep> delta = new long [ max <identifiersep> n + 1 ] ; loop <identifiersep> over <identifiersep> lines : while ( ( line = br . read <identifiersep> line ( ) ) != null ) { for ( int i = 0 ; i < mhk <identifiersep> ur <identifiersep> is . length ; i ++ ) mhk <identifiersep> ur <identifiersep> is [ i ] = null ; <LOG> string [ ] split = line . split ( <string_literal> ) ; date date = date <identifiersep> format . parse ( split [ 0 ] ) ; gregorian <identifiersep> calendar calendar = new gregorian <identifiersep> calendar ( time <identifiersep> zone . get <identifiersep> time <identifiersep> zone ( <string_literal> ) ) ; calendar . set <identifiersep> time ( date ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; calendar . set ( calendar . hour <identifiersep> of <identifiersep> day , 0 ) ; <ect>
calendar . set ( calendar . second , 0 ) ; calendar . get <identifiersep> time ( ) ; freenet <identifiersep> uri [ ] inserted <identifiersep> ur <identifiersep> is = new freenet <identifiersep> uri [ inserted <identifiersep> blocks ] ; int [ ] insert <identifiersep> times = new int [ inserted <identifiersep> blocks ] ; if ( split . length < <number_literal> ) continue ; int seed <identifiersep> time = integer . parse <identifiersep> int ( split [ <number_literal> ] ) ; <LOG> if ( split . length < <number_literal> ) continue ; int token = <number_literal> ; if ( split . length < token + inserted <identifiersep> blocks * <number_literal> ) continue ; for ( int i = 0 ; i < inserted <identifiersep> blocks ; i ++ ) { try { insert <identifiersep> times [ i ] = integer . parse <identifiersep> int ( split [ token ] ) ; <ect>
} catch ( malformed <identifiersep> url <identifiersep> exception e ) { inserted <identifiersep> ur <identifiersep> is [ i ] = null ; } token ++ ; system . out . println ( <string_literal> + i + <string_literal> + inserted <identifiersep> ur <identifiersep> is [ i ] + <string_literal> + insert <identifiersep> times [ i ] ) ; } for ( int i = 0 ; i < targets . length ; i ++ ) { if ( math . abs ( targets [ i ] . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) - calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ) < hours . to <identifiersep> millis ( <number_literal> ) ) { <LOG> system . out . println ( <string_literal> + split [ 1 ] ) ; csv <identifiersep> line . add ( integer . to <identifiersep> string ( i ) ) ; int pulled = 0 ; int inserted = 0 ; for ( int j = 0 ; j < inserted <identifiersep> blocks ; j ++ ) { if ( inserted <identifiersep> ur <identifiersep> is [ j ] == null ) { <ect>
try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; fetch <identifiersep> waiter fw = new fetch <identifiersep> waiter ( request <identifiersep> context ) ; client . fetch ( inserted <identifiersep> ur <identifiersep> is [ j ] , <number_literal> , fw , fctx ) ; fw . wait <identifiersep> for <identifiersep> completion ( ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; pulled ++ ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
} catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( fetch <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; system . err . println ( <string_literal> + j + <string_literal> + e ) ; } } <LOG> } } while ( split . length > token + inserted <identifiersep> blocks ) { int delta ; try { delta = integer . parse <identifiersep> int ( split [ token ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + token + <string_literal> + token + <string_literal> ) ; <ect>
while ( split . length > token + inserted <identifiersep> blocks ) { int delta ; try { delta = integer . parse <identifiersep> int ( split [ token ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + token + <string_literal> + token + <string_literal> ) ; <LOG> system . err . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; continue loop <identifiersep> over <identifiersep> lines ; } system . out . println ( <string_literal> + ( ( 1 < < delta ) - 1 ) + <string_literal> ) ; token ++ ; int total <identifiersep> fetch <identifiersep> time = 0 ; int total <identifiersep> successes = 0 ; <ect>
delta = integer . parse <identifiersep> int ( split [ token ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + token + <string_literal> + token + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; continue loop <identifiersep> over <identifiersep> lines ; } <LOG> token ++ ; int total <identifiersep> fetch <identifiersep> time = 0 ; int total <identifiersep> successes = 0 ; int total <identifiersep> fetches = 0 ; for ( int i = 0 ; i < inserted <identifiersep> blocks ; i ++ ) { if ( split [ token ] . equals ( <string_literal> ) ) <ect>
try { mhk <identifiersep> fetch <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; system . out . println ( <string_literal> + i + <string_literal> + date + <string_literal> + mhk <identifiersep> fetch <identifiersep> time + <string_literal> ) ; total <identifiersep> successes ++ ; total <identifiersep> fetch <identifiersep> time += mhk <identifiersep> fetch <identifiersep> time ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> } token ++ ; } total <identifiersep> fetches <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> fetches ; total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> successes ; total <identifiersep> fetch <identifiersep> time <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> fetch <identifiersep> time ; system . err . println ( <string_literal> + total <identifiersep> successes + <string_literal> + total <identifiersep> fetches + <string_literal> + ( ( double ) total <identifiersep> fetch <identifiersep> time ) / ( ( double ) total <identifiersep> successes ) + <string_literal> + delta + <string_literal> + date <identifiersep> format . format ( date ) ) ; } } system . out . println ( ) ; <ect>
total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> successes ; total <identifiersep> fetch <identifiersep> time <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> fetch <identifiersep> time ; system . err . println ( <string_literal> + total <identifiersep> successes + <string_literal> + total <identifiersep> fetches + <string_literal> + ( ( double ) total <identifiersep> fetch <identifiersep> time ) / ( ( double ) total <identifiersep> successes ) + <string_literal> + delta + <string_literal> + date <identifiersep> format . format ( date ) ) ; } } system . out . println ( ) ; system . out . println ( ) ; for ( int i = 0 ; i < max <identifiersep> n + 1 ; i ++ ) { <LOG> } fis . close ( ) ; fis = null ; } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; exit <identifiersep> code = exit <identifiersep> threw <identifiersep> something ; } finally { <ect>
ip <identifiersep> override = args [ 0 ] ; file dir = new file ( <string_literal> ) ; file <identifiersep> util . remove <identifiersep> all ( dir ) ; random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . normal , <string_literal> <comment> , false ) ; file seednodes = new file ( <string_literal> ) ; if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { <LOG> system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port1 ) ) ; inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; fis . close ( ) ; <ect>
node . fast <identifiersep> weak <identifiersep> random . next <identifiersep> bytes ( buf ) ; int to <identifiersep> write = ( int ) math . min ( test <identifiersep> size - written , buf . length ) ; os . write ( buf , 0 , to <identifiersep> write ) ; written += to <identifiersep> write ; } } finally { os . close ( ) ; } <LOG> high <identifiersep> level <identifiersep> simple <identifiersep> client client = node . client <identifiersep> core . make <identifiersep> client ( ( short ) 0 , false , false ) ; insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; long start <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri uri ; try { uri = client . insert ( block , false , null ) ; <ect>
} catch ( insert <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; return ; } long end <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> node . park ( ) ; <comment> <ect>
} catch ( fetch <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> fetch <identifiersep> failed ) ; return ; } long end <identifiersep> fetch <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> second <identifiersep> node . park ( ) ; system . exit ( 0 ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; try { <ect>
random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . error , <string_literal> , false ) ; byte [ ] seed = new byte [ <number_literal> ] ; random . next <identifiersep> bytes ( seed ) ; mersenne <identifiersep> twister fast <identifiersep> random = new mersenne <identifiersep> twister ( seed ) ; file seednodes = new file ( <string_literal> ) ; if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { <LOG> system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } file second <identifiersep> inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port ) ) ; second <identifiersep> inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( second <identifiersep> inner <identifiersep> dir , <string_literal> ) ) ; fis . close ( ) ; <ect>
input <identifiersep> stream is = new file <identifiersep> input <identifiersep> stream ( data <identifiersep> file ) ; file <identifiersep> util . copy ( is , sock <identifiersep> os , test <identifiersep> size ) ; system . out . println ( <string_literal> ) ; while ( true ) { name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; fs = new simple <identifiersep> field <identifiersep> set ( lis , <number_literal> , <number_literal> , true , false , true ) ; <LOG> system . out . print ( fs . to <identifiersep> ordered <identifiersep> string ( ) ) ; if ( name . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } if ( name . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> + name ) ; system . out . print ( fs . to <identifiersep> ordered <identifiersep> string ( ) ) ; if ( name . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } if ( name . equals ( <string_literal> ) ) { <LOG> system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } if ( name . equals ( <string_literal> ) ) { long end <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri uri = new freenet <identifiersep> uri ( fs . get ( <string_literal> ) ) ; system . out . println ( <string_literal> + ( end <identifiersep> insert <identifiersep> time - start <identifiersep> insert <identifiersep> time ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> insert <identifiersep> time - start <identifiersep> insert <identifiersep> time ) + <string_literal> + uri + <string_literal> ) ; sock <identifiersep> os . close ( ) ; <ect>
synchronized ( sequence <identifiersep> number <identifiersep> lock ) { if ( first <identifiersep> seq <identifiersep> num <identifiersep> used == - 1 ) { first <identifiersep> seq <identifiersep> num <identifiersep> used = next <identifiersep> seq <identifiersep> num ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + first <identifiersep> seq <identifiersep> num <identifiersep> used ) ; } else { if ( next <identifiersep> seq <identifiersep> num == first <identifiersep> seq <identifiersep> num <identifiersep> used ) { <LOG> pn . start <identifiersep> rekeying ( ) ; return - 1 ; } if ( first <identifiersep> seq <identifiersep> num <identifiersep> used > next <identifiersep> seq <identifiersep> num ) { if ( first <identifiersep> seq <identifiersep> num <identifiersep> used - next <identifiersep> seq <identifiersep> num < rekey <identifiersep> threshold ) pn . start <identifiersep> rekeying ( ) ; } else { if ( ( new <identifiersep> packet <identifiersep> format . num <identifiersep> seqnums - next <identifiersep> seq <identifiersep> num ) + first <identifiersep> seq <identifiersep> num <identifiersep> used < rekey <identifiersep> threshold ) pn . start <identifiersep> rekeying ( ) ; <ect>
sent = sent <identifiersep> packets . remove ( ack ) ; max <identifiersep> size = ( max <identifiersep> seen <identifiersep> in <identifiersep> flight * <number_literal> ) + <number_literal> ; } if ( sent != null ) { rtt = sent . acked ( key ) ; valid <identifiersep> ack = true ; } else { <LOG> long packet <identifiersep> sent = lost <identifiersep> sent <identifiersep> times . query <identifiersep> and <identifiersep> remove ( ack ) ; if ( packet <identifiersep> sent < 0 ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ack + <string_literal> ) ; return ; } rtt = ack <identifiersep> received - packet <identifiersep> sent ; } if ( pn == null ) <ect>
synchronized ( acks ) { iterator < map . entry < integer , long > > it = acks . entry <identifiersep> set ( ) . iterator ( ) ; while ( it . has <identifiersep> next ( ) && packet . get <identifiersep> length ( ) < max <identifiersep> packet <identifiersep> size ) { map . entry < integer , long > entry = it . next ( ) ; int ack = entry . get <identifiersep> key ( ) ; <comment> <LOG> if ( ! packet . add <identifiersep> ack ( ack , max <identifiersep> packet <identifiersep> size ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ack ) ; break ; } if ( entry . get <identifiersep> value ( ) + max <identifiersep> ack <identifiersep> delay < now ) must <identifiersep> send = true ; if ( moved == null ) { <ect>
<comment> public decoded process ( byte [ ] buf , int offset , int length , peer peer , peer <identifiersep> node opn , long now ) { if ( opn != null && opn . get <identifiersep> outgoing <identifiersep> mangler ( ) != this ) { <LOG> opn = null ; } boolean want <identifiersep> anon <identifiersep> auth = crypto . want <identifiersep> anon <identifiersep> auth ( ) ; if ( opn != null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; if ( length > node . symmetric <identifiersep> key <identifiersep> length <comment> + hash <identifiersep> length + <number_literal> && ! node . is <identifiersep> stopping ( ) ) { <comment> <ect>
if ( want <identifiersep> anon <identifiersep> auth ) { if ( try <identifiersep> process <identifiersep> auth <identifiersep> anon ( buf , offset , length , peer ) ) return decoded . decoded ; } if ( want <identifiersep> anon <identifiersep> auth && ! want <identifiersep> anon <identifiersep> auth <identifiersep> change <identifiersep> ip ) { if ( check <identifiersep> anon <identifiersep> auth <identifiersep> change <identifiersep> ip ( opn , buf , offset , length , peer , now ) ) { <comment> <LOG> return decoded . decoded ; } } <comment> <ect>
<comment> <LOG> } else { logger . minor ( this , <string_literal> + length + <string_literal> + ( digest <identifiersep> length + iv <identifiersep> length + <number_literal> ) ) ; } } return false ; } <comment> <ect>
int data <identifiersep> start = iv <identifiersep> length + digest <identifiersep> length + offset + <number_literal> ; int byte1 = ( ( pcfb . decipher ( buf [ data <identifiersep> start - <number_literal> ] ) ) & 0xff ) ; int byte2 = ( ( pcfb . decipher ( buf [ data <identifiersep> start - 1 ] ) ) & 0xff ) ; int data <identifiersep> length = ( byte1 < < <number_literal> ) + byte2 ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + data <identifiersep> length + <string_literal> + byte1 + <string_literal> + byte2 + ' ) ' ) ; if ( data <identifiersep> length > length - ( iv <identifiersep> length + hash . length + <number_literal> ) ) { <LOG> return false ; } <comment> <ect>
private boolean try <identifiersep> process <identifiersep> auth <identifiersep> anon <identifiersep> reply ( byte [ ] buf , int offset , int length , peer <identifiersep> node pn , peer peer , long now ) { block <identifiersep> cipher auth <identifiersep> key = pn . anonymous <identifiersep> initiator <identifiersep> setup <identifiersep> cipher ; <comment> <LOG> return false ; } <comment> <ect>
byte [ ] real <identifiersep> hash = sha256 . digest ( payload ) ; if ( message <identifiersep> digest . is <identifiersep> equal ( real <identifiersep> hash , hash ) ) { <comment> <LOG> return false ; } } <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + packet <identifiersep> type + <string_literal> + version + <string_literal> + neg <identifiersep> type + <string_literal> + setup <identifiersep> type + <string_literal> + reply <identifiersep> to + <string_literal> ) ; if ( version != 1 ) { logger . error ( this , <string_literal> + version ) ; return ; } if ( ! ( neg <identifiersep> type == <number_literal> ) ) { if ( neg <identifiersep> type > <number_literal> ) <LOG> else logger . warning ( this , <string_literal> + neg <identifiersep> type ) ; return ; } <comment> <ect>
logger . error ( this , <string_literal> + neg <identifiersep> type ) ; else logger . warning ( this , <string_literal> + neg <identifiersep> type ) ; return ; } <comment> <LOG> return ; } <comment> <ect>
<comment> final int packet <identifiersep> type = payload [ <number_literal> ] ; <comment> final int setup <identifiersep> type = payload [ <number_literal> ] ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + packet <identifiersep> type + <string_literal> + version + <string_literal> + neg <identifiersep> type + <string_literal> + setup <identifiersep> type + <string_literal> + reply <identifiersep> to + <string_literal> ) ; if ( version != 1 ) { <LOG> return ; } if ( ! ( neg <identifiersep> type == <number_literal> ) ) { if ( neg <identifiersep> type > <number_literal> ) logger . error ( this , <string_literal> + neg <identifiersep> type ) ; else logger . warning ( this , <string_literal> + neg <identifiersep> type ) ; <ect>
logger . error ( this , <string_literal> + version ) ; return ; } if ( ! ( neg <identifiersep> type == <number_literal> ) ) { if ( neg <identifiersep> type > <number_literal> ) logger . error ( this , <string_literal> + neg <identifiersep> type ) ; else <LOG> return ; } <comment> <ect>
process <identifiersep> jfk <identifiersep> message2 ( payload , <number_literal> , pn , reply <identifiersep> to , true , setup <identifiersep> type , neg <identifiersep> type ) ; } else if ( packet <identifiersep> type == <number_literal> ) { <comment> <LOG> } } private final serial <identifiersep> executor auth <identifiersep> handling <identifiersep> thread = new serial <identifiersep> executor ( native <identifiersep> thread . high <identifiersep> priority , <number_literal> ) ; <comment> private void process <identifiersep> decrypted <identifiersep> auth ( final byte [ ] payload , final peer <identifiersep> node pn , final peer reply <identifiersep> to , final boolean old <identifiersep> opennet <identifiersep> peer ) { <ect>
last <identifiersep> logged <identifiersep> no <identifiersep> contexts = now ; } log <identifiersep> loud <identifiersep> error <identifiersep> no <identifiersep> contexts ( ) ; } private void log <identifiersep> loud <identifiersep> error <identifiersep> no <identifiersep> contexts ( ) { <comment> <LOG> system . err . println ( <string_literal> ) ; if ( file <identifiersep> util . detected <identifiersep> os . is <identifiersep> unix ) { file f = new file ( <string_literal> ) ; if ( f . exists ( ) ) system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } private final lru <identifiersep> map < inet <identifiersep> address , long > throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip = lru <identifiersep> map . create <identifiersep> safe <identifiersep> map ( inet <identifiersep> address <identifiersep> comparator . comparator ) ; private static final int rekey <identifiersep> by <identifiersep> ip <identifiersep> table <identifiersep> size = <number_literal> ; private boolean throttle <identifiersep> rekey ( peer <identifiersep> node pn , peer reply <identifiersep> to ) { if ( pn != null ) { <ect>
system . err . println ( <string_literal> ) ; if ( file <identifiersep> util . detected <identifiersep> os . is <identifiersep> unix ) { file f = new file ( <string_literal> ) ; if ( f . exists ( ) ) system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> } } private final lru <identifiersep> map < inet <identifiersep> address , long > throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip = lru <identifiersep> map . create <identifiersep> safe <identifiersep> map ( inet <identifiersep> address <identifiersep> comparator . comparator ) ; private static final int rekey <identifiersep> by <identifiersep> ip <identifiersep> table <identifiersep> size = <number_literal> ; private boolean throttle <identifiersep> rekey ( peer <identifiersep> node pn , peer reply <identifiersep> to ) { if ( pn != null ) { return pn . throttle <identifiersep> rekey ( ) ; } long now = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
system . arraycopy ( pn . identity <identifiersep> hash , 0 , message1 , offset , pn . identity <identifiersep> hash . length ) ; send <identifiersep> anon <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , 0 , setup <identifiersep> type , message1 , pn , reply <identifiersep> to , pn . anonymous <identifiersep> initiator <identifiersep> setup <identifiersep> cipher ) ; } else { send <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , 0 , message1 , pn , reply <identifiersep> to ) ; } long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( t2 - now ) > <number_literal> ) { <LOG> } } <comment> <ect>
<comment> <LOG> byte [ ] message2 = new byte [ nonce <identifiersep> initator . length + nonce <identifiersep> size + modulus <identifiersep> length + sig . length + hash <identifiersep> length ] ; int offset = 0 ; system . arraycopy ( nonce <identifiersep> initator , 0 , message2 , offset , nonce <identifiersep> initator . length ) ; offset += nonce <identifiersep> initator . length ; <ect>
return ; } <comment> <LOG> return ; } logger . error ( this , <string_literal> + pn . get <identifiersep> peer ( ) ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( his <identifiersep> exponential ) + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash ) + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( sig ) ) ; return ; <ect>
if ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash == null ) { <comment> <LOG> <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash ) + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( sig ) ) ; return ; } <comment> <ect>
( c . get <identifiersep> block <identifiersep> size ( ) > > <number_literal> ) + <comment> <LOG> return ; } <comment> <ect>
byte [ ] authenticator = arrays . copy <identifiersep> of <identifiersep> range ( payload , input <identifiersep> offset , input <identifiersep> offset + hash <identifiersep> length ) ; input <identifiersep> offset += hash <identifiersep> length ; <comment> <LOG> if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( nonce <identifiersep> initiator <identifiersep> hashed ) ) ; logger . normal ( this , <string_literal> + pn ) ; } return ; } <comment> <ect>
if ( unknown <identifiersep> initiator ) { send <identifiersep> anon <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , setup <identifiersep> type , ( byte [ ] ) message4 , null , reply <identifiersep> to , crypto . anon <identifiersep> setup <identifiersep> cipher ) ; } else { send <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , ( byte [ ] ) message4 , pn , reply <identifiersep> to ) ; } return ; } else { <LOG> } byte [ ] hmac = arrays . copy <identifiersep> of <identifiersep> range ( payload , input <identifiersep> offset , input <identifiersep> offset + hash <identifiersep> length ) ; input <identifiersep> offset += hash <identifiersep> length ; byte [ ] computed <identifiersep> exponential ; ec <identifiersep> public <identifiersep> key initiator <identifiersep> key = ecdh . get <identifiersep> public <identifiersep> key ( initiator <identifiersep> exponential , ecdh <identifiersep> curve <identifiersep> to <identifiersep> use ) ; ec <identifiersep> public <identifiersep> key responder <identifiersep> key = ecdh . get <identifiersep> public <identifiersep> key ( responder <identifiersep> exponential , ecdh <identifiersep> curve <identifiersep> to <identifiersep> use ) ; ecdh <identifiersep> light <identifiersep> context ctx = find <identifiersep> ecdh <identifiersep> context <identifiersep> by <identifiersep> pub <identifiersep> key ( responder <identifiersep> key ) ; <ect>
if ( ctx == null ) { logger . error ( this , <string_literal> + pn ) ; <comment> <LOG> <comment> byte [ ] outgoing <identifiersep> key = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; byte [ ] incomming <identifiersep> key = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; byte [ ] ke = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; byte [ ] ka = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; byte [ ] hmac <identifiersep> key = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; <ect>
pn = get <identifiersep> peer <identifiersep> node <identifiersep> from <identifiersep> unknown <identifiersep> initiator ( his <identifiersep> ref , setup <identifiersep> type , pn , reply <identifiersep> to ) ; } if ( pn == null ) { if ( unknown <identifiersep> initiator ) { <comment> <LOG> } return ; } <comment> <ect>
logger . normal ( this , <string_literal> + pn + <string_literal> ) ; dont <identifiersep> want = true ; opennet . purge <identifiersep> old <identifiersep> opennet <identifiersep> peer ( opn ) ; } <comment> <LOG> system . out . println ( <string_literal> + ( ( darknet <identifiersep> peer <identifiersep> node ) pn ) . get <identifiersep> name ( ) + <string_literal> ) ; } logger . normal ( this , <string_literal> ) ; dont <identifiersep> want = true ; } long new <identifiersep> tracker <identifiersep> id = pn . completed <identifiersep> handshake ( boot <identifiersep> id , his <identifiersep> ref , 0 , his <identifiersep> ref . length , outgoing <identifiersep> cipher , outgoing <identifiersep> key , incomming <identifiersep> cipher , incomming <identifiersep> key , reply <identifiersep> to , true , neg <identifiersep> type , tracker <identifiersep> id , false , false , hmac <identifiersep> key , iv <identifiersep> cipher , <ect>
c , ke , ka , authenticator , his <identifiersep> ref , pn , reply <identifiersep> to , unknown <identifiersep> initiator , setup <identifiersep> type , new <identifiersep> tracker <identifiersep> id , new <identifiersep> tracker <identifiersep> id == tracker <identifiersep> id ) ; if ( dont <identifiersep> want ) { node . peers . disconnect <identifiersep> and <identifiersep> remove ( pn , true , true , true ) ; <comment> <LOG> <comment> <ect>
if ( ( t2 - t1 ) > <number_literal> ) { logger . error ( this , <string_literal> + pn . get <identifiersep> peer ( ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( t2 - t1 , <number_literal> , true ) ) ; } } private peer <identifiersep> node get <identifiersep> peer <identifiersep> node <identifiersep> from <identifiersep> unknown <identifiersep> initiator ( byte [ ] his <identifiersep> ref , int setup <identifiersep> type , peer <identifiersep> node pn , peer from ) { if ( setup <identifiersep> type == setup <identifiersep> opennet <identifiersep> seednode ) { opennet <identifiersep> manager om = node . get <identifiersep> opennet ( ) ; if ( om == null ) { <LOG> <comment> <ect>
return null ; } peer <identifiersep> node seed ; try { seed = new seed <identifiersep> client <identifiersep> peer <identifiersep> node ( ref , node , crypto ) ; <comment> <LOG> return null ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; <ect>
<comment> <comment> <LOG> <comment> pn . outgoing <identifiersep> key = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; pn . incomming <identifiersep> key = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; pn . jfk <identifiersep> ke = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; pn . jfk <identifiersep> ka = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; pn . hmac <identifiersep> key = compute <identifiersep> jfk <identifiersep> shared <identifiersep> key ( computed <identifiersep> exponential , nonce <identifiersep> initiator <identifiersep> hashed , nonce <identifiersep> responder , <string_literal> ) ; <ect>
offset += iv <identifiersep> length ; system . arraycopy ( cyphertext , cleartext <identifiersep> to <identifiersep> encypher <identifiersep> offset , message4 , offset , cyphertext . length - cleartext <identifiersep> to <identifiersep> encypher <identifiersep> offset ) ; <comment> <LOG> } if ( unknown <identifiersep> initiator ) { send <identifiersep> anon <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , setup <identifiersep> type , message4 , pn , reply <identifiersep> to , crypto . anon <identifiersep> setup <identifiersep> cipher ) ; } else { send <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , message4 , pn , reply <identifiersep> to ) ; } long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( t2 - t1 ) > <number_literal> ) <ect>
int length = output . length ; if ( length > sock . get <identifiersep> max <identifiersep> packet <identifiersep> size ( ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + length ) ; } byte [ ] iv = new byte [ pcfb <identifiersep> mode . length <identifiersep> iv ( cipher ) ] ; node . random . next <identifiersep> bytes ( iv ) ; byte [ ] hash = sha256 . digest ( output ) ; <LOG> int pre <identifiersep> padding <identifiersep> length = iv . length + hash . length + <number_literal> <comment> + output . length ; int max <identifiersep> packet <identifiersep> size = sock . get <identifiersep> max <identifiersep> packet <identifiersep> size ( ) ; int padding <identifiersep> length ; if ( pre <identifiersep> padding <identifiersep> length < max <identifiersep> packet <identifiersep> size ) { padding <identifiersep> length = node . fast <identifiersep> weak <identifiersep> random . next <identifiersep> int ( math . min ( <number_literal> , max <identifiersep> packet <identifiersep> size - pre <identifiersep> padding <identifiersep> length ) ) ; } else { <ect>
system . arraycopy ( output , 0 , data , hash . length + iv . length + <number_literal> , output . length ) ; util . random <identifiersep> bytes ( node . fast <identifiersep> weak <identifiersep> random , data , hash . length + iv . length + <number_literal> + output . length , padding <identifiersep> length ) ; try { send <identifiersep> packet ( data , reply <identifiersep> to , pn ) ; node . node <identifiersep> stats . report <identifiersep> auth <identifiersep> bytes ( data . length + sock . get <identifiersep> headers <identifiersep> length ( reply <identifiersep> to ) ) ; } catch ( local <identifiersep> address <identifiersep> exception e ) { <LOG> } } private void send <identifiersep> packet ( byte [ ] data , peer reply <identifiersep> to , peer <identifiersep> node pn ) throws local <identifiersep> address <identifiersep> exception { if ( pn != null ) { if ( pn . is <identifiersep> ignore <identifiersep> source ( ) ) { peer p = pn . get <identifiersep> peer ( ) ; if ( p != null ) reply <identifiersep> to = p ; } } sock . send <identifiersep> packet ( data , reply <identifiersep> to , pn == null ? crypto . config . always <identifiersep> allow <identifiersep> local <identifiersep> addresses ( ) : pn . allow <identifiersep> local <identifiersep> addresses ( ) ) ; <ect>
@ override public boolean always <identifiersep> allow <identifiersep> local <identifiersep> addresses ( ) { return crypto . config . always <identifiersep> allow <identifiersep> local <identifiersep> addresses ( ) ; } private ecdh <identifiersep> light <identifiersep> context  <identifiersep> gen <identifiersep> ecdh <identifiersep> light <identifiersep> context ( ) { final ecdh <identifiersep> light <identifiersep> context ctx = new ecdh <identifiersep> light <identifiersep> context ( ecdh <identifiersep> curve <identifiersep> to <identifiersep> use ) ; ctx . set <identifiersep> ecdsa <identifiersep> signature ( crypto . ecdsa <identifiersep> sign ( ctx . get <identifiersep> public <identifiersep> key <identifiersep> network <identifiersep> format ( ) ) ) ; <LOG> return ctx ; } private void  <identifiersep> fill <identifiersep> jfkecdhfifo <identifiersep> off <identifiersep> thread ( ) { <comment> <ect>
last <identifiersep> io <identifiersep> stat <identifiersep> time = <number_literal> ; int default <identifiersep> thread <identifiersep> limit ; long memory <identifiersep> limit = node <identifiersep> starter . get <identifiersep> memory <identifiersep> limit <identifiersep> mb ( ) ; system . out . println ( <string_literal> + memory <identifiersep> limit + <string_literal> ) ; if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; <LOG> } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; <LOG> } else { system . out . println ( <string_literal> ) ; default <identifiersep> thread <identifiersep> limit = <number_literal> ; } stats <identifiersep> config . register ( <string_literal> , default <identifiersep> thread <identifiersep> limit , sort <identifiersep> order ++ , true , true , <string_literal> , <string_literal> , new int <identifiersep> callback ( ) { @ override <ect>
} ) ; enable <identifiersep> new <identifiersep> load <identifiersep> management <identifiersep> bulk = stats <identifiersep> config . get <identifiersep> boolean ( <string_literal> ) ; if ( node . last <identifiersep> version < = <number_literal> && ( enable <identifiersep> new <identifiersep> load <identifiersep> management <identifiersep> rt || enable <identifiersep> new <identifiersep> load <identifiersep> management <identifiersep> bulk ) ) { <comment> <LOG> stats <identifiersep> config . config . store ( ) ; } persister = new configurable <identifiersep> persister ( this , stats <identifiersep> config , <string_literal> , <string_literal> , sort <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , node . ticker , node . get <identifiersep> run <identifiersep> dir ( ) ) ; simple <identifiersep> field <identifiersep> set throttle <identifiersep> fs = persister . read ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + throttle <identifiersep> fs ) ; <comment> <ect>
<comment> <LOG> return 1 . 0 ; } return non <identifiersep> overhead <identifiersep> fraction ; } private double get <identifiersep> output <identifiersep> bandwidth <identifiersep> upper <identifiersep> limit ( long limit , double non <identifiersep> overhead <identifiersep> fraction ) { double output <identifiersep> available <identifiersep> per <identifiersep> second = node . get <identifiersep> output <identifiersep> bandwidth <identifiersep> limit ( ) * non <identifiersep> overhead <identifiersep> fraction ; return output <identifiersep> available <identifiersep> per <identifiersep> second * limit ; } private int get <identifiersep> max <identifiersep> transfers <identifiersep> upper <identifiersep> limit ( boolean real <identifiersep> time , double non <identifiersep> overhead <identifiersep> fraction ) { <ect>
} else { first <identifiersep> node <identifiersep> average <identifiersep> ping <identifiersep> time <identifiersep> threshold <identifiersep> break = 0 ; } if ( ( first <identifiersep> node <identifiersep> average <identifiersep> ping <identifiersep> time <identifiersep> threshold <identifiersep> break != 0 ) && ( ( now - first <identifiersep> node <identifiersep> average <identifiersep> ping <identifiersep> time <identifiersep> threshold <identifiersep> break ) >= max <identifiersep> node <identifiersep> average <identifiersep> ping <identifiersep> time <identifiersep> alert <identifiersep> delay ) ) { node <identifiersep> average <identifiersep> ping <identifiersep> alert <identifiersep> relevant = true ; } else { node <identifiersep> average <identifiersep> ping <identifiersep> alert <identifiersep> relevant = false ; } <LOG> next <identifiersep> peer <identifiersep> manager <identifiersep> user <identifiersep> alert <identifiersep> stats <identifiersep> update <identifiersep> time = now + peer <identifiersep> manager <identifiersep> user <identifiersep> alert <identifiersep> stats <identifiersep> update <identifiersep> interval ; } } @ override public simple <identifiersep> field <identifiersep> set persist <identifiersep> throttles <identifiersep> to <identifiersep> field <identifiersep> set ( ) { simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( true ) ; fs . put ( <string_literal> , remote <identifiersep> chk <identifiersep> fetch <identifiersep> bytes <identifiersep> sent <identifiersep> average . export <identifiersep> field <identifiersep> set ( true ) ) ; fs . put ( <string_literal> , remote <identifiersep> ssk <identifiersep> fetch <identifiersep> bytes <identifiersep> sent <identifiersep> average . export <identifiersep> field <identifiersep> set ( true ) ) ; <ect>
@ override public void sent <identifiersep> bytes ( int x ) { synchronized ( node <identifiersep> stats . this ) { resend <identifiersep> bytes <identifiersep> sent += x ; } } @ override public void sent <identifiersep> payload ( int x ) { <LOG> } } ; public synchronized long get <identifiersep> resend <identifiersep> bytes <identifiersep> sent ( ) { return resend <identifiersep> bytes <identifiersep> sent ; } private long uom <identifiersep> bytes <identifiersep> sent ; public synchronized void report <identifiersep> uom <identifiersep> bytes <identifiersep> sent ( int x ) { uom <identifiersep> bytes <identifiersep> sent += x ; <ect>
return location . is <identifiersep> valid ( current <identifiersep> location ) ; } public synchronized int get <identifiersep> degree ( ) { if ( current <identifiersep> peers <identifiersep> location == null ) return 0 ; return current <identifiersep> peers <identifiersep> location . length ; } boolean update <identifiersep> location ( double new <identifiersep> loc , double [ ] new <identifiersep> locs ) { if ( ! location . is <identifiersep> valid ( new <identifiersep> loc ) ) { <LOG> <comment> <ect>
<comment> public static double distance ( double a , double b ) { if ( ! is <identifiersep> valid ( a ) || ! is <identifiersep> valid ( b ) ) { string err <identifiersep> msg = <string_literal> + a + <string_literal> + b + <string_literal> ; <LOG> throw new illegal <identifiersep> argument <identifiersep> exception ( err <identifiersep> msg ) ; } return simple <identifiersep> distance ( a , b ) ; } <comment> <ect>
try { source . send <identifiersep> async ( confirm , null , this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; } } catch ( crypt <identifiersep> format <identifiersep> exception e ) { <LOG> msg = dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> ssk <identifiersep> error ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception ee ) { <comment> <ect>
} else { logger . error ( this , <string_literal> + msg + <string_literal> + this ) ; } } try { key . set <identifiersep> pub <identifiersep> key ( pub <identifiersep> key ) ; block = new ssk <identifiersep> block ( data , headers , key , false ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e1 ) { <LOG> message msg = dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> ssk <identifiersep> error ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
logger . error ( this , <string_literal> + uid + <string_literal> ) ; return ; } catch ( peer <identifiersep> restarted <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <LOG> return ; } block = stored <identifiersep> block ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + key + <string_literal> + uid ) ; if ( htl > 0 ) sender = node . make <identifiersep> insert <identifiersep> sender ( block , htl , uid , tag , source , false , false , can <identifiersep> write <identifiersep> datastore , fork <identifiersep> on <identifiersep> cacheable , prefer <identifiersep> insert , ignore <identifiersep> low <identifiersep> backoff , real <identifiersep> time <identifiersep> flag ) ; boolean received <identifiersep> rejected <identifiersep> overload = false ; <ect>
if ( ! ( reassigned || was <identifiersep> local || source <identifiersep> restarted || timed <identifiersep> out <identifiersep> but <identifiersep> continued ) ) { boolean expected = false ; if ( handling <identifiersep> timeouts != null ) { expected = true ; for ( peer <identifiersep> node pn : currently <identifiersep> routing <identifiersep> to ) { if ( handling <identifiersep> timeouts . contains ( pn ) ) { <LOG> break ; } expected = false ; } } if ( ! expected ) { if ( handling <identifiersep> timeouts != null ) logger . normal ( this , <string_literal> + currently <identifiersep> routing <identifiersep> to + <string_literal> ) ; else <ect>
if ( ! ( reassigned || was <identifiersep> local ) ) { boolean expected = false ; if ( handling <identifiersep> timeouts != null ) { expected = true ; for ( peer <identifiersep> node pn : fetching <identifiersep> offered <identifiersep> key <identifiersep> from ) { if ( handling <identifiersep> timeouts . contains ( pn ) ) { <LOG> break ; } expected = false ; } } if ( ! expected ) <comment> <ect>
allow <identifiersep> local <identifiersep> addresses = metadata . get <identifiersep> boolean ( <string_literal> , false ) ; string s = metadata . get ( <string_literal> ) ; if ( s != null ) { trust <identifiersep> level = friend <identifiersep> trust . value <identifiersep> of ( s ) ; } else { trust <identifiersep> level = node . security <identifiersep> levels . get <identifiersep> default <identifiersep> friend <identifiersep> trust ( ) ; <LOG> } s = metadata . get ( <string_literal> ) ; if ( s != null ) { our <identifiersep> visibility = friend <identifiersep> visibility . value <identifiersep> of ( s ) ; } else { system . err . println ( <string_literal> + name + <string_literal> ) ; node . create <identifiersep> visibility <identifiersep> alert ( ) ; <ect>
public boolean read <identifiersep> extra <identifiersep> peer <identifiersep> data ( ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { return false ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { <LOG> return false ; } file [ ] extra <identifiersep> peer <identifiersep> data <identifiersep> files = extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . list <identifiersep> files ( ) ; if ( extra <identifiersep> peer <identifiersep> data <identifiersep> files == null ) { return false ; } boolean got <identifiersep> error = false ; boolean read <identifiersep> result = false ; <ect>
string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { <LOG> return false ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) + file . separator + file <identifiersep> number ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ) ; return false ; } return read <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( extra <identifiersep> peer <identifiersep> data <identifiersep> file , file <identifiersep> number ) ; <ect>
try { <comment> <LOG> } finally { try { br . close ( ) ; } catch ( io <identifiersep> exception e5 ) { logger . error ( this , <string_literal> + e5 + <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) , e5 ) ; } } if ( fs == null ) { <ect>
boolean parse <identifiersep> result = false ; try { parse <identifiersep> result = parse <identifiersep> extra <identifiersep> peer <identifiersep> data ( fs , extra <identifiersep> peer <identifiersep> data <identifiersep> file , file <identifiersep> number ) ; if ( ! parse <identifiersep> result ) { got <identifiersep> error = true ; } } catch ( fs <identifiersep> parse <identifiersep> exception e2 ) { <LOG> got <identifiersep> error = true ; } return ! got <identifiersep> error ; } private boolean parse <identifiersep> extra <identifiersep> peer <identifiersep> data ( simple <identifiersep> field <identifiersep> set fs , file extra <identifiersep> peer <identifiersep> data <identifiersep> file , int file <identifiersep> number ) throws fs <identifiersep> parse <identifiersep> exception { string extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> string = fs . get ( <string_literal> ) ; int extra <identifiersep> peer <identifiersep> data <identifiersep> type = - 1 ; try { <ect>
} else if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type == node . extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> peer <identifiersep> note ) { string peer <identifiersep> note <identifiersep> type <identifiersep> string = fs . get ( <string_literal> ) ; int peer <identifiersep> note <identifiersep> type = - 1 ; try { peer <identifiersep> note <identifiersep> type = integer . parse <identifiersep> int ( peer <identifiersep> note <identifiersep> type <identifiersep> string ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return false ; } if ( peer <identifiersep> note <identifiersep> type == node . peer <identifiersep> note <identifiersep> type <identifiersep> private <identifiersep> darknet <identifiersep> comment ) { synchronized ( this ) { try { private <identifiersep> darknet <identifiersep> comment = base64 . decode <identifiersep> utf8 ( fs . get ( <string_literal> ) ) ; } catch ( illegal <identifiersep> base64exception e ) { <ect>
private <identifiersep> darknet <identifiersep> comment = base64 . decode <identifiersep> utf8 ( fs . get ( <string_literal> ) ) ; } catch ( illegal <identifiersep> base64exception e ) { logger . error ( this , <string_literal> , e ) ; return false ; } private <identifiersep> darknet <identifiersep> comment <identifiersep> file <identifiersep> number = file <identifiersep> number ; } return true ; } <LOG> return false ; } else if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type == node . extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> queued <identifiersep> to <identifiersep> send <identifiersep> n2nm ) { boolean send <identifiersep> success = false ; int type = fs . get <identifiersep> int ( <string_literal> ) ; if ( is <identifiersep> connected ( ) ) { message n2nm ; <ect>
handle <identifiersep> fproxy <identifiersep> bookmark <identifiersep> feed ( fs , file <identifiersep> number ) ; return true ; } else if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type == node . extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> download ) { logger . normal ( this , <string_literal> + fs . to <identifiersep> string ( ) ) ; handle <identifiersep> fproxy <identifiersep> download <identifiersep> feed ( fs , file <identifiersep> number ) ; return true ; } <LOG> return false ; } public int write <identifiersep> new <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( simple <identifiersep> field <identifiersep> set fs , int extra <identifiersep> peer <identifiersep> data <identifiersep> type ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type > 0 ) fs . put <identifiersep> overwrite ( <string_literal> , integer . to <identifiersep> string ( extra <identifiersep> peer <identifiersep> data <identifiersep> type ) ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; <ect>
file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . mkdir ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return - 1 ; } } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { <LOG> return - 1 ; } integer [ ] local <identifiersep> file <identifiersep> numbers ; int next <identifiersep> file <identifiersep> number = 0 ; synchronized ( extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers ) { <comment> <ect>
fs . write <identifiersep> to ( bw ) ; bw . close ( ) ; } catch ( io <identifiersep> exception e ) { try { fos . close ( ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> } logger . error ( this , <string_literal> + e , e ) ; return - 1 ; } return next <identifiersep> file <identifiersep> number ; } public void delete <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( int file <identifiersep> number ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path , get <identifiersep> identity <identifiersep> string ( ) ) ; <ect>
return - 1 ; } return next <identifiersep> file <identifiersep> number ; } public void delete <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( int file <identifiersep> number ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path , get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { <LOG> return ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir , integer . to <identifiersep> string ( file <identifiersep> number ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { <ect>
return ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir , integer . to <identifiersep> string ( file <identifiersep> number ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { <LOG> return ; } synchronized ( extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers ) { extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers . remove ( file <identifiersep> number ) ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . delete ( ) ) { if ( extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file + <string_literal> + get <identifiersep> peer ( ) + <string_literal> ) ; <ect>
} else { logger . normal ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file + <string_literal> + get <identifiersep> peer ( ) ) ; } } } public void remove <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { <LOG> return ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return ; } integer [ ] local <identifiersep> file <identifiersep> numbers ; synchronized ( extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers ) { <ect>
public boolean rewrite <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( simple <identifiersep> field <identifiersep> set fs , int extra <identifiersep> peer <identifiersep> data <identifiersep> type , int file <identifiersep> number ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type > 0 ) fs . put <identifiersep> overwrite ( <string_literal> , integer . to <identifiersep> string ( extra <identifiersep> peer <identifiersep> data <identifiersep> type ) ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { <LOG> return false ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) + file . separator + file <identifiersep> number ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { <ect>
node . client <identifiersep> core . alerts . register ( user <identifiersep> alert ) ; } public void handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { final file <identifiersep> offer offer ; try { offer = new file <identifiersep> offer ( fs , false ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <LOG> return ; } long u = offer . uid ; synchronized ( this ) { if ( his <identifiersep> file <identifiersep> offers <identifiersep> by <identifiersep> uid . contains <identifiersep> key ( u ) ) return ; <comment> <ect>
fo . accept ( ) ; } public void reject <identifiersep> transfer ( long id ) { file <identifiersep> offer fo ; synchronized ( this ) { fo = his <identifiersep> file <identifiersep> offers <identifiersep> by <identifiersep> uid . remove ( id ) ; } if ( fo == null ) { <LOG> return ; } fo . reject ( ) ; } public void handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer <identifiersep> accepted ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; file <identifiersep> offer fo ; synchronized ( this ) { fo = ( my <identifiersep> file <identifiersep> offers <identifiersep> by <identifiersep> uid . get ( uid ) ) ; } if ( fo == null ) { <LOG> try { send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> bulk <identifiersep> send <identifiersep> aborted ( uid ) , null , node . node <identifiersep> stats . node <identifiersep> to <identifiersep> node <identifiersep> counter ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> return ; } file <identifiersep> offer fo ; synchronized ( this ) { fo = my <identifiersep> file <identifiersep> offers <identifiersep> by <identifiersep> uid . remove ( uid ) ; } fo . on <identifiersep> rejected ( ) ; } public void handle <identifiersep> fproxy <identifiersep> bookmark <identifiersep> feed ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { <ect>
description = base64 . decode <identifiersep> utf8 ( s ) ; uri = new freenet <identifiersep> uri ( fs . get ( <string_literal> ) ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; return ; } catch ( illegal <identifiersep> base64exception e ) { <LOG> return ; } bookmark <identifiersep> feed <identifiersep> user <identifiersep> alert user <identifiersep> alert = new bookmark <identifiersep> feed <identifiersep> user <identifiersep> alert ( this , name , description , has <identifiersep> an <identifiersep> active <identifiersep> link , file <identifiersep> number , uri , composed <identifiersep> time , sent <identifiersep> time , received <identifiersep> time ) ; node . client <identifiersep> core . alerts . register ( user <identifiersep> alert ) ; } public void handle <identifiersep> fproxy <identifiersep> download <identifiersep> feed ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { freenet <identifiersep> uri uri = null ; string description = null ; <ect>
description = base64 . decode <identifiersep> utf8 ( s ) ; uri = new freenet <identifiersep> uri ( fs . get ( <string_literal> ) ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; return ; } catch ( illegal <identifiersep> base64exception e ) { <LOG> return ; } download <identifiersep> feed <identifiersep> user <identifiersep> alert user <identifiersep> alert = new download <identifiersep> feed <identifiersep> user <identifiersep> alert ( this , description , file <identifiersep> number , uri , composed <identifiersep> time , sent <identifiersep> time , received <identifiersep> time ) ; node . client <identifiersep> core . alerts . register ( user <identifiersep> alert ) ; } @ override public string user <identifiersep> to <identifiersep> string ( ) { return <string_literal> + get <identifiersep> peer ( ) + <string_literal> + get <identifiersep> name ( ) ; <ect>
peer <identifiersep> added <identifiersep> time = 0 ; } <comment> <LOG> <comment> <ect>
byte <identifiersep> array <identifiersep> output <identifiersep> stream baos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; deflater <identifiersep> output <identifiersep> stream dos = new deflater <identifiersep> output <identifiersep> stream ( baos ) ; try { my <identifiersep> full <identifiersep> noderef . write <identifiersep> to ( dos ) ; dos . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> synchronized ( this ) { sending <identifiersep> full <identifiersep> noderef = false ; } return ; } byte [ ] data = baos . to <identifiersep> byte <identifiersep> array ( ) ; long uid = node . fast <identifiersep> weak <identifiersep> random . next <identifiersep> long ( ) ; random <identifiersep> access <identifiersep> buffer raf = new byte <identifiersep> array <identifiersep> random <identifiersep> access <identifiersep> buffer ( data ) ; <ect>
logger . error ( this , <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } catch ( io <identifiersep> exception e ) { synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { receiving <identifiersep> full <identifiersep> noderef = false ; } <LOG> return ; } try { process <identifiersep> new <identifiersep> noderef ( fs , false , false , true ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + darknet <identifiersep> peer <identifiersep> node . this + <string_literal> + e , e ) ; synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { <ect>
receiving <identifiersep> full <identifiersep> noderef = false ; } return ; } synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { full <identifiersep> field <identifiersep> set = fs ; } node . peers . write <identifiersep> peers <identifiersep> darknet ( ) ; } else { <LOG> } } finally { synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { receiving <identifiersep> full <identifiersep> noderef = false ; } } } } ) ; } catch ( runtime <identifiersep> exception e ) { synchronized ( this ) { <ect>
gc . set <identifiersep> time <identifiersep> zone ( time <identifiersep> zone . get <identifiersep> time <identifiersep> zone ( <string_literal> ) ) ; throw new peer <identifiersep> too <identifiersep> old <identifiersep> exception ( <string_literal> , <number_literal> , gc . get <identifiersep> time ( ) ) ; } byte [ ] pub ; try { pub = base64 . decode ( sfs . get ( <string_literal> ) ) ; } catch ( illegal <identifiersep> base64exception e ) { <LOG> throw new fs <identifiersep> parse <identifiersep> exception ( e ) ; } if ( pub . length > ecdsa . curves . p256 . modulus <identifiersep> size ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; ec <identifiersep> public <identifiersep> key key = ecdsa . get <identifiersep> public <identifiersep> key ( pub , ecdsa . curves . p256 ) ; if ( key == null ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; <ect>
for ( string phys : physical ) { peer p ; try { p = new peer ( phys , true , true ) ; } catch ( hostname <identifiersep> syntax <identifiersep> exception e ) { if ( from <identifiersep> local ) <LOG> system . err . println ( <string_literal> + phys ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; <ect>
if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { if ( from <identifiersep> local ) <LOG> system . err . println ( <string_literal> + phys ) ; continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; <ect>
if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( from <identifiersep> local ) <LOG> system . err . println ( <string_literal> + phys ) ; continue ; } if ( ! nominal <identifiersep> peer . contains ( p ) ) nominal <identifiersep> peer . add ( p ) ; } } } catch ( exception e1 ) { throw new fs <identifiersep> parse <identifiersep> exception ( e1 ) ; <ect>
string detected <identifiersep> udp <identifiersep> string = metadata . get ( <string_literal> ) ; p = null ; if ( detected <identifiersep> udp <identifiersep> string != null ) p = new peer ( detected <identifiersep> udp <identifiersep> string , false ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { p = null ; <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e ) { p = null ; logger . error ( this , <string_literal> + metadata . get ( <string_literal> ) + <string_literal> + e , e ) ; } if ( p != null ) detected <identifiersep> peer = p ; update <identifiersep> short <identifiersep> to <identifiersep> string ( ) ; <ect>
ark = new usk ( ssk , ark <identifiersep> no ) ; } else if ( for <identifiersep> diff <identifiersep> node <identifiersep> ref && ark <identifiersep> pub <identifiersep> key == null && my <identifiersep> ark != null && ark <identifiersep> no > - 1 ) { <comment> <LOG> return false ; } else return false ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + e , e ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + e , e ) ; <ect>
boolean can <identifiersep> send = cur != null && pf . can <identifiersep> send ( cur ) ; if ( can <identifiersep> send ) { <comment> <LOG> t = l ; } long l = pf . time <identifiersep> next <identifiersep> urgent ( can <identifiersep> send , now ) ; if ( l < now && log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; t = math . min ( t , l ) ; } return t ; <ect>
logger . warning ( this , <string_literal> + req + <string_literal> + peer <identifiersep> node . this , new exception ( <string_literal> ) ) ; this . local <identifiersep> rejected <identifiersep> overload ( <string_literal> , real <identifiersep> time ) ; <comment> <LOG> <comment> <ect>
if ( ( ! is <identifiersep> connected ( ) ) && ( ! dont <identifiersep> log ) ) { <comment> <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> ) ; } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; } } long now = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
synchronized ( this ) { disconnecting = false ; <comment> <LOG> return - 1 ; } } if ( previous <identifiersep> tracker != null ) { if ( arrays . equals ( outgoing <identifiersep> key , previous <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( incomming <identifiersep> key , previous <identifiersep> tracker . incomming <identifiersep> key ) ) { logger . error ( this , <string_literal> ) ; return - 1 ; <ect>
&& arrays . equals ( incomming <identifiersep> key , previous <identifiersep> tracker . incomming <identifiersep> key ) ) { logger . error ( this , <string_literal> ) ; return - 1 ; } } if ( unverified <identifiersep> tracker != null ) { if ( arrays . equals ( outgoing <identifiersep> key , unverified <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( incomming <identifiersep> key , unverified <identifiersep> tracker . incomming <identifiersep> key ) ) { <LOG> return - 1 ; } } handshake <identifiersep> count = 0 ; bogus <identifiersep> noderef = false ; <comment> <ect>
arrays . equals ( current <identifiersep> tracker . outgoing <identifiersep> key , previous <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( current <identifiersep> tracker . incomming <identifiersep> key , previous <identifiersep> tracker . incomming <identifiersep> key ) ) logger . error ( this , <string_literal> + current <identifiersep> tracker + <string_literal> + previous <identifiersep> tracker ) ; if ( previous <identifiersep> tracker != null && unverified <identifiersep> tracker != null && arrays . equals ( previous <identifiersep> tracker . outgoing <identifiersep> key , unverified <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( previous <identifiersep> tracker . incomming <identifiersep> key , unverified <identifiersep> tracker . incomming <identifiersep> key ) ) <LOG> time <identifiersep> last <identifiersep> sent <identifiersep> packet = now ; if ( packet <identifiersep> format == null ) { packet <identifiersep> format = new new <identifiersep> packet <identifiersep> format ( this , our <identifiersep> initial <identifiersep> msg <identifiersep> id , their <identifiersep> initial <identifiersep> msg <identifiersep> id ) ; } <comment> <ect>
changed <identifiersep> anything = true ; version = new <identifiersep> version ; if ( version != null ) { try { simple <identifiersep> version = version . get <identifiersep> arbitrary <identifiersep> build <identifiersep> number ( version ) ; } catch ( version <identifiersep> parse <identifiersep> exception e ) { <LOG> } } version . seen <identifiersep> version ( new <identifiersep> version ) ; } string new <identifiersep> last <identifiersep> good <identifiersep> version = fs . get ( <string_literal> ) ; if ( new <identifiersep> last <identifiersep> good <identifiersep> version != null ) { <comment> <ect>
try { p = new peer ( phys , true , true ) ; } catch ( hostname <identifiersep> syntax <identifiersep> exception e ) { logger . error ( this , <string_literal> + phys ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { <LOG> continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> if ( for <identifiersep> full <identifiersep> node <identifiersep> ref ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; } } catch ( exception e1 ) { logger . error ( this , <string_literal> + e1 , e1 ) ; throw new fs <identifiersep> parse <identifiersep> exception ( e1 ) ; } if ( log <identifiersep> minor ) <ect>
simple <identifiersep> field <identifiersep> set sfs = fs . subset ( <string_literal> ) ; if ( sfs != null ) { byte [ ] pub ; try { pub = base64 . decode ( sfs . get ( <string_literal> ) ) ; } catch ( illegal <identifiersep> base64exception e ) { <LOG> throw new fs <identifiersep> parse <identifiersep> exception ( e ) ; } if ( pub . length > ecdsa . curves . p256 . modulus <identifiersep> size ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; ec <identifiersep> public <identifiersep> key key = ecdsa . get <identifiersep> public <identifiersep> key ( pub , ecdsa . curves . p256 ) ; if ( key == null ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; <ect>
public void enter <identifiersep> mandatory <identifiersep> backoff ( string reason , boolean real <identifiersep> time ) { long now = system . current <identifiersep> time <identifiersep> millis ( ) ; synchronized ( this ) { long mandatory <identifiersep> backoff <identifiersep> until = real <identifiersep> time ? mandatory <identifiersep> backoff <identifiersep> until <identifiersep> rt : mandatory <identifiersep> backoff <identifiersep> until <identifiersep> bulk ; int mandatory <identifiersep> backoff <identifiersep> length = real <identifiersep> time ? mandatory <identifiersep> backoff <identifiersep> length <identifiersep> rt : mandatory <identifiersep> backoff <identifiersep> length <identifiersep> bulk ; if ( mandatory <identifiersep> backoff <identifiersep> until > - 1 && mandatory <identifiersep> backoff <identifiersep> until > now ) return ; <LOG> mandatory <identifiersep> backoff <identifiersep> until = now + ( mandatory <identifiersep> backoff <identifiersep> length / <number_literal> ) + node . fast <identifiersep> weak <identifiersep> random . next <identifiersep> int ( mandatory <identifiersep> backoff <identifiersep> length / <number_literal> ) ; mandatory <identifiersep> backoff <identifiersep> length *= mandatory <identifiersep> backoff <identifiersep> multiplier ; node . node <identifiersep> stats . report <identifiersep> mandatory <identifiersep> backoff ( reason , mandatory <identifiersep> backoff <identifiersep> until - now , real <identifiersep> time ) ; if ( real <identifiersep> time ) { mandatory <identifiersep> backoff <identifiersep> length <identifiersep> rt = mandatory <identifiersep> backoff <identifiersep> length ; <ect>
if ( my <identifiersep> ark . suggested <identifiersep> edition < fetched <identifiersep> edition + 1 ) my <identifiersep> ark = my <identifiersep> ark . copy ( fetched <identifiersep> edition + 1 ) ; } process <identifiersep> new <identifiersep> noderef ( fs , true , false , false ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <comment> <LOG> synchronized ( this ) { handshake <identifiersep> count = peer <identifiersep> node . max <identifiersep> handshake <identifiersep> count ; } } } public synchronized int get <identifiersep> peer <identifiersep> node <identifiersep> status ( ) { return peer <identifiersep> node <identifiersep> status ; } public string get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) { int status = get <identifiersep> peer <identifiersep> node <identifiersep> status ( ) ; <ect>
fs = new simple <identifiersep> field <identifiersep> set ( ref , false , true , false ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; got <identifiersep> ark ( fs , edition ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> } result . as <identifiersep> bucket ( ) . free ( ) ; } public synchronized boolean no <identifiersep> contact <identifiersep> details ( ) { return handshake <identifiersep> i <identifiersep> ps == null || handshake <identifiersep> i <identifiersep> ps . length == 0 ; } public synchronized void report <identifiersep> incoming <identifiersep> bytes ( int length ) { total <identifiersep> input <identifiersep> since <identifiersep> startup += length ; total <identifiersep> bytes <identifiersep> exchanged <identifiersep> with <identifiersep> current <identifiersep> tracker += length ; <ect>
long second <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( second <identifiersep> time - first <identifiersep> time ) > <number_literal> ) logger . error ( this , <string_literal> + ( second <identifiersep> time - first <identifiersep> time ) + <string_literal> + user <identifiersep> to <identifiersep> string ( ) ) ; if ( local <identifiersep> handshake <identifiersep> i <identifiersep> ps . length == 0 ) { long third <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( third <identifiersep> time - second <identifiersep> time ) > <number_literal> ) <LOG> return null ; } long loop <identifiersep> time1 = system . current <identifiersep> time <identifiersep> millis ( ) ; list < peer > valid <identifiersep> i <identifiersep> ps = new array <identifiersep> list < peer > ( local <identifiersep> handshake <identifiersep> i <identifiersep> ps . length ) ; boolean allow <identifiersep> local <identifiersep> addresses = allow <identifiersep> local <identifiersep> addresses ( ) ; for ( peer peer : local <identifiersep> handshake <identifiersep> i <identifiersep> ps ) { freenet <identifiersep> inet <identifiersep> address addr = peer . get <identifiersep> freenet <identifiersep> address ( ) ; <ect>
logger . error ( this , <string_literal> + this + <string_literal> ) ; } rto = rto * <number_literal> ; if ( rto > max <identifiersep> rto ) rto = max <identifiersep> rto ; consecutive <identifiersep> rto <identifiersep> backoffs ++ ; if ( consecutive <identifiersep> rto <identifiersep> backoffs > max <identifiersep> consecutive <identifiersep> rto <identifiersep> backoffs ) { <LOG> consecutive <identifiersep> rto <identifiersep> backoffs = 0 ; reported <identifiersep> rtt = false ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + rto + <string_literal> + short <identifiersep> to <identifiersep> string ( ) + <string_literal> + consecutive <identifiersep> rto <identifiersep> backoffs ) ; } private long resend <identifiersep> bytes <identifiersep> sent ; public final byte <identifiersep> counter resend <identifiersep> byte <identifiersep> counter = new byte <identifiersep> counter ( ) { @ override <ect>
boolean ignore <identifiersep> local <identifiersep> vs <identifiersep> remote = node . node <identifiersep> stats . ignore <identifiersep> local <identifiersep> vs <identifiersep> remote <identifiersep> bandwidth <identifiersep> liability ( ) ; if ( ! is <identifiersep> routable ( ) ) return null ; if ( is <identifiersep> in <identifiersep> mandatory <identifiersep> backoff ( system . current <identifiersep> time <identifiersep> millis ( ) , real <identifiersep> time ) ) return null ; synchronized ( routed <identifiersep> to <identifiersep> lock ) { load <identifiersep> stats = last <identifiersep> incoming <identifiersep> load <identifiersep> stats ; if ( load <identifiersep> stats == null ) { <LOG> if ( tag . add <identifiersep> routed <identifiersep> to ( peer <identifiersep> node . this , offered <identifiersep> key ) ) { <comment> <ect>
<comment> <LOG> } } } <comment> <ect>
fs = new simple <identifiersep> field <identifiersep> set ( node <identifiersep> reference , false , true , true ) ; if ( ! fs . get <identifiersep> end <identifiersep> marker ( ) . ends <identifiersep> with ( <string_literal> ) ) { logger . error ( this , <string_literal> + fs . get <identifiersep> end <identifiersep> marker ( ) + <string_literal> ) ; return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . wrong <identifiersep> encoding ; } fs . set <identifiersep> end <identifiersep> marker ( <string_literal> ) ; <comment> <LOG> return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . cant <identifiersep> parse ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t . get <identifiersep> message ( ) , t ) ; return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . internal <identifiersep> error ; } peer <identifiersep> node pn ; try { <ect>
return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . cant <identifiersep> parse ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . cant <identifiersep> parse ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . invalid <identifiersep> signature ; } catch ( throwable t ) { <LOG> return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . internal <identifiersep> error ; } if ( arrays . equals ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash , node . get <identifiersep> darknet <identifiersep> pub <identifiersep> key <identifiersep> hash ( ) ) ) { return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . try <identifiersep> to <identifiersep> add <identifiersep> self ; } if ( ! this . node . add <identifiersep> peer <identifiersep> connection ( pn ) ) { return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . already <identifiersep> in <identifiersep> reference ; } return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . ok ; <ect>
received <identifiersep> cookie session <identifiersep> cookie = context . get <identifiersep> cookie ( null , m <identifiersep> cookie <identifiersep> path , m <identifiersep> cookie <identifiersep> name ) ; return session <identifiersep> cookie == null ? null : uuid . from <identifiersep> string ( session <identifiersep> cookie . get <identifiersep> value ( ) ) ; } catch ( parse <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; return null ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { <LOG> return null ; } } <comment> <ect>
else core . node . set <identifiersep> master <identifiersep> password ( password , false ) ; } catch ( already <identifiersep> set <identifiersep> password <identifiersep> exception e ) { send <identifiersep> change <identifiersep> password <identifiersep> form ( ctx , false , false , new <identifiersep> physical <identifiersep> level . name ( ) ) ; return ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { <LOG> page <identifiersep> node page = ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> page <identifiersep> node ( l10n <identifiersep> sec ( <string_literal> ) , ctx ) ; page <identifiersep> node = page . outer ; html <identifiersep> node content <identifiersep> node = page . content ; content = ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> infobox ( <string_literal> , l10n <identifiersep> sec ( <string_literal> ) , content <identifiersep> node , <string_literal> , true ) . add <identifiersep> child ( <string_literal> , <string_literal> , <string_literal> ) ; <ect>
core . node . change <identifiersep> master <identifiersep> password ( password , <string_literal> , false ) ; } catch ( io <identifiersep> exception e ) { if ( ! core . node . get <identifiersep> master <identifiersep> password <identifiersep> file ( ) . exists ( ) ) { <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; string msg = <string_literal> + l10n <identifiersep> sec ( <string_literal> ) + <string_literal> + l10n <identifiersep> sec ( <string_literal> ) + <string_literal> + l10n <identifiersep> sec ( <string_literal> ) + <string_literal> ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; print <identifiersep> writer pw = new print <identifiersep> writer ( sw ) ; e . print <identifiersep> stack <identifiersep> trace ( pw ) ; <ect>
} else { if ( request . is <identifiersep> part <identifiersep> set ( <string_literal> ) ) { string master <identifiersep> password = request . get <identifiersep> part <identifiersep> as <identifiersep> string <identifiersep> failsafe ( <string_literal> , <number_literal> ) ; if ( master <identifiersep> password . is <identifiersep> empty ( ) ) { send <identifiersep> password <identifiersep> page ( ctx , true , null ) ; return ; } <LOG> try { node . set <identifiersep> master <identifiersep> password ( master <identifiersep> password , false ) ; } catch ( already <identifiersep> set <identifiersep> password <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; logger . error ( this , <string_literal> ) ; multi <identifiersep> value <identifiersep> table < string , string > headers = new multi <identifiersep> value <identifiersep> table < string , string > ( ) ; <ect>
return ; } system . err . println ( <string_literal> ) ; try { node . set <identifiersep> master <identifiersep> password ( master <identifiersep> password , false ) ; } catch ( already <identifiersep> set <identifiersep> password <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; <LOG> multi <identifiersep> value <identifiersep> table < string , string > headers = new multi <identifiersep> value <identifiersep> table < string , string > ( ) ; headers . put ( <string_literal> , <string_literal> ) ; ctx . send <identifiersep> reply <identifiersep> headers ( <number_literal> , <string_literal> , headers , null , 0 ) ; return ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { send <identifiersep> password <identifiersep> form <identifiersep> page ( true , ctx ) ; <ect>
try { filter <identifiersep> status status = apply <identifiersep> filter ( data , result <identifiersep> bucket , mime <identifiersep> type , operation , core ) ; result <identifiersep> mime <identifiersep> type = status . mime <identifiersep> type ; } catch ( unsafe <identifiersep> content <identifiersep> type <identifiersep> exception e ) { unsafe = true ; } catch ( io <identifiersep> exception e ) { <LOG> throw e ; } if ( unsafe ) { send <identifiersep> error <identifiersep> page ( ctx , <number_literal> , l10n ( <string_literal> ) , l10n ( <string_literal> ) ) ; } else { if ( result <identifiersep> handling == result <identifiersep> handling . display ) { ctx . send <identifiersep> reply <identifiersep> headers ( <number_literal> , <string_literal> , null , result <identifiersep> mime <identifiersep> type , result <identifiersep> bucket . size ( ) ) ; <ect>
page <identifiersep> node page = ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> page <identifiersep> node ( l10n ( <string_literal> ) , ctx ) ; html <identifiersep> node page <identifiersep> node = page . outer ; html <identifiersep> node content <identifiersep> node = page . content ; if ( node . is <identifiersep> using <identifiersep> wrapper ( ) ) { ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> infobox ( <string_literal> , l10n ( <string_literal> ) , content <identifiersep> node , <string_literal> , true ) . add <identifiersep> child ( <string_literal> , l10n ( <string_literal> , <string_literal> , wrapper <identifiersep> manager . get <identifiersep> properties ( ) . get <identifiersep> property ( <string_literal> ) ) ) ; <LOG> wrapper <identifiersep> manager . request <identifiersep> thread <identifiersep> dump ( ) ; } else { ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> infobox ( <string_literal> , l10n ( <string_literal> ) , content <identifiersep> node , <string_literal> , true ) . add <identifiersep> child ( <string_literal> , l10n ( <string_literal> ) ) ; } this . write <identifiersep> html <identifiersep> reply ( ctx , <number_literal> , <string_literal> , page <identifiersep> node . generate ( ) ) ; } else if ( request . is <identifiersep> part <identifiersep> set ( <string_literal> ) ) { <ect>
string link = get <identifiersep> link ( e . new <identifiersep> uri , requested <identifiersep> mime <identifiersep> type , max <identifiersep> size , httprequest . get <identifiersep> param ( <string_literal> , null ) , httprequest . is <identifiersep> parameter <identifiersep> set ( <string_literal> ) , max <identifiersep> retries , override <identifiersep> size ) ; try { uri = new uri ( link ) ; inner <identifiersep> handle <identifiersep> method <identifiersep> get ( uri , httprequest , ctx , recursion ) ; return ; } catch ( uri <identifiersep> syntax <identifiersep> exception e1 ) { <LOG> } } toadlet . write <identifiersep> permanent <identifiersep> redirect ( ctx , msg , get <identifiersep> link ( e . new <identifiersep> uri , requested <identifiersep> mime <identifiersep> type , max <identifiersep> size , httprequest . get <identifiersep> param ( <string_literal> , null ) , httprequest . is <identifiersep> parameter <identifiersep> set ( <string_literal> ) , max <identifiersep> retries , override <identifiersep> size ) ) ; } else if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> big ) { page <identifiersep> node page = ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> page <identifiersep> node ( l10n ( <string_literal> ) , ctx ) ; html <identifiersep> node page <identifiersep> node = page . outer ; html <identifiersep> node content <identifiersep> node = page . content ; <ect>
push <identifiersep> data <identifiersep> manager = new push <identifiersep> data <identifiersep> manager ( get <identifiersep> ticker ( ) ) ; interval <identifiersep> push <identifiersep> manager = new interval <identifiersep> pusher <identifiersep> manager ( get <identifiersep> ticker ( ) , push <identifiersep> data <identifiersep> manager ) ; bookmark <identifiersep> manager = new bookmark <identifiersep> manager ( core , public <identifiersep> gateway <identifiersep> mode ( ) ) ; try { f <identifiersep> proxy <identifiersep> toadlet . maybe <identifiersep> create <identifiersep> f <identifiersep> proxy <identifiersep> etc ( core , node , node . config , this ) ; } catch ( io <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } public void set <identifiersep> core ( node <identifiersep> client <identifiersep> core core ) { this . core = core ; } <comment> <ect>
} ) ; enable <identifiersep> activelinks = fproxy <identifiersep> config . get <identifiersep> boolean ( <string_literal> ) ; fproxy <identifiersep> config . register ( <string_literal> , f <identifiersep> proxy <identifiersep> toadlet . max <identifiersep> length <identifiersep> no <identifiersep> progress , config <identifiersep> item <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , new f <identifiersep> proxy <identifiersep> passthru <identifiersep> max <identifiersep> size <identifiersep> no <identifiersep> progress ( ) , true ) ; f <identifiersep> proxy <identifiersep> toadlet . max <identifiersep> length <identifiersep> no <identifiersep> progress = fproxy <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; fproxy <identifiersep> config . register ( <string_literal> , f <identifiersep> proxy <identifiersep> toadlet . max <identifiersep> length <identifiersep> with <identifiersep> progress , config <identifiersep> item <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , new f <identifiersep> proxy <identifiersep> passthru <identifiersep> max <identifiersep> size <identifiersep> progress ( ) , true ) ; f <identifiersep> proxy <identifiersep> toadlet . max <identifiersep> length <identifiersep> with <identifiersep> progress = fproxy <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; <LOG> fproxy <identifiersep> config . register ( <string_literal> , false , config <identifiersep> item <identifiersep> order ++ , true , true , <string_literal> , <string_literal> , new boolean <identifiersep> callback ( ) { @ override public boolean get ( ) { return enable <identifiersep> caching <identifiersep> for <identifiersep> chk <identifiersep> and <identifiersep> ssk <identifiersep> keys ; } @ override public void set ( boolean value ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception , node <identifiersep> need <identifiersep> restart <identifiersep> exception { <ect>
return was <identifiersep> public <identifiersep> gateway <identifiersep> mode ; } public void start ( ) { if ( my <identifiersep> thread != null ) try { maybe <identifiersep> get <identifiersep> network <identifiersep> interface ( ) ; my <identifiersep> thread . start ( ) ; logger . normal ( this , <string_literal> + bind <identifiersep> to + ' : ' + port ) ; <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; } } public void finish <identifiersep> start ( ) { core . node . security <identifiersep> levels . add <identifiersep> network <identifiersep> threat <identifiersep> level <identifiersep> listener ( new security <identifiersep> level <identifiersep> listener < network <identifiersep> threat <identifiersep> level > ( ) { @ override public void on <identifiersep> change ( network <identifiersep> threat <identifiersep> level old <identifiersep> level , <ect>
public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; try { toadlet <identifiersep> context <identifiersep> impl . handle ( sock , simple <identifiersep> toadlet <identifiersep> server . this , page <identifiersep> maker , get <identifiersep> user <identifiersep> alert <identifiersep> manager ( ) , bookmark <identifiersep> manager ) ; } catch ( throwable t ) { <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; logger . error ( this , <string_literal> + t , t ) ; } finally { synchronized ( simple <identifiersep> toadlet <identifiersep> server . this ) { fproxy <identifiersep> connections -- ; simple <identifiersep> toadlet <identifiersep> server . this . notify <identifiersep> all ( ) ; <ect>
class <identifiersep> loader loader = bookmark <identifiersep> manager . class . get <identifiersep> class <identifiersep> loader ( ) ; <comment> <LOG> } finally { closer . close ( in ) ; default <identifiersep> bookmarks = default <identifiersep> bookmarks ; } } private static volatile boolean log <identifiersep> minor ; static { logger . register <identifiersep> log <identifiersep> threshold <identifiersep> callback ( new log <identifiersep> threshold <identifiersep> callback ( ) { <ect>
write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> , <string_literal> , file . get <identifiersep> filename ( ) ) , ctx , false , true ) ; return false ; } catch ( malformed <identifiersep> url <identifiersep> exception mue1 ) { write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> ) , ctx , false , true ) ; return false ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { <LOG> write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; <comment> <ect>
return false ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <LOG> write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> ) , ctx ) ; return false ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <ect>
client <identifiersep> put <identifiersep> dir = new client <identifiersep> put <identifiersep> dir ( fcp . get <identifiersep> global <identifiersep> forever <identifiersep> client ( ) , furi , identifier , integer . max <identifiersep> value , request <identifiersep> starter . bulk <identifiersep> splitfile <identifiersep> priority <identifiersep> class , persistence . forever , null , false , ! compress , - 1 , file , null , false , <comment> false , true , false , false , node . fork <identifiersep> on <identifiersep> cacheable <identifiersep> default , high <identifiersep> level <identifiersep> simple <identifiersep> client <identifiersep> impl . extra <identifiersep> inserts <identifiersep> single <identifiersep> block , high <identifiersep> level <identifiersep> simple <identifiersep> client <identifiersep> impl . extra <identifiersep> inserts <identifiersep> splitfile <identifiersep> header , false , override <identifiersep> splitfile <identifiersep> key , fcp . core ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + file + <string_literal> + furi + <string_literal> + identifier ) ; if ( client <identifiersep> put <identifiersep> dir != null ) try { fcp . start <identifiersep> blocking ( client <identifiersep> put <identifiersep> dir , context ) ; } catch ( identifier <identifiersep> collision <identifiersep> exception e ) { <LOG> write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { send <identifiersep> persistence <identifiersep> disabled <identifiersep> error ( ctx ) ; return false ; } write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; <ect>
else <comment> <LOG> mime <identifiersep> type = default <identifiersep> mime <identifiersep> types . default <identifiersep> mime <identifiersep> type ; } if ( failure <identifiersep> code == fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> validation <identifiersep> unknown <identifiersep> mime ) { mime <identifiersep> type = content <identifiersep> filter . strip <identifiersep> mime <identifiersep> type ( mime <identifiersep> type ) ; linked <identifiersep> list < download <identifiersep> request <identifiersep> status > list = failed <identifiersep> unknown <identifiersep> mime <identifiersep> type . get ( mime <identifiersep> type ) ; if ( list == null ) { list = new linked <identifiersep> list < download <identifiersep> request <identifiersep> status > ( ) ; <ect>
} catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> return false ; } finally { closer . close ( fis ) ; } } private void save <identifiersep> completed <identifiersep> identifiers ( ) { file <identifiersep> output <identifiersep> stream fos = null ; buffered <identifiersep> writer bw = null ; <ect>
for ( string identifier : identifiers ) bw . write ( identifier + ' \\ n' ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( io <identifiersep> exception e ) { <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + req + <string_literal> + identifier , new exception ( <string_literal> ) ) ; return ; } if ( req instanceof client <identifiersep> get ) { freenet <identifiersep> uri uri = ( ( client <identifiersep> get ) req ) . get <identifiersep> uri ( ) ; if ( uri == null ) { <LOG> return ; } long size = ( ( client <identifiersep> get ) req ) . get <identifiersep> data <identifiersep> size ( ) ; get <identifiersep> completed <identifiersep> event event = new get <identifiersep> completed <identifiersep> event ( identifier , uri , size ) ; synchronized ( completed <identifiersep> gets ) { completed <identifiersep> gets . put ( identifier , event ) ; } core . alerts . register ( event ) ; <ect>
synchronized ( completed <identifiersep> puts ) { completed <identifiersep> puts . put ( identifier , event ) ; } core . alerts . register ( event ) ; } else if ( req instanceof client <identifiersep> put <identifiersep> dir ) { freenet <identifiersep> uri uri = ( ( client <identifiersep> put <identifiersep> dir ) req ) . get <identifiersep> final <identifiersep> uri ( ) ; if ( uri == null ) { <LOG> return ; } long size = ( ( client <identifiersep> put <identifiersep> dir ) req ) . get <identifiersep> total <identifiersep> data <identifiersep> size ( ) ; int files = ( ( client <identifiersep> put <identifiersep> dir ) req ) . get <identifiersep> number <identifiersep> of <identifiersep> files ( ) ; put <identifiersep> dir <identifiersep> completed <identifiersep> event event = new put <identifiersep> dir <identifiersep> completed <identifiersep> event ( identifier , uri , size , files ) ; synchronized ( completed <identifiersep> put <identifiersep> dirs ) { completed <identifiersep> put <identifiersep> dirs . put ( identifier , event ) ; <ect>
} catch ( plugin <identifiersep> http <identifiersep> exception e ) { send <identifiersep> error <identifiersep> page ( ctx , plugin <identifiersep> http <identifiersep> exception . code , e . message , e . location ) ; } catch ( socket <identifiersep> exception e ) { ctx . force <identifiersep> disconnect ( ) ; } catch ( throwable t ) { ctx . force <identifiersep> disconnect ( ) ; <LOG> write <identifiersep> internal <identifiersep> error ( t , ctx ) ; } } <comment> <ect>
. append ( e . get <identifiersep> message ( ) ) . append ( ' \\ n' ) ; } catch ( node <identifiersep> need <identifiersep> restart <identifiersep> exception e ) { need <identifiersep> restart = true ; } catch ( exception e ) { errbuf . append ( o . get <identifiersep> name ( ) ) . append ( ' ' ) . append ( e ) . append ( ' \\ n' ) ; <LOG> } } else if ( log <identifiersep> minor ) { logger . minor ( this , prefix + ' . ' + config <identifiersep> name + <string_literal> ) ; } } } <comment> <ect>
<comment> public void set <identifiersep> auto <identifiersep> update ( boolean enabled ) { try { config . get ( <string_literal> ) . set ( <string_literal> , enabled ) ; } catch ( config <identifiersep> exception e ) { <LOG> } } <comment> public void set <identifiersep> u <identifiersep> pn <identifiersep> p ( final boolean enable <identifiersep> u <identifiersep> pn <identifiersep> p ) { <ect>
<comment> <LOG> return first <identifiersep> time <identifiersep> wizard <identifiersep> toadlet . wizard <identifiersep> step . bandwidth <identifiersep> rate . name ( ) ; } set <identifiersep> wizard <identifiersep> complete ( ) ; return first <identifiersep> time <identifiersep> wizard <identifiersep> toadlet . wizard <identifiersep> step . complete . name ( ) ; } <comment> <ect>
long slashdot <identifiersep> cache <identifiersep> size = math . min ( size / <number_literal> , max <identifiersep> slashdot <identifiersep> cache <identifiersep> size ) ; long store <identifiersep> size = size - ( client <identifiersep> cache <identifiersep> size + slashdot <identifiersep> cache <identifiersep> size ) ; system . out . println ( <string_literal> + fields . long <identifiersep> to <identifiersep> string ( store <identifiersep> size , true ) ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( store <identifiersep> size , true ) ) ; if ( config . get ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) . equals ( <string_literal> ) ) config . get ( <string_literal> ) . set ( <string_literal> , <string_literal> ) ; <LOG> config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( client <identifiersep> cache <identifiersep> size , true ) ) ; if ( config . get ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) . equals ( <string_literal> ) ) config . get ( <string_literal> ) . set ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> + fields . long <identifiersep> to <identifiersep> string ( slashdot <identifiersep> cache <identifiersep> size , true ) ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( slashdot <identifiersep> cache <identifiersep> size , true ) ) ; logger . normal ( this , <string_literal> + selected <identifiersep> store <identifiersep> size ) ; <ect>
if ( config . get ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) . equals ( <string_literal> ) ) config . get ( <string_literal> ) . set ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> + fields . long <identifiersep> to <identifiersep> string ( slashdot <identifiersep> cache <identifiersep> size , true ) ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( slashdot <identifiersep> cache <identifiersep> size , true ) ) ; logger . normal ( this , <string_literal> + selected <identifiersep> store <identifiersep> size ) ; } catch ( config <identifiersep> exception e ) { <LOG> } } private long max <identifiersep> datastore <identifiersep> size ( ) { long max <identifiersep> memory = node <identifiersep> starter . get <identifiersep> memory <identifiersep> limit <identifiersep> bytes ( ) ; if ( max <identifiersep> memory == long . max <identifiersep> value ) return <number_literal> * <number_literal> * <number_literal> ; <comment> <ect>
final int ki <identifiersep> b = <number_literal> ; if ( downstream <identifiersep> bits < 0 ) { <comment> <LOG> downstream <identifiersep> bytes = - 1 ; } else { downstream <identifiersep> bytes = downstream <identifiersep> bits / <number_literal> ; } if ( upstream <identifiersep> bits < 0 ) { <comment> <ect>
<comment> <LOG> } catch ( freenet . config . node <identifiersep> need <identifiersep> restart <identifiersep> exception e ) { <comment> <ect>
this . bucketfactory = ctx . get <identifiersep> bucket <identifiersep> factory ( ) ; this . method = method ; if ( data != null ) { try { this . parse <identifiersep> multi <identifiersep> part <identifiersep> data ( ) ; } catch ( io <identifiersep> exception ioe ) { <LOG> } } } <comment> @ override public string get <identifiersep> path ( ) { return this . uri . get <identifiersep> path ( ) ; <ect>
is = part . get <identifiersep> input <identifiersep> stream ( ) ; dis = new data <identifiersep> input <identifiersep> stream ( is ) ; byte [ ] buf = new byte [ ( int ) math . min ( part . size ( ) , max <identifiersep> length ) ] ; dis . read <identifiersep> fully ( buf , 0 , buf . length ) ; return buf ; } catch ( io <identifiersep> exception ioe ) { <LOG> return new byte [ 0 ] ; } finally { closer . close ( dis ) ; if ( dis == null ) closer . close ( is ) ; <comment> <ect>
} catch ( fetch <identifiersep> exception e ) { synchronized ( this ) { this . failed = e ; this . finished = true ; } } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <LOG> synchronized ( this ) { this . failed = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; this . finished = true ; } } } <comment> private boolean check <identifiersep> cache ( client <identifiersep> context context ) { <ect>
public void finish <identifiersep> cancel ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + uri + <string_literal> + max <identifiersep> size ) ; try { getter . cancel ( tracker . context ) ; } catch ( throwable t ) { <comment> <LOG> } bucket d ; synchronized ( this ) { d = data ; cancelled = true ; } if ( d != null ) { try { <ect>
this . reply <identifiersep> cookies = null ; this . closed = false ; this . uri = uri ; sock <identifiersep> output <identifiersep> stream = sock . get <identifiersep> output <identifiersep> stream ( ) ; remote <identifiersep> addr = sock . get <identifiersep> inet <identifiersep> address ( ) ; if ( log <identifiersep> debug ) <LOG> this . bf = bf ; this . pagemaker = page <identifiersep> maker ; this . container = container ; this . user <identifiersep> alert <identifiersep> manager = user <identifiersep> alert <identifiersep> manager ; this . bookmark <identifiersep> manager = bookmark <identifiersep> manager ; <comment> <ect>
multi <identifiersep> value <identifiersep> table < string , string > headers = new multi <identifiersep> value <identifiersep> table < string , string > ( ) ; while ( true ) { string line = lis . read <identifiersep> line ( <number_literal> , <number_literal> , false ) ; <comment> <LOG> if ( line . length ( ) == 0 ) break ; int index = line . index <identifiersep> of ( ' : ' ) ; if ( index < 0 ) { throw new parse <identifiersep> exception ( <string_literal> , - 1 ) ; } string before = line . substring ( 0 , index ) . to <identifiersep> lower <identifiersep> case ( ) ; string after = line . substring ( index + 1 ) ; <ect>
<comment> <LOG> try { string msg = <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; print <identifiersep> writer pw = new print <identifiersep> writer ( sw ) ; t . print <identifiersep> stack <identifiersep> trace ( pw ) ; <ect>
if ( l10n != null ) { <comment> <LOG> } else { navigation <identifiersep> title = new <identifiersep> navigation <identifiersep> title ; } } if ( navigation <identifiersep> link != null ) { string new <identifiersep> navigation <identifiersep> link = l10n . get <identifiersep> string ( navigation <identifiersep> link ) ; if ( new <identifiersep> navigation <identifiersep> link == null ) { logger . error ( this , <string_literal> + l10n + <string_literal> ) ; <ect>
<comment> list <identifiersep> item . add <identifiersep> attribute ( <string_literal> , get <identifiersep> plugin <identifiersep> l10n <identifiersep> css <identifiersep> identifier ( menu . plugin , text ) ) ; string new <identifiersep> title = menu . plugin . get <identifiersep> string ( menu <identifiersep> item <identifiersep> title ) ; if ( new <identifiersep> title == null ) { <LOG> } else { menu <identifiersep> item <identifiersep> title = new <identifiersep> title ; } string new <identifiersep> text = menu . plugin . get <identifiersep> string ( text ) ; if ( new <identifiersep> text == null ) { logger . error ( this , <string_literal> + menu . plugin + <string_literal> ) ; } else { <ect>
try { real <identifiersep> run ( ) ; } catch ( io <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + e , e ) ; } catch ( throwable t ) { <LOG> } finally { <comment> <ect>
logger . debug ( this , <string_literal> + msg , new exception ( <string_literal> ) ) ; if ( msg == null ) throw new null <identifiersep> pointer <identifiersep> exception ( ) ; boolean never <identifiersep> drop <identifiersep> a <identifiersep> message = handler . server . never <identifiersep> drop <identifiersep> a <identifiersep> message ( ) ; int max <identifiersep> queue <identifiersep> length = handler . server . max <identifiersep> message <identifiersep> queue <identifiersep> length ( ) ; synchronized ( out <identifiersep> queue ) { if ( closed <identifiersep> output <identifiersep> queue ) { <LOG> <comment> <ect>
<comment> <LOG> return ; } } out <identifiersep> queue . add ( msg ) ; out <identifiersep> queue . notify <identifiersep> all ( ) ; } } public void on <identifiersep> closed ( ) { synchronized ( out <identifiersep> queue ) { out <identifiersep> queue . notify <identifiersep> all ( ) ; <ect>
temp <identifiersep> bucket = create <identifiersep> bucket ( bf , len , server ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; file <identifiersep> util . copy ( is , new null <identifiersep> output <identifiersep> stream ( ) , len ) ; throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . internal <identifiersep> error , e . to <identifiersep> string ( ) , get <identifiersep> identifier ( ) , is <identifiersep> global ( ) ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <LOG> file <identifiersep> util . copy ( is , new null <identifiersep> output <identifiersep> stream ( ) , len ) ; throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . persistence <identifiersep> disabled , null , get <identifiersep> identifier ( ) , is <identifiersep> global ( ) ) ; } bucket <identifiersep> tools . copy <identifiersep> from ( temp <identifiersep> bucket , is , len ) ; this . bucket = temp <identifiersep> bucket ; } @ override protected void write <identifiersep> data ( output <identifiersep> stream os ) throws io <identifiersep> exception { <ect>
handler . server . core . client <identifiersep> context . job <identifiersep> runner . queue ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { try { client <identifiersep> request req = handler . remove <identifiersep> persistent <identifiersep> forever <identifiersep> request ( global , identifier ) ; if ( req == null ) { <LOG> return false ; } return true ; } catch ( message <identifiersep> invalid <identifiersep> exception e ) { fcp <identifiersep> message err = new protocol <identifiersep> error <identifiersep> message ( e . protocol <identifiersep> code , false , e . get <identifiersep> message ( ) , e . ident , e . global ) ; handler . output <identifiersep> handler . queue ( err ) ; return false ; <ect>
} catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . ref <identifiersep> parse <identifiersep> error , <string_literal> + e . get <identifiersep> message ( ) , identifier , false ) ; } if ( arrays . equals ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash , node . get <identifiersep> opennet <identifiersep> pub <identifiersep> key <identifiersep> hash ( ) ) ) throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . cannot <identifiersep> peer <identifiersep> with <identifiersep> self , <string_literal> , identifier , false ) ; if ( ! node . add <identifiersep> peer <identifiersep> connection ( pn ) ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . duplicate <identifiersep> peer <identifiersep> ref , <string_literal> , identifier , false ) ; } <LOG> } else { try { pn = node . create <identifiersep> new <identifiersep> darknet <identifiersep> node ( fs , trust , visibility ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . ref <identifiersep> parse <identifiersep> error , <string_literal> + e . get <identifiersep> message ( ) , identifier , false ) ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { <ect>
boolean removed <identifiersep> from <identifiersep> running = false ; if ( req == null ) { for ( client <identifiersep> request r : completed <identifiersep> unacked <identifiersep> requests ) { if ( r . get <identifiersep> identifier ( ) . equals ( identifier ) ) { req = r ; completed <identifiersep> unacked <identifiersep> requests . remove ( r ) ; <LOG> break ; } } if ( req == null ) { for ( client <identifiersep> request r : running <identifiersep> persistent <identifiersep> requests ) { if ( r . get <identifiersep> identifier ( ) . equals ( identifier ) ) { req = r ; running <identifiersep> persistent <identifiersep> requests . remove ( r ) ; <ect>
system . out . println ( <string_literal> + bind <identifiersep> to + ' : ' + port + <string_literal> ) ; } this . network <identifiersep> interface = temp <identifiersep> network <identifiersep> interface ; } public void maybe <identifiersep> start ( ) { if ( this . enabled ) { maybe <identifiersep> get <identifiersep> network <identifiersep> interface ( ) ; logger . normal ( this , <string_literal> + bind <identifiersep> to + ' : ' + port + ' . ' ) ; <LOG> if ( this . network <identifiersep> interface != null ) { thread t = new thread ( this , <string_literal> ) ; t . set <identifiersep> daemon ( true ) ; t . start ( ) ; } } else { logger . normal ( this , <string_literal> ) ; <ect>
try { network <identifiersep> interface . wait <identifiersep> bound ( ) ; real <identifiersep> run ( ) ; } catch ( io <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + e , e ) ; } catch ( throwable t ) { <LOG> } if ( wrapper <identifiersep> manager . has <identifiersep> shutdown <identifiersep> hook <identifiersep> been <identifiersep> triggered ( ) ) return ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } } } private void real <identifiersep> run ( ) throws io <identifiersep> exception { <ect>
public boolean run ( client <identifiersep> context context ) { boolean succeeded = false ; try { global <identifiersep> forever <identifiersep> client . remove <identifiersep> all ( core . client <identifiersep> context ) ; succeeded = true ; } catch ( throwable t ) { <LOG> system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; } finally { success . set ( succeeded ) ; done . count <identifiersep> down ( ) ; <ect>
global <identifiersep> forever <identifiersep> client . remove <identifiersep> all ( core . client <identifiersep> context ) ; succeeded = true ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } finally { success . set ( succeeded ) ; done . count <identifiersep> down ( ) ; } return true ; } } , native <identifiersep> thread . high <identifiersep> priority ) ; while ( done . get <identifiersep> count ( ) > 0 ) { <ect>
if ( preferred != null ) new <identifiersep> data = preferred ; else new <identifiersep> data = core . temp <identifiersep> bucket <identifiersep> factory . make <identifiersep> bucket ( orig <identifiersep> data . size ( ) ) ; bucket <identifiersep> tools . copy ( orig <identifiersep> data , new <identifiersep> data ) ; } catch ( io <identifiersep> exception e ) { <LOG> return null ; } } return new cache <identifiersep> fetch <identifiersep> result ( new client <identifiersep> metadata ( get . get <identifiersep> mime <identifiersep> type ( ) ) , new <identifiersep> data , filtered ) ; } return null ; } } <ect>
protected client <identifiersep> requester get <identifiersep> client <identifiersep> request ( ) { return putter ; } @ override protected fcp <identifiersep> message persistent <identifiersep> tag <identifiersep> message ( ) { <comment> <LOG> if ( putter == null ) logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; <comment> <ect>
return new persistent <identifiersep> put <identifiersep> dir ( identifier , public <identifiersep> uri , uri , verbosity , priority <identifiersep> class , persistence , global , default <identifiersep> name , manifest <identifiersep> elements , client <identifiersep> token , started , ctx . max <identifiersep> insert <identifiersep> retries , ctx . dont <identifiersep> compress , ctx . compressor <identifiersep> descriptor , was <identifiersep> disk <identifiersep> put , is <identifiersep> real <identifiersep> time ( ) , putter != null ? putter . get <identifiersep> splitfile <identifiersep> crypto <identifiersep> key ( ) : null , this . ctx . get <identifiersep> compatibility <identifiersep> mode ( ) ) ; } private boolean is <identifiersep> real <identifiersep> time ( ) { <comment> <LOG> return false ; } return low <identifiersep> level <identifiersep> client . real <identifiersep> time <identifiersep> flag ( ) ; } @ override protected string get <identifiersep> type <identifiersep> name ( ) { return <string_literal> ; } @ override <ect>
public void should <identifiersep> update ( ) { log <identifiersep> debug = logger . should <identifiersep> log ( log <identifiersep> level . debug , this ) ; } } ) ; } public void send ( output <identifiersep> stream os ) throws io <identifiersep> exception { simple <identifiersep> field <identifiersep> set sfs = get <identifiersep> field <identifiersep> set ( ) ; if ( sfs == null ) { <LOG> return ; } sfs . set <identifiersep> end <identifiersep> marker ( get <identifiersep> end <identifiersep> string ( ) ) ; string msg = sfs . to <identifiersep> string ( ) ; os . write ( ( get <identifiersep> name ( ) + ' \\ n' ) . get <identifiersep> bytes ( <string_literal> ) ) ; os . write ( msg . get <identifiersep> bytes ( <string_literal> ) ) ; if ( log <identifiersep> debug ) { <ect>
sfs . set <identifiersep> end <identifiersep> marker ( get <identifiersep> end <identifiersep> string ( ) ) ; string msg = sfs . to <identifiersep> string ( ) ; os . write ( ( get <identifiersep> name ( ) + ' \\ n' ) . get <identifiersep> bytes ( <string_literal> ) ) ; os . write ( msg . get <identifiersep> bytes ( <string_literal> ) ) ; if ( log <identifiersep> debug ) { logger . debug ( this , <string_literal> + get <identifiersep> name ( ) + ' \\ n' + sfs . to <identifiersep> string ( ) ) ; <LOG> } } string get <identifiersep> end <identifiersep> string ( ) { return <string_literal> ; } public abstract simple <identifiersep> field <identifiersep> set get <identifiersep> field <identifiersep> set ( ) ; public abstract string get <identifiersep> name ( ) ; <comment> <ect>
if ( target <identifiersep> file . exists ( ) ) { if ( target <identifiersep> file . length ( ) == 0 ) { <comment> <LOG> } if ( target <identifiersep> file . exists ( ) ) throw new io <identifiersep> exception ( <string_literal> + target <identifiersep> file ) ; } ret = new file <identifiersep> bucket ( return <identifiersep> filename , false , true , false , false ) ; if ( filter <identifiersep> data ) { string name = return <identifiersep> filename . get <identifiersep> name ( ) ; int idx = name . last <identifiersep> index <identifiersep> of ( ' . ' ) ; <ect>
@ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { logger . minor ( this , <string_literal> + identifier ) ; bucket data = binary <identifiersep> blob ? state . get <identifiersep> blob <identifiersep> bucket ( ) : result . as <identifiersep> bucket ( ) ; synchronized ( this ) { if ( succeeded ) { <LOG> return ; <comment> <ect>
handle <identifiersep> compatibility <identifiersep> mode ( ( splitfile <identifiersep> compatibility <identifiersep> mode <identifiersep> event ) ce , context ) ; return ; } else if ( ce instanceof expected <identifiersep> hashes <identifiersep> event ) { expected <identifiersep> hashes <identifiersep> event event = ( expected <identifiersep> hashes <identifiersep> event ) ce ; synchronized ( this ) { if ( expected <identifiersep> hashes != null ) { <LOG> return ; } else { progress = this . expected <identifiersep> hashes = new expected <identifiersep> hashes ( event , identifier , global ) ; } } verbosity <identifiersep> mask = client <identifiersep> get . verbosity <identifiersep> expected <identifiersep> hashes ; if ( ( verbosity & verbosity <identifiersep> mask ) == 0 ) return ; <ect>
file target = get <identifiersep> dest <identifiersep> filename ( ) ; if ( target != null ) target = new file ( target . get <identifiersep> path ( ) ) ; bucket shadow = ( finished && succeeded ) ? get <identifiersep> bucket ( ) : null ; if ( shadow != null ) { if ( data <identifiersep> size != shadow . size ( ) ) { <LOG> shadow = null ; } else { shadow = shadow . create <identifiersep> shadow ( ) ; } } boolean filter <identifiersep> data ; boolean overridden <identifiersep> data <identifiersep> type ; filter <identifiersep> data = fctx . filter <identifiersep> data ; <ect>
fctx = new fetch <identifiersep> context ( inner <identifiersep> dis ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } finally { inner <identifiersep> dis . close ( ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> } if ( fctx == null ) { fctx = context . get <identifiersep> default <identifiersep> persistent <identifiersep> fetch <identifiersep> context ( ) ; } this . fctx = fctx ; fctx . event <identifiersep> producer . add <identifiersep> event <identifiersep> listener ( this ) ; if ( dis . read <identifiersep> boolean ( ) ) extension <identifiersep> check = dis . read <identifiersep> utf ( ) ; <ect>
return <identifiersep> bucket <identifiersep> direct = null ; succeeded = false ; finished = false ; } finally { inner <identifiersep> dis . close ( ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> return <identifiersep> bucket <identifiersep> direct = null ; succeeded = false ; finished = false ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; return <identifiersep> bucket <identifiersep> direct = null ; <ect>
data <identifiersep> input <identifiersep> stream inner <identifiersep> dis = new data <identifiersep> input <identifiersep> stream ( checker . checksum <identifiersep> reader <identifiersep> with <identifiersep> length ( dis , context . temp <identifiersep> bucket <identifiersep> factory , <number_literal> ) ) ; try { get <identifiersep> failed <identifiersep> message = new get <identifiersep> failed <identifiersep> message ( inner <identifiersep> dis , req <identifiersep> id , found <identifiersep> data <identifiersep> length , found <identifiersep> data <identifiersep> mime <identifiersep> type ) ; started = true ; } catch ( io <identifiersep> exception e ) { <LOG> finished = false ; get <identifiersep> failed <identifiersep> message = null ; } finally { inner <identifiersep> dis . close ( ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; <ect>
fcp <identifiersep> message err = new protocol <identifiersep> error <identifiersep> message ( protocol <identifiersep> error <identifiersep> message . message <identifiersep> parse <identifiersep> error , false , <string_literal> + fs . get <identifiersep> end <identifiersep> marker ( ) , fs . get ( <string_literal> ) , fs . get <identifiersep> boolean ( <string_literal> , false ) ) ; handler . output <identifiersep> handler . queue ( err ) ; continue ; } fcp <identifiersep> message msg ; try { if ( log <identifiersep> debug ) <LOG> msg = fcp <identifiersep> message . create ( message <identifiersep> type , fs , handler . bf , handler . server . core . persistent <identifiersep> temp <identifiersep> bucket <identifiersep> factory ) ; if ( msg == null ) continue ; } catch ( message <identifiersep> invalid <identifiersep> exception e ) { if ( first <identifiersep> message ) { fcp <identifiersep> message err = new protocol <identifiersep> error <identifiersep> message ( protocol <identifiersep> error <identifiersep> message . client <identifiersep> hello <identifiersep> must <identifiersep> be <identifiersep> first <identifiersep> message , true , null , null , false ) ; handler . output <identifiersep> handler . queue ( err ) ; <ect>
pi = node . plugin <identifiersep> manager . start <identifiersep> plugin <identifiersep> file ( plugin <identifiersep> url , store ) ; } else if ( typename <identifiersep> freenet . equals ( type ) ) { pi = node . plugin <identifiersep> manager . start <identifiersep> plugin <identifiersep> freenet ( plugin <identifiersep> url , store ) ; } else if ( typename <identifiersep> url . equals ( type ) ) { pi = node . plugin <identifiersep> manager . start <identifiersep> plugin <identifiersep> url ( plugin <identifiersep> url , store ) ; } else { <LOG> handler . output <identifiersep> handler . queue ( new protocol <identifiersep> error <identifiersep> message ( protocol <identifiersep> error <identifiersep> message . internal <identifiersep> error , false , <string_literal> , identifier , false ) ) ; return ; } if ( pi == null ) { handler . output <identifiersep> handler . queue ( new protocol <identifiersep> error <identifiersep> message ( protocol <identifiersep> error <identifiersep> message . no <identifiersep> such <identifiersep> plugin , false , <string_literal> + plugin <identifiersep> url + <string_literal> , identifier , false ) ) ; } else { handler . output <identifiersep> handler . queue ( new plugin <identifiersep> info <identifiersep> message ( pi , identifier , true ) ) ; <ect>
logger . error ( this , <string_literal> + this ) ; return null ; } simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( false ) ; simple <identifiersep> field <identifiersep> set values = new simple <identifiersep> field <identifiersep> set ( false ) ; for ( hash <identifiersep> result hash : hashes ) { if ( hash == null ) { <LOG> return null ; } values . put <identifiersep> overwrite ( hash . type . name ( ) , hash . hash <identifiersep> as <identifiersep> hex ( ) ) ; } fs . put ( <string_literal> , values ) ; fs . put <identifiersep> overwrite ( <string_literal> , identifier ) ; fs . put ( <string_literal> , global ) ; return fs ; <ect>
filter <identifiersep> status status = apply <identifiersep> filter ( input , output , handler . server . core . client <identifiersep> context ) ; result <identifiersep> charset = status . charset ; result <identifiersep> mime <identifiersep> type = status . mime <identifiersep> type ; } catch ( unsafe <identifiersep> content <identifiersep> type <identifiersep> exception e ) { unsafe = true ; } catch ( io <identifiersep> exception e ) { <LOG> throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . internal <identifiersep> error , e . to <identifiersep> string ( ) , identifier , false ) ; } finally { closer . close ( input ) ; closer . close ( output ) ; } filter <identifiersep> result <identifiersep> message response = new filter <identifiersep> result <identifiersep> message ( identifier , result <identifiersep> charset , result <identifiersep> mime <identifiersep> type , unsafe , result <identifiersep> bucket ) ; handler . output <identifiersep> handler . queue ( response ) ; <ect>
boolean is <identifiersep> global ( ) { return global ; } public void free <identifiersep> data ( ) { if ( bucket == null ) { if ( data <identifiersep> length ( ) < = 0 ) return ; <comment> <LOG> return ; } bucket . free ( ) ; } } <ect>
<comment> <LOG> } this . overridden <identifiersep> data <identifiersep> type = overridden <identifiersep> data <identifiersep> type ; this . failure <identifiersep> code = failure <identifiersep> code ; this . mime <identifiersep> type = mime ; this . data <identifiersep> size = size ; this . dest <identifiersep> filename = dest ; this . detected <identifiersep> compat <identifiersep> modes = compat ; <ect>
public int get <identifiersep> priority ( ) { native <identifiersep> thread . priority <identifiersep> level priority = native <identifiersep> thread . priority <identifiersep> level . norm <identifiersep> priority ; if ( message <identifiersep> handler instanceof prioritized <identifiersep> message <identifiersep> handler ) { try { priority = ( ( prioritized <identifiersep> message <identifiersep> handler ) message <identifiersep> handler ) . get <identifiersep> priority ( message ) ; } catch ( throwable t ) { <LOG> } } return priority . value ; } <comment> @ override public string to <identifiersep> string ( ) { <comment> <ect>
input <identifiersep> stream is = null ; try { is = data . get <identifiersep> input <identifiersep> stream ( ) ; sha256 . hash ( is , md ) ; } catch ( io <identifiersep> exception e ) { sha256 . return <identifiersep> message <identifiersep> digest ( md ) ; <LOG> throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . could <identifiersep> not <identifiersep> read <identifiersep> file , <string_literal> + e , identifier , global ) ; } finally { closer . close ( is ) ; } found <identifiersep> hash = md . digest ( ) ; sha256 . return <identifiersep> message <identifiersep> digest ( md ) ; <ect>
persistence , orig <identifiersep> filename , client <identifiersep> metadata . get <identifiersep> mime <identifiersep> type ( ) , client . is <identifiersep> global <identifiersep> queue , get <identifiersep> data <identifiersep> size ( ) , client <identifiersep> token , started , ctx . max <identifiersep> insert <identifiersep> retries , target <identifiersep> filename , binary <identifiersep> blob , this . ctx . get <identifiersep> compatibility <identifiersep> mode ( ) , this . ctx . dont <identifiersep> compress , this . ctx . compressor <identifiersep> descriptor , is <identifiersep> real <identifiersep> time ( ) , putter != null ? putter . get <identifiersep> splitfile <identifiersep> crypto <identifiersep> key ( ) : null ) ; } private boolean is <identifiersep> real <identifiersep> time ( ) { <comment> <LOG> return false ; } return low <identifiersep> level <identifiersep> client . real <identifiersep> time <identifiersep> flag ( ) ; } @ override protected string get <identifiersep> type <identifiersep> name ( ) { return <string_literal> ; } @ override <ect>
subset . put ( <string_literal> , e . get <identifiersep> size ( ) ) ; if ( mime <identifiersep> override != null ) subset . put <identifiersep> single ( <string_literal> , mime <identifiersep> override ) ; <comment> <LOG> } else if ( data instanceof file <identifiersep> bucket ) { subset . put <identifiersep> single ( <string_literal> , <string_literal> ) ; subset . put <identifiersep> single ( <string_literal> , ( ( file <identifiersep> bucket ) data ) . get <identifiersep> file ( ) . get <identifiersep> path ( ) ) ; } else if ( data instanceof padded <identifiersep> ephemerally <identifiersep> encrypted <identifiersep> bucket || data instanceof null <identifiersep> bucket || data instanceof persistent <identifiersep> temp <identifiersep> file <identifiersep> bucket || data instanceof temp <identifiersep> bucket <identifiersep> factory . temp <identifiersep> bucket || data instanceof encrypted <identifiersep> random <identifiersep> access <identifiersep> bucket ) { subset . put <identifiersep> single ( <string_literal> , <string_literal> ) ; } else { <ect>
sfs . put <identifiersep> single ( <string_literal> , extra ) ; sfs . put ( <string_literal> , fatal ) ; sfs . put ( <string_literal> , global ) ; return sfs ; } @ override public void run ( fcp <identifiersep> connection <identifiersep> handler handler , node node ) { <LOG> } @ override public string get <identifiersep> name ( ) { return <string_literal> ; } @ override public string to <identifiersep> string ( ) { return super . to <identifiersep> string ( ) + <string_literal> + code + <string_literal> + extra + <string_literal> + fatal + <string_literal> + ident + <string_literal> + global ; <ect>
<comment> <LOG> throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + source , e ) ; } } @ override input <identifiersep> stream get <identifiersep> input <identifiersep> stream ( plugin <identifiersep> progress progress ) throws io <identifiersep> exception { url <identifiersep> connection url <identifiersep> connection = get <identifiersep> source ( ) . open <identifiersep> connection ( ) ; url <identifiersep> connection . set <identifiersep> use <identifiersep> caches ( false ) ; url <identifiersep> connection . set <identifiersep> allow <identifiersep> user <identifiersep> interaction ( false ) ; <ect>
} catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> + source , e ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + source , e ) ; } } @ override input <identifiersep> stream get <identifiersep> input <identifiersep> stream ( final plugin <identifiersep> progress progress ) throws io <identifiersep> exception , plugin <identifiersep> not <identifiersep> found <identifiersep> exception { freenet <identifiersep> uri uri = get <identifiersep> source ( ) ; <LOG> while ( true ) { try { progress . set <identifiersep> downloading ( ) ; hlsc . add <identifiersep> event <identifiersep> hook ( new client <identifiersep> event <identifiersep> listener ( ) { @ override public void receive ( client <identifiersep> event ce , client <identifiersep> context context ) { <ect>
if ( toadlet <identifiersep> links . size ( ) < 1 ) return false ; return toadlet <identifiersep> links . remove ( linkfrom ) ; } public void start <identifiersep> shutdown <identifiersep> plugin ( plugin <identifiersep> manager manager , boolean reloading ) { unregister ( manager , reloading ) ; <comment> <LOG> try { plug . terminate ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> , t ) ; system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
<comment> <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; } synchronized ( this ) { stopping = true ; } } public boolean finish <identifiersep> shutdown <identifiersep> plugin ( plugin <identifiersep> manager manager , long max <identifiersep> wait <identifiersep> time , boolean reloading ) { boolean success = true ; if ( thread != null ) { <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; <comment> <ect>
plug . handle ( replysender , plugparams , data2 , access ) ; } catch ( thread <identifiersep> death td ) { throw td ; <comment> <LOG> } } } <ect>
try { ks . store ( tmp <identifiersep> fos , new char [ 0 ] ) ; } finally { closer . close ( tmp <identifiersep> fos ) ; } system . out . println ( <string_literal> ) ; } catch ( exception e ) { <LOG> throw new io <identifiersep> exception ( <string_literal> + e ) ; } finally { closer . close ( fis ) ; } system . set <identifiersep> property ( <string_literal> , tmp <identifiersep> keystore . to <identifiersep> string ( ) ) ; return super . get <identifiersep> input <identifiersep> stream ( progress ) ; } private input <identifiersep> stream get <identifiersep> cert ( ) throws io <identifiersep> exception { <ect>
return true ; } } ) ; to <identifiersep> start = pmconfig . get <identifiersep> string <identifiersep> arr ( <string_literal> ) ; if ( last <identifiersep> version < <number_literal> && contains ( to <identifiersep> start , <string_literal> ) && ! contains ( to <identifiersep> start , <string_literal> ) ) { to <identifiersep> start = arrays . copy <identifiersep> of ( to <identifiersep> start , to <identifiersep> start . length + 1 ) ; to <identifiersep> start [ to <identifiersep> start . length - 1 ] = <string_literal> ; <LOG> } if ( contains ( to <identifiersep> start , <string_literal> ) ) { for ( int i = 0 ; i < to <identifiersep> start . length ; i ++ ) { if ( <string_literal> . equals ( to <identifiersep> start [ i ] ) ) to <identifiersep> start [ i ] = <string_literal> ; } system . err . println ( <string_literal> ) ; } <comment> <ect>
long now = system . current <identifiersep> time <identifiersep> millis ( ) ; long deadline = now + max <identifiersep> wait <identifiersep> time ; while ( true ) { int delta = ( int ) ( deadline - now ) ; if ( delta < = 0 ) { string list = plugin <identifiersep> list ( wrappers ) ; <LOG> system . err . println ( <string_literal> + list ) ; } else { for ( iterator < plugin <identifiersep> info <identifiersep> wrapper > it = wrappers . list <identifiersep> iterator ( ) ; it . has <identifiersep> next ( ) ; ) { plugin <identifiersep> info <identifiersep> wrapper pi = it . next ( ) ; system . out . println ( <string_literal> + pi . get <identifiersep> filename ( ) ) ; if ( pi . finish <identifiersep> shutdown <identifiersep> plugin ( this , delta , false ) ) { <ect>
string list = plugin <identifiersep> list ( wrappers ) ; logger . error ( this , <string_literal> + list ) ; system . err . println ( <string_literal> + list ) ; } else { for ( iterator < plugin <identifiersep> info <identifiersep> wrapper > it = wrappers . list <identifiersep> iterator ( ) ; it . has <identifiersep> next ( ) ; ) { plugin <identifiersep> info <identifiersep> wrapper pi = it . next ( ) ; <LOG> if ( pi . finish <identifiersep> shutdown <identifiersep> plugin ( this , delta , false ) ) { it . remove ( ) ; } } if ( wrappers . is <identifiersep> empty ( ) ) { logger . normal ( this , <string_literal> ) ; system . out . println ( <string_literal> ) ; return ; <ect>
it . remove ( ) ; } } if ( wrappers . is <identifiersep> empty ( ) ) { logger . normal ( this , <string_literal> ) ; system . out . println ( <string_literal> ) ; return ; } string list = plugin <identifiersep> list ( wrappers ) ; <LOG> system . err . println ( <string_literal> + list ) ; } } } private static string plugin <identifiersep> list ( array <identifiersep> list < plugin <identifiersep> info <identifiersep> wrapper > wrappers ) { string <identifiersep> buffer sb = new string <identifiersep> buffer ( ) ; for ( plugin <identifiersep> info <identifiersep> wrapper pi : wrappers ) { sb . append ( pi . get <identifiersep> filename ( ) ) ; sb . append ( ' \\ n' ) ; <ect>
old <identifiersep> alert = plugins <identifiersep> failed <identifiersep> load . put ( filename , new <identifiersep> alert ) ; } core . alerts . register ( new <identifiersep> alert ) ; core . alerts . unregister ( old <identifiersep> alert ) ; } catch ( unsupported <identifiersep> class <identifiersep> version <identifiersep> error e ) { logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> + filename + <string_literal> ) ; logger . error ( this , <string_literal> + filename + <string_literal> ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , l10n ( <string_literal> , <string_literal> , filename ) ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; <ect>
} catch ( unsupported <identifiersep> class <identifiersep> version <identifiersep> error e ) { logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; system . err . println ( <string_literal> + filename + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> + filename + <string_literal> ) ; <LOG> plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , l10n ( <string_literal> , <string_literal> , filename ) ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; synchronized ( plugin <identifiersep> wrappers ) { old <identifiersep> alert = plugins <identifiersep> failed <identifiersep> load . put ( filename , new <identifiersep> alert ) ; } core . alerts . register ( new <identifiersep> alert ) ; <ect>
synchronized ( plugin <identifiersep> wrappers ) { old <identifiersep> alert = plugins <identifiersep> failed <identifiersep> load . put ( filename , new <identifiersep> alert ) ; } core . alerts . register ( new <identifiersep> alert ) ; core . alerts . unregister ( old <identifiersep> alert ) ; } catch ( throwable e ) { logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> + filename + <string_literal> ) ; logger . error ( this , <string_literal> + filename + <string_literal> ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , e ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; <ect>
core . alerts . unregister ( old <identifiersep> alert ) ; } catch ( throwable e ) { logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; system . err . println ( <string_literal> + filename + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> + filename + <string_literal> ) ; <LOG> plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , e ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; synchronized ( plugin <identifiersep> wrappers ) { old <identifiersep> alert = plugins <identifiersep> failed <identifiersep> load . put ( filename , new <identifiersep> alert ) ; } core . alerts . register ( new <identifiersep> alert ) ; <ect>
<comment> public void remove <identifiersep> cached <identifiersep> copy ( string plugin <identifiersep> specification ) { if ( plugin <identifiersep> specification == null ) { <comment> <LOG> return ; } int last <identifiersep> slash = plugin <identifiersep> specification . last <identifiersep> index <identifiersep> of ( ' / ' ) ; string plugin <identifiersep> filename ; if ( last <identifiersep> slash == - 1 ) <comment> last <identifiersep> slash = plugin <identifiersep> specification . last <identifiersep> index <identifiersep> of ( ' \\ \\ ' ) ; <ect>
return ; for ( string target : targets ) { toadlet <identifiersep> list . remove ( target ) ; logger . normal ( this , <string_literal> + target + <string_literal> + pi . get <identifiersep> plugin <identifiersep> class <identifiersep> name ( ) + ' / ' ) ; } } catch ( throwable ex ) { <LOG> } } } public void remove <identifiersep> toadlet <identifiersep> symlinks ( plugin <identifiersep> info <identifiersep> wrapper pi ) { synchronized ( toadlet <identifiersep> list ) { string rm = null ; try { string targets [ ] = pi . get <identifiersep> plugin <identifiersep> toadlet <identifiersep> symlinks ( ) ; if ( targets == null ) <ect>
<comment> private fred <identifiersep> plugin load <identifiersep> plugin ( plugin <identifiersep> down <identifiersep> loader < ? > pdl , string name , plugin <identifiersep> progress progress , boolean ignore <identifiersep> old ) throws plugin <identifiersep> not <identifiersep> found <identifiersep> exception { pdl . set <identifiersep> source ( name ) ; <comment> file plugin <identifiersep> directory = node . get <identifiersep> plugin <identifiersep> dir ( ) ; if ( ( plugin <identifiersep> directory . exists ( ) && ! plugin <identifiersep> directory . is <identifiersep> directory ( ) ) || ( ! plugin <identifiersep> directory . exists ( ) && ! plugin <identifiersep> directory . mkdirs ( ) ) ) { <LOG> throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } <comment> string filename = pdl . get <identifiersep> plugin <identifiersep> name ( name ) ; boolean plugin <identifiersep> is <identifiersep> local = pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> file ; file plugin <identifiersep> file = new file ( plugin <identifiersep> directory , filename + <string_literal> + system . current <identifiersep> time <identifiersep> millis ( ) ) ; <comment> <ect>
while ( ( read = plugin <identifiersep> input <identifiersep> stream . read ( buffer ) ) != - 1 ) { plugin <identifiersep> output <identifiersep> stream . write ( buffer , 0 , read ) ; } plugin <identifiersep> output <identifiersep> stream . close ( ) ; if ( temp <identifiersep> plugin <identifiersep> file . length ( ) == 0 ) throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; if ( ! file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> plugin <identifiersep> file , plugin <identifiersep> file ) ) { <LOG> throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } <comment> <ect>
testsum = get <identifiersep> file <identifiersep> digest ( plugin <identifiersep> file , <string_literal> ) ; } if ( digest != null ) { if ( ! ( digest . equals <identifiersep> ignore <identifiersep> case ( testsum ) ) ) { logger . error ( this , <string_literal> + digest + <string_literal> + testsum ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + digest + <string_literal> + testsum ) ; } } } catch ( io <identifiersep> exception ioe1 ) { <LOG> if ( temp <identifiersep> plugin <identifiersep> file != null ) temp <identifiersep> plugin <identifiersep> file . delete ( ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + ioe1 . get <identifiersep> message ( ) , ioe1 ) ; } finally { closer . close ( plugin <identifiersep> output <identifiersep> stream ) ; closer . close ( plugin <identifiersep> input <identifiersep> stream ) ; <ect>
logger . error ( this , <string_literal> ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } attributes main <identifiersep> attributes = manifest . get <identifiersep> main <identifiersep> attributes ( ) ; if ( main <identifiersep> attributes == null ) { <LOG> plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } plugin <identifiersep> main <identifiersep> class <identifiersep> name = main <identifiersep> attributes . get <identifiersep> value ( <string_literal> ) ; if ( plugin <identifiersep> main <identifiersep> class <identifiersep> name == null ) { logger . error ( this , <string_literal> ) ; <ect>
<comment> <LOG> } plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> too <identifiersep> old <identifiersep> exception ( <string_literal> + min <identifiersep> ver + <string_literal> + ver ) ; } } if ( object instanceof fred <identifiersep> plugin <identifiersep> l10n ) { ( ( fred <identifiersep> plugin <identifiersep> l10n ) object ) . set <identifiersep> language ( node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> selected <identifiersep> language ( ) ) ; } if ( object instanceof fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n ) { <ect>
return ( fred <identifiersep> plugin ) object ; } catch ( io <identifiersep> exception ioe1 ) { logger . error ( this , <string_literal> , ioe1 ) ; plugin <identifiersep> file . delete ( ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ioe1 ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception cnfe1 ) { <LOG> plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + cnfe1 . get <identifiersep> message ( ) + <string_literal> , cnfe1 ) ; } catch ( instantiation <identifiersep> exception ie1 ) { logger . error ( this , <string_literal> , ie1 ) ; <ect>
} catch ( instantiation <identifiersep> exception ie1 ) { logger . error ( this , <string_literal> , ie1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ie1 ) ; } catch ( illegal <identifiersep> access <identifiersep> exception iae1 ) { <LOG> plugin <identifiersep> file . delete ( ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , iae1 ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe1 ) { logger . error ( this , <string_literal> , ncdfe1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; <ect>
} catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe1 ) { logger . error ( this , <string_literal> , ncdfe1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ncdfe1 ) ; } catch ( throwable t ) { <LOG> plugin <identifiersep> file . delete ( ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + t , t ) ; } } } return null ; } <comment> <ect>
executor . execute ( new runnable ( ) { @ override public void run ( ) { try { plug . set <identifiersep> language ( lang ) ; } catch ( throwable t ) { <LOG> } } } , <string_literal> ) ; } else if ( pi . is <identifiersep> base <identifiersep> l10n <identifiersep> plugin ( ) ) { final fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n plug = ( fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n ) ( pi . plug ) ; executor . execute ( new runnable ( ) { @ override public void run ( ) { <ect>
node . executor . execute ( new runnable ( ) { @ override public void run ( ) { try { target . on <identifiersep> reply ( pluginname , client <identifiersep> side <identifiersep> identifier , params , bucket ) ; } catch ( throwable t ) { <LOG> } } } , <string_literal> + pluginname ) ; } } <ect>
this . load <identifiersep> override <identifiersep> file <identifiersep> or <identifiersep> backup ( ) ; } catch ( io <identifiersep> exception e ) { this . translation <identifiersep> override = null ; logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; } this . current <identifiersep> translation = this . load <identifiersep> translation ( lang ) ; if ( this . current <identifiersep> translation == null ) { <LOG> this . current <identifiersep> translation = null ; } } <comment> <ect>
in = this . cl . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( this . get <identifiersep> l10n <identifiersep> file <identifiersep> name ( lang ) ) ; if ( in != null ) { result = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( in , false , false ) ; } else { system . err . println ( <string_literal> + this . get <identifiersep> l10n <identifiersep> file <identifiersep> name ( lang ) ) ; } } catch ( exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; result = null ; } finally { closer . close ( in ) ; } return result ; } <comment> <ect>
<comment> private string get <identifiersep> fallback <identifiersep> string ( string key ) { this . load <identifiersep> fallback ( ) ; string result = this . fallback <identifiersep> translation . get ( key ) ; if ( result == null ) { <LOG> system . err . println ( <string_literal> + key + <string_literal> ) ; new exception ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; } <comment> <ect>
private list < html <identifiersep> node > get <identifiersep> html <identifiersep> with <identifiersep> substitutions ( string key , string [ ] patterns , html <identifiersep> node [ ] values ) { for ( string value : get <identifiersep> strings ( key ) ) { <comment> <LOG> } } <comment> <ect>
try { compressor . compressor <identifiersep> type . lzma <identifiersep> new . decompress ( is = data . get <identifiersep> input <identifiersep> stream ( ) , os , data . size ( ) , expected <identifiersep> size ) ; } catch ( compression <identifiersep> output <identifiersep> size <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; wrapper . set ( e ) ; } catch ( io <identifiersep> exception e ) { <LOG> wrapper . set ( e ) ; } finally { try { os . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
<comment> <LOG> continue ; } long size = entry . get <identifiersep> size ( ) ; if ( name . equals ( <string_literal> ) ) got <identifiersep> metadata = true ; if ( size > max <identifiersep> archived <identifiersep> file <identifiersep> size && ! name . equals ( element ) ) { add <identifiersep> error <identifiersep> element ( ctx , key , name , <string_literal> + size + <string_literal> + max <identifiersep> archived <identifiersep> file <identifiersep> size , true ) ; <ect>
throw new archive <identifiersep> failure <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } } } private string strip <identifiersep> leading <identifiersep> slashes ( string name ) { while ( name . length ( ) > 1 && name . char <identifiersep> at ( 0 ) == ' / ' ) name = name . substring ( 1 ) ; return name ; } <comment> <ect>
synchronized ( this ) { while ( true ) { archive <identifiersep> store <identifiersep> item item ; if ( cached <identifiersep> data < = max <identifiersep> cached <identifiersep> data && stored <identifiersep> data . size ( ) < = max <identifiersep> cached <identifiersep> elements ) return ; if ( stored <identifiersep> data . is <identifiersep> empty ( ) ) { <comment> <LOG> return ; } item = stored <identifiersep> data . pop <identifiersep> value ( ) ; long space = item . space <identifiersep> used ( ) ; cached <identifiersep> data -= space ; <comment> <ect>
mode = m ; error <identifiersep> codes = null ; new <identifiersep> uri = null ; this . expected <identifiersep> size = expected <identifiersep> size ; this . expected <identifiersep> mime <identifiersep> type = expected <identifiersep> mime <identifiersep> type ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode m , long expected <identifiersep> size , boolean finalized <identifiersep> size , string expected <identifiersep> mime <identifiersep> type , freenet <identifiersep> uri uri ) { super ( get <identifiersep> message ( m ) ) ; extra <identifiersep> message = null ; this . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type = finalized <identifiersep> size ; <ect>
this . mode = mode ; error <identifiersep> codes = null ; init <identifiersep> cause ( t ) ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , string reason , throwable t ) { super ( reason + <string_literal> + get <identifiersep> message ( mode ) + <string_literal> + t . get <identifiersep> message ( ) ) ; extra <identifiersep> message = t . get <identifiersep> message ( ) ; this . mode = mode ; <ect>
extra <identifiersep> message = msg ; error <identifiersep> codes = null ; this . mode = mode ; new <identifiersep> uri = uri ; expected <identifiersep> size = - 1 ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception e , fetch <identifiersep> exception <identifiersep> mode new <identifiersep> mode ) { super ( get <identifiersep> message ( new <identifiersep> mode ) + ( e . extra <identifiersep> message != null ? <string_literal> + e . extra <identifiersep> message : <string_literal> ) ) ; this . mode = new <identifiersep> mode ; this . new <identifiersep> uri = e . new <identifiersep> uri ; <ect>
this . error <identifiersep> codes = e . error <identifiersep> codes ; this . expected <identifiersep> mime <identifiersep> type = e . expected <identifiersep> mime <identifiersep> type ; this . expected <identifiersep> size = e . expected <identifiersep> size ; this . extra <identifiersep> message = e . extra <identifiersep> message ; this . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type = e . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception e ) { super ( e . get <identifiersep> message ( ) ) ; init <identifiersep> cause ( e ) ; this . mode = e . mode ; <ect>
case archive <identifiersep> restart : case permanent <identifiersep> redirect : case wrong <identifiersep> mime <identifiersep> type : <comment> <LOG> return false ; <comment> <ect>
&& code != compatibility <identifiersep> mode . compat <identifiersep> current . code ) { <comment> <LOG> top <identifiersep> compatibility <identifiersep> mode = insert <identifiersep> context . compatibility <identifiersep> mode . compat <identifiersep> unknown ; } else { throw new metadata <identifiersep> parse <identifiersep> exception ( <string_literal> + code ) ; } } } else { top <identifiersep> size = 0 ; top <identifiersep> compressed <identifiersep> size = 0 ; <ect>
object o = entry . get <identifiersep> value ( ) ; if ( o instanceof metadata ) { metadata data = ( metadata ) o ; if ( data == null ) throw new null <identifiersep> pointer <identifiersep> exception ( ) ; if ( log <identifiersep> debug ) <LOG> manifest <identifiersep> entries . put ( key , data ) ; } else if ( o instanceof hash <identifiersep> map ) { if ( key . equals ( <string_literal> ) ) { logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; } hash <identifiersep> map < string , object > hm = metadata . force <identifiersep> map ( o ) ; if ( log <identifiersep> debug ) <ect>
manifest <identifiersep> entries . put ( key , data ) ; } else if ( o instanceof hash <identifiersep> map ) { if ( key . equals ( <string_literal> ) ) { logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; } hash <identifiersep> map < string , object > hm = metadata . force <identifiersep> map ( o ) ; if ( log <identifiersep> debug ) <LOG> metadata sub <identifiersep> map = mk <identifiersep> redirection <identifiersep> manifest <identifiersep> with <identifiersep> metadata ( hm ) ; manifest <identifiersep> entries . put ( key , sub <identifiersep> map ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key ) ; } } } <comment> <ect>
this . set <identifiersep> mime <identifiersep> type ( cm . get <identifiersep> mime <identifiersep> type ( ) ) ; target <identifiersep> name = arg ; while ( true ) { if ( target <identifiersep> name . is <identifiersep> empty ( ) ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + arg + <string_literal> ) ; if ( target <identifiersep> name . char <identifiersep> at ( 0 ) == ' / ' ) { target <identifiersep> name = target <identifiersep> name . substring ( 1 ) ; <LOG> continue ; } else break ; } } else throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; hashes = null ; top <identifiersep> size = 0 ; <ect>
inc ( k . code ) ; } public void inc ( insert <identifiersep> exception <identifiersep> mode k ) { if ( ! insert ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; inc ( k . code ) ; } public synchronized void inc ( int k ) { if ( k == 0 ) { <LOG> } if ( map == null ) map = new hash <identifiersep> map < integer , integer > ( ) ; integer key = k ; integer i = map . get ( key ) ; if ( i == null ) map . put ( key , 1 ) ; else <ect>
public freenet <identifiersep> uri insert <identifiersep> redirect ( freenet <identifiersep> uri insert <identifiersep> uri , freenet <identifiersep> uri target <identifiersep> uri ) throws insert <identifiersep> exception { metadata m = new metadata ( document <identifiersep> type . simple <identifiersep> redirect , null , null , target <identifiersep> uri , new client <identifiersep> metadata ( ) ) ; random <identifiersep> access <identifiersep> bucket b ; try { b = m . to <identifiersep> bucket ( bucket <identifiersep> factory ) ; } catch ( io <identifiersep> exception e ) { <LOG> throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; } insert <identifiersep> block block = new insert <identifiersep> block ( b , null , insert <identifiersep> uri ) ; freenet <identifiersep> uri uri = insert ( block , false , null , true , priority <identifiersep> class ) ; <ect>
logger . register <identifiersep> class ( null <identifiersep> client <identifiersep> callback . class ) ; } private final request <identifiersep> client cb ; public null <identifiersep> client <identifiersep> callback ( request <identifiersep> client cb ) { this . cb = cb ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { <LOG> } @ override public void on <identifiersep> failure ( insert <identifiersep> exception e , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + e + <string_literal> + state , e ) ; } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + e + <string_literal> + state , e ) ; } @ override public void on <identifiersep> failure ( insert <identifiersep> exception e , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + e + <string_literal> + state , e ) ; } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { <LOG> } @ override public void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + uri + <string_literal> + state ) ; } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + result + <string_literal> + state ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; } @ override public void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + uri + <string_literal> + state ) ; } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { <LOG> result . data . free ( ) ; } @ override public void on <identifiersep> success ( base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; } @ override public void on <identifiersep> generated <identifiersep> metadata ( bucket metadata , base <identifiersep> client <identifiersep> putter state ) { <ect>
result . data . free ( ) ; } @ override public void on <identifiersep> success ( base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; } @ override public void on <identifiersep> generated <identifiersep> metadata ( bucket metadata , base <identifiersep> client <identifiersep> putter state ) { <LOG> metadata . free ( ) ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <comment> <ect>
for ( client <identifiersep> event <identifiersep> listener cel : list ) { try { cel . receive ( ce , context ) ; } catch ( exception ue ) { system . err . println ( <string_literal> ) ; ue . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } } } <comment> public synchronized client <identifiersep> event <identifiersep> listener [ ] get <identifiersep> event <identifiersep> listeners ( ) { client <identifiersep> event <identifiersep> listener [ ] ret = new client <identifiersep> event <identifiersep> listener [ listeners . size ( ) ] ; return listeners . to <identifiersep> array ( ret ) ; } <comment> public synchronized void add <identifiersep> event <identifiersep> listeners ( client <identifiersep> event <identifiersep> listener [ ] cela ) { <ect>
context . ticker , context . memory <identifiersep> limited <identifiersep> job <identifiersep> runner , checker , persistent , file <identifiersep> complete <identifiersep> via <identifiersep> truncation , context . get <identifiersep> file <identifiersep> random <identifiersep> access <identifiersep> buffer <identifiersep> factory ( persistent ) , context . get <identifiersep> chk <identifiersep> fetch <identifiersep> scheduler ( real <identifiersep> time <identifiersep> flag ) . fetching <identifiersep> keys ( ) ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . not <identifiersep> enough <identifiersep> disk <identifiersep> space ) ; } catch ( io <identifiersep> exception e ) { <LOG> throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } long eventual <identifiersep> length = math . max ( storage . decompressed <identifiersep> length , metadata . uncompressed <identifiersep> data <identifiersep> length ( ) ) ; cb . on <identifiersep> expected <identifiersep> size ( eventual <identifiersep> length , context ) ; if ( metadata . uncompressed <identifiersep> data <identifiersep> length ( ) > 0 ) cb . on <identifiersep> finalized <identifiersep> metadata ( ) ; if ( eventual <identifiersep> length > 0 && fetch <identifiersep> context . max <identifiersep> output <identifiersep> length > 0 && eventual <identifiersep> length > fetch <identifiersep> context . max <identifiersep> output <identifiersep> length ) <ect>
@ override public void queue <identifiersep> heal ( byte [ ] data , byte [ ] crypto <identifiersep> key , byte crypto <identifiersep> algorithm ) { try { context . healing <identifiersep> queue . queue ( bucket <identifiersep> tools . make <identifiersep> immutable <identifiersep> bucket ( context . temp <identifiersep> bucket <identifiersep> factory , data ) , crypto <identifiersep> key , crypto <identifiersep> algorithm , context ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> } } public boolean local <identifiersep> request <identifiersep> only ( ) { return block <identifiersep> fetch <identifiersep> context . local <identifiersep> request <identifiersep> only ; } public void to <identifiersep> network ( ) { parent . to <identifiersep> network ( context ) ; } public boolean has <identifiersep> finished ( ) { return failed || succeeded ; <ect>
array <identifiersep> list < my <identifiersep> block > maybe <identifiersep> blocks = new array <identifiersep> list < my <identifiersep> block > ( ) ; int fetched <identifiersep> count = 0 ; synchronized ( this ) { boolean [ ] used = new boolean [ total <identifiersep> blocks ] ; for ( short i = 0 ; i < blocks <identifiersep> fetched . length ; i ++ ) { if ( blocks <identifiersep> fetched [ i ] < 0 || blocks <identifiersep> fetched [ i ] > total <identifiersep> blocks ) { <LOG> if ( blocks <identifiersep> fetched [ i ] != - 1 ) blocks <identifiersep> fetched [ i ] = - 1 ; maybe <identifiersep> blocks . add ( new my <identifiersep> block ( all <identifiersep> blocks [ i ] , ( short ) - 1 , i ) ) ; continue ; } else if ( used [ blocks <identifiersep> fetched [ i ] ] ) { logger . warning ( this , <string_literal> + i + <string_literal> + blocks <identifiersep> fetched [ i ] ) ; <ect>
used [ blocks <identifiersep> fetched [ i ] ] = true ; fetched <identifiersep> count ++ ; } } if ( fetched <identifiersep> count < blocks <identifiersep> for <identifiersep> decode ( ) ) { int old <identifiersep> blocks <identifiersep> fetched <identifiersep> count = block <identifiersep> chooser . success <identifiersep> count ( ) ; block <identifiersep> chooser . replace <identifiersep> successes ( used ) ; if ( block <identifiersep> chooser . success <identifiersep> count ( ) != old <identifiersep> blocks <identifiersep> fetched <identifiersep> count ) { <LOG> <string_literal> + old <identifiersep> blocks <identifiersep> fetched <identifiersep> count ) ; } } } if ( fetched <identifiersep> count < blocks <identifiersep> for <identifiersep> decode ( ) ) { <comment> <ect>
} else { synchronized ( this ) { block <identifiersep> chooser . on <identifiersep> un <identifiersep> success ( block <identifiersep> number ) ; blocks <identifiersep> fetched [ test . slot ] = block <identifiersep> number ; this . block <identifiersep> chooser . on <identifiersep> success ( block <identifiersep> number ) ; } } } } catch ( chk <identifiersep> encode <identifiersep> exception e ) { <LOG> failed = true ; } if ( ! failed ) { valid <identifiersep> blocks ++ ; if ( block <identifiersep> number < blocks <identifiersep> for <identifiersep> decode ( ) ) valid <identifiersep> data <identifiersep> blocks ++ ; if ( block <identifiersep> number < data <identifiersep> blocks . length ) <ect>
<comment> <LOG> return false ; } if ( capturing <identifiersep> binary <identifiersep> blob ) parent . fetcher . maybe <identifiersep> add <identifiersep> to <identifiersep> binary <identifiersep> blob ( block ) ; } catch ( chk <identifiersep> encode <identifiersep> exception e ) { <comment> <ect>
client <identifiersep> chk <identifiersep> block decoded <identifiersep> block ; byte [ ] decoded <identifiersep> data ; try { decoded <identifiersep> block = new client <identifiersep> chk <identifiersep> block ( block , decode <identifiersep> key ) ; decoded <identifiersep> data = decoded <identifiersep> block . memory <identifiersep> decode ( ) ; } catch ( chk <identifiersep> verify <identifiersep> exception e ) { <LOG> return false ; } catch ( chk <identifiersep> decode <identifiersep> exception e ) { logger . error ( this , <string_literal> + decode <identifiersep> key ) ; return false ; } return inner <identifiersep> on <identifiersep> got <identifiersep> key ( key , decoded <identifiersep> block , keys , block <identifiersep> number , decoded <identifiersep> data ) ; } <comment> <ect>
if ( block <identifiersep> number == data <identifiersep> blocks - 1 && this . seg <identifiersep> no == parent . segments . length - 1 && parent . last <identifiersep> block <identifiersep> might <identifiersep> not <identifiersep> be <identifiersep> padded ( ) ) { <comment> <LOG> return false ; } else { parent . fail ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . splitfile <identifiersep> error , <string_literal> ) ) ; return false ; } } split <identifiersep> file <identifiersep> fetcher <identifiersep> cross <identifiersep> segment <identifiersep> storage callback = null ; <comment> <ect>
<comment> private void inner <identifiersep> write <identifiersep> metadata ( boolean force ) throws io <identifiersep> exception { if ( ! parent . persistent ) return ; synchronized ( this ) { if ( ! ( force || metadata <identifiersep> dirty ) ) return ; <LOG> output <identifiersep> stream cos = parent . write <identifiersep> checksummed <identifiersep> to ( segment <identifiersep> status <identifiersep> offset , segment <identifiersep> status <identifiersep> padded <identifiersep> length ) ; try { data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( cos ) ; for ( int s : blocks <identifiersep> fetched ) dos . write <identifiersep> int ( s ) ; block <identifiersep> chooser . write <identifiersep> retries ( dos ) ; <ect>
succeeded = false ; finished = false ; } else { return buf ; } } catch ( chk <identifiersep> encode <identifiersep> exception e ) { <comment> <LOG> return null ; } } } logger . error ( this , <string_literal> + block <identifiersep> num + <string_literal> + this ) ; return null ; } synchronized void resume <identifiersep> callback ( int block <identifiersep> no , split <identifiersep> file <identifiersep> fetcher <identifiersep> cross <identifiersep> segment <identifiersep> storage cross <identifiersep> segment ) { this . cross <identifiersep> segments <identifiersep> by <identifiersep> block [ block <identifiersep> no ] = cross <identifiersep> segment ; } public synchronized boolean has <identifiersep> block ( int block <identifiersep> no ) { <ect>
on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> big , e ) , false , context ) ; return null ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . not <identifiersep> enough <identifiersep> disk <identifiersep> space ) , false , context ) ; return null ; } catch ( io <identifiersep> exception e ) { <LOG> on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) , false , context ) ; return null ; } return data ; } <comment> @ override public long get <identifiersep> token ( ) { <ect>
@ override public void run ( ) { while ( true ) { try { if ( real <identifiersep> run ( ) ) return ; <comment> <LOG> } } } <comment> private boolean real <identifiersep> run ( ) { random random ; if ( kill <identifiersep> blocks != 0 ) <ect>
scheduler . finish <identifiersep> register ( new sendable <identifiersep> get [ ] { get } , true , valid ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + get + <string_literal> + t , t ) ; try { get . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error , <string_literal> + t , t ) , null , context ) ; } catch ( throwable t1 ) { <LOG> } } return false ; } @ override public string to <identifiersep> string ( ) { return <string_literal> ; } } , native <identifiersep> thread . norm <identifiersep> priority ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <ect>
if ( ! dont <identifiersep> compress ) this . dont <identifiersep> compress = false ; if ( min . ordinal ( ) > this . min . ordinal ( ) ) this . min = min ; if ( max . ordinal ( ) < this . max . ordinal ( ) || this . max == compatibility <identifiersep> mode . compat <identifiersep> unknown ) this . max = max ; if ( this . crypto <identifiersep> key == null ) { this . crypto <identifiersep> key = crypto <identifiersep> key ; } else if ( crypto <identifiersep> key != null && ! arrays . equals ( this . crypto <identifiersep> key , crypto <identifiersep> key ) ) { <LOG> this . crypto <identifiersep> key = null ; } } public compatibility <identifiersep> mode min ( ) { return min ; } public compatibility <identifiersep> mode max ( ) { return max ; } public byte [ ] get <identifiersep> crypto <identifiersep> key ( ) { <ect>
ctx , real <identifiersep> time <identifiersep> flag , m , false , source <identifiersep> length , token , true , true <comment> , null , context , persistent , true , extra <identifiersep> inserts , crypto <identifiersep> algorithm , force <identifiersep> crypto <identifiersep> key ) ; logger . normal ( this , <string_literal> + uri + <string_literal> + sb + <string_literal> + pub <identifiersep> usk ) ; m . add ( sb ) ; sb . schedule ( context ) ; added = true ; } catch ( io <identifiersep> exception e ) { <LOG> if ( ! added ) { cb . on <identifiersep> failure ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , pub <identifiersep> usk . get <identifiersep> ssk ( edition ) . get <identifiersep> uri ( ) ) , this , context ) ; return ; } <comment> <ect>
usk new <identifiersep> edition = pub <identifiersep> usk . copy ( edition ) ; finished = true ; sbi = null ; freenet <identifiersep> uri target <identifiersep> uri = pub <identifiersep> usk . get <identifiersep> ssk ( edition ) . get <identifiersep> uri ( ) ; freenet <identifiersep> uri real <identifiersep> uri = ( ( single <identifiersep> block <identifiersep> inserter ) state ) . get <identifiersep> uri ( context ) ; if ( ! target <identifiersep> uri . equals ( real <identifiersep> uri ) ) <LOG> else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + target <identifiersep> uri + <string_literal> + real <identifiersep> uri ) ; context . usk <identifiersep> manager . update <identifiersep> known <identifiersep> good ( pub <identifiersep> usk , edition , context ) ; } if ( free <identifiersep> data ) { data . free ( ) ; <ect>
schedule <identifiersep> insert ( context ) ; } @ override public void on <identifiersep> cancelled ( client <identifiersep> context context ) { synchronized ( this ) { fetcher = null ; if ( finished ) return ; } <LOG> cancel ( context ) ; } @ override public void on <identifiersep> encode ( base <identifiersep> client <identifiersep> key key , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { <comment> <ect>
public void on <identifiersep> transition ( client <identifiersep> put <identifiersep> state old <identifiersep> state , client <identifiersep> put <identifiersep> state new <identifiersep> state , client <identifiersep> context context ) { <comment> <LOG> } @ override public void on <identifiersep> block <identifiersep> set <identifiersep> finished ( client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { <comment> <ect>
} catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> + e ) ; <comment> <LOG> <comment> <ect>
if ( key <identifiersep> listener . needs <identifiersep> keys ( ) ) { try { this . job <identifiersep> runner . queue ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { system . out . println ( <string_literal> + split <identifiersep> file <identifiersep> fetcher <identifiersep> storage . this ) ; <LOG> key <identifiersep> salter salt = fetcher . get <identifiersep> salter ( ) ; for ( int i = 0 ; i < segments . length ; i ++ ) { split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage segment = segments [ i ] ; try { try { split <identifiersep> file <identifiersep> segment <identifiersep> keys keys = segment . read <identifiersep> segment <identifiersep> keys ( ) ; <ect>
key <identifiersep> listener . inner <identifiersep> write <identifiersep> main <identifiersep> bloom <identifiersep> filter ( offset <identifiersep> main <identifiersep> bloom <identifiersep> filter ) ; } catch ( io <identifiersep> exception e ) { if ( persistent ) fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } fetcher . restarted <identifiersep> after <identifiersep> data <identifiersep> corruption ( ) ; logger . warning ( this , <string_literal> + split <identifiersep> file <identifiersep> fetcher <identifiersep> storage . this ) ; <LOG> return false ; } } , native <identifiersep> thread . low <identifiersep> priority + 1 ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
} finally { lock . unlock ( ) ; } write <identifiersep> general <identifiersep> progress ( false ) ; return false ; } catch ( io <identifiersep> exception e ) { if ( is <identifiersep> finishing ( ) ) return false ; <LOG> return false ; } } } ; private final runnable wrap <identifiersep> lazy <identifiersep> write <identifiersep> metadata = new runnable ( ) { @ override public void run ( ) { job <identifiersep> runner . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( write <identifiersep> metadata <identifiersep> job ) ; <ect>
@ override public boolean run ( client <identifiersep> context context ) { fetcher . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; return true ; } } ) ; } public void fail <identifiersep> on <identifiersep> disk <identifiersep> error ( final checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> job <identifiersep> runner . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { fetcher . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; return true ; } } ) ; <ect>
@ override public key <identifiersep> listener make <identifiersep> key <identifiersep> listener ( client <identifiersep> context context , boolean on <identifiersep> startup ) { synchronized ( this ) { if ( finished ) return null ; if ( cancelled ) return null ; } if ( key == null ) { <LOG> return null ; } key new <identifiersep> key = key . get <identifiersep> node <identifiersep> key ( true ) ; if ( parent == null ) { logger . error ( this , <string_literal> + this + <string_literal> + persistent + <string_literal> + key + <string_literal> + ctx ) ; return null ; } short prio = parent . get <identifiersep> priority <identifiersep> class ( ) ; <ect>
<comment> public void remove <identifiersep> pending <identifiersep> keys ( key <identifiersep> listener getter , boolean complain ) { boolean found = sched <identifiersep> transient . remove <identifiersep> pending <identifiersep> keys ( getter ) ; if ( sched <identifiersep> core != null ) found | = sched <identifiersep> core . remove <identifiersep> pending <identifiersep> keys ( getter ) ; if ( complain && ! found ) <LOG> } <comment> public void remove <identifiersep> pending <identifiersep> keys ( has <identifiersep> key <identifiersep> listener getter , boolean complain ) { <ect>
return false ; } @ override public string to <identifiersep> string ( ) { return <string_literal> ; } } , prio ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e1 ) { <LOG> } } } @ override public void call <identifiersep> failure ( final sendable <identifiersep> insert insert , final low <identifiersep> level <identifiersep> put <identifiersep> exception e , int prio , boolean persistent ) { if ( ! persistent ) { insert . on <identifiersep> failure ( e , null , client <identifiersep> context ) ; } else { try { <ect>
context . get <identifiersep> chk <identifiersep> insert <identifiersep> scheduler ( real <identifiersep> time ) . fetching <identifiersep> keys ( ) , context . persistent <identifiersep> fg , context . persistent <identifiersep> file <identifiersep> tracker , context . get <identifiersep> persistent <identifiersep> master <identifiersep> secret ( ) ) ; storage . on <identifiersep> resume ( context ) ; this . sender = new split <identifiersep> file <identifiersep> inserter <identifiersep> sender ( this , storage ) ; schedule ( context ) ; } catch ( io <identifiersep> exception e ) { <LOG> raf . close ( ) ; raf . free ( ) ; original <identifiersep> data . close ( ) ; if ( free <identifiersep> data ) original <identifiersep> data . free ( ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; <ect>
raf . free ( ) ; original <identifiersep> data . close ( ) ; if ( free <identifiersep> data ) original <identifiersep> data . free ( ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> raf . close ( ) ; raf . free ( ) ; original <identifiersep> data . close ( ) ; if ( free <identifiersep> data ) original <identifiersep> data . free ( ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; <ect>
static final long prefetch <identifiersep> delay = seconds . to <identifiersep> millis ( <number_literal> ) ; private void schedule <identifiersep> prefetch <identifiersep> checker ( ) { context . ticker . queue <identifiersep> timed <identifiersep> job ( prefetch <identifiersep> checker , <string_literal> , prefetch <identifiersep> delay , false , true ) ; } private final runnable prefetch <identifiersep> checker = new runnable ( ) { @ override public void run ( ) { <LOG> array <identifiersep> list < usk > to <identifiersep> fetch = null ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; boolean empty = true ; synchronized ( usk <identifiersep> manager . this ) { for ( map . entry < usk , long > entry : temporary <identifiersep> background <identifiersep> fetchers <identifiersep> prefetch . entry <identifiersep> set ( ) ) { empty = false ; <ect>
usk clear = orig . clear <identifiersep> copy ( ) ; synchronized ( this ) { if ( background <identifiersep> fetchers <identifiersep> by <identifiersep> clear <identifiersep> usk . get ( clear ) == fetcher ) { background <identifiersep> fetchers <identifiersep> by <identifiersep> clear <identifiersep> usk . remove ( clear ) ; if ( ! ignore <identifiersep> error ) { <comment> <LOG> } } if ( temporary <identifiersep> background <identifiersep> fetchers <identifiersep> lru . get ( clear ) == fetcher ) { temporary <identifiersep> background <identifiersep> fetchers <identifiersep> lru . remove <identifiersep> key ( clear ) ; temporary <identifiersep> background <identifiersep> fetchers <identifiersep> prefetch . remove ( clear ) ; } } } public boolean persistent ( ) { return false ; } client <identifiersep> context get <identifiersep> context ( ) { <ect>
<comment> <LOG> } } } <ect>
<comment> <LOG> inner <identifiersep> set <identifiersep> files <identifiersep> and <identifiersep> load ( true , dir , base <identifiersep> name , write <identifiersep> encrypted , encryption <identifiersep> key , context , request <identifiersep> starters , random ) ; } on <identifiersep> started ( no <identifiersep> write ) ; } else { inner <identifiersep> set <identifiersep> files <identifiersep> only ( dir , base <identifiersep> name , write <identifiersep> encrypted , encryption <identifiersep> key ) ; on <identifiersep> started ( false ) ; <ect>
try { file <identifiersep> util . secure <identifiersep> delete ( f ) ; } catch ( io <identifiersep> exception e ) { f . delete ( ) ; if ( f . exists ( ) ) { system . err . println ( <string_literal> + f + <string_literal> ) ; <LOG> <comment> <ect>
if ( loaded . done <identifiersep> something ( ) ) { if ( ! no <identifiersep> serialize ) { on <identifiersep> loading ( ) ; if ( loaded . get <identifiersep> salt ( ) == null ) { salt = new byte [ <number_literal> ] ; random . next <identifiersep> bytes ( salt ) ; <LOG> system . err . println ( <string_literal> ) ; new <identifiersep> salt = true ; } else { salt = loaded . salt ; } } int success = 0 ; int restored <identifiersep> restarted = 0 ; <ect>
try { fis = bucket . get <identifiersep> input <identifiersep> stream ( ) ; inner <identifiersep> load ( loaded , fis , length , ! no <identifiersep> serialize && ! loaded . done <identifiersep> something ( ) , context , request <identifiersep> starters , random , no <identifiersep> serialize ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> system . err . println ( <string_literal> + bucket + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; loaded . set <identifiersep> something <identifiersep> failed ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + bucket + <string_literal> + t , t ) ; system . err . println ( <string_literal> + bucket + <string_literal> + t ) ; <ect>
<comment> <LOG> system . err . println ( <string_literal> + bucket + <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; loaded . set <identifiersep> something <identifiersep> failed ( ) ; } finally { try { if ( fis != null ) fis . close ( ) ; <ect>
t . print <identifiersep> stack <identifiersep> trace ( ) ; loaded . set <identifiersep> something <identifiersep> failed ( ) ; } finally { try { if ( fis != null ) fis . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void inner <identifiersep> load ( partial <identifiersep> load loaded , input <identifiersep> stream fis , long length , boolean latest , client <identifiersep> context context , request <identifiersep> starter <identifiersep> group request <identifiersep> starters , random random , boolean no <identifiersep> serialize ) throws node <identifiersep> init <identifiersep> exception , io <identifiersep> exception { object <identifiersep> input <identifiersep> stream ois = new object <identifiersep> input <identifiersep> stream ( fis ) ; long magic = ois . read <identifiersep> long ( ) ; if ( magic != magic ) throw new io <identifiersep> exception ( <string_literal> ) ; <ect>
request <identifiersep> starters . set <identifiersep> global <identifiersep> salt ( salt ) ; int request <identifiersep> count = ois . read <identifiersep> int ( ) ; for ( int i = 0 ; i < request <identifiersep> count ; i ++ ) { client <identifiersep> request request = null ; request <identifiersep> identifier req <identifiersep> id = read <identifiersep> request <identifiersep> identifier ( ois ) ; if ( req <identifiersep> id != null && context . persistent <identifiersep> root . has <identifiersep> request ( req <identifiersep> id ) ) { <LOG> skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; <comment> <ect>
request = null ; } else { loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , request , request <identifiersep> load <identifiersep> status . loaded ) ; } } } } else skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> ) ; } catch ( throwable t ) { <comment> <ect>
skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; system . err . println ( <string_literal> ) ; } catch ( throwable t ) { <comment> <LOG> system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } if ( request == null || log <identifiersep> minor ) { try { client <identifiersep> request restored = read <identifiersep> request <identifiersep> from <identifiersep> recovery <identifiersep> data ( ois , length , req <identifiersep> id ) ; if ( request == null && restored != null ) { <ect>
request = restored ; boolean loaded <identifiersep> fully = restored . fully <identifiersep> resumed ( ) ; loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , request , loaded <identifiersep> fully ? request <identifiersep> load <identifiersep> status . restored <identifiersep> fully : request <identifiersep> load <identifiersep> status . restored <identifiersep> restarted ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { if ( request == null ) { <LOG> system . err . println ( <string_literal> ) ; } else { logger . error ( this , <string_literal> + req <identifiersep> id ) ; } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { <ect>
loaded <identifiersep> fully ? request <identifiersep> load <identifiersep> status . restored <identifiersep> fully : request <identifiersep> load <identifiersep> status . restored <identifiersep> restarted ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { if ( request == null ) { logger . error ( this , <string_literal> ) ; system . err . println ( <string_literal> ) ; } else { <LOG> } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { if ( request == null ) { logger . error ( this , <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; <ect>
logger . error ( this , <string_literal> + req <identifiersep> id ) ; } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { if ( request == null ) { logger . error ( this , <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } else { logger . error ( this , <string_literal> + req <identifiersep> id + <string_literal> + e , e ) ; } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } } else { <ect>
skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; } } if ( latest ) { try { <comment> <LOG> } } ois . close ( ) ; fis = null ; } private void read <identifiersep> stats <identifiersep> and <identifiersep> buckets ( object <identifiersep> input <identifiersep> stream ois , long length , client <identifiersep> context context ) throws io <identifiersep> exception , class <identifiersep> not <identifiersep> found <identifiersep> exception { persistent <identifiersep> stats <identifiersep> putter stored <identifiersep> stats <identifiersep> putter = ( persistent <identifiersep> stats <identifiersep> putter ) ois . read <identifiersep> object ( ) ; this . bandwidth <identifiersep> stats <identifiersep> putter . add <identifiersep> from ( stored <identifiersep> stats <identifiersep> putter ) ; int count = ois . read <identifiersep> int ( ) ; <ect>
if ( shutdown ) { for ( client <identifiersep> request req : requests ) { if ( req == null ) continue ; try { req . on <identifiersep> shutdown ( get <identifiersep> client <identifiersep> context ( ) ) ; } catch ( throwable t ) { <LOG> } } } oos . write <identifiersep> int ( requests . length ) ; for ( client <identifiersep> request req : requests ) { <comment> <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void write <identifiersep> recovery <identifiersep> data ( object <identifiersep> output <identifiersep> stream os , client <identifiersep> request req ) throws io <identifiersep> exception { prepend <identifiersep> length <identifiersep> output <identifiersep> stream oos = checker . checksum <identifiersep> writer <identifiersep> with <identifiersep> length ( os , temp <identifiersep> bucket <identifiersep> factory ) ; data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( oos ) ; try { req . get <identifiersep> client <identifiersep> detail ( dos , checker ) ; <ect>
try { req . get <identifiersep> client <identifiersep> detail ( dos , checker ) ; dos . close ( ) ; oos = null ; } catch ( throwable e ) { logger . error ( this , <string_literal> + req + <string_literal> + e , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; oos . abort ( ) ; } finally { if ( oos != null ) oos . close ( ) ; } } private client <identifiersep> request read <identifiersep> request <identifiersep> from <identifiersep> recovery <identifiersep> data ( object <identifiersep> input <identifiersep> stream is , long total <identifiersep> length , request <identifiersep> identifier req <identifiersep> id ) throws io <identifiersep> exception , checksum <identifiersep> failed <identifiersep> exception , storage <identifiersep> format <identifiersep> exception { input <identifiersep> stream tmp = checker . checksum <identifiersep> reader <identifiersep> with <identifiersep> length ( is , this . temp <identifiersep> bucket <identifiersep> factory , total <identifiersep> length ) ; <ect>
try { object <identifiersep> output <identifiersep> stream inner <identifiersep> oos = new object <identifiersep> output <identifiersep> stream ( oos ) ; inner <identifiersep> oos . write <identifiersep> object ( req ) ; inner <identifiersep> oos . close ( ) ; oos = null ; } catch ( throwable e ) { <LOG> oos . abort ( ) ; } finally { if ( oos != null ) oos . close ( ) ; } } private object read <identifiersep> checksummed <identifiersep> object ( object <identifiersep> input <identifiersep> stream is , long total <identifiersep> length ) throws io <identifiersep> exception , checksum <identifiersep> failed <identifiersep> exception , class <identifiersep> not <identifiersep> found <identifiersep> exception { input <identifiersep> stream ois = checker . checksum <identifiersep> reader <identifiersep> with <identifiersep> length ( is , this . temp <identifiersep> bucket <identifiersep> factory , total <identifiersep> length ) ; try { <ect>
short length = is . read <identifiersep> short ( ) ; if ( length < = 0 ) return null ; byte [ ] buf = new byte [ length ] ; try { checker . read <identifiersep> and <identifiersep> checksum ( is , buf , 0 , length ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> return null ; } data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( buf ) ) ; try { return new request <identifiersep> identifier ( dis ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
public client <identifiersep> key <identifiersep> block get ( client <identifiersep> key key ) { key <identifiersep> block block = get ( key . get <identifiersep> node <identifiersep> key ( false ) ) ; if ( block == null ) return null ; try { return key . create <identifiersep> key <identifiersep> block ( key , block ) ; } catch ( key <identifiersep> verify <identifiersep> exception e ) { <LOG> return null ; } } } <ect>
synchronized ( this ) { f = fetcher ; } if ( f == null ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; f . change <identifiersep> usk <identifiersep> poll <identifiersep> parameters ( time , tries , context ) ; } @ override public void inner <identifiersep> on <identifiersep> resume ( client <identifiersep> context context ) { <LOG> <comment> <ect>
boolean shutdown = false ; checkpoint <identifiersep> lock lock = null ; try { lock = parent . job <identifiersep> runner . lock ( ) ; inner <identifiersep> decode ( chunk ) ; } catch ( io <identifiersep> exception e ) { <LOG> parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { shutdown = true ; } finally { chunk . release ( ) ; try { <ect>
logger . error ( this , <string_literal> ) ; fail <identifiersep> off <identifiersep> thread ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> ) ) ; return ; } client <identifiersep> chk <identifiersep> block block = encode <identifiersep> block ( key , data ) ; string decoded = i >= data <identifiersep> block <identifiersep> count ? <string_literal> : <string_literal> ; if ( block == null || ! key . get <identifiersep> node <identifiersep> chk ( ) . equals ( block . get <identifiersep> key ( ) ) ) { <LOG> fail <identifiersep> off <identifiersep> thread ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . splitfile <identifiersep> decode <identifiersep> error , decoded + <string_literal> ) ) ; return ; } else { report <identifiersep> block <identifiersep> to <identifiersep> segment <identifiersep> off <identifiersep> thread ( i , key , block , data ) ; } } private client <identifiersep> chk <identifiersep> block encode <identifiersep> block ( client <identifiersep> chk key , byte [ ] data ) { try { <ect>
return true ; } <comment> private void on <identifiersep> completed <identifiersep> cross <identifiersep> segment <identifiersep> encode ( ) { synchronized ( this ) { if ( status == status . encoded <identifiersep> cross <identifiersep> segments ) return ; <comment> <LOG> return ; } status = status . encoded <identifiersep> cross <identifiersep> segments ; } start <identifiersep> segment <identifiersep> encode ( ) ; } private void on <identifiersep> completed <identifiersep> segment <identifiersep> encode ( ) { synchronized ( this ) { if ( status == status . encoded ) return ; <comment> <ect>
specify <identifiersep> splitfile <identifiersep> key <identifiersep> in <identifiersep> metadata , cross <identifiersep> check <identifiersep> blocks ) ; } void inner <identifiersep> write <identifiersep> segment <identifiersep> key ( int seg <identifiersep> no , int block <identifiersep> no , byte [ ] buf ) throws io <identifiersep> exception { assert ( buf . length == split <identifiersep> file <identifiersep> inserter <identifiersep> segment <identifiersep> storage . get <identifiersep> key <identifiersep> length ( this ) ) ; assert ( seg <identifiersep> no >= 0 && seg <identifiersep> no < segments . length ) ; assert ( block <identifiersep> no >= 0 && block <identifiersep> no < segments [ seg <identifiersep> no ] . total <identifiersep> block <identifiersep> count ) ; long file <identifiersep> offset = this . offset <identifiersep> segment <identifiersep> keys [ seg <identifiersep> no ] + key <identifiersep> length * block <identifiersep> no ; <LOG> raf . pwrite ( file <identifiersep> offset , buf , 0 , buf . length ) ; } byte [ ] inner <identifiersep> read <identifiersep> segment <identifiersep> key ( int seg <identifiersep> no , int block <identifiersep> no ) throws io <identifiersep> exception { byte [ ] buf = new byte [ key <identifiersep> length ] ; long file <identifiersep> offset = this . offset <identifiersep> segment <identifiersep> keys [ seg <identifiersep> no ] + key <identifiersep> length * block <identifiersep> no ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + block <identifiersep> no + <string_literal> + seg <identifiersep> no + <string_literal> + this + <string_literal> + file <identifiersep> offset ) ; raf . pread ( file <identifiersep> offset , buf , 0 , buf . length ) ; <ect>
void fail ( final insert <identifiersep> exception e ) { synchronized ( this ) { if ( this . status == status . succeeded || this . status == status . failed || this . status == status . generating <identifiersep> metadata ) { <comment> <LOG> return ; } <comment> <ect>
} finally { lock . unlock ( ) ; } write <identifiersep> overall <identifiersep> status ( false ) ; return false ; } catch ( io <identifiersep> exception e ) { if ( is <identifiersep> finishing ( ) ) return false ; <LOG> return false ; } } } ; private final runnable wrap <identifiersep> lazy <identifiersep> write <identifiersep> metadata = new runnable ( ) { @ override public void run ( ) { job <identifiersep> runner . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( write <identifiersep> metadata <identifiersep> job ) ; <ect>
if ( hashes != null ) { rcb . on <identifiersep> hashes ( hashes , context ) ; } } if ( metadata . is <identifiersep> simple <identifiersep> manifest ( ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; string name ; if ( metadata . count <identifiersep> documents ( ) == 1 && metadata . get <identifiersep> document ( <string_literal> ) != null && metadata . get <identifiersep> document ( <string_literal> ) . is <identifiersep> simple <identifiersep> manifest ( ) ) { <LOG> name = <string_literal> ; } else if ( meta <identifiersep> strings . is <identifiersep> empty ( ) ) { freenet <identifiersep> uri u = uri ; string last = u . last <identifiersep> meta <identifiersep> string ( ) ; if ( last == null || ! last . equals ( <string_literal> ) ) u = u . add <identifiersep> meta <identifiersep> strings ( new string [ ] { <string_literal> } ) ; <ect>
} else stream <identifiersep> generator . write <identifiersep> to ( output , context ) ; <comment> <LOG> on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; return ; } finally { closer . close ( pipe <identifiersep> out ) ; closer . close ( pipe <identifiersep> in ) ; closer . close ( output ) ; <ect>
return null ; } @ override public short get <identifiersep> priority <identifiersep> class ( ) { return priority <identifiersep> class ; } @ override public void internal <identifiersep> error ( throwable t , request <identifiersep> scheduler sched , client <identifiersep> context context , boolean persistent ) { <LOG> } @ override public sendable <identifiersep> request <identifiersep> sender get <identifiersep> sender ( client <identifiersep> context context ) { return new sendable <identifiersep> request <identifiersep> sender ( ) { @ override public boolean send ( node <identifiersep> client <identifiersep> core core , final request <identifiersep> scheduler sched , client <identifiersep> context context , chosen <identifiersep> block req ) { final key key = ( ( my <identifiersep> sendable <identifiersep> request <identifiersep> item ) req . token ) . key ; <ect>
private void inner <identifiersep> success ( bucket bucket , client <identifiersep> context context ) { byte [ ] data ; try { data = bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( bucket ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } string line ; try { line = new string ( data , <string_literal> ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
} catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } catch ( throwable t ) { <comment> <LOG> return ; } string [ ] split = line . split ( <string_literal> ) ; if ( split . length < <number_literal> ) { logger . error ( this , <string_literal> + line + <string_literal> ) ; return ; } if ( ! split [ 0 ] . starts <identifiersep> with ( <string_literal> ) ) { <ect>
return ; } string [ ] split = line . split ( <string_literal> ) ; if ( split . length < <number_literal> ) { logger . error ( this , <string_literal> + line + <string_literal> ) ; return ; } if ( ! split [ 0 ] . starts <identifiersep> with ( <string_literal> ) ) { <LOG> return ; } string value = split [ 1 ] ; long hint ; try { hint = long . parse <identifiersep> long ( value ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <ect>
if ( last <identifiersep> request <identifiersep> data == null ) data = null ; else { try { data = bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( last <identifiersep> request <identifiersep> data ) ; } catch ( io <identifiersep> exception e ) { <LOG> data = null ; } last <identifiersep> request <identifiersep> data . free ( ) ; } } for ( usk <identifiersep> fetcher <identifiersep> callback c : cb ) { try { if ( ed == - 1 ) c . on <identifiersep> failure ( context ) ; <ect>
if ( ! check <identifiersep> store <identifiersep> only ) { kill <identifiersep> attempts = cancel <identifiersep> before ( cur <identifiersep> latest , context ) ; usk <identifiersep> watching <identifiersep> keys . to <identifiersep> fetch list = watching <identifiersep> keys . get <identifiersep> editions <identifiersep> to <identifiersep> fetch ( cur <identifiersep> latest , context . random , get <identifiersep> running <identifiersep> fetch <identifiersep> editions ( ) , should <identifiersep> add <identifiersep> random <identifiersep> editions ( context . random ) ) ; lookup [ ] to <identifiersep> poll = list . to <identifiersep> poll ; lookup [ ] to <identifiersep> fetch = list . to <identifiersep> fetch ; for ( lookup i : to <identifiersep> poll ) { <LOG> attempts <identifiersep> to <identifiersep> start . add ( add ( i , true ) ) ; } for ( lookup i : to <identifiersep> fetch ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + i + <string_literal> + orig <identifiersep> usk ) ; attempts <identifiersep> to <identifiersep> start . add ( add ( i , false ) ) ; } } if ( ( ! schedule <identifiersep> after <identifiersep> db <identifiersep> rs <identifiersep> done ) || dbr <identifiersep> attempts . is <identifiersep> empty ( ) ) register <identifiersep> now = ! fill <identifiersep> keys <identifiersep> watching ( cur <identifiersep> latest , context ) ; <ect>
<comment> <LOG> attempts <identifiersep> to <identifiersep> start . add ( add ( i , true ) ) ; } for ( lookup i : to <identifiersep> fetch ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + i + <string_literal> + orig <identifiersep> usk ) ; attempts <identifiersep> to <identifiersep> start . add ( add ( i , false ) ) ; } } started = true ; if ( looked <identifiersep> up < = 0 && atts != null ) { <ect>
l . val = ed ; boolean poll = background <identifiersep> poll ; if ( ( ( ! poll ) && to <identifiersep> fetch . contains ( l ) ) || ( poll && to <identifiersep> poll . contains ( l ) ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + l ) ; continue ; } if ( already <identifiersep> running . remove ( l ) ) { <LOG> continue ; } client <identifiersep> ssk key ; <comment> <ect>
} else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + l ) ; } } else { if ( ! to <identifiersep> fetch . contains ( l ) ) { to <identifiersep> fetch . add ( l ) ; } else { <LOG> } } } } public synchronized void get <identifiersep> random <identifiersep> editions ( list < lookup > to <identifiersep> fetch , long looked <identifiersep> up , list < lookup > already <identifiersep> running , random random , int allowed ) { <comment> <ect>
errors . inc ( insert <identifiersep> exception <identifiersep> mode . route <identifiersep> not <identifiersep> found ) ; break ; case low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> really <identifiersep> not <identifiersep> found : errors . inc ( insert <identifiersep> exception <identifiersep> mode . route <identifiersep> really <identifiersep> not <identifiersep> found ) ; break ; default : <LOG> errors . inc ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) ; } if ( e . code == low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> not <identifiersep> found ) { consecutive <identifiersep> rn <identifiersep> fs ++ ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + consecutive <identifiersep> rn <identifiersep> fs + <string_literal> + consecutive <identifiersep> rn <identifiersep> fs <identifiersep> count <identifiersep> as <identifiersep> success ) ; if ( consecutive <identifiersep> rn <identifiersep> fs == consecutive <identifiersep> rn <identifiersep> fs <identifiersep> count <identifiersep> as <identifiersep> success ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + consecutive <identifiersep> rn <identifiersep> fs + <string_literal> ) ; <ect>
if ( matches . is <identifiersep> empty ( ) ) { return false ; } for ( key <identifiersep> listener listener : matches ) { try { remove <identifiersep> pending <identifiersep> keys ( listener ) ; } catch ( throwable t ) { <LOG> } } return true ; } public short get <identifiersep> key <identifiersep> prio ( key key , short priority , client <identifiersep> context context ) { assert ( key instanceof node <identifiersep> ssk == is <identifiersep> ssk <identifiersep> scheduler ) ; byte [ ] salted <identifiersep> key = salt <identifiersep> key ( key ) ; list < key <identifiersep> listener > matches = probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ; if ( matches . is <identifiersep> empty ( ) ) { <ect>
public synchronized long count <identifiersep> waiting <identifiersep> keys ( ) { long count = 0 ; for ( key <identifiersep> listener listener : key <identifiersep> listeners ) { try { count += listener . count <identifiersep> keys ( ) ; } catch ( throwable t ) { <LOG> } } return count ; } public boolean any <identifiersep> want <identifiersep> key ( key key , client <identifiersep> context context ) { assert ( key instanceof node <identifiersep> ssk == is <identifiersep> ssk <identifiersep> scheduler ) ; byte [ ] salted <identifiersep> key = salt <identifiersep> key ( key ) ; list < key <identifiersep> listener > matches = probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ; if ( ! matches . is <identifiersep> empty ( ) ) { <ect>
byte [ ] salted <identifiersep> key = salt <identifiersep> key ( key ) ; for ( key <identifiersep> listener listener : key <identifiersep> listeners ) { try { if ( listener . probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ) { return true ; } } catch ( throwable t ) { <LOG> } } return false ; } public boolean trip <identifiersep> pending <identifiersep> key ( key key , key <identifiersep> block block , client <identifiersep> context context ) { if ( ( key instanceof node <identifiersep> ssk ) != is <identifiersep> ssk <identifiersep> scheduler ) { logger . error ( this , <string_literal> + key + <string_literal> + is <identifiersep> ssk <identifiersep> scheduler , new exception ( <string_literal> ) ) ; return false ; } assert ( key instanceof node <identifiersep> ssk == is <identifiersep> ssk <identifiersep> scheduler ) ; <ect>
boolean ret = false ; for ( key <identifiersep> listener listener : matches ) { try { if ( listener . handle <identifiersep> block ( key , salted <identifiersep> key , block , context ) ) { ret = true ; } } catch ( throwable t ) { <LOG> } if ( listener . is <identifiersep> empty ( ) ) { try { remove <identifiersep> pending <identifiersep> keys ( listener ) ; } catch ( throwable t ) { logger . error ( this , format ( <string_literal> , listener ) , t ) ; } } } return ret ; <ect>
list < key <identifiersep> listener > matches = probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ; for ( key <identifiersep> listener listener : matches ) { sendable <identifiersep> get [ ] reqs ; try { reqs = listener . get <identifiersep> requests <identifiersep> for <identifiersep> key ( key , salted <identifiersep> key , context ) ; } catch ( throwable t ) { <LOG> continue ; } if ( reqs == null ) { continue ; } for ( sendable <identifiersep> get req : reqs ) { list . add ( req ) ; } } if ( list . is <identifiersep> empty ( ) ) { <ect>
<comment> <LOG> } inner <identifiersep> register ( req , context , null ) ; continue ; } <comment> <ect>
client <identifiersep> grabber . clear <identifiersep> wakeup <identifiersep> time ( context ) ; } return request <identifiersep> grabber ; } public void reregister <identifiersep> all ( client <identifiersep> requester request , request <identifiersep> scheduler lock , client <identifiersep> context context , short old <identifiersep> prio ) { request <identifiersep> client client = request . get <identifiersep> client ( ) ; short new <identifiersep> prio = request . get <identifiersep> priority <identifiersep> class ( ) ; if ( new <identifiersep> prio == old <identifiersep> prio ) { <LOG> return ; } client <identifiersep> request <identifiersep> scheduler <identifiersep> group group = request . get <identifiersep> scheduler <identifiersep> group ( ) ; synchronized ( this ) { <comment> <ect>
request <identifiersep> grabber . add <identifiersep> grabber ( group , rga , context ) ; } } public synchronized long count <identifiersep> queued <identifiersep> requests ( client <identifiersep> context context ) { long total = 0 ; for ( int i = 0 ; i < priorities . length ; i ++ ) { request <identifiersep> client <identifiersep> rga <identifiersep> node prio = priorities [ i ] ; if ( prio == null || prio . is <identifiersep> empty ( ) ) <LOG> else { system . out . println ( <string_literal> + i + <string_literal> + prio . size ( ) ) ; system . out . println ( <string_literal> + prio . size ( ) + <string_literal> + prio ) ; for ( int k = 0 ; k < prio . size ( ) ; k ++ ) { request <identifiersep> client client = prio . get <identifiersep> client ( k ) ; system . out . println ( <string_literal> + k + <string_literal> + client ) ; <ect>
for ( int i = 0 ; i < priorities . length ; i ++ ) { request <identifiersep> client <identifiersep> rga <identifiersep> node prio = priorities [ i ] ; if ( prio == null || prio . is <identifiersep> empty ( ) ) system . out . println ( <string_literal> + i + <string_literal> ) ; else { system . out . println ( <string_literal> + i + <string_literal> + prio . size ( ) ) ; <LOG> for ( int k = 0 ; k < prio . size ( ) ; k ++ ) { request <identifiersep> client client = prio . get <identifiersep> client ( k ) ; system . out . println ( <string_literal> + k + <string_literal> + client ) ; client <identifiersep> request <identifiersep> rga <identifiersep> node request <identifiersep> grabber = prio . get <identifiersep> grabber ( client ) ; system . out . println ( <string_literal> + request <identifiersep> grabber ) ; for ( int l = 0 ; l < request <identifiersep> grabber . size ( ) ; l ++ ) { <ect>
system . out . println ( <string_literal> + i + <string_literal> + prio . size ( ) ) ; system . out . println ( <string_literal> + prio . size ( ) + <string_literal> + prio ) ; for ( int k = 0 ; k < prio . size ( ) ; k ++ ) { request <identifiersep> client client = prio . get <identifiersep> client ( k ) ; system . out . println ( <string_literal> + k + <string_literal> + client ) ; client <identifiersep> request <identifiersep> rga <identifiersep> node request <identifiersep> grabber = prio . get <identifiersep> grabber ( client ) ; <LOG> for ( int l = 0 ; l < request <identifiersep> grabber . size ( ) ; l ++ ) { client <identifiersep> request <identifiersep> scheduler <identifiersep> group cr = request <identifiersep> grabber . get <identifiersep> client ( l ) ; system . out . println ( <string_literal> + l + <string_literal> + cr ) ; random <identifiersep> grab <identifiersep> array rga = request <identifiersep> grabber . get <identifiersep> grabber ( cr ) ; system . out . println ( <string_literal> + rga . size ( ) + <string_literal> + rga ) ; long sendable = 0 ; <ect>
client <identifiersep> request <identifiersep> rga <identifiersep> node request <identifiersep> grabber = prio . get <identifiersep> grabber ( client ) ; system . out . println ( <string_literal> + request <identifiersep> grabber ) ; for ( int l = 0 ; l < request <identifiersep> grabber . size ( ) ; l ++ ) { client <identifiersep> request <identifiersep> scheduler <identifiersep> group cr = request <identifiersep> grabber . get <identifiersep> client ( l ) ; system . out . println ( <string_literal> + l + <string_literal> + cr ) ; random <identifiersep> grab <identifiersep> array rga = request <identifiersep> grabber . get <identifiersep> grabber ( cr ) ; <LOG> long sendable = 0 ; long all = 0 ; for ( int m = 0 ; m < rga . size ( ) ; m ++ ) { sendable <identifiersep> request req = ( sendable <identifiersep> request ) rga . get ( m ) ; if ( req == null ) continue ; sendable += req . count <identifiersep> sendable <identifiersep> keys ( context ) ; <ect>
} catch ( unsafe <identifiersep> content <identifiersep> type <identifiersep> exception e ) { logger . normal ( this , <string_literal> , e ) ; ex = e . create <identifiersep> fetch <identifiersep> exception ( ctx . override <identifiersep> mime != null ? ctx . override <identifiersep> mime : expected <identifiersep> mime , expected <identifiersep> size ) ; <comment> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <comment> <LOG> ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; <comment> } catch ( compression <identifiersep> output <identifiersep> size <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> big , e ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { <ect>
} catch ( compression <identifiersep> output <identifiersep> size <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> big , e ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . not <identifiersep> enough <identifiersep> disk <identifiersep> space ) ; } catch ( io <identifiersep> exception e ) { <LOG> ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = e ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <ect>
} ) ; } @ override public void on <identifiersep> hashes ( hash <identifiersep> result [ ] hashes , client <identifiersep> context context ) { synchronized ( this ) { if ( this . hashes != null ) { if ( ! hash <identifiersep> result . strict <identifiersep> equals ( hashes , this . hashes ) ) <LOG> return ; } this . hashes = hashes ; } hash <identifiersep> result [ ] client <identifiersep> hashes = hashes ; if ( persistent ( ) ) client <identifiersep> hashes = hash <identifiersep> result . copy ( hashes ) ; final hash <identifiersep> result [ ] h = client <identifiersep> hashes ; context . get <identifiersep> job <identifiersep> runner ( persistent ( ) ) . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( new persistent <identifiersep> job ( ) { <ect>
} catch ( fetch <identifiersep> exception e ) { current <identifiersep> state = null ; logger . error ( this , <string_literal> + e , e ) ; throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } catch ( runtime <identifiersep> exception e ) { <comment> <LOG> throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } <comment> <ect>
resumed <identifiersep> fetcher = true ; return true ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return false ; } catch ( resume <identifiersep> failed <identifiersep> exception e ) { <LOG> return false ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return false ; } } else return false ; } public boolean resumed <identifiersep> fetcher ( ) { <ect>
if ( ! force && ! metadata <identifiersep> dirty ) return ; if ( cancelled ) return ; try { dos = new data <identifiersep> output <identifiersep> stream ( parent . write <identifiersep> checksummed <identifiersep> to ( parent . segment <identifiersep> status <identifiersep> offset ( seg <identifiersep> no ) , status <identifiersep> length ) ) ; inner <identifiersep> store <identifiersep> status ( dos ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } metadata <identifiersep> dirty = false ; } <comment> <ect>
read <identifiersep> key ( i ) ; } } catch ( io <identifiersep> exception e ) { parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; return ; } catch ( missing <identifiersep> key <identifiersep> exception e ) { <comment> <LOG> synchronized ( this ) { encoded = false ; } return ; } } public int stored <identifiersep> keys <identifiersep> length ( ) { return key <identifiersep> length * total <identifiersep> block <identifiersep> count ; } public byte [ ] read <identifiersep> data <identifiersep> block ( int block <identifiersep> no ) throws io <identifiersep> exception { <ect>
return encoding ; } public client <identifiersep> chk <identifiersep> block encode <identifiersep> block ( int block <identifiersep> no ) throws io <identifiersep> exception { if ( parent . is <identifiersep> finishing ( ) ) { throw new io <identifiersep> exception ( <string_literal> + block <identifiersep> no + <string_literal> + this + <string_literal> + parent ) ; } synchronized ( this ) { if ( this . block <identifiersep> chooser . has <identifiersep> succeeded ( block <identifiersep> no ) ) { <LOG> throw new io <identifiersep> exception ( <string_literal> + block <identifiersep> no + <string_literal> + this + <string_literal> + parent ) ; } } byte [ ] buf = read <identifiersep> block ( block <identifiersep> no ) ; return encode <identifiersep> block ( buf ) ; } private byte [ ] read <identifiersep> block ( int block <identifiersep> no ) throws io <identifiersep> exception { assert ( block <identifiersep> no >= 0 && block <identifiersep> no < total <identifiersep> block <identifiersep> count ) ; if ( block <identifiersep> no < data <identifiersep> block <identifiersep> count ) <ect>
try { read <identifiersep> key ( block <identifiersep> no ) ; block <identifiersep> chooser . on <identifiersep> rnf ( block <identifiersep> no ) ; parent . clear <identifiersep> cooldown ( ) ; return ; } catch ( missing <identifiersep> key <identifiersep> exception e1 ) { <LOG> } catch ( io <identifiersep> exception e1 ) { if ( parent . has <identifiersep> finished ( ) ) return ; <comment> <ect>
try { sbi . schedule ( context ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ctr + <string_literal> + data ) ; return true ; } catch ( throwable e ) { <LOG> return false ; } } @ override public void queue ( bucket data , byte [ ] crypto <identifiersep> key , byte crypto <identifiersep> algorithm , client <identifiersep> context context ) { if ( ! inner <identifiersep> queue ( data , crypto <identifiersep> key , crypto <identifiersep> algorithm , context ) ) data . free ( ) ; } @ override <ect>
public void on <identifiersep> transition ( client <identifiersep> put <identifiersep> state old <identifiersep> state , client <identifiersep> put <identifiersep> state new <identifiersep> state , client <identifiersep> context context ) { <comment> <LOG> } @ override public void on <identifiersep> block <identifiersep> set <identifiersep> finished ( client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { <comment> <ect>
this . generate <identifiersep> hashes = generate <identifiersep> hashes ; this . pre1254 = pre1254 ; } public void init ( final client <identifiersep> context ctx ) { synchronized ( this ) { <comment> <LOG> return ; } scheduled = true ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + orig <identifiersep> data . size ( ) + <string_literal> + inserter + <string_literal> + orig <identifiersep> data + <string_literal> + generate <identifiersep> hashes ) ; ctx . rc . enqueue <identifiersep> new <identifiersep> job ( this ) ; } @ override <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + generate <identifiersep> hashes ) ; is = hasher = new multi <identifiersep> hash <identifiersep> input <identifiersep> stream ( is , generate <identifiersep> hashes ) ; } try { comp . compress ( is , os , orig <identifiersep> size , best <identifiersep> compressed <identifiersep> data <identifiersep> size ) ; } catch ( runtime <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
return native <identifiersep> thread . norm <identifiersep> priority ; } @ override public void run ( ) { try { inserter . on <identifiersep> compressed ( output , context ) ; } catch ( throwable t ) { <LOG> } } } , <string_literal> + this ) ; } } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; if ( best <identifiersep> compressed <identifiersep> data != null && best <identifiersep> compressed <identifiersep> data != orig <identifiersep> data ) best <identifiersep> compressed <identifiersep> data . free ( ) ; } catch ( invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception e ) { <ect>
@ override public boolean run ( client <identifiersep> context context ) { inserter . cb . on <identifiersep> failure ( ie , inserter , context ) ; return true ; } } , native <identifiersep> thread . norm <identifiersep> priority + 1 ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e1 ) { <LOG> if ( best <identifiersep> compressed <identifiersep> data != null && best <identifiersep> compressed <identifiersep> data != orig <identifiersep> data ) best <identifiersep> compressed <identifiersep> data . free ( ) ; } } else { inserter . cb . on <identifiersep> failure ( ie , inserter , context ) ; } } <comment> <ect>
if ( ! hash <identifiersep> result . strict <identifiersep> equals ( results , hashes ) ) { logger . error ( this , <string_literal> + hash <identifiersep> stream . get <identifiersep> read <identifiersep> bytes ( ) + <string_literal> + <string_literal> + uri ) ; throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> hash <identifiersep> failed ) ; } } on <identifiersep> finish ( ) ; } catch ( throwable t ) { if ( ! ( t instanceof fetch <identifiersep> exception || t instanceof unsafe <identifiersep> content <identifiersep> type <identifiersep> exception || t instanceof compression <identifiersep> output <identifiersep> size <identifiersep> exception ) ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + t , t ) ; set <identifiersep> error ( t ) ; } finally { closer . close ( input ) ; closer . close ( output ) ; <ect>
string name = me . get <identifiersep> key ( ) ; object o = me . get <identifiersep> value ( ) ; if ( o instanceof hash <identifiersep> map ) { @ suppress <identifiersep> warnings ( <string_literal> ) hash <identifiersep> map < string , object > hm = ( hash <identifiersep> map < string , object > ) o ; hash <identifiersep> map < string , object > sub <identifiersep> map = new hash <identifiersep> map < string , object > ( ) ; <LOG> smc . add <identifiersep> item ( name , make <identifiersep> manifest ( hm , archive <identifiersep> prefix + name + ' / ' ) ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + name + <string_literal> + sub <identifiersep> map . size ( ) + <string_literal> + hm . size ( ) ) ; } else if ( o instanceof metadata ) { <comment> <ect>
<comment> <LOG> smc . add <identifiersep> item ( name , ( metadata ) o ) ; } else { manifest <identifiersep> element element = ( manifest <identifiersep> element ) o ; string mime <identifiersep> type = element . get <identifiersep> mime <identifiersep> type ( ) ; client <identifiersep> metadata cm ; if ( mime <identifiersep> type == null || mime <identifiersep> type . equals ( default <identifiersep> mime <identifiersep> types . default <identifiersep> mime <identifiersep> type ) ) <ect>
try { core . node . store ( b , false , req . can <identifiersep> write <identifiersep> client <identifiersep> cache , true , false ) ; } catch ( key <identifiersep> collision <identifiersep> exception e ) { low <identifiersep> level <identifiersep> put <identifiersep> exception failed = new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . collision ) ; key <identifiersep> block collided = core . node . fetch ( k . get <identifiersep> node <identifiersep> key ( ) , true , req . can <identifiersep> write <identifiersep> client <identifiersep> cache , false , false , null ) ; if ( collided == null ) { <LOG> <comment> <ect>
return true ; } else { if ( single <identifiersep> block <identifiersep> inserter . log <identifiersep> minor ) logger . minor ( this , <string_literal> + collided . is <identifiersep> metadata ( ) + <string_literal> + block . is <identifiersep> metadata + <string_literal> + collided . get <identifiersep> compression <identifiersep> codec ( ) + <string_literal> + block . compression <identifiersep> codec + <string_literal> + data . length + <string_literal> + inserting . length + <string_literal> + fields . hash <identifiersep> code ( data ) + <string_literal> + fields . hash <identifiersep> code ( inserting ) ) ; } } catch ( key <identifiersep> verify <identifiersep> exception e1 ) { <LOG> } catch ( key <identifiersep> decode <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 + <string_literal> , e1 ) ; } catch ( io <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 + <string_literal> , e1 ) ; } } req . on <identifiersep> failure ( e , context ) ; if ( single <identifiersep> block <identifiersep> inserter . log <identifiersep> minor ) logger . minor ( this , <string_literal> + e ) ; <ect>
<string_literal> + data . length + <string_literal> + inserting . length + <string_literal> + fields . hash <identifiersep> code ( data ) + <string_literal> + fields . hash <identifiersep> code ( inserting ) ) ; } } catch ( key <identifiersep> verify <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 + <string_literal> , e1 ) ; } catch ( key <identifiersep> decode <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 + <string_literal> , e1 ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> } } req . on <identifiersep> failure ( e , context ) ; if ( single <identifiersep> block <identifiersep> inserter . log <identifiersep> minor ) logger . minor ( this , <string_literal> + e ) ; return true ; } finally { block . copy <identifiersep> bucket . free ( ) ; } if ( single <identifiersep> block <identifiersep> inserter . log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <ect>
private block <identifiersep> item get <identifiersep> block <identifiersep> item ( block <identifiersep> item <identifiersep> key key , client <identifiersep> context context ) throws insert <identifiersep> exception { try { synchronized ( this ) { if ( finished ) return null ; } if ( persistent ) { if ( source <identifiersep> data == null ) { <LOG> fail ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) , context ) ; return null ; } } bucket data = source <identifiersep> data . create <identifiersep> shadow ( ) ; freenet <identifiersep> uri u = uri ; if ( u . get <identifiersep> key <identifiersep> type ( ) . equals ( <string_literal> ) ) u = freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ; if ( data == null ) { <ect>
total <identifiersep> blocks ++ ; was <identifiersep> finalized = block <identifiersep> set <identifiersep> finalized ; } if ( was <identifiersep> finalized ) { if ( log <identifiersep> level . minor . matches <identifiersep> threshold ( logger . global <identifiersep> get <identifiersep> threshold <identifiersep> new ( ) ) ) logger . error ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; else <LOG> } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + total <identifiersep> blocks + <string_literal> + successful <identifiersep> blocks + <string_literal> + failed <identifiersep> blocks + <string_literal> + min <identifiersep> success <identifiersep> blocks ) ; } <comment> public void add <identifiersep> blocks ( int num ) { boolean was <identifiersep> finalized ; synchronized ( this ) { total <identifiersep> blocks += num ; <ect>
total <identifiersep> blocks += num ; was <identifiersep> finalized = block <identifiersep> set <identifiersep> finalized ; } if ( was <identifiersep> finalized ) { if ( log <identifiersep> level . minor . matches <identifiersep> threshold ( logger . global <identifiersep> get <identifiersep> threshold <identifiersep> new ( ) ) ) logger . error ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; else <LOG> } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + num + <string_literal> + total <identifiersep> blocks + <string_literal> + successful <identifiersep> blocks + <string_literal> + failed <identifiersep> blocks + <string_literal> + min <identifiersep> success <identifiersep> blocks ) ; } <comment> public void completed <identifiersep> block ( boolean dont <identifiersep> notify , client <identifiersep> context context ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + dont <identifiersep> notify + <string_literal> + total <identifiersep> blocks + <string_literal> + successful <identifiersep> blocks + <string_literal> + failed <identifiersep> blocks + <string_literal> + fatally <identifiersep> failed <identifiersep> blocks + <string_literal> + block <identifiersep> set <identifiersep> finalized + <string_literal> + min <identifiersep> success <identifiersep> blocks + <string_literal> + this ) ; synchronized ( this ) { <ect>
finished = true ; current <identifiersep> state = null ; } <comment> <LOG> synchronized ( this ) { finished = true ; current <identifiersep> state = null ; } <comment> <ect>
@ override public void on <identifiersep> encode ( base <identifiersep> client <identifiersep> key key , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { freenet <identifiersep> uri u ; synchronized ( this ) { u = key . get <identifiersep> uri ( ) ; if ( got <identifiersep> final <identifiersep> metadata ) { <LOG> } if ( target <identifiersep> filename != null ) u = u . push <identifiersep> meta <identifiersep> string ( target <identifiersep> filename ) ; if ( this . uri != null ) { if ( ! this . uri . equals ( u ) ) { logger . error ( this , <string_literal> + this . uri + <string_literal> + u + <string_literal> + this , new exception ( <string_literal> ) ) ; } return ; <ect>
<comment> public void on <identifiersep> metadata ( bucket final <identifiersep> metadata , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { boolean free <identifiersep> it = false ; synchronized ( this ) { if ( uri != null ) { <LOG> } if ( got <identifiersep> final <identifiersep> metadata ) { logger . error ( this , <string_literal> + this ) ; free <identifiersep> it = true ; } else { got <identifiersep> final <identifiersep> metadata = true ; } } if ( free <identifiersep> it ) { <ect>
context . job <identifiersep> runner . set <identifiersep> checkpoint <identifiersep> asap ( ) ; logger . normal ( this , <string_literal> + current <identifiersep> state + <string_literal> + old <identifiersep> state + <string_literal> + new <identifiersep> state ) ; } <comment> @ override public void on <identifiersep> metadata ( metadata m , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { <LOG> } <comment> protected int min <identifiersep> success <identifiersep> fetch <identifiersep> blocks ; @ override public int get <identifiersep> min <identifiersep> success <identifiersep> fetch <identifiersep> blocks ( ) { return min <identifiersep> success <identifiersep> fetch <identifiersep> blocks ; } @ override <ect>
<comment> <LOG> system . out . println ( <string_literal> + finished ) ; system . out . println ( <string_literal> + data ) ; } public byte [ ] get <identifiersep> client <identifiersep> detail ( checksum <identifiersep> checker checker ) throws io <identifiersep> exception { if ( client instanceof persistent <identifiersep> client <identifiersep> callback ) { return get <identifiersep> client <identifiersep> detail ( ( persistent <identifiersep> client <identifiersep> callback ) client , checker ) ; } else <ect>
<comment> <LOG> } public byte [ ] get <identifiersep> client <identifiersep> detail ( checksum <identifiersep> checker checker ) throws io <identifiersep> exception { if ( client instanceof persistent <identifiersep> client <identifiersep> callback ) { return get <identifiersep> client <identifiersep> detail ( ( persistent <identifiersep> client <identifiersep> callback ) client , checker ) ; } else return new byte [ 0 ] ; } @ override <ect>
public void on <identifiersep> success ( client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { on <identifiersep> block <identifiersep> set <identifiersep> finished ( state , context ) ; on <identifiersep> fetchable ( state ) ; boolean complete = true ; synchronized ( this ) { if ( finished ) { <LOG> return ; } list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( waiting <identifiersep> for , state ) ; list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( waiting <identifiersep> for <identifiersep> block <identifiersep> set , state ) ; list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( waiting <identifiersep> for <identifiersep> fetchable , state ) ; if ( ! ( waiting <identifiersep> for . is <identifiersep> empty ( ) && started ) ) { complete = false ; <ect>
@ override public void on <identifiersep> encode ( base <identifiersep> client <identifiersep> key key , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { synchronized ( this ) { if ( state != generator ) return ; if ( encoded <identifiersep> key != null ) { if ( key . equals ( encoded <identifiersep> key ) ) return ; <comment> <LOG> } encoded <identifiersep> key = key ; } cb . on <identifiersep> encode ( key , this , context ) ; } @ override public void cancel ( client <identifiersep> context context ) { client <identifiersep> put <identifiersep> state [ ] states = new client <identifiersep> put <identifiersep> state [ waiting <identifiersep> for . size ( ) ] ; synchronized ( this ) { <ect>
logger . error ( this , <string_literal> + state ) ; } } @ override public synchronized void on <identifiersep> metadata ( bucket metadata , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { if ( generator == state ) { cb . on <identifiersep> metadata ( metadata , this , context ) ; } else { <LOG> } } @ override public void on <identifiersep> block <identifiersep> set <identifiersep> finished ( client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { synchronized ( this ) { list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( this . waiting <identifiersep> for <identifiersep> block <identifiersep> set , state ) ; if ( ! started ) return ; if ( ! waiting <identifiersep> for <identifiersep> block <identifiersep> set . is <identifiersep> empty ( ) ) return ; <ect>
void on <identifiersep> compressed ( compression <identifiersep> output output , client <identifiersep> context context ) { synchronized ( this ) { if ( started ) { logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; return ; } if ( cancelled ) { <LOG> return ; } } try { on <identifiersep> compressed <identifiersep> inner ( output , context ) ; } catch ( insert <identifiersep> exception e ) { cb . on <identifiersep> failure ( e , single <identifiersep> file <identifiersep> inserter . this , context ) ; } catch ( throwable t ) { <ect>
insert <identifiersep> exception e = null ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + state ) ; synchronized ( this ) { if ( finished ) return ; if ( report <identifiersep> metadata <identifiersep> only ) { if ( state != sfi ) { <LOG> return ; } meta <identifiersep> insert <identifiersep> success = true ; } else if ( state == metadata <identifiersep> putter ) { logger . error ( this , <string_literal> ) ; e = new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , null ) ; } else if ( state != sfi ) { <ect>
return ; } meta <identifiersep> insert <identifiersep> success = true ; } else if ( state == metadata <identifiersep> putter ) { logger . error ( this , <string_literal> ) ; e = new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , null ) ; } else if ( state != sfi ) { <LOG> e = new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , null ) ; } else { <comment> <ect>
hm . put ( target <identifiersep> filename , meta ) ; meta = metadata . mk <identifiersep> redirection <identifiersep> manifest <identifiersep> with <identifiersep> metadata ( hm ) ; meta <identifiersep> putter <identifiersep> target <identifiersep> filename = null ; try { meta <identifiersep> bytes = meta . write <identifiersep> to <identifiersep> byte <identifiersep> array ( ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e1 ) { <LOG> fail ( ( insert <identifiersep> exception ) new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e1 , null ) . init <identifiersep> cause ( e1 ) , context ) ; return ; } } } random <identifiersep> access <identifiersep> bucket metadata <identifiersep> bucket ; try { metadata <identifiersep> bucket = bucket <identifiersep> tools . make <identifiersep> immutable <identifiersep> bucket ( context . get <identifiersep> bucket <identifiersep> factory ( persistent ) , meta <identifiersep> bytes ) ; } catch ( io <identifiersep> exception e1 ) { <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + state + ' ) ' ) ; boolean meta ; synchronized ( this ) { meta = ( state == metadata <identifiersep> putter ) ; if ( meta ) { if ( ! meta <identifiersep> insert <identifiersep> started ) { <LOG> } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( meta <identifiersep> fetchable ? <string_literal> : <string_literal> ) ) ; if ( meta <identifiersep> fetchable ) return ; meta <identifiersep> fetchable = true ; } else { if ( state != sfi ) { logger . error ( this , <string_literal> + state ) ; <ect>
putter . schedule ( context ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + putter + <string_literal> + this ) ; return true ; } else { return false ; } } catch ( insert <identifiersep> exception e1 ) { <LOG> fail ( e1 , context ) ; return true ; } } @ override public void on <identifiersep> metadata ( bucket meta , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + state ) ; boolean free <identifiersep> it = false ; <ect>
free <identifiersep> it = true ; } else { <comment> <LOG> return ; } meta <identifiersep> insert <identifiersep> success = true ; } else { logger . error ( this , <string_literal> + state ) ; free <identifiersep> it = true ; } } if ( free <identifiersep> it ) { <ect>
if ( ! parent . persistent ) return ; data <identifiersep> output <identifiersep> stream dos ; try { dos = new data <identifiersep> output <identifiersep> stream ( parent . write <identifiersep> checksummed <identifiersep> to ( parent . cross <identifiersep> segment <identifiersep> status <identifiersep> offset ( seg <identifiersep> no ) , status <identifiersep> length ) ) ; inner <identifiersep> store <identifiersep> status ( dos ) ; } catch ( io <identifiersep> exception e ) { <LOG> return ; } try { dos . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; <ect>
int segments = storage . segments . length ; segment <identifiersep> filters = new binary <identifiersep> bloom <identifiersep> filter [ segments ] ; byte [ ] segments <identifiersep> filter <identifiersep> buffer = new byte [ per <identifiersep> segment <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes * segments ] ; try { storage . pread <identifiersep> checksummed ( storage . offset <identifiersep> segment <identifiersep> bloom <identifiersep> filters , segments <identifiersep> filter <identifiersep> buffer , 0 , segments <identifiersep> filter <identifiersep> buffer . length ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> must <identifiersep> regenerate <identifiersep> segment <identifiersep> filters = true ; } byte <identifiersep> buffer base <identifiersep> buffer = byte <identifiersep> buffer . wrap ( segments <identifiersep> filter <identifiersep> buffer ) ; int start = 0 ; int end = per <identifiersep> segment <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes ; for ( int i = 0 ; i < segments ; i ++ ) { base <identifiersep> buffer . position ( start ) ; <ect>
byte [ ] salted <identifiersep> key = salter . salt <identifiersep> key ( key ) ; filter . add <identifiersep> key ( salted <identifiersep> key ) ; } if ( must <identifiersep> regenerate <identifiersep> segment <identifiersep> filters || ! finished <identifiersep> setup ) { byte [ ] local <identifiersep> salted = local <identifiersep> salt <identifiersep> key ( key ) ; segment <identifiersep> filters [ seg <identifiersep> no ] . add <identifiersep> key ( local <identifiersep> salted ) ; } <comment> <LOG> } synchronized void finished <identifiersep> setup ( ) { finished <identifiersep> setup = true ; } private byte [ ] local <identifiersep> salt <identifiersep> key ( key key ) { message <identifiersep> digest md = sha256 . get <identifiersep> message <identifiersep> digest ( ) ; md . update ( key . get <identifiersep> routing <identifiersep> key ( ) ) ; md . update ( local <identifiersep> salt ) ; <ect>
this . orig <identifiersep> sfi = new single <identifiersep> file <identifiersep> inserter ( this , this , block , false , ctx , real <identifiersep> time <identifiersep> flag , false , true , null , null , false , null , false , persistent ( ) , 0 , 0 , null , crypto <identifiersep> algorithm , force <identifiersep> crypto <identifiersep> key , - 1 ) ; } @ override public void on <identifiersep> encode ( base <identifiersep> client <identifiersep> key key , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + key + <string_literal> + this ) ; <comment> <LOG> <comment> <ect>
this . item <identifiersep> name = name ; metadata = null ; parent <identifiersep> put <identifiersep> handler = parent ; if ( running <identifiersep> map != null ) { synchronized ( running <identifiersep> map ) { if ( running <identifiersep> map . contains ( this ) ) { <LOG> } else { running <identifiersep> map . add ( this ) ; } } } synchronized ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets ) { if ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . contains ( this ) ) { logger . error ( this , <string_literal> , new error ( <string_literal> ) ) ; } else { <ect>
if ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . contains ( this ) ) { logger . error ( this , <string_literal> , new error ( <string_literal> ) ) ; } else { put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . add ( this ) ; } } synchronized ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable ) { if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable . contains ( this ) ) { <LOG> } else { put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable . add ( this ) ; } } } <comment> <ect>
ok = running <identifiersep> put <identifiersep> handlers . contains ( this ) ; } if ( ! ok ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + this ) ; } } } synchronized ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets ) { ok = put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . contains ( this ) ; } if ( ! ok ) { <LOG> <comment> <ect>
synchronized ( this ) { old <identifiersep> state = current <identifiersep> state ; current <identifiersep> state = null ; } synchronized ( base <identifiersep> manifest <identifiersep> putter . this ) { running <identifiersep> put <identifiersep> handlers . remove ( this ) ; if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> metadata . remove ( this ) ) { <LOG> } if ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . remove ( this ) ) { logger . error ( this , <string_literal> + this + <string_literal> + base <identifiersep> manifest <identifiersep> putter . this , new error ( <string_literal> ) ) ; } if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable . remove ( this ) ) { logger . error ( this , <string_literal> + this + <string_literal> + base <identifiersep> manifest <identifiersep> putter . this , new error ( <string_literal> ) ) ; } if ( ! running <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> minor ) { <ect>
running <identifiersep> put <identifiersep> handlers . remove ( this ) ; if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> metadata . remove ( this ) ) { logger . error ( this , <string_literal> + this . item <identifiersep> name + <string_literal> + this + <string_literal> + base <identifiersep> manifest <identifiersep> putter . this , new error ( <string_literal> ) ) ; } if ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . remove ( this ) ) { logger . error ( this , <string_literal> + this + <string_literal> + base <identifiersep> manifest <identifiersep> putter . this , new error ( <string_literal> ) ) ; } if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable . remove ( this ) ) { <LOG> } if ( ! running <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> + running <identifiersep> put <identifiersep> handlers . size ( ) ) ; for ( object o : running <identifiersep> put <identifiersep> handlers ) { logger . minor ( this , <string_literal> + o ) ; } } } } try <identifiersep> complete ( context ) ; <ect>
try { if ( current <identifiersep> state != null ) current <identifiersep> state . on <identifiersep> resume ( context ) ; if ( orig <identifiersep> sfi != null ) orig <identifiersep> sfi . on <identifiersep> resume ( context ) ; } catch ( insert <identifiersep> exception e ) { <LOG> throw new resume <identifiersep> failed <identifiersep> exception ( <string_literal> + e ) ; } } @ override public void on <identifiersep> shutdown ( client <identifiersep> context context ) { client <identifiersep> put <identifiersep> state s ; synchronized ( this ) { s = current <identifiersep> state ; <ect>
if ( killed ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; if ( context == null ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; if ( must <identifiersep> checkpoint && enable <identifiersep> checkpointing ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + job ) ; queued <identifiersep> jobs . add ( new queued <identifiersep> job ( job , thread <identifiersep> priority ) ) ; } else { <LOG> executor . execute ( new job <identifiersep> runnable ( job , thread <identifiersep> priority , context ) ) ; running <identifiersep> jobs ++ ; } } } @ override public void queue <identifiersep> internal ( persistent <identifiersep> job job , int thread <identifiersep> priority ) throws persistence <identifiersep> disabled <identifiersep> exception { synchronized ( sync ) { if ( ! loading ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; <ect>
logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; queued <identifiersep> jobs . add ( new queued <identifiersep> job ( job , thread <identifiersep> priority ) ) ; } else { if ( must <identifiersep> checkpoint ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } running <identifiersep> jobs ++ ; <LOG> executor . execute ( new job <identifiersep> runnable ( job , thread <identifiersep> priority , context ) ) ; } } } @ override public void queue <identifiersep> internal ( persistent <identifiersep> job job ) { try { queue <identifiersep> internal ( job , native <identifiersep> thread . norm <identifiersep> priority ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <ect>
this . thread <identifiersep> priority = thread <identifiersep> priority ; this . context = context ; } @ override public void run ( ) { boolean ret = false ; try { <LOG> ret = job . run ( context ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> + job , t ) ; } finally { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + job + <string_literal> + must <identifiersep> checkpoint + <string_literal> + enable <identifiersep> checkpointing + <string_literal> + running <identifiersep> jobs ) ; handle <identifiersep> completion ( ret , thread <identifiersep> priority ) ; <ect>
try { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + job ) ; ret = job . run ( context ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> + job , t ) ; } finally { <LOG> handle <identifiersep> completion ( ret , thread <identifiersep> priority ) ; } } } public void handle <identifiersep> completion ( boolean ret , int thread <identifiersep> priority ) { synchronized ( sync ) { running <identifiersep> jobs -- ; if ( running <identifiersep> jobs == 0 ) <comment> <ect>
sync . notify <identifiersep> all ( ) ; return ; } } synchronized ( serialize <identifiersep> checkpoints ) { try { inner <identifiersep> checkpoint ( shutdown ) ; } catch ( throwable t ) { <LOG> } } synchronized ( sync ) { must <identifiersep> checkpoint = false ; writing = false ; queued <identifiersep> job [ ] jobs = queued <identifiersep> jobs . to <identifiersep> array ( new queued <identifiersep> job [ queued <identifiersep> jobs . size ( ) ] ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + jobs . length + <string_literal> ) ; for ( queued <identifiersep> job job : jobs ) { <ect>
<comment> public void wait <identifiersep> for <identifiersep> idle <identifiersep> and <identifiersep> checkpoint ( ) { synchronized ( sync ) { while ( running <identifiersep> jobs > 0 || writing ) { if ( ! enable <identifiersep> checkpointing ) return ; <LOG> try { sync . wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
public synchronized void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uri ) ; if ( this . uri == null ) this . uri = uri ; if ( uri . equals ( this . uri ) ) return ; <LOG> } <comment> public synchronized freenet <identifiersep> uri wait <identifiersep> for <identifiersep> completion ( ) throws insert <identifiersep> exception { while ( ! finished ) { try { wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { <ect>
throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , uri ) ; } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { <comment> <LOG> metadata . free ( ) ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { throw new unsupported <identifiersep> operation <identifiersep> exception ( ) ; <comment> <ect>
<comment> public static string htm <identifiersep> lelement <identifiersep> verifier ( string element <identifiersep> string , boolean is <identifiersep> id <identifiersep> selector ) { <LOG> string htm <identifiersep> lelement = <string_literal> , pseudo <identifiersep> class = <string_literal> , class <identifiersep> name = <string_literal> , id = <string_literal> ; boolean is <identifiersep> valid = true ; string <identifiersep> builder f <identifiersep> buffer = new string <identifiersep> builder ( ) ; array <identifiersep> list < string > att <identifiersep> selections = null ; while ( element <identifiersep> string . index <identifiersep> of ( ' [ ' ) != - 1 && element <identifiersep> string . index <identifiersep> of ( ' ] ' ) != - 1 && ( element <identifiersep> string . index <identifiersep> of ( ' [ ' ) < element <identifiersep> string . index <identifiersep> of ( ' ] ' ) ) ) { <ect>
if ( is <identifiersep> id <identifiersep> selector ) return null ; int index = element <identifiersep> string . index <identifiersep> of ( ' : ' ) ; if ( index != element <identifiersep> string . length ( ) - 1 ) { pseudo <identifiersep> class = element <identifiersep> string . substring ( index + 1 , element <identifiersep> string . length ( ) ) . trim ( ) ; htm <identifiersep> lelement = element <identifiersep> string . substring ( 0 , index ) . trim ( ) ; <LOG> } else { htm <identifiersep> lelement = element <identifiersep> string . trim ( ) ; } } else htm <identifiersep> lelement = element <identifiersep> string . trim ( ) ; if ( htm <identifiersep> lelement . index <identifiersep> of ( ' . ' ) != - 1 ) <ect>
<comment> <LOG> } } if ( is <identifiersep> id <identifiersep> selector && <string_literal> . equals ( id ) ) return null ; <comment> <ect>
{ if ( ! ( ( c >= 'a' && c < = 'z' ) || ( c >= 'a' && c < = 'z' ) || c == ' <identifiersep> ' || c == ' - ' ) ) is <identifiersep> valid = false ; } } if ( att <identifiersep> selection <identifiersep> parts . length > 1 ) { <comment> <LOG> if ( ! ( element <identifiersep> info . is <identifiersep> valid <identifiersep> identifier ( att <identifiersep> selection <identifiersep> parts [ 1 ] ) || element <identifiersep> info . is <identifiersep> valid <identifiersep> string <identifiersep> with <identifiersep> quotes ( att <identifiersep> selection <identifiersep> parts [ 1 ] ) ) ) is <identifiersep> valid = false ; } } } if ( is <identifiersep> valid ) { f <identifiersep> buffer . append ( htm <identifiersep> lelement ) ; if ( ! class <identifiersep> name . equals ( <string_literal> ) ) { f <identifiersep> buffer . append ( ' . ' ) ; <ect>
} else if ( c == ' \\ n' && eat <identifiersep> lf ) { <comment> <LOG> return null ; } else if ( c == ' \\ r' && escaping && escaped <identifiersep> digits == 0 ) { escaping = false ; eat <identifiersep> lf = true ; } else if ( ( c == ' \\ n' || c == ' \\ f' ) && escaping ) { if ( escaped <identifiersep> digits == 0 ) <ect>
} else if ( escaping && escaped <identifiersep> digits > 0 && ( <string_literal> . index <identifiersep> of ( c ) != - 1 ) ) { escaping = false ; if ( c == ' \\ r' ) eat <identifiersep> lf = true ; } else if ( c == ' \\ \\ ' && ! escaping ) { escaping = true ; } else if ( c == ' \\ \\ ' && escaping && escaped <identifiersep> digits > 0 ) { <LOG> return null ; <comment> <ect>
if ( bracketing != 0 ) return null ; <comment> <LOG> parts [ 0 ] = htm <identifiersep> lelement <identifiersep> verifier ( parts [ 0 ] , false ) ; parts [ 1 ] = recursive <identifiersep> selector <identifiersep> verifier ( parts [ 1 ] ) ; if ( parts [ 0 ] != null && parts [ 1 ] != null ) return parts [ 0 ] + selector + parts [ 1 ] ; else return null ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; w . write ( x ) ; } continue ; } bom <identifiersep> possible = false ; prevc = c ; c = ( char ) x ; <LOG> if ( prevc == ' / ' && c == ' * ' && current <identifiersep> state != state1inquote && current <identifiersep> state != state2inquote && current <identifiersep> state != state3inquote && current <identifiersep> state != statecomment ) { state <identifiersep> before <identifiersep> comment = current <identifiersep> state ; current <identifiersep> state = statecomment ; if ( buffer . char <identifiersep> at ( buffer . length ( ) - 1 ) == ' / ' ) { <ect>
break ; } w . write ( buffer . substring ( 0 , i ) ) ; buffer . delete ( 0 , i ) ; if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { w . write ( buffer . substring ( 0 , <number_literal> ) ) ; if ( <string_literal> . index <identifiersep> of ( buffer . char <identifiersep> at ( <number_literal> ) ) == - 1 ) { <LOG> return ; } buffer . delete ( 0 , <number_literal> ) ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
<comment> <LOG> if ( ! charset . is <identifiersep> supported ( detected <identifiersep> charset ) ) { logger . normal ( this , <string_literal> + detected <identifiersep> charset ) ; throw new unsupported <identifiersep> charset <identifiersep> in <identifiersep> filter <identifiersep> exception ( <string_literal> + detected <identifiersep> charset ) ; } if ( stop <identifiersep> at <identifiersep> detected <identifiersep> charset ) return ; if ( passed <identifiersep> charset != null && ! detected <identifiersep> charset . equals <identifiersep> ignore <identifiersep> case ( passed <identifiersep> charset ) ) { logger . normal ( this , <string_literal> + detected <identifiersep> charset + <string_literal> + passed <identifiersep> charset + <string_literal> ) ; <ect>
if ( ! ( s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) ) ) current <identifiersep> state = state2 ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; break ; } break ; case state1inquote : <LOG> switch ( c ) { case ' <string_literal> ' && prevc != ' \\ \\ ' ) current <identifiersep> state = state1 ; buffer . append ( c ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . substring ( 0 , i ) + <string_literal> ) ; string ws = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { ws += buffer . substring ( 0 , <number_literal> ) ; if ( <string_literal> . index <identifiersep> of ( buffer . char <identifiersep> at ( <number_literal> ) ) == - 1 ) { <LOG> return ; } buffer . delete ( 0 , <number_literal> ) ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
<comment> <LOG> buffer . set <identifiersep> length ( 0 ) ; break ; case ' , ' : if ( prevc == ' \\ \\ ' ) { <comment> <ect>
ws = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; if ( ! s2comma ) { if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { filtered <identifiersep> tokens . append ( buffer . substring ( 0 , <number_literal> ) ) ; if ( <string_literal> . index <identifiersep> of ( buffer . char <identifiersep> at ( <number_literal> ) ) == - 1 ) { <LOG> return ; } buffer . delete ( 0 , <number_literal> ) ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
open <identifiersep> braces -- ; <comment> <LOG> w . write ( filtered <identifiersep> tokens . to <identifiersep> string ( ) ) ; } else { if ( open <identifiersep> braces > 0 ) open <identifiersep> braces -- ; <comment> <ect>
buffer . append ( c ) ; current <identifiersep> state = state2inquote ; current <identifiersep> quote = c ; break ; default : buffer . append ( c ) ; <LOG> break ; } break ; case state2inquote : if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; charset <identifiersep> possible = false ; switch ( c ) <ect>
<comment> <LOG> break ; } int i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; break ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . substring ( 0 , i ) ) ; whitespace <identifiersep> before <identifiersep> property = buffer . substring ( 0 , i ) ; property <identifiersep> name = buffer . delete ( 0 , i ) . to <identifiersep> string ( ) . trim ( ) ; <LOG> buffer . set <identifiersep> length ( 0 ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; break ; case ' ; ' : if ( prevc == ' \\ \\ ' ) { <comment> <ect>
<comment> <LOG> break ; } i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; break ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . substring ( 0 , i ) + <string_literal> ) ; whitespace <identifiersep> after <identifiersep> colon = buffer . substring ( 0 , i ) ; property <identifiersep> value = buffer . delete ( 0 , i ) . to <identifiersep> string ( ) . trim ( ) ; <LOG> buffer . set <identifiersep> length ( 0 ) ; css <identifiersep> property <identifiersep> verifier obj = get <identifiersep> verifier ( property <identifiersep> name ) ; if ( obj != null ) { parsed <identifiersep> word [ ] words = split ( property <identifiersep> value , obj . allow <identifiersep> comma <identifiersep> delimiters ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( words ) ) ; if ( words != null && ! ignore <identifiersep> elements <identifiersep> s2 && ! ignore <identifiersep> elements <identifiersep> s3 && verify <identifiersep> token ( current <identifiersep> media , elements , obj , words ) ) <ect>
whitespace <identifiersep> before <identifiersep> property = <string_literal> ; filtered <identifiersep> tokens . append ( property <identifiersep> name ) ; filtered <identifiersep> tokens . append ( ' : ' ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> after <identifiersep> colon ) ; filtered <identifiersep> tokens . append ( property <identifiersep> value ) ; filtered <identifiersep> tokens . append ( ' ; ' ) ; <LOG> if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens . to <identifiersep> string ( ) + <string_literal> ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens . to <identifiersep> string ( ) + <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( words ) + <string_literal> + ignore <identifiersep> elements <identifiersep> s1 + <string_literal> + ignore <identifiersep> elements <identifiersep> s2 + <string_literal> + ignore <identifiersep> elements <identifiersep> s3 ) ; } } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> ) ; } ignore <identifiersep> elements <identifiersep> s3 = false ; <ect>
filtered <identifiersep> tokens . append ( whitespace <identifiersep> after <identifiersep> colon ) ; filtered <identifiersep> tokens . append ( property <identifiersep> value ) ; filtered <identifiersep> tokens . append ( ' ; ' ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> + property <identifiersep> value ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens . to <identifiersep> string ( ) + <string_literal> ) ; } else { <LOG> } } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> ) ; } ignore <identifiersep> elements <identifiersep> s3 = false ; property <identifiersep> name = <string_literal> ; property <identifiersep> value = <string_literal> ; break ; <ect>
buffer . append ( c ) ; break ; } open <identifiersep> braces -- ; if ( open <identifiersep> braces > open <identifiersep> braces <identifiersep> starting <identifiersep> s3 - 1 ) { <comment> <LOG> if ( open <identifiersep> braces < 0 ) open <identifiersep> braces = 0 ; break ; } if ( open <identifiersep> braces < 0 ) open <identifiersep> braces = 0 ; for ( i = buffer . length ( ) - 1 ; i >= 0 ; i -- ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) <ect>
continue ; break ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . substring ( 0 , i ) ) ; whitespace <identifiersep> after <identifiersep> colon = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; property <identifiersep> value = buffer . to <identifiersep> string ( ) . trim ( ) ; <LOG> buffer . set <identifiersep> length ( 0 ) ; obj = get <identifiersep> verifier ( property <identifiersep> name ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> + property <identifiersep> value ) ; if ( obj != null ) { parsed <identifiersep> word [ ] words = split ( property <identifiersep> value , obj . allow <identifiersep> comma <identifiersep> delimiters ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( words ) ) ; <ect>
break ; } break ; case state3inquote : charset <identifiersep> possible = false ; if ( stop <identifiersep> at <identifiersep> detected <identifiersep> charset ) return ; <LOG> switch ( c ) { case ' <string_literal> ' && prevc != ' \\ \\ ' ) current <identifiersep> state = state3 ; buffer . append ( c ) ; <ect>
{ current <identifiersep> state = state <identifiersep> before <identifiersep> comment ; c = 0 ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + current <identifiersep> state ) ; } break ; } break ; } } <LOG> w . write ( filtered <identifiersep> tokens . to <identifiersep> string ( ) ) ; for ( int i = 0 ; i < open <identifiersep> braces ; i ++ ) w . write ( ' } ' ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer + <string_literal> ) ; int i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { <ect>
if ( last <identifiersep> word != null && last <identifiersep> word . post <identifiersep> comma ) sb . append ( ' , ' ) ; last <identifiersep> word = word ; if ( ! first ) sb . append ( <string_literal> ) ; if ( ! word . changed ) { sb . append ( word . original ) ; <LOG> } else { sb . append ( word . encode ( false ) ) ; <comment> <ect>
sb . append ( word . original ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + word . original + <string_literal> ) ; } else { sb . append ( word . encode ( false ) ) ; <comment> <LOG> return sb . to <identifiersep> string ( ) ; } private boolean changed <identifiersep> anything ( parsed <identifiersep> word [ ] words ) { for ( parsed <identifiersep> word word : words ) { if ( word . changed ) return true ; } return false ; } private array <identifiersep> list < string > comma <identifiersep> list <identifiersep> from <identifiersep> identifiers ( parsed <identifiersep> word [ ] strparts , int offset ) { <ect>
<comment> <LOG> return null ; } else if ( last <identifiersep> word . post <identifiersep> comma ) { if ( log <identifiersep> debug ) logger . debug ( css <identifiersep> tokenizer <identifiersep> filter . class , <string_literal> + last <identifiersep> word + <string_literal> + input + <string_literal> + i ) ; <comment> <ect>
last <identifiersep> word . changed = true ; } else last <identifiersep> word . post <identifiersep> comma = true ; <comment> <LOG> return null ; } add <identifiersep> comma = true ; } } <comment> <ect>
orig <identifiersep> token . append ( escape ) ; decoded <identifiersep> token . append ( ( char ) integer . parse <identifiersep> int ( escape . to <identifiersep> string ( ) , <number_literal> ) ) ; } else if ( escaping ) { <comment> <LOG> parsed <identifiersep> word word = parse <identifiersep> token ( orig <identifiersep> token , decoded <identifiersep> token , dont <identifiersep> like <identifiersep> orig <identifiersep> token , could <identifiersep> be <identifiersep> identifier ) ; if ( word == null ) return null ; words . add ( word ) ; } return words . to <identifiersep> array ( new parsed <identifiersep> word [ words . size ( ) ] ) ; } private static parsed <identifiersep> word parse <identifiersep> token ( string <identifiersep> builder orig <identifiersep> token , string <identifiersep> builder decoded <identifiersep> token , boolean dont <identifiersep> like <identifiersep> orig <identifiersep> token , boolean could <identifiersep> be <identifiersep> identifier ) { if ( orig <identifiersep> token . length ( ) > <number_literal> ) { <ect>
for ( i = stripped <identifiersep> orig . length ( ) - 1 ; i >= 0 ; i -- ) { char c = stripped <identifiersep> orig . char <identifiersep> at ( i ) ; if ( ! ( c == \' \' || c == \' \\ t\' ) ) break ; if ( i > 0 && stripped <identifiersep> orig . char <identifiersep> at ( i - 1 ) == \' \\ \\ \' ) break ; } decoded <identifiersep> token . set <identifiersep> length ( decoded <identifiersep> token . length ( ) - ( stripped <identifiersep> orig . length ( ) - i - 1 ) ) ; stripped <identifiersep> orig = stripped <identifiersep> orig . substring ( 0 , i + 1 ) ; <LOG> if ( stripped <identifiersep> orig . length ( ) == 0 ) return null ; if ( stripped <identifiersep> orig . length ( ) > <number_literal> ) { char c = stripped <identifiersep> orig . char <identifiersep> at ( 0 ) ; if ( c == \' \\ \'\' || c == \' \\ " \' ) { char d = stripped <identifiersep> orig . char <identifiersep> at ( stripped <identifiersep> orig . length ( ) - 1 ) ; if ( c == d ) { <ect>
float . parse <identifiersep> float ( value ) ; <comment> <LOG> try { <comment> <ect>
try { <comment> <LOG> word . set <identifiersep> new <identifiersep> url ( s ) ; return true ; } catch ( comment <identifiersep> exception e ) { <comment> <ect>
public boolean check <identifiersep> validity ( parsed <identifiersep> word word , filter <identifiersep> callback cb ) { return this . check <identifiersep> validity ( null , null , new parsed <identifiersep> word [ ] { word } , cb ) ; } <comment> <LOG> if ( ! only <identifiersep> value <identifiersep> verifier ) { if ( allowed <identifiersep> media != null ) { boolean allowed = false ; for ( string m : media ) if ( allowed <identifiersep> media . contains ( m ) ) { <ect>
<comment> public boolean recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( string expression , parsed <identifiersep> word [ ] words , filter <identifiersep> callback cb ) { <LOG> if ( ( expression == null || ( <string_literal> . equals ( expression . trim ( ) ) ) ) ) { if ( words == null || words . length == 0 ) return true ; else return false ; <ect>
<comment> <LOG> if ( recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( first <identifiersep> part , part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db , cb ) ) <comment> <ect>
if ( recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( first <identifiersep> part , part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db , cb ) ) <comment> <LOG> } return false ; } else if ( expression . char <identifiersep> at ( i ) == 'b' ) { <comment> <ect>
string first <identifiersep> part = expression . substring ( 0 , i ) ; string second <identifiersep> part = expression . substring ( first <identifiersep> index , expression . length ( ) ) ; if ( second <identifiersep> part . length ( ) > 0 && second <identifiersep> part . char <identifiersep> at ( 0 ) == ' ' ) { second <identifiersep> part = second <identifiersep> part . substring ( 1 ) ; } else if ( second <identifiersep> part . length ( ) > 0 ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + second <identifiersep> part . char <identifiersep> at ( 0 ) ) ; } <LOG> int index = integer . parse <identifiersep> int ( first <identifiersep> part ) ; string [ ] str <identifiersep> limits = expression . substring ( i + 1 , tindex ) . split ( <string_literal> ) ; if ( str <identifiersep> limits . length == <number_literal> ) { int lower <identifiersep> limit = integer . parse <identifiersep> int ( str <identifiersep> limits [ 0 ] ) ; int upper <identifiersep> limit = integer . parse <identifiersep> int ( str <identifiersep> limits [ 1 ] ) ; <ect>
return new parsed <identifiersep> word [ 0 ] ; } <comment> public boolean recursive <identifiersep> variable <identifiersep> occurance <identifiersep> verifier ( int verifier <identifiersep> index , parsed <identifiersep> word [ ] value <identifiersep> parts , int lower <identifiersep> limit , int upper <identifiersep> limit , int tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> lower <identifiersep> limit , int tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> upper <identifiersep> limit , string second <identifiersep> part , filter <identifiersep> callback cb ) { <LOG> if ( ( value <identifiersep> parts == null || value <identifiersep> parts . length == 0 ) && lower <identifiersep> limit == 0 ) return true ; if ( lower <identifiersep> limit < = 0 ) { <comment> <ect>
if ( result ) { <comment> <LOG> return true ; } <comment> <ect>
string pattern = ignored <identifiersep> parts + ( ( ( <string_literal> . equals ( ignored <identifiersep> parts ) ) || ( <string_literal> . equals ( second <identifiersep> part ) ) ) ? <string_literal> : <string_literal> ) + second <identifiersep> part ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + to <identifiersep> string ( get <identifiersep> sub <identifiersep> array ( words , 0 , j + 1 ) ) + <string_literal> + index + <string_literal> + pattern + <string_literal> + to <identifiersep> string ( value <identifiersep> to <identifiersep> pass ) ) ; if ( pattern . equals ( <string_literal> ) ) return false ; result = recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( pattern , value <identifiersep> to <identifiersep> pass , cb ) ; if ( result ) { <LOG> return true ; } } } } } if ( last <identifiersep> a != - 1 ) return false ; <comment> <ect>
content <identifiersep> property <identifiersep> verifier ( collection < string > allowed <identifiersep> values ) { super ( allowed <identifiersep> values , null , null , null ) ; } @ override public boolean check <identifiersep> validity ( string [ ] media , string [ ] elements , parsed <identifiersep> word [ ] value , filter <identifiersep> callback cb ) { <LOG> if ( value . length != 1 ) return false ; if ( value [ 0 ] instanceof parsed <identifiersep> identifier && allowed <identifiersep> values != null && allowed <identifiersep> values . contains ( ( ( parsed <identifiersep> identifier ) value [ 0 ] ) . get <identifiersep> decoded ( ) ) ) return true ; <comment> <ect>
string orig = ( ( simple <identifiersep> parsed <identifiersep> word ) word ) . original ; if ( orig . index <identifiersep> of ( <string_literal> ) != - 1 ) { int slash <identifiersep> index = orig . index <identifiersep> of ( <string_literal> ) ; string first <identifiersep> part = orig . substring ( 0 , slash <identifiersep> index ) ; string second <identifiersep> part = orig . substring ( slash <identifiersep> index + 1 , orig . length ( ) ) ; <LOG> css <identifiersep> property <identifiersep> verifier line <identifiersep> height = new css <identifiersep> property <identifiersep> verifier ( arrays . as <identifiersep> list ( <string_literal> ) , arrays . as <identifiersep> list ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) , null , null , true ) ; parsed <identifiersep> word [ ] first = split ( first <identifiersep> part , false ) ; parsed <identifiersep> word [ ] second = split ( second <identifiersep> part , false ) ; if ( first . length == 1 && second . length == 1 && font <identifiersep> size . check <identifiersep> validity ( first , cb ) && line <identifiersep> height . check <identifiersep> validity ( second , cb ) ) continue ; <ect>
public boolean check <identifiersep> validity ( string [ ] media , string [ ] elements , parsed <identifiersep> word [ ] value , filter <identifiersep> callback cb ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + to <identifiersep> string ( value ) ) ; if ( value . length == 1 ) { if ( value [ 0 ] instanceof parsed <identifiersep> identifier && <string_literal> . equals <identifiersep> ignore <identifiersep> case ( ( ( parsed <identifiersep> identifier ) value [ 0 ] ) . original ) ) { <comment> <LOG> return true ; } } if ( allowed <identifiersep> media != null && ! only <identifiersep> value <identifiersep> verifier ) { boolean allowed = false ; for ( string m : media ) if ( allowed <identifiersep> media . contains ( m ) ) { allowed = true ; <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> if ( i == value . length - 1 ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + get <identifiersep> string <identifiersep> from <identifiersep> array ( font <identifiersep> words . to <identifiersep> array ( new string [ font <identifiersep> words . size ( ) ] ) ) + <string_literal> + valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ) ; return valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ; } if ( ! possibly <identifiersep> valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ) return false ; boolean last = false ; <ect>
parsed <identifiersep> word new <identifiersep> word = value [ j ] ; if ( j == value . length - 1 ) last = true ; string s1 ; if ( new <identifiersep> word instanceof parsed <identifiersep> identifier ) { s1 = ( ( parsed <identifiersep> identifier ) new <identifiersep> word ) . original ; font <identifiersep> words . add ( s1 ) ; <LOG> if ( last ) { if ( new <identifiersep> word . post <identifiersep> comma ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; } if ( valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ) { <comment> <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + s1 + <string_literal> ) ; if ( last ) { if ( new <identifiersep> word . post <identifiersep> comma ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; } if ( valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ) { <comment> <LOG> return true ; } } if ( new <identifiersep> word . post <identifiersep> comma ) { <comment> <ect>
i = j ; continue outer ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + fields . comma <identifiersep> list ( font <identifiersep> words . to <identifiersep> array ( new string [ font <identifiersep> words . size ( ) ] ) ) ) ; return false ; } } } else { <LOG> return false ; } } <comment> <ect>
w . write ( <string_literal> + top + <string_literal> ) ; if ( top . equals ( element ) ) return ; } } <comment> <LOG> if ( pc . kill <identifiersep> text ) { return ; } string <identifiersep> builder out = new string <identifiersep> builder ( s . length ( ) * <number_literal> ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . char <identifiersep> at ( i ) ; if ( c == ' < ' && ! ( pc . in <identifiersep> style || pc . in <identifiersep> script ) ) { <ect>
w . write ( sout ) ; } string process <identifiersep> tag ( list < string > split <identifiersep> tag , writer w , html <identifiersep> parse <identifiersep> context pc ) throws io <identifiersep> exception , data <identifiersep> filter <identifiersep> exception { <comment> <LOG> } parsed <identifiersep> tag t = new parsed <identifiersep> tag ( split <identifiersep> tag ) ; if ( ! pc . kill <identifiersep> tag ) { t = t . sanitize ( pc ) ; if ( t != null ) { <comment> <ect>
if ( len > 1 ) { unparsed <identifiersep> attrs = new string [ len - 1 ] ; for ( int x = 1 ; x < len ; x ++ ) unparsed <identifiersep> attrs [ x - 1 ] = v . get ( x ) ; } else unparsed <identifiersep> attrs = new string [ 0 ] ; <LOG> } public parsed <identifiersep> tag sanitize ( html <identifiersep> parse <identifiersep> context pc ) throws data <identifiersep> filter <identifiersep> exception { tag <identifiersep> verifier tv = allowed <identifiersep> tags <identifiersep> verifiers . get ( element . to <identifiersep> lower <identifiersep> case ( ) ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + tv + <string_literal> + element ) ; if ( tv == null ) { if ( delete <identifiersep> wierd <identifiersep> stuff ) { <ect>
return new parsed <identifiersep> tag ( t , out <identifiersep> attrs ) ; } map < string , object > sanitize <identifiersep> hash ( map < string , object > h , parsed <identifiersep> tag p , html <identifiersep> parse <identifiersep> context pc ) throws data <identifiersep> filter <identifiersep> exception { map < string , object > hn = new linked <identifiersep> hash <identifiersep> map < string , object > ( ) ; for ( map . entry < string , object > entry : h . entry <identifiersep> set ( ) ) { <LOG> string x = entry . get <identifiersep> key ( ) ; object o = entry . get <identifiersep> value ( ) ; boolean inline = inline <identifiersep> uri <identifiersep> attrs . contains ( x ) ; <comment> <ect>
hn . put ( x , o ) ; continue ; } <comment> <LOG> hn . put ( x , o ) ; } } return hn ; } <comment> protected boolean expunge <identifiersep> tag <identifiersep> if <identifiersep> no <identifiersep> attributes ( ) { return false ; <ect>
pc . current <identifiersep> style <identifiersep> script <identifiersep> chunk = <string_literal> ; } pc . expecting <identifiersep> bad <identifiersep> comment = false ; <comment> <LOG> pc . style <identifiersep> script <identifiersep> recurse <identifiersep> count ++ ; if ( pc . style <identifiersep> script <identifiersep> recurse <identifiersep> count > 1 ) { if ( delete <identifiersep> errors ) pc . write <identifiersep> after <identifiersep> tag . append ( <string_literal> + l10n ( <string_literal> ) + <string_literal> ) ; else throw <identifiersep> filter <identifiersep> exception ( l10n ( <string_literal> ) ) ; <ect>
try { ret = process <identifiersep> uri ( base <identifiersep> href , null , true , false ) ; } catch ( comment <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + base <identifiersep> href + <string_literal> + e1 . get <identifiersep> message ( ) ) ; ret = null ; } if ( ret == null ) { <LOG> return null ; } else { try { base <identifiersep> uri = new uri ( ret ) ; set <identifiersep> stripped <identifiersep> uri ( ret ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <ect>
return false ; } boolean is <identifiersep> valid = true ; for ( int i = 0 ; i < parts . length && is <identifiersep> valid ; i ++ ) { if ( ! is <identifiersep> number ( parts [ i ] . trim ( ) ) ) { is <identifiersep> valid = false ; } } if ( is <identifiersep> valid ) { <LOG> return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> percentage ( part . trim ( ) ) || is <identifiersep> length ( part . trim ( ) , false ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> percentage ( part . trim ( ) ) || is <identifiersep> length ( part . trim ( ) , false ) ) { <LOG> return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && ( is <identifiersep> percentage ( parts [ 0 ] . trim ( ) ) || is <identifiersep> length ( parts [ 0 ] . trim ( ) , false ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; <ect>
{ string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && ( is <identifiersep> percentage ( parts [ 0 ] . trim ( ) ) || is <identifiersep> length ( parts [ 0 ] . trim ( ) , false ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } else if ( parts . length == <number_literal> && ( is <identifiersep> percentage ( parts [ 0 ] . trim ( ) ) || is <identifiersep> length ( parts [ 0 ] . trim ( ) , false ) ) && ( is <identifiersep> percentage ( parts [ 1 ] . trim ( ) ) || is <identifiersep> length ( parts [ 1 ] . trim ( ) , false ) ) ) { <LOG> return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && is <identifiersep> number ( parts [ 0 ] . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; <ect>
{ string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && is <identifiersep> number ( parts [ 0 ] . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } else if ( parts . length == <number_literal> && is <identifiersep> number ( parts [ 0 ] . trim ( ) ) && is <identifiersep> number ( parts [ 1 ] . trim ( ) ) ) { <LOG> return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> number ( part . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> number ( part . trim ( ) ) ) { <LOG> return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> angle ( part . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> number ( part . trim ( ) ) || is <identifiersep> angle ( part . trim ( ) ) ) { <LOG> return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> number ( part . trim ( ) ) || is <identifiersep> angle ( part . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && ( is <identifiersep> number ( parts [ 0 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) ) { <LOG> return true ; } else if ( parts . length == <number_literal> && ( is <identifiersep> number ( parts [ 0 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) && ( is <identifiersep> number ( parts [ 1 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } return false ; } public static boolean is <identifiersep> frequency ( string value ) <ect>
super ( get <identifiersep> message ( m ) + <string_literal> + msg ) ; extra = msg ; mode = m ; error <identifiersep> codes = null ; this . uri = expected <identifiersep> uri ; if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + <string_literal> + msg , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode m , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( get <identifiersep> message ( m ) ) ; extra = null ; mode = m ; <ect>
extra = e . get <identifiersep> message ( ) ; this . mode = mode ; error <identifiersep> codes = null ; init <identifiersep> cause ( e ) ; this . uri = expected <identifiersep> uri ; if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + <string_literal> + e , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode mode , string message , throwable e , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( get <identifiersep> message ( mode ) + <string_literal> + message + <string_literal> + e . get <identifiersep> message ( ) ) ; extra = e . get <identifiersep> message ( ) ; this . mode = mode ; <ect>
super ( get <identifiersep> message ( mode ) ) ; extra = null ; this . mode = mode ; this . error <identifiersep> codes = error <identifiersep> codes ; this . uri = expected <identifiersep> uri ; if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode mode , string message , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( message == null ? get <identifiersep> message ( mode ) : ( get <identifiersep> message ( mode ) + <string_literal> + message ) ) ; extra = message ; this . mode = mode ; <ect>
super ( get <identifiersep> message ( mode ) ) ; extra = null ; this . mode = mode ; this . error <identifiersep> codes = null ; this . uri = null ; if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception e ) { super ( e . get <identifiersep> message ( ) ) ; extra = e . extra ; mode = e . mode ; <ect>
case rejected <identifiersep> overload : case too <identifiersep> many <identifiersep> retries <identifiersep> in <identifiersep> blocks : case route <identifiersep> not <identifiersep> found : case route <identifiersep> really <identifiersep> not <identifiersep> found : return false ; default : <LOG> return false ; } } <comment> public static insert <identifiersep> exception construct ( failure <identifiersep> code <identifiersep> tracker errors ) { if ( errors == null ) return null ; <ect>
methods . add ( m ) ; } } return methods ; } private void run <identifiersep> tests ( list < method > tests ) throws exception { for ( method m : tests ) { string test <identifiersep> name = string . value <identifiersep> of ( m . get <identifiersep> name ( ) . char <identifiersep> at ( <number_literal> ) ) . to <identifiersep> lower <identifiersep> case ( ) . concat ( m . get <identifiersep> name ( ) . substring ( <number_literal> ) ) ; int seconds <identifiersep> lasts = m . is <identifiersep> annotation <identifiersep> present ( seconds <identifiersep> long . class ) ? m . get <identifiersep> annotation ( seconds <identifiersep> long . class ) . value ( ) : - 1 ; <LOG> print <identifiersep> stream err = system . err ; print <identifiersep> stream out = system . out ; try { memory <identifiersep> output <identifiersep> stream mos = new memory <identifiersep> output <identifiersep> stream ( ) ; system . set <identifiersep> out ( new print <identifiersep> stream ( mos ) ) ; system . set <identifiersep> err ( new print <identifiersep> stream ( new output <identifiersep> stream ( ) { <ect>
system . out . println ( <string_literal> ) ; try { run <identifiersep> tests ( get <identifiersep> all <identifiersep> integration <identifiersep> tests ( ) ) ; } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; } <LOG> try { run <identifiersep> tests ( get <identifiersep> all <identifiersep> acceptance <identifiersep> tests ( ) ) ; } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; } } return true ; <ect>
web <identifiersep> client c2 = new web <identifiersep> client ( ) ; string request <identifiersep> id1 = ( ( html <identifiersep> page ) c1 . get <identifiersep> page ( test <identifiersep> url ) ) . get <identifiersep> element <identifiersep> by <identifiersep> id ( <string_literal> ) . get <identifiersep> attribute ( <string_literal> ) ; string request <identifiersep> id2 = ( ( html <identifiersep> page ) c2 . get <identifiersep> page ( test <identifiersep> url ) ) . get <identifiersep> element <identifiersep> by <identifiersep> id ( <string_literal> ) . get <identifiersep> attribute ( <string_literal> ) ; system . out . println ( <string_literal> ) ; c1 . close <identifiersep> all <identifiersep> windows ( ) ; c2 . close <identifiersep> all <identifiersep> windows ( ) ; <LOG> if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { throw new exception ( <string_literal> ) ; } system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { thread . sleep ( <number_literal> ) ; system . out . println ( <string_literal> + i ) ; <ect>
final double p = math . pow ( q , k ) ; final double actual = ( double ) f <identifiersep> pos / pass <identifiersep> false ; final double limit = p * 1 . <number_literal> + 1 . 0 / pass <identifiersep> false ; <comment> <LOG> system . out . println ( <string_literal> + limit ) ; system . out . println ( <string_literal> + actual ) ; system . out . println ( <string_literal> + actual / p ) ; <comment> assert <identifiersep> false ( <string_literal> + p + <string_literal> + actual , actual > limit ) ; } public void test <identifiersep> counting <identifiersep> filter <identifiersep> false <identifiersep> positive ( ) { <ect>
final double limit = p * 1 . <number_literal> + 1 . 0 / pass <identifiersep> false ; <comment> <LOG> system . out . println ( <string_literal> + actual / p ) ; <comment> assert <identifiersep> false ( <string_literal> + p + <string_literal> + actual , actual > limit ) ; } public void test <identifiersep> counting <identifiersep> filter <identifiersep> false <identifiersep> positive ( ) { int k = bloom <identifiersep> filter . optimial <identifiersep> k ( filter <identifiersep> size , pass ) ; bloom <identifiersep> filter filter = bloom <identifiersep> filter . create <identifiersep> filter ( filter <identifiersep> size , k , true ) ; <ect>
<comment> <LOG> fail ( ) ; } private string decode <identifiersep> block ( chk <identifiersep> block verify , client <identifiersep> chk key ) throws chk <identifiersep> verify <identifiersep> exception , chk <identifiersep> decode <identifiersep> exception , io <identifiersep> exception { client <identifiersep> chk <identifiersep> block cb = new client <identifiersep> chk <identifiersep> block ( verify , key ) ; bucket output = cb . decode ( new array <identifiersep> bucket <identifiersep> factory ( ) , <number_literal> , false ) ; byte [ ] buf = bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( output ) ; return new string ( buf , <string_literal> ) ; <ect>
{ byte [ ] b1 = new byte [ <number_literal> ] ; byte [ ] b2 = new byte [ <number_literal> ] ; r1 . next <identifiersep> bytes ( b1 ) ; r2 . next <identifiersep> bytes ( b2 ) ; if ( ! arrays . equals ( b1 , b2 ) ) { <LOG> return ; } } for ( int off = 0 ; off < <number_literal> ; off ++ ) { for ( int len = 0 ; len < <number_literal> ; len ++ ) { byte [ ] b1 = new byte [ len ] ; byte [ ] b2 = new byte [ len + off ] ; r1 . next <identifiersep> bytes ( b1 ) ; <ect>
security . add <identifiersep> provider ( new bouncy <identifiersep> castle <identifiersep> provider ( ) ) ; ecdh alice = new ecdh ( curves . p256 ) ; ecdh bob = new ecdh ( curves . p256 ) ; public <identifiersep> key bob <identifiersep> p = bob . get <identifiersep> public <identifiersep> key ( ) ; public <identifiersep> key alice <identifiersep> p = alice . get <identifiersep> public <identifiersep> key ( ) ; system . out . println ( <string_literal> + alice . curve ) ; <LOG> system . out . println ( <string_literal> + to <identifiersep> hex ( alice <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice . get <identifiersep> agreed <identifiersep> secret ( bob . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob . get <identifiersep> agreed <identifiersep> secret ( alice . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; } public static string to <identifiersep> hex ( byte [ ] arg ) { return string . format ( <string_literal> , new big <identifiersep> integer ( 1 , arg ) ) ; <ect>
ecdh bob = new ecdh ( curves . p256 ) ; public <identifiersep> key bob <identifiersep> p = bob . get <identifiersep> public <identifiersep> key ( ) ; public <identifiersep> key alice <identifiersep> p = alice . get <identifiersep> public <identifiersep> key ( ) ; system . out . println ( <string_literal> + alice . curve ) ; system . out . println ( <string_literal> + bob . curve ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; <LOG> system . out . println ( <string_literal> + to <identifiersep> hex ( alice . get <identifiersep> agreed <identifiersep> secret ( bob . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob . get <identifiersep> agreed <identifiersep> secret ( alice . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; } public static string to <identifiersep> hex ( byte [ ] arg ) { return string . format ( <string_literal> , new big <identifiersep> integer ( 1 , arg ) ) ; } public static string to <identifiersep> hex ( string arg ) throws unsupported <identifiersep> encoding <identifiersep> exception { return to <identifiersep> hex ( arg . get <identifiersep> bytes ( <string_literal> ) ) ; <ect>
public <identifiersep> key alice <identifiersep> p = alice . get <identifiersep> public <identifiersep> key ( ) ; system . out . println ( <string_literal> + alice . curve ) ; system . out . println ( <string_literal> + bob . curve ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice . get <identifiersep> agreed <identifiersep> secret ( bob . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; <LOG> } public static string to <identifiersep> hex ( byte [ ] arg ) { return string . format ( <string_literal> , new big <identifiersep> integer ( 1 , arg ) ) ; } public static string to <identifiersep> hex ( string arg ) throws unsupported <identifiersep> encoding <identifiersep> exception { return to <identifiersep> hex ( arg . get <identifiersep> bytes ( <string_literal> ) ) ; } } <ect>
int count = 0 ; system . out . println ( <string_literal> ) ; random r = new random ( 0x <identifiersep> bbbbbbbb ) ; for ( int len = <number_literal> ; len < = <number_literal> ; len *= <number_literal> ) { byte [ ] plaintext = new byte [ len ] ; r . next <identifiersep> bytes ( plaintext ) ; <LOG> int iterations = <number_literal> / len ; long t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; for ( int i = 0 ; i < iterations ; i ++ ) { byte [ ] r1 = hmac <identifiersep> legacy . mac <identifiersep> with <identifiersep> sha256 ( known <identifiersep> key , plaintext , <number_literal> ) ; for ( int j = 0 ; j < r1 . length ; j ++ ) { count += r1 [ j ] ; <ect>
hmac . update ( plaintext , 0 , plaintext . length ) ; hmac . do <identifiersep> final ( r1 , 0 ) ; for ( int j = 0 ; j < r1 . length ; j ++ ) { count += r1 [ j ] ; } } long bc <identifiersep> length = system . current <identifiersep> time <identifiersep> millis ( ) - t1 ; system . out . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( legacy <identifiersep> length , <number_literal> , true ) ) ; <LOG> system . out . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( bc <identifiersep> length , <number_literal> , true ) ) ; } } } <ect>
public void test <identifiersep> non <identifiersep> standard <identifiersep> test <identifiersep> vk ( ) throws unsupported <identifiersep> cipher <identifiersep> exception { rijndael aes128 = new rijndael ( <number_literal> , <number_literal> ) ; for ( int i = 0 ; i < test <identifiersep> vk256x256 . length ; i ++ ) { aes128 . initialize ( test <identifiersep> vk256x256 [ i ] [ 0 ] ) ; byte [ ] cipher = new byte [ <number_literal> / <number_literal> ] ; aes128 . encipher ( test <identifiersep> vk <identifiersep> p <identifiersep> tx256 , cipher ) ; <LOG> <comment> <ect>
for ( int i = 0 ; i < test <identifiersep> vk256x256 . length ; i ++ ) { aes128 . initialize ( test <identifiersep> vk256x256 [ i ] [ 0 ] ) ; byte [ ] cipher = new byte [ <number_literal> / <number_literal> ] ; aes128 . encipher ( test <identifiersep> vk <identifiersep> p <identifiersep> tx256 , cipher ) ; <comment> <LOG> assert <identifiersep> true ( <string_literal> + ( i + 1 ) , arrays . equals ( cipher , test <identifiersep> vk256x256 [ i ] [ 1 ] ) ) ; } } <comment> <ect>
string to <identifiersep> sign = <string_literal> ; byte [ ] signed <identifiersep> bytes = to <identifiersep> sign . get <identifiersep> bytes ( <string_literal> ) ; <comment> <LOG> system . out . println ( <string_literal> + to <identifiersep> hex ( sig ) ) ; system . out . println ( <string_literal> + ecdsa . verify ( sig , signed <identifiersep> bytes ) ) ; simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; system . out . println ( <string_literal> ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
<comment> <LOG> simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; system . out . println ( <string_literal> ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> ) ; ecdsa ecdsa2 = new ecdsa ( sfs . get <identifiersep> subset ( curve . name ( ) ) , curve ) ; system . out . println ( ecdsa2 . get <identifiersep> public <identifiersep> key ( ) ) ; <ect>
system . out . println ( <string_literal> + to <identifiersep> sign + <string_literal> + to <identifiersep> hex ( signed <identifiersep> bytes ) + <string_literal> ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( sig ) ) ; system . out . println ( <string_literal> + ecdsa . verify ( sig , signed <identifiersep> bytes ) ) ; simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; system . out . println ( <string_literal> ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; <LOG> ecdsa ecdsa2 = new ecdsa ( sfs . get <identifiersep> subset ( curve . name ( ) ) , curve ) ; system . out . println ( ecdsa2 . get <identifiersep> public <identifiersep> key ( ) ) ; system . out . println ( <string_literal> + ecdsa2 . verify ( sig , signed <identifiersep> bytes ) ) ; system . out . println ( <string_literal> + ecdsa . curve . max <identifiersep> sig <identifiersep> size + <string_literal> ) ; int max = 0 ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { <ect>
system . out . println ( <string_literal> ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> ) ; ecdsa ecdsa2 = new ecdsa ( sfs . get <identifiersep> subset ( curve . name ( ) ) , curve ) ; system . out . println ( ecdsa2 . get <identifiersep> public <identifiersep> key ( ) ) ; system . out . println ( <string_literal> + ecdsa2 . verify ( sig , signed <identifiersep> bytes ) ) ; <LOG> int max = 0 ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { max = math . max ( max , ecdsa . sign ( signed <identifiersep> bytes ) . length ) ; } system . out . println ( max ) ; } public static string to <identifiersep> hex ( byte [ ] arg ) { return string . format ( <string_literal> , new big <identifiersep> integer ( 1 , arg ) ) ; <ect>
hmac <identifiersep> legacy s = null ; try { s = new hmac <identifiersep> legacy ( message <identifiersep> digest . get <identifiersep> instance ( <string_literal> ) ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } byte [ ] key = new byte [ <number_literal> ] ; <LOG> byte [ ] text ; text = <string_literal> . get <identifiersep> bytes ( <string_literal> ) ; for ( int i = 0 ; i < key . length ; i ++ ) key [ i ] = ( byte ) 0x0b ; byte [ ] mv = s . mac ( key , text , <number_literal> ) ; system . out . println ( hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( mv , 0 , mv . length ) ) ; <ect>
t3 = system . current <identifiersep> time <identifiersep> millis ( ) ; float d <identifiersep> native <identifiersep> decode = t2 - t1 ; float d <identifiersep> pure <identifiersep> decode = t3 - t2 ; system . out . println ( maybe <identifiersep> native ) ; system . out . println ( pure <identifiersep> code ) ; system . out . println ( <string_literal> + d <identifiersep> native <identifiersep> encode + <string_literal> + d <identifiersep> pure <identifiersep> encode + <string_literal> ) ; <LOG> } public void test <identifiersep> simple <identifiersep> rev ( ) { int lim = fec <identifiersep> math . gf <identifiersep> size + 1 ; fec <identifiersep> code code = fec <identifiersep> code <identifiersep> factory . get <identifiersep> default ( ) . create <identifiersep> fec <identifiersep> code ( kk , lim ) ; fec <identifiersep> code code2 = new pure <identifiersep> code ( kk , lim ) ; int [ ] index = new int [ kk ] ; for ( int i = 0 ; i < kk ; i ++ ) <ect>
fos = new file <identifiersep> output <identifiersep> stream ( <string_literal> ) ; fos . write ( out . to <identifiersep> byte <identifiersep> array ( ) ) ; fos . close ( ) ; failed = true ; assert <identifiersep> false ( <string_literal> + fo . charset , true ) ; } catch ( data <identifiersep> filter <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; if ( e . get <identifiersep> cause ( ) != null ) { e . get <identifiersep> cause ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; } <comment> <ect>
string key = itr . next ( ) ; string value = css2 <identifiersep> selector . get ( key ) ; system . err . println ( <string_literal> + ( i ++ ) + <string_literal> + key + <string_literal> + value ) ; assert <identifiersep> true ( <string_literal> + key + <string_literal> + filter ( key ) + <string_literal> + value + <string_literal> , filter ( key ) . contains ( value ) ) ; } i = 0 ; for ( string key : css2 <identifiersep> bad <identifiersep> selector ) { <LOG> assert <identifiersep> true ( <string_literal> . equals ( filter ( key ) ) ) ; } } public void test <identifiersep> css3selector ( ) throws io <identifiersep> exception , uri <identifiersep> syntax <identifiersep> exception { collection < string > c = css3 <identifiersep> selector . key <identifiersep> set ( ) ; iterator < string > itr = c . iterator ( ) ; int i = 0 ; while ( itr . has <identifiersep> next ( ) ) <ect>
string key = itr . next ( ) ; string value = css3 <identifiersep> selector . get ( key ) ; system . err . println ( <string_literal> + ( i ++ ) + <string_literal> + key + <string_literal> + value ) ; assert <identifiersep> true ( <string_literal> + key + <string_literal> + filter ( key ) + <string_literal> + value + <string_literal> , filter ( key ) . contains ( value ) ) ; } i = 0 ; for ( string key : css3 <identifiersep> bad <identifiersep> selector ) { <LOG> assert <identifiersep> true ( <string_literal> . equals ( filter ( key ) ) ) ; } } public void test <identifiersep> newlines ( ) throws io <identifiersep> exception , uri <identifiersep> syntax <identifiersep> exception { assert <identifiersep> true ( <string_literal> + css <identifiersep> string <identifiersep> newlines + <string_literal> + filter ( css <identifiersep> string <identifiersep> newlines ) + <string_literal> + css <identifiersep> string <identifiersep> newlinesc + <string_literal> , css <identifiersep> string <identifiersep> newlinesc . equals ( filter ( css <identifiersep> string <identifiersep> newlines ) ) ) ; } public void test <identifiersep> background <identifiersep> url ( ) throws io <identifiersep> exception , uri <identifiersep> syntax <identifiersep> exception { assert <identifiersep> true ( <string_literal> + css <identifiersep> background <identifiersep> url + <string_literal> + filter ( css <identifiersep> background <identifiersep> url ) + <string_literal> + css <identifiersep> background <identifiersep> urlc + <string_literal> , css <identifiersep> background <identifiersep> urlc . equals ( filter ( css <identifiersep> background <identifiersep> url ) ) ) ; assert <identifiersep> true ( <string_literal> + css <identifiersep> lcase <identifiersep> background <identifiersep> url + <string_literal> + filter ( css <identifiersep> lcase <identifiersep> background <identifiersep> url ) + <string_literal> , css <identifiersep> lcase <identifiersep> background <identifiersep> urlc . equals ( filter ( css <identifiersep> lcase <identifiersep> background <identifiersep> url ) ) ) ; <ect>
int seed = 0 ; int n <identifiersep> probes = <number_literal> ; if ( args . length > 0 ) { <comment> <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; } } if ( args . length > 1 ) { <comment> <ect>
} catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; } } if ( args . length > 1 ) { <comment> <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; } } random rand = new mersenne <identifiersep> twister ( seed ) ; int sleep <identifiersep> interval = <number_literal> ; <comment> <ect>
int sleep <identifiersep> interval = <number_literal> ; <comment> <LOG> try { thread . sleep ( sleep <identifiersep> interval + rand . next <identifiersep> int ( sleep <identifiersep> interval / <number_literal> ) ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
{ int j ; mersenne <identifiersep> twister r ; <comment> <LOG> for ( j = 0 ; j < <number_literal> ; j ++ ) { <comment> <ect>
system . out . println ( <string_literal> ) ; r = new mersenne <identifiersep> twister ( seed ) ; ms = system . current <identifiersep> time <identifiersep> millis ( ) ; xx = 0 ; for ( j = 0 ; j < <number_literal> ; j ++ ) xx += r . next <identifiersep> int ( ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <comment> <ect>
ms = system . current <identifiersep> time <identifiersep> millis ( ) ; xx = 0 ; for ( j = 0 ; j < <number_literal> ; j ++ ) xx += r . next <identifiersep> int ( ) ; system . out . println ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - ms ) + <string_literal> + xx ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <comment> <ect>
for ( j = 0 ; j < <number_literal> ; j ++ ) xx += r . next <identifiersep> int ( ) ; system . out . println ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - ms ) + <string_literal> + xx ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> <comment> <ect>
r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> boolean ( ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%8 == <number_literal> ) ) system . out . println ( ) ; <LOG> r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> boolean ( ( double ) ( j / <number_literal> . 0 ) ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%8 == <number_literal> ) ) system . out . println ( ) ; <ect>
for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> boolean ( ( float ) ( j / <number_literal> . 0f ) ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%8 == <number_literal> ) ) system . out . println ( ) ; byte [ ] bytes = new byte [ <number_literal> ] ; <LOG> r = new mersenne <identifiersep> twister ( seed ) ; r . next <identifiersep> bytes ( bytes ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( bytes [ j ] + <string_literal> ) ; if ( j%16 == <number_literal> ) system . out . println ( ) ; <ect>
for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( ( b = r . next <identifiersep> byte ( ) ) + <string_literal> ) ; if ( b != bytes [ j ] ) system . out . print ( <string_literal> ) ; if ( j%16 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%16 == <number_literal> ) ) system . out . println ( ) ; <LOG> r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> short ( ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%8 == <number_literal> ) ) system . out . println ( ) ; <ect>
r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> int ( ) + <string_literal> ) ; if ( j%4 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%4 == <number_literal> ) ) system . out . println ( ) ; <LOG> r = new mersenne <identifiersep> twister ( seed ) ; int max = 1 ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> int ( max ) + <string_literal> ) ; max *= <number_literal> ; <ect>
r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> long ( ) + <string_literal> ) ; if ( j%3 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%3 == <number_literal> ) ) system . out . println ( ) ; <LOG> r = new mersenne <identifiersep> twister ( seed ) ; long max2 = 1 ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> long ( max2 ) + <string_literal> ) ; max2 *= <number_literal> ; <ect>
{ string skin <identifiersep> folder = get <identifiersep> skin <identifiersep> folder ( ) ; string resource <identifiersep> path = skin <identifiersep> folder + resource ; <comment> <LOG> return null ; } if ( test <identifiersep> exist ) { <comment> <ect>
for ( select <identifiersep> item select <identifiersep> item : plain <identifiersep> select . get <identifiersep> select <identifiersep> items ( ) ) { if ( ! is <identifiersep> select <identifiersep> item <identifiersep> allowed ( select <identifiersep> item , tables ) ) { return false ; } } return true ; } } } catch ( jsql <identifiersep> parser <identifiersep> exception e ) { <comment> <LOG> exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } return false ; } private static map < string , string > get <identifiersep> tables ( plain <identifiersep> select plain <identifiersep> select ) { map < string , string > tables = new hash <identifiersep> map < > ( ) ; <comment> <ect>
{ transaction transaction = get <identifiersep> current <identifiersep> transaction ( ) ; session session = get <identifiersep> current <identifiersep> session ( ) ; <comment> <LOG> <comment> <ect>
if ( ( ( session == null ) && ( transaction != null ) ) || ( ( transaction == null ) && ( session != null ) ) ) { this . logger . warn ( <string_literal> , session , transaction ) ; <comment> <LOG> return false ; } <comment> <ect>
<comment> <LOG> set <identifiersep> current <identifiersep> session ( session ) ; this . logger . debug ( <string_literal> ) ; transaction = session . begin <identifiersep> transaction ( ) ; this . logger . debug ( <string_literal> , transaction ) ; set <identifiersep> current <identifiersep> transaction ( transaction ) ; <comment> <ect>
} else { session = sfactory . open <identifiersep> session ( ) ; } this . logger . debug ( <string_literal> , session ) ; set <identifiersep> current <identifiersep> session ( session ) ; this . logger . debug ( <string_literal> ) ; transaction = session . begin <identifiersep> transaction ( ) ; <LOG> set <identifiersep> current <identifiersep> transaction ( transaction ) ; <comment> <ect>
base <identifiersep> property previous <identifiersep> property = previous <identifiersep> property <identifiersep> class . new <identifiersep> property ( ) ; <comment> <LOG> } } } } private void migrate ( property <identifiersep> class new <identifiersep> property <identifiersep> class ) throws query <identifiersep> exception { class <identifiersep> property <identifiersep> reference property <identifiersep> reference = new <identifiersep> property <identifiersep> class . get <identifiersep> reference ( ) ; entity <identifiersep> reference class <identifiersep> reference = property <identifiersep> reference . extract <identifiersep> reference ( entity <identifiersep> type . document ) ; entity <identifiersep> reference wiki <identifiersep> reference = property <identifiersep> reference . extract <identifiersep> reference ( entity <identifiersep> type . wiki ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
local <identifiersep> event . set <identifiersep> event ( ( event ) remote <identifiersep> event . get <identifiersep> event ( ) ) ; if ( remote <identifiersep> event . get <identifiersep> event ( ) instanceof document <identifiersep> deleted <identifiersep> event ) { local <identifiersep> event . set <identifiersep> source ( unserialize <identifiersep> deletd <identifiersep> document ( remote <identifiersep> event . get <identifiersep> source ( ) , xcontext ) ) ; } else { local <identifiersep> event . set <identifiersep> source ( unserialize <identifiersep> document ( remote <identifiersep> event . get <identifiersep> source ( ) ) ) ; } } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } return true ; } return false ; } private x <identifiersep> wiki <identifiersep> document unserialize <identifiersep> deletd <identifiersep> document ( serializable remote <identifiersep> data , x <identifiersep> wiki <identifiersep> context xcontext ) throws x <identifiersep> wiki <identifiersep> exception { map < string , serializable > remote <identifiersep> data <identifiersep> map = ( map < string , serializable > ) remote <identifiersep> data ; <ect>
<comment> <LOG> } } return document ; } @ override public string get <identifiersep> current <identifiersep> action ( ) { return this . xcontext <identifiersep> provider . get ( ) . get <identifiersep> action ( ) ; } @ override <ect>
base <identifiersep> object sheet <identifiersep> binding <identifiersep> object = ( ( x <identifiersep> wiki <identifiersep> document ) document ) . new <identifiersep> x <identifiersep> object ( sheet <identifiersep> binding <identifiersep> class <identifiersep> reference , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; sheet <identifiersep> binding <identifiersep> object . set <identifiersep> string <identifiersep> value ( sheet <identifiersep> property , sheet <identifiersep> reference <identifiersep> string ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { string doc <identifiersep> string <identifiersep> reference = this . default <identifiersep> entity <identifiersep> reference <identifiersep> serializer . serialize ( document . get <identifiersep> document <identifiersep> reference ( ) ) ; <LOG> return false ; } return true ; } @ override public boolean unbind ( document <identifiersep> model <identifiersep> bridge document , document <identifiersep> reference sheet <identifiersep> reference ) { document <identifiersep> reference sheet <identifiersep> binding <identifiersep> class <identifiersep> reference = <ect>
@ suppress <identifiersep> warnings ( <string_literal> ) list < page <identifiersep> sequence <identifiersep> results > page <identifiersep> sequences = fo <identifiersep> results . get <identifiersep> page <identifiersep> sequences ( ) ; for ( page <identifiersep> sequence <identifiersep> results page <identifiersep> sequence <identifiersep> results : page <identifiersep> sequences ) { this . logger . debug ( <string_literal> + string <identifiersep> utils . default <identifiersep> if <identifiersep> empty ( page <identifiersep> sequence <identifiersep> results . get <identifiersep> id ( ) , <string_literal> ) + <string_literal> + page <identifiersep> sequence <identifiersep> results . get <identifiersep> page <identifiersep> count ( ) + <string_literal> ) ; } <LOG> } } private configuration load <identifiersep> configuration ( ) { configuration configuration = null ; try ( input <identifiersep> stream fop <identifiersep> configuration <identifiersep> file = fopxslfo <identifiersep> renderer . class . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ) { if ( fop <identifiersep> configuration <identifiersep> file != null ) { configuration = new default <identifiersep> configuration <identifiersep> builder ( ) . build ( fop <identifiersep> configuration <identifiersep> file ) ; <ect>
<comment> <LOG> } } if ( writable <identifiersep> configuration instanceof default <identifiersep> configuration ) { extend <identifiersep> configuration ( ( default <identifiersep> configuration ) writable <identifiersep> configuration ) ; } } return writable <identifiersep> configuration ; } private void extend <identifiersep> configuration ( default <identifiersep> configuration writable <identifiersep> configuration ) { <comment> <ect>
velocity <identifiersep> context velocity <identifiersep> context = velocity <identifiersep> manager . get <identifiersep> velocity <identifiersep> context ( ) ; velocity <identifiersep> engine velocity <identifiersep> engine = velocity <identifiersep> manager . get <identifiersep> velocity <identifiersep> engine ( ) ; string <identifiersep> writer writer = new string <identifiersep> writer ( ) ; velocity <identifiersep> engine . evaluate ( velocity <identifiersep> context , writer , xcontext . get <identifiersep> doc ( ) . get <identifiersep> prefixed <identifiersep> full <identifiersep> name ( ) , content ) ; return writer . to <identifiersep> string ( ) ; } } catch ( x <identifiersep> wiki <identifiersep> velocity <identifiersep> exception e ) { <LOG> } return <string_literal> ; } @ override public set < x <identifiersep> wiki <identifiersep> link > extract <identifiersep> links ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { return doc . get <identifiersep> unique <identifiersep> wiki <identifiersep> linked <identifiersep> pages ( context ) ; } @ override <ect>
<comment> <LOG> } @ override public x <identifiersep> wiki <identifiersep> context create <identifiersep> stub <identifiersep> context ( ) { x <identifiersep> wiki <identifiersep> context stub <identifiersep> context ; if ( this . initial <identifiersep> context != null ) { stub <identifiersep> context = this . initial <identifiersep> context . clone ( ) ; <ect>
<comment> <LOG> return ; } } } catch ( component <identifiersep> lookup <identifiersep> exception e ) { throw new filter <identifiersep> exception ( string . format ( <string_literal> , type ) , e ) ; } this . current <identifiersep> class <identifiersep> property <identifiersep> meta = provider . get <identifiersep> definition ( ) ; if ( this . entity == null ) { <ect>
public xdom get <identifiersep> xdom <identifiersep> no <identifiersep> exception ( template template ) { xdom xdom ; try { xdom = get <identifiersep> xdom ( template ) ; } catch ( throwable e ) { <LOG> xdom = generate <identifiersep> error ( e ) ; } return xdom ; } public xdom get <identifiersep> xdom ( template template ) throws exception { xdom xdom ; if ( template != null ) { <ect>
<comment> public void render <identifiersep> no <identifiersep> exception ( template template , writer writer ) { try { render ( template , writer ) ; } catch ( exception e ) { <LOG> render <identifiersep> error ( e , writer ) ; } } public string render ( string template <identifiersep> name ) throws exception { return render <identifiersep> from <identifiersep> skin ( template <identifiersep> name , ( skin ) null ) ; } public string render <identifiersep> from <identifiersep> skin ( string template <identifiersep> name , string skin <identifiersep> id ) throws exception { <ect>
public xdom execute <identifiersep> no <identifiersep> exception ( template template ) { xdom xdom ; try { xdom = execute ( template ) ; } catch ( throwable e ) { <LOG> xdom = generate <identifiersep> error ( e ) ; } return xdom ; } private xdom execute ( template template , template <identifiersep> content content ) throws exception { xdom xdom = get <identifiersep> xdom ( template , content ) ; transform ( xdom ) ; <ect>
http <identifiersep> servlet <identifiersep> response response , x <identifiersep> wiki <identifiersep> context context ) throws exception { principal principal = authenticate ( username , password , context ) ; if ( principal != null ) { <comment> <LOG> } <comment> <ect>
<comment> protected principal authenticate <identifiersep> super <identifiersep> admin ( string password , x <identifiersep> wiki <identifiersep> context context ) { <LOG> } principal principal ; <comment> <ect>
if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + authservicepage + <string_literal> ) ; } return null ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { <LOG> } return null ; } } @ override public x <identifiersep> wiki <identifiersep> user check <identifiersep> auth ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { x <identifiersep> wiki <identifiersep> auth <identifiersep> service authservice = get <identifiersep> auth <identifiersep> service ( context ) ; if ( authservice == null ) { <ect>
<comment> private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( app <identifiersep> server <identifiersep> trusted <identifiersep> kerberos <identifiersep> auth <identifiersep> service <identifiersep> impl . class ) ; @ override public x <identifiersep> wiki <identifiersep> user check <identifiersep> auth ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { string user = context . get <identifiersep> request ( ) . get <identifiersep> remote <identifiersep> user ( ) ; <LOG> if ( string <identifiersep> utils . is <identifiersep> blank ( user ) ) { return super . check <identifiersep> auth ( context ) ; } else { user = this . extract <identifiersep> username <identifiersep> from <identifiersep> principal ( user ) ; user = create <identifiersep> user ( user , context ) ; user = xwiki <identifiersep> space + dot + user ; <ect>
string user = context . get <identifiersep> request ( ) . get <identifiersep> remote <identifiersep> user ( ) ; if ( ( user == null ) || user . equals ( <string_literal> ) ) { return super . check <identifiersep> auth ( context ) ; } else { logger . debug ( <string_literal> , user ) ; create <identifiersep> user ( user , context ) ; <LOG> user = <string_literal> + user ; } context . set <identifiersep> user ( user ) ; return new x <identifiersep> wiki <identifiersep> user ( user ) ; } <comment> <ect>
wrapped <identifiersep> request . set <identifiersep> user <identifiersep> principal ( null ) ; return null ; } final string user <identifiersep> name = get <identifiersep> context <identifiersep> user <identifiersep> name ( wrapped <identifiersep> request . get <identifiersep> user <identifiersep> principal ( ) , context ) ; if ( user <identifiersep> name != null ) { <LOG> } } if ( user <identifiersep> name == null ) { return null ; } return new x <identifiersep> wiki <identifiersep> user ( user <identifiersep> name ) ; } catch ( exception e ) { logger . error ( <string_literal> , e ) ; return null ; <ect>
return null ; } return new x <identifiersep> wiki <identifiersep> user ( user <identifiersep> name ) ; } catch ( exception e ) { logger . error ( <string_literal> , e ) ; return null ; } finally { <LOG> + <string_literal> ) ; } } <comment> <ect>
logger . info ( <string_literal> + principal . get <identifiersep> name ( ) + <string_literal> ) ; } } if ( principal == null ) { return null ; } return new x <identifiersep> wiki <identifiersep> user ( get <identifiersep> context <identifiersep> user <identifiersep> name ( principal , context ) ) ; } catch ( exception e ) { <LOG> return null ; } } private string get <identifiersep> context <identifiersep> user <identifiersep> name ( principal principal , x <identifiersep> wiki <identifiersep> context context ) { string context <identifiersep> user <identifiersep> name ; if ( principal != null ) { <comment> <ect>
<comment> <LOG> return null ; } } protected string find <identifiersep> user ( string username , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { string user ; <comment> <ect>
final string stored = user <identifiersep> object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; result = new password <identifiersep> class ( ) . get <identifiersep> equivalent <identifiersep> password ( stored , password ) . equals ( stored ) ; } if ( result ) { logger . debug ( <string_literal> + username + <string_literal> ) ; } else { <LOG> } logger . debug ( ( system . current <identifiersep> time <identifiersep> millis ( ) - time ) + <string_literal> ) ; } return result ; } catch ( throwable e ) { logger . error ( <string_literal> , e ) ; return false ; } } protected string get <identifiersep> param ( string name , x <identifiersep> wiki <identifiersep> context context ) <ect>
logger . debug ( <string_literal> + username + <string_literal> ) ; } else { logger . debug ( <string_literal> + username + <string_literal> ) ; } logger . debug ( ( system . current <identifiersep> time <identifiersep> millis ( ) - time ) + <string_literal> ) ; } return result ; } catch ( throwable e ) { <LOG> return false ; } } protected string get <identifiersep> param ( string name , x <identifiersep> wiki <identifiersep> context context ) { string param = <string_literal> ; try { param = context . get <identifiersep> wiki ( ) . get <identifiersep> x <identifiersep> wiki <identifiersep> preference ( name , context ) ; <ect>
if ( createuser != null ) { string wikiname = context . get <identifiersep> wiki ( ) . clear <identifiersep> name ( user , true , true , context ) ; x <identifiersep> wiki <identifiersep> document userdoc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( new document <identifiersep> reference ( context . get <identifiersep> wiki <identifiersep> id ( ) , <string_literal> , wikiname ) , context ) ; if ( userdoc . is <identifiersep> new ( ) ) { <LOG> } if ( <string_literal> . equals ( createuser ) ) { logger . debug ( <string_literal> + user ) ; } context . get <identifiersep> wiki ( ) . create <identifiersep> empty <identifiersep> user ( wikiname , <string_literal> , context ) ; } } else { <ect>
if ( <string_literal> . equals ( createuser ) ) { logger . debug ( <string_literal> + user ) ; } context . get <identifiersep> wiki ( ) . create <identifiersep> empty <identifiersep> user ( wikiname , <string_literal> , context ) ; } } else { <LOG> } } return wikiname ; } return user ; } <comment> <ect>
string levels = bobj . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; boolean allowdeny = ( bobj . get <identifiersep> int <identifiersep> value ( <string_literal> ) == 1 ) ; if ( allowdeny == allow ) { logger . debug ( <string_literal> , access <identifiersep> level , levels ) ; string [ ] levelsarray = string <identifiersep> utils . split ( levels , <string_literal> ) ; if ( array <identifiersep> utils . contains ( levelsarray , access <identifiersep> level ) ) { <LOG> found = true ; logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , users ) ; string [ ] userarray = groups <identifiersep> class . get <identifiersep> list <identifiersep> from <identifiersep> string ( users ) . to <identifiersep> array ( new string [ 0 ] ) ; for ( int ii = 0 ; ii < userarray . length ; ii ++ ) { string value = userarray [ ii ] ; if ( value . index <identifiersep> of ( <string_literal> ) == - 1 ) { <ect>
string <identifiersep> utils . join ( userarray , <string_literal> ) ) ; } <comment> <LOG> return true ; } <comment> <ect>
<comment> <LOG> return true ; } logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , users ) ; } } else { logger . debug ( <string_literal> , i ) ; } } } logger . debug ( <string_literal> ) ; <comment> <ect>
return true ; } } if ( ( context . get <identifiersep> wiki <identifiersep> id ( ) != null ) && ( array <identifiersep> utils . contains ( userarray , user <identifiersep> or <identifiersep> group <identifiersep> name ) ) ) { logger . debug ( <string_literal> , users , user <identifiersep> or <identifiersep> group <identifiersep> name ) ; return true ; } logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , users ) ; } } else { <LOG> } } } logger . debug ( <string_literal> ) ; <comment> <ect>
add <identifiersep> member <identifiersep> groups ( doc . get <identifiersep> wiki <identifiersep> name ( ) , prefixed <identifiersep> full <identifiersep> name , user <identifiersep> or <identifiersep> group <identifiersep> document <identifiersep> reference , grouplist , context ) ; <comment> <LOG> } for ( string group : grouplist ) { try { <comment> <ect>
collection < document <identifiersep> reference > group <identifiersep> references = group <identifiersep> service . get <identifiersep> all <identifiersep> groups <identifiersep> references <identifiersep> for <identifiersep> member ( user <identifiersep> or <identifiersep> group <identifiersep> document <identifiersep> reference , 0 , 0 , context ) ; tmp <identifiersep> group <identifiersep> list = new array <identifiersep> list < string > ( group <identifiersep> references . size ( ) ) ; for ( document <identifiersep> reference group <identifiersep> reference : group <identifiersep> references ) { tmp <identifiersep> group <identifiersep> list . add ( this . entity <identifiersep> reference <identifiersep> serializer . serialize ( group <identifiersep> reference ) ) ; } } catch ( exception e ) { <LOG> tmp <identifiersep> group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } finally { context . set <identifiersep> wiki <identifiersep> id ( current <identifiersep> wiki ) ; } grouplistcache . put ( key , tmp <identifiersep> group <identifiersep> list ) ; } grouplist . add <identifiersep> all ( tmp <identifiersep> group <identifiersep> list ) ; } public boolean has <identifiersep> access <identifiersep> level ( string access <identifiersep> level , string user <identifiersep> or <identifiersep> group <identifiersep> name , string entity <identifiersep> reference , boolean user , <ect>
<comment> <LOG> return false ; } } @ override public boolean has <identifiersep> admin <identifiersep> rights ( x <identifiersep> wiki <identifiersep> context context ) { boolean has <identifiersep> admin = has <identifiersep> wiki <identifiersep> admin <identifiersep> rights ( context ) ; if ( ! has <identifiersep> admin ) { <ect>
@ override public boolean has <identifiersep> wiki <identifiersep> admin <identifiersep> rights ( x <identifiersep> wiki <identifiersep> context context ) { try { return has <identifiersep> access <identifiersep> level ( <string_literal> , context . get <identifiersep> user ( ) , <string_literal> , context ) ; } catch ( exception e ) { <LOG> return false ; } } } <ect>
string protected <identifiersep> password = password ; if ( this . protection . equals ( protection <identifiersep> all ) || this . protection . equals ( protection <identifiersep> encryption ) ) { protected <identifiersep> username = encrypt <identifiersep> text ( protected <identifiersep> username ) ; protected <identifiersep> password = encrypt <identifiersep> text ( protected <identifiersep> password ) ; if ( protected <identifiersep> username == null || protected <identifiersep> password == null ) { logger . error ( <string_literal> ) ; <LOG> logger . error ( <string_literal> ) ; return ; } } <comment> <ect>
if ( validation <identifiersep> hash != null ) { <comment> <LOG> logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; } } } return ; } <comment> <ect>
cookie validation <identifiersep> cookie = new cookie ( get <identifiersep> cookie <identifiersep> prefix ( ) + cookie <identifiersep> validation , validation <identifiersep> hash ) ; setup <identifiersep> cookie ( validation <identifiersep> cookie , session <identifiersep> cookie , secure <identifiersep> cookie , cookie <identifiersep> domain , response ) ; } else { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; <LOG> logger . error ( <string_literal> ) ; } } } return ; } <comment> <ect>
private void set <identifiersep> max <identifiersep> age ( cookie cookie ) { try { cookie . set <identifiersep> max <identifiersep> age ( math . round ( <number_literal> * <number_literal> * <number_literal> * float . parse <identifiersep> float ( this . cookie <identifiersep> life ) ) ) ; } catch ( exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { <LOG> } } } <comment> <ect>
string servername = conform <identifiersep> cookie <identifiersep> domain ( request . get <identifiersep> server <identifiersep> name ( ) ) ; for ( string domain : this . cookie <identifiersep> domains ) { if ( servername . ends <identifiersep> with ( domain ) ) { cookie <identifiersep> domain = domain ; break ; } } } <LOG> } return cookie <identifiersep> domain ; } <comment> <ect>
<comment> private string get <identifiersep> validation <identifiersep> hash ( string username , string password , string client <identifiersep> ip ) { if ( this . validation <identifiersep> key == null ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> ) ; <LOG> } return null ; } message <identifiersep> digest md5 = null ; string <identifiersep> buffer sb <identifiersep> value <identifiersep> before <identifiersep> md5 = new string <identifiersep> buffer ( ) ; try { md5 = message <identifiersep> digest . get <identifiersep> instance ( <string_literal> ) ; sb <identifiersep> value <identifiersep> before <identifiersep> md5 . append ( username ) ; <ect>
<comment> <LOG> logger . error ( <string_literal> ) ; } } catch ( exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + clear <identifiersep> text , e ) ; } } return null ; } <comment> <ect>
return encrypted <identifiersep> encoded <identifiersep> text . replace <identifiersep> all ( <string_literal> , <string_literal> ) ; } if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; } } catch ( exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { <LOG> } } return null ; } <comment> <ect>
return new byte [ 0 ] ; } } public input <identifiersep> stream get <identifiersep> content <identifiersep> input <identifiersep> stream ( ) { try { return this . attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> return null ; } } public string get <identifiersep> content <identifiersep> as <identifiersep> string ( ) throws x <identifiersep> wiki <identifiersep> exception { <comment> <ect>
attachments = collections . empty <identifiersep> list ( ) ; } list < deleted <identifiersep> attachment > result = new array <identifiersep> list < deleted <identifiersep> attachment > ( attachments . size ( ) ) ; for ( com . xpn . xwiki . doc . deleted <identifiersep> attachment attachment : attachments ) { result . add ( new deleted <identifiersep> attachment ( attachment , this . context ) ) ; } return result ; } catch ( exception ex ) { <LOG> } return collections . empty <identifiersep> list ( ) ; } <comment> <ect>
try { if ( reference != null && get <identifiersep> authorization <identifiersep> manager ( ) . has <identifiersep> access ( right . view , reference ) ) { x <identifiersep> wiki <identifiersep> document document <identifiersep> revision = get <identifiersep> document <identifiersep> revision <identifiersep> provider ( ) . get <identifiersep> revision ( reference , revision ) ; if ( document <identifiersep> revision != null ) { return new document ( document <identifiersep> revision , this . context ) ; } } } catch ( exception e ) { <LOG> } return null ; } <comment> <ect>
register <identifiersep> right = this . xwiki . get <identifiersep> right <identifiersep> service ( ) . has <identifiersep> access <identifiersep> level ( <string_literal> , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) . get <identifiersep> user ( ) , <string_literal> , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; } if ( register <identifiersep> right ) { return this . xwiki . create <identifiersep> user ( with <identifiersep> validation , user <identifiersep> rights , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; } return - 1 ; } catch ( exception e ) { <LOG> return - <number_literal> ; } } <comment> <ect>
{ if ( ! has <identifiersep> programming <identifiersep> rights ( ) ) { return <string_literal> ; } try { return this . xwiki . get <identifiersep> url <identifiersep> content ( surl , this . context ) ; } catch ( exception e ) { <LOG> return <string_literal> ; } } <comment> <ect>
try { x <identifiersep> wiki <identifiersep> attachment attachment = this . deleted <identifiersep> attachment . restore <identifiersep> attachment ( ) ; if ( attachment != null ) { document doc = this . context . get <identifiersep> wiki ( ) . get <identifiersep> document ( get <identifiersep> doc <identifiersep> name ( ) , this . context ) . new <identifiersep> document ( this . context ) ; return new attachment ( doc , attachment , this . context ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { <LOG> } return null ; } <comment> <ect>
public void delete ( ) throws x <identifiersep> wiki <identifiersep> exception { if ( this . can <identifiersep> delete ( ) ) { try { this . context . get <identifiersep> wiki ( ) . get <identifiersep> attachment <identifiersep> recycle <identifiersep> bin <identifiersep> store ( ) . delete <identifiersep> from <identifiersep> recycle <identifiersep> bin ( get <identifiersep> id ( ) , this . context , true ) ; } catch ( exception ex ) { <LOG> } } else { java . lang . object [ ] args = { this . get <identifiersep> filename ( ) , this . get <identifiersep> doc <identifiersep> name ( ) } ; throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> access , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> access <identifiersep> denied , <string_literal> , null , args ) ; } } } <ect>
<comment> <LOG> return false ; } } else { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> access , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> access <identifiersep> denied , <string_literal> , null ) ; } } } <ect>
obj . set <identifiersep> guid ( null ) ; } save <identifiersep> x <identifiersep> wiki <identifiersep> collection ( obj , context , false ) ; } } } } if ( context . get <identifiersep> wiki ( ) . has <identifiersep> backlinks ( context ) ) { try { save <identifiersep> links ( doc , context , true ) ; } catch ( exception e ) { <LOG> e ) ; } } <comment> <ect>
base <identifiersep> string <identifiersep> property string <identifiersep> property = ( base <identifiersep> string <identifiersep> property ) property ; if ( string <identifiersep> property . get <identifiersep> value ( ) == null ) { string <identifiersep> property . set <identifiersep> value ( <string_literal> ) ; } } ( ( base <identifiersep> property ) property ) . set <identifiersep> value <identifiersep> dirty ( false ) ; } catch ( object <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> } <comment> <ect>
iterator it = mapping . get <identifiersep> property <identifiersep> iterator ( ) ; while ( it . has <identifiersep> next ( ) ) { property hibprop = ( property ) it . next ( ) ; string propname = hibprop . get <identifiersep> name ( ) ; property <identifiersep> class propclass = ( property <identifiersep> class ) bclass . get <identifiersep> field ( propname ) ; if ( propclass == null ) { <LOG> return false ; } boolean result = is <identifiersep> valid <identifiersep> column <identifiersep> type ( hibprop . get <identifiersep> value ( ) . get <identifiersep> type ( ) . get <identifiersep> name ( ) , propclass . get <identifiersep> class <identifiersep> name ( ) ) ; if ( result == false ) { this . logger . warn ( <string_literal> , propname ) ; return false ; } } return true ; <ect>
b <identifiersep> transaction = begin <identifiersep> transaction ( context ) ; } session session = get <identifiersep> session ( context ) ; <comment> <LOG> attachment . get <identifiersep> doc ( ) . get <identifiersep> document <identifiersep> reference ( ) ) ; } attachment <identifiersep> versioning <identifiersep> store store = resolve <identifiersep> attachment <identifiersep> versioning <identifiersep> store ( attachment , context ) ; store . delete <identifiersep> archive ( attachment , context , false ) ; try { session . delete ( attachment ) ; } catch ( exception e ) { <ect>
private attachment <identifiersep> versioning <identifiersep> store get <identifiersep> attachment <identifiersep> versioning <identifiersep> store ( string store <identifiersep> type ) { if ( store <identifiersep> type != null && ! store <identifiersep> type . equals ( hint ) ) { try { return this . component <identifiersep> manager . get <identifiersep> instance ( attachment <identifiersep> versioning <identifiersep> store . class , store <identifiersep> type ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } return null ; } } <ect>
{ try { return session . create <identifiersep> criteria ( x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> info . class ) . add ( restrictions . eq ( <string_literal> , long . value <identifiersep> of ( id ) ) ) . add ( restrictions . is <identifiersep> not <identifiersep> null ( <string_literal> ) ) . list ( ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { <comment> <LOG> return collections . empty <identifiersep> list ( ) ; } } } ) ; } @ override public x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> content load <identifiersep> rcs <identifiersep> node <identifiersep> content ( final x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> id id , boolean b <identifiersep> transaction , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <ect>
dbcp <identifiersep> properties . put ( <string_literal> , value ) ; break ; default : dbcp <identifiersep> properties . put ( property , value ) ; } } } <comment> <LOG> string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; dbcp <identifiersep> properties . list ( new print <identifiersep> writer ( sw , true ) ) ; logger . debug ( sw . to <identifiersep> string ( ) ) ; } <comment> <ect>
conn . close ( ) ; } finally { log <identifiersep> statistics ( ) ; } } @ override public void close ( ) throws hibernate <identifiersep> exception { <LOG> log <identifiersep> statistics ( ) ; try { if ( this . ds != null ) { this . ds . close ( ) ; this . ds = null ; } else { <ect>
<comment> private void log <identifiersep> progress ( string message , object . . . params ) { if ( params . length > 0 ) { this . logger . info ( <string_literal> , get <identifiersep> name ( ) , string . format ( message , params ) ) ; } else { <LOG> } } <comment> <ect>
x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> store <identifiersep> migration , get <identifiersep> name ( ) + <string_literal> , e ) ; } int timer = 0 ; this . logger . debug ( <string_literal> , times [ timer ++ ] / <number_literal> ) ; for ( string [ ] table : table <identifiersep> to <identifiersep> process ) { <LOG> } } } else { final list < string [ ] > docs <identifiersep> coll = new array <identifiersep> list < string [ ] > ( ) ; for ( class < ? > doc <identifiersep> class : doc <identifiersep> classes ) { docs <identifiersep> coll . add <identifiersep> all ( get <identifiersep> collection <identifiersep> properties ( get <identifiersep> class <identifiersep> mapping ( doc <identifiersep> class . get <identifiersep> name ( ) ) ) ) ; } for ( class < ? > doc <identifiersep> class : doclink <identifiersep> classes ) { docs <identifiersep> coll . add <identifiersep> all ( get <identifiersep> collection <identifiersep> properties ( get <identifiersep> class <identifiersep> mapping ( doc <identifiersep> class . get <identifiersep> name ( ) ) ) ) ; <ect>
} ) ; int timer = 0 ; for ( string [ ] coll : docs <identifiersep> coll ) { this . logger . debug ( <string_literal> , coll [ 0 ] , times [ timer ++ ] / <number_literal> ) ; } for ( class < ? > doclink <identifiersep> class : doclink <identifiersep> classes ) { <LOG> times [ timer ++ ] / <number_literal> ) ; } this . logger . debug ( <string_literal> , x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> info . class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; this . logger . debug ( <string_literal> , x <identifiersep> wiki <identifiersep> document . class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; } } log <identifiersep> progress ( <string_literal> ) ; <ect>
this . logger . debug ( <string_literal> , coll [ 0 ] , times [ timer ++ ] / <number_literal> ) ; } for ( class < ? > doclink <identifiersep> class : doclink <identifiersep> classes ) { this . logger . debug ( <string_literal> , doclink <identifiersep> class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; } this . logger . debug ( <string_literal> , x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> info . class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; <LOG> times [ timer ++ ] / <number_literal> ) ; } } log <identifiersep> progress ( <string_literal> ) ; } else { log <identifiersep> progress ( <string_literal> ) ; } <comment> <ect>
x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> store <identifiersep> migration , get <identifiersep> name ( ) + <string_literal> , e ) ; } int timer = 0 ; this . logger . debug ( <string_literal> , times [ timer ++ ] / <number_literal> ) ; for ( string [ ] table : table <identifiersep> to <identifiersep> process ) { <LOG> } } } else { <comment> <ect>
for ( string custom <identifiersep> mapped <identifiersep> class : custom <identifiersep> class <identifiersep> to <identifiersep> process ) { this . logger . debug ( <string_literal> , custom <identifiersep> mapped <identifiersep> class , times [ timer ++ ] / <number_literal> ) ; } for ( string property <identifiersep> class : class <identifiersep> to <identifiersep> process ) { this . logger . debug ( <string_literal> , property <identifiersep> class , times [ timer ++ ] / <number_literal> ) ; } <LOG> times [ timer ++ ] / <number_literal> ) ; } } log <identifiersep> progress ( <string_literal> ) ; } else { log <identifiersep> progress ( <string_literal> ) ; } <comment> <ect>
+ <string_literal> ) . set <identifiersep> string ( <string_literal> , table <identifiersep> name ) . unique <identifiersep> result ( ) ; } } ) ; } catch ( exception e ) { <comment> <LOG> } } sb . append ( <string_literal> ) . append ( table <identifiersep> name ) ; if ( pk <identifiersep> name != null ) { sb . append ( <string_literal> ) . append ( pk <identifiersep> name ) ; } sb . append ( <string_literal> ) ; } <comment> <ect>
string liquibase <identifiersep> change <identifiersep> logs = get <identifiersep> liquibase <identifiersep> change <identifiersep> logs ( migrations , pre <identifiersep> hibernate ) ; if ( liquibase <identifiersep> change <identifiersep> logs == null || liquibase <identifiersep> change <identifiersep> logs . length ( ) == 0 ) { return ; } final string database = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) . get <identifiersep> wiki <identifiersep> id ( ) ; if ( pre <identifiersep> hibernate ) { <LOG> } else { this . logger . info ( <string_literal> , database ) ; } } final string <identifiersep> builder change <identifiersep> logs = new string <identifiersep> builder ( <number_literal> ) ; change <identifiersep> logs . append ( get <identifiersep> liquibase <identifiersep> change <identifiersep> log <identifiersep> header ( ) ) ; change <identifiersep> logs . append ( liquibase <identifiersep> change <identifiersep> logs ) ; change <identifiersep> logs . append ( get <identifiersep> liquibase <identifiersep> change <identifiersep> log <identifiersep> footer ( ) ) ; <ect>
for ( int i = 0 ; i < this . sql <identifiersep> list . size ( ) ; i ++ ) { out . println ( <string_literal> + this . sql <identifiersep> list . get ( i ) ) ; } out . flush ( ) ; } public void log <identifiersep> sql <identifiersep> list ( ) { <LOG> for ( int i = 0 ; i < this . sql <identifiersep> list . size ( ) ; i ++ ) { logger . debug ( <string_literal> + this . sql <identifiersep> list . get ( i ) ) ; } } } } <ect>
<comment> <LOG> } } } ; <comment> private session <identifiersep> factory session <identifiersep> factory ; @ override <ect>
return get <identifiersep> key ( doc ) ; } @ override public x <identifiersep> wiki <identifiersep> document load <identifiersep> x <identifiersep> wiki <identifiersep> doc ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <comment> <LOG> x <identifiersep> wiki <identifiersep> document cachedoc ; try { cachedoc = get <identifiersep> cache ( ) . get ( key ) ; } catch ( exception e ) { logger . error ( <string_literal> , e ) ; cachedoc = null ; <ect>
cachedoc = get <identifiersep> cache ( ) . get ( key ) ; } catch ( exception e ) { logger . error ( <string_literal> , e ) ; cachedoc = null ; } if ( cachedoc != null ) { cachedoc . set <identifiersep> from <identifiersep> cache ( true ) ; <LOG> } else { boolean result = get <identifiersep> page <identifiersep> exist <identifiersep> cache ( ) . get ( key ) ; if ( result == boolean . false ) { logger . debug ( <string_literal> , key ) ; cachedoc = doc ; cachedoc . set <identifiersep> new ( true ) ; <ect>
cachedoc = doc ; cachedoc . set <identifiersep> new ( true ) ; <comment> <LOG> cachedoc = this . store . load <identifiersep> x <identifiersep> wiki <identifiersep> doc ( doc , context ) ; logger . debug ( <string_literal> , key ) ; if ( cachedoc . is <identifiersep> new ( ) ) { get <identifiersep> page <identifiersep> exist <identifiersep> cache ( ) . set ( key , boolean . false ) ; } else { get <identifiersep> cache ( ) . set ( key , cachedoc ) ; <ect>
if ( cachedoc . is <identifiersep> new ( ) ) { get <identifiersep> page <identifiersep> exist <identifiersep> cache ( ) . set ( key , boolean . false ) ; } else { get <identifiersep> cache ( ) . set ( key , cachedoc ) ; <comment> <LOG> } cachedoc . set <identifiersep> store ( this . store ) ; } logger . debug ( <string_literal> , key ) ; return cachedoc ; } @ override public void delete <identifiersep> x <identifiersep> wiki <identifiersep> doc ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <ect>
<comment> @ deprecated public x <identifiersep> wiki <identifiersep> hibernate <identifiersep> base <identifiersep> store ( x <identifiersep> wiki xwiki , x <identifiersep> wiki <identifiersep> context context ) { string path = xwiki . param ( <string_literal> , <string_literal> ) ; <LOG> set <identifiersep> path ( path ) ; } <comment> <ect>
x <identifiersep> wiki <identifiersep> context context = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( inputxcontext ) ; <comment> <LOG> try { string [ ] sql = get <identifiersep> schema <identifiersep> update <identifiersep> script ( this . store . get <identifiersep> configuration ( ) , context ) ; update <identifiersep> schema ( sql , context ) ; } finally { logger . info ( <string_literal> , context . get <identifiersep> wiki <identifiersep> id ( ) ) ; } } <comment> <ect>
{ document <identifiersep> result dom <identifiersep> result = new document <identifiersep> result ( ) ; try { utils . get <identifiersep> component ( x <identifiersep> wiki <identifiersep> document <identifiersep> filter <identifiersep> utils . class ) . export <identifiersep> entity ( this , new default <identifiersep> result <identifiersep> output <identifiersep> target ( dom <identifiersep> result ) ) ; } catch ( exception e ) { <LOG> return null ; } return dom <identifiersep> result . get <identifiersep> document ( ) . get <identifiersep> root <identifiersep> element ( ) ; } <comment> <ect>
parameters . put ( <string_literal> , object . get <identifiersep> document <identifiersep> reference ( ) ) ; syntax syntax = <string_literal> . equals ( editor <identifiersep> type ) ? syntax . plain <identifiersep> 1 <identifiersep> 0 : get <identifiersep> object <identifiersep> document <identifiersep> syntax ( object , context ) ; syntax <identifiersep> content syntax <identifiersep> content = new syntax <identifiersep> content ( object . get <identifiersep> string <identifiersep> value ( name ) , syntax ) ; try { buffer . append ( editor . render ( syntax <identifiersep> content , parameters ) ) ; } catch ( edit <identifiersep> exception e ) { <LOG> } } @ override public void display <identifiersep> view ( string <identifiersep> buffer buffer , string name , string prefix , base <identifiersep> collection object , x <identifiersep> wiki <identifiersep> context context ) { string content <identifiersep> type = get <identifiersep> content <identifiersep> type ( ) ; x <identifiersep> wiki <identifiersep> document doc = context . get <identifiersep> doc ( ) ; <ect>
sb . append ( integer . to <identifiersep> hex <identifiersep> string ( b ) ) ; } return sb . to <identifiersep> string ( ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { logger . error ( <string_literal> , algorithm <identifiersep> name , get <identifiersep> name ( ) , get <identifiersep> x <identifiersep> class <identifiersep> reference ( ) , ex ) ; } catch ( null <identifiersep> pointer <identifiersep> exception ex ) { <LOG> } return password ; } public static string random <identifiersep> salt ( ) { string <identifiersep> builder salt = new string <identifiersep> builder ( ) ; secure <identifiersep> random random = new secure <identifiersep> random ( ) ; byte bytes [ ] = new byte [ <number_literal> ] ; <ect>
<comment> <LOG> } return sql ; } public string get <identifiersep> sql ( ) { return get <identifiersep> large <identifiersep> string <identifiersep> value ( <string_literal> ) ; } public void set <identifiersep> sql ( string sql ) { <ect>
if ( ( value != null ) && ( ! value . equals ( <string_literal> ) ) ) { nvalue = double . value <identifiersep> of ( value ) ; } } else { if ( ( value != null ) && ( ! value . equals ( <string_literal> ) ) ) { nvalue = long . value <identifiersep> of ( value ) ; } } } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> + value ) ; <comment> <ect>
<comment> <LOG> } return sql ; } } <ect>
<comment> protected string get <identifiersep> default <identifiersep> custom <identifiersep> displayer ( string property <identifiersep> class <identifiersep> name , x <identifiersep> wiki <identifiersep> context context ) { <LOG> try { <comment> <ect>
logger . debug ( <string_literal> , page <identifiersep> name ) ; return document <identifiersep> displayer <identifiersep> identifier <identifiersep> prefix + <string_literal> + page <identifiersep> name ; } <comment> <LOG> return document <identifiersep> displayer <identifiersep> identifier <identifiersep> prefix + context . get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) + <string_literal> + page <identifiersep> name ; } } <comment> <ect>
return base <identifiersep> class ; } document <identifiersep> reference class <identifiersep> reference = get <identifiersep> x <identifiersep> class <identifiersep> reference ( ) ; if ( class <identifiersep> reference != null ) { try { base <identifiersep> class = context . get <identifiersep> wiki ( ) . get <identifiersep> x <identifiersep> class ( class <identifiersep> reference , context ) ; } catch ( exception e ) { <LOG> } } return base <identifiersep> class ; } public string get <identifiersep> string <identifiersep> value ( string name ) { base <identifiersep> property prop = ( base <identifiersep> property ) safeget ( name ) ; if ( prop == null || prop . get <identifiersep> value ( ) == null ) { return <string_literal> ; <ect>
base <identifiersep> object object = doc . get <identifiersep> object ( class <identifiersep> name , object <identifiersep> number ) ; if ( object != null ) { base <identifiersep> property property = ( base <identifiersep> property ) object . get ( property <identifiersep> name ) ; if ( property != null ) { value = property . get <identifiersep> value ( ) ; } } } } catch ( exception e ) { <LOG> } return value ; } @ override @ deprecated public object get <identifiersep> property ( string document <identifiersep> reference , string class <identifiersep> name , string property <identifiersep> name ) { object value = null ; <ect>
base <identifiersep> object object = doc . get <identifiersep> x <identifiersep> object ( class <identifiersep> reference ) ; if ( object != null ) { base <identifiersep> property property = ( base <identifiersep> property ) object . get ( property <identifiersep> name ) ; if ( property != null ) { value = property . get <identifiersep> value ( ) ; } } } } catch ( exception e ) { <LOG> } return value ; } @ override public object get <identifiersep> property ( document <identifiersep> reference document <identifiersep> reference , document <identifiersep> reference class <identifiersep> reference , int object <identifiersep> number , string property <identifiersep> name ) { object value = null ; <ect>
base <identifiersep> object object = doc . get <identifiersep> first <identifiersep> object ( property <identifiersep> name , xcontext ) ; if ( object != null ) { base <identifiersep> property property = ( base <identifiersep> property ) object . get ( property <identifiersep> name ) ; if ( property != null ) { value = property . get <identifiersep> value ( ) ; } } } } catch ( exception e ) { <LOG> } return value ; } @ override public list < object > get <identifiersep> properties ( string document <identifiersep> reference , string class <identifiersep> name ) { list < object > result ; try { <ect>
<comment> @ override public void error ( sax <identifiersep> parse <identifiersep> exception exception ) throws sax <identifiersep> exception { <LOG> exception . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
<comment> @ override public void warning ( sax <identifiersep> parse <identifiersep> exception exception ) throws sax <identifiersep> exception { <LOG> exception . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
<comment> <LOG> } finally { if ( backup != null ) { restore <identifiersep> context ( backup , context ) ; } context . put ( ckey <identifiersep> sdoc , current <identifiersep> s <identifiersep> document ) ; get <identifiersep> progress ( ) . end <identifiersep> step ( this ) ; } return <string_literal> ; <ect>
public com . xpn . xwiki . api . document new <identifiersep> document ( string custom <identifiersep> class <identifiersep> name , x <identifiersep> wiki <identifiersep> context context ) { if ( ! ( ( custom <identifiersep> class <identifiersep> name == null ) || ( custom <identifiersep> class <identifiersep> name . equals ( <string_literal> ) ) ) ) { try { return new <identifiersep> document ( class . for <identifiersep> name ( custom <identifiersep> class <identifiersep> name ) , context ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> } } return new com . xpn . xwiki . api . document ( this , context ) ; } <comment> <ect>
for ( int i = 0 ; i < list . size ( ) ; i ++ ) { string name = list . get ( i ) ; if ( name . index <identifiersep> of ( ' . ' ) == - 1 ) { list . set ( i , get <identifiersep> space ( ) + <string_literal> + name ) ; } } return list ; } catch ( exception e ) { <LOG> return null ; } } public list < string > get <identifiersep> included <identifiersep> macros ( x <identifiersep> wiki <identifiersep> context context ) { return context . get <identifiersep> wiki ( ) . get <identifiersep> included <identifiersep> macros ( get <identifiersep> space ( ) , get <identifiersep> content ( ) , context ) ; } public string display <identifiersep> rendered ( property <identifiersep> class pclass , string prefix , base <identifiersep> collection object , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception <ect>
try { string prev = get <identifiersep> document <identifiersep> archive ( context ) . get <identifiersep> prev <identifiersep> version ( version ) . to <identifiersep> string ( ) ; x <identifiersep> wiki <identifiersep> document prev <identifiersep> doc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( this , prev , context ) ; return get <identifiersep> deltas ( diff . diff ( to <identifiersep> string . string <identifiersep> to <identifiersep> array ( prev <identifiersep> doc . get <identifiersep> content ( ) ) , to <identifiersep> string . string <identifiersep> to <identifiersep> array ( get <identifiersep> content ( ) ) ) ) ; } catch ( exception ex ) { <LOG> } return new array <identifiersep> list < delta > ( ) ; } public list < delta > get <identifiersep> rendered <identifiersep> content <identifiersep> diff ( x <identifiersep> wiki <identifiersep> document from <identifiersep> doc , x <identifiersep> wiki <identifiersep> document to <identifiersep> doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception , differentiation <identifiersep> failed <identifiersep> exception { string original <identifiersep> content = from <identifiersep> doc . get <identifiersep> rendered <identifiersep> content ( context ) ; string new <identifiersep> content = to <identifiersep> doc . get <identifiersep> rendered <identifiersep> content ( context ) ; <ect>
{ try { return get <identifiersep> default <identifiersep> edit <identifiersep> mode <identifiersep> internal ( context ) ; } catch ( exception e ) { <comment> <LOG> return <string_literal> ; } } private string get <identifiersep> default <identifiersep> edit <identifiersep> mode <identifiersep> internal ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { string edit <identifiersep> mode <identifiersep> property = <string_literal> ; document <identifiersep> reference edit <identifiersep> mode <identifiersep> class = get <identifiersep> current <identifiersep> reference <identifiersep> document <identifiersep> reference <identifiersep> resolver ( ) . resolve ( x <identifiersep> wiki <identifiersep> constant . edit <identifiersep> mode <identifiersep> class ) ; <ect>
int b = element & 0x <identifiersep> ff ; if ( b < 0x10 ) { sb . append ( '0' ) ; } sb . append ( integer . to <identifiersep> hex <identifiersep> string ( b ) ) ; } return sb . to <identifiersep> string ( ) ; } catch ( exception ex ) { <LOG> } return hash <identifiersep> code ( ) + <string_literal> ; } public static string get <identifiersep> internal <identifiersep> property <identifiersep> name ( string propname , x <identifiersep> wiki <identifiersep> context context ) { contextual <identifiersep> localization <identifiersep> manager localization <identifiersep> manager = utils . get <identifiersep> component ( contextual <identifiersep> localization <identifiersep> manager . class ) ; string cpropname = string <identifiersep> utils . capitalize ( propname ) ; return localization <identifiersep> manager == null ? cpropname : localization <identifiersep> manager . get <identifiersep> translation <identifiersep> plain ( cpropname ) ; <ect>
private x <identifiersep> wiki <identifiersep> attachment <identifiersep> store <identifiersep> interface get <identifiersep> x <identifiersep> wiki <identifiersep> attachment <identifiersep> store <identifiersep> interface ( string store <identifiersep> type ) { if ( store <identifiersep> type != null && ! store <identifiersep> type . equals ( x <identifiersep> wiki <identifiersep> hibernate <identifiersep> attachment <identifiersep> store . hint ) ) { try { return utils . get <identifiersep> context <identifiersep> component <identifiersep> manager ( ) . get <identifiersep> instance ( x <identifiersep> wiki <identifiersep> attachment <identifiersep> store <identifiersep> interface . class , store <identifiersep> type ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } return null ; } } <ect>
{ try { string <identifiersep> writer writer = new string <identifiersep> writer ( ) ; to <identifiersep> xml ( new default <identifiersep> writer <identifiersep> output <identifiersep> target ( writer ) , b <identifiersep> with <identifiersep> attachment <identifiersep> content , b <identifiersep> with <identifiersep> versions , true , context ) ; return writer . to <identifiersep> string ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> return <string_literal> ; } } <comment> <ect>
modified = true ; } try { if ( ! io <identifiersep> utils . content <identifiersep> equals ( get <identifiersep> content <identifiersep> input <identifiersep> stream ( null ) , attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( null ) ) ) { set <identifiersep> content ( attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( null ) ) ; modified = true ; } } catch ( exception e ) { <LOG> } return modified ; } public boolean equals <identifiersep> data ( x <identifiersep> wiki <identifiersep> attachment other <identifiersep> attachment , x <identifiersep> wiki <identifiersep> context xcontext ) throws x <identifiersep> wiki <identifiersep> exception { try { if ( get <identifiersep> long <identifiersep> size ( ) == other <identifiersep> attachment . get <identifiersep> long <identifiersep> size ( ) ) { input <identifiersep> stream is = get <identifiersep> content <identifiersep> input <identifiersep> stream ( xcontext ) ; <ect>
<comment> public void set <identifiersep> diff ( boolean is <identifiersep> diff ) { if ( this . content != null ) { if ( is <identifiersep> diff != is <identifiersep> content <identifiersep> diff ( ) ) { <LOG> this . is <identifiersep> diff = is <identifiersep> content <identifiersep> diff ( ) ; return ; } } this . is <identifiersep> diff = is <identifiersep> diff ; } <comment> <ect>
public org . w3c . dom . document get <identifiersep> dom <identifiersep> for <identifiersep> string ( string str ) { try { return document <identifiersep> builder <identifiersep> factory . new <identifiersep> instance ( ) . new <identifiersep> document <identifiersep> builder ( ) . parse ( new input <identifiersep> source ( new string <identifiersep> reader ( str ) ) ) ; } catch ( sax <identifiersep> exception ex ) { <LOG> } catch ( io <identifiersep> exception ex ) { logger . warn ( <string_literal> + str , ex ) ; } catch ( parser <identifiersep> configuration <identifiersep> exception ex ) { logger . warn ( <string_literal> + str , ex ) ; } return null ; } <comment> <ect>
. parse ( new input <identifiersep> source ( new string <identifiersep> reader ( str ) ) ) ; } catch ( sax <identifiersep> exception ex ) { logger . warn ( <string_literal> + str , ex ) ; } catch ( io <identifiersep> exception ex ) { logger . warn ( <string_literal> + str , ex ) ; } catch ( parser <identifiersep> configuration <identifiersep> exception ex ) { <LOG> } return null ; } <comment> <ect>
file file = new file ( resource ) ; try { if ( file . exists ( ) ) { return new file <identifiersep> input <identifiersep> stream ( file ) ; } } catch ( exception e ) { <comment> <LOG> } try { container container = utils . get <identifiersep> component ( container . class ) ; input <identifiersep> stream res = container . get <identifiersep> application <identifiersep> context ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( resource ) ; if ( res != null ) { return res ; } } catch ( exception e ) { <ect>
try { locale l = new locale ( parts [ 0 ] , parts . length > 1 ? parts [ 1 ] : <string_literal> ) ; <comment> <LOG> } return default <identifiersep> language ; } <comment> <ect>
for ( int l = digest . length , i = math . max ( 0 , digest . length - <number_literal> ) ; i < l ; i ++ ) { hash = hash < < <number_literal> | ( ( long ) digest [ i ] & 0x <identifiersep> ff ) ; } } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; throw new runtime <identifiersep> exception ( <string_literal> ) ; } catch ( exception ex ) { <LOG> throw new runtime <identifiersep> exception ( <string_literal> ) ; } return hash ; } } <ect>
<comment> private static void add <identifiersep> dir <identifiersep> to <identifiersep> zip ( file directory , file <identifiersep> filter filter , zip <identifiersep> output <identifiersep> stream out , string base <identifiersep> path , collection < string > exported <identifiersep> skin <identifiersep> files ) throws io <identifiersep> exception { <LOG> } if ( ! directory . is <identifiersep> directory ( ) ) { return ; } file [ ] files = directory . list <identifiersep> files ( filter ) ; if ( files == null ) { return ; } for ( file file : files ) { <ect>
public url create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( string filename , string spaces , string name , string revision , string wiki , x <identifiersep> wiki <identifiersep> context context ) { try { return get <identifiersep> url ( wiki , spaces , name , filename , revision , context ) ; } catch ( exception ex ) { <LOG> return super . create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( filename , spaces , name , revision , wiki , context ) ; } } @ override public url create <identifiersep> skin <identifiersep> url ( string filename , string skin , x <identifiersep> wiki <identifiersep> context context ) { try { map < string , file > used <identifiersep> files = get <identifiersep> file <identifiersep> mapping ( context ) ; <ect>
export <identifiersep> html ( content , out , type , context ) ; } finally { try { file <identifiersep> utils . delete <identifiersep> directory ( tempdir ) ; } catch ( io <identifiersep> exception ex ) { <comment> <LOG> } } } @ override public void export <identifiersep> html ( string html , output <identifiersep> stream out , export <identifiersep> type type , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { export <identifiersep> xhtml ( apply <identifiersep> css ( convert <identifiersep> to <identifiersep> strict <identifiersep> x <identifiersep> html ( html ) , context ) , out , type , context ) ; } <comment> <ect>
public int is <identifiersep> installable ( ) { return this . installable ; } public int test <identifiersep> install ( boolean is <identifiersep> admin , x <identifiersep> wiki <identifiersep> context context ) { <LOG> + ( ( this . doc == null ) ? <string_literal> : get <identifiersep> language ( ) ) ) ; } this . installable = install <identifiersep> impossible ; try { if ( this . doc == null ) { return this . installable ; } try { <ect>
if ( bclass . get <identifiersep> field <identifiersep> list ( ) . size ( ) > 0 ) { this . class <identifiersep> files . add ( docinfo ) ; } if ( bclass . get <identifiersep> custom <identifiersep> mapping ( ) != null ) { this . custom <identifiersep> mapping <identifiersep> files . add ( docinfo ) ; } return true ; } catch ( exclude <identifiersep> document <identifiersep> exception e ) { <LOG> return false ; } } public boolean add ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { return add ( doc , document <identifiersep> info . action <identifiersep> not <identifiersep> defined , context ) ; } public boolean update <identifiersep> doc ( string doc <identifiersep> full <identifiersep> name , int action , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <ect>
<comment> for ( x <identifiersep> wiki <identifiersep> document doc : docs <identifiersep> to <identifiersep> load ) { if ( document <identifiersep> exist <identifiersep> in <identifiersep> package <identifiersep> file ( doc . get <identifiersep> full <identifiersep> name ( ) , doc . get <identifiersep> language ( ) , description ) ) { this . add ( doc , context ) ; } else { <LOG> + <string_literal> ) ; <comment> <ect>
int res = doc <identifiersep> info . test <identifiersep> install ( is <identifiersep> admin , context ) ; if ( res < result ) { result = res ; } } return result ; } finally { <LOG> } } } public int install ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { boolean is <identifiersep> admin = context . get <identifiersep> wiki ( ) . get <identifiersep> right <identifiersep> service ( ) . has <identifiersep> wiki <identifiersep> admin <identifiersep> rights ( context ) ; if ( test <identifiersep> install ( is <identifiersep> admin , context ) == document <identifiersep> info . install <identifiersep> impossible ) { set <identifiersep> status ( document <identifiersep> info . install <identifiersep> impossible , context ) ; return document <identifiersep> info . install <identifiersep> impossible ; <ect>
installed <identifiersep> extension installed <identifiersep> extension = installed <identifiersep> repository . install <identifiersep> extension ( local <identifiersep> extension , namespace , false ) ; <comment> <LOG> } } } <comment> <ect>
context . get <identifiersep> wiki ( ) . get <identifiersep> store ( ) . delete <identifiersep> x <identifiersep> wiki <identifiersep> doc ( previousdoc , context ) ; } catch ( exception e ) { <comment> <LOG> logger . debug ( <string_literal> + previousdoc . get <identifiersep> document <identifiersep> reference ( ) , e ) ; } } } else if ( previousdoc . has <identifiersep> element ( x <identifiersep> wiki <identifiersep> document . has <identifiersep> attachments ) ) { <comment> <ect>
<comment> <LOG> } result = document <identifiersep> info . install <identifiersep> error ; } } return result ; } <comment> private boolean document <identifiersep> contains <identifiersep> history ( document <identifiersep> info doc ) <ect>
add ( doc , context ) ; ++ count ; } else { throw new package <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <string_literal> + doc . get <identifiersep> document <identifiersep> reference ( ) + <string_literal> ) ; } } catch ( exclude <identifiersep> document <identifiersep> exception e ) { <LOG> } } else if ( ! file . get <identifiersep> name ( ) . equals ( default <identifiersep> package <identifiersep> file <identifiersep> name ) ) { logger . info ( file . get <identifiersep> absolute <identifiersep> path ( ) + <string_literal> ) ; } } } return count ; } <comment> <ect>
file infofile = new file ( dir , default <identifiersep> package <identifiersep> file <identifiersep> name ) ; document description = from <identifiersep> xml ( new file <identifiersep> input <identifiersep> stream ( infofile ) ) ; count = read <identifiersep> from <identifiersep> dir ( dir , context , description ) ; update <identifiersep> file <identifiersep> infos ( description ) ; } catch ( document <identifiersep> exception e ) { throw new package <identifiersep> exception ( package <identifiersep> exception . error <identifiersep> package <identifiersep> unknown , <string_literal> ) ; } <LOG> return <string_literal> ; } <comment> <ect>
this . plugins . add ( plugin . get <identifiersep> name ( ) ) ; this . plugins <identifiersep> classes . put ( plugin . get <identifiersep> name ( ) , plugin ) ; this . plugin <identifiersep> class <identifiersep> names . add ( class <identifiersep> name ) ; init <identifiersep> plugin ( plugin , plugin <identifiersep> class , context ) ; } } catch ( exception ex ) { <comment> <LOG> } } public void remove <identifiersep> plugin ( string class <identifiersep> name ) { this . plugins . remove ( class <identifiersep> name ) ; object plugin = this . plugins <identifiersep> classes . get ( class <identifiersep> name ) ; this . plugins <identifiersep> classes . remove ( class <identifiersep> name ) ; for ( string name : this . function <identifiersep> list . key <identifiersep> set ( ) ) { <ect>
{ x <identifiersep> wiki <identifiersep> attachment attach = attachment ; for ( x <identifiersep> wiki <identifiersep> plugin <identifiersep> interface plugin : get <identifiersep> plugins ( <string_literal> ) ) { try { attach = plugin . download <identifiersep> attachment ( attach , context ) ; } catch ( exception ex ) { <LOG> } } return attach ; } } <ect>
list < file <identifiersep> item > fileuploadlist = get <identifiersep> file <identifiersep> items ( context ) ; if ( fileuploadlist != null ) { for ( file <identifiersep> item item : fileuploadlist ) { try { item . delete ( ) ; } catch ( exception ex ) { <LOG> } } context . remove ( file <identifiersep> list <identifiersep> key ) ; } } <comment> <ect>
throws x <identifiersep> wiki <identifiersep> exception { logger . debug ( <string_literal> ) ; <comment> <LOG> return ; } <comment> <ect>
<comment> public file <identifiersep> item get <identifiersep> file ( string formfield <identifiersep> name , x <identifiersep> wiki <identifiersep> context context ) { <LOG> list < file <identifiersep> item > fileuploadlist = get <identifiersep> file <identifiersep> items ( context ) ; if ( fileuploadlist == null ) { return null ; } file <identifiersep> item fileitem = null ; for ( file <identifiersep> item item : fileuploadlist ) { if ( formfield <identifiersep> name . equals ( item . get <identifiersep> field <identifiersep> name ( ) ) ) { <ect>
int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> } return count ; } <comment> <ect>
int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> } return count ; } <comment> public int count <identifiersep> all <identifiersep> local <identifiersep> groups ( ) throws x <identifiersep> wiki <identifiersep> exception <ect>
public collection < string > get <identifiersep> all <identifiersep> groups <identifiersep> names <identifiersep> for <identifiersep> member ( string member ) throws x <identifiersep> wiki <identifiersep> exception { collection < string > member <identifiersep> list ; try { member <identifiersep> list = rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> groups <identifiersep> names <identifiersep> for <identifiersep> member ( member , 0 , 0 , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> member <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return member <identifiersep> list ; } <comment> <ect>
public int count <identifiersep> all <identifiersep> groups <identifiersep> names <identifiersep> for <identifiersep> member ( string member ) throws x <identifiersep> wiki <identifiersep> exception { int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> groups <identifiersep> names <identifiersep> for <identifiersep> member ( member , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> } return count ; } <comment> <ect>
int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> } return count ; } <comment> <ect>
int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> } return count ; } <comment> public int count <identifiersep> all <identifiersep> local <identifiersep> users ( ) throws x <identifiersep> wiki <identifiersep> exception <ect>
try { user <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
try { user <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> wiki <identifiersep> users <identifiersep> or <identifiersep> groups ( true , wiki <identifiersep> name , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; user <identifiersep> list = convert ( xdoc <identifiersep> list ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> wiki <identifiersep> users <identifiersep> or <identifiersep> groups ( true , wiki <identifiersep> name , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; user <identifiersep> list = convert ( xdoc <identifiersep> list ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
string user <identifiersep> or <identifiersep> group <identifiersep> space = document . get <identifiersep> space ( ) ; string user <identifiersep> or <identifiersep> group <identifiersep> name = document . get <identifiersep> name ( ) ; if ( document . get <identifiersep> object ( <string_literal> ) != null ) { try { clean <identifiersep> deleted <identifiersep> user <identifiersep> or <identifiersep> group ( user <identifiersep> or <identifiersep> group <identifiersep> wiki , user <identifiersep> or <identifiersep> group <identifiersep> space , user <identifiersep> or <identifiersep> group <identifiersep> name , true , context ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } else if ( document . get <identifiersep> object ( <string_literal> ) != null ) { try { clean <identifiersep> deleted <identifiersep> user <identifiersep> or <identifiersep> group ( user <identifiersep> or <identifiersep> group <identifiersep> wiki , user <identifiersep> or <identifiersep> group <identifiersep> space , user <identifiersep> or <identifiersep> group <identifiersep> name , false , context ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } } } <comment> <ect>
super . init ( context ) ; file dir = this . environment . get <identifiersep> temporary <identifiersep> directory ( ) ; this . temp <identifiersep> dir = new file ( dir , <string_literal> ) ; try { this . temp <identifiersep> dir . mkdirs ( ) ; } catch ( exception ex ) { <LOG> } } public byte [ ] get <identifiersep> svg <identifiersep> image ( string content , int height , int width ) throws io <identifiersep> exception , svg <identifiersep> converter <identifiersep> exception { return get <identifiersep> svg <identifiersep> image ( content , <string_literal> , height , width ) ; } public byte [ ] get <identifiersep> svg <identifiersep> image ( string content , string extension , int height , int width ) throws io <identifiersep> exception , svg <identifiersep> converter <identifiersep> exception { <ect>
{ string current <identifiersep> wiki = get <identifiersep> wiki <identifiersep> id ( ) ; try { set <identifiersep> wiki <identifiersep> id ( get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) ) ; return get <identifiersep> wiki ( ) . get <identifiersep> document ( x <identifiersep> wiki . get <identifiersep> server <identifiersep> wiki <identifiersep> page ( current <identifiersep> wiki ) , this ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } finally { set <identifiersep> wiki <identifiersep> id ( current <identifiersep> wiki ) ; } return null ; } public int get <identifiersep> cache <identifiersep> duration ( ) { return this . cache <identifiersep> duration ; <ect>
{ try { while ( true ) { register ( ) ; } } catch ( interrupted <identifiersep> exception e ) { <LOG> } } catch ( stop <identifiersep> stats <identifiersep> store <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } } <comment> <ect>
<comment> public void add ( x <identifiersep> wiki <identifiersep> stats <identifiersep> store <identifiersep> item stats <identifiersep> register <identifiersep> item ) { try { this . queue . put ( stats <identifiersep> register <identifiersep> item ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } } <comment> <ect>
referer <identifiersep> stat . set <identifiersep> int <identifiersep> value ( <string_literal> , referer <identifiersep> stat . get <identifiersep> page <identifiersep> views ( ) + stats . size ( ) ) ; <comment> <LOG> } } } <ect>
} catch ( exception e ) { logger . error ( <string_literal> , get <identifiersep> id ( ) , e ) ; } } } <comment> <LOG> } } } <ect>
list < ? > solist = store . search ( query , range . get <identifiersep> absolute <identifiersep> size ( ) , range . get <identifiersep> absolute <identifiersep> start ( ) , param <identifiersep> list , context ) ; visi <identifiersep> stat <identifiersep> list = get <identifiersep> visit <identifiersep> statistics ( solist , new date <identifiersep> time ( period . get <identifiersep> start ( ) ) , new date <identifiersep> time ( period . get <identifiersep> end ( ) ) ) ; if ( range . get <identifiersep> size ( ) < 0 ) { collections . reverse ( visi <identifiersep> stat <identifiersep> list ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> visi <identifiersep> stat <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return visi <identifiersep> stat <identifiersep> list ; } <comment> <ect>
if ( servername . index <identifiersep> of ( cookie <identifiersep> domain2 ) != - 1 ) { cookie <identifiersep> domain = cookie <identifiersep> domain2 ; break ; } } } if ( cookie <identifiersep> domain != null ) { cookie . set <identifiersep> domain ( cookie <identifiersep> domain ) ; } <LOG> + cookie . get <identifiersep> domain ( ) + <string_literal> + cookie . get <identifiersep> path ( ) + <string_literal> + cookie . get <identifiersep> max <identifiersep> age ( ) ) ; } context . get <identifiersep> response ( ) . add <identifiersep> cookie ( cookie ) ; return cookie ; } <comment> <ect>
thread cthread = thread . current <identifiersep> thread ( ) ; monitor <identifiersep> data mdata = this . active <identifiersep> timer <identifiersep> data <identifiersep> list . get ( cthread ) ; if ( mdata != null ) { remove <identifiersep> from <identifiersep> active <identifiersep> timer <identifiersep> data <identifiersep> list ( cthread ) ; add <identifiersep> to <identifiersep> last <identifiersep> unfinished <identifiersep> timer <identifiersep> data <identifiersep> list ( mdata ) ; <LOG> + <string_literal> ) ; } mdata . end <identifiersep> request ( false ) ; } mdata = new monitor <identifiersep> data ( page , action , url , cthread . get <identifiersep> name ( ) ) ; this . active <identifiersep> timer <identifiersep> data <identifiersep> list . put ( cthread , mdata ) ; } catch ( throwable e ) { <ect>
return ; } try { thread cthread = thread . current <identifiersep> thread ( ) ; monitor <identifiersep> data mdata = this . active <identifiersep> timer <identifiersep> data <identifiersep> list . get ( cthread ) ; if ( mdata == null ) { <LOG> } return ; } mdata . end <identifiersep> request ( true ) ; add <identifiersep> duration ( mdata . get <identifiersep> duration ( ) ) ; add <identifiersep> timer <identifiersep> duration ( mdata ) ; remove <identifiersep> from <identifiersep> active <identifiersep> timer <identifiersep> data <identifiersep> list ( cthread ) ; add <identifiersep> to <identifiersep> timer <identifiersep> data <identifiersep> list ( mdata ) ; <ect>
thread cthread = thread . current <identifiersep> thread ( ) ; monitor <identifiersep> data mdata = this . active <identifiersep> timer <identifiersep> data <identifiersep> list . get ( cthread ) ; if ( mdata != null ) { mdata . start <identifiersep> timer ( timername , desc ) ; } } catch ( throwable e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } public void set <identifiersep> timer <identifiersep> desc ( string timername , string desc ) { if ( is <identifiersep> active ( ) == false ) { return ; } try { <ect>
thread cthread = thread . current <identifiersep> thread ( ) ; monitor <identifiersep> data mdata = this . active <identifiersep> timer <identifiersep> data <identifiersep> list . get ( cthread ) ; if ( mdata != null ) { mdata . end <identifiersep> timer ( timername ) ; } } catch ( throwable e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } public map < thread , monitor <identifiersep> data > get <identifiersep> active <identifiersep> timer <identifiersep> data ( ) { return this . active <identifiersep> timer <identifiersep> data <identifiersep> list ; } public map < string , monitor <identifiersep> timer <identifiersep> summary > get <identifiersep> timer <identifiersep> summaries ( ) { <ect>
public void set <identifiersep> timer <identifiersep> details ( string timername , string details ) { monitor <identifiersep> timer timer ; timer = this . timers . get ( timername ) ; if ( timer == null ) { <LOG> } } else { timer . set <identifiersep> details ( details ) ; } } public void end <identifiersep> timer ( string timername ) { if ( this . start <identifiersep> time == null ) { return ; <ect>
monitor <identifiersep> timer <identifiersep> summary tsummary = this . timer <identifiersep> summaries . get ( timername ) ; if ( tsummary == null ) { tsummary = new monitor <identifiersep> timer <identifiersep> summary ( timername ) ; this . timer <identifiersep> summaries . put ( timername , tsummary ) ; } tsummary . add <identifiersep> timer ( timer . get <identifiersep> duration ( ) ) ; <LOG> + timer . get <identifiersep> duration ( ) + <string_literal> + timer . get <identifiersep> details ( ) ) ; } } } public list < monitor <identifiersep> timer > get <identifiersep> timer <identifiersep> list ( ) { return this . timer <identifiersep> list ; } public map < string , monitor <identifiersep> timer <identifiersep> summary > get <identifiersep> timer <identifiersep> summaries ( ) { <ect>
{ logger . debug ( <string_literal> + this . wiki <identifiersep> page + <string_literal> + get <identifiersep> duration ( ) + <string_literal> ) ; iterator < monitor <identifiersep> timer <identifiersep> summary > it = this . timer <identifiersep> summaries . values ( ) . iterator ( ) ; while ( it . has <identifiersep> next ( ) ) { monitor <identifiersep> timer <identifiersep> summary tsummary = it . next ( ) ; <LOG> + tsummary . get <identifiersep> duration ( ) + <string_literal> + tsummary . get <identifiersep> nb <identifiersep> calls ( ) ) ; } } } public string get <identifiersep> thread <identifiersep> name ( ) { return this . thread <identifiersep> name ; } public void set <identifiersep> thread <identifiersep> name ( string thread <identifiersep> name ) { <ect>
} catch ( illegal <identifiersep> access <identifiersep> exception e ) { logger . error ( <string_literal> , method <identifiersep> name , e ) ; return null ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { return null ; } catch ( invocation <identifiersep> target <identifiersep> exception e ) { <LOG> return null ; } } public static http <identifiersep> client get <identifiersep> http <identifiersep> client ( int timeout , string user <identifiersep> agent ) { http <identifiersep> client client = new http <identifiersep> client ( ) ; if ( timeout != 0 ) { client . get <identifiersep> params ( ) . set <identifiersep> so <identifiersep> timeout ( timeout ) ; <ect>
if ( document <identifiersep> reference . get <identifiersep> wiki <identifiersep> reference ( ) . get <identifiersep> name ( ) . equals ( context . get <identifiersep> wiki <identifiersep> id ( ) ) ) { x <identifiersep> wiki <identifiersep> document document = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , context ) ; if ( initializer . update <identifiersep> document ( document ) ) { save <identifiersep> document ( document , localize <identifiersep> plain <identifiersep> or <identifiersep> key ( <string_literal> ) , context ) ; } } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } public x <identifiersep> wiki <identifiersep> store <identifiersep> interface get <identifiersep> not <identifiersep> cache <identifiersep> store ( ) { x <identifiersep> wiki <identifiersep> store <identifiersep> interface store = get <identifiersep> store ( ) ; if ( store instanceof x <identifiersep> wiki <identifiersep> cache <identifiersep> store <identifiersep> interface ) { store = ( ( x <identifiersep> wiki <identifiersep> cache <identifiersep> store <identifiersep> interface ) store ) . get <identifiersep> store ( ) ; } return store ; <ect>
public string parse <identifiersep> template ( string template , x <identifiersep> wiki <identifiersep> context context ) { string result = <string_literal> ; try { result = evaluate <identifiersep> template ( template , context ) ; } catch ( exception e ) { <LOG> } return result ; } <comment> <ect>
try { <comment> <LOG> object [ ] args = { template , skin <identifiersep> id } ; x <identifiersep> wiki <identifiersep> exception xe = new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> rendering <identifiersep> velocity <identifiersep> exception , <string_literal> , e , args ) ; return util . get <identifiersep> html <identifiersep> exception <identifiersep> message ( xe , context ) ; } finally { <ect>
<comment> public string render <identifiersep> template ( string template , x <identifiersep> wiki <identifiersep> context context ) { try { return get <identifiersep> old <identifiersep> rendering ( ) . render <identifiersep> template ( template , context ) ; } catch ( exception ex ) { <LOG> return parse <identifiersep> template ( template , context ) ; } } <comment> public string invoke <identifiersep> servlet <identifiersep> and <identifiersep> return <identifiersep> as <identifiersep> string ( string url , x <identifiersep> wiki <identifiersep> context xwiki <identifiersep> context ) <ect>
<comment> <LOG> } } <comment> <ect>
public string get <identifiersep> skin ( x <identifiersep> wiki <identifiersep> context context ) { string skin ; try { skin = get <identifiersep> internal <identifiersep> skin <identifiersep> manager ( ) . get <identifiersep> current <identifiersep> skin <identifiersep> id ( true ) ; } catch ( exception e ) { <LOG> skin = get <identifiersep> default <identifiersep> base <identifiersep> skin ( context ) ; } return skin ; } public string get <identifiersep> skin <identifiersep> preference ( string prefname , x <identifiersep> wiki <identifiersep> context context ) { return get <identifiersep> skin <identifiersep> preference ( prefname , <string_literal> , context ) ; } public string get <identifiersep> skin <identifiersep> preference ( string prefname , string default <identifiersep> value , x <identifiersep> wiki <identifiersep> context context ) <ect>
if ( string <identifiersep> utils . is <identifiersep> blank ( default <identifiersep> language ) ) { default <identifiersep> locale = locale . english ; } else { try { default <identifiersep> locale = locale <identifiersep> utils . to <identifiersep> locale ( util . normalize <identifiersep> language ( default <identifiersep> language ) ) ; } catch ( exception e ) { <LOG> default <identifiersep> locale = locale . english ; } } return default <identifiersep> locale ; } <comment> <ect>
{ if ( ! path . starts <identifiersep> with ( segment ) ) { <comment> <LOG> } } if ( ! path . starts <identifiersep> with ( segment ) ) { <comment> <ect>
this . group <identifiersep> service = group <identifiersep> service ; } <comment> <LOG> string auth <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> ) ; if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( auth <identifiersep> class ) ) { logger . debug ( <string_literal> + auth <identifiersep> class + <string_literal> ) ; } } else { if ( is <identifiersep> ldap ( ) ) { <ect>
} else { if ( is <identifiersep> ldap ( ) ) { auth <identifiersep> class = <string_literal> ; } else { auth <identifiersep> class = <string_literal> ; } <LOG> } } try { <comment> <ect>
private static final string default <identifiersep> right <identifiersep> service <identifiersep> class = <string_literal> ; public x <identifiersep> wiki <identifiersep> right <identifiersep> service get <identifiersep> right <identifiersep> service ( ) { synchronized ( this . right <identifiersep> service <identifiersep> lock ) { if ( this . right <identifiersep> service == null ) { <LOG> string rights <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> ) ; if ( rights <identifiersep> class != null && ! rights <identifiersep> class . equals ( default <identifiersep> right <identifiersep> service <identifiersep> class ) ) { logger . warn ( <string_literal> , rights <identifiersep> class ) ; } } else { <ect>
if ( rights <identifiersep> class != null && ! rights <identifiersep> class . equals ( default <identifiersep> right <identifiersep> service <identifiersep> class ) ) { logger . warn ( <string_literal> , rights <identifiersep> class ) ; } } else { rights <identifiersep> class = default <identifiersep> right <identifiersep> service <identifiersep> class ; <LOG> } } try { this . right <identifiersep> service = ( x <identifiersep> wiki <identifiersep> right <identifiersep> service ) class . for <identifiersep> name ( rights <identifiersep> class ) . new <identifiersep> instance ( ) ; logger . debug ( <string_literal> ) ; } catch ( exception e ) { exception last <identifiersep> exception = e ; if ( ! rights <identifiersep> class . equals ( default <identifiersep> right <identifiersep> service <identifiersep> class ) ) { <ect>
<string_literal> + <string_literal> , rights <identifiersep> class , default <identifiersep> right <identifiersep> service <identifiersep> class ) , e ) ; rights <identifiersep> class = default <identifiersep> right <identifiersep> service <identifiersep> class ; try { this . right <identifiersep> service = ( x <identifiersep> wiki <identifiersep> right <identifiersep> service ) class . for <identifiersep> name ( rights <identifiersep> class ) . new <identifiersep> instance ( ) ; <LOG> } catch ( exception e1 ) { last <identifiersep> exception = e1 ; } } if ( this . right <identifiersep> service == null ) { logger . warn ( string . format ( <string_literal> + <string_literal> , <ect>
logger . info ( <string_literal> ) ; x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service factory <identifiersep> service = null ; string url <identifiersep> factory <identifiersep> service <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> ) ; if ( url <identifiersep> factory <identifiersep> service <identifiersep> class != null ) { try { <LOG> } factory <identifiersep> service = ( x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service ) class . for <identifiersep> name ( url <identifiersep> factory <identifiersep> service <identifiersep> class ) . get <identifiersep> constructor ( new class < ? > [ ] { x <identifiersep> wiki . class } ) . new <identifiersep> instance ( new object [ ] { this } ) ; } catch ( exception e ) { factory <identifiersep> service = null ; logger . warn ( <string_literal> + url <identifiersep> factory <identifiersep> service <identifiersep> class + <string_literal> , e ) ; <ect>
. get <identifiersep> constructor ( new class < ? > [ ] { x <identifiersep> wiki . class } ) . new <identifiersep> instance ( new object [ ] { this } ) ; } catch ( exception e ) { factory <identifiersep> service = null ; logger . warn ( <string_literal> + url <identifiersep> factory <identifiersep> service <identifiersep> class + <string_literal> , e ) ; } } if ( factory <identifiersep> service == null ) { <LOG> } factory <identifiersep> service = new x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service <identifiersep> impl ( this ) ; } <comment> <ect>
sdf = new simple <identifiersep> date <identifiersep> format ( xformat ) ; } try { sdf . set <identifiersep> time <identifiersep> zone ( time <identifiersep> zone . get <identifiersep> time <identifiersep> zone ( get <identifiersep> user <identifiersep> time <identifiersep> zone ( context ) ) ) ; } catch ( exception e ) { } return sdf . format ( date ) ; } catch ( exception e ) { <LOG> if ( format == null ) { if ( xformat . equals ( default <identifiersep> format ) ) { return date . to <identifiersep> string ( ) ; } else { return format <identifiersep> date ( date , default <identifiersep> format , context ) ; } } else { <ect>
{ x <identifiersep> wiki <identifiersep> document newdoc = get <identifiersep> recycle <identifiersep> bin <identifiersep> store ( ) . restore <identifiersep> from <identifiersep> recycle <identifiersep> bin ( index , context , true ) ; save <identifiersep> document ( newdoc , comment , context ) ; get <identifiersep> recycle <identifiersep> bin <identifiersep> store ( ) . delete <identifiersep> from <identifiersep> recycle <identifiersep> bin ( index , context , true ) ; } public x <identifiersep> wiki <identifiersep> document rollback ( final x <identifiersep> wiki <identifiersep> document tdoc , string rev , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <LOG> <comment> <ect>
logger . debug ( <string_literal> ) ; for ( x <identifiersep> wiki <identifiersep> attachment old <identifiersep> attachment : old <identifiersep> attachments ) { string filename = old <identifiersep> attachment . get <identifiersep> filename ( ) ; x <identifiersep> wiki <identifiersep> attachment equivalent <identifiersep> attachment = tdoc . get <identifiersep> attachment ( filename ) ; if ( equivalent <identifiersep> attachment == null ) { <comment> <LOG> to <identifiersep> restore . add ( old <identifiersep> attachment ) ; continue ; } x <identifiersep> wiki <identifiersep> attachment equivalent <identifiersep> attachment <identifiersep> revision = equivalent <identifiersep> attachment . get <identifiersep> attachment <identifiersep> revision ( old <identifiersep> attachment . get <identifiersep> version ( ) , context ) ; <comment> <ect>
get <identifiersep> attachment <identifiersep> recycle <identifiersep> bin <identifiersep> store ( ) . save <identifiersep> to <identifiersep> recycle <identifiersep> bin ( equivalent <identifiersep> attachment , context . get <identifiersep> user ( ) , new date ( ) , context , true ) ; to <identifiersep> restore . add ( old <identifiersep> attachment ) ; } continue ; } if ( ! string <identifiersep> utils . equals ( old <identifiersep> attachment . get <identifiersep> version ( ) , equivalent <identifiersep> attachment . get <identifiersep> version ( ) ) ) { <comment> <LOG> to <identifiersep> revert . add ( equivalent <identifiersep> attachment ) ; } } for ( x <identifiersep> wiki <identifiersep> attachment attachment : current <identifiersep> attachments ) { if ( rolledback <identifiersep> doc . get <identifiersep> attachment ( attachment . get <identifiersep> filename ( ) ) == null ) { logger . debug ( <string_literal> + attachment . get <identifiersep> filename ( ) ) ; <comment> <ect>
for ( string wiki : this . initialized <identifiersep> wikis . key <identifiersep> set ( ) ) { initialize <identifiersep> mandatory <identifiersep> document ( wiki , initializer , context ) ; } } else if ( namespace . starts <identifiersep> with ( <string_literal> ) ) { <comment> <LOG> } } <comment> private static final regex <identifiersep> entity <identifiersep> reference xwikipreference <identifiersep> property <identifiersep> reference = x <identifiersep> wiki <identifiersep> preferences <identifiersep> document <identifiersep> initializer . object <identifiersep> reference ; private static final list < event > listener <identifiersep> events = <ect>
string <identifiersep> builder new <identifiersep> path = new string <identifiersep> builder ( <string_literal> ) ; <comment> <LOG> } return skin <identifiersep> url ; } <comment> private void render <identifiersep> skin <identifiersep> file ( string path , string spaces , string name , string wiki <identifiersep> id , file output <identifiersep> file , int css <identifiersep> path <identifiersep> adjustment <identifiersep> value , x <identifiersep> wiki <identifiersep> context context ) throws io <identifiersep> exception , x <identifiersep> wiki <identifiersep> exception <ect>
newpath . append ( <string_literal> ) ; if ( ! string <identifiersep> utils . is <identifiersep> empty ( anchor ) ) { newpath . append ( <string_literal> ) ; newpath . append ( anchor ) ; } return new url ( newpath . to <identifiersep> string ( ) ) ; } } catch ( exception e ) { <LOG> } return super . create <identifiersep> url ( spaces , name , action , querystring , anchor , xwikidb , context ) ; } <comment> <ect>
public url create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( string filename , string spaces , string name , string revision , string xwikidb , x <identifiersep> wiki <identifiersep> context context ) { try { return create <identifiersep> attachment <identifiersep> url ( filename , spaces , name , xwikidb , context ) ; } catch ( exception e ) { <LOG> return super . create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( filename , spaces , name , revision , xwikidb , context ) ; } } @ override public string get <identifiersep> url ( url url , x <identifiersep> wiki <identifiersep> context context ) { if ( url == null ) { return <string_literal> ; <ect>
<comment> <LOG> } return false ; } private string evaluate <identifiersep> velocity ( string content , entity <identifiersep> reference reference , document <identifiersep> reference author , x <identifiersep> wiki <identifiersep> context context ) { entity <identifiersep> reference <identifiersep> serializer < string > serializer = utils . get <identifiersep> component ( entity <identifiersep> reference <identifiersep> serializer . type <identifiersep> string ) ; string namespace = serializer . serialize ( reference ) ; <ect>
} else { <comment> <LOG> } return false ; } <comment> <ect>
this . docs <identifiersep> to <identifiersep> refresh . add ( doc <identifiersep> id ) ; this . previous <identifiersep> dates . put ( doc <identifiersep> id , doc <identifiersep> date ) ; } result . add ( doc <identifiersep> bundle ) ; } else { <comment> <LOG> + <string_literal> + <string_literal> ) ; } } } } return result ; } <comment> <ect>
x <identifiersep> wiki <identifiersep> lock lock = doc . get <identifiersep> lock ( context ) ; if ( ( lock == null ) || ( lock . get <identifiersep> user <identifiersep> name ( ) . equals ( context . get <identifiersep> user ( ) ) ) || ( peform . is <identifiersep> lock <identifiersep> force ( ) ) ) { doc . set <identifiersep> lock ( context . get <identifiersep> user ( ) , context ) ; } } catch ( exception e ) { <comment> <LOG> } } <comment> <ect>
<comment> <LOG> throw e ; } } <comment> <ect>
} catch ( not <identifiersep> found <identifiersep> resource <identifiersep> handler <identifiersep> exception e ) { <comment> <LOG> } get <identifiersep> progress ( ) . start <identifiersep> step ( this , <string_literal> ) ; <comment> <ect>
<comment> <LOG> } <comment> <ect>
return null ; } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { if ( ex . get <identifiersep> code ( ) == x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> app <identifiersep> send <identifiersep> response <identifiersep> exception ) { logger . error ( <string_literal> ) ; } } catch ( exception e2 ) { <comment> <LOG> logger . error ( <string_literal> , e2 ) ; } return null ; } finally { <comment> <ect>
x <identifiersep> wiki <identifiersep> lock lock = tdoc . get <identifiersep> lock ( context ) ; if ( ( lock == null ) || ( lock . get <identifiersep> user <identifiersep> name ( ) . equals ( context . get <identifiersep> user ( ) ) ) || ( peform . is <identifiersep> lock <identifiersep> force ( ) ) ) { tdoc . set <identifiersep> lock ( context . get <identifiersep> user ( ) , context ) ; } } catch ( exception e ) { <comment> <LOG> } } return <string_literal> ; } } <ect>
try { context . get <identifiersep> response ( ) . set <identifiersep> content <identifiersep> type ( <string_literal> ) ; context . get <identifiersep> response ( ) . set <identifiersep> status ( http <identifiersep> status <identifiersep> code ) ; context . get <identifiersep> response ( ) . set <identifiersep> character <identifiersep> encoding ( context . get <identifiersep> wiki ( ) . get <identifiersep> encoding ( ) ) ; context . get <identifiersep> response ( ) . get <identifiersep> writer ( ) . print ( message ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } <comment> <ect>
x <identifiersep> wiki <identifiersep> document config <identifiersep> doc = xwiki . get <identifiersep> document ( config <identifiersep> ref , context ) ; <comment> <LOG> return false ; } } catch ( exception e ) { logger . warn ( <string_literal> , e . get <identifiersep> message ( ) ) ; return false ; } } return true ; } } <ect>
protected void register ( x <identifiersep> wiki xwiki , int mode , class < ? extends x <identifiersep> wiki <identifiersep> url <identifiersep> factory > default <identifiersep> impl , string property <identifiersep> name ) { this . factory <identifiersep> map . put ( mode , default <identifiersep> impl ) ; string url <identifiersep> factory <identifiersep> class <identifiersep> name = xwiki . param ( property <identifiersep> name ) ; if ( url <identifiersep> factory <identifiersep> class <identifiersep> name != null ) { try { <LOG> @ suppress <identifiersep> warnings ( <string_literal> ) class < ? extends x <identifiersep> wiki <identifiersep> url <identifiersep> factory > url <identifiersep> factory <identifiersep> class = ( class < ? extends x <identifiersep> wiki <identifiersep> url <identifiersep> factory > ) class . for <identifiersep> name ( url <identifiersep> factory <identifiersep> class <identifiersep> name ) ; this . factory <identifiersep> map . put ( mode , url <identifiersep> factory <identifiersep> class ) ; } catch ( exception e ) { logger . error ( <string_literal> + url <identifiersep> factory <identifiersep> class <identifiersep> name + <string_literal> ) ; <ect>
x <identifiersep> wiki <identifiersep> url <identifiersep> factory urlf = null ; try { class < ? extends x <identifiersep> wiki <identifiersep> url <identifiersep> factory > url <identifiersep> factory <identifiersep> class = this . factory <identifiersep> map . get ( mode ) ; urlf = url <identifiersep> factory <identifiersep> class . new <identifiersep> instance ( ) ; urlf . init ( context ) ; } catch ( exception e ) { <LOG> } return urlf ; } } <ect>
string <identifiersep> utils . remove <identifiersep> end ( string <identifiersep> utils . remove <identifiersep> end ( querystring , <string_literal> ) , <string_literal> ) ) ; } string anchor = url . get <identifiersep> ref ( ) ; if ( ! string <identifiersep> utils . is <identifiersep> empty ( anchor ) ) { relative <identifiersep> url <identifiersep> builder . append ( <string_literal> ) . append ( anchor ) ; } relative <identifiersep> url = relative <identifiersep> url <identifiersep> builder . to <identifiersep> string ( ) ; } } } catch ( exception e ) { <LOG> } return string <identifiersep> utils . default <identifiersep> if <identifiersep> empty ( relative <identifiersep> url , <string_literal> ) ; } @ override public url get <identifiersep> request <identifiersep> url ( x <identifiersep> wiki <identifiersep> context context ) { final url url = super . get <identifiersep> request <identifiersep> url ( context ) ; try { <ect>
} catch ( exception ex ) { wrong <identifiersep> file <identifiersep> names . add ( fileupload . get <identifiersep> file <identifiersep> name ( field <identifiersep> name , context ) ) ; } } for ( entry < string , string > file : file <identifiersep> names . entry <identifiersep> set ( ) ) { try { upload <identifiersep> attachment ( file . get <identifiersep> value ( ) , file . get <identifiersep> key ( ) , fileupload , doc , context ) ; } catch ( exception ex ) { <LOG> failed <identifiersep> files . put ( file . get <identifiersep> key ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( ex ) ) ; } } logger . debug ( <string_literal> + file <identifiersep> names ) ; logger . debug ( <string_literal> + failed <identifiersep> files ) ; logger . debug ( <string_literal> + wrong <identifiersep> file <identifiersep> names ) ; if ( ajax ) { try { <ect>
try { upload <identifiersep> attachment ( file . get <identifiersep> value ( ) , file . get <identifiersep> key ( ) , fileupload , doc , context ) ; } catch ( exception ex ) { logger . warn ( <string_literal> , ex ) ; failed <identifiersep> files . put ( file . get <identifiersep> key ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( ex ) ) ; } } logger . debug ( <string_literal> + file <identifiersep> names ) ; <LOG> logger . debug ( <string_literal> + wrong <identifiersep> file <identifiersep> names ) ; if ( ajax ) { try { response . get <identifiersep> output <identifiersep> stream ( ) . println ( <string_literal> ) ; } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; <ect>
<comment> <LOG> return false ; } } private set < string > get <identifiersep> target ( event event , object source , document <identifiersep> reference user <identifiersep> reference , string template <identifiersep> content ) { try { <comment> <ect>
public string url ( string resource <identifiersep> name ) { if ( string <identifiersep> utils . is <identifiersep> empty ( resource <identifiersep> name ) ) { return null ; } string [ ] parts = resource <identifiersep> name . split ( resource <identifiersep> separator , <number_literal> ) ; if ( parts . length < <number_literal> ) { <LOG> return null ; } <comment> <ect>
if ( meta <identifiersep> data != null ) { try { json <identifiersep> map . put ( property <identifiersep> db <identifiersep> name , meta <identifiersep> data . get <identifiersep> database <identifiersep> product <identifiersep> name ( ) ) ; } catch ( sql <identifiersep> exception e ) { <comment> <LOG> } try { json <identifiersep> map . put ( property <identifiersep> db <identifiersep> version , meta <identifiersep> data . get <identifiersep> database <identifiersep> product <identifiersep> version ( ) ) ; } catch ( sql <identifiersep> exception e ) { <comment> <ect>
results = collections . empty <identifiersep> list ( ) ; } else { results = response . get <identifiersep> results ( ) ; query . set ( cursor <identifiersep> mark <identifiersep> params . cursor <identifiersep> mark <identifiersep> param , response . get <identifiersep> next <identifiersep> cursor <identifiersep> mark ( ) ) ; } } catch ( exception e ) { results = collections . empty <identifiersep> list ( ) ; <LOG> } index = 0 ; } return results ; } <comment> <ect>
<comment> <LOG> } } <comment> private query get <identifiersep> query ( ) throws query <identifiersep> exception { <ect>
return indexer <identifiersep> request ; } @ override protected void run <identifiersep> internal ( ) throws exception { if ( get <identifiersep> request ( ) . is <identifiersep> overwrite ( ) ) { entity <identifiersep> reference root <identifiersep> reference = get <identifiersep> request ( ) . get <identifiersep> root <identifiersep> reference ( ) ; <LOG> this . indexer . index ( root <identifiersep> reference , true ) ; } else { update <identifiersep> solr <identifiersep> index ( ) ; } } <comment> <ect>
{ this . logger . debug ( <string_literal> , solr <identifiersep> document ) ; this . server . add ( solr <identifiersep> document ) ; } @ override public void add ( list < solr <identifiersep> input <identifiersep> document > solr <identifiersep> documents ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { <LOG> this . server . add ( solr <identifiersep> documents ) ; } @ override public void delete ( string id ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , id ) ; this . server . delete <identifiersep> by <identifiersep> id ( id ) ; <ect>
{ this . logger . debug ( <string_literal> , id ) ; this . server . delete <identifiersep> by <identifiersep> id ( id ) ; } @ override public void delete ( list < string > ids ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { <LOG> this . server . delete <identifiersep> by <identifiersep> id ( ids ) ; } @ override public void delete <identifiersep> by <identifiersep> query ( string query ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , query ) ; this . server . delete <identifiersep> by <identifiersep> query ( query ) ; <ect>
{ this . logger . debug ( <string_literal> , query ) ; this . server . delete <identifiersep> by <identifiersep> query ( query ) ; } @ override public void commit ( ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { <LOG> this . server . commit ( ) ; } @ override public void rollback ( ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> ) ; this . server . rollback ( ) ; <ect>
{ this . logger . debug ( <string_literal> ) ; this . server . rollback ( ) ; } @ override public query <identifiersep> response query ( solr <identifiersep> params solr <identifiersep> params ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { <LOG> return this . server . query ( solr <identifiersep> params ) ; } @ override public query <identifiersep> response query <identifiersep> and <identifiersep> stream <identifiersep> response ( solr <identifiersep> params params , streaming <identifiersep> response <identifiersep> callback callback ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , params ) ; <ect>
this . solr <identifiersep> indexer . get ( ) . delete ( entity <identifiersep> event . get <identifiersep> reference ( ) , false ) ; } else if ( event instanceof wiki <identifiersep> deleted <identifiersep> event ) { string wiki <identifiersep> name = ( string ) source ; wiki <identifiersep> reference wiki <identifiersep> reference = new wiki <identifiersep> reference ( wiki <identifiersep> name ) ; this . solr <identifiersep> indexer . get ( ) . delete ( wiki <identifiersep> reference , false ) ; } } catch ( exception e ) { <LOG> } } <comment> <ect>
string solr <identifiersep> home = determine <identifiersep> home <identifiersep> directory ( ) ; try { <comment> <LOG> <comment> <ect>
public void dispose ( ) throws component <identifiersep> lifecycle <identifiersep> exception { if ( this . server != null ) { try { this . server . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } if ( this . container != null ) { this . container . shutdown ( ) ; } } <comment> <ect>
<comment> private class resolver extends abstract <identifiersep> x <identifiersep> wiki <identifiersep> runnable { @ override public void run <identifiersep> internal ( ) { <LOG> while ( ! thread . interrupted ( ) ) { resolve <identifiersep> queue <identifiersep> entry queue <identifiersep> entry ; try { queue <identifiersep> entry = resolve <identifiersep> queue . take ( ) ; } catch ( interrupted <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; <ect>
queue <identifiersep> entry . operation ) ) ; } else if ( queue <identifiersep> entry . reference != null ) { index <identifiersep> queue . put ( new index <identifiersep> queue <identifiersep> entry ( queue <identifiersep> entry . reference , queue <identifiersep> entry . operation ) ) ; } } } catch ( throwable e ) { logger . warn ( <string_literal> , queue <identifiersep> entry . operation , queue <identifiersep> entry . reference , e ) ; } } <LOG> } } <comment> private static final resolve <identifiersep> queue <identifiersep> entry resolve <identifiersep> queue <identifiersep> entry <identifiersep> stop = new resolve <identifiersep> queue <identifiersep> entry ( null , false , index <identifiersep> operation . stop ) ; <comment> <ect>
while ( ! thread . interrupted ( ) ) { <comment> <LOG> queue <identifiersep> entry = index <identifiersep> queue <identifiersep> entry <identifiersep> stop ; } <comment> <ect>
input <identifiersep> stream in = attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( this . xcontext <identifiersep> provider . get ( ) ) ; try { return tika <identifiersep> utils . parse <identifiersep> to <identifiersep> string ( in , metadata ) ; } finally { in . close ( ) ; } } catch ( exception e ) { <LOG> return null ; } } private void set <identifiersep> hierarchy <identifiersep> fields ( solr <identifiersep> input <identifiersep> document solr <identifiersep> document , entity <identifiersep> reference path ) { solr <identifiersep> document . set <identifiersep> field ( field <identifiersep> utils . space <identifiersep> exact , this . local <identifiersep> serializer . serialize ( path ) ) ; list < entity <identifiersep> reference > ancestors = path . get <identifiersep> reversed <identifiersep> reference <identifiersep> chain ( ) ; <comment> <ect>
throw new solr <identifiersep> indexer <identifiersep> exception ( <string_literal> + space <identifiersep> reference + <string_literal> , e ) ; } for ( string document <identifiersep> name : document <identifiersep> names ) { entity <identifiersep> reference document <identifiersep> reference = new entity <identifiersep> reference ( document <identifiersep> name , entity <identifiersep> type . document , space <identifiersep> reference ) ; try { iterables . add <identifiersep> all ( result , this . document <identifiersep> resolver <identifiersep> provider . get ( ) . get <identifiersep> references ( document <identifiersep> reference ) ) ; } catch ( exception e ) { <LOG> } } return result ; } @ override public string get <identifiersep> query ( entity <identifiersep> reference reference ) throws solr <identifiersep> indexer <identifiersep> exception { string <identifiersep> builder builder = new string <identifiersep> builder ( ) ; entity <identifiersep> reference wiki <identifiersep> reference = reference . extract <identifiersep> reference ( entity <identifiersep> type . wiki ) ; <ect>
for ( string local <identifiersep> space <identifiersep> ref : local <identifiersep> space <identifiersep> refs ) { entity <identifiersep> reference space <identifiersep> reference = this . explicit <identifiersep> entity <identifiersep> reference <identifiersep> resolver . resolve ( local <identifiersep> space <identifiersep> ref , entity <identifiersep> type . space , wiki <identifiersep> reference ) ; try { iterables . add <identifiersep> all ( result , this . space <identifiersep> resolver <identifiersep> provider . get ( ) . get <identifiersep> references ( space <identifiersep> reference ) ) ; } catch ( exception e ) { <LOG> } } return result ; } @ override public string get <identifiersep> query ( entity <identifiersep> reference reference ) { return field <identifiersep> utils . wiki + ' : ' + client <identifiersep> utils . escape <identifiersep> query <identifiersep> chars ( reference . get <identifiersep> name ( ) ) ; } } <ect>
for ( base <identifiersep> object object : objects ) { if ( object != null ) { base <identifiersep> object <identifiersep> reference object <identifiersep> reference = object . get <identifiersep> reference ( ) ; try { iterables . add <identifiersep> all ( result , this . object <identifiersep> resolver <identifiersep> provider . get ( ) . get <identifiersep> references ( object <identifiersep> reference ) ) ; } catch ( exception e ) { <LOG> } } } } } @ override public string get <identifiersep> id ( entity <identifiersep> reference reference ) throws solr <identifiersep> indexer <identifiersep> exception { document <identifiersep> reference document <identifiersep> reference = new document <identifiersep> reference ( reference ) ; string result = super . get <identifiersep> id ( reference ) ; <comment> <ect>
output <identifiersep> stream os = response . get <identifiersep> output <identifiersep> stream ( ) ; file <identifiersep> utils . copy <identifiersep> file ( result , os ) ; os . flush ( ) ; } private boolean rasterize <identifiersep> to <identifiersep> file ( string content , file out , int width , int height ) throws io <identifiersep> exception { if ( ! out . get <identifiersep> parent <identifiersep> file ( ) . exists ( ) && ! out . get <identifiersep> parent <identifiersep> file ( ) . mkdirs ( ) ) { <LOG> return false ; } else if ( out . exists ( ) && out . is <identifiersep> file ( ) ) { this . logger . debug ( <string_literal> , out . get <identifiersep> absolute <identifiersep> path ( ) ) ; return true ; } else { try ( output <identifiersep> stream fout = new file <identifiersep> output <identifiersep> stream ( out ) ) { <ect>
return false ; } else if ( out . exists ( ) && out . is <identifiersep> file ( ) ) { this . logger . debug ( <string_literal> , out . get <identifiersep> absolute <identifiersep> path ( ) ) ; return true ; } else { try ( output <identifiersep> stream fout = new file <identifiersep> output <identifiersep> stream ( out ) ) { <LOG> transcoder <identifiersep> input input = new transcoder <identifiersep> input ( new string <identifiersep> reader ( content ) ) ; transcoder <identifiersep> output output = new transcoder <identifiersep> output ( fout ) ; boolean success = rasterize ( input , output , width , height ) ; if ( ! success ) { out . delete ( ) ; } return success ; <ect>
public boolean rasterize <identifiersep> to <identifiersep> response ( string content , int width , int height ) { try { this . component . rasterize <identifiersep> to <identifiersep> response ( content , width , height ) ; return true ; } catch ( exception ex ) { <LOG> } return false ; } } <ect>
if ( <string_literal> . equals ( this . xwikicfg . get <identifiersep> property ( <string_literal> , <string_literal> ) ) ) { try { xdom title = extract <identifiersep> title <identifiersep> from <identifiersep> content ( document , parameters ) ; if ( title != null ) { return title ; } } catch ( exception e ) { <LOG> e ) ; } } <comment> <ect>
<comment> <LOG> } catch ( exception e ) { <comment> <ect>
displayer = this . content <identifiersep> displayer ; string content <identifiersep> hint = <string_literal> + syntax <identifiersep> id ; if ( this . component <identifiersep> manager . has <identifiersep> component ( document <identifiersep> displayer . class , content <identifiersep> hint ) ) { try { displayer = this . component <identifiersep> manager . get <identifiersep> instance ( document <identifiersep> displayer . class , content <identifiersep> hint ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } } return displayer . display ( document , parameters ) ; } } <ect>
{ document <identifiersep> model <identifiersep> bridge class <identifiersep> document ; try { class <identifiersep> document = document <identifiersep> access <identifiersep> bridge . get <identifiersep> translated <identifiersep> document <identifiersep> instance ( class <identifiersep> reference ) ; } catch ( exception e ) { string class <identifiersep> string <identifiersep> reference = default <identifiersep> entity <identifiersep> reference <identifiersep> serializer . serialize ( class <identifiersep> reference ) ; <LOG> return collections . empty <identifiersep> list ( ) ; } list < document <identifiersep> reference > sheet <identifiersep> references = new array <identifiersep> list < document <identifiersep> reference > ( ) ; for ( document <identifiersep> reference sheet <identifiersep> reference : class <identifiersep> sheet <identifiersep> binder . get <identifiersep> sheets ( class <identifiersep> document ) ) { if ( match <identifiersep> sheet ( sheet <identifiersep> reference , action ) ) { sheet <identifiersep> references . add ( sheet <identifiersep> reference ) ; } } return sheet <identifiersep> references ; <ect>
this . servlet <identifiersep> provider . reload ( ) ; <comment> <LOG> } } private void flush ( ) { execution <identifiersep> context context = this . execution . get <identifiersep> context ( ) ; if ( context != null && context . has <identifiersep> property ( restart ) ) { restart <identifiersep> now ( ) ; } } } <ect>
application . set <identifiersep> context ( application <identifiersep> context ) ; <comment> <LOG> } return application ; } @ override public void destroy ( ) { super . destroy ( ) ; <comment> <ect>
if ( is != null ) { try { log <identifiersep> manager . get <identifiersep> log <identifiersep> manager ( ) . read <identifiersep> configuration ( is ) ; } finally { io <identifiersep> utils . close <identifiersep> quietly ( is ) ; } } } catch ( exception e ) { <LOG> } } <comment> <ect>
try { path = url <identifiersep> decoder . decode ( path , <string_literal> ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> } return path ; } <comment> protected boolean is <identifiersep> zip <identifiersep> file ( input <identifiersep> stream filecontent ) <ect>
base <identifiersep> property tag <identifiersep> property ; try { base <identifiersep> class tag <identifiersep> class = context . get <identifiersep> wiki ( ) . get <identifiersep> class ( tag <identifiersep> class , context ) ; property <identifiersep> class tag <identifiersep> property <identifiersep> definition = ( property <identifiersep> class ) tag <identifiersep> class . get <identifiersep> field ( tag <identifiersep> property ) ; tag <identifiersep> property = tag <identifiersep> property <identifiersep> definition . new <identifiersep> property ( ) ; } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { <LOG> tag <identifiersep> property = new db <identifiersep> string <identifiersep> list <identifiersep> property ( ) ; } tag <identifiersep> property . set <identifiersep> name ( tag <identifiersep> property ) ; tag <identifiersep> property . set <identifiersep> object ( tag <identifiersep> object ) ; tag <identifiersep> object . safeput ( tag <identifiersep> property , tag <identifiersep> property ) ; return tag <identifiersep> property ; } <comment> <ect>
this . channels . remove ( channel <identifiersep> id ) ; <comment> <LOG> } this . logger . info ( <string_literal> , channel <identifiersep> id ) ; } <comment> <ect>
input <identifiersep> stream is = null ; try { environment environment = this . component <identifiersep> manager . get <identifiersep> instance ( environment . class ) ; is = environment . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( path ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <LOG> } if ( is == null ) { <comment> <ect>
public remote <identifiersep> observation <identifiersep> manager get <identifiersep> remote <identifiersep> observation <identifiersep> manager ( ) { if ( this . remote <identifiersep> observation <identifiersep> manager == null ) { try { this . remote <identifiersep> observation <identifiersep> manager = this . component <identifiersep> manager . get <identifiersep> instance ( remote <identifiersep> observation <identifiersep> manager . class ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } return this . remote <identifiersep> observation <identifiersep> manager ; } @ override public void receive ( message msg ) { remote <identifiersep> event <identifiersep> data remote <identifiersep> event = ( remote <identifiersep> event <identifiersep> data ) msg . get <identifiersep> object ( ) ; this . logger . debug ( <string_literal> , remote <identifiersep> event ) ; <ect>
+ this . configuration . get <identifiersep> network <identifiersep> adapter ( ) + <string_literal> , e ) ; } <comment> <LOG> } } } @ override public void notify ( local <identifiersep> event <identifiersep> data local <identifiersep> event ) { if ( this . remote <identifiersep> event <identifiersep> manager <identifiersep> context . is <identifiersep> remote <identifiersep> state ( ) ) { <comment> <ect>
{ if ( this . execution . get <identifiersep> context ( ) == null ) { execution <identifiersep> context context = new execution <identifiersep> context ( ) ; try { this . execution <identifiersep> context <identifiersep> manager . initialize ( context ) ; } catch ( exception e ) { <LOG> } } } } <ect>
hibernate <identifiersep> store . begin <identifiersep> transaction ( context ) ; session session = hibernate <identifiersep> store . get <identifiersep> session ( context ) ; session . update ( event ) ; hibernate <identifiersep> store . end <identifiersep> transaction ( context , true ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { hibernate <identifiersep> store . end <identifiersep> transaction ( context , false ) ; <LOG> } } } <ect>
<comment> public list < object [ ] > search <identifiersep> unique <identifiersep> pages ( string optional <identifiersep> where <identifiersep> clause , int max <identifiersep> items , int start <identifiersep> at ) { try { return get <identifiersep> activity <identifiersep> stream ( ) . search <identifiersep> unique <identifiersep> pages ( optional <identifiersep> where <identifiersep> clause , max <identifiersep> items , start <identifiersep> at , this . context ) ; } catch ( activity <identifiersep> stream <identifiersep> exception ex ) { <LOG> return collections . empty <identifiersep> list ( ) ; } } <comment> <ect>
<comment> public list < object [ ] > search <identifiersep> daily <identifiersep> pages ( string optional <identifiersep> where <identifiersep> clause , int max <identifiersep> items , int start <identifiersep> at ) { try { return get <identifiersep> activity <identifiersep> stream ( ) . search <identifiersep> daily <identifiersep> pages ( optional <identifiersep> where <identifiersep> clause , max <identifiersep> items , start <identifiersep> at , this . context ) ; } catch ( activity <identifiersep> stream <identifiersep> exception ex ) { <LOG> return collections . empty <identifiersep> list ( ) ; } } <comment> <ect>
doc . set <identifiersep> content ( <string_literal> ) ; doc . set <identifiersep> syntax ( syntax . xwiki <identifiersep> <number_literal> <identifiersep> 0 ) ; } if ( needs <identifiersep> update ) { context . get <identifiersep> wiki ( ) . save <identifiersep> document ( doc , <string_literal> , true , context ) ; ( ( scheduler <identifiersep> plugin ) context . get <identifiersep> wiki ( ) . get <identifiersep> plugin ( <string_literal> , context ) ) . schedule <identifiersep> job ( job , context ) ; } } catch ( exception e ) { <LOG> } } <comment> <ect>
mail <identifiersep> status <identifiersep> result . increment <identifiersep> current <identifiersep> size ( ) ; } @ override public void on <identifiersep> prepare <identifiersep> fatal <identifiersep> error ( exception exception , map < string , object > parameters ) { super . on <identifiersep> prepare <identifiersep> fatal <identifiersep> error ( exception , parameters ) ; <comment> <LOG> } @ override public void on <identifiersep> send <identifiersep> message <identifiersep> success ( extended <identifiersep> mime <identifiersep> message message , map < string , object > parameters ) { super . on <identifiersep> send <identifiersep> message <identifiersep> success ( message , parameters ) ; string unique <identifiersep> message <identifiersep> id = message . get <identifiersep> unique <identifiersep> message <identifiersep> id ( ) ; mail <identifiersep> status status = retrieve <identifiersep> existing <identifiersep> mail <identifiersep> status ( unique <identifiersep> message <identifiersep> id , mail <identifiersep> state . send <identifiersep> success ) ; <ect>
private void delete <identifiersep> status ( mail <identifiersep> status status , map < string , object > parameters ) { try { mail <identifiersep> status <identifiersep> store . delete ( status . get <identifiersep> message <identifiersep> id ( ) , parameters ) ; } catch ( mail <identifiersep> store <identifiersep> exception e ) { <comment> <LOG> } } private void delete <identifiersep> mail <identifiersep> content ( mail <identifiersep> status current <identifiersep> status ) { if ( current <identifiersep> status != null ) { try { mail <identifiersep> content <identifiersep> store . delete ( current <identifiersep> status . get <identifiersep> batch <identifiersep> id ( ) , current <identifiersep> status . get <identifiersep> message <identifiersep> id ( ) ) ; } catch ( mail <identifiersep> store <identifiersep> exception e ) { <ect>
if ( this . batch <identifiersep> id == null ) { return collections . empty <identifiersep> iterator ( ) ; } try { return this . mail <identifiersep> status <identifiersep> store . load ( collections . < string , object > singleton <identifiersep> map ( batchid <identifiersep> key , this . batch <identifiersep> id ) , 0 , 0 , date <identifiersep> field , true ) . iterator ( ) ; } catch ( mail <identifiersep> store <identifiersep> exception e ) { <LOG> return collections . empty <identifiersep> iterator ( ) ; } } @ override public iterator < mail <identifiersep> status > get <identifiersep> all <identifiersep> errors ( ) { return get <identifiersep> filtered <identifiersep> state ( <string_literal> ) ; } @ override <ect>
public object do <identifiersep> in <identifiersep> hibernate ( session session ) throws hibernate <identifiersep> exception , x <identifiersep> wiki <identifiersep> exception { session . save ( status ) ; return null ; } } ) ; <comment> <LOG> } catch ( exception e ) { throw new mail <identifiersep> store <identifiersep> exception ( string . format ( <string_literal> , status ) , e ) ; } finally { xwiki <identifiersep> context . set <identifiersep> wiki <identifiersep> id ( current <identifiersep> wiki ) ; } } @ override public mail <identifiersep> status load ( string unique <identifiersep> message <identifiersep> id ) throws mail <identifiersep> store <identifiersep> exception <ect>
iterator < map . entry < string , object > > entry <identifiersep> iterator = filter <identifiersep> map . entry <identifiersep> set ( ) . iterator ( ) ; while ( entry <identifiersep> iterator . has <identifiersep> next ( ) ) { map . entry < string , object > entry = entry <identifiersep> iterator . next ( ) ; add <identifiersep> entry <identifiersep> tolog ( builder , entry ) ; if ( entry <identifiersep> iterator . has <identifiersep> next ( ) ) { builder . append ( ' , ' ) . append ( ( ' ' ) ) ; } } <LOG> } } private void add <identifiersep> entry <identifiersep> tolog ( string <identifiersep> builder builder , map . entry < string , object > entry ) { add <identifiersep> value <identifiersep> tolog ( builder , entry . get <identifiersep> key ( ) ) ; builder . append ( <string_literal> ) ; add <identifiersep> value <identifiersep> tolog ( builder , entry . get <identifiersep> value ( ) ) ; } private void add <identifiersep> value <identifiersep> tolog ( string <identifiersep> builder builder , object value ) <ect>
logger . debug ( <string_literal> , message . get <identifiersep> unique <identifiersep> message <identifiersep> id ( ) , batch <identifiersep> id , exception ) ; } } @ override public void on <identifiersep> prepare <identifiersep> fatal <identifiersep> error ( exception exception , map < string , object > parameters ) { <LOG> } @ override public void on <identifiersep> prepare <identifiersep> end ( map < string , object > parameters ) { logger . debug ( <string_literal> , batch <identifiersep> id ) ; } @ override public void on <identifiersep> send <identifiersep> message <identifiersep> success ( extended <identifiersep> mime <identifiersep> message message , map < string , object > parameters ) <ect>
logger . debug ( <string_literal> , message . get <identifiersep> unique <identifiersep> message <identifiersep> id ( ) , batch <identifiersep> id , exception ) ; } } @ override public void on <identifiersep> send <identifiersep> message <identifiersep> fatal <identifiersep> error ( string unique <identifiersep> message <identifiersep> id , exception exception , map < string , object > parameters ) { <LOG> } } <ect>
} finally { this . prepare <identifiersep> mail <identifiersep> queue <identifiersep> manager . remove <identifiersep> message <identifiersep> from <identifiersep> queue ( mail <identifiersep> item ) ; } } <comment> <LOG> break ; } catch ( exception e ) { <comment> <ect>
<comment> public xml <identifiersep> script <identifiersep> service ( ) { try { this . ls <identifiersep> impl = ( dom <identifiersep> implementation <identifiersep> ls ) dom <identifiersep> implementation <identifiersep> registry . new <identifiersep> instance ( ) . get <identifiersep> dom <identifiersep> implementation ( <string_literal> ) ; } catch ( exception ex ) { <LOG> } } <comment> <ect>
context <identifiersep> component <identifiersep> manager <identifiersep> provider . get ( ) . get <identifiersep> instance <identifiersep> list ( ui <identifiersep> extension . class ) ; for ( string panel <identifiersep> serialized <identifiersep> reference : panel <identifiersep> serialized <identifiersep> references ) { for ( ui <identifiersep> extension extension : all <identifiersep> extensions ) { if ( extension . get <identifiersep> id ( ) . equals ( panel <identifiersep> serialized <identifiersep> reference ) ) { panels . add ( extension ) ; } } } } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } return panels ; } } <ect>
<comment> <LOG> } } else { <comment> <ect>
return null ; } list < version > version <identifiersep> list = new array <identifiersep> list < version > ( versions . get <identifiersep> size ( ) ) ; for ( version version : versions ) { version <identifiersep> list . add ( version ) ; } return find <identifiersep> valid <identifiersep> version ( flavor <identifiersep> id , namespace , version <identifiersep> list ) ; } catch ( resolve <identifiersep> exception e ) { <LOG> } return null ; } private extension find <identifiersep> valid <identifiersep> version ( string flavor <identifiersep> id , string namespace , list < version > version <identifiersep> list ) { this . progress <identifiersep> manager . push <identifiersep> level <identifiersep> progress ( version <identifiersep> list . size ( ) , flavor <identifiersep> id ) ; try { for ( list <identifiersep> iterator < version > it = version <identifiersep> list . list <identifiersep> iterator ( version <identifiersep> list . size ( ) ) ; it . has <identifiersep> previous ( ) ; ) { <ect>
xwiki <identifiersep> pref = new document <identifiersep> reference ( global <identifiersep> preferences , main <identifiersep> wiki ) ; email <identifiersep> class <identifiersep> reference = new document <identifiersep> reference ( email <identifiersep> preferences <identifiersep> class , main <identifiersep> wiki ) ; diff <identifiersep> type = document <identifiersep> access <identifiersep> bridge . get <identifiersep> property ( xwiki <identifiersep> pref , email <identifiersep> class <identifiersep> reference , diff <identifiersep> type ) ; if ( diff <identifiersep> type != null && string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( ( string ) diff <identifiersep> type ) ) { return notification <identifiersep> email <identifiersep> diff <identifiersep> type . value <identifiersep> of ( ( string ) diff <identifiersep> type ) ; } } } catch ( exception e ) { <LOG> } <comment> <ect>
document <identifiersep> reference user <identifiersep> reference = resolver . resolve ( result ) ; x <identifiersep> wiki <identifiersep> document user <identifiersep> document = xwiki . get <identifiersep> document ( user <identifiersep> reference , context ) ; logger . debug ( <string_literal> , result ) ; try { migrate <identifiersep> document ( user <identifiersep> document ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } <comment> <ect>
boolean register = should <identifiersep> register ( event , current <identifiersep> doc , user <identifiersep> reference ) ; if ( register ) { try { watched <identifiersep> entities <identifiersep> manager . watch <identifiersep> entity ( factory . create <identifiersep> watched <identifiersep> location <identifiersep> reference ( current <identifiersep> doc . get <identifiersep> document <identifiersep> reference ( ) ) , user <identifiersep> reference ) ; } catch ( notification <identifiersep> exception e ) { <LOG> user <identifiersep> reference , e ) ; } } } private boolean should <identifiersep> register ( event event , x <identifiersep> wiki <identifiersep> document current <identifiersep> doc , document <identifiersep> reference user <identifiersep> reference ) { switch ( configuration . get <identifiersep> automatic <identifiersep> watch <identifiersep> mode ( user <identifiersep> reference ) ) { case none : return false ; <ect>
if ( obj == null ) { continue ; } found | = remove <identifiersep> value <identifiersep> from <identifiersep> object ( filter <identifiersep> preference <identifiersep> name , type , field <identifiersep> name , obj ) ; } if ( found ) { xwiki . save <identifiersep> document ( document , <string_literal> , context ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } private boolean remove <identifiersep> value <identifiersep> from <identifiersep> object ( string filter <identifiersep> preference <identifiersep> name , string type , string field <identifiersep> name , base <identifiersep> object obj ) { boolean found = false ; list < string > values = obj . get <identifiersep> list <identifiersep> value ( field <identifiersep> name ) ; if ( values != null && ! values . is <identifiersep> empty ( ) ) { iterator < string > iterator = values . iterator ( ) ; <ect>
&& ( match <identifiersep> all <identifiersep> events ( pref ) || match <identifiersep> event <identifiersep> type ( pref , event <identifiersep> type ) ) ) ; iterator < notification <identifiersep> filter <identifiersep> preference > iterator = filter <identifiersep> preference <identifiersep> stream . iterator ( ) ; while ( iterator . has <identifiersep> next ( ) ) { results . add ( new scope <identifiersep> notification <identifiersep> filter <identifiersep> preference ( iterator . next ( ) , entity <identifiersep> reference <identifiersep> resolver ) ) ; } } catch ( notification <identifiersep> exception e ) { <LOG> } return new scope <identifiersep> notification <identifiersep> filter <identifiersep> preferences <identifiersep> hierarchy ( results ) ; } private boolean match <identifiersep> filter ( notification <identifiersep> filter <identifiersep> preference pref ) { return pref . is <identifiersep> enabled ( ) && scope <identifiersep> notification <identifiersep> filter . filter <identifiersep> name . equals ( pref . get <identifiersep> filter <identifiersep> name ( ) ) ; } private boolean match <identifiersep> format ( notification <identifiersep> filter <identifiersep> preference filter <identifiersep> preference , notification <identifiersep> format format ) { <ect>
try { for ( notification <identifiersep> filter <identifiersep> preference <identifiersep> provider provider : component <identifiersep> manager . < notification <identifiersep> filter <identifiersep> preference <identifiersep> provider > get <identifiersep> instance <identifiersep> list ( notification <identifiersep> filter <identifiersep> preference <identifiersep> provider . class ) ) { provider . set <identifiersep> filter <identifiersep> preference <identifiersep> enabled ( filter <identifiersep> preference <identifiersep> name , enabled ) ; } } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } <comment> <ect>
handle <identifiersep> events ( ) ; handle <identifiersep> wiki <identifiersep> logo ( ) ; handle <identifiersep> image <identifiersep> attachments <identifiersep> from <identifiersep> template ( ) ; try { factory <identifiersep> parameters . put ( from , new internet <identifiersep> address ( mail <identifiersep> sender <identifiersep> configuration . get <identifiersep> from <identifiersep> address ( ) ) ) ; } catch ( address <identifiersep> exception | null <identifiersep> pointer <identifiersep> exception e ) { <LOG> } factory <identifiersep> parameters . put ( to , this . current <identifiersep> user <identifiersep> email ) ; } private void handle <identifiersep> image <identifiersep> attachments <identifiersep> from <identifiersep> template ( ) throws notification <identifiersep> exception { collection < attachment > attachments = get <identifiersep> attachments ( ) ; try { attachments . add <identifiersep> all ( mail <identifiersep> template <identifiersep> image <identifiersep> attachments <identifiersep> extractor . get <identifiersep> images ( template <identifiersep> reference ) ) ; <ect>
user <identifiersep> avatars . add <identifiersep> all ( event . get <identifiersep> users ( ) ) ; } collection < attachment > attachments = get <identifiersep> attachments ( ) ; for ( document <identifiersep> reference user <identifiersep> avatar : user <identifiersep> avatars ) { try { attachments . add ( user <identifiersep> avatar <identifiersep> attachment <identifiersep> extractor . get <identifiersep> user <identifiersep> avatar ( user <identifiersep> avatar , <number_literal> ) ) ; } catch ( exception e ) { <LOG> } } } private map < string , object > get <identifiersep> velocity <identifiersep> variables ( ) { object velocity <identifiersep> variables = factory <identifiersep> parameters . get ( velocity <identifiersep> variables ) ; if ( velocity <identifiersep> variables == null ) { velocity <identifiersep> variables = new hash <identifiersep> map < string , object > ( ) ; factory <identifiersep> parameters . put ( velocity <identifiersep> variables , velocity <identifiersep> variables ) ; <ect>
new wiki <identifiersep> reference ( wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> current <identifiersep> wiki <identifiersep> id ( ) ) ) ; object user <identifiersep> interval = document <identifiersep> access <identifiersep> bridge . get <identifiersep> property ( user , class <identifiersep> reference , <string_literal> ) ; if ( is <identifiersep> default <identifiersep> interval ( user <identifiersep> interval ) || is <identifiersep> same <identifiersep> interval ( user <identifiersep> interval ) ) { next <identifiersep> user = user ; } } } } catch ( exception e ) { <LOG> } } private void do <identifiersep> query ( ) throws query <identifiersep> exception { query query = query <identifiersep> manager . create <identifiersep> query ( xwql <identifiersep> query , query . xwql ) ; query . set <identifiersep> limit ( batch <identifiersep> size ) ; query . set <identifiersep> offset ( offset ) ; users . add <identifiersep> all ( query . execute ( ) ) ; <ect>
this . was <identifiersep> started = false ; if ( verify <identifiersep> running <identifiersep> xwiki <identifiersep> at <identifiersep> start . equals ( <string_literal> ) ) { logger . info ( <string_literal> , get <identifiersep> url ( ) ) ; <comment> <LOG> stop <identifiersep> internal ( ) ; logger . info ( <string_literal> , get <identifiersep> url ( ) , get <identifiersep> stop <identifiersep> port ( ) , get <identifiersep> rmi <identifiersep> port ( ) ) ; start <identifiersep> x <identifiersep> wiki ( ) ; wait <identifiersep> for <identifiersep> x <identifiersep> wiki <identifiersep> to <identifiersep> load ( ) ; this . managed = true ; <ect>
logger . info ( <string_literal> , get <identifiersep> url ( ) , get <identifiersep> stop <identifiersep> port ( ) , get <identifiersep> rmi <identifiersep> port ( ) ) ; start <identifiersep> x <identifiersep> wiki ( ) ; wait <identifiersep> for <identifiersep> x <identifiersep> wiki <identifiersep> to <identifiersep> load ( ) ; this . managed = true ; } else { <LOG> } } private default <identifiersep> execute <identifiersep> result <identifiersep> handler execute <identifiersep> command ( string command <identifiersep> line ) throws exception { <comment> <ect>
fis = new file <identifiersep> input <identifiersep> stream ( path ) ; try { properties . load ( fis ) ; } finally { fis . close ( ) ; } } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> } return properties ; } <comment> private properties <identifiersep> configuration get <identifiersep> properties <identifiersep> configuration ( string path ) throws configuration <identifiersep> exception { <ect>
{ x <identifiersep> wiki <identifiersep> context context = this . xwiki <identifiersep> context <identifiersep> provider . get ( ) ; <comment> <LOG> return ; } if ( event instanceof script <identifiersep> evaluating <identifiersep> event ) { <comment> <ect>
if ( ! log <identifiersep> printed ) { this . logger . debug ( <string_literal> , current <identifiersep> doc <identifiersep> reference ) ; } context . drop <identifiersep> permissions ( ) ; } else { <comment> <LOG> if ( original <identifiersep> value != null ) { context . put ( x <identifiersep> wiki <identifiersep> constant . dropped <identifiersep> permissions , original <identifiersep> value ) ; } else { context . remove ( x <identifiersep> wiki <identifiersep> constant . dropped <identifiersep> permissions ) ; } context . remove ( prcheck <identifiersep> key ) ; } } } <ect>
protected void starting ( description description ) { logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; } @ override protected void succeeded ( description description ) { <LOG> } @ override protected void failed ( throwable e , description description ) { logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; take <identifiersep> screenshot ( description ) ; logger . info ( <string_literal> , driver . get <identifiersep> current <identifiersep> url ( ) ) ; <ect>
logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; } @ override protected void failed ( throwable e , description description ) { logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; take <identifiersep> screenshot ( description ) ; <LOG> logger . info ( <string_literal> , driver . get <identifiersep> page <identifiersep> source ( ) ) ; } <comment> private string get <identifiersep> test <identifiersep> name ( description description ) <ect>
<comment> public void take <identifiersep> screenshot ( string test <identifiersep> name ) { if ( ! ( driver instanceof takes <identifiersep> screenshot ) ) { <LOG> return ; } try { file source <identifiersep> file = ( ( takes <identifiersep> screenshot ) driver ) . get <identifiersep> screenshot <identifiersep> as ( output <identifiersep> type . file ) ; file screenshot <identifiersep> file ; if ( screenshot <identifiersep> dir != null ) { file screenshot <identifiersep> dir = new file ( screenshot <identifiersep> dir ) ; <ect>
screenshot <identifiersep> file = new file ( screenshot <identifiersep> dir , test <identifiersep> name + <string_literal> ) ; } else { screenshot <identifiersep> file = new file ( new file ( system . get <identifiersep> property ( <string_literal> ) ) , test <identifiersep> name + <string_literal> ) ; } file <identifiersep> utils . copy <identifiersep> file ( source <identifiersep> file , screenshot <identifiersep> file ) ; logger . info ( <string_literal> , test <identifiersep> name , screenshot <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } catch ( exception e ) { <LOG> } } } <ect>
<comment> && ! login <identifiersep> action . equals ( context . get <identifiersep> action ( ) ) && ! context . get <identifiersep> wiki ( ) . param ( <string_literal> , <string_literal> ) . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) { context . get <identifiersep> wiki ( ) . get <identifiersep> auth <identifiersep> service ( ) . show <identifiersep> login ( context ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } <comment> private void authenticate <identifiersep> user ( x <identifiersep> wiki <identifiersep> context context ) <ect>
@ override public boolean check <identifiersep> access ( string action , x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { right right = action <identifiersep> to <identifiersep> right ( action ) ; entity <identifiersep> reference entity <identifiersep> reference = doc . get <identifiersep> document <identifiersep> reference ( ) ; <LOG> authenticate <identifiersep> user ( context ) ; if ( contextual <identifiersep> authorization <identifiersep> manager . has <identifiersep> access ( right , entity <identifiersep> reference ) ) { return true ; } <comment> <ect>
<comment> <LOG> } finally { read <identifiersep> write <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; } } <comment> <ect>
this . logger . debug ( <string_literal> , user , entity , access ) ; return access ; } if ( ! entry . is <identifiersep> empty ( ) ) { security <identifiersep> access <identifiersep> entry access <identifiersep> entry = security <identifiersep> cache . get ( user , ref ) ; if ( access <identifiersep> entry == null ) { security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; <LOG> return access ; } else { security <identifiersep> access access = access <identifiersep> entry . get <identifiersep> access ( ) ; logger . debug ( <string_literal> , user , entity , access ) ; return access ; } } } security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; <ect>
return access ; } else { security <identifiersep> access access = access <identifiersep> entry . get <identifiersep> access ( ) ; logger . debug ( <string_literal> , user , entity , access ) ; return access ; } } } security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; <LOG> return access ; } <comment> <ect>
private void dispose <identifiersep> children ( ) { if ( children != null ) { for ( security <identifiersep> cache <identifiersep> entry child : children ) { if ( ! child . disposed ) { <LOG> } <comment> <ect>
<comment> private void remove <identifiersep> child ( security <identifiersep> cache <identifiersep> entry entry ) { if ( this . children != null ) { this . children . remove ( entry ) ; <LOG> } } } <comment> public boolean is <identifiersep> user ( ) { return entry . get <identifiersep> reference ( ) instanceof user <identifiersep> security <identifiersep> reference && ! ( entry instanceof security <identifiersep> access <identifiersep> entry ) ; <ect>
string key = get <identifiersep> entry <identifiersep> key ( entry ) ; write <identifiersep> lock . lock ( ) ; try { if ( is <identifiersep> already <identifiersep> inserted ( key , entry ) ) { return ; } add <identifiersep> entry ( key , new security <identifiersep> cache <identifiersep> entry ( entry , wiki ) ) ; <LOG> } finally { new <identifiersep> entry = null ; write <identifiersep> lock . unlock ( ) ; } } <comment> <ect>
security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( user , entity ) ; if ( entry == null ) { logger . debug ( <string_literal> , get <identifiersep> entry <identifiersep> key ( user , entity ) ) ; } return null ; } <LOG> } return ( security <identifiersep> access <identifiersep> entry ) entry . get <identifiersep> entry ( ) ; } @ override public security <identifiersep> rule <identifiersep> entry get ( security <identifiersep> reference entity ) { security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( entity ) ; <ect>
return valid ; } private boolean is <identifiersep> version <identifiersep> valid ( x <identifiersep> wiki <identifiersep> document document , base <identifiersep> object extension <identifiersep> version <identifiersep> object , x <identifiersep> wiki <identifiersep> context context ) { <comment> <LOG> x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extensionversion <identifiersep> classreference , extension <identifiersep> version <identifiersep> object . get <identifiersep> number ( ) ) ; return false ; } boolean valid ; resource <identifiersep> reference resource <identifiersep> reference = null ; try { resource <identifiersep> reference = get <identifiersep> download <identifiersep> reference ( document , extension <identifiersep> version ) ; <ect>
x <identifiersep> wiki <identifiersep> document attachment <identifiersep> document ; try { attachment <identifiersep> document = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( attachment <identifiersep> reference . get <identifiersep> document <identifiersep> reference ( ) , context ) ; valid = attachment <identifiersep> document . get <identifiersep> attachment ( attachment <identifiersep> reference . get <identifiersep> name ( ) ) != null ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> valid = false ; } if ( ! valid ) { this . logger . debug ( <string_literal> , attachment <identifiersep> reference ) ; } } else if ( resource <identifiersep> type . url . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) || extension <identifiersep> resource <identifiersep> reference . type . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) ) { valid = true ; <ect>
this . logger . debug ( <string_literal> , attachment <identifiersep> reference ) ; } } else if ( resource <identifiersep> type . url . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) || extension <identifiersep> resource <identifiersep> reference . type . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) ) { valid = true ; } else { valid = false ; <LOG> } } else { valid = false ; this . logger . debug ( <string_literal> , x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extensionversion <identifiersep> classreference , extension <identifiersep> version <identifiersep> object . get <identifiersep> number ( ) ) ; } return valid ; } public void validate <identifiersep> extensions ( ) throws query <identifiersep> exception , x <identifiersep> wiki <identifiersep> exception <ect>
document <identifiersep> reference document <identifiersep> reference = this . current <identifiersep> string <identifiersep> resolver . resolve ( document <identifiersep> name , wiki <identifiersep> reference ) ; string user <identifiersep> display <identifiersep> name = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> plain <identifiersep> user <identifiersep> name ( document <identifiersep> reference , xcontext ) ; if ( user <identifiersep> display <identifiersep> name . equals ( author <identifiersep> name ) ) { return document <identifiersep> name ; } } } } catch ( query <identifiersep> exception e ) { <LOG> } return null ; } private boolean update <identifiersep> extension <identifiersep> version <identifiersep> dependencies ( x <identifiersep> wiki <identifiersep> document document , extension extension ) throws x <identifiersep> wiki <identifiersep> exception { boolean need <identifiersep> save = false ; list < extension <identifiersep> dependency > dependencies = new array <identifiersep> list < > ( extension . get <identifiersep> dependencies ( ) ) ; <ect>
private velocity <identifiersep> manager get <identifiersep> velocity <identifiersep> manager ( ) { if ( this . velocity <identifiersep> manager == null ) { try { this . velocity <identifiersep> manager = this . component <identifiersep> manager . get <identifiersep> instance ( velocity <identifiersep> manager . class ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } return this . velocity <identifiersep> manager ; } @ override public void push ( transformation transformation , xdom xdom , syntax syntax , string id , boolean restricted , syntax target <identifiersep> syntax ) { super . push ( transformation , xdom , syntax , id , restricted , target <identifiersep> syntax ) ; <ect>
namespace , e . get <identifiersep> message ( ) ) ; } } } private void close <identifiersep> namespace ( string namespace ) { if ( get <identifiersep> velocity <identifiersep> manager ( ) != null ) { try { get <identifiersep> velocity <identifiersep> manager ( ) . get <identifiersep> velocity <identifiersep> engine ( ) . stopped <identifiersep> using <identifiersep> macro <identifiersep> namespace ( namespace ) ; <LOG> } catch ( exception e ) { <comment> <ect>
{ boolean result = true ; if ( this . wiki <identifiersep> macro <identifiersep> manager . has <identifiersep> wiki <identifiersep> macro ( document <identifiersep> reference ) ) { try { this . wiki <identifiersep> macro <identifiersep> manager . unregister <identifiersep> wiki <identifiersep> macro ( document <identifiersep> reference ) ; } catch ( wiki <identifiersep> macro <identifiersep> exception e ) { <LOG> result = false ; } } return result ; } } <ect>
} catch ( exception e ) { this . logger . error ( <string_literal> , e ) ; } } else if ( event instanceof wiki <identifiersep> ready <identifiersep> event ) { try { initializer . register <identifiersep> existing <identifiersep> wiki <identifiersep> macros ( ( ( wiki <identifiersep> ready <identifiersep> event ) event ) . get <identifiersep> wiki <identifiersep> id ( ) ) ; } catch ( exception e ) { <LOG> } } } } <ect>
x <identifiersep> wiki <identifiersep> context xcontext = ( x <identifiersep> wiki <identifiersep> context ) execution . get <identifiersep> context ( ) . get <identifiersep> property ( <string_literal> ) ; xcontext . remove ( <string_literal> ) ; <comment> <LOG> } } } <ect>
<comment> private void register <identifiersep> macros <identifiersep> for <identifiersep> wiki ( string wiki <identifiersep> name , x <identifiersep> wiki <identifiersep> context xcontext ) { try { <LOG> <comment> <ect>
<comment> private void register <identifiersep> macro ( document <identifiersep> reference wiki <identifiersep> macro <identifiersep> document <identifiersep> reference , string wiki <identifiersep> macro <identifiersep> document <identifiersep> author , x <identifiersep> wiki <identifiersep> context xcontext ) { <LOG> document <identifiersep> reference original <identifiersep> author = xcontext . get <identifiersep> user <identifiersep> reference ( ) ; try { wiki <identifiersep> macro macro = this . wiki <identifiersep> macro <identifiersep> factory . create <identifiersep> wiki <identifiersep> macro ( wiki <identifiersep> macro <identifiersep> document <identifiersep> reference ) ; this . wiki <identifiersep> macro <identifiersep> manager . register <identifiersep> wiki <identifiersep> macro ( wiki <identifiersep> macro <identifiersep> document <identifiersep> reference , macro ) ; this . logger . debug ( <string_literal> , macro . get <identifiersep> descriptor ( ) . get <identifiersep> id ( ) . get <identifiersep> id ( ) , wiki <identifiersep> macro <identifiersep> document <identifiersep> reference ) ; <ect>
list < syntax > syntaxes = new array <identifiersep> list < syntax > ( ) ; try { for ( parser parser : this . component <identifiersep> manager <identifiersep> provider . get ( ) . < parser > get <identifiersep> instance <identifiersep> list ( parser . class ) ) { syntaxes . add ( parser . get <identifiersep> syntax ( ) ) ; } } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <LOG> } return syntaxes ; } <comment> public list < syntax > get <identifiersep> available <identifiersep> renderer <identifiersep> syntaxes ( ) { <ect>
filter <identifiersep> name = null ; } } velocity <identifiersep> macro <identifiersep> filter filter = null ; if ( filter <identifiersep> name != null ) { try { filter = get <identifiersep> component <identifiersep> manager ( ) . get <identifiersep> instance ( velocity <identifiersep> macro <identifiersep> filter . class , filter <identifiersep> name ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } return filter ; } } <ect>
if ( parameters . get <identifiersep> language ( ) != null ) { if ( this . component <identifiersep> manager . has <identifiersep> component ( highlight <identifiersep> parser . class , parameters . get <identifiersep> language ( ) ) ) { try { parser = this . component <identifiersep> manager . get <identifiersep> instance ( highlight <identifiersep> parser . class , parameters . get <identifiersep> language ( ) ) ; return parser . highlight ( parameters . get <identifiersep> language ( ) , new string <identifiersep> reader ( content ) ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> e ) ; } } } this . logger . debug ( <string_literal> , parameters . get <identifiersep> language ( ) ) ; parser = this . component <identifiersep> manager . get <identifiersep> instance ( highlight <identifiersep> parser . class , <string_literal> ) ; return parser . highlight ( parameters . get <identifiersep> language ( ) , new string <identifiersep> reader ( content ) ) ; <ect>
transformation <identifiersep> context . set <identifiersep> id ( role <identifiersep> hint ) ; ( ( mutable <identifiersep> rendering <identifiersep> context ) rendering <identifiersep> context ) . transform <identifiersep> in <identifiersep> context ( macro <identifiersep> transformation , transformation <identifiersep> context , transformed <identifiersep> xdom ) ; } catch ( transformation <identifiersep> exception e ) { logger . warn ( <string_literal> , role <identifiersep> hint ) ; } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { <LOG> } return new composite <identifiersep> block ( transformed <identifiersep> xdom . get <identifiersep> children ( ) ) ; } <comment> <ect>
this . evaluated <identifiersep> parameters . put ( entry . get <identifiersep> key ( ) , writer . to <identifiersep> string ( ) ) ; } catch ( x <identifiersep> wiki <identifiersep> velocity <identifiersep> exception e ) { logger . warn ( string . format ( <string_literal> , entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) , e . get <identifiersep> message ( ) ) ) ; } } } catch ( x <identifiersep> wiki <identifiersep> velocity <identifiersep> exception ex ) { <LOG> } this . previous <identifiersep> context <identifiersep> id = current <identifiersep> context <identifiersep> id ; this . previous <identifiersep> wiki = current <identifiersep> wiki ; } } return this . evaluated <identifiersep> parameters ; } } <ect>
<comment> <LOG> } } } } } <ect>
if ( document . is <identifiersep> new ( ) ) { logger . warn ( <string_literal> , doc <identifiersep> reference ) ; return null ; } <comment> <LOG> return null ; } <comment> <ect>
try { observation <identifiersep> manager . notify ( new wiki <identifiersep> provisioning <identifiersep> event ( wiki <identifiersep> id ) , wiki <identifiersep> id , xcontext ) ; wiki <identifiersep> copier . copy <identifiersep> documents ( template <identifiersep> id , wiki <identifiersep> id , false ) ; observation <identifiersep> manager . notify ( new wiki <identifiersep> provisioned <identifiersep> event ( wiki <identifiersep> id ) , wiki <identifiersep> id , xcontext ) ; observation <identifiersep> manager . notify ( new wiki <identifiersep> copied <identifiersep> event ( template <identifiersep> id , wiki <identifiersep> id ) , template <identifiersep> id , xcontext ) ; } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { <LOG> observation <identifiersep> manager . notify ( new wiki <identifiersep> provisioning <identifiersep> failed <identifiersep> event ( wiki <identifiersep> id ) , wiki <identifiersep> id , xcontext ) ; } } @ override public string get <identifiersep> type ( ) { return jobtype ; } } <ect>
authorization <identifiersep> manager . check <identifiersep> access ( right . admin , context . get <identifiersep> user <identifiersep> reference ( ) , wiki <identifiersep> reference ) ; } <comment> <LOG> return false ; } catch ( access <identifiersep> denied <identifiersep> exception e ) { error ( string . format ( <string_literal> + <string_literal> , context . get <identifiersep> user <identifiersep> reference ( ) , wiki <identifiersep> id ) , e ) ; return false ; <ect>
<comment> public boolean is <identifiersep> template ( string wiki <identifiersep> id ) { try { return wiki <identifiersep> template <identifiersep> manager . is <identifiersep> template ( wiki <identifiersep> id ) ; } catch ( wiki <identifiersep> template <identifiersep> manager <identifiersep> exception e ) { <LOG> return null ; } } <comment> <ect>
wiki <identifiersep> template <identifiersep> manager . create <identifiersep> wiki <identifiersep> from <identifiersep> template ( new <identifiersep> wiki <identifiersep> id , new <identifiersep> wiki <identifiersep> alias , template <identifiersep> id , owner <identifiersep> id , fail <identifiersep> on <identifiersep> exist ) ; return true ; } catch ( wiki <identifiersep> template <identifiersep> manager <identifiersep> exception e ) { error ( <string_literal> , e ) ; } catch ( access <identifiersep> denied <identifiersep> exception e ) { <LOG> } return false ; } <comment> <ect>
throw new authorization <identifiersep> exception ( <string_literal> ) ; } <comment> <LOG> } return false ; } <comment> <ect>
return true ; } <comment> <LOG> } return false ; } <comment> <ect>
for ( string key : properties ) { <comment> <LOG> } } return keys ; } @ override public < t > t get <identifiersep> property ( string key , t default <identifiersep> value ) { t result = get <identifiersep> property <identifiersep> value ( key , default <identifiersep> value != null ? ( class < t > ) default <identifiersep> value . get <identifiersep> class ( ) : null ) ; <comment> <ect>
{ <comment> <LOG> } } @ override public translation get <identifiersep> translation ( string key , locale locale ) { x <identifiersep> wiki <identifiersep> context xcontext = this . context <identifiersep> provider . get ( ) ; <comment> <ect>
document <identifiersep> bundle = new x <identifiersep> wiki <identifiersep> preferences <identifiersep> document <identifiersep> translation <identifiersep> bundle ( idprefix , document , this . component <identifiersep> manager , this . translation <identifiersep> message <identifiersep> parser ) ; this . document <identifiersep> bundles <identifiersep> cache . set ( uid , document <identifiersep> bundle ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <LOG> } } return document <identifiersep> bundle ; } } <ect>
input <identifiersep> stream component <identifiersep> list <identifiersep> stream = url . open <identifiersep> stream ( ) ; try { properties . load ( component <identifiersep> list <identifiersep> stream ) ; } finally { component <identifiersep> list <identifiersep> stream . close ( ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } } return properties ; } } <ect>
{ <comment> <LOG> } <comment> <ect>
for ( translation <identifiersep> bundle bundle : this . bundle <identifiersep> context . get <identifiersep> bundles ( ) ) { try { translation translation = bundle . get <identifiersep> translation ( key , locale ) ; if ( translation != null && translation . get <identifiersep> locale ( ) . equals ( locale ) ) { return translation ; } } catch ( exception e ) { <LOG> } } <comment> <ect>
try ( input <identifiersep> stream component <identifiersep> list <identifiersep> stream = locale <identifiersep> url . open <identifiersep> stream ( ) ) { properties . load ( component <identifiersep> list <identifiersep> stream ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> } <comment> <ect>
if ( bundle == null ) { try { bundle = create <identifiersep> bundle ( locale ) ; if ( bundle != null ) { this . bundle <identifiersep> cache . put ( locale , bundle ) ; } } catch ( exception e ) { <LOG> } } return bundle ; } @ override public translation get <identifiersep> translation ( string key , locale locale ) { translation translation ; localized <identifiersep> translation <identifiersep> bundle bundle = get <identifiersep> localized <identifiersep> bundle ( locale ) ; <ect>
throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } else if ( events . get ( 0 ) . get <identifiersep> user ( ) . equals ( this . bridge . get <identifiersep> current <identifiersep> user <identifiersep> reference ( ) ) ) { this . stream . delete <identifiersep> event ( events . get ( 0 ) ) ; } else { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } } catch ( query <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
application <identifiersep> context <identifiersep> listener <identifiersep> manager . destroy <identifiersep> application <identifiersep> context ( container . get <identifiersep> application <identifiersep> context ( ) ) ; } catch ( component <identifiersep> lookup <identifiersep> exception ex ) { <comment> <LOG> } } <ect>
{ try { this . random = secure <identifiersep> random . get <identifiersep> instance ( <string_literal> ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <comment> <LOG> } byte [ ] seed = this . random . generate <identifiersep> seed ( token <identifiersep> length ) ; this . random . set <identifiersep> seed ( seed ) ; this . logger . debug ( <string_literal> ) ; } <comment> <ect>
<comment> <LOG> this . tokens . remove ( get <identifiersep> token <identifiersep> key ( ) ) ; } @ override public boolean is <identifiersep> token <identifiersep> valid ( string token ) { if ( ! this . configuration . is <identifiersep> enabled ( ) ) { return true ; <ect>
io <identifiersep> utils . close <identifiersep> quietly ( fis ) ; } } return result ; } catch ( exception ex ) { throw new office <identifiersep> converter <identifiersep> exception ( <string_literal> , ex ) ; } finally { if ( ! storage . clean <identifiersep> up ( ) ) { <LOG> } } } @ override public document <identifiersep> format <identifiersep> registry get <identifiersep> format <identifiersep> registry ( ) { return converter . get <identifiersep> format <identifiersep> registry ( ) ; } } <ect>
<comment> <LOG> } catch ( exception e ) { set <identifiersep> state ( server <identifiersep> state . error ) ; throw new office <identifiersep> server <identifiersep> exception ( <string_literal> , e ) ; } } @ override public void stop ( ) throws office <identifiersep> server <identifiersep> exception { <ect>
attachment <identifiersep> reference attachment <identifiersep> reference = new attachment <identifiersep> reference ( artifact . get <identifiersep> key ( ) , target <identifiersep> document <identifiersep> reference ) ; try { this . doc <identifiersep> bridge . set <identifiersep> attachment <identifiersep> content ( attachment <identifiersep> reference , artifact . get <identifiersep> value ( ) ) ; } catch ( exception ex ) { <comment> <LOG> } } } } <ect>
io <identifiersep> utils . copy ( process . get <identifiersep> input <identifiersep> stream ( ) , new null <identifiersep> output <identifiersep> stream ( ) ) ; try { process . wait <identifiersep> for ( ) ; } catch ( interrupted <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } if ( process . exit <identifiersep> value ( ) != 0 ) { <LOG> } return process . exit <identifiersep> value ( ) == 0 ; } } <ect>
hash <identifiersep> algorithm . update ( inline ? ( byte ) 't' : ( byte ) 'f' ) ; hash <identifiersep> algorithm . update ( ( byte ) size . ordinal ( ) ) ; hash <identifiersep> algorithm . update ( ( byte ) type . ordinal ( ) ) ; hash <identifiersep> algorithm . update ( formula . get <identifiersep> bytes ( ) ) ; return string . value <identifiersep> of ( org . apache . commons . codec . binary . hex . encode <identifiersep> hex ( hash <identifiersep> algorithm . digest ( ) ) ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { <LOG> } catch ( null <identifiersep> pointer <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } <comment> <ect>
super . init ( context ) ; file dir = this . environment . get <identifiersep> temporary <identifiersep> directory ( ) ; this . temp <identifiersep> dir = new file ( dir , this . get <identifiersep> name ( ) ) ; try { this . temp <identifiersep> dir . mkdirs ( ) ; } catch ( exception ex ) { <LOG> } this . dot <identifiersep> path = context . get <identifiersep> wiki ( ) . param ( <string_literal> , dot <identifiersep> engine ) ; if ( ! this . dot <identifiersep> path . equals ( dot <identifiersep> engine ) ) { try { file dfile = new file ( this . dot <identifiersep> path ) ; if ( ! dfile . exists ( ) ) { logger . error ( <string_literal> + this . dot <identifiersep> path ) ; <ect>
<comment> <LOG> } } catch ( exception e ) { <comment> <ect>
processed <identifiersep> addresses . add ( address ) ; document <identifiersep> reference template <identifiersep> reference = get <identifiersep> template <identifiersep> reference ( subscriber <identifiersep> reference ) ; result = new watch <identifiersep> list <identifiersep> message <identifiersep> data ( subscriber <identifiersep> reference , template <identifiersep> reference , first <identifiersep> name , last <identifiersep> name , address , matching <identifiersep> events ) ; } catch ( exception e ) { <LOG> } return result ; } private document <identifiersep> reference get <identifiersep> template <identifiersep> reference ( document <identifiersep> reference subscriber <identifiersep> reference ) { document <identifiersep> reference result = null ; <comment> <ect>
events . add ( event ) ; } else { <comment> <LOG> } return events ; } @ override public list < watch <identifiersep> list <identifiersep> event > get <identifiersep> matching <identifiersep> visible <identifiersep> events ( list < watch <identifiersep> list <identifiersep> event > events , string subscriber ) { list < watch <identifiersep> list <identifiersep> event > result = new array <identifiersep> list < watch <identifiersep> list <identifiersep> event > ( ) ; for ( watch <identifiersep> list <identifiersep> event event : events ) { <ect>
{ collection < string > wiki <identifiersep> servers = new array <identifiersep> list < string > ( ) ; set < string > results = new hash <identifiersep> set < > ( ) ; try { wiki <identifiersep> servers = wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> all <identifiersep> ids ( ) ; } catch ( exception e ) { <LOG> } try { <comment> <ect>
iterator < string > it = up <identifiersep> docs <identifiersep> in <identifiersep> wiki . iterator ( ) ; while ( it . has <identifiersep> next ( ) ) { results . add ( wiki <identifiersep> prefix + it . next ( ) ) ; } } catch ( exception e ) { logger . error ( <string_literal> , wiki , e ) ; } } } catch ( exception e ) { <LOG> } return results ; } <comment> <ect>
string value = watch <identifiersep> object . get <identifiersep> string <identifiersep> value ( watch <identifiersep> list <identifiersep> class <identifiersep> document <identifiersep> initializer . automaticwatch <identifiersep> property ) ; if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( value ) && ! watch <identifiersep> list <identifiersep> class <identifiersep> document <identifiersep> initializer . automaticwatch <identifiersep> default <identifiersep> value . equals ( value ) ) { mode = automatic <identifiersep> watch <identifiersep> mode . value <identifiersep> of ( value ) ; } } catch ( exception e ) { <comment> <LOG> } if ( mode == null ) { string value = context . get <identifiersep> wiki ( ) . param ( <string_literal> ) ; if ( value != null ) { try { mode = automatic <identifiersep> watch <identifiersep> mode . value <identifiersep> of ( value . to <identifiersep> upper <identifiersep> case ( ) ) ; } catch ( exception e ) { <ect>
if ( string <identifiersep> utils . is <identifiersep> blank ( recipients ) ) { recipients = mail . get <identifiersep> bcc ( ) ; } else { recipients = mail . get <identifiersep> bcc ( ) + <string_literal> + recipients ; } internet <identifiersep> address [ ] bcc = to <identifiersep> internet <identifiersep> addresses ( recipients ) ; if ( ( to == null ) && ( cc == null ) && ( bcc == null ) ) { <LOG> return null ; } mime <identifiersep> message message = new mime <identifiersep> message ( session ) ; message . set <identifiersep> sent <identifiersep> date ( new date ( ) ) ; message . set <identifiersep> from ( from ) ; if ( to != null ) { message . set <identifiersep> recipients ( javax . mail . message . recipient <identifiersep> type . to , to ) ; <ect>
<comment> <LOG> } } <comment> <ect>
<comment> <LOG> } transport = null ; session = null ; } } catch ( send <identifiersep> failed <identifiersep> exception ex ) { send <identifiersep> failed <identifiersep> count ++ ; logger . error ( <string_literal> , ex ) ; logger . error ( <string_literal> + mail . to <identifiersep> string ( ) ) ; <ect>
logger . error ( <string_literal> , ex ) ; } transport = null ; session = null ; } } catch ( send <identifiersep> failed <identifiersep> exception ex ) { send <identifiersep> failed <identifiersep> count ++ ; logger . error ( <string_literal> , ex ) ; <LOG> if ( email <identifiersep> count == 1 ) { throw ex ; } if ( ( email <identifiersep> count != 1 ) && ( send <identifiersep> failed <identifiersep> count > <number_literal> ) ) { throw ex ; } } catch ( messaging <identifiersep> exception mex ) { logger . error ( <string_literal> , mex ) ; <ect>
if ( email <identifiersep> count == 1 ) { throw ex ; } if ( ( email <identifiersep> count != 1 ) && ( send <identifiersep> failed <identifiersep> count > <number_literal> ) ) { throw ex ; } } catch ( messaging <identifiersep> exception mex ) { logger . error ( <string_literal> , mex ) ; <LOG> if ( email <identifiersep> count == 1 ) { throw mex ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; <ect>
logger . error ( <string_literal> + mail . to <identifiersep> string ( ) ) ; if ( email <identifiersep> count == 1 ) { throw mex ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } } finally { try { if ( transport != null ) { transport . close ( ) ; } } catch ( messaging <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; <ect>
} finally { try { if ( transport != null ) { transport . close ( ) ; } } catch ( messaging <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } <LOG> } return true ; } <comment> <ect>
mail . set <identifiersep> html <identifiersep> part ( html ) ; mail . set <identifiersep> attachments ( doc <identifiersep> api . get <identifiersep> attachment <identifiersep> list ( ) ) ; try { send <identifiersep> mail ( mail , context ) ; return 0 ; } catch ( exception e ) { <LOG> return error ; } } finally { context . set <identifiersep> url <identifiersep> factory ( original <identifiersep> url <identifiersep> factory ) ; context . set <identifiersep> locale ( original <identifiersep> locale ) ; } } private string evaluate ( string content , string name , velocity <identifiersep> context vcontext , x <identifiersep> wiki <identifiersep> context context ) { <ect>
return get <identifiersep> protected <identifiersep> plugin ( ) . send <identifiersep> mail <identifiersep> from <identifiersep> template ( document <identifiersep> full <identifiersep> name , from , to , cc , bcc , language , vcontext , this . context ) ; } catch ( exception e ) { <comment> <LOG> return - 1 ; } } <comment> <ect>
try { get <identifiersep> protected <identifiersep> plugin ( ) . send <identifiersep> mail ( mail , this . context ) ; } catch ( exception e ) { <comment> <LOG> result = - 1 ; } return result ; } @ override public mail <identifiersep> configuration create <identifiersep> mail <identifiersep> configuration ( x <identifiersep> wiki xwiki ) { return new mail <identifiersep> configuration ( xwiki ) ; <ect>
} catch ( x <identifiersep> wiki <identifiersep> exception e1 ) { logger . error ( <string_literal> , extension , e1 ) ; } } this . always <identifiersep> used <identifiersep> extensions . put ( current <identifiersep> wiki , extensions ) ; return extensions ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> return collections . empty <identifiersep> set ( ) ; } } } @ override public boolean has <identifiersep> page <identifiersep> extensions ( x <identifiersep> wiki <identifiersep> context context ) { x <identifiersep> wiki <identifiersep> document doc = context . get <identifiersep> doc ( ) ; list < base <identifiersep> object > objects = doc . get <identifiersep> objects ( get <identifiersep> extension <identifiersep> class <identifiersep> name ( ) ) ; <ect>
public base <identifiersep> class get <identifiersep> extension <identifiersep> class ( x <identifiersep> wiki <identifiersep> context context ) { try { x <identifiersep> wiki <identifiersep> document doc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( get <identifiersep> extension <identifiersep> class <identifiersep> name ( ) , context ) ; return doc . get <identifiersep> x <identifiersep> class ( ) ; } catch ( exception ex ) { <LOG> } return null ; } <comment> <ect>
<comment> public void use ( string resource , x <identifiersep> wiki <identifiersep> context context ) { <LOG> get <identifiersep> pulled <identifiersep> resources ( context ) . add ( resource ) ; <comment> <ect>
string <identifiersep> writer out = new string <identifiersep> writer ( ) ; compressor . compress ( out , - 1 , true , false , false , false ) ; return out . to <identifiersep> string ( ) ; } catch ( io <identifiersep> exception ex ) { logger . info ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } catch ( evaluator <identifiersep> exception ex ) { <LOG> } catch ( exception ex ) { logger . warn ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } return source ; } <comment> private static class custom <identifiersep> error <identifiersep> reporter implements error <identifiersep> reporter { <ect>
logger . warn ( message <identifiersep> format . format ( <string_literal> , message , context , line <identifiersep> number , column ) ) ; } @ override public evaluator <identifiersep> exception runtime <identifiersep> error ( string message , string filename , int line <identifiersep> number , string context , int column ) { <LOG> return null ; } @ override public void warning ( string message , string filename , int line <identifiersep> number , string context , int column ) { logger . info ( message <identifiersep> format . format ( <string_literal> , message , context , line <identifiersep> number , column ) ) ; <ect>
string wiki <identifiersep> id = ( ( wiki <identifiersep> deleted <identifiersep> event ) event ) . get <identifiersep> wiki <identifiersep> id ( ) ; file directory = this . store . get <identifiersep> wiki <identifiersep> dir ( wiki <identifiersep> id ) ; if ( directory . exists ( ) && directory . is <identifiersep> directory ( ) ) { try { file <identifiersep> utils . delete <identifiersep> directory ( directory ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } } } <ect>
public void scheduler <identifiersep> error ( string message , scheduler <identifiersep> exception error ) { logger . error ( message , error ) ; } @ override public void scheduler <identifiersep> shutdown ( ) { <LOG> } @ override public string get <identifiersep> name ( ) { return <string_literal> ; } @ override public void job <identifiersep> to <identifiersep> be <identifiersep> executed ( job <identifiersep> execution <identifiersep> context context ) <ect>
@ override public void job <identifiersep> execution <identifiersep> vetoed ( job <identifiersep> execution <identifiersep> context context ) { } @ override public void job <identifiersep> was <identifiersep> executed ( job <identifiersep> execution <identifiersep> context context , job <identifiersep> execution <identifiersep> exception e ) { <LOG> } @ override public void triggers <identifiersep> paused ( string trigger <identifiersep> group ) { <comment> <ect>
<comment> <LOG> return true ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . context . put ( <string_literal> , e . get <identifiersep> message ( ) ) ; return false ; } } <comment> <ect>
<comment> public boolean trigger <identifiersep> job ( base <identifiersep> object object ) { try { get <identifiersep> protected <identifiersep> plugin ( ) . trigger <identifiersep> job ( object , this . context ) ; <LOG> return true ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . context . put ( <string_literal> , e . get <identifiersep> message ( ) ) ; return false ; } } <comment> <ect>
for ( string wiki <identifiersep> name : wiki <identifiersep> servers ) { xcontext . set <identifiersep> wiki <identifiersep> id ( wiki <identifiersep> name ) ; restore <identifiersep> existing <identifiersep> jobs ( xcontext ) ; } } finally { xcontext . set <identifiersep> wiki <identifiersep> id ( initial <identifiersep> db ) ; } } catch ( scheduler <identifiersep> exception e ) { <LOG> } catch ( scheduler <identifiersep> plugin <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } <comment> <ect>
x <identifiersep> wiki <identifiersep> document job <identifiersep> doc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( doc <identifiersep> reference , context ) ; register ( job <identifiersep> doc , context ) ; } catch ( exception e ) { logger . error ( <string_literal> , doc <identifiersep> reference , context . get <identifiersep> wiki <identifiersep> id ( ) , e ) ; } } } catch ( exception e ) { <LOG> } } private void register ( x <identifiersep> wiki <identifiersep> document job <identifiersep> doc , x <identifiersep> wiki <identifiersep> context context ) throws scheduler <identifiersep> plugin <identifiersep> exception { base <identifiersep> object job <identifiersep> obj = job <identifiersep> doc . get <identifiersep> x <identifiersep> object ( xwiki <identifiersep> job <identifiersep> classreference ) ; register ( job <identifiersep> obj , context ) ; } private void register ( base <identifiersep> object job <identifiersep> obj , x <identifiersep> wiki <identifiersep> context context ) throws scheduler <identifiersep> plugin <identifiersep> exception { <ect>
case normal : if ( get <identifiersep> trigger ( object , context ) . compare <identifiersep> to ( trigger ) != 0 ) { logger . debug ( <string_literal> , object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ) ; } get <identifiersep> scheduler ( ) . reschedule <identifiersep> job ( trigger . get <identifiersep> key ( ) , trigger ) ; break ; case none : <LOG> get <identifiersep> scheduler ( ) . schedule <identifiersep> job ( trigger ) ; logger . info ( <string_literal> , object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ) ; if ( object . get <identifiersep> string <identifiersep> value ( <string_literal> ) . equals ( <string_literal> ) ) { get <identifiersep> scheduler ( ) . pause <identifiersep> job ( new job <identifiersep> key ( xjob ) ) ; save <identifiersep> status ( <string_literal> , object , context ) ; } else { <ect>
get <identifiersep> scheduler ( ) . pause <identifiersep> job ( new job <identifiersep> key ( xjob ) ) ; save <identifiersep> status ( <string_literal> , object , context ) ; } else { save <identifiersep> status ( <string_literal> , object , context ) ; } break ; default : <LOG> get <identifiersep> scheduler ( ) . schedule <identifiersep> job ( trigger ) ; save <identifiersep> status ( <string_literal> , object , context ) ; break ; } } catch ( scheduler <identifiersep> exception e ) { throw new scheduler <identifiersep> plugin <identifiersep> exception ( scheduler <identifiersep> plugin <identifiersep> exception . error <identifiersep> schedulerplugin <identifiersep> schedule <identifiersep> job , <string_literal> + object . get <identifiersep> string <identifiersep> value ( <string_literal> ) , e ) ; <ect>
} else { if ( original <identifiersep> job <identifiersep> obj == null ) { <comment> <LOG> exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } } } <ect>
component <identifiersep> manager component <identifiersep> manager = this . component <identifiersep> manager <identifiersep> manager . get <identifiersep> component <identifiersep> manager ( new document <identifiersep> namespace ( document ) . serialize ( ) , false ) ; if ( component <identifiersep> manager instanceof disposable ) { try { ( ( disposable ) component <identifiersep> manager ) . dispose ( ) ; } catch ( component <identifiersep> lifecycle <identifiersep> exception e ) { <LOG> } } } } <ect>
<comment> <LOG> exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } break ; } } } } <ect>
{ for ( wiki <identifiersep> component component : components ) { <comment> <LOG> component . get <identifiersep> document <identifiersep> reference ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } <comment> <ect>
try { this . install <identifiersep> or <identifiersep> update <identifiersep> component <identifiersep> x <identifiersep> class ( ) ; this . install <identifiersep> or <identifiersep> update <identifiersep> component <identifiersep> requirement <identifiersep> x <identifiersep> class ( ) ; this . install <identifiersep> or <identifiersep> update <identifiersep> component <identifiersep> method <identifiersep> x <identifiersep> class ( ) ; this . install <identifiersep> or <identifiersep> update <identifiersep> component <identifiersep> interface <identifiersep> x <identifiersep> class ( ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } <comment> private void install <identifiersep> or <identifiersep> update <identifiersep> component <identifiersep> interface <identifiersep> x <identifiersep> class ( ) throws x <identifiersep> wiki <identifiersep> exception <ect>
<comment> <LOG> } return wiki <identifiersep> objects <identifiersep> list ; } <comment> <ect>
try { node <identifiersep> list empty <identifiersep> attributes = x <identifiersep> path <identifiersep> api . select <identifiersep> node <identifiersep> list ( document , <string_literal> ) ; for ( int i = empty <identifiersep> attributes . get <identifiersep> length ( ) - 1 ; i >= 0 ; i -- ) { attr empty <identifiersep> attribute = ( attr ) empty <identifiersep> attributes . item ( i ) ; empty <identifiersep> attribute . get <identifiersep> owner <identifiersep> element ( ) . remove <identifiersep> attribute <identifiersep> node ( empty <identifiersep> attribute ) ; } } catch ( transformer <identifiersep> exception e ) { <LOG> } } } <ect>
x <identifiersep> wiki <identifiersep> document template = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( template <identifiersep> reference , xcontext ) ; string template <identifiersep> syntax = template . get <identifiersep> syntax ( ) . to <identifiersep> id <identifiersep> string ( ) ; string output = xcontext . get <identifiersep> doc ( ) . get <identifiersep> rendered <identifiersep> content ( template . get <identifiersep> content ( ) , template <identifiersep> syntax , xcontext ) ; <comment> <LOG> return null ; } } <comment> <ect>
) ; <comment> window . read <identifiersep> cookie = x <identifiersep> wiki . cookies . read . wrap ( function ( ) { <LOG> var args = $a ( arguments ) , proceed = args . shift ( ) ; return proceed . apply ( window , args ) ; } ) ; <comment> <ect>
) ; <comment> window . toggle <identifiersep> panel <identifiersep> visibility = x <identifiersep> wiki . toggle <identifiersep> panel <identifiersep> visibility . wrap ( function ( ) { <LOG> var args = $a ( arguments ) , proceed = args . shift ( ) ; return proceed . apply ( window , args ) ; } ) ; <comment> <ect>
warn ( <string_literal> ) ; x <identifiersep> wiki . edit <identifiersep> lock . unlock ( ) ; } <comment> window . lock <identifiersep> edit = function ( ) { <LOG> x <identifiersep> wiki . edit <identifiersep> lock . lock ( ) ; } <comment> window . cancel <identifiersep> cancel <identifiersep> edit = function ( ) { warn ( <string_literal> ) ; <ect>
this . cell <identifiersep> dates = new array ( ) ; this . cells = new array ( ) ; this . render <identifiersep> stack = new array ( ) ; this .  <identifiersep> render <identifiersep> stack = new array ( ) ; this . o <identifiersep> dom <identifiersep> container = document . get <identifiersep> element <identifiersep> by <identifiersep> id ( container <identifiersep> id ) ; if ( ! this . o <identifiersep> dom <identifiersep> container ) { <LOG> } this . today = new date ( ) ; yahoo . widget . date <identifiersep> math . clear <identifiersep> time ( this . today ) ; var month ; var year ; if ( monthyear ) { var a <identifiersep> month <identifiersep> year = monthyear . split ( this . locale . date <identifiersep> field <identifiersep> delimiter ) ; <ect>
<comment> this . do <identifiersep> select <identifiersep> cell = function ( e , cal ) { var cell = this ; var index = cell . index ; <LOG> var d = cal . cell <identifiersep> dates [ index ] ; var date = new date ( d [ 0 ] , d [ 1 ] - 1 , d [ <number_literal> ] ) ; if ( ! cal . is <identifiersep> date <identifiersep> oom ( date ) && ! yahoo . util . dom . has <identifiersep> class ( cell , cal . style . css <identifiersep> cell <identifiersep> restricted ) && ! yahoo . util . dom . has <identifiersep> class ( cell , cal . style . css <identifiersep> cell <identifiersep> oob ) ) { if ( cal . options . multi <identifiersep> select ) { var link = cell . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) [ 0 ] ; link . blur ( ) ; <ect>
<comment> yahoo . widget . calendar <identifiersep> core . prototype . render <identifiersep> body = function ( working <identifiersep> date ) { <LOG> this . pre <identifiersep> month <identifiersep> days = working <identifiersep> date . get <identifiersep> day ( ) ; if ( this . options . start <identifiersep> weekday > 0 ) { this . pre <identifiersep> month <identifiersep> days -= this . options . start <identifiersep> weekday ; } if ( this . pre <identifiersep> month <identifiersep> days < 0 ) { this . pre <identifiersep> month <identifiersep> days += <number_literal> ; } this . logger . log ( this . pre <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; <ect>
if ( this . options . start <identifiersep> weekday > 0 ) { this . pre <identifiersep> month <identifiersep> days -= this . options . start <identifiersep> weekday ; } if ( this . pre <identifiersep> month <identifiersep> days < 0 ) { this . pre <identifiersep> month <identifiersep> days += <number_literal> ; } this . logger . log ( this . pre <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; this . month <identifiersep> days = yahoo . widget . date <identifiersep> math . find <identifiersep> month <identifiersep> end ( working <identifiersep> date ) . get <identifiersep> date ( ) ; <LOG> this . post <identifiersep> month <identifiersep> days = yahoo . widget . calendar <identifiersep> core . display <identifiersep> days - this . pre <identifiersep> month <identifiersep> days - this . month <identifiersep> days ; this . logger . log ( this . post <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; working <identifiersep> date = yahoo . widget . date <identifiersep> math . subtract ( working <identifiersep> date , yahoo . widget . date <identifiersep> math . day , this . pre <identifiersep> month <identifiersep> days ) ; this . logger . log ( <string_literal> + working <identifiersep> date , <string_literal> ) ; var week <identifiersep> row <identifiersep> index = 0 ; for ( var c = 0 ; c < this . cells . length ; ++ c ) { <ect>
this . logger . log ( this . pre <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; this . month <identifiersep> days = yahoo . widget . date <identifiersep> math . find <identifiersep> month <identifiersep> end ( working <identifiersep> date ) . get <identifiersep> date ( ) ; this . logger . log ( this . month <identifiersep> days + <string_literal> , <string_literal> ) ; this . post <identifiersep> month <identifiersep> days = yahoo . widget . calendar <identifiersep> core . display <identifiersep> days - this . pre <identifiersep> month <identifiersep> days - this . month <identifiersep> days ; this . logger . log ( this . post <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; working <identifiersep> date = yahoo . widget . date <identifiersep> math . subtract ( working <identifiersep> date , yahoo . widget . date <identifiersep> math . day , this . pre <identifiersep> month <identifiersep> days ) ; <LOG> var week <identifiersep> row <identifiersep> index = 0 ; for ( var c = 0 ; c < this . cells . length ; ++ c ) { var cell <identifiersep> renderers = new array ( ) ; var cell = this . cells [ c ] ; this . clear <identifiersep> element ( cell ) ; cell . index = c ; <ect>
) { cell <identifiersep> renderers [ cell <identifiersep> renderers . length ] = this . render <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> date ; } else { cell <identifiersep> renderers [ cell <identifiersep> renderers . length ] = this . render <identifiersep> cell <identifiersep> default ; } for ( var x = 0 ; x < cell <identifiersep> renderers . length ; ++ x ) { var ren = cell <identifiersep> renderers [ x ] ; <LOG> if ( ren . call ( this , working <identifiersep> date , cell ) == yahoo . widget . calendar <identifiersep> core . stop <identifiersep> render ) { break ; } } working <identifiersep> date = yahoo . widget . date <identifiersep> math . add ( working <identifiersep> date , yahoo . widget . date <identifiersep> math . day , 1 ) ; <comment> <ect>
<comment> yahoo . widget . calendar <identifiersep> core . prototype . select = function ( date ) { this . on <identifiersep> before <identifiersep> select ( ) ; <LOG> var a <identifiersep> to <identifiersep> be <identifiersep> selected = this .  <identifiersep> to <identifiersep> field <identifiersep> array ( date ) ; this . logger . log ( <string_literal> + a <identifiersep> to <identifiersep> be <identifiersep> selected , <string_literal> ) ; for ( var a = 0 ; a < a <identifiersep> to <identifiersep> be <identifiersep> selected . length ; ++ a ) { var to <identifiersep> select = a <identifiersep> to <identifiersep> be <identifiersep> selected [ a ] ; <comment> <ect>
yahoo . widget . calendar <identifiersep> core . prototype . select <identifiersep> cell = function ( cell <identifiersep> index ) { this . on <identifiersep> before <identifiersep> select ( ) ; this . cells = this . tbody . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) ; var cell = this . cells [ cell <identifiersep> index ] ; var cell <identifiersep> date = this . cell <identifiersep> dates [ cell <identifiersep> index ] ; var d <identifiersep> cell <identifiersep> date = this .  <identifiersep> to <identifiersep> date ( cell <identifiersep> date ) ; <LOG> var select <identifiersep> date = cell <identifiersep> date . concat ( ) ; this . selected <identifiersep> dates . push ( select <identifiersep> date ) ; if ( this . parent ) { this . parent . sync ( this ) ; } this . render <identifiersep> cell <identifiersep> style <identifiersep> selected ( d <identifiersep> cell <identifiersep> date , cell ) ; this . on <identifiersep> select ( [ select <identifiersep> date ] ) ; <ect>
this . on <identifiersep> before <identifiersep> deselect ( ) ; this . cells = this . tbody . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) ; var cell = this . cells [ i ] ; var cell <identifiersep> date = this . cell <identifiersep> dates [ i ] ; var cell <identifiersep> date <identifiersep> index = this .  <identifiersep> index <identifiersep> of <identifiersep> selected <identifiersep> field <identifiersep> array ( cell <identifiersep> date ) ; var d <identifiersep> cell <identifiersep> date = this .  <identifiersep> to <identifiersep> date ( cell <identifiersep> date ) ; <LOG> var select <identifiersep> date = cell <identifiersep> date . concat ( ) ; if ( cell <identifiersep> date <identifiersep> index > - 1 ) { if ( this . page <identifiersep> date . get <identifiersep> month ( ) == d <identifiersep> cell <identifiersep> date . get <identifiersep> month ( ) && this . page <identifiersep> date . get <identifiersep> full <identifiersep> year ( ) == d <identifiersep> cell <identifiersep> date . get <identifiersep> full <identifiersep> year ( ) ) { yahoo . util . dom . remove <identifiersep> class ( cell , this . style . css <identifiersep> cell <identifiersep> selected ) ; } this . selected <identifiersep> dates . splice ( cell <identifiersep> date <identifiersep> index , 1 ) ; <ect>
this . index + <string_literal> ; } ; <comment> yahoo . widget . check <identifiersep> node . prototype . check <identifiersep> click = function ( ) { <LOG> if ( this . check <identifiersep> state == = 0 ) { this . check ( ) ; } else { this . uncheck ( ) ; } <comment> <ect>
<comment> yahoo . widget . check <identifiersep> node . prototype . update <identifiersep> parent = function ( ) { var p = this . parent ; if ( ! p || ! p . update <identifiersep> parent ) { <LOG> return ; } var something <identifiersep> checked = false ; var something <identifiersep> not <identifiersep> checked = false ; for ( var i = 0 ; i < p . children . length ; ++ i ) { if ( p . children [ i ] . checked ) { something <identifiersep> checked = true ; <ect>
this . children [ i ] . uncheck ( ) ; } this . update <identifiersep> check <identifiersep> html ( ) ; this . update <identifiersep> parent ( ) ; } ; <comment> <LOG> var sb = new array ( ) ; sb [ sb . length ] = ' < table border = <string_literal> cellpadding = <string_literal> cellspacing = <string_literal> > ' ; sb [ sb . length ] = ' < tr > ' ; for ( i = 0 ; i < this . depth ; ++ i ) { sb [ sb . length ] = ' < td class = <string_literal> > & # <number_literal> ; < / td > ' ; } sb [ sb . length ] = ' < td' ; <ect>
<comment> animate <identifiersep> collapse : function ( el ) { <LOG> if ( this .  <identifiersep> collapse <identifiersep> anim && this .  <identifiersep> anim <identifiersep> count < this . max <identifiersep> anim ) { <comment> <ect>
this . logger . log ( <string_literal> ) ; return ; } if ( ! this . get <identifiersep> el ( ) ) { this . expanded = true ; return ; } if ( ! this . children <identifiersep> rendered ) { <LOG> this . get <identifiersep> children <identifiersep> el ( ) . inner <identifiersep> html = this . render <identifiersep> children ( ) ; } else { this . logger . log ( <string_literal> ) ; } this . expanded = true ; if ( this . has <identifiersep> icon ) { this . get <identifiersep> toggle <identifiersep> el ( ) . class <identifiersep> name = this . get <identifiersep> style ( ) ; <ect>
<comment> get <identifiersep> style : function ( ) { <LOG> if ( this . is <identifiersep> loading ) { this . logger . log ( <string_literal> ) ; return <string_literal> ; } else { <comment> <ect>
var loc = ( this . next <identifiersep> sibling ) ? <string_literal> : <string_literal> ; <comment> <LOG> return <string_literal> + loc + type ; } } , <comment> <ect>
<comment> render <identifiersep> children : function ( ) { <LOG> var node = this ; if ( this . is <identifiersep> dynamic ( ) && ! this . dynamic <identifiersep> load <identifiersep> complete ) { this . is <identifiersep> loading = true ; this . tree . locked = true ; if ( this . data <identifiersep> loader ) { this . logger . log ( <string_literal> ) ; <ect>
node . data <identifiersep> loader ( node , function ( ) { node . load <identifiersep> complete ( ) ; } ) ; } , <number_literal> ) ; } else if ( this . tree . root . data <identifiersep> loader ) { <LOG> set <identifiersep> timeout ( function ( ) { node . tree . root . data <identifiersep> loader ( node , function ( ) { node . load <identifiersep> complete ( ) ; } ) ; <ect>
} , <comment> complete <identifiersep> render : function ( ) { <LOG> var sb = [ ] ; for ( var i = 0 ; i < this . children . length ; ++ i ) { this . children [ i ] . children <identifiersep> rendered = false ; sb [ sb . length ] = this . children [ i ] . get <identifiersep> html ( ) ; } this . children <identifiersep> rendered = true ; return sb . join ( <string_literal> ) ; <ect>
<comment> get <identifiersep> ancestor : function ( depth ) { if ( depth >= this . depth || depth < 0 ) { <LOG> return null ; } var p = this . parent ; while ( p . depth > depth ) { p = p . parent ; } return p ; } , <ect>
<comment> yahoo . widget . text <identifiersep> node . prototype . get <identifiersep> label <identifiersep> el = function ( ) { return document . get <identifiersep> element <identifiersep> by <identifiersep> id ( this . label <identifiersep> el <identifiersep> id ) ; } ; <comment> <LOG> var sb = [ ] ; sb [ sb . length ] = ' < table border = <string_literal> cellpadding = <string_literal> cellspacing = <string_literal> > ' ; sb [ sb . length ] = ' < tr > ' ; for ( i = 0 ; i < this . depth ; ++ i ) { <comment> <ect>
<comment> yahoo . widget . html <identifiersep> node . prototype . get <identifiersep> content <identifiersep> el = function ( ) { return document . get <identifiersep> element <identifiersep> by <identifiersep> id ( this . content <identifiersep> el <identifiersep> id ) ; } ; <comment> <LOG> var sb = [ ] ; sb [ sb . length ] = ' < table border = <string_literal> cellpadding = <string_literal> cellspacing = <string_literal> > ' ; sb [ sb . length ] = ' < tr > ' ; for ( i = 0 ; i < this . depth ; ++ i ) { sb [ sb . length ] = ' < td class = <string_literal> > & # <number_literal> ; < / td > ' ; } if ( this . has <identifiersep> icon ) { <ect>
<comment> yahoo . widget . tv <identifiersep> fade <identifiersep> out . prototype = { animate : function ( ) { var tvanim = this ; <comment> <LOG> <comment> <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
o <identifiersep> scope , b <identifiersep> override ) ; return true ; } } <comment> <LOG> return false ; } <comment> <ect>
average <identifiersep> rating voter <identifiersep> rating = calc <identifiersep> new <identifiersep> voter <identifiersep> reputation ( rating . get <identifiersep> author ( ) , document <identifiersep> ref , rating , old <identifiersep> vote ) ; <comment> <LOG> } } } catch ( reputation <identifiersep> exception e ) { if ( e . get <identifiersep> code ( ) != reputation <identifiersep> exception . error <identifiersep> reputation <identifiersep> not <identifiersep> implemented ) { <comment> <ect>
calc <identifiersep> new <identifiersep> contributor <identifiersep> reputation ( doc . get <identifiersep> creator <identifiersep> reference ( ) , document <identifiersep> ref , rating , old <identifiersep> vote ) ; <comment> <LOG> re ) ; } } } catch ( reputation <identifiersep> exception e ) { if ( e . get <identifiersep> code ( ) != reputation <identifiersep> exception . error <identifiersep> reputation <identifiersep> not <identifiersep> implemented ) { <comment> <ect>
if ( e . get <identifiersep> code ( ) != reputation <identifiersep> exception . error <identifiersep> reputation <identifiersep> not <identifiersep> implemented ) { <comment> <LOG> } } <comment> <ect>
return rating ; } @ override public list < rating > get <identifiersep> ratings ( document <identifiersep> reference document <identifiersep> ref , int start , int count , boolean asc ) throws ratings <identifiersep> exception { <LOG> } string sql = <string_literal> + <string_literal> + <string_literal> + <string_literal> + <string_literal> + ( asc ? <string_literal> : <string_literal> ) ; list < ? > params = new array <identifiersep> list < string > ( arrays . as <identifiersep> list ( get <identifiersep> ratings <identifiersep> class <identifiersep> name ( ) , rating <identifiersep> class <identifiersep> fieldname <identifiersep> parent , <ect>
+ <string_literal> + averagerating <identifiersep> class <identifiersep> fieldname <identifiersep> averagevote <identifiersep> method + <string_literal> + method + <string_literal> ; string sql = <string_literal> + fromsql2 + wheresql2 ; <LOG> } get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) . put ( <string_literal> , sql ) ; list result = get <identifiersep> x <identifiersep> wiki ( ) . get <identifiersep> store ( ) . search ( sql , 0 , 0 , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; float vote = ( ( number ) ( ( object [ ] ) result . get ( 0 ) ) [ 0 ] ) . float <identifiersep> value ( ) ; int nbvotes = ( ( number ) ( ( object [ ] ) result . get ( 0 ) ) [ 1 ] ) . int <identifiersep> value ( ) ; average <identifiersep> rating avgr = new memory <identifiersep> average <identifiersep> rating ( null , nbvotes , vote / nbvotes , method ) ; return avgr ; <ect>
} catch ( exception e ) { logger . error ( <string_literal> , e ) ; } try { return component <identifiersep> manager . get <identifiersep> instance ( ratings <identifiersep> manager . class , ratings <identifiersep> hint ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <LOG> try { return component <identifiersep> manager . get <identifiersep> instance ( ratings <identifiersep> manager . class , default <identifiersep> hint ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e1 ) { return null ; } } } } <ect>
reputation <identifiersep> instance . set <identifiersep> component <identifiersep> manager ( component <identifiersep> manager ) ; reputation <identifiersep> instance . set <identifiersep> execution ( execution ) ; reputation <identifiersep> instance . set <identifiersep> x <identifiersep> wiki <identifiersep> context ( get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; reputation <identifiersep> instance . set <identifiersep> ratings <identifiersep> manager ( ratings <identifiersep> manager <identifiersep> provider . get ( document <identifiersep> ref ) ) ; return reputation <identifiersep> instance ; } } catch ( throwable e ) { <LOG> } } try { return component <identifiersep> manager . get <identifiersep> instance ( reputation <identifiersep> algorithm . class , reputation <identifiersep> algorithm <identifiersep> hint ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <ect>
{ if ( this . observation <identifiersep> manager != null ) { return this . observation <identifiersep> manager ; } try { this . observation <identifiersep> manager = this . component <identifiersep> manager . get <identifiersep> instance ( observation <identifiersep> manager . class ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } return this . observation <identifiersep> manager ; } } <ect>
list < string > up <identifiersep> docs <identifiersep> in <identifiersep> wiki = context . get <identifiersep> wiki ( ) . get <identifiersep> store ( ) . search <identifiersep> documents <identifiersep> names ( request , 0 , 0 , values , context ) ; iterator < string > it = up <identifiersep> docs <identifiersep> in <identifiersep> wiki . iterator ( ) ; while ( it . has <identifiersep> next ( ) ) { results . add ( wiki <identifiersep> prefix + it . next ( ) ) ; } } catch ( exception e ) { <LOG> } } } finally { context . set <identifiersep> wiki <identifiersep> id ( ori <identifiersep> database ) ; } return results ; } <comment> <ect>
. search <identifiersep> documents <identifiersep> names ( <string_literal> , 0 , 0 , params , context ) ; for ( string doc <identifiersep> name : doc <identifiersep> names ) { x <identifiersep> wiki <identifiersep> document doc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( doc <identifiersep> name , context ) ; results . add ( new document ( doc , context ) ) ; } } catch ( exception e ) { <LOG> } finally { context . set <identifiersep> wiki <identifiersep> id ( ori <identifiersep> database ) ; } return results ; } <comment> <ect>
wiki <identifiersep> name = wiki <identifiersep> name . to <identifiersep> lower <identifiersep> case ( ) ; try { x <identifiersep> wiki <identifiersep> document userdoc = get <identifiersep> document ( wiki <identifiersep> admin , context ) ; <comment> <LOG> + <string_literal> ) ; } return - <number_literal> ; } <comment> <ect>
logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } return - <number_literal> ; } string wiki <identifiersep> forbidden <identifiersep> list = param ( <string_literal> ) ; if ( util . contains ( wiki <identifiersep> name , wiki <identifiersep> forbidden <identifiersep> list , <string_literal> ) ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { <LOG> + <string_literal> ) ; } return - <number_literal> ; } string wiki <identifiersep> server <identifiersep> page = <string_literal> + wiki <identifiersep> name . substring ( 0 , 1 ) . to <identifiersep> upper <identifiersep> case ( ) + wiki <identifiersep> name . substring ( 1 ) ; <comment> <ect>
if ( fail <identifiersep> on <identifiersep> exist ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } return - <number_literal> ; <LOG> + <string_literal> ) ; } } <comment> <ect>
} catch ( x <identifiersep> wiki <identifiersep> exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { if ( e . get <identifiersep> code ( ) == <number_literal> ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } else if ( e . get <identifiersep> code ( ) == <number_literal> ) { <LOG> + <string_literal> ) ; } else { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> , e ) ; } } } catch ( exception e ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> <ect>
logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } else { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> , e ) ; } } } catch ( exception e ) { <LOG> + <string_literal> , e ) ; } try { update <identifiersep> database ( wiki <identifiersep> name , true , false , context ) ; } catch ( exception e ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> , e ) ; <ect>
<comment> return 1 ; } catch ( exception e ) { <LOG> + <string_literal> , e ) ; return - <number_literal> ; } finally { context . set <identifiersep> database ( database ) ; } } <comment> <ect>
if ( xwikicfgis == null ) { if ( context != null ) { xwikicfgis = context . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( configuration <identifiersep> location ) ; logger . debug ( <string_literal> + configuration <identifiersep> location + <string_literal> + <string_literal> ) ; } else { <LOG> } } <comment> <ect>
<comment> <LOG> } } } <ect>
<comment> conf <identifiersep> error ( <string_literal> ) , <comment> <LOG> <comment> private string state <identifiersep> description ; <comment> <ect>
+ result . substring ( order <identifiersep> or <identifiersep> group <identifiersep> by <identifiersep> idx ) ; } else { <comment> <LOG> } return result ; } } <ect>
if ( ! string <identifiersep> utils . is <identifiersep> blank ( filter ) ) { try { query <identifiersep> filter query <identifiersep> filter = this . component <identifiersep> manager . get <identifiersep> instance ( query <identifiersep> filter . class , filter ) ; add <identifiersep> filter ( query <identifiersep> filter ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <LOG> } } return this ; } <comment> <ect>
@ override public query add <identifiersep> filter ( query <identifiersep> filter filter ) { if ( ! this . filters . contains ( filter ) ) { this . filters . add ( filter ) ; } else { <LOG> } return this ; } @ override public < t > list < t > execute ( ) throws query <identifiersep> exception { return get <identifiersep> executer ( ) . execute ( this ) ; } <comment> <ect>
private string get <identifiersep> content <identifiersep> as <identifiersep> string ( x <identifiersep> wiki <identifiersep> attachment attachment ) { try { return attachment == null ? null : io <identifiersep> utils . to <identifiersep> string ( attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( this . xcontext <identifiersep> provider . get ( ) ) ) ; } catch ( exception e ) { <LOG> exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; return null ; } } } <ect>
try { repair <identifiersep> extension ( new extension <identifiersep> id ( extension <identifiersep> dependency . get <identifiersep> id ( ) , extension <identifiersep> dependency . get <identifiersep> version <identifiersep> constraint ( ) . get <identifiersep> version ( ) ) , namespace , true , managed <identifiersep> dependencies ) ; } catch ( install <identifiersep> exception e ) { <LOG> } } } } } <ect>
namespace ) ; } try { wiki <identifiersep> reference wiki <identifiersep> reference = new wiki <identifiersep> reference ( xar <identifiersep> handler <identifiersep> utils . get <identifiersep> wiki <identifiersep> from <identifiersep> namespace ( namespace ) ) ; diff ( new xar <identifiersep> file ( new file ( installed <identifiersep> extension . get <identifiersep> file ( ) . get <identifiersep> absolute <identifiersep> path ( ) ) ) , wiki <identifiersep> reference , installed <identifiersep> extension . get <identifiersep> id ( ) , alreadydone ) ; } catch ( unsupported <identifiersep> namespace <identifiersep> exception e ) { <LOG> } catch ( io <identifiersep> exception e ) { this . logger . error ( <string_literal> , installed <identifiersep> extension . get <identifiersep> id ( ) , e ) ; } catch ( xar <identifiersep> exception e ) { this . logger . error ( <string_literal> , installed <identifiersep> extension . get <identifiersep> id ( ) , e ) ; } } } private void diff ( xar <identifiersep> file xar <identifiersep> file , wiki <identifiersep> reference wiki <identifiersep> reference , extension <identifiersep> id extension <identifiersep> id , set < local <identifiersep> document <identifiersep> reference > alreadydone ) <ect>
installed <identifiersep> extension . get <identifiersep> id ( ) , alreadydone ) ; } catch ( unsupported <identifiersep> namespace <identifiersep> exception e ) { this . logger . error ( <string_literal> , namespace , e ) ; } catch ( io <identifiersep> exception e ) { this . logger . error ( <string_literal> , installed <identifiersep> extension . get <identifiersep> id ( ) , e ) ; } catch ( xar <identifiersep> exception e ) { <LOG> } } } private void diff ( xar <identifiersep> file xar <identifiersep> file , wiki <identifiersep> reference wiki <identifiersep> reference , extension <identifiersep> id extension <identifiersep> id , set < local <identifiersep> document <identifiersep> reference > alreadydone ) { collection < xar <identifiersep> entry > xar <identifiersep> entries = xar <identifiersep> file . get <identifiersep> entries ( ) ; this . progress <identifiersep> manager . push <identifiersep> level <identifiersep> progress ( xar <identifiersep> entries . size ( ) , this ) ; try { <ect>
} catch ( io <identifiersep> exception e ) { <comment> <LOG> } <comment> <ect>
private void maybe <identifiersep> add <identifiersep> document <identifiersep> diff ( document <identifiersep> unified <identifiersep> diff document <identifiersep> diff ) { int differences <identifiersep> count = document <identifiersep> diff . size ( ) + document <identifiersep> diff . get <identifiersep> attachment <identifiersep> diffs ( ) . size ( ) + document <identifiersep> diff . get <identifiersep> object <identifiersep> diffs ( ) . size ( ) + document <identifiersep> diff . get <identifiersep> class <identifiersep> property <identifiersep> diffs ( ) . size ( ) ; if ( get <identifiersep> request ( ) . is <identifiersep> verbose ( ) ) { if ( document <identifiersep> diff . get <identifiersep> next <identifiersep> reference ( ) == null ) { <LOG> } else if ( document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) == null ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> next <identifiersep> reference ( ) ) ; } else if ( differences <identifiersep> count > 0 ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) , differences <identifiersep> count ) ; } else { <ect>
if ( get <identifiersep> request ( ) . is <identifiersep> verbose ( ) ) { if ( document <identifiersep> diff . get <identifiersep> next <identifiersep> reference ( ) == null ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) ) ; } else if ( document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) == null ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> next <identifiersep> reference ( ) ) ; } else if ( differences <identifiersep> count > 0 ) { <LOG> differences <identifiersep> count ) ; } else { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) ) ; } } if ( differences <identifiersep> count > 0 ) { get <identifiersep> status ( ) . get <identifiersep> document <identifiersep> diffs ( ) . add ( document <identifiersep> diff ) ; } } } <ect>
<comment> <LOG> } } } <ect>
if ( xar <identifiersep> installed <identifiersep> extension . get <identifiersep> namespaces ( ) == null ) { pages <identifiersep> updated ( xar <identifiersep> installed <identifiersep> extension , null , true ) ; } else { for ( string namespace : local <identifiersep> extension . get <identifiersep> namespaces ( ) ) { pages <identifiersep> updated ( xar <identifiersep> installed <identifiersep> extension , namespace , true ) ; } } } catch ( exception e ) { <LOG> continue ; } } } } <comment> <ect>
{ x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; x <identifiersep> wiki <identifiersep> document next <identifiersep> document ; try { next <identifiersep> document = get <identifiersep> x <identifiersep> wiki <identifiersep> document ( input <identifiersep> stream , wiki <identifiersep> reference ) ; } catch ( exception e ) { <LOG> return null ; } document <identifiersep> reference reference = next <identifiersep> document . get <identifiersep> document <identifiersep> reference <identifiersep> with <identifiersep> locale ( ) ; x <identifiersep> wiki <identifiersep> document current <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( reference , xcontext ) ; current <identifiersep> document . load <identifiersep> attachments <identifiersep> content <identifiersep> safe ( xcontext ) ; x <identifiersep> wiki <identifiersep> document previous <identifiersep> document ; xar <identifiersep> extension <identifiersep> plan xar <identifiersep> extension <identifiersep> plan = configuration . get <identifiersep> xar <identifiersep> extension <identifiersep> plan ( ) ; <ect>
execution <identifiersep> context context = this . execution . get <identifiersep> context ( ) ; if ( context != null && context . get <identifiersep> property ( contextkey <identifiersep> packageconfiguration ) == null ) { job current <identifiersep> job = null ; try { current <identifiersep> job = this . component <identifiersep> manager . < job <identifiersep> context > get <identifiersep> instance ( job <identifiersep> context . class ) . get <identifiersep> current <identifiersep> job ( ) ; } catch ( exception e ) { <LOG> } if ( current <identifiersep> job != null ) { package <identifiersep> configuration configuration = new package <identifiersep> configuration ( ) ; context . set <identifiersep> property ( contextkey <identifiersep> packageconfiguration , configuration ) ; document <identifiersep> reference user <identifiersep> reference = get <identifiersep> request <identifiersep> user <identifiersep> reference ( abstract <identifiersep> extension <identifiersep> validator . property <identifiersep> userreference , request ) ; configuration . set <identifiersep> interactive ( request . is <identifiersep> interactive ( ) ) ; <ect>
<comment> <LOG> } } <comment> <ect>
<comment> <LOG> } return steps ; } private void add <identifiersep> default <identifiersep> ui <identifiersep> step ( list < distribution <identifiersep> step > steps , boolean is <identifiersep> main <identifiersep> wiki ) { extension <identifiersep> id ui ; if ( is <identifiersep> main <identifiersep> wiki ) { ui = get <identifiersep> ui <identifiersep> extension <identifiersep> id ( ) ; <ect>
} else { <comment> <LOG> } } } @ override public distribution <identifiersep> job <identifiersep> status get <identifiersep> previous <identifiersep> status ( ) { if ( is <identifiersep> main <identifiersep> wiki ( ) ) { return this . distribution <identifiersep> manager . get <identifiersep> previous <identifiersep> farm <identifiersep> job <identifiersep> status ( ) ; } else { <ect>
{ wiki <identifiersep> descriptor <identifiersep> manager wiki <identifiersep> descriptor <identifiersep> manager = this . wiki <identifiersep> descriptor <identifiersep> manager <identifiersep> provider . get ( ) ; collection < string > wiki <identifiersep> ids ; try { wiki <identifiersep> ids = wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> all <identifiersep> ids ( ) ; } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { <LOG> set <identifiersep> state ( null ) ; return ; } extension <identifiersep> id wiki <identifiersep> extension <identifiersep> ui = this . distribution <identifiersep> manager . get <identifiersep> wiki <identifiersep> ui <identifiersep> extension <identifiersep> id ( ) ; for ( string wiki <identifiersep> id : wiki <identifiersep> ids ) { if ( ! wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> main <identifiersep> wiki <identifiersep> id ( ) . equals ( wiki <identifiersep> id ) ) { string namespace = new namespace ( <string_literal> , wiki <identifiersep> id ) . to <identifiersep> string ( ) ; <ect>
return ; } wiki <identifiersep> descriptor <identifiersep> manager wiki <identifiersep> descriptor <identifiersep> manager = this . wiki <identifiersep> descriptor <identifiersep> manager <identifiersep> provider . get ( ) ; collection < string > wiki <identifiersep> ids ; try { wiki <identifiersep> ids = wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> all <identifiersep> ids ( ) ; } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { <LOG> set <identifiersep> state ( null ) ; return ; } string main <identifiersep> wiki = wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> main <identifiersep> wiki <identifiersep> id ( ) ; <comment> <ect>
try { distribution <identifiersep> step welcome <identifiersep> step = this . component <identifiersep> manager . < distribution <identifiersep> step > get <identifiersep> instance ( distribution <identifiersep> step . class , report <identifiersep> distribution <identifiersep> step . id ) ; welcome <identifiersep> step . set <identifiersep> state ( state . completed ) ; steps . add ( welcome <identifiersep> step ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e1 ) { <LOG> } } <comment> <ect>
distribution <identifiersep> job <identifiersep> thread . set <identifiersep> name ( <string_literal> + wiki + <string_literal> ) ; distribution <identifiersep> job <identifiersep> thread . start ( ) ; <comment> <LOG> } return null ; } private distribution <identifiersep> state get <identifiersep> distribution <identifiersep> state ( distribution <identifiersep> job <identifiersep> status previous <identifiersep> status ) { return distribution <identifiersep> job <identifiersep> status . get <identifiersep> distribution <identifiersep> state ( previous <identifiersep> status != null ? previous <identifiersep> status . get <identifiersep> distribution <identifiersep> extension ( ) : null , this . distribution <identifiersep> extension != null ? this . distribution <identifiersep> extension . get <identifiersep> id ( ) : null ) ; <ect>
{ x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; document <identifiersep> reference current <identifiersep> user = xcontext . get <identifiersep> user <identifiersep> reference ( ) ; <comment> <LOG> return true ; } <comment> <ect>
remote <identifiersep> extension <identifiersep> job <identifiersep> started <identifiersep> event job <identifiersep> event = ( remote <identifiersep> extension <identifiersep> job <identifiersep> started <identifiersep> event ) event ; try { job job = this . job <identifiersep> executor . execute ( job <identifiersep> event . get <identifiersep> job <identifiersep> type ( ) , job <identifiersep> event . get <identifiersep> request ( ) ) ; for ( log <identifiersep> event log : job . get <identifiersep> status ( ) . get <identifiersep> log ( ) . get <identifiersep> logs ( log <identifiersep> level . error ) ) { this . logger . error ( log . get <identifiersep> message ( ) , log . get <identifiersep> argument <identifiersep> array ( ) ) ; } } catch ( job <identifiersep> exception e ) { <LOG> } } } <ect>
super ( name , class <identifiersep> name , context ) ; init ( context ) ; } @ override public void init ( x <identifiersep> wiki <identifiersep> context context ) { super . init ( context ) ; <LOG> file dir = this . environment . get <identifiersep> temporary <identifiersep> directory ( ) ; temp <identifiersep> dir = new file ( dir , <string_literal> ) ; try { temp <identifiersep> dir . mkdirs ( ) ; } catch ( exception e1 ) { logger . warn ( <string_literal> + temp <identifiersep> dir , e1 ) ; <ect>
} catch ( exception e1 ) { logger . warn ( <string_literal> + temp <identifiersep> dir , e1 ) ; dir = new file ( context . get <identifiersep> wiki ( ) . param ( <string_literal> ) ) ; try { temp <identifiersep> dir = new file ( dir , <string_literal> ) ; } catch ( exception e2 ) { <LOG> } } } @ override public string get <identifiersep> name ( ) { return <string_literal> ; } public chart generate <identifiersep> chart ( chart <identifiersep> params params , x <identifiersep> wiki <identifiersep> context context ) throws generate <identifiersep> exception { <ect>
if ( selection == null || selection . trim ( ) . length ( ) == 0 ) { <comment> <LOG> } finally { <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> + <string_literal> + object . get <identifiersep> number ( ) + <string_literal> , e ) ; } } } return annotation ; } <comment> <ect>
<comment> <LOG> } } } <comment> <ect>
this . logger . info ( <string_literal> , reference ) ; } else { xcontext . get <identifiersep> wiki ( ) . delete <identifiersep> all <identifiersep> documents ( document , xcontext ) ; this . logger . info ( <string_literal> , reference ) ; } return true ; } catch ( exception e ) { <LOG> return false ; } } @ override public boolean remove <identifiersep> lock ( document <identifiersep> reference reference ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { <ect>
if ( document . get <identifiersep> lock ( xcontext ) != null ) { document . remove <identifiersep> lock ( xcontext ) ; this . logger . info ( <string_literal> , reference ) ; } return true ; } catch ( exception e ) { <comment> <LOG> return false ; } } @ override public void create <identifiersep> redirect ( document <identifiersep> reference old <identifiersep> reference , document <identifiersep> reference new <identifiersep> reference ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; document <identifiersep> reference redirect <identifiersep> class <identifiersep> reference = <ect>
query . bind <identifiersep> value ( <string_literal> , space <identifiersep> prefix + <string_literal> ) ; list < document <identifiersep> reference > descendants = new array <identifiersep> list < > ( ) ; for ( object full <identifiersep> name : query . execute ( ) ) { descendants . add ( this . explicit <identifiersep> document <identifiersep> reference <identifiersep> resolver . resolve ( ( string ) full <identifiersep> name , space <identifiersep> reference ) ) ; } return descendants ; } catch ( exception e ) { <LOG> return collections . empty <identifiersep> list ( ) ; } } @ override public boolean update <identifiersep> parent <identifiersep> field ( final document <identifiersep> reference old <identifiersep> parent <identifiersep> reference , final document <identifiersep> reference new <identifiersep> parent <identifiersep> reference ) { x <identifiersep> wiki <identifiersep> context context = xcontext <identifiersep> provider . get ( ) ; <ect>
document . set <identifiersep> parent <identifiersep> reference ( hierarchical <identifiersep> parent ) ; save = true ; } } if ( save ) { wiki . save <identifiersep> document ( document , <string_literal> , true , context ) ; this . logger . info ( <string_literal> , document <identifiersep> reference ) ; } } catch ( exception e ) { <LOG> } } private document <identifiersep> reference get <identifiersep> hierarchical <identifiersep> parent ( document <identifiersep> reference document <identifiersep> reference ) { final string space <identifiersep> home <identifiersep> page = entity <identifiersep> reference <identifiersep> provider . get <identifiersep> default <identifiersep> reference ( entity <identifiersep> type . document ) . get <identifiersep> name ( ) ; entity <identifiersep> reference parent <identifiersep> of <identifiersep> the <identifiersep> space = document <identifiersep> reference . get <identifiersep> last <identifiersep> space <identifiersep> reference ( ) . get <identifiersep> parent ( ) ; boolean page <identifiersep> is <identifiersep> not <identifiersep> terminal = document <identifiersep> reference . get <identifiersep> name ( ) . equals ( space <identifiersep> home <identifiersep> page ) ; <comment> <ect>
} else if ( check <identifiersep> context <identifiersep> user && ! can <identifiersep> restore <identifiersep> deleted <identifiersep> document ( deleted <identifiersep> document <identifiersep> id , context . get <identifiersep> user <identifiersep> reference ( ) ) ) { logger . error ( <string_literal> , deleted <identifiersep> document <identifiersep> reference , deleted <identifiersep> document <identifiersep> id ) ; } else { <comment> <LOG> return true ; } } catch ( exception e ) { <comment> <ect>
try { x <identifiersep> wiki <identifiersep> deleted <identifiersep> document [ ] deleted <identifiersep> documents = xwiki . get <identifiersep> recycle <identifiersep> bin <identifiersep> store ( ) . get <identifiersep> all <identifiersep> deleted <identifiersep> documents ( batch <identifiersep> id , false , context , true ) ; for ( x <identifiersep> wiki <identifiersep> deleted <identifiersep> document deleted <identifiersep> document : deleted <identifiersep> documents ) { result . add ( deleted <identifiersep> document . get <identifiersep> id ( ) ) ; } } catch ( exception e ) { <LOG> } return result ; } @ override public boolean can <identifiersep> restore <identifiersep> deleted <identifiersep> document ( long deleted <identifiersep> document <identifiersep> id , document <identifiersep> reference user <identifiersep> reference ) { boolean result = false ; x <identifiersep> wiki <identifiersep> context context = this . xcontext <identifiersep> provider . get ( ) ; <ect>
public void update <identifiersep> relative <identifiersep> links ( document <identifiersep> reference old <identifiersep> reference , document <identifiersep> reference new <identifiersep> reference ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { update <identifiersep> relative <identifiersep> links ( xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( new <identifiersep> reference , xcontext ) , old <identifiersep> reference ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } private void update <identifiersep> relative <identifiersep> links ( x <identifiersep> wiki <identifiersep> document document , document <identifiersep> reference old <identifiersep> document <identifiersep> reference ) throws x <identifiersep> wiki <identifiersep> exception { <comment> <ect>
linked <identifiersep> resource <identifiersep> helper . set <identifiersep> resource <identifiersep> reference <identifiersep> string ( block , serialized <identifiersep> link <identifiersep> reference ) ; } } if ( modified ) { document . set <identifiersep> content ( xdom ) ; save <identifiersep> document <identifiersep> preserving <identifiersep> content <identifiersep> author ( document , <string_literal> , true ) ; this . logger . info ( <string_literal> , document . get <identifiersep> document <identifiersep> reference ( ) ) ; } else { <LOG> } } <comment> <ect>
@ override protected void process ( entity <identifiersep> reference source ) { <comment> <LOG> return ; } <comment> <ect>
} else if ( destination . get <identifiersep> type ( ) == entity <identifiersep> type . space ) { maybe <identifiersep> move ( source , new document <identifiersep> reference ( source . get <identifiersep> name ( ) , new space <identifiersep> reference ( destination ) ) ) ; } else if ( destination . get <identifiersep> type ( ) == entity <identifiersep> type . document && is <identifiersep> space <identifiersep> home <identifiersep> reference ( new document <identifiersep> reference ( destination ) ) ) { maybe <identifiersep> move ( source , new document <identifiersep> reference ( source . get <identifiersep> name ( ) , new space <identifiersep> reference ( destination . get <identifiersep> parent ( ) ) ) ) ; } else { <LOG> } } protected void process ( space <identifiersep> reference source , entity <identifiersep> reference destination ) { if ( destination . get <identifiersep> type ( ) == entity <identifiersep> type . space || destination . get <identifiersep> type ( ) == entity <identifiersep> type . wiki ) { process ( source , new space <identifiersep> reference ( source . get <identifiersep> name ( ) , destination ) ) ; } else if ( destination . get <identifiersep> type ( ) == entity <identifiersep> type . document && is <identifiersep> space <identifiersep> home <identifiersep> reference ( new document <identifiersep> reference ( destination ) ) ) { <ect>
protected void maybe <identifiersep> move ( document <identifiersep> reference old <identifiersep> reference , document <identifiersep> reference new <identifiersep> reference ) { <comment> <LOG> } else if ( ! this . model <identifiersep> bridge . exists ( old <identifiersep> reference ) ) { this . logger . warn ( <string_literal> , old <identifiersep> reference ) ; } else if ( this . request . is <identifiersep> delete <identifiersep> source ( ) && ! has <identifiersep> access ( right . delete , old <identifiersep> reference ) ) { <comment> <ect>
<comment> <LOG> } else if ( ! has <identifiersep> access ( right . view , new <identifiersep> reference ) || ! has <identifiersep> access ( right . edit , new <identifiersep> reference ) || ( this . model <identifiersep> bridge . exists ( new <identifiersep> reference ) && ! has <identifiersep> access ( right . delete , new <identifiersep> reference ) ) ) { this . logger . error ( <string_literal> , new <identifiersep> reference ) ; } else { move ( old <identifiersep> reference , new <identifiersep> reference ) ; <ect>
{ collection < string > wiki <identifiersep> ids = collections . singleton ( old <identifiersep> reference . get <identifiersep> wiki <identifiersep> reference ( ) . get <identifiersep> name ( ) ) ; if ( this . request . is <identifiersep> update <identifiersep> links <identifiersep> on <identifiersep> farm ( ) ) { try { wiki <identifiersep> ids = this . wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> all <identifiersep> ids ( ) ; } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { <LOG> } } boolean pop <identifiersep> level <identifiersep> progress = false ; try { if ( wiki <identifiersep> ids . size ( ) > 0 ) { this . progress <identifiersep> manager . push <identifiersep> level <identifiersep> progress ( wiki <identifiersep> ids . size ( ) , this ) ; pop <identifiersep> level <identifiersep> progress = true ; } for ( string wiki <identifiersep> id : wiki <identifiersep> ids ) { <ect>
process ( new document <identifiersep> reference ( entity <identifiersep> reference ) ) ; break ; case space : process ( new space <identifiersep> reference ( entity <identifiersep> reference ) ) ; break ; default : <LOG> } } private void process ( document <identifiersep> reference document <identifiersep> reference ) { if ( this . request . is <identifiersep> deep ( ) && is <identifiersep> space <identifiersep> home <identifiersep> reference ( document <identifiersep> reference ) ) { process ( document <identifiersep> reference . get <identifiersep> last <identifiersep> space <identifiersep> reference ( ) ) ; } else { maybe <identifiersep> delete ( document <identifiersep> reference ) ; <ect>
{ entity <identifiersep> selection entity <identifiersep> selection = concerned <identifiersep> entities . get ( document <identifiersep> reference ) ; if ( entity <identifiersep> selection != null && ! entity <identifiersep> selection . is <identifiersep> selected ( ) ) { <comment> <LOG> } else if ( ! has <identifiersep> access ( right . delete , document <identifiersep> reference ) ) { this . logger . error ( <string_literal> , document <identifiersep> reference ) ; } else { this . model <identifiersep> bridge . delete ( document <identifiersep> reference ) ; } } } <ect>
get <identifiersep> entities ( new document <identifiersep> reference ( entity <identifiersep> reference ) ) ; break ; case space : get <identifiersep> entities ( new space <identifiersep> reference ( entity <identifiersep> reference ) ) ; break ; default : <LOG> } } private void get <identifiersep> entities ( document <identifiersep> reference document <identifiersep> reference ) { if ( this . request . is <identifiersep> deep ( ) && is <identifiersep> space <identifiersep> home <identifiersep> reference ( document <identifiersep> reference ) ) { get <identifiersep> entities ( document <identifiersep> reference . get <identifiersep> last <identifiersep> space <identifiersep> reference ( ) ) ; } else { this . concerned <identifiersep> entities . put ( document <identifiersep> reference , new entity <identifiersep> selection ( document <identifiersep> reference ) ) ; <ect>
case http <identifiersep> status . sc <identifiersep> unauthorized : <comment> <LOG> break ; case http <identifiersep> status . sc <identifiersep> not <identifiersep> found : <comment> <ect>
try { return validator . validate ( ) ; } catch ( escaping <identifiersep> error error ) { <comment> <LOG> return collections . empty <identifiersep> list ( ) ; } } <comment> <ect>
public void test <identifiersep> add <identifiersep> group <identifiersep> to <identifiersep> group ( ) { string group = <string_literal> ; create <identifiersep> group ( group ) ; open <identifiersep> groups <identifiersep> page ( ) ; string xpath = <string_literal> + group + <string_literal> ; <LOG> wait <identifiersep> for <identifiersep> condition ( <string_literal> + xpath + <string_literal> ) ; get <identifiersep> selenium ( ) . click ( <string_literal> + group + <string_literal> ) ; wait <identifiersep> for <identifiersep> lightbox ( <string_literal> ) ; set <identifiersep> field <identifiersep> value ( <string_literal> , <string_literal> ) ; click <identifiersep> link <identifiersep> with <identifiersep> locator ( <string_literal> , false ) ; string xpath <identifiersep> prefix = <string_literal> ; <ect>
string <identifiersep> buffer message = new string <identifiersep> buffer ( ) ; message . append ( <string_literal> + this . target . get <identifiersep> name ( ) ) ; boolean has <identifiersep> error = false ; for ( validation <identifiersep> error error : errors ) { if ( error . get <identifiersep> type ( ) == validation <identifiersep> error . type . warning ) { if ( error . get <identifiersep> line ( ) >= 0 ) { <LOG> + error . get <identifiersep> message ( ) ) ; } else { system . out . println ( <string_literal> + error . get <identifiersep> message ( ) ) ; } } else { if ( error . get <identifiersep> line ( ) >= 0 ) { message . append ( <string_literal> + error . to <identifiersep> string ( ) + <string_literal> + error . get <identifiersep> line ( ) + <string_literal> <ect>
message . append ( <string_literal> + error . to <identifiersep> string ( ) + <string_literal> + error . get <identifiersep> line ( ) + <string_literal> + error . get <identifiersep> column ( ) + <string_literal> ) ; } else { message . append ( <string_literal> + error . to <identifiersep> string ( ) ) ; } has <identifiersep> error = true ; } } if ( has <identifiersep> error ) { <LOG> system . err . println ( <string_literal> ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new string <identifiersep> reader ( new string ( response <identifiersep> body ) ) ) ; int index = 1 ; for ( string line = reader . read <identifiersep> line ( ) ; line != null ; line = reader . read <identifiersep> line ( ) , ++ index ) { system . err . println ( index + <string_literal> + line ) ; } } assert <identifiersep> false ( message . to <identifiersep> string ( ) , has <identifiersep> error ) ; <ect>
if ( has <identifiersep> error ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new string <identifiersep> reader ( new string ( response <identifiersep> body ) ) ) ; int index = 1 ; for ( string line = reader . read <identifiersep> line ( ) ; line != null ; line = reader . read <identifiersep> line ( ) , ++ index ) { <LOG> } } assert <identifiersep> false ( message . to <identifiersep> string ( ) , has <identifiersep> error ) ; } protected boolean has <identifiersep> log <identifiersep> errors ( string output ) { return output . index <identifiersep> of ( <string_literal> ) >= 0 || output . index <identifiersep> of ( <string_literal> ) >= 0 ; } protected boolean has <identifiersep> log <identifiersep> warnings ( string output ) { <ect>
error <identifiersep> lines . add ( error . get <identifiersep> line ( ) - 1 ) ; error <identifiersep> lines . add ( error . get <identifiersep> line ( ) ) ; error <identifiersep> lines . add ( error . get <identifiersep> line ( ) + 1 ) ; error <identifiersep> lines . add ( error . get <identifiersep> line ( ) + <number_literal> ) ; has <identifiersep> error = true ; } } if ( has <identifiersep> error ) { <LOG> system . err . println ( <string_literal> ) ; message . append ( <string_literal> ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new string <identifiersep> reader ( new string ( response <identifiersep> body ) ) ) ; int index = 1 ; int last <identifiersep> error <identifiersep> line = - 1 ; for ( string line = reader . read <identifiersep> line ( ) ; line != null ; line = reader . read <identifiersep> line ( ) , ++ index ) { <ect>
public void life <identifiersep> cycle <identifiersep> started ( life <identifiersep> cycle event ) { logger . info ( delimiter ) ; try { string server <identifiersep> url = <string_literal> + inet <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) . get <identifiersep> canonical <identifiersep> host <identifiersep> name ( ) + <string_literal> + system . get <identifiersep> property ( <string_literal> , <string_literal> ) + <string_literal> ; <LOG> } catch ( unknown <identifiersep> host <identifiersep> exception ex ) { <comment> <ect>
{ logger . info ( delimiter ) ; logger . info ( messages . get <identifiersep> string ( <string_literal> ) ) ; } @ override public void life <identifiersep> cycle <identifiersep> stopped ( life <identifiersep> cycle event ) { <LOG> } } <ect>
