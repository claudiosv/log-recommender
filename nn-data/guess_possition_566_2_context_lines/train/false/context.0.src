throw new parse <identifiersep> exception ( tpe . get <identifiersep> message ( ) , 0 ) ; } catch ( dnssec <identifiersep> runtime <identifiersep> exception e ) { throw new dnssec <identifiersep> exception ( e ) ; } if ( records == null ) <LOG> { return null ; } list < string [ ] > rec <identifiersep> vals = new array <identifiersep> list < > ( records . length ) ; for ( int i = 0 ; i < records . length ; i ++ ) { string [ ] rec <identifiersep> val = new string [ <number_literal> ] ; <ect>
: ( ( a <identifiersep> record ) r ) . get <identifiersep> address ( ) . get <identifiersep> address ( ) ) , port ) ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) <LOG> { } } } v6lookup = ! v6lookup ; logger . trace ( <string_literal> + addresses ) ; return addresses . to <identifiersep> array ( new inet <identifiersep> socket <identifiersep> address [ 0 ] ) ; } <comment> <ect>
<comment> <LOG> { throw new parse <identifiersep> exception ( tpe . get <identifiersep> message ( ) , 0 ) ; } catch ( dnssec <identifiersep> runtime <identifiersep> exception e ) { throw new dnssec <identifiersep> exception ( e ) ; <ect>
<comment> <LOG> { throw new parse <identifiersep> exception ( tpe . get <identifiersep> message ( ) , 0 ) ; } catch ( dnssec <identifiersep> runtime <identifiersep> exception e ) { throw new dnssec <identifiersep> exception ( e ) ; <ect>
enumeration < network <identifiersep> interface > ifaces ; try { ifaces = network <identifiersep> interface . get <identifiersep> network <identifiersep> interfaces ( ) ; } catch ( socket <identifiersep> exception e ) <LOG> { return in4 <identifiersep> addr <identifiersep> any ; } while ( ifaces . has <identifiersep> more <identifiersep> elements ( ) ) { enumeration < inet <identifiersep> address > addrs = ifaces . next <identifiersep> element ( ) . get <identifiersep> inet <identifiersep> addresses ( ) ; <ect>
{ protocol <identifiersep> provider . register ( sec <identifiersep> auth ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { handle <identifiersep> operation <identifiersep> failed <identifiersep> exception ( ex ) ; } catch ( throwable ex ) <LOG> { account <identifiersep> id account <identifiersep> id = protocol <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) ; util <identifiersep> activator . get <identifiersep> alert <identifiersep> ui <identifiersep> service ( ) . show <identifiersep> alert <identifiersep> dialog ( util <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , util <identifiersep> activator . get <identifiersep> resources ( ) <ect>
return parser . parse ( in ) ; } finally { in . close ( ) ; } } catch ( exception ex ) <LOG> { return html ; } } <comment> private static class html <identifiersep> parser <identifiersep> callback <ect>
int min <identifiersep> port = integer . parse <identifiersep> int ( new <identifiersep> min <identifiersep> port <identifiersep> string ) ; int max <identifiersep> port = integer . parse <identifiersep> int ( new <identifiersep> max <identifiersep> port <identifiersep> string ) ; return new port <identifiersep> tracker ( min <identifiersep> port , max <identifiersep> port ) ; } catch ( exception exc ) <comment> <LOG> + <string_literal> + new <identifiersep> max <identifiersep> port <identifiersep> string + <string_literal> ) ; return null ; } } } <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <comment> <LOG> service <identifiersep> impl = create <identifiersep> service <identifiersep> impl ( ) ; bundle <identifiersep> context . register <identifiersep> service ( service <identifiersep> class . get <identifiersep> name ( ) , service <identifiersep> impl , <ect>
{ phones <identifiersep> list . add ( number ) ; continue ; } phones <identifiersep> list . add ( number + <string_literal> + get <identifiersep> localized <identifiersep> phone <identifiersep> number ( d ) + <string_literal> ) ; } } } } catch ( throwable t ) <LOG> { } } return phones <identifiersep> list ; } <comment> <ect>
{ <comment> <LOG> <comment> <ect>
if ( loopback == null ) { loopback = network <identifiersep> interface . get <identifiersep> network <identifiersep> interfaces ( ) . next <identifiersep> element ( ) ; } } catch ( socket <identifiersep> exception exc ) { <LOG> <comment> <ect>
catch ( exception exc ) { logger . error ( <string_literal> , exc ) ; return null ; } string lock <identifiersep> address <identifiersep> str = lock <identifiersep> properties . get <identifiersep> property ( pname <identifiersep> lock <identifiersep> address ) ; if ( lock <identifiersep> address <identifiersep> str == null ) <LOG> { return null ; } string lock <identifiersep> port = lock <identifiersep> properties . get <identifiersep> property ( pname <identifiersep> lock <identifiersep> port ) ; if ( lock <identifiersep> port == null ) { logger . error ( <string_literal> ) ; <ect>
if ( lock <identifiersep> port == null ) { logger . error ( <string_literal> ) ; return null ; } inet <identifiersep> address lock <identifiersep> address = find <identifiersep> local <identifiersep> address ( lock <identifiersep> address <identifiersep> str ) ; if ( lock <identifiersep> address == null ) <LOG> { return null ; } int port ; try { port = integer . parse <identifiersep> int ( lock <identifiersep> port ) ; <ect>
<string_literal> + <string_literal> ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( io <identifiersep> exception e ) <LOG> { return lock <identifiersep> error ; } return success ; } <comment> <ect>
print <identifiersep> stream . flush ( ) ; print <identifiersep> stream . close ( ) ; inter <identifiersep> instance <identifiersep> socket . close ( ) ; } <comment> <LOG> { return lock <identifiersep> error ; } return success ; } <comment> <ect>
{ buffered <identifiersep> reader line <identifiersep> reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( inter <identifiersep> instance <identifiersep> socket . get <identifiersep> input <identifiersep> stream ( ) ) ) ; <comment> <LOG> message = line <identifiersep> reader . read <identifiersep> line ( ) ; synchronized ( this ) { notify <identifiersep> all ( ) ; } } catch ( io <identifiersep> exception exc ) { <ect>
<comment> public void handle <identifiersep> unknown <identifiersep> arg ( string arg ) <LOG> { handle <identifiersep> help <identifiersep> arg ( ) ; } <comment> <ect>
<comment> public void handle <identifiersep> help <identifiersep> arg ( ) { handle <identifiersep> version <identifiersep> arg ( ) ; <LOG> system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
<comment> public void handle <identifiersep> help <identifiersep> arg ( ) { handle <identifiersep> version <identifiersep> arg ( ) ; system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
{ handle <identifiersep> version <identifiersep> arg ( ) ; system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; } <comment> <ect>
system . out . println ( <string_literal> + get <identifiersep> package <identifiersep> name ( ) + <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; } <comment> <ect>
system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; } <comment> <ect>
public void start ( bundle <identifiersep> context context ) throws exception { bundle <identifiersep> context = context ; if ( os <identifiersep> utils . is <identifiersep> android ) <LOG> load <identifiersep> logging <identifiersep> config ( ) ; thread . set <identifiersep> default <identifiersep> uncaught <identifiersep> exception <identifiersep> handler ( this ) ; } <comment> <ect>
@ override protected plugin <identifiersep> component get <identifiersep> plugin <identifiersep> instance ( ) { return new about <identifiersep> window <identifiersep> plugin <identifiersep> component ( get <identifiersep> container ( ) , this ) ; } } , <LOG> help <identifiersep> menu <identifiersep> filter ) ; <comment> <ect>
{ bg <identifiersep> image = image <identifiersep> io . read ( branding <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> image <identifiersep> url ( <string_literal> ) ) ; this . set <identifiersep> preferred <identifiersep> size ( new dimension ( bg <identifiersep> image . get <identifiersep> width ( this ) , bg <identifiersep> image . get <identifiersep> height ( this ) ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { bg <identifiersep> image = null ; } } @ override protected void paint <identifiersep> component ( graphics g ) { super . paint <identifiersep> component ( g ) ; <ect>
document . insert <identifiersep> after <identifiersep> end ( root . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } public void insert <identifiersep> after <identifiersep> start ( string text ) { element root = this . document . get <identifiersep> default <identifiersep> root <identifiersep> element ( ) ; try { this . document . insert <identifiersep> before <identifiersep> start ( root <ect>
element root = this . document . get <identifiersep> default <identifiersep> root <identifiersep> element ( ) ; try { this . document . insert <identifiersep> before <identifiersep> start ( root . get <identifiersep> element ( 0 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } } <ect>
try { <comment> <LOG> { } boolean has <identifiersep> registered <identifiersep> accounts = false ; if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { <ect>
image image = null ; try { image = image <identifiersep> io . read ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( wizard . get <identifiersep> page <identifiersep> image ( ) ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { } if ( image != null ) { image = image . get <identifiersep> scaled <identifiersep> instance ( <number_literal> , <number_literal> , image . scale <identifiersep> smooth ) ; protocol <identifiersep> label . set <identifiersep> icon ( new image <identifiersep> icon ( image ) ) ; } if ( is <identifiersep> preferred <identifiersep> wizard ) <ect>
{ <comment> <LOG> { } for ( int i = 0 ; i < ser <identifiersep> refs . length ; i ++ ) { protocol <identifiersep> provider <identifiersep> factory provider <identifiersep> factory = ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ i ] ) ; provider <identifiersep> factories <identifiersep> map <ect>
<string_literal> ) , resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , popup <identifiersep> dialog . information <identifiersep> message ) ; } catch ( exception e ) <LOG> { } finally { <comment> <ect>
tools <identifiersep> menu <identifiersep> filter ) ; } <comment> <LOG> { <comment> <ect>
} ; m <identifiersep> update <identifiersep> executor = executors . new <identifiersep> single <identifiersep> thread <identifiersep> scheduled <identifiersep> executor ( ) ; m <identifiersep> update <identifiersep> executor . schedule <identifiersep> at <identifiersep> fixed <identifiersep> rate ( update <identifiersep> runnable , hours <identifiersep> to <identifiersep> wait , <number_literal> * <number_literal> * <number_literal> , <LOG> time <identifiersep> unit . seconds ) ; } } <comment> @ override <ect>
. parse ( resources . get <identifiersep> property <identifiersep> input <identifiersep> stream ( <string_literal> ) ) ; } catch ( sax <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( parser <identifiersep> configuration <identifiersep> exception e ) <LOG> { } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } element root = server <identifiersep> comments . get <identifiersep> document <identifiersep> element ( ) ; comments <identifiersep> list = root . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) ; <ect>
{ j <identifiersep> button register <identifiersep> button = new j <identifiersep> button ( text ) ; register <identifiersep> button . add <identifiersep> action <identifiersep> listener ( new action <identifiersep> listener ( ) { public void action <identifiersep> performed ( action <identifiersep> event evt ) <LOG> { if ( parent <identifiersep> form . is <identifiersep> web <identifiersep> signup <identifiersep> supported ( ) ) { parent <identifiersep> form . web <identifiersep> signup ( ) ; } } } ) ; return register <identifiersep> button ; <ect>
+ <string_literal> + protocol <identifiersep> names . jabber + <string_literal> ; try { ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) <LOG> { } return ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bc ) <LOG> { bundle <identifiersep> context = bc ; service <identifiersep> reference ui <identifiersep> service <identifiersep> ref = bundle <identifiersep> context . get <identifiersep> service <identifiersep> reference ( ui <identifiersep> service . class . get <identifiersep> name ( ) ) ; ui <identifiersep> service = ( ui <identifiersep> service ) bundle <identifiersep> context . get <identifiersep> service ( ui <identifiersep> service <identifiersep> ref ) ; wizard <identifiersep> container = ui <identifiersep> service . get <identifiersep> account <identifiersep> reg <identifiersep> wizard <identifiersep> container ( ) ; <ect>
= ( ( blf <identifiersep> source <identifiersep> contact ) action <identifiersep> source ) . get <identifiersep> line ( ) ; operation <identifiersep> set <identifiersep> telephony <identifiersep> blf opset = line . get <identifiersep> provider ( ) . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> telephony <identifiersep> blf . class ) ; opset . pickup ( line ) ; } catch ( exception ex ) <LOG> { } } } ) . start ( ) ; } <comment> <ect>
container <identifiersep> filter . put ( protocol <identifiersep> provider <identifiersep> factory . protocol , protocol <identifiersep> names . irc ) ; bundle <identifiersep> context . register <identifiersep> service ( account <identifiersep> registration <identifiersep> wizard . class . get <identifiersep> name ( ) , irc <identifiersep> wizard , container <identifiersep> filter ) ; <LOG> { } } <comment> <ect>
bundle <identifiersep> context . register <identifiersep> service ( configuration <identifiersep> form . class . get <identifiersep> name ( ) , panel , properties ) ; } } ) . start ( ) ; } <LOG> } ) ; } <comment> <ect>
cbo <identifiersep> alias . set <identifiersep> selected <identifiersep> item ( entry . get <identifiersep> alias ( ) ) ; } } catch ( key <identifiersep> store <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; show <identifiersep> generic <identifiersep> error ( <string_literal> , ex ) ; } catch ( provider <identifiersep> exception ex ) <LOG> { show <identifiersep> generic <identifiersep> error ( <string_literal> , ex ) ; } } private void init <identifiersep> components ( ) { set <identifiersep> title ( r . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; set <identifiersep> layout ( new border <identifiersep> layout ( ) ) ; <ect>
) && cbo <identifiersep> alias . get <identifiersep> selected <identifiersep> item ( ) != null ) { txt <identifiersep> display <identifiersep> name . set <identifiersep> text ( cbo <identifiersep> alias . get <identifiersep> selected <identifiersep> item ( ) . to <identifiersep> string ( ) ) ; } } catch ( key <identifiersep> store <identifiersep> exception e ) { <LOG> cbo <identifiersep> alias . remove <identifiersep> all <identifiersep> items ( ) ; show <identifiersep> generic <identifiersep> error ( <string_literal> , e ) ; } } private void show <identifiersep> generic <identifiersep> error ( string msg , throwable e ) { j <identifiersep> option <identifiersep> pane . show <identifiersep> message <identifiersep> dialog ( this , <ect>
public void action <identifiersep> performed ( action <identifiersep> event e ) { try { set <identifiersep> autostart ( auto <identifiersep> start <identifiersep> check <identifiersep> box . is <identifiersep> selected ( ) ) ; } catch ( exception ex ) <LOG> { } } } ) ; try { auto <identifiersep> start <identifiersep> check <identifiersep> box . set <identifiersep> selected ( windows <identifiersep> startup . is <identifiersep> startup <identifiersep> enabled ( get <identifiersep> application <identifiersep> name ( ) ) ) ; <ect>
{ advapi32util . registry <identifiersep> delete <identifiersep> value ( win <identifiersep> reg . hkey <identifiersep> current <identifiersep> user , registry <identifiersep> startup <identifiersep> key , app <identifiersep> name ) ; } catch ( throwable t ) <LOG> { } } } } <ect>
else bundle <identifiersep> context . add <identifiersep> service <identifiersep> listener ( this ) ; } catch ( throwable t ) { <comment> <LOG> logger . error ( <string_literal> , t ) ; } } <comment> @ override <ect>
<comment> private void poly <identifiersep> operation ( mouse <identifiersep> event e ) <LOG> { graphics g = draw <identifiersep> canvas . get <identifiersep> graphics ( ) ; g . set <identifiersep> color ( current <identifiersep> color ) ; if ( done <identifiersep> drawing ) { re <identifiersep> init <identifiersep> mouse ( e ) ; <ect>
<comment> public void receive <identifiersep> whiteboard <identifiersep> object ( whiteboard <identifiersep> object wbo ) <LOG> { whiteboard <identifiersep> shape ws = create <identifiersep> whiteboard <identifiersep> shape ( wbo ) ; for ( int i = 0 ; i < display <identifiersep> list . size ( ) ; i ++ ) { whiteboard <identifiersep> shape wbs = display <identifiersep> list . get ( i ) ; if ( wbs . get <identifiersep> id ( ) . equals ( wbo . get <identifiersep> id ( ) ) ) <ect>
<comment> private whiteboard <identifiersep> shape create <identifiersep> whiteboard <identifiersep> shape ( whiteboard <identifiersep> object wbo ) <LOG> { whiteboard <identifiersep> shape w <identifiersep> shape = null ; string id = wbo . get <identifiersep> id ( ) ; int color = wbo . get <identifiersep> color ( ) ; int t = wbo . get <identifiersep> thickness ( ) ; if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> path ) <ect>
color c = color . get <identifiersep> color ( <string_literal> , color ) ; list < whiteboard <identifiersep> point > points = path . get <identifiersep> points ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> path ( id , t , c , points ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> poly <identifiersep> line ) { <LOG> whiteboard <identifiersep> object <identifiersep> poly <identifiersep> line p <identifiersep> line = ( whiteboard <identifiersep> object <identifiersep> poly <identifiersep> line ) wbo ; color c = color . get <identifiersep> color ( <string_literal> , color ) ; list < whiteboard <identifiersep> point > points = p <identifiersep> line . get <identifiersep> points ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> poly <identifiersep> line ( id , t , c , points , false ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> polygon ) <ect>
list < whiteboard <identifiersep> point > points = polygon . get <identifiersep> points ( ) ; boolean fill = polygon . is <identifiersep> fill ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> polygon ( id , t , c , points , fill ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> line ) { <LOG> whiteboard <identifiersep> object <identifiersep> line line = ( whiteboard <identifiersep> object <identifiersep> line ) wbo ; whiteboard <identifiersep> point p <identifiersep> start = line . get <identifiersep> whiteboard <identifiersep> point <identifiersep> start ( ) ; whiteboard <identifiersep> point p <identifiersep> end = line . get <identifiersep> whiteboard <identifiersep> point <identifiersep> end ( ) ; color c = color . get <identifiersep> color ( <string_literal> , color ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> line ( id , t , c , p <identifiersep> start , p <identifiersep> end ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> rect ) <ect>
wb <identifiersep> frames . add ( wb <identifiersep> frame ) ; wb <identifiersep> frame . set <identifiersep> contact ( contact ) ; wb <identifiersep> frame . set <identifiersep> visible ( true ) ; wb <identifiersep> session . join ( ) ; wb <identifiersep> session . invite ( contact . get <identifiersep> address ( ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { } catch ( operation <identifiersep> not <identifiersep> supported <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } . start ( ) ; <ect>
{ string master ; boolean correct = true ; master <identifiersep> password <identifiersep> input <identifiersep> service master <identifiersep> password <identifiersep> input <identifiersep> service = security <identifiersep> config <identifiersep> activator . get <identifiersep> master <identifiersep> password <identifiersep> input <identifiersep> service ( ) ; if ( master <identifiersep> password <identifiersep> input <identifiersep> service == null ) <LOG> { return ; } do { master = master <identifiersep> password <identifiersep> input <identifiersep> service . show <identifiersep> input <identifiersep> dialog ( correct ) ; if ( master == null ) <ect>
else { title = <string_literal> ; msg = <string_literal> ; <comment> <LOG> change <identifiersep> master <identifiersep> password <identifiersep> button . set <identifiersep> enabled ( true ) ; } security <identifiersep> config <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( resources . get <identifiersep> i18n <identifiersep> string ( msg ) , <ect>
<comment> private void handle <identifiersep> provider <identifiersep> added ( protocol <identifiersep> provider <identifiersep> service provider ) <LOG> { <comment> <ect>
= provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> sms <identifiersep> messaging . class ) ; if ( op <identifiersep> set <identifiersep> sms != null ) { op <identifiersep> set <identifiersep> sms . add <identifiersep> message <identifiersep> listener ( this ) ; } else <LOG> { } operation <identifiersep> set <identifiersep> multi <identifiersep> user <identifiersep> chat op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat = provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> multi <identifiersep> user <identifiersep> chat . class ) ; if ( op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat != null ) { for ( chat <identifiersep> room room : op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat . get <identifiersep> currently <identifiersep> joined <identifiersep> chat <identifiersep> rooms ( ) ) <ect>
if ( os <identifiersep> utils . is <identifiersep> mac ) com . apple . eawt . application . get <identifiersep> application ( ) . request <identifiersep> user <identifiersep> attention ( true ) ; else alerter . new <identifiersep> instance ( ) . alert ( fr ) ; } catch ( throwable ex ) <LOG> { } } <comment> <ect>
{ start <identifiersep> internal ( bundle <identifiersep> context ) ; } else if ( ! configuration <identifiersep> utils . is <identifiersep> alerter <identifiersep> enabled ( ) && started ) { stop <identifiersep> internal ( bundle <identifiersep> context ) ; } } catch ( throwable t ) <LOG> { } } <comment> <ect>
otr <identifiersep> activator . bundle <identifiersep> context , otr <identifiersep> action <identifiersep> handler . class ) ; if ( action <identifiersep> handler != null ) { action <identifiersep> handler . on <identifiersep> authenticate <identifiersep> link <identifiersep> clicked ( guid ) ; } else <LOG> { } } } @ override public void end <identifiersep> session ( otr <identifiersep> contact otr <identifiersep> contact ) { session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( otr <identifiersep> contact ) ; try <ect>
scheduler . schedule <identifiersep> sc <identifiersep> session <identifiersep> status <identifiersep> change ( otr <identifiersep> contact , sc <identifiersep> session <identifiersep> status . timed <identifiersep> out ) ; try { otr <identifiersep> engine . get <identifiersep> session ( session <identifiersep> id ) . start <identifiersep> session ( ) ; } catch ( otr <identifiersep> exception e ) <LOG> { show <identifiersep> error ( session <identifiersep> id , e . get <identifiersep> message ( ) ) ; } } @ override public string transform <identifiersep> receiving ( otr <identifiersep> contact otr <identifiersep> contact , string msg <identifiersep> text ) { session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( otr <identifiersep> contact ) ; <ect>
{ session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( otr <identifiersep> contact ) ; try { return otr <identifiersep> engine . get <identifiersep> session ( session <identifiersep> id ) . transform <identifiersep> sending ( msg <identifiersep> text ) ; } catch ( otr <identifiersep> exception e ) <LOG> { show <identifiersep> error ( session <identifiersep> id , e . get <identifiersep> message ( ) ) ; return null ; } } private session get <identifiersep> session ( otr <identifiersep> contact contact ) { session <identifiersep> id session <identifiersep> id = get <identifiersep> session <identifiersep> id ( contact ) ; <ect>
logger . trace ( <string_literal> + s <identifiersep> service . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; } <comment> <LOG> return ; if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { { logger . debug ( <ect>
return ; this . otr <identifiersep> contact = otr <identifiersep> contact ; this . set <identifiersep> status ( otr <identifiersep> activator . sc <identifiersep> otr <identifiersep> engine . get <identifiersep> session <identifiersep> status ( otr <identifiersep> contact ) ) ; this . set <identifiersep> policy ( otr <identifiersep> activator . sc <identifiersep> otr <identifiersep> engine . get <identifiersep> contact <identifiersep> policy ( contact ) ) ; <LOG> return ; } } } <comment> @ override public void set <identifiersep> current <identifiersep> contact ( meta <identifiersep> contact meta <identifiersep> contact ) <ect>
try { resource <identifiersep> bundle resource <identifiersep> bundle = resource <identifiersep> bundle . get <identifiersep> bundle ( default <identifiersep> image <identifiersep> resource <identifiersep> path ) ; this . init <identifiersep> resources ( resource <identifiersep> bundle , resources ) ; } catch ( missing <identifiersep> resource <identifiersep> exception ex ) <LOG> { } this . init <identifiersep> image <identifiersep> plugin <identifiersep> resources ( resources ) ; image <identifiersep> resources = resources ; return resources ; } <comment> <ect>
try { resource <identifiersep> bundle resource <identifiersep> bundle = resource <identifiersep> bundle . get <identifiersep> bundle ( default <identifiersep> color <identifiersep> resource <identifiersep> path ) ; this . init <identifiersep> resources ( resource <identifiersep> bundle , resources ) ; } catch ( missing <identifiersep> resource <identifiersep> exception ex ) <LOG> { } this . init <identifiersep> color <identifiersep> plugin <identifiersep> resources ( resources ) ; color <identifiersep> resources = resources ; return resources ; } <comment> <ect>
+ <string_literal> + protocol <identifiersep> names . sip + <string_literal> ; try { ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) <LOG> { } return ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; } <comment> <ect>
configuration <identifiersep> form . general <identifiersep> type ) ; bundle <identifiersep> context . register <identifiersep> service ( configuration <identifiersep> form . class . get <identifiersep> name ( ) , new lazy <identifiersep> configuration <identifiersep> form ( <string_literal> , get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> loader ( ) , <string_literal> , <LOG> <string_literal> , <number_literal> ) , properties ) ; } <comment> <ect>
<comment> private void handle <identifiersep> provider <identifiersep> removed ( protocol <identifiersep> provider <identifiersep> service provider ) <LOG> { if ( has <identifiersep> at <identifiersep> least <identifiersep> one <identifiersep> successful <identifiersep> connection ( provider ) ) { set <identifiersep> at <identifiersep> least <identifiersep> one <identifiersep> successful <identifiersep> connection ( provider , false ) ; } provider . remove <identifiersep> registration <identifiersep> state <identifiersep> change <identifiersep> listener ( this ) ; auto <identifiersep> reconn <identifiersep> enabled <identifiersep> providers . remove ( provider ) ; <ect>
+ <string_literal> + evt . get <identifiersep> reason ( ) + <string_literal> + evt . get <identifiersep> reason <identifiersep> code ( ) + <string_literal> + evt . get <identifiersep> old <identifiersep> state ( ) , new exception ( <string_literal> ) ) ; } trace <identifiersep> current <identifiersep> pp <identifiersep> state ( ) ; } } } catch ( throwable ex ) <LOG> { } } } <comment> private void reconnect ( final protocol <identifiersep> provider <identifiersep> service pp ) <ect>
@ override protected plugin <identifiersep> component get <identifiersep> plugin <identifiersep> instance ( ) { return new example <identifiersep> plugin <identifiersep> menu <identifiersep> item ( this ) ; } } , <LOG> container <identifiersep> filter ) ; } <comment> <ect>
<comment> <LOG> { } map < object , protocol <identifiersep> provider <identifiersep> factory > provider <identifiersep> factories <identifiersep> map = new hashtable < object , protocol <identifiersep> provider <identifiersep> factory > ( ) ; if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) <ect>
if ( security <identifiersep> event instanceof call <identifiersep> peer <identifiersep> security <identifiersep> on <identifiersep> event ) fire <identifiersep> notification ( call <identifiersep> security <identifiersep> on ) ; } } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; <LOG> else } } <comment> <ect>
source <identifiersep> chat <identifiersep> room , incoming <identifiersep> message , title , html <identifiersep> content , evt . get <identifiersep> message ( ) . get <identifiersep> message <identifiersep> uid ( ) ) ; } } catch ( throwable t ) <LOG> { } } <comment> <ect>
evt . get <identifiersep> source <identifiersep> contact ( ) , incoming <identifiersep> message , title , html <identifiersep> content , source <identifiersep> msg . get <identifiersep> message <identifiersep> uid ( ) ) ; } catch ( throwable t ) <LOG> { } } <comment> public void outgoing <identifiersep> call <identifiersep> created ( call <identifiersep> event event ) <ect>
logger . info ( <string_literal> ) ; <comment> <LOG> new notification <identifiersep> manager ( ) . init ( ) ; } finally { logger . log <identifiersep> exit ( ) ; } } public void stop ( bundle <identifiersep> context bc ) throws exception { <ect>
new global <identifiersep> shortcut <identifiersep> table <identifiersep> model ( ) ; <comment> public global <identifiersep> shortcut <identifiersep> config <identifiersep> form ( ) { <LOG> super ( new border <identifiersep> layout ( ) ) ; this . init <identifiersep> components ( ) ; } <comment> private void init <identifiersep> components ( ) <ect>
. get <identifiersep> string ( <string_literal> ) + ex . get <identifiersep> message ( ) ; dialog . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( message , resources . get <identifiersep> string ( <string_literal> ) , <LOG> popup <identifiersep> dialog . warning <identifiersep> message ) ; } } } ) ; } @ override public string get <identifiersep> name ( ) { return <string_literal> ; <ect>
{ parse <identifiersep> locales ( node . get <identifiersep> child <identifiersep> nodes ( ) ) ; } else { logger . warn ( <string_literal> + node . get <identifiersep> node <identifiersep> name ( ) ) ; } } } catch ( io <identifiersep> exception exc ) <LOG> { } catch ( sax <identifiersep> exception exc ) { logger . error ( <string_literal> , exc ) ; } catch ( parser <identifiersep> configuration <identifiersep> exception exc ) { <ect>
{ logger . error ( <string_literal> , exc ) ; } catch ( sax <identifiersep> exception exc ) { logger . error ( <string_literal> , exc ) ; } catch ( parser <identifiersep> configuration <identifiersep> exception exc ) <LOG> { } } <comment> <ect>
word <identifiersep> start = end ; } } } catch ( bad <identifiersep> location <identifiersep> exception exc ) { string msg = <string_literal> ; logger . error ( msg , exc ) ; } catch ( throwable exc ) <LOG> { } prompt <identifiersep> repaint ( ) ; } public void remove <identifiersep> update ( document <identifiersep> event event ) { if ( ! this . is <identifiersep> enabled ) return ; <ect>
{ return get <identifiersep> corrections ( word . get <identifiersep> word ( comp . get <identifiersep> document ( ) . get <identifiersep> text ( 0 , comp . get <identifiersep> document ( ) . get <identifiersep> length ( ) ) , index , false ) ) ; } } catch ( bad <identifiersep> location <identifiersep> exception e ) <LOG> { } } j <identifiersep> menu <identifiersep> item spell <identifiersep> check = new j <identifiersep> menu <identifiersep> item ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; array <identifiersep> list < j <identifiersep> menu <identifiersep> item > spell <identifiersep> check <identifiersep> item = new array <identifiersep> list < j <identifiersep> menu <identifiersep> item > ( ) ; <ect>
if ( ! swing <identifiersep> utilities . is <identifiersep> event <identifiersep> dispatch <identifiersep> thread ( ) ) swing <identifiersep> utilities . invoke <identifiersep> and <identifiersep> wait ( creator ) ; else creator . run ( ) ; return creator . menu <identifiersep> bar ; } catch ( throwable t ) <LOG> { } return null ; } } , container <identifiersep> filter ) ; } <comment> <ect>
spell <identifiersep> check <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . add <identifiersep> chat <identifiersep> listener ( spell <identifiersep> checker . this ) ; for ( chat chat : spell <identifiersep> check <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> all <identifiersep> chats ( ) ) chat <identifiersep> created ( chat ) ; } <LOG> } ) ; } <comment> synchronized void stop ( ) <ect>
try { <comment> <LOG> { return false ; } } <comment> <ect>
<string_literal> , get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> loader ( ) , <string_literal> , <string_literal> , <number_literal> ) , <LOG> properties ) ; } <comment> public void stop ( bundle <identifiersep> context bc ) throws exception <ect>
<comment> public void start ( final bundle <identifiersep> context context ) throws exception { <LOG> this . context = context ; handle <identifiersep> new <identifiersep> system <identifiersep> activity <identifiersep> notifications <identifiersep> service ( get <identifiersep> system <identifiersep> activity <identifiersep> notifications <identifiersep> service ( context ) ) ; <comment> <ect>
else mac <identifiersep> osx <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> query . remove <identifiersep> property ( id , mac <identifiersep> osx <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> query . abperson <identifiersep> properties [ ( ( mac <identifiersep> osx <identifiersep> addr <identifiersep> book <identifiersep> contact <identifiersep> detail ) detail ) . get <identifiersep> property ( ) ] ) ; } <LOG> else contact <identifiersep> details . remove ( detail ) ; } } <comment> <ect>
{ long time = new simple <identifiersep> date <identifiersep> format ( <string_literal> ) . parse ( props [ i ] + <string_literal> ) . get <identifiersep> time ( ) ; end <identifiersep> time = new date ( time ) ; } catch ( parse <identifiersep> exception e ) <LOG> { return ; } break ; case pid <identifiersep> lid <identifiersep> busy <identifiersep> status : status = busy <identifiersep> status <identifiersep> enum . get <identifiersep> from <identifiersep> long ( ( long ) props [ i ] ) ; break ; <ect>
{ presence . add <identifiersep> provider <identifiersep> presence <identifiersep> status <identifiersep> listener ( presence <identifiersep> status <identifiersep> listener ) ; } presence <identifiersep> status presence <identifiersep> status = presence . get <identifiersep> presence <identifiersep> status ( ) ; if ( presence <identifiersep> status == null ) <LOG> { <comment> <ect>
if ( props != null && props [ pr <identifiersep> object <identifiersep> type ] != null && props [ pr <identifiersep> object <identifiersep> type ] instanceof long ) { obj <identifiersep> type = ( ( long ) props [ pr <identifiersep> object <identifiersep> type ] ) . long <identifiersep> value ( ) ; } else <LOG> { return false ; } <comment> <ect>
{ try { plugin <identifiersep> manager <identifiersep> activator . bundle <identifiersep> context . install <identifiersep> bundle ( bundle <identifiersep> path <identifiersep> field . get <identifiersep> text ( ) ) ; } catch ( bundle <identifiersep> exception ex ) <LOG> { plugin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } catch ( throwable ex ) { <ect>
{ try { bundle <identifiersep> path <identifiersep> field . set <identifiersep> text ( new <identifiersep> bundle <identifiersep> file . to <identifiersep> uri ( ) . to <identifiersep> url ( ) . to <identifiersep> string ( ) ) ; } catch ( malformed <identifiersep> url <identifiersep> exception ex ) <LOG> { } } } else dispose ( ) ; } <comment> <ect>
{ try { ( ( bundle ) plugin <identifiersep> table . get <identifiersep> model ( ) . get <identifiersep> value <identifiersep> at ( selected <identifiersep> rows [ i ] , 0 ) ) . stop ( ) ; } catch ( bundle <identifiersep> exception ex ) <LOG> { plugin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } } default <identifiersep> button <identifiersep> state ( ) ; } else if ( source <identifiersep> button . equals ( uninstall <identifiersep> button ) ) <ect>
{ try { ( ( bundle ) plugin <identifiersep> table . get <identifiersep> model ( ) . get <identifiersep> value <identifiersep> at ( selected <identifiersep> rows [ i ] , 0 ) ) . update ( ) ; } catch ( bundle <identifiersep> exception ex ) <LOG> { plugin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } } <comment> <ect>
try { dialog . close ( false ) ; <comment> <LOG> { } } <comment> <ect>
if ( optional != null ) { add <identifiersep> file <identifiersep> to <identifiersep> zip ( optional , out ) ; } out . close ( ) ; return destination ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) <LOG> { } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } return null ; } <comment> <ect>
for ( file f : fs ) { if ( f . get <identifiersep> name ( ) . ends <identifiersep> with ( <string_literal> ) ) continue ; add <identifiersep> file <identifiersep> to <identifiersep> zip ( f , out ) ; } } catch ( exception e ) <LOG> { } } <comment> <ect>
out . close <identifiersep> entry ( ) ; in . close ( ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } } <comment> <ect>
{ logger . info ( <string_literal> + register <identifiersep> link , e1 ) ; } catch ( io <identifiersep> exception e1 ) <LOG> { } return new <identifiersep> account ; } <comment> <ect>
<comment> <LOG> { } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { protocol <identifiersep> provider <identifiersep> factory provider <identifiersep> factory <ect>
<comment> url = provdisc . discover <identifiersep> url ( ) ; break ; } } } provisioning <identifiersep> service . start ( url ) ; bundle <identifiersep> context . register <identifiersep> service ( <LOG> provisioning <identifiersep> service . class . get <identifiersep> name ( ) , provisioning <identifiersep> service , null ) ; } <comment> <ect>
@ override public boolean has <identifiersep> params ( string location ) { return location . contains ( <string_literal> ) ; } } ) ; } catch ( throwable t ) <LOG> { error <identifiersep> while <identifiersep> provisioning = t ; } <comment> <ect>
selector . select <identifiersep> no <identifiersep> skin ( ) ; new <identifiersep> bundle . start ( ) ; } catch ( malformed <identifiersep> url <identifiersep> exception ex ) { logger . info ( <string_literal> , ex ) ; } } } catch ( bundle <identifiersep> exception ex ) <LOG> { skin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } catch ( throwable ex ) { <ect>
container . container <identifiersep> call <identifiersep> dialog . get <identifiersep> id ( ) ) ; bundle <identifiersep> context . register <identifiersep> service ( plugin <identifiersep> component <identifiersep> factory . class . get <identifiersep> name ( ) , new contact <identifiersep> info <identifiersep> plugin <identifiersep> component <identifiersep> factory ( container . container <identifiersep> call <identifiersep> dialog ) , <LOG> container <identifiersep> filter ) ; } } public void stop ( bundle <identifiersep> context bc ) throws exception { } <comment> <ect>
= desktop <identifiersep> util <identifiersep> activator . get <identifiersep> resources ( ) ; res [ 0 ] = new chat <identifiersep> room <identifiersep> destroy <identifiersep> reason <identifiersep> dialog ( r . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , r . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } } ) ; } catch ( throwable t ) <LOG> { return null ; } chat <identifiersep> room <identifiersep> destroy <identifiersep> reason <identifiersep> dialog reason <identifiersep> dialog = res [ 0 ] ; int result = reason <identifiersep> dialog . show <identifiersep> dialog ( ) ; string destroy <identifiersep> options [ ] = new string [ <number_literal> ] ; if ( result == message <identifiersep> dialog . ok <identifiersep> return <identifiersep> code ) <ect>
= swing <identifiersep> utilities . get <identifiersep> window <identifiersep> ancestor ( popup <identifiersep> notification <identifiersep> panel . this ) ; parent <identifiersep> window . dispose ( ) ; } catch ( exception ex ) { <comment> <LOG> <comment> <ect>
if ( presence <identifiersep> op <identifiersep> set == null || ! protocol <identifiersep> provider . is <identifiersep> registered ( ) ) continue ; presence <identifiersep> op <identifiersep> set . publish <identifiersep> presence <identifiersep> status ( presence <identifiersep> op <identifiersep> set . get <identifiersep> presence <identifiersep> status ( ) , message ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e1 ) <LOG> { } catch ( illegal <identifiersep> state <identifiersep> exception e1 ) { logger . error ( <string_literal> , e1 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { <ect>
{ image <identifiersep> byte = image <identifiersep> utils . to <identifiersep> byte <identifiersep> array ( image ) ; } try { op <identifiersep> set <identifiersep> avatar . set <identifiersep> avatar ( image <identifiersep> byte ) ; } catch ( throwable t ) <LOG> { } } } } } } } } . start ( ) ; } <comment> private void clear <identifiersep> recent <identifiersep> images ( ) <ect>
= desktop <identifiersep> util <identifiersep> activator . get <identifiersep> file <identifiersep> access <identifiersep> service ( ) . get <identifiersep> private <identifiersep> persistent <identifiersep> file ( file <identifiersep> name , file <identifiersep> category . cache ) ; if ( image <identifiersep> file . exists ( ) && ! image <identifiersep> file . delete ( ) ) logger . error ( <string_literal> + index ) ; } catch ( exception e ) { <LOG> <comment> <ect>
if ( ! image <identifiersep> file . exists ( ) ) return null ; try { return image <identifiersep> io . read ( image <identifiersep> file ) ; } catch ( io <identifiersep> exception ioe ) <LOG> { return null ; } } <comment> <ect>
location . x , location . y , video <identifiersep> container . get <identifiersep> width ( ) , video <identifiersep> container . get <identifiersep> height ( ) ) ) ; this . grabbed <identifiersep> image = image <identifiersep> utils . to <identifiersep> byte <identifiersep> array ( bi ) ; } catch ( throwable e ) <LOG> { } close ( false ) ; this . set <identifiersep> visible ( false ) ; } <comment> <ect>
public void run ( ) { try { presence <identifiersep> op <identifiersep> set . publish <identifiersep> presence <identifiersep> status ( current <identifiersep> status , message ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e1 ) <LOG> { } catch ( illegal <identifiersep> state <identifiersep> exception e1 ) { logger . error ( <string_literal> , e1 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { <ect>
string stack <identifiersep> trace = sw . to <identifiersep> string ( ) ; try { sw . close ( ) ; } catch ( io <identifiersep> exception ex ) { <LOG> <comment> <ect>
image <identifiersep> icon = scale <identifiersep> image <identifiersep> within <identifiersep> bounds ( image , width , height ) ; else logger . trace ( <string_literal> ) ; } catch ( exception e ) <LOG> { } if ( image <identifiersep> icon != null ) return new image <identifiersep> icon ( image <identifiersep> icon ) ; return null ; } <comment> <ect>
break ; } } else logger . trace ( <string_literal> ) ; } catch ( exception e ) <LOG> { } return image <identifiersep> icon ; } <comment> <ect>
{ byte <identifiersep> array <identifiersep> output <identifiersep> stream out = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; try { image <identifiersep> io . write ( image , <string_literal> , out ) ; } catch ( io <identifiersep> exception e ) <LOG> { return null ; } return out . to <identifiersep> byte <identifiersep> array ( ) ; } <comment> <ect>
try { image <identifiersep> io . write ( scaled <identifiersep> image , <string_literal> , out <identifiersep> stream ) ; scaled <identifiersep> bytes = out <identifiersep> stream . to <identifiersep> byte <identifiersep> array ( ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } return scaled <identifiersep> bytes ; } <comment> <ect>
document . insert <identifiersep> after <identifiersep> end ( root . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } <comment> <ect>
this . document . insert <identifiersep> before <identifiersep> start ( root . get <identifiersep> element ( 0 ) , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } } <ect>
<string_literal> , window . class , shape . class ) ; m <identifiersep> set <identifiersep> window <identifiersep> opacity = awt <identifiersep> utilities <identifiersep> class . get <identifiersep> method ( <string_literal> , window . class , float . class ) ; m <identifiersep> set <identifiersep> window <identifiersep> opaque = awt <identifiersep> utilities <identifiersep> class . get <identifiersep> method ( <string_literal> , window . class , boolean . class ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception ex ) <LOG> { } catch ( security <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) { <ect>
{ logger . info ( <string_literal> ) ; } catch ( security <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception ex ) <LOG> { } } static { init ( ) ; } private static boolean is <identifiersep> supported ( method method , object kind ) { <ect>
{ return ( ( boolean ) ret ) . boolean <identifiersep> value ( ) ; } } catch ( illegal <identifiersep> access <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) <LOG> { } catch ( invocation <identifiersep> target <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } return false ; } public static boolean is <identifiersep> translucency <identifiersep> supported ( object kind ) <ect>
{ return ; } try { method . invoke ( null , window , value ) ; } catch ( illegal <identifiersep> access <identifiersep> exception ex ) <LOG> { } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ex ) { <ect>
{ logger . info ( <string_literal> ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { logger . info ( <string_literal> ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ex ) <LOG> { } } public static void set <identifiersep> window <identifiersep> shape ( window window , shape shape ) { set ( m <identifiersep> set <identifiersep> window <identifiersep> shape , window , shape ) ; } public static void set <identifiersep> window <identifiersep> opacity ( window window , float opacity ) { <ect>
{ if ( e . get <identifiersep> key ( ) . ends <identifiersep> with ( get <identifiersep> contact <identifiersep> source ( ) . default <identifiersep> scope ) ) { read <identifiersep> entry ( e . get <identifiersep> value ( ) ) ; } } } super . stopped ( true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) <LOG> { } catch ( exception e ) { logger . warn ( <string_literal> + file , e ) ; } } <comment> <ect>
private service <identifiersep> registration notification <identifiersep> service ; public void start ( bundle <identifiersep> context bc ) throws exception { bundle <identifiersep> context = bc ; try { <LOG> logger . log <identifiersep> entry ( ) ; notification <identifiersep> service = bundle <identifiersep> context . register <identifiersep> service ( notification <identifiersep> service . class . get <identifiersep> name ( ) , new notification <identifiersep> service <identifiersep> impl ( ) , null ) ; logger . info ( <string_literal> ) ; <ect>
logger . info ( <string_literal> ) ; } finally { logger . log <identifiersep> exit ( ) ; } } public void stop ( bundle <identifiersep> context bc ) throws exception { <LOG> notification <identifiersep> service . unregister ( ) ; } <comment> <ect>
for ( int p <identifiersep> idx = 0 ; p <identifiersep> idx < pattern <identifiersep> len ; p <identifiersep> idx ++ ) { pattern [ p <identifiersep> idx ] = config <identifiersep> service . get <identifiersep> long ( action <identifiersep> prop <identifiersep> name + <string_literal> + p <identifiersep> idx , - 1 ) ; if ( pattern [ p <identifiersep> idx ] == - 1 ) <LOG> { continue ; } } int repeat = config <identifiersep> service . get <identifiersep> int ( action <identifiersep> prop <identifiersep> name + <string_literal> , - 1 ) ; action = new vibrate <identifiersep> notification <identifiersep> action ( <ect>
else response = http <identifiersep> client . execute ( req ) ; <comment> <LOG> { break ; } <comment> <ect>
try { scheme sch = new scheme ( <string_literal> , <number_literal> , new ssl <identifiersep> socket <identifiersep> factory <identifiersep> ex ( ssl <identifiersep> ctx ) ) ; http <identifiersep> client . get <identifiersep> connection <identifiersep> manager ( ) . get <identifiersep> scheme <identifiersep> registry ( ) . register ( sch ) ; } catch ( throwable t ) <LOG> { } <comment> <ect>
= <string_literal> + resource <identifiersep> pack . resource <identifiersep> name + <string_literal> + type <identifiersep> name + <string_literal> ; try { ser <identifiersep> refs = bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( clazz , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> ser <identifiersep> refs = null ; } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { return bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs . iterator ( ) . next ( ) ) ; } return null ; } <comment> <ect>
<comment> public char get <identifiersep> i18n <identifiersep> mnemonic ( string key , locale locale ) { string resource <identifiersep> string = do <identifiersep> get <identifiersep> i18string ( key , locale ) ; if ( resource <identifiersep> string == null ) <LOG> { return 0 ; } int mnemonic <identifiersep> index = resource <identifiersep> string . index <identifiersep> of ( ' & ' ) ; if ( mnemonic <identifiersep> index > - 1 && mnemonic <identifiersep> index < resource <identifiersep> string . length ( ) - 1 ) { return resource <identifiersep> string . char <identifiersep> at ( mnemonic <identifiersep> index + 1 ) ; <ect>
<comment> public url get <identifiersep> settings <identifiersep> url ( string url <identifiersep> key ) { string path = get <identifiersep> settings <identifiersep> string ( url <identifiersep> key ) ; if ( path == null || path . length ( ) == 0 ) <LOG> { return null ; } return settings <identifiersep> pack . get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> loader ( ) . get <identifiersep> resource ( path ) ; } <comment> <ect>
byte [ ] image = null ; try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return image ; } <comment> <ect>
protected void fire <identifiersep> message <identifiersep> event ( event <identifiersep> object evt ) { collection < message <identifiersep> listener > listeners = null ; synchronized ( this . message <identifiersep> listeners ) { <LOG> listeners = new array <identifiersep> list < message <identifiersep> listener > ( this . message <identifiersep> listeners ) ; } + <string_literal> + evt ) ; <comment> <ect>
{ protocol <identifiersep> provider <identifiersep> factory = ( protocol <identifiersep> provider <identifiersep> factory ) bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs [ 0 ] ) ; } } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) <LOG> { } return protocol <identifiersep> provider <identifiersep> factory ; } <comment> <ect>
= media <identifiersep> service . create <identifiersep> media <identifiersep> stream ( connector , device , srtp <identifiersep> control ) ; } } else <LOG> { } return configure <identifiersep> stream ( call <identifiersep> peer <identifiersep> media <identifiersep> handler , device , format , target , direction , rtp <identifiersep> extensions , stream , master <identifiersep> stream ) ; <ect>
else if ( users <identifiersep> state == conference <identifiersep> info <identifiersep> document . state . deleted ) { try { new <identifiersep> document = new conference <identifiersep> info <identifiersep> document ( ) ; } catch ( xml <identifiersep> exception e ) <LOG> { return - 1 ; } new <identifiersep> document . set <identifiersep> version ( diff . get <identifiersep> version ( ) ) ; new <identifiersep> document . set <identifiersep> entity ( diff . get <identifiersep> entity ( ) ) ; new <identifiersep> document . set <identifiersep> user <identifiersep> count ( diff . get <identifiersep> user <identifiersep> count ( ) ) ; } else <comment> <ect>
<comment> public void start ( bundle <identifiersep> context context ) throws exception <LOG> { protocol <identifiersep> media <identifiersep> activator . bundle <identifiersep> context = context ; } <comment> <ect>
int version = - 1 ; try { version = integer . parse <identifiersep> int ( version <identifiersep> string ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) <LOG> { } return version ; } <comment> <ect>
<comment> public void send <identifiersep> hole <identifiersep> punch <identifiersep> packet ( media <identifiersep> stream <identifiersep> target target , media <identifiersep> type type , raw <identifiersep> packet packet ) <LOG> { <comment> <ect>
<comment> protected void close <identifiersep> stream ( media <identifiersep> type media <identifiersep> type ) <LOG> { <comment> boolean media <identifiersep> handler <identifiersep> close <identifiersep> stream = false ; <ect>
<comment> public void set <identifiersep> local <identifiersep> video <identifiersep> transmission <identifiersep> enabled ( boolean enabled ) <LOG> { media <identifiersep> direction old <identifiersep> value = video <identifiersep> direction <identifiersep> user <identifiersep> preference ; video <identifiersep> direction <identifiersep> user <identifiersep> preference = enabled ? media <identifiersep> direction . sendrecv : media <identifiersep> direction . recvonly ; media <identifiersep> direction new <identifiersep> value = video <identifiersep> direction <identifiersep> user <identifiersep> preference ; <comment> <ect>
<comment> private void add <identifiersep> call <identifiersep> listener ( call call ) { <LOG> { } synchronized ( calls ) { if ( ! calls . contains ( call ) ) { call <identifiersep> state call <identifiersep> state = call . get <identifiersep> call <identifiersep> state ( ) ; <ect>
<comment> private void call <identifiersep> state <identifiersep> changed ( call <identifiersep> change <identifiersep> event ev ) { call call = ev . get <identifiersep> source <identifiersep> call ( ) ; <LOG> { } if ( call <identifiersep> state . call <identifiersep> initialization . equals ( ev . get <identifiersep> old <identifiersep> value ( ) ) && call <identifiersep> state . call <identifiersep> in <identifiersep> progress . equals ( call . get <identifiersep> call <identifiersep> state ( ) ) && protocol <identifiersep> provider <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> boolean ( <ect>
&& ! call <identifiersep> peer <identifiersep> state . is <identifiersep> on <identifiersep> hold ( peer <identifiersep> state ) ) { try { telephony . put <identifiersep> on <identifiersep> hold ( peer ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { } } } } } <comment> <ect>
<comment> private void remove <identifiersep> call <identifiersep> listener ( call call ) { <LOG> { } call . remove <identifiersep> call <identifiersep> change <identifiersep> listener ( listener ) ; synchronized ( calls ) { calls . remove ( call ) ; } } <comment> <ect>
<comment> public void call <identifiersep> state <identifiersep> changed ( call <identifiersep> change <identifiersep> event ev ) { <LOG> { } call call = ev . get <identifiersep> source <identifiersep> call ( ) ; object old <identifiersep> call <identifiersep> state = ev . get <identifiersep> old <identifiersep> value ( ) ; object new <identifiersep> call <identifiersep> state = call . get <identifiersep> call <identifiersep> state ( ) ; if ( ( call <identifiersep> state . call <identifiersep> initialization . equals ( old <identifiersep> call <identifiersep> state ) && call <identifiersep> state . call <identifiersep> in <identifiersep> progress . equals ( new <identifiersep> call <identifiersep> state ) ) <ect>
<comment> private void run ( ) { <LOG> { } if ( ! protocol <identifiersep> provider <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> boolean ( pname <identifiersep> on <identifiersep> the <identifiersep> phone <identifiersep> status <identifiersep> enabled , false ) ) { <ect>
= bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , null ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ise ) { <LOG> { } pps <identifiersep> refs = null ; } if ( ( pps <identifiersep> refs == null ) || ( pps <identifiersep> refs . length == 0 ) ) { forget <identifiersep> presence <identifiersep> statuses ( ) ; } else <ect>
protocol <identifiersep> provider <identifiersep> service pps = ( protocol <identifiersep> provider <identifiersep> service ) bundle <identifiersep> context . get <identifiersep> service ( pps <identifiersep> ref ) ; if ( pps == null ) { <LOG> { } continue ; } operation <identifiersep> set <identifiersep> presence presence = pps . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> presence . class ) ; if ( presence == null ) <ect>
<comment> forget <identifiersep> presence <identifiersep> status ( pps ) ; } else if ( pps . is <identifiersep> registered ( ) ) { <LOG> { } presence <identifiersep> status on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status = find <identifiersep> on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status ( presence ) ; if ( on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status == null ) { <ect>
<string_literal> ) ; } presence <identifiersep> status presence <identifiersep> status = presence . get <identifiersep> presence <identifiersep> status ( ) ; if ( presence <identifiersep> status == null ) { <LOG> { } <comment> <ect>
logger . debug ( <string_literal> + listeners . size ( ) + <string_literal> + evt ) ; for ( provider <identifiersep> presence <identifiersep> status <identifiersep> listener listener : listeners ) <LOG> listener . provider <identifiersep> status <identifiersep> changed ( evt ) ; } <comment> <ect>
new <identifiersep> parent ) ; collection < subscription <identifiersep> listener > listeners ; synchronized ( subscription <identifiersep> listeners ) { listeners <LOG> = new array <identifiersep> list < subscription <identifiersep> listener > ( subscription <identifiersep> listeners ) ; } + <string_literal> + evt ) ; for ( subscription <identifiersep> listener listener : listeners ) listener . subscription <identifiersep> moved ( evt ) ; } <comment> <ect>
return class <identifiersep> name . substring ( 0 , class <identifiersep> name . last <identifiersep> index <identifiersep> of ( ' . ' ) ) ; } <comment> public void stop ( ) <LOG> { synchronized ( registered <identifiersep> accounts ) { for ( service <identifiersep> registration < protocol <identifiersep> provider <identifiersep> service > reg : registered <identifiersep> accounts . values ( ) ) { <ect>
{ system . load <identifiersep> library ( <string_literal> ) ; sparkle <identifiersep> activator . sparkle <identifiersep> lib <identifiersep> loaded = true ; } } catch ( throwable t ) { <LOG> logger . warn ( <string_literal> ) ; return ; } string download <identifiersep> link = get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> string ( prop <identifiersep> update <identifiersep> link ) ; string title = resource <identifiersep> management <identifiersep> service <identifiersep> utils . get <identifiersep> service ( bundle <identifiersep> context ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ; <ect>
<comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <LOG> sparkle <identifiersep> activator . bundle <identifiersep> context = null ; } <comment> <ect>
<comment> public void growl <identifiersep> notification <identifiersep> timed <identifiersep> out ( object context ) <LOG> { } <comment> <ect>
public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <comment> <LOG> return ; growl <identifiersep> notification <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; handler = new growl <identifiersep> notification <identifiersep> service <identifiersep> impl ( ) ; handler . start ( bundle <identifiersep> context ) ; bundle <identifiersep> context . register <identifiersep> service ( popup <identifiersep> message <identifiersep> handler . class . get <identifiersep> name ( ) , <ect>
throws exception { <comment> <LOG> handler . stop ( bundle <identifiersep> context ) ; } <comment> <ect>
for ( sc <identifiersep> audio <identifiersep> clip clip : clips <identifiersep> to <identifiersep> stop ) { try { clip . stop ( ) ; } catch ( throwable t ) <LOG> { } } } } <comment> <ect>
private static configuration <identifiersep> service configuration <identifiersep> service ; public void start ( bundle <identifiersep> context bc ) throws exception { bundle <identifiersep> context = bc ; try { <LOG> logger . log <identifiersep> entry ( ) ; <comment> <ect>
command <identifiersep> handler . get <identifiersep> action <identifiersep> type ( ) ) ; notification <identifiersep> service . remove <identifiersep> action <identifiersep> handler ( log <identifiersep> message <identifiersep> handler . get <identifiersep> action <identifiersep> type ( ) ) ; notification <identifiersep> service . remove <identifiersep> action <identifiersep> handler ( popup <identifiersep> message <identifiersep> handler . get <identifiersep> action <identifiersep> type ( ) ) ; notification <identifiersep> service . remove <identifiersep> action <identifiersep> handler ( <LOG> sound <identifiersep> handler . get <identifiersep> action <identifiersep> type ( ) ) ; } <comment> <ect>
public void run ( ) { try { launch <identifiersep> browser ( url ) ; } catch ( exception e ) <LOG> { } } } ; launch <identifiersep> browser <identifiersep> thread . start ( ) ; } } <ect>
if ( session <identifiersep> certs != null ) stored <identifiersep> certs . add <identifiersep> all ( session <identifiersep> certs ) ; } } if ( ! stored <identifiersep> certs . contains ( thumbprint ) ) { switch ( verify ( chain , message ) ) { <LOG> case do <identifiersep> not <identifiersep> trust : throw new certificate <identifiersep> exception ( <string_literal> + chain [ 0 ] . get <identifiersep> subject <identifiersep> dn ( ) + <string_literal> , e ) ; case trust <identifiersep> always : <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception <LOG> { bundle <identifiersep> context . register <identifiersep> service ( provisioning <identifiersep> discovery <identifiersep> service . class . get <identifiersep> name ( ) , provisioning <identifiersep> service , null ) ; <ect>
<comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception <LOG> { } } <ect>
{ string <identifiersep> buffer url = new string <identifiersep> buffer ( ) ; try { jmdns = jm <identifiersep> dns . create ( ) ; } catch ( io <identifiersep> exception e ) <LOG> { return null ; } service <identifiersep> info info = jmdns . get <identifiersep> service <identifiersep> info ( <string_literal> , <string_literal> , mdns <identifiersep> timeout ) ; if ( info == null ) { <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception <LOG> { bundle <identifiersep> context . register <identifiersep> service ( provisioning <identifiersep> discovery <identifiersep> service . class . get <identifiersep> name ( ) , provisioning <identifiersep> service , null ) ; <ect>
<string_literal> ) ) ) { j <identifiersep> frame . set <identifiersep> default <identifiersep> look <identifiersep> and <identifiersep> feel <identifiersep> decorated ( true ) ; j <identifiersep> dialog . set <identifiersep> default <identifiersep> look <identifiersep> and <identifiersep> feel <identifiersep> decorated ( true ) ; } ui <identifiersep> manager . set <identifiersep> look <identifiersep> and <identifiersep> feel ( lf ) ; } catch ( unsupported <identifiersep> look <identifiersep> and <identifiersep> feel <identifiersep> exception ex ) <LOG> { } } } private void fix <identifiersep> windows <identifiersep> ui <identifiersep> defaults ( ui <identifiersep> defaults ui <identifiersep> defaults ) { <comment> <ect>
{ public void run ( ) { get <identifiersep> configuration <identifiersep> container ( ) ; } } ) ; } catch ( throwable e ) <LOG> { <comment> <ect>
private void undo ( ) { try { undo . undo ( ) ; } catch ( cannot <identifiersep> undo <identifiersep> exception e ) <LOG> { } } <comment> private void redo ( ) { <ect>
. get <identifiersep> current <identifiersep> chat <identifiersep> transport ( ) . send <identifiersep> typing <identifiersep> notification ( typing <identifiersep> state ) ; if ( result == chat <identifiersep> panel . typing <identifiersep> notification <identifiersep> successfully <identifiersep> sent ) stopped <identifiersep> typing <identifiersep> timer . set <identifiersep> delay ( <number_literal> * <number_literal> ) ; } catch ( exception ex ) <LOG> { } } else if ( typing <identifiersep> state == operation <identifiersep> set <identifiersep> typing <identifiersep> notifications . state <identifiersep> paused ) { stop <identifiersep> typing <identifiersep> timer ( ) ; } } } <comment> <ect>
<comment> <LOG> { } } <comment> <ect>
{ doc . insert <identifiersep> after <identifiersep> end ( current <identifiersep> element , text ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } this . editor <identifiersep> pane . set <identifiersep> caret <identifiersep> position ( doc . get <identifiersep> length ( ) ) ; } <comment> <ect>
<comment> <LOG> { + <string_literal> , descriptor , descriptor . get <identifiersep> class ( ) . get <identifiersep> canonical <identifiersep> name ( ) ) ) ; return ; } <comment> <ect>
<comment> <LOG> { if ( ex instanceof illegal <identifiersep> state <identifiersep> exception ) { add <identifiersep> error <identifiersep> message ( chat <identifiersep> session . get <identifiersep> current <identifiersep> chat <identifiersep> transport ( ) . get <identifiersep> name ( ) , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <ect>
{ sms <identifiersep> chat <identifiersep> transport = transport ; break ; } } } <comment> <LOG> { this . refresh <identifiersep> write <identifiersep> area ( ) ; this . add <identifiersep> message ( sms <identifiersep> chat <identifiersep> transport . get <identifiersep> name ( ) , new date ( ) , chat . outgoing <identifiersep> message , <ect>
this . add <identifiersep> error <identifiersep> message ( chat <identifiersep> session . get <identifiersep> current <identifiersep> chat <identifiersep> transport ( ) . get <identifiersep> name ( ) , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) + protocol <identifiersep> error ) ; } catch ( exception ex ) <LOG> { this . refresh <identifiersep> write <identifiersep> area ( ) ; this . add <identifiersep> message ( chat <identifiersep> session . get <identifiersep> current <identifiersep> chat <identifiersep> transport ( ) . get <identifiersep> name ( ) , new date ( ) , chat . outgoing <identifiersep> message , <ect>
case chat <identifiersep> focus <identifiersep> event . focus <identifiersep> gained : listener . chat <identifiersep> focus <identifiersep> gained ( evt ) ; break ; case chat <identifiersep> focus <identifiersep> event . focus <identifiersep> lost : listener . chat <identifiersep> focus <identifiersep> lost ( evt ) ; break ; <LOG> default : } } } <comment> <ect>
ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> ser <identifiersep> refs = null ; } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory <ect>
. get <identifiersep> scaled <identifiersep> instance <identifiersep> in <identifiersep> bytes ( image . get <identifiersep> image ( ) , width , height ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) <LOG> { } } return bytes ; } } <ect>
logger . debug ( <string_literal> , e ) ; this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) <LOG> { this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( unsupported <identifiersep> operation <identifiersep> exception e ) <ect>
logger . debug ( <string_literal> , e ) ; this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( security <identifiersep> exception e ) <LOG> { this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( io <identifiersep> exception e ) <ect>
logger . debug ( <string_literal> , e ) ; this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( exception e ) <LOG> { this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } } <comment> <ect>
{ file download <identifiersep> dir = gui <identifiersep> activator . get <identifiersep> file <identifiersep> access <identifiersep> service ( ) . get <identifiersep> default <identifiersep> download <identifiersep> directory ( ) ; gui <identifiersep> activator . get <identifiersep> desktop <identifiersep> service ( ) . open ( download <identifiersep> dir ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) <LOG> { this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) <ect>
<comment> public void remove <identifiersep> all <identifiersep> chats ( ) <LOG> { if ( get <identifiersep> chat <identifiersep> tab <identifiersep> count ( ) > 0 ) { this . chat <identifiersep> tabbed <identifiersep> pane . remove <identifiersep> all ( ) ; this . main <identifiersep> panel . remove ( chat <identifiersep> tabbed <identifiersep> pane ) ; chat <identifiersep> count = 0 ; <ect>
{ warning <identifiersep> icon = new image <identifiersep> icon ( image <identifiersep> io . read ( gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> image <identifiersep> url ( <string_literal> ) ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { } j <identifiersep> label warning <identifiersep> sign = new j <identifiersep> label ( warning <identifiersep> icon ) ; j <identifiersep> panel warning <identifiersep> panel = new transparent <identifiersep> panel ( ) ; warning <identifiersep> panel . set <identifiersep> layout ( new box <identifiersep> layout ( warning <identifiersep> panel , box <identifiersep> layout . x <identifiersep> axis ) ) ; warning <identifiersep> panel . add ( warning <identifiersep> sign ) ; warning <identifiersep> panel . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; <ect>
msg <identifiersep> id <identifiersep> to <identifiersep> chat <identifiersep> string . put ( current <identifiersep> message <identifiersep> id , new <identifiersep> chat <identifiersep> string ) ; } catch ( bad <identifiersep> location <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } } } @ override protected object construct ( ) throws exception { string new <identifiersep> chat <identifiersep> string = msg <identifiersep> id <identifiersep> to <identifiersep> chat <identifiersep> string . get ( current <identifiersep> message <identifiersep> id ) ; <ect>
try { chat <identifiersep> room . kick <identifiersep> participant ( ( chat <identifiersep> room <identifiersep> member ) chat <identifiersep> contact . get <identifiersep> descriptor ( ) , reason ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { if ( e . get <identifiersep> error <identifiersep> code ( ) == operation <identifiersep> failed <identifiersep> exception . not <identifiersep> enough <identifiersep> privileges ) { error <identifiersep> dialog error <identifiersep> dialog = new error <identifiersep> dialog ( <ect>
try { uri <identifiersep> list <identifiersep> flavor = new data <identifiersep> flavor ( <string_literal> ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> <comment> <ect>
catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } if ( t . is <identifiersep> data <identifiersep> flavor <identifiersep> supported ( uri <identifiersep> list <identifiersep> flavor ) && os <identifiersep> utils . is <identifiersep> linux ) { try { object o = t . get <identifiersep> transfer <identifiersep> data ( uri <identifiersep> list <identifiersep> flavor ) ; <ect>
catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } if ( t . is <identifiersep> data <identifiersep> flavor <identifiersep> supported ( ui <identifiersep> contact <identifiersep> data <identifiersep> flavor ) ) { object o = null ; try { <ect>
catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } if ( o instanceof contact <identifiersep> node ) { ui <identifiersep> contact ui <identifiersep> contact = ( ( contact <identifiersep> node ) o ) . get <identifiersep> contact <identifiersep> descriptor ( ) ; <comment> <ect>
catch ( unsupported <identifiersep> flavor <identifiersep> exception ufe ) { logger . debug ( <string_literal> , ufe ) ; } catch ( io <identifiersep> exception ioe ) <LOG> { } } return false ; } } <ect>
doc . insert <identifiersep> after <identifiersep> end ( root . get <identifiersep> element ( root . get <identifiersep> element <identifiersep> count ( ) - 1 ) , chat <identifiersep> string ) ; } catch ( bad <identifiersep> location <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } public void message <identifiersep> delivered ( chat <identifiersep> room <identifiersep> message <identifiersep> delivered <identifiersep> event evt ) { } public void message <identifiersep> delivery <identifiersep> failed ( chat <identifiersep> room <identifiersep> message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { } public void message <identifiersep> received ( chat <identifiersep> room <identifiersep> message <identifiersep> received <identifiersep> event evt ) { } <comment> <ect>
{ if ( ! swing <identifiersep> utilities . is <identifiersep> event <identifiersep> dispatch <identifiersep> thread ( ) ) swing <identifiersep> utilities . invoke <identifiersep> and <identifiersep> wait ( this ) ; else this . run ( ) ; } catch ( throwable t ) <LOG> { <comment> <ect>
document . insert <identifiersep> before <identifiersep> end ( parent <identifiersep> element , new <identifiersep> message ) ; <comment> <LOG> { } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } finish <identifiersep> message <identifiersep> add ( new <identifiersep> message ) ; } <comment> <ect>
element root = document . get <identifiersep> default <identifiersep> root <identifiersep> element ( ) ; element corrected <identifiersep> msg <identifiersep> element = document . get <identifiersep> element ( root , attribute . id , chat <identifiersep> html <identifiersep> utils . message <identifiersep> text <identifiersep> id + corrected <identifiersep> uid ) ; if ( corrected <identifiersep> msg <identifiersep> element == null ) <LOG> { return ; } string contact <identifiersep> address = ( string ) corrected <identifiersep> msg <identifiersep> element . get <identifiersep> attributes ( ) . get <identifiersep> attribute ( attribute . name ) ; boolean is <identifiersep> history <ect>
<comment> <LOG> { } } finish <identifiersep> message <identifiersep> add ( new <identifiersep> message ) ; } <comment> <ect>
<comment> <LOG> { } } string last <identifiersep> elem <identifiersep> content = get <identifiersep> element <identifiersep> content ( last <identifiersep> message <identifiersep> uid , message ) ; if ( last <identifiersep> elem <identifiersep> content != null ) { finish <identifiersep> message <identifiersep> add ( last <identifiersep> elem <identifiersep> content ) ; } } <comment> <ect>
else { <comment> <LOG> { return ; } delete <identifiersep> all <identifiersep> messages <identifiersep> without <identifiersep> header ( ) ; } <comment> <ect>
chat <identifiersep> html <identifiersep> utils . message <identifiersep> text <identifiersep> id + last <identifiersep> message <identifiersep> uid ) ; if ( last <identifiersep> msg <identifiersep> element == null ) { <comment> <LOG> <comment> <ect>
ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( contact <identifiersep> event <identifiersep> handler . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> ser <identifiersep> refs = null ; } if ( ( ser <identifiersep> refs == null ) || ser <identifiersep> refs . is <identifiersep> empty ( ) ) return null ; return gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> refs . iterator ( ) . next ( ) ) ; } <comment> <ect>
get <identifiersep> default <identifiersep> close <identifiersep> operation ( ) == j <identifiersep> frame . dispose <identifiersep> on <identifiersep> close ) { try { gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> bundle ( 0 ) . stop ( ) ; } catch ( bundle <identifiersep> exception ex ) <LOG> { system . exit ( 0 ) ; } <comment> <ect>
{ if ( enable <identifiersep> account <identifiersep> worker != null ) { logger . warn ( <string_literal> ) ; return ; } <LOG> int mouse <identifiersep> index = this . location <identifiersep> to <identifiersep> index ( event . get <identifiersep> point ( ) ) ; <comment> <ect>
if ( protocol <identifiersep> provider != null ) this . wizard <identifiersep> container . save <identifiersep> account <identifiersep> wizard ( protocol <identifiersep> provider , wizard ) ; this . wizard <identifiersep> container . unregister <identifiersep> wizard <identifiersep> pages ( ) ; this . wizard <identifiersep> container . remove <identifiersep> wizzard <identifiersep> icon ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { if ( e . get <identifiersep> error <identifiersep> code ( ) == operation <identifiersep> failed <identifiersep> exception . illegal <identifiersep> argument ) { new error <identifiersep> dialog ( gui <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> main <identifiersep> frame ( ) , <ect>
return ; string protocol <identifiersep> name = ( string ) ser <identifiersep> ref . get <identifiersep> property ( protocol <identifiersep> provider <identifiersep> factory . protocol ) ; account <identifiersep> registration <identifiersep> wizard wizard = ( account <identifiersep> registration <identifiersep> wizard ) s <identifiersep> service ; switch ( event . get <identifiersep> type ( ) ) { <LOG> case service <identifiersep> event . registered : add <identifiersep> account <identifiersep> registration <identifiersep> wizard ( protocol <identifiersep> name , wizard ) ; break ; case service <identifiersep> event . unregistering : remove <identifiersep> account <identifiersep> registration <identifiersep> wizard ( protocol <identifiersep> name , wizard ) ; break ; <ect>
{ stop <identifiersep> connecting ( wizard <identifiersep> container ) ; } } ) ; <comment> <LOG> <comment> <ect>
{ stop <identifiersep> connecting ( wizard <identifiersep> container ) ; } } ) ; <comment> <LOG> <comment> <ect>
try { ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception exc ) <LOG> { } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { final plugin <identifiersep> component <identifiersep> factory f = ( plugin <identifiersep> component <identifiersep> factory ) gui <identifiersep> activator <ect>
try { ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception exc ) <LOG> { } if ( ser <identifiersep> refs != null ) { for ( int i = 0 ; i < ser <identifiersep> refs . length ; i ++ ) { plugin <identifiersep> component <identifiersep> factory factory = <ect>
ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) { <LOG> ser <identifiersep> refs = null ; } if ( ( ser <identifiersep> refs != null ) && ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { for ( service <identifiersep> reference < plugin <identifiersep> component <identifiersep> factory > ser <identifiersep> ref : ser <identifiersep> refs ) { plugin <identifiersep> component <identifiersep> factory factory <ect>
try { ser <identifiersep> refs = gui <identifiersep> activator . bundle <identifiersep> context . get <identifiersep> service <identifiersep> references ( plugin <identifiersep> component <identifiersep> factory . class . get <identifiersep> name ( ) , osgi <identifiersep> filter ) ; } catch ( invalid <identifiersep> syntax <identifiersep> exception exc ) <LOG> { } if ( ser <identifiersep> refs != null ) { for ( int i = 0 ; i < ser <identifiersep> refs . length ; i ++ ) { plugin <identifiersep> component <identifiersep> factory factory = <ect>
<comment> <LOG> { } } } } } <comment> public void set <identifiersep> default <identifiersep> filter ( contact <identifiersep> list <identifiersep> filter filter ) <ect>
object o = null ; try { o = t . get <identifiersep> transfer <identifiersep> data ( data <identifiersep> flavor . java <identifiersep> file <identifiersep> list <identifiersep> flavor ) ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) <LOG> { } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } if ( o instanceof collection ) <ect>
object o = null ; try { o = t . get <identifiersep> transfer <identifiersep> data ( ui <identifiersep> contact <identifiersep> data <identifiersep> flavor ) ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) <LOG> { } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } if ( o instanceof contact <identifiersep> node <ect>
{ <comment> <LOG> { } if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { custom <identifiersep> contact <identifiersep> actions <identifiersep> service < ? > custom <identifiersep> action <identifiersep> service <ect>
catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } if ( o instanceof contact <identifiersep> node ) { ui <identifiersep> contact ui <identifiersep> contact = ( ( contact <identifiersep> node ) o ) . get <identifiersep> contact <identifiersep> descriptor ( ) ; iterator < ui <identifiersep> contact <identifiersep> detail > contact <identifiersep> details = ui <identifiersep> contact <ect>
catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } if ( callee == null ) return false ; else { map < protocol <identifiersep> provider <identifiersep> service , list < string > > callees <ect>
command = string . format ( command , call <identifiersep> peers . get ( 0 ) . get <identifiersep> address ( ) ) ; try { logger . info ( <string_literal> + command ) ; runtime . get <identifiersep> runtime ( ) . exec ( command ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } } <comment> <ect>
= call . get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> telephony <identifiersep> park . class ) ; try { park <identifiersep> op <identifiersep> set . park <identifiersep> call ( text <identifiersep> field . get <identifiersep> text ( ) , peer ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { + <string_literal> + text <identifiersep> field . get <identifiersep> text ( ) , ex ) ; } } } ) ; return popup <identifiersep> menu ; } } <ect>
if ( telephony != null ) { try { telephony . transfer ( peer , target ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { + <string_literal> + target , ex ) ; } } } <comment> <ect>
string <identifiersep> contact , contact <identifiersep> resource , ui <identifiersep> contact ) ; } } } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) <LOG> throw ( thread <identifiersep> death ) t ; string message = gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ; if ( t . get <identifiersep> message ( ) != null ) message += <string_literal> + t . get <identifiersep> message ( ) ; new error <identifiersep> dialog ( <ect>
= peer . get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> basic <identifiersep> telephony . class ) ; try { basic <identifiersep> telephony . hangup <identifiersep> call <identifiersep> peer ( peer ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ofe ) <LOG> { } } } } <comment> private static class enable <identifiersep> local <identifiersep> video <identifiersep> thread extends thread <ect>
catch ( exception ex ) { <comment> <LOG> <comment> } } } <comment> <ect>
byte [ ] icon = null ; try { icon = config <identifiersep> form . get <identifiersep> icon ( ) ; config <identifiersep> form <identifiersep> title = config <identifiersep> form . get <identifiersep> title ( ) ; } catch ( exception e ) <LOG> { } if ( icon != null ) config <identifiersep> form <identifiersep> icon = new image <identifiersep> icon ( icon ) ; } <comment> <ect>
<comment> public void dispose ( ) { systray <identifiersep> service systray = gui <identifiersep> activator . get <identifiersep> systray <identifiersep> service ( ) ; if ( systray == null ) <LOG> { return ; } systray . remove <identifiersep> popup <identifiersep> message <identifiersep> listener ( listener ) ; } <comment> <ect>
logger . info ( <string_literal> ) ; bundle <identifiersep> context . register <identifiersep> service ( ui <identifiersep> service . class . get <identifiersep> name ( ) , ui <identifiersep> service , <LOG> null ) ; <comment> <ect>
if ( ! ser <identifiersep> refs . is <identifiersep> empty ( ) ) { service <identifiersep> reference < security <identifiersep> authority > ser <identifiersep> ref = ser <identifiersep> refs . iterator ( ) . next ( ) ; security <identifiersep> authority = bundle <identifiersep> context . get <identifiersep> service ( ser <identifiersep> ref ) ; } } catch ( invalid <identifiersep> syntax <identifiersep> exception ex ) <LOG> { } return security <identifiersep> authority ; } <comment> <ect>
byte [ ] icon = null ; try { icon = new byte [ is . available ( ) ] ; is . read ( icon ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return new image <identifiersep> icon ( icon ) ; } <comment> public static void clear <identifiersep> cache ( ) <ect>
protocol <identifiersep> provider <identifiersep> service . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> sms <identifiersep> messaging . class ) ; contact contact = sms <identifiersep> messaging . get <identifiersep> contact ( to ) ; meta <identifiersep> contact meta <identifiersep> contact = gui <identifiersep> activator . get <identifiersep> contact <identifiersep> list <identifiersep> service ( ) . find <identifiersep> meta <identifiersep> contact <identifiersep> by <identifiersep> contact ( contact ) ; if ( meta <identifiersep> contact == null ) <LOG> { return ; } gui <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> chat <identifiersep> window <identifiersep> manager ( ) . start <identifiersep> chat ( meta <identifiersep> contact , contact , true ) ; } <comment> <ect>
<string_literal> ) ; chat <identifiersep> panel . add <identifiersep> error <identifiersep> message ( phone <identifiersep> number , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( exception ex ) <LOG> { chat <identifiersep> panel . add <identifiersep> message ( phone <identifiersep> number == null ? chat <identifiersep> transport . get <identifiersep> name ( ) : phone <identifiersep> number , new date ( ) , chat . outgoing <identifiersep> message , message , <ect>
finally { try { r . close ( ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } } } <comment> public static void reload ( ) { <ect>
object o = null ; try { o = t . get <identifiersep> transfer <identifiersep> data ( ui <identifiersep> contact <identifiersep> data <identifiersep> flavor ) ; } catch ( unsupported <identifiersep> flavor <identifiersep> exception e ) <LOG> { } catch ( io <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } if ( o instanceof collection ) <ect>
<comment> private synchronized void add <identifiersep> plugin <identifiersep> component ( plugin <identifiersep> component <identifiersep> factory factory ) { plugin <identifiersep> component c = <LOG> factory . get <identifiersep> plugin <identifiersep> component <identifiersep> instance ( plugin <identifiersep> container . this ) ; <comment> <ect>
<comment> static void fire <identifiersep> change <identifiersep> event ( change <identifiersep> event evt , network <identifiersep> configuration <identifiersep> change <identifiersep> listener listener ) { try <LOG> { listener . configuration <identifiersep> changed ( evt ) ; } catch ( throwable e ) { logger . warn ( <string_literal> + evt + <string_literal> + listener , e ) ; <ect>
if ( local <identifiersep> host == null ) { try { local <identifiersep> host = inet <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) <LOG> { } } if ( local <identifiersep> host . is <identifiersep> any <identifiersep> local <identifiersep> address ( ) ) { { logger . trace ( <ect>
done = true ; break ; } } } } } } catch ( exception e ) { <comment> <LOG> logger . warn ( <string_literal> , e ) ; } } return local <identifiersep> host ; } <comment> <ect>
stun <identifiersep> srv <identifiersep> name , transport . udp . to <identifiersep> string ( ) , domain <identifiersep> name ) ; if ( srv <identifiersep> record != null ) { srvr <identifiersep> address = srv <identifiersep> record . get <identifiersep> target ( ) ; port = srv <identifiersep> record . get <identifiersep> port ( ) ; } } catch ( parse <identifiersep> exception e ) <LOG> { srvr <identifiersep> address = null ; } catch ( dnssec <identifiersep> exception e ) { logger . warn ( <string_literal> + domain <identifiersep> name + <string_literal> , e ) ; <ect>
if ( has <identifiersep> address ) network <identifiersep> event <identifiersep> dispatcher . fire <identifiersep> change <identifiersep> event ( new change <identifiersep> event ( network <identifiersep> interface . get <identifiersep> name ( ) , change <identifiersep> event . iface <identifiersep> up , null , false , true ) , listener ) ; } } } catch ( socket <identifiersep> exception e ) <LOG> { } } <comment> <ect>
{ try { event <identifiersep> dispatcher . fire <identifiersep> change <identifiersep> event ( new change <identifiersep> event ( event . get <identifiersep> source ( ) , change <identifiersep> event . dns <identifiersep> change ) ) ; } catch ( throwable t ) <LOG> { } } } <comment> private void down <identifiersep> all <identifiersep> interfaces ( ) { <ect>
active <identifiersep> interfaces . entry <identifiersep> set ( ) ) { logger . info ( <string_literal> + en . get <identifiersep> key ( ) + <string_literal> + en . get <identifiersep> value ( ) ) ; } for ( map . entry < string , list < inet <identifiersep> address > > en : current <identifiersep> active <identifiersep> interfaces . entry <identifiersep> set ( ) ) <LOG> { + <string_literal> + en . get <identifiersep> value ( ) ) ; } } <comment> <ect>
if ( join ) { chat <identifiersep> room . join ( ) ; for ( string contact : contacts ) chat <identifiersep> room . invite ( contact , reason ) ; } } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { muc <identifiersep> activator . get <identifiersep> alert <identifiersep> ui <identifiersep> service ( ) . show <identifiersep> alert <identifiersep> dialog ( muc <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , muc <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { protocol <identifiersep> provider . get <identifiersep> protocol <identifiersep> display <identifiersep> name ( ) } ) , <ect>
if ( subject != null ) { try { chat <identifiersep> room <identifiersep> wrapper . get <identifiersep> chat <identifiersep> room ( ) . set <identifiersep> subject ( subject ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { } } } chat <identifiersep> room <identifiersep> wrapper . fire <identifiersep> property <identifiersep> change ( return <identifiersep> code ) ; } } <comment> <ect>
<comment> public int get <identifiersep> color ( string key ) { string res = get <identifiersep> color <identifiersep> resources ( ) . get ( key ) ; if ( res == null ) <LOG> { return 0x <identifiersep> ffffff ; } else return integer . parse <identifiersep> int ( res , <number_literal> ) ; } <comment> <ect>
<comment> public input <identifiersep> stream get <identifiersep> image <identifiersep> input <identifiersep> stream ( string stream <identifiersep> key ) { string path = get <identifiersep> image <identifiersep> path ( stream <identifiersep> key ) ; if ( path == null || path . length ( ) == 0 ) <LOG> { return null ; } return get <identifiersep> image <identifiersep> input <identifiersep> stream <identifiersep> for <identifiersep> path ( path ) ; } <comment> <ect>
<comment> public url get <identifiersep> sound <identifiersep> url ( string url <identifiersep> key ) { string path = get <identifiersep> sound <identifiersep> path ( url <identifiersep> key ) ; if ( path == null || path . length ( ) == 0 ) <LOG> { return null ; } return get <identifiersep> sound <identifiersep> url <identifiersep> for <identifiersep> path ( path ) ; } <comment> <ect>
{ if ( password != null ) encrypted <identifiersep> password = crypto . encrypt ( password ) ; set <identifiersep> encrypted ( account <identifiersep> prefix , encrypted <identifiersep> password ) ; return true ; } catch ( exception ex ) <LOG> { return false ; } } else return false ; } <comment> <ect>
<comment> public boolean remove <identifiersep> password ( string account <identifiersep> prefix ) { <LOG> set <identifiersep> encrypted ( account <identifiersep> prefix , null ) ; return true ; } <comment> <ect>
|| is <identifiersep> stored <identifiersep> encrypted ( prefix ) ) { set <identifiersep> unencrypted ( prefix , null ) ; } else if ( ! move <identifiersep> password <identifiersep> property ( prefix , new string ( base64 . decode ( encoded <identifiersep> password ) ) ) ) <LOG> { } } } } <comment> <ect>
<comment> if ( crypto == null ) <LOG> { if ( is <identifiersep> using <identifiersep> master <identifiersep> password ( ) ) { string master = show <identifiersep> password <identifiersep> prompt ( ) ; if ( master == null ) { <ect>
<comment> public void handle <identifiersep> uri ( string uri <identifiersep> arg ) <LOG> { <comment> <ect>
{ config . put ( prop <identifiersep> name , value ) ; } } try { super . init ( config ) ; } catch ( io <identifiersep> exception e ) <LOG> { } this . head <identifiersep> resolver = head <identifiersep> resolver ; reset ( ) ; lookup . set <identifiersep> default <identifiersep> resolver ( this ) ; dns <identifiersep> util <identifiersep> activator . get <identifiersep> notification <identifiersep> service ( ) . register <identifiersep> default <identifiersep> notification <identifiersep> for <identifiersep> event ( <ect>
custom <identifiersep> resolver . pdefault <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled ) ) { bundle <identifiersep> context . register <identifiersep> service ( custom <identifiersep> resolver . class . get <identifiersep> name ( ) , new configurable <identifiersep> dnssec <identifiersep> resolver ( new extended <identifiersep> resolver ( ) ) , null ) ; <LOG> logger . info ( <string_literal> ) ; } } <comment> <ect>
<comment> <LOG> { } } return false ; } <comment> <ect>
{ message local <identifiersep> response = null ; try { local <identifiersep> response = default <identifiersep> resolver . send ( query ) ; } catch ( socket <identifiersep> timeout <identifiersep> exception exc ) <LOG> { exception = exc ; } catch ( throwable exc ) { logger . info ( <string_literal> , exc ) ; exception = exc ; <ect>
if ( ! done ) wait <identifiersep> for <identifiersep> response ( 0 ) ; if ( response != null ) { return response ; } else if ( exception instanceof socket <identifiersep> timeout <identifiersep> exception ) <LOG> { throw ( io <identifiersep> exception ) exception ; } else if ( exception instanceof io <identifiersep> exception ) { logger . warn ( <string_literal> , exception ) ; throw ( io <identifiersep> exception ) exception ; <ect>
else if ( exception instanceof runtime <identifiersep> exception ) { logger . warn ( <string_literal> , exception ) ; throw ( runtime <identifiersep> exception ) exception ; } else if ( exception instanceof error ) <LOG> { throw ( error ) exception ; } else { logger . warn ( <string_literal> , exception ) ; <ect>
{ if ( packet <identifiersep> logging <identifiersep> service != null ) packet <identifiersep> logging <identifiersep> service . stop ( ) ; configuration <identifiersep> service = null ; file <identifiersep> access <identifiersep> service = null ; <LOG> packet <identifiersep> logging <identifiersep> service = null ; } <comment> <ect>
<comment> public synchronized void queue <identifiersep> packet ( packet packet ) { if ( evicting <identifiersep> queue <identifiersep> max <identifiersep> size - pkts <identifiersep> to <identifiersep> save . size ( ) == 0 ) <LOG> { } pkts <identifiersep> to <identifiersep> save . add ( packet ) ; notify <identifiersep> all ( ) ; } } } <ect>
try { dbus <identifiersep> conn . add <identifiersep> sig <identifiersep> handler ( d <identifiersep> bus . name <identifiersep> owner <identifiersep> changed . class , this ) ; dbus <identifiersep> conn . add <identifiersep> sig <identifiersep> handler ( d <identifiersep> bus <identifiersep> network <identifiersep> manager . state <identifiersep> change . class , this ) ; dbus <identifiersep> conn . add <identifiersep> sig <identifiersep> handler ( d <identifiersep> bus <identifiersep> network <identifiersep> manager . state <identifiersep> changed . class , this ) ; } catch ( d <identifiersep> bus <identifiersep> exception e ) <LOG> { } } <comment> @ suppress <identifiersep> warnings ( <string_literal> ) public void stop ( ) <ect>
idle <identifiersep> state <identifiersep> check <identifiersep> delay = check <identifiersep> for <identifiersep> idle <identifiersep> default ; } <comment> <LOG> { return ; } catch ( throwable t ) { logger . error ( <string_literal> , t ) ; } } } <comment> <ect>
{ int event <identifiersep> id = evt . get <identifiersep> event <identifiersep> id ( ) ; <comment> <LOG> { } if ( event <identifiersep> id == system <identifiersep> activity <identifiersep> event . event <identifiersep> network <identifiersep> change ) { <comment> <ect>
{ listener . activity <identifiersep> changed ( evt ) ; } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; <LOG> else } } <comment> <ect>
{ listener . activity <identifiersep> changed ( evt ) ; } catch ( throwable t ) { if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; <LOG> else } } <comment> <ect>
logger . info ( <string_literal> + listeners . size ( ) + <string_literal> + evt ) ; } try { listener . activity <identifiersep> changed ( evt ) ; } catch ( throwable e ) <LOG> { } } <comment> public void run ( ) { <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <LOG> sys <identifiersep> activity <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; sys <identifiersep> activities <identifiersep> service <identifiersep> impl = new system <identifiersep> activity <identifiersep> notifications <identifiersep> service <identifiersep> impl ( ) ; sys <identifiersep> activities <identifiersep> service <identifiersep> impl . start ( ) ; bundle <identifiersep> context . register <identifiersep> service ( system <identifiersep> activity <identifiersep> notifications <identifiersep> service . class . get <identifiersep> name ( ) , sys <identifiersep> activities <identifiersep> service <identifiersep> impl , <ect>
iterator < history <identifiersep> record > recs = reader . find <identifiersep> last ( count ) ; while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , item ) ) ; } } catch ( io <identifiersep> exception e ) <LOG> { } } collections . sort ( result , new message <identifiersep> event <identifiersep> comparator < event <identifiersep> object > ( ) ) ; int start <identifiersep> index = result . size ( ) - count ; if ( start <identifiersep> index < 0 ) start <identifiersep> index = 0 ; return result . sub <identifiersep> list ( start <identifiersep> index , result . size ( ) ) ; <ect>
try { <comment> <LOG> { return null ; } } <comment> <ect>
while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , item ) ) ; } } catch ( io <identifiersep> exception e ) <LOG> { } } collections . sort ( result , new message <identifiersep> event <identifiersep> comparator < event <identifiersep> object > ( ) ) ; int start <identifiersep> index = result . size ( ) - count ; if ( start <identifiersep> index < 0 ) start <identifiersep> index = 0 ; return result . sub <identifiersep> list ( start <identifiersep> index , result . size ( ) ) ; <ect>
is <identifiersep> sms <identifiersep> subtype ? msg <identifiersep> subtype <identifiersep> sms : null } , message <identifiersep> timestamp , structure <identifiersep> names [ <number_literal> ] ) ; <comment> <LOG> { } } <comment> <ect>
{ synchronized ( this . sync <identifiersep> root <identifiersep> history <identifiersep> service ) { if ( this . history <identifiersep> service == history <identifiersep> service ) { <LOG> this . history <identifiersep> service = null ; } } } <comment> <ect>
logger . trace ( <string_literal> + s <identifiersep> service . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; <comment> <LOG> return ; } if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { logger . debug ( <string_literal> ) ; this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; <ect>
{ op <identifiersep> set <identifiersep> im . add <identifiersep> message <identifiersep> listener ( this ) ; if ( this . message <identifiersep> source <identifiersep> service != null ) op <identifiersep> set <identifiersep> im . add <identifiersep> message <identifiersep> listener ( message <identifiersep> source <identifiersep> service ) ; } else <LOG> { } operation <identifiersep> set <identifiersep> sms <identifiersep> messaging op <identifiersep> set <identifiersep> sms = provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> sms <identifiersep> messaging . class ) ; if ( op <identifiersep> set <identifiersep> sms != null ) { op <identifiersep> set <identifiersep> sms . add <identifiersep> message <identifiersep> listener ( this ) ; <ect>
room . add <identifiersep> message <identifiersep> listener ( this ) ; } op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat . add <identifiersep> presence <identifiersep> listener ( this ) ; if ( message <identifiersep> source <identifiersep> service != null ) op <identifiersep> set <identifiersep> multi <identifiersep> u <identifiersep> chat . add <identifiersep> presence <identifiersep> listener ( message <identifiersep> source <identifiersep> service ) ; } else <LOG> { } if ( message <identifiersep> source <identifiersep> service != null ) { operation <identifiersep> set <identifiersep> presence op <identifiersep> set <identifiersep> presence = provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> presence . class ) ; if ( op <identifiersep> set <identifiersep> presence != null ) <ect>
iterator < history <identifiersep> record > recs = reader . find <identifiersep> by <identifiersep> start <identifiersep> date ( start <identifiersep> date ) ; while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( reader ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return result ; } <comment> <ect>
iterator < history <identifiersep> record > recs = reader . find <identifiersep> by <identifiersep> period ( start <identifiersep> date , end <identifiersep> date ) ; while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( reader ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return result ; } <comment> <ect>
while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( reader ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return result ; } <comment> <ect>
while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } } catch ( io <identifiersep> exception e ) <LOG> { } collections . sort ( result , new chat <identifiersep> room <identifiersep> message <identifiersep> event <identifiersep> comparator < event <identifiersep> object > ( ) ) ; int start <identifiersep> index = result . size ( ) - count ; if ( start <identifiersep> index < 0 ) start <identifiersep> index = 0 ; <ect>
while ( recs . has <identifiersep> next ( ) ) { result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> message <identifiersep> event ( recs . next ( ) , room ) ) ; } } catch ( io <identifiersep> exception e ) <LOG> { } collections . sort ( result , new chat <identifiersep> room <identifiersep> message <identifiersep> event <identifiersep> comparator < event <identifiersep> object > ( ) ) ; int start <identifiersep> index = result . size ( ) - count ; if ( start <identifiersep> index < 0 ) start <identifiersep> index = 0 ; <ect>
{ history history = this . get <identifiersep> history <identifiersep> for <identifiersep> ad <identifiersep> hoc <identifiersep> multi <identifiersep> chat ( evt . get <identifiersep> source <identifiersep> chat <identifiersep> room ( ) ) ; write <identifiersep> message ( history , <string_literal> , evt . get <identifiersep> source <identifiersep> chat <identifiersep> room <identifiersep> participant ( ) , evt . get <identifiersep> message ( ) , evt . get <identifiersep> timestamp ( ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } <comment> <ect>
msc . get <identifiersep> contact <identifiersep> address ( ) , sdf . format ( msc . get <identifiersep> timestamp ( ) ) , recent <identifiersep> msgs <identifiersep> ver } , number <identifiersep> of <identifiersep> msgs <identifiersep> in <identifiersep> history ) ; } catch ( io <identifiersep> exception ex ) <LOG> { return ; } } } <comment> private void update <identifiersep> recent <identifiersep> message <identifiersep> to <identifiersep> history ( final comparable <identifiersep> evt <identifiersep> obj msg ) <ect>
msg <identifiersep> history <identifiersep> service = new message <identifiersep> history <identifiersep> service <identifiersep> impl ( ) ; msg <identifiersep> history <identifiersep> service . set <identifiersep> history <identifiersep> service ( history <identifiersep> service ) ; msg <identifiersep> history <identifiersep> service . start ( bundle <identifiersep> context ) ; bundle <identifiersep> context . register <identifiersep> service ( <LOG> message <identifiersep> history <identifiersep> service . class . get <identifiersep> name ( ) , msg <identifiersep> history <identifiersep> service , null ) ; } finally { logger . log <identifiersep> exit ( ) ; } } <comment> <ect>
case search <identifiersep> cancelled : case search <identifiersep> achieved : query = ( ldap <identifiersep> query ) event . get <identifiersep> content ( ) ; if ( this . pending <identifiersep> searches . get ( query ) != null ) { this . pending <identifiersep> searches . get ( query ) . get <identifiersep> pending <identifiersep> servers ( ) . remove ( <LOG> event . get <identifiersep> source ( ) ) ; <string_literal> + event . get <identifiersep> source ( ) + <string_literal> ) ; if ( pending <identifiersep> searches . get ( query ) . get <identifiersep> pending <identifiersep> servers ( ) . size ( ) == 0 ) { fire <identifiersep> ldap <identifiersep> event ( event , pending <identifiersep> searches . get ( query ) . <ect>
try { dir <identifiersep> context . close ( ) ; } catch ( naming <identifiersep> exception e ) { logger . trace ( <string_literal> + this + <LOG> <string_literal> ) ; } } <comment> <ect>
attribute attribute = attributes . get ( <string_literal> ) ; naming <identifiersep> enumeration < ? > values = attribute . get <identifiersep> all ( ) ; while ( values . has <identifiersep> more ( ) ) { nodes . add ( ( string ) values . next ( ) ) ; } } } catch ( naming <identifiersep> exception e ) <LOG> { } finally { if ( dir <identifiersep> context != null ) disconnect ( dir <identifiersep> context ) ; } } else <ect>
while ( result . has <identifiersep> more ( ) ) { search <identifiersep> result sr = ( search <identifiersep> result ) result . next ( ) ; nodes . add ( sr . get <identifiersep> name ( ) ) ; logger . trace ( sr . get <identifiersep> name ( ) ) ; } } catch ( naming <identifiersep> exception e ) <LOG> { e . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { if ( dir <identifiersep> context != null ) disconnect ( dir <identifiersep> context ) ; <ect>
while ( rs . has <identifiersep> next ( ) ) { history <identifiersep> record hr = rs . next ( ) ; result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> call <identifiersep> record ( hr ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( history <identifiersep> reader ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } return result ; } <comment> <ect>
while ( rs . has <identifiersep> next ( ) ) { history <identifiersep> record hr = rs . next ( ) ; result . add ( convert <identifiersep> history <identifiersep> record <identifiersep> to <identifiersep> call <identifiersep> record ( hr ) ) ; } remove <identifiersep> history <identifiersep> search <identifiersep> progress <identifiersep> listeners ( history <identifiersep> reader ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } return result ; } <comment> <ect>
= history . get <identifiersep> interactive <identifiersep> reader ( ) ; history <identifiersep> query history <identifiersep> query = history <identifiersep> reader . find <identifiersep> by <identifiersep> keyword ( address , <string_literal> , record <identifiersep> count ) ; call <identifiersep> query = new call <identifiersep> history <identifiersep> query <identifiersep> impl ( history <identifiersep> query ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } return call <identifiersep> query ; } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bc ) <LOG> { this . bundle <identifiersep> context = bc ; <comment> <ect>
<comment> public void set <identifiersep> history <identifiersep> service ( history <identifiersep> service history <identifiersep> service ) throws illegal <identifiersep> argument <identifiersep> exception , io <identifiersep> exception { synchronized ( this . sync <identifiersep> root <identifiersep> history <identifiersep> service ) { <LOG> this . history <identifiersep> service = history <identifiersep> service ; } } <comment> <ect>
logger . trace ( <string_literal> + s <identifiersep> service . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; <comment> <LOG> return ; } if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) { logger . debug ( <string_literal> ) ; this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; <ect>
<comment> private void handle <identifiersep> provider <identifiersep> added ( protocol <identifiersep> provider <identifiersep> service provider ) <LOG> { <comment> <ect>
return ; history history ; try { history = this . get <identifiersep> history ( null , null ) ; } catch ( io <identifiersep> exception e ) <LOG> { return ; } history <identifiersep> writer history <identifiersep> writer = history . get <identifiersep> writer ( ) ; history <identifiersep> writer . history <identifiersep> record <identifiersep> updater updater = new history <identifiersep> writer . history <identifiersep> record <identifiersep> updater ( ) { <ect>
return changes <identifiersep> map ; } } ; try { history <identifiersep> writer . update <identifiersep> record ( updater ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bc ) throws exception <LOG> { bundle <identifiersep> context = bc ; get <identifiersep> configuration <identifiersep> service ( ) ; bc . register <identifiersep> service ( popup <identifiersep> message <identifiersep> handler . class . get <identifiersep> name ( ) , new popup <identifiersep> message <identifiersep> handler <identifiersep> swing <identifiersep> impl ( ) <ect>
return started ; } <comment> public void stop ( ) <LOG> { this . started = false ; synchronized ( contact <identifiersep> list <identifiersep> rw <identifiersep> lock ) { contact <identifiersep> list <identifiersep> rw <identifiersep> lock . notify <identifiersep> all ( ) ; } } <comment> <ect>
fa <identifiersep> service . create <identifiersep> fail <identifiersep> safe <identifiersep> transaction ( this . contactlist <identifiersep> file ) ; contactlist <identifiersep> trans . restore <identifiersep> file ( ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( illegal <identifiersep> state <identifiersep> exception e ) <LOG> { } try { <comment> <ect>
{ try { contact <identifiersep> list <identifiersep> document = builder . parse ( contactlist <identifiersep> file ) ; } catch ( throwable ex ) { <LOG> logger . error ( <string_literal> , ex ) ; <comment> <ect>
{ <comment> <LOG> { } <comment> <ect>
contact <identifiersep> list <identifiersep> rw <identifiersep> lock . wait ( <number_literal> ) ; if ( is <identifiersep> modified ) { store <identifiersep> contact <identifiersep> list0 ( ) ; is <identifiersep> modified = false ; } } } } catch ( io <identifiersep> exception ex ) <LOG> { started = false ; } catch ( interrupted <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; started = false ; <ect>
proto <identifiersep> contact . get <identifiersep> address ( ) ) ; proto <identifiersep> contact <identifiersep> element . set <identifiersep> attribute ( account <identifiersep> id <identifiersep> attr <identifiersep> name , proto <identifiersep> contact . get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> unique <identifiersep> id ( ) ) ; && proto <identifiersep> contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) == null ) <LOG> { logger . info ( <string_literal> + proto <identifiersep> contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) ) ; } if ( proto <identifiersep> contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) == null ) return null ; proto <identifiersep> contact <identifiersep> element . set <identifiersep> attribute ( parent <identifiersep> proto <identifiersep> group <identifiersep> uid <identifiersep> attr <identifiersep> name , <ect>
{ element old <identifiersep> mc <identifiersep> node = find <identifiersep> meta <identifiersep> contact <identifiersep> node ( evt . get <identifiersep> old <identifiersep> parent ( ) . get <identifiersep> meta <identifiersep> uid ( ) ) ; <comment> <LOG> { + old <identifiersep> mc <identifiersep> node ) ; return ; } element proto <identifiersep> node = xml <identifiersep> utils . locate <identifiersep> element ( old <identifiersep> mc <identifiersep> node , proto <identifiersep> contact <identifiersep> node <identifiersep> name , proto <identifiersep> contact <identifiersep> address <identifiersep> attr <identifiersep> name , evt . get <identifiersep> proto <identifiersep> contact ( ) <ect>
<comment> public void start ( bundle <identifiersep> context bc ) <LOG> { this . bundle <identifiersep> context = bc ; <comment> <ect>
<comment> <LOG> { throw new null <identifiersep> pointer <identifiersep> exception ( <string_literal> ) ; } operation <identifiersep> set <identifiersep> persistent <identifiersep> presence op <identifiersep> set <identifiersep> pers <identifiersep> presence = proto <identifiersep> provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence . class ) ; <comment> <ect>
<comment> public void purge <identifiersep> locally <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> copy ( ) { this . storage <identifiersep> manager . store <identifiersep> contact <identifiersep> list <identifiersep> and <identifiersep> stop <identifiersep> storage <identifiersep> manager ( ) ; <LOG> this . storage <identifiersep> manager . remove <identifiersep> contact <identifiersep> list <identifiersep> file ( ) ; } <comment> <ect>
<comment> private void handle <identifiersep> provider <identifiersep> removed ( protocol <identifiersep> provider <identifiersep> service provider ) <LOG> { this . currently <identifiersep> installed <identifiersep> providers . remove ( provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> unique <identifiersep> id ( ) ) ; <comment> <ect>
if ( service instanceof protocol <identifiersep> provider <identifiersep> factory ) { source <identifiersep> factory = ( protocol <identifiersep> provider <identifiersep> factory ) service ; break ; } } if ( event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) <LOG> { <comment> <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) <LOG> { contact source <identifiersep> contact = evt . get <identifiersep> source <identifiersep> contact ( ) ; <comment> <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) <LOG> { meta <identifiersep> contact <identifiersep> impl meta <identifiersep> contact = ( meta <identifiersep> contact <identifiersep> impl ) find <identifiersep> meta <identifiersep> contact <identifiersep> by <identifiersep> contact ( evt . get <identifiersep> source <identifiersep> contact ( ) ) ; meta <identifiersep> contact <identifiersep> group <identifiersep> impl meta <identifiersep> contact <identifiersep> group = ( meta <identifiersep> contact <identifiersep> group <identifiersep> impl ) find <identifiersep> meta <identifiersep> contact <identifiersep> group <identifiersep> by <identifiersep> contact <identifiersep> group ( evt . get <identifiersep> parent <identifiersep> group ( ) ) ; meta <identifiersep> contact . remove <identifiersep> proto <identifiersep> contact ( evt . get <identifiersep> source <identifiersep> contact ( ) ) ; <ect>
<comment> public void group <identifiersep> removed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) <LOG> { meta <identifiersep> contact <identifiersep> group <identifiersep> impl meta <identifiersep> contact <identifiersep> group = ( meta <identifiersep> contact <identifiersep> group <identifiersep> impl ) find <identifiersep> meta <identifiersep> contact <identifiersep> group <identifiersep> by <identifiersep> contact <identifiersep> group ( evt . get <identifiersep> source <identifiersep> group ( ) ) ; if ( meta <identifiersep> contact <identifiersep> group == null ) { logger . error ( <ect>
case meta <identifiersep> contact <identifiersep> event . meta <identifiersep> contact <identifiersep> added : listener . meta <identifiersep> contact <identifiersep> added ( evt ) ; break ; case meta <identifiersep> contact <identifiersep> event . meta <identifiersep> contact <identifiersep> removed : listener . meta <identifiersep> contact <identifiersep> removed ( evt ) ; break ; <LOG> default : } } } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context context ) throws exception { <LOG> bundle <identifiersep> context = context ; mcl <identifiersep> service <identifiersep> impl = new meta <identifiersep> contact <identifiersep> list <identifiersep> service <identifiersep> impl ( ) ; <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception <LOG> { if ( mcl <identifiersep> service <identifiersep> impl != null ) mcl <identifiersep> service <identifiersep> impl . stop ( context ) ; } <comment> <ect>
immutable <identifiersep> default <identifiersep> properties . remove ( name ) ; } } } catch ( exception ex ) { <comment> <LOG> + <string_literal> ) ; } } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { if ( use <identifiersep> prop <identifiersep> file <identifiersep> config <identifiersep> service ( bundle <identifiersep> context ) ) <LOG> { this . cs = lib <identifiersep> jitsi . get <identifiersep> configuration <identifiersep> service ( ) ; } else { this . cs = new jdbc <identifiersep> config <identifiersep> service ( service <identifiersep> utils . get <identifiersep> service ( <ect>
<comment> public void start ( bundle <identifiersep> context bc ) <LOG> { this . bundle <identifiersep> context = bc ; services . clear ( ) ; <comment> <ect>
+ <string_literal> ) ; } try { thread . sleep ( shutdown <identifiersep> timeout ) ; } catch ( interrupted <identifiersep> exception ex ) <LOG> { return ; } <comment> <ect>
<comment> try { delete <identifiersep> on <identifiersep> halt <identifiersep> hook . run <identifiersep> hooks ( ) ; } catch ( throwable t ) { <LOG> logger . warn ( <string_literal> , t ) ; } runtime . get <identifiersep> runtime ( ) . halt ( system <identifiersep> exit <identifiersep> code ) ; } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context context ) throws exception <LOG> { version <identifiersep> activator . bundle <identifiersep> context = context ; context . register <identifiersep> service ( version <identifiersep> service . class . get <identifiersep> name ( ) , new version <identifiersep> service <identifiersep> impl ( ) , <ect>
peer . gtk <identifiersep> menu <identifiersep> item = gtk . gtk <identifiersep> separator <identifiersep> menu <identifiersep> item <identifiersep> new ( ) ; } if ( em instanceof j <identifiersep> menu <identifiersep> item ) { create <identifiersep> gtk <identifiersep> menu <identifiersep> item ( peer ) ; } if ( em instanceof j <identifiersep> menu && peer . gtk <identifiersep> menu <identifiersep> item != null ) { <LOG> j <identifiersep> menu m = ( j <identifiersep> menu ) em ; peer . gtk <identifiersep> menu = gtk . gtk <identifiersep> menu <identifiersep> new ( ) ; create <identifiersep> gtk <identifiersep> menu <identifiersep> items ( peer , m . get <identifiersep> menu <identifiersep> components ( ) ) ; gtk . gtk <identifiersep> menu <identifiersep> item <identifiersep> set <identifiersep> submenu ( peer . gtk <identifiersep> menu <identifiersep> item , peer . gtk <identifiersep> menu ) ; } if ( peer . gtk <identifiersep> menu <identifiersep> item != null ) { <ect>
peer . gtk <identifiersep> menu <identifiersep> item , peer . gtk <identifiersep> image ) ; gtk . gtk <identifiersep> image <identifiersep> menu <identifiersep> item <identifiersep> set <identifiersep> always <identifiersep> show <identifiersep> image ( peer . gtk <identifiersep> menu <identifiersep> item , 1 ) ; } } } if ( peer . gtk <identifiersep> menu <identifiersep> item == null ) <LOG> { return ; } menu <identifiersep> item <identifiersep> change <identifiersep> listener micl = new menu <identifiersep> item <identifiersep> change <identifiersep> listener ( peer ) ; m . add <identifiersep> property <identifiersep> change <identifiersep> listener ( micl ) ; m . add <identifiersep> change <identifiersep> listener ( micl ) ; <comment> <ect>
this . peer = peer ; this . menu = ( j <identifiersep> menu <identifiersep> item ) peer . menu <identifiersep> item ; } @ override public void property <identifiersep> change ( property <identifiersep> change <identifiersep> event evt ) { <LOG> { } switch ( evt . get <identifiersep> property <identifiersep> name ( ) ) { case j <identifiersep> menu <identifiersep> item . text <identifiersep> changed <identifiersep> property : gtk . gdk <identifiersep> threads <identifiersep> enter ( ) ; try <ect>
j <identifiersep> menu <identifiersep> item menu = ( j <identifiersep> menu <identifiersep> item ) peer . menu <identifiersep> item ; if ( menu instanceof j <identifiersep> check <identifiersep> box <identifiersep> menu <identifiersep> item ) { <comment> <LOG> <comment> <ect>
{ return ; } string p = string . format ( <string_literal> + indent * <number_literal> + <string_literal> , 0 ) . replace ( '0' , ' ' ) ; for ( component em : components ) { if ( em instanceof j <identifiersep> popup <identifiersep> menu . separator ) <LOG> { } if ( em instanceof j <identifiersep> menu <identifiersep> item ) { j <identifiersep> menu <identifiersep> item m = ( j <identifiersep> menu <identifiersep> item ) em ; logger . debug ( p + em . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + m . get <identifiersep> text ( ) ) ; } if ( em instanceof j <identifiersep> menu ) <ect>
<comment> public final static system <identifiersep> tray get <identifiersep> system <identifiersep> tray ( ) { if ( system <identifiersep> tray == null ) { <LOG> string mode = get <identifiersep> system <identifiersep> tray <identifiersep> mode ( ) ; switch ( mode ) { case disabled <identifiersep> tray <identifiersep> mode : return null ; case <string_literal> : <ect>
break ; case <string_literal> : try { system <identifiersep> tray = new app <identifiersep> indicator <identifiersep> tray ( false ) ; } catch ( exception ex ) <LOG> { } break ; } if ( system <identifiersep> tray == null ) { os <identifiersep> dependent <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . set <identifiersep> property ( systray <identifiersep> service . pnmae <identifiersep> tray <identifiersep> mode , <string_literal> ) ; <ect>
logger . info ( <string_literal> ) ; bundle <identifiersep> context . register <identifiersep> service ( systray <identifiersep> service . class . get <identifiersep> name ( ) , systray <identifiersep> service , <LOG> null ) ; <comment> <ect>
logger . info ( <string_literal> ) ; bundle <identifiersep> context . register <identifiersep> service ( desktop <identifiersep> service . class . get <identifiersep> name ( ) , desktop <identifiersep> service , <LOG> null ) ; logger . log <identifiersep> entry ( ) ; } finally { logger . log <identifiersep> exit ( ) ; } } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception <LOG> { google <identifiersep> contacts <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; google <identifiersep> contacts <identifiersep> service = new google <identifiersep> contacts <identifiersep> service <identifiersep> impl ( ) ; service <identifiersep> registration = bundle <identifiersep> context . register <identifiersep> service ( google <identifiersep> contacts <identifiersep> service . class . get <identifiersep> name ( ) , <ect>
{ dialog . set <identifiersep> visible ( true ) ; } switch ( dialog . get <identifiersep> response ( ) ) { case confirmed : <comment> <LOG> final string approval <identifiersep> code = dialog . get <identifiersep> approval <identifiersep> code ( ) ; token = request <identifiersep> authentication <identifiersep> token ( approval <identifiersep> code ) ; save <identifiersep> refresh <identifiersep> token ( token , identity ) ; break ; case cancelled : default : <ect>
( refresh <identifiersep> token <identifiersep> request ) data ; content . put ( <string_literal> , google <identifiersep> api <identifiersep> client <identifiersep> id ) ; content . put ( <string_literal> , google <identifiersep> api <identifiersep> client <identifiersep> secret ) ; logger . info ( <string_literal> + <string_literal> ) ; <LOG> { } } else { logger . debug ( <string_literal> ) ; } } } ) ; builder . add <identifiersep> refresh <identifiersep> listener ( new credential <identifiersep> refresh <identifiersep> listener ( ) <ect>
{ count = max <identifiersep> result ; } try { url = new url ( feed <identifiersep> url ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) <LOG> { return ret ; } if ( g <identifiersep> query . is <identifiersep> cancelled ( ) ) { return ret ; } while ( matched <identifiersep> contacts < count || end <identifiersep> of <identifiersep> contacts ) <ect>
public google <identifiersep> contacts <identifiersep> connection get <identifiersep> connection ( string login ) { try { return new google <identifiersep> contacts <identifiersep> connection <identifiersep> impl ( login ) ; } catch ( exception e ) <LOG> { return null ; } } <comment> <ect>
{ try { google <identifiersep> service . set <identifiersep> o <identifiersep> auth2credentials ( this . store . get ( this . login ) ) ; return connection <identifiersep> status . success ; } catch ( failed <identifiersep> acquire <identifiersep> credential <identifiersep> exception e ) <LOG> { return connection <identifiersep> status . error <identifiersep> unknown ; } } <comment> <ect>
{ logger . debug ( <string_literal> ) ; <LOG> for ( string capability : capabilities ) } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context context ) { if ( this . keybindings <identifiersep> service == null ) { <LOG> bundle <identifiersep> context = context ; + <string_literal> ) ; this . keybindings <identifiersep> service = new keybindings <identifiersep> service <identifiersep> impl ( ) ; this . keybindings <identifiersep> service . start ( context ) ; context . register <identifiersep> service ( keybindings <identifiersep> service . class . get <identifiersep> name ( ) , this . keybindings <identifiersep> service , null ) ; <ect>
hashtable < string , string > hashtable = new hashtable < string , string > ( ) ; hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> metacafe <identifiersep> impl . metacafe <identifiersep> config <identifiersep> label ) ; metacafe <identifiersep> source = new replacement <identifiersep> service <identifiersep> metacafe <identifiersep> impl ( ) ; metacafe <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> metacafe <identifiersep> source , hashtable ) ; } <comment> <ect>
<comment> public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> dailymotion <identifiersep> impl ( ) <LOG> { } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { <LOG> dailymotion <identifiersep> source <identifiersep> serv <identifiersep> reg . unregister ( ) ; } } <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { <LOG> flickr <identifiersep> serv <identifiersep> reg . unregister ( ) ; } } <ect>
string secret = ( string ) result . get ( <string_literal> ) ; thumb <identifiersep> url = <string_literal> + farm <identifiersep> id + <string_literal> + server <identifiersep> id + <string_literal> + m . group ( 1 ) + <string_literal> + secret + <string_literal> ; } } } catch ( throwable e ) <LOG> { } } return thumb <identifiersep> url ; } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context bc ) throws exception { <LOG> viddler <identifiersep> serv <identifiersep> reg . unregister ( ) ; } } <ect>
context . register <identifiersep> service ( direct <identifiersep> image <identifiersep> replacement <identifiersep> service . class . get <identifiersep> name ( ) , direct <identifiersep> image <identifiersep> source , hashtable ) ; direct <identifiersep> image <identifiersep> source <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> direct <identifiersep> image <identifiersep> source , hashtable ) ; } <comment> <ect>
<string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> direct <identifiersep> image <identifiersep> impl ( ) { <LOG> set <identifiersep> max <identifiersep> img <identifiersep> size <identifiersep> from <identifiersep> conf ( ) ; } <comment> <ect>
<comment> public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> hulu <identifiersep> impl ( ) <LOG> { } <comment> <ect>
hashtable < string , string > hashtable = new hashtable < string , string > ( ) ; hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> hulu <identifiersep> impl . hulu <identifiersep> config <identifiersep> label ) ; hulu <identifiersep> source = new replacement <identifiersep> service <identifiersep> hulu <identifiersep> impl ( ) ; hulu <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> hulu <identifiersep> source , hashtable ) ; } <comment> <ect>
hashtable < string , string > hashtable = new hashtable < string , string > ( ) ; hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> youtube <identifiersep> impl . youtube <identifiersep> config <identifiersep> label ) ; youtube <identifiersep> source = new replacement <identifiersep> service <identifiersep> youtube <identifiersep> impl ( ) ; youtube <identifiersep> source <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> youtube <identifiersep> source , hashtable ) ; } <comment> <ect>
<comment> public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> youtube <identifiersep> impl ( ) <LOG> { } <comment> <ect>
smiley <identifiersep> source = new replacement <identifiersep> service <identifiersep> smiley <identifiersep> impl ( ) ; smiley <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( smilies <identifiersep> replacement <identifiersep> service . class . get <identifiersep> name ( ) , smiley <identifiersep> source , hashtable ) ; smiley <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> smiley <identifiersep> source , hashtable ) ; } <comment> <ect>
<comment> public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> bliptv <identifiersep> impl ( ) <LOG> { } <comment> <ect>
hashtable < string , string > hashtable = new hashtable < string , string > ( ) ; hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> bliptv <identifiersep> impl . bliptv <identifiersep> config <identifiersep> label ) ; bliptv <identifiersep> source = new replacement <identifiersep> service <identifiersep> bliptv <identifiersep> impl ( ) ; bliptv <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> bliptv <identifiersep> source , hashtable ) ; } <comment> <ect>
<comment> public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> vimeo <identifiersep> impl ( ) <LOG> { } <comment> <ect>
hashtable < string , string > hashtable = new hashtable < string , string > ( ) ; hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> vimeo <identifiersep> impl . vimeo <identifiersep> config <identifiersep> label ) ; vimeo <identifiersep> source = new replacement <identifiersep> service <identifiersep> vimeo <identifiersep> impl ( ) ; vimeo <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> vimeo <identifiersep> source , hashtable ) ; } <comment> <ect>
contact <identifiersep> group new <identifiersep> parent <identifiersep> group , contact contact , int index ) { <comment> <LOG> if ( parent <identifiersep> operation <identifiersep> set == null ) { return ; } <comment> <ect>
<comment> contact <identifiersep> icq <identifiersep> impl create <identifiersep> volatile <identifiersep> contact ( screenname screenname ) <LOG> { <comment> <ect>
<comment> <LOG> { <comment> <ect>
<comment> public void create <identifiersep> group ( string group <identifiersep> name ) <LOG> { buddy <identifiersep> list . add <identifiersep> group ( group <identifiersep> name ) ; logger . trace ( <string_literal> + group <identifiersep> name + <string_literal> ) ; } <comment> <ect>
public void group <identifiersep> added ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group , list < ? extends buddy > buddies ) <LOG> { logger . trace ( <string_literal> + buddies ) ; contact <identifiersep> group <identifiersep> icq <identifiersep> impl new <identifiersep> group = find <identifiersep> contact <identifiersep> group ( group . get <identifiersep> name ( ) ) ; <comment> <ect>
<comment> public void group <identifiersep> removed ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group ) <LOG> { int index = find <identifiersep> contact <identifiersep> group <identifiersep> index ( group ) ; if ( index == - 1 ) { logger . debug ( <string_literal> + group . get <identifiersep> name ( ) ) ; <ect>
public void buddy <identifiersep> added ( buddy <identifiersep> list list , group joust <identifiersep> sim <identifiersep> group , list < ? extends buddy > old <identifiersep> items , list < ? extends buddy > new <identifiersep> items , buddy buddy ) <LOG> { <comment> <ect>
logger . trace ( <string_literal> + contact <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> ) ; return ; } <comment> <LOG> <comment> <ect>
public void screenname <identifiersep> changed ( buddy buddy , screenname old <identifiersep> screenname , screenname new <identifiersep> screenname ) { <comment> <LOG> logger . debug ( <string_literal> ) ; } <comment> <ect>
<comment> public void alert <identifiersep> sound <identifiersep> changed ( buddy buddy , string old <identifiersep> alert <identifiersep> sound , string new <identifiersep> alert <identifiersep> sound ) { <LOG> <comment> } <comment> <ect>
<comment> public void alias <identifiersep> changed ( buddy buddy , string old <identifiersep> alias , string new <identifiersep> alias ) { <LOG> <comment> } <comment> <ect>
private static class joust <identifiersep> sim <identifiersep> item <identifiersep> change <identifiersep> listener implements ssi <identifiersep> item <identifiersep> change <identifiersep> listener { public void handle <identifiersep> item <identifiersep> created ( ssi <identifiersep> item item ) { <LOG> <comment> + <string_literal> + item . get <identifiersep> data ( ) . to <identifiersep> string ( ) ) ; } public void handle <identifiersep> item <identifiersep> deleted ( ssi <identifiersep> item item ) { <comment> <ect>
<comment> logger . debug ( <string_literal> + item ) ; } public void handle <identifiersep> item <identifiersep> modified ( ssi <identifiersep> item item ) { <LOG> <comment> + <string_literal> + item . get <identifiersep> data ( ) . to <identifiersep> string ( ) ) ; } } <comment> private class nick <identifiersep> retriever <ect>
byte [ ] image = null ; try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return image ; } } <ect>
request <identifiersep> id ) ; icq <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> info <identifiersep> service ( ) . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac ( offline <identifiersep> msg <identifiersep> delete <identifiersep> req ) ; } else if ( snac instanceof snac <identifiersep> error ) <LOG> { } } } <comment> <ect>
+ <string_literal> + info ) ; } public void send <identifiersep> automatically <identifiersep> failed ( icbm <identifiersep> service service , net . kano . joustsim . oscar . oscar . service . icbm . message message , set < conversation > tried <identifiersep> conversations ) <LOG> { } } <comment> <ect>
icq <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> icbm <identifiersep> service ( ) . get <identifiersep> im <identifiersep> conversation ( new screenname ( icq <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> user <identifiersep> id ( ) ) ) ; <comment> <LOG> new keep <identifiersep> alive <identifiersep> check <identifiersep> task ( ) , keepalive <identifiersep> wait ) ; im <identifiersep> conversation . send <identifiersep> message ( new simple <identifiersep> message ( sys <identifiersep> msg . to <identifiersep> string ( ) ) ) ; } catch ( exception ex ) { logger . error ( <string_literal> , ex ) ; } } } <comment> <ect>
boolean success = false ; private boolean timeout = false ; public void handle <identifiersep> sent ( snac <identifiersep> request <identifiersep> sent <identifiersep> event evt ) { } public void handle <identifiersep> timeout ( snac <identifiersep> request <identifiersep> timeout <identifiersep> event event ) <LOG> { synchronized ( waiting <identifiersep> for <identifiersep> response <identifiersep> lock ) { if ( ran ) return ; ran = true ; <ect>
<comment> <LOG> <comment> <ect>
{ contact <identifiersep> group . remove <identifiersep> contact ( contact <identifiersep> icq <identifiersep> impl ) ; fire <identifiersep> subscription <identifiersep> event ( contact <identifiersep> icq <identifiersep> impl , contact <identifiersep> group , subscription <identifiersep> event . subscription <identifiersep> removed ) ; <LOG> return ; } if ( ! contact <identifiersep> group . is <identifiersep> persistent ( ) && contact <identifiersep> icq <identifiersep> impl . get <identifiersep> joust <identifiersep> sim <identifiersep> buddy ( ) . is <identifiersep> awaiting <identifiersep> authorization ( ) ) { <comment> <ect>
{ bos <identifiersep> service . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac ( new set <identifiersep> info <identifiersep> cmd ( new info <identifiersep> data ( null , info <identifiersep> data . not <identifiersep> away , null , null ) ) ) ; } } } else { <LOG> long icq <identifiersep> status = presence <identifiersep> status <identifiersep> to <identifiersep> status <identifiersep> long ( status ) ; bos <identifiersep> service . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac ( new set <identifiersep> extra <identifiersep> info <identifiersep> cmd ( icq <identifiersep> status ) ) ; if ( status . equals ( icq <identifiersep> status <identifiersep> enum . away ) ) parent <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> info <identifiersep> service ( ) . set <identifiersep> away <identifiersep> message ( status <identifiersep> message ) ; else <ect>
logger . debug ( <string_literal> + evt . get <identifiersep> old <identifiersep> state ( ) + <string_literal> + evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) == registration <identifiersep> state . finalizing <identifiersep> registration ) <LOG> { parent <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> bos <identifiersep> service ( ) . add <identifiersep> main <identifiersep> bos <identifiersep> service <identifiersep> listener ( joust <identifiersep> sim <identifiersep> bos <identifiersep> listener ) ; ss <identifiersep> contact <identifiersep> list . init ( parent <identifiersep> provider . get <identifiersep> aim <identifiersep> connection ( ) . get <identifiersep> ssi <identifiersep> service ( ) ) ; <comment> <ect>
<comment> <LOG> block . get <identifiersep> extra <identifiersep> data ( ) ) ; if ( get <identifiersep> current <identifiersep> status <identifiersep> message ( ) . equals ( status <identifiersep> message ) ) { logger . debug ( <string_literal> ) ; return ; } string old <identifiersep> status <identifiersep> message = get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; <ect>
<comment> public void handle <identifiersep> your <identifiersep> info ( main <identifiersep> bos <identifiersep> service service , full <identifiersep> user <identifiersep> info user <identifiersep> info ) <LOG> { logger . debug ( <string_literal> + current <identifiersep> icq <identifiersep> status ) ; logger . debug ( <string_literal> + user <identifiersep> info . get <identifiersep> icq <identifiersep> status ( ) ) ; <comment> <ect>
full <identifiersep> user <identifiersep> info user <identifiersep> info ) { logger . debug ( <string_literal> + user <identifiersep> info ) ; <LOG> logger . debug ( <string_literal> + current <identifiersep> icq <identifiersep> status ) ; <comment> <ect>
<comment> public void got <identifiersep> buddy <identifiersep> status ( buddy <identifiersep> service service , screenname buddy , full <identifiersep> user <identifiersep> info info ) { <LOG> logger . debug ( <string_literal> + buddy ) ; contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( buddy . get <identifiersep> formatted ( ) ) ; if ( source <identifiersep> contact == null ) { logger . warn ( <string_literal> + buddy ) ; return ; <ect>
for ( extra <identifiersep> info <identifiersep> block block : extra <identifiersep> info <identifiersep> blocks ) { if ( block . get <identifiersep> type ( ) == extra <identifiersep> info <identifiersep> block . type <identifiersep> availmsg ) { string status = extra <identifiersep> info <identifiersep> data . read <identifiersep> available <identifiersep> message ( <LOG> block . get <identifiersep> extra <identifiersep> data ( ) ) ; source <identifiersep> contact . set <identifiersep> status <identifiersep> message ( status ) ; logger . debug ( <string_literal> ) ; fire <identifiersep> contact <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event ( source <identifiersep> contact , parent , old <identifiersep> status , new <identifiersep> status ) ; <ect>
<comment> public void buddy <identifiersep> offline ( buddy <identifiersep> service service , screenname buddy ) <LOG> { contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( buddy . get <identifiersep> formatted ( ) ) ; if ( source <identifiersep> contact == null ) return ; presence <identifiersep> status old <identifiersep> status <ect>
public void received <identifiersep> status <identifiersep> update ( buddy <identifiersep> info <identifiersep> manager manager , screenname buddy , buddy <identifiersep> info info ) { string status <identifiersep> message = info . get <identifiersep> status <identifiersep> message ( ) ; <LOG> logger . debug ( <string_literal> + buddy ) ; logger . debug ( <string_literal> + info . get <identifiersep> online <identifiersep> since ( ) ) ; logger . debug ( <string_literal> + status <identifiersep> message ) ; contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact <ect>
logger . debug ( <string_literal> + buddy ) ; logger . debug ( <string_literal> + info . get <identifiersep> away <identifiersep> message ( ) ) ; <LOG> logger . debug ( <string_literal> + info . get <identifiersep> online <identifiersep> since ( ) ) ; contact <identifiersep> icq <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( buddy . get <identifiersep> formatted ( ) ) ; if ( source <identifiersep> contact != null ) { source <identifiersep> contact . set <identifiersep> status <identifiersep> message ( status <identifiersep> message ) ; <ect>
new authorization <identifiersep> response ( authorization <identifiersep> response . reject , reason ) , src <identifiersep> contact ) ; try { unsubscribe ( src <identifiersep> contact ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { } } public void authorization <identifiersep> accepted ( screenname screenname , string reason ) { logger . trace ( <string_literal> + screenname ) ; contact src <identifiersep> contact = find <identifiersep> contact <identifiersep> by <identifiersep> id ( screenname . get <identifiersep> formatted ( ) ) ; <ect>
authorization <identifiersep> handler . process <identifiersep> authorization <identifiersep> response ( new authorization <identifiersep> response ( authorization <identifiersep> response . accept , reason ) , src <identifiersep> contact ) ; } public void authorization <identifiersep> request <identifiersep> received ( screenname screenname , string reason ) <LOG> { contact src <identifiersep> contact = find <identifiersep> contact <identifiersep> by <identifiersep> id ( screenname . get <identifiersep> formatted ( ) ) ; if ( src <identifiersep> contact == null ) src <identifiersep> contact = create <identifiersep> volatile <identifiersep> contact ( screenname . get <identifiersep> formatted ( ) ) ; authorization <identifiersep> request auth <identifiersep> request = new authorization <identifiersep> request ( ) ; auth <identifiersep> request . set <identifiersep> reason ( reason ) ; <ect>
auth <identifiersep> response . get <identifiersep> response <identifiersep> code ( ) == authorization <identifiersep> response . accept , auth <identifiersep> response . get <identifiersep> reason ( ) ) ; } public boolean authorization <identifiersep> required ( screenname screenname , group parent <identifiersep> group ) { <LOG> logger . trace ( <string_literal> + screenname ) ; contact <identifiersep> icq <identifiersep> impl src <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> screen <identifiersep> name ( screenname . get <identifiersep> formatted ( ) ) ; if ( src <identifiersep> contact == null ) { contact <identifiersep> group <identifiersep> icq <identifiersep> impl parent = <ect>
string reason ) { logger . trace ( <string_literal> + screenname ) ; } public void you <identifiersep> were <identifiersep> added ( screenname screenname ) <LOG> { } } <comment> private class icon <identifiersep> update <identifiersep> listener implements icon <identifiersep> request <identifiersep> listener <ect>
{ logger . trace ( <string_literal> ) ; read <identifiersep> work <identifiersep> user <identifiersep> info ( ( meta <identifiersep> work <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> notes <identifiersep> info <identifiersep> cmd ) <LOG> { read <identifiersep> user <identifiersep> about <identifiersep> info ( ( meta <identifiersep> notes <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> interests <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; <ect>
{ logger . trace ( <string_literal> ) ; read <identifiersep> interests <identifiersep> user <identifiersep> info ( ( meta <identifiersep> interests <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> affiliations <identifiersep> info <identifiersep> cmd ) <LOG> { read <identifiersep> affilations <identifiersep> user <identifiersep> info ( ( meta <identifiersep> affiliations <identifiersep> info <identifiersep> cmd ) snac ) ; result = get <identifiersep> info <identifiersep> for <identifiersep> request ( ( ( meta <identifiersep> affiliations <identifiersep> info <identifiersep> cmd ) snac ) . get <identifiersep> id ( ) ) ; <comment> <ect>
new date ( ) , message , ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> message <identifiersep> delivered <identifiersep> event . conversation <identifiersep> message <identifiersep> delivered ) ; fire <identifiersep> message <identifiersep> event ( msg <identifiersep> delivered <identifiersep> evt ) ; } catch ( exception e ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error ) ; } } <comment> <ect>
{ try { chat <identifiersep> room . join ( ) ; } catch ( exception e ) <LOG> { } } if ( invite <identifiersep> user <identifiersep> list != null && new <identifiersep> chat <identifiersep> session <identifiersep> state . equals ( chat <identifiersep> session <identifiersep> state . inroom ) ) { iterator < map . entry < string , string > > invites <identifiersep> iter = invite <identifiersep> user <identifiersep> list . entry <identifiersep> set ( ) . iterator ( ) ; <ect>
byte [ ] image = null ; try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return image ; } public static resource <identifiersep> management <identifiersep> service get <identifiersep> resources ( ) { if ( resources <identifiersep> service == null ) { <ect>
<comment> <LOG> else } else if ( new <identifiersep> state == state . failed ) { <comment> <ect>
<comment> public void buddy <identifiersep> info <identifiersep> updated ( icbm <identifiersep> service service , screenname buddy , icbm <identifiersep> buddy <identifiersep> info info ) <LOG> { } <comment> <ect>
{ logger . debug ( <string_literal> + event ) ; } <comment> <LOG> { } public void got <identifiersep> other <identifiersep> event ( conversation conversation , conversation <identifiersep> event <identifiersep> info event ) { logger . debug ( <string_literal> ) ; <ect>
logger . debug ( <string_literal> + ti . get <identifiersep> typing <identifiersep> state ( ) ) ; } else if ( event instanceof message <identifiersep> info ) { <LOG> message <identifiersep> info ti = ( message <identifiersep> info ) event ; } } public void can <identifiersep> send <identifiersep> message <identifiersep> changed ( conversation con , boolean can <identifiersep> send ) { logger . debug ( <string_literal> ) ; } <comment> <ect>
{ logger . debug ( <string_literal> ) ; } <comment> <LOG> { } <comment> <ect>
synchronized ( connect <identifiersep> and <identifiersep> login <identifiersep> lock ) { in <identifiersep> connect <identifiersep> and <identifiersep> login = true ; } initialize <identifiersep> connect <identifiersep> and <identifiersep> login ( authority , security <identifiersep> authority . authentication <identifiersep> required ) ; } catch ( xmpp <identifiersep> exception ex ) <LOG> { event <identifiersep> during <identifiersep> login = null ; fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( ex ) ; } finally { synchronized ( connect <identifiersep> and <identifiersep> login <identifiersep> lock ) <ect>
<comment> <LOG> { event <identifiersep> during <identifiersep> login = null ; disconnect <identifiersep> and <identifiersep> clean <identifiersep> connection ( ) ; fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( get <identifiersep> registration <identifiersep> state ( ) , registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , null ) ; <ect>
if ( custom <identifiersep> xmpp <identifiersep> domain != null && ! had <identifiersep> dns <identifiersep> sec <identifiersep> exception [ 0 ] ) { logger . info ( <string_literal> + custom <identifiersep> xmpp <identifiersep> domain ) ; state = connect <identifiersep> using <identifiersep> srv <identifiersep> records ( custom <identifiersep> xmpp <identifiersep> domain , service <identifiersep> name , <LOG> had <identifiersep> dns <identifiersep> sec <identifiersep> exception , login <identifiersep> strategy ) ; if ( had <identifiersep> dns <identifiersep> sec <identifiersep> exception [ 0 ] ) { set <identifiersep> dnssec <identifiersep> login <identifiersep> failure ( ) ; return ; } if ( state == connect <identifiersep> state . abort <identifiersep> connecting <ect>
server <identifiersep> port ) ; } catch ( parse <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( dnssec <identifiersep> exception e ) <LOG> { set <identifiersep> dnssec <identifiersep> login <identifiersep> failure ( ) ; return ; } if ( addrs == null || addrs . length == 0 ) { logger . error ( <string_literal> ) ; <ect>
srv <identifiersep> record srv <identifiersep> records [ ] = null ; try { srv <identifiersep> records = network <identifiersep> utils . get <identifiersep> srv <identifiersep> records ( <string_literal> , <string_literal> , domain ) ; } catch ( parse <identifiersep> exception e ) <LOG> { } catch ( dnssec <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; dnssec <identifiersep> state [ 0 ] = true ; } if ( srv <identifiersep> records != null ) <ect>
addrs = network <identifiersep> utils . get <identifiersep> aand <identifiersep> aaaa <identifiersep> records ( srv . get <identifiersep> target ( ) , srv . get <identifiersep> port ( ) ) ; } catch ( parse <identifiersep> exception e ) <LOG> { } catch ( dnssec <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; dnssec <identifiersep> state [ 0 ] = true ; } if ( addrs == null || addrs . length == 0 ) <ect>
proxy = new org . jivesoftware . smack . proxy . proxy <identifiersep> info ( enum . value <identifiersep> of ( org . jivesoftware . smack . proxy . proxy <identifiersep> info . proxy <identifiersep> type . class , global <identifiersep> proxy <identifiersep> type ) , global <identifiersep> proxy <identifiersep> address , global <identifiersep> proxy <identifiersep> port , global <identifiersep> proxy <identifiersep> username , global <identifiersep> proxy <identifiersep> password ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) <LOG> { proxy = null ; } } } <comment> <ect>
{ next <identifiersep> hop = network <identifiersep> utils . get <identifiersep> inet <identifiersep> address ( next <identifiersep> hop <identifiersep> str ) ; } catch ( unknown <identifiersep> host <identifiersep> exception ex ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <LOG> <string_literal> , ex ) ; } return next <identifiersep> hop ; } <comment> public void start <identifiersep> jingle <identifiersep> nodes <identifiersep> discovery ( ) <ect>
domain ) ; } catch ( parse <identifiersep> exception e ) { logger . info ( <string_literal> ) ; return false ; } catch ( dnssec <identifiersep> exception e ) <LOG> { return false ; } if ( srv <identifiersep> records == null ) { return false ; } for ( srv <identifiersep> record srv : srv <identifiersep> records ) <ect>
class . for <identifiersep> name ( org . jivesoftware . smackx . bytestreams . socks5 . socks5bytestream <identifiersep> manager . class . get <identifiersep> name ( ) ) ; class . for <identifiersep> name ( xhtml <identifiersep> manager . class . get <identifiersep> name ( ) ) ; class . for <identifiersep> name ( org . jivesoftware . smackx . bytestreams . ibb . in <identifiersep> band <identifiersep> bytestream <identifiersep> manager . class . get <identifiersep> name ( ) ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) <LOG> { } } <comment> <ect>
return null ; } <comment> <LOG> { return null ; } password = new string ( pass ) ; if ( credentials . is <identifiersep> password <identifiersep> persistent ( ) ) { jabber <identifiersep> activator . get <identifiersep> protocol <identifiersep> provider <identifiersep> factory ( ) <ect>
desc . get <identifiersep> port ( ) , transport . udp ) ; <comment> <LOG> { continue ; } stun <identifiersep> candidate <identifiersep> harvester harvester ; if ( desc . is <identifiersep> turn <identifiersep> supported ( ) ) { <comment> <ect>
stream , port <identifiersep> tracker . get <identifiersep> min <identifiersep> port ( ) , port <identifiersep> tracker . get <identifiersep> max <identifiersep> port ( ) ) ; if ( max <identifiersep> allocated <identifiersep> port > 0 ) { int next <identifiersep> port = 1 + max <identifiersep> allocated <identifiersep> port ; <LOG> port <identifiersep> tracker . set <identifiersep> next <identifiersep> port ( next <identifiersep> port ) ; } } catch ( throwable t ) { <comment> <ect>
<comment> boolean ice <identifiersep> agent <identifiersep> state <identifiersep> is <identifiersep> running <LOG> = ice <identifiersep> processing <identifiersep> state . running . equals ( ice <identifiersep> agent . get <identifiersep> state ( ) ) ; int generation = ice <identifiersep> agent . get <identifiersep> generation ( ) ; boolean start <identifiersep> connectivity <identifiersep> establishment = false ; for ( map . entry < string , ice <identifiersep> udp <identifiersep> transport <identifiersep> packet <identifiersep> extension > e : remote . entry <identifiersep> set ( ) ) { <ect>
{ object new <identifiersep> value = evt . get <identifiersep> new <identifiersep> value ( ) ; if ( ice <identifiersep> processing <identifiersep> state . completed . equals ( new <identifiersep> value ) || ice <identifiersep> processing <identifiersep> state . failed . equals ( new <identifiersep> value ) || ice <identifiersep> processing <identifiersep> state . terminated . equals ( new <identifiersep> value ) ) <LOG> { agent ice <identifiersep> agent = ( agent ) evt . get <identifiersep> source ( ) ; ice <identifiersep> agent . remove <identifiersep> state <identifiersep> change <identifiersep> listener ( this ) ; if ( ice <identifiersep> agent == ice <identifiersep> udp <identifiersep> transport <identifiersep> manager . this . ice <identifiersep> agent ) { synchronized ( ice <identifiersep> processing <identifiersep> state <identifiersep> sync <identifiersep> root ) <ect>
{ muc = new multi <identifiersep> user <identifiersep> chat ( get <identifiersep> xmpp <identifiersep> connection ( ) , get <identifiersep> canonical <identifiersep> room <identifiersep> name ( room <identifiersep> name ) ) ; muc . create ( jabber <identifiersep> activator . get <identifiersep> global <identifiersep> display <identifiersep> details <identifiersep> service ( ) . get <identifiersep> display <identifiersep> name ( jabber <identifiersep> provider ) ) ; } catch ( xmpp <identifiersep> exception ex ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , ex . get <identifiersep> xmpp <identifiersep> error ( ) . get <identifiersep> code ( ) , ex . get <identifiersep> cause ( ) ) ; } boolean is <identifiersep> private = false ; if ( room <identifiersep> properties != null ) <ect>
fire <identifiersep> invitation <identifiersep> event ( chat <identifiersep> room , inviter , reason , password . get <identifiersep> bytes ( ) ) ; else fire <identifiersep> invitation <identifiersep> event ( chat <identifiersep> room , inviter , reason , null ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { } catch ( operation <identifiersep> not <identifiersep> supported <identifiersep> exception e ) { logger . error ( <string_literal> + room , e ) ; } } } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { if ( evt . get <identifiersep> new <identifiersep> state ( ) == registration <identifiersep> state . registered ) <LOG> { multi <identifiersep> user <identifiersep> chat . add <identifiersep> invitation <identifiersep> listener ( jabber <identifiersep> provider . get <identifiersep> connection ( ) , new smack <identifiersep> invitation <identifiersep> listener ( ) ) ; } else if ( evt . get <identifiersep> new <identifiersep> state ( ) == registration <identifiersep> state . unregistered || evt . get <identifiersep> new <identifiersep> state ( ) == registration <identifiersep> state . connection <identifiersep> failed ) <ect>
server <identifiersep> stored <identifiersep> group <identifiersep> event evt = new server <identifiersep> stored <identifiersep> group <identifiersep> event ( group , event <identifiersep> id , parent <identifiersep> operation <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , jabber <identifiersep> provider <LOG> , parent <identifiersep> operation <identifiersep> set ) ; iterable < server <identifiersep> stored <identifiersep> group <identifiersep> listener > listeners ; synchronized ( server <identifiersep> stored <identifiersep> group <identifiersep> listeners ) { listeners = new array <identifiersep> list < server <identifiersep> stored <identifiersep> group <identifiersep> listener > ( <ect>
{ <comment> <LOG> return ; } + <string_literal> + parent <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) ) ; <comment> <ect>
<comment> public void add <identifiersep> contact ( contact <identifiersep> group parent , string id ) throws operation <identifiersep> failed <identifiersep> exception <LOG> { final string complete <identifiersep> id = parse <identifiersep> address <identifiersep> string ( id ) ; <comment> <ect>
{ logger . trace ( <string_literal> + group <identifiersep> name ) ; contact <identifiersep> group <identifiersep> jabber <identifiersep> impl existing <identifiersep> group = find <identifiersep> contact <identifiersep> group ( group <identifiersep> name ) ; if ( existing <identifiersep> group != null && existing <identifiersep> group . is <identifiersep> persistent ( ) ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + group <identifiersep> name + <string_literal> , operation <identifiersep> failed <identifiersep> exception . contact <identifiersep> group <identifiersep> already <identifiersep> exists ) ; } roster <identifiersep> group new <identifiersep> roster <identifiersep> group = roster . create <identifiersep> group ( group <identifiersep> name ) ; contact <identifiersep> group <identifiersep> jabber <identifiersep> impl new <identifiersep> group = <ect>
while ( iter . has <identifiersep> next ( ) ) { contact <identifiersep> jabber <identifiersep> impl item = ( contact <identifiersep> jabber <identifiersep> impl ) iter . next ( ) ; if ( item . is <identifiersep> persistent ( ) ) roster . remove <identifiersep> entry ( item . get <identifiersep> source <identifiersep> entry ( ) ) ; } } catch ( xmpp <identifiersep> exception ex ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( ex . get <identifiersep> message ( ) , operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error , ex ) ; } } <comment> <ect>
roster . create <identifiersep> entry ( contact . get <identifiersep> source <identifiersep> entry ( ) . get <identifiersep> user ( ) , contact . get <identifiersep> display <identifiersep> name ( ) , new string [ ] { new <identifiersep> parent . get <identifiersep> group <identifiersep> name ( ) } ) ; smack <identifiersep> configuration . set <identifiersep> packet <identifiersep> reply <identifiersep> timeout ( <number_literal> ) ; new <identifiersep> parent . add <identifiersep> contact ( contact ) ; } catch ( xmpp <identifiersep> exception ex ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( ex . get <identifiersep> message ( ) , operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error , ex ) ; } } <comment> <ect>
public void entries <identifiersep> deleted ( collection < string > addresses ) { iterator < string > iter = addresses . iterator ( ) ; while ( iter . has <identifiersep> next ( ) ) { <LOG> string address = iter . next ( ) ; contact <identifiersep> jabber <identifiersep> impl contact = find <identifiersep> contact <identifiersep> by <identifiersep> id ( address ) ; if ( contact == null ) { logger . trace ( <string_literal> <ect>
final call <identifiersep> peer <identifiersep> jabber <identifiersep> impl call <identifiersep> peer <identifiersep> jabber = ( call <identifiersep> peer <identifiersep> jabber <identifiersep> impl ) call <identifiersep> peer ; final long time <identifiersep> since <identifiersep> last <identifiersep> coin = system . current <identifiersep> time <identifiersep> millis ( ) - call <identifiersep> peer <identifiersep> jabber . get <identifiersep> last <identifiersep> conference <identifiersep> info <identifiersep> sent <identifiersep> timestamp ( ) ; if ( time <identifiersep> since <identifiersep> last <identifiersep> coin < coin <identifiersep> min <identifiersep> interval ) { if ( call <identifiersep> peer <identifiersep> jabber . is <identifiersep> conf <identifiersep> info <identifiersep> scheduled ( ) ) <LOG> return ; call <identifiersep> peer <identifiersep> jabber . set <identifiersep> conf <identifiersep> info <identifiersep> scheduled ( true ) ; new thread ( new runnable ( ) { @ override public void run ( ) { <ect>
protocol <identifiersep> provider <identifiersep> service <identifiersep> jabber <identifiersep> impl . urn <identifiersep> xmpp <identifiersep> jingle <identifiersep> coin ) ) { logger . info ( call <identifiersep> peer . get <identifiersep> address ( ) + <string_literal> ) ; call <identifiersep> peer <identifiersep> jabber . set <identifiersep> conf <identifiersep> info <identifiersep> scheduled ( false ) ; return ; } } catch ( xmpp <identifiersep> exception xmppe ) <LOG> { } conference <identifiersep> info <identifiersep> document current <identifiersep> conf <identifiersep> info = get <identifiersep> current <identifiersep> conference <identifiersep> info ( call <identifiersep> peer <identifiersep> jabber ) ; conference <identifiersep> info <identifiersep> document last <identifiersep> sent <identifiersep> conf <identifiersep> info = call <identifiersep> peer <identifiersep> jabber . get <identifiersep> last <identifiersep> conference <identifiersep> info <identifiersep> sent ( ) ; conference <identifiersep> info <identifiersep> document diff ; <ect>
{ logger . debug ( <string_literal> ) ; subscribe <identifiersep> for <identifiersep> coin <identifiersep> packets ( ) ; } else if ( registration <identifiersep> state . unregistered . equals ( registration <identifiersep> state ) ) <LOG> { unsubscribe <identifiersep> for <identifiersep> coin <identifiersep> packets ( ) ; } } <comment> <ect>
if ( call <identifiersep> peer != null ) { if ( type == iq . type . error ) { call <identifiersep> peer . fire <identifiersep> conference <identifiersep> member <identifiersep> error <identifiersep> event ( error <identifiersep> message ) ; <LOG> return ; } + <string_literal> + coin <identifiersep> iq . get <identifiersep> version ( ) + <string_literal> ) ; handle <identifiersep> coin ( call <identifiersep> peer , coin <identifiersep> iq ) ; } } } <comment> <ect>
<comment> public void submit ( ) throws operation <identifiersep> failed <identifiersep> exception <LOG> { try { smack <identifiersep> multi <identifiersep> user <identifiersep> chat . send <identifiersep> configuration <identifiersep> form ( smack <identifiersep> submit <identifiersep> form ) ; } catch ( xmpp <identifiersep> exception e ) { <ect>
<comment> <LOG> { } <comment> <ect>
{ logger . error ( <string_literal> ) ; return null ; } iterator < column > columns = data . get <identifiersep> columns ( ) ; iterator < row > rows = data . get <identifiersep> rows ( ) ; if ( columns == null || rows == null ) <LOG> { return null ; } column jid <identifiersep> column = null ; while ( columns . has <identifiersep> next ( ) ) { column tmp <identifiersep> collumn = columns . next ( ) ; <ect>
{ done = true ; } } if ( event <identifiersep> type == xml <identifiersep> pull <identifiersep> parser . text ) { string text = parser . get <identifiersep> text ( ) ; packet <identifiersep> extension . set <identifiersep> text ( text ) ; } <LOG> if ( logger . is <identifiersep> loggable ( level . finest ) ) } return packet <identifiersep> extension ; } } <ect>
if ( ppe instanceof abstract <identifiersep> packet <identifiersep> extension ) { copy . add <identifiersep> child <identifiersep> extension ( abstract <identifiersep> packet <identifiersep> extension . clone ( ( abstract <identifiersep> packet <identifiersep> extension ) ppe ) ) ; } else <LOG> { } } return copy ; } public string to <identifiersep> string ( ) { if ( has <identifiersep> rid ( ) ) { <ect>
<comment> long sleep <identifiersep> duration = ( system . current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> wake <identifiersep> up ) ; last <identifiersep> wake <identifiersep> up = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( sleep <identifiersep> duration < min <identifiersep> wake <identifiersep> up <identifiersep> interval ) <LOG> { return ; } <comment> <ect>
try { return <string_literal> + sha1crypto . encode ( thumbnail <identifiersep> data ) + <string_literal> + server <identifiersep> address ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) <LOG> { } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { logger . debug ( <string_literal> , e ) ; } return null ; <ect>
<comment> <LOG> { logger . trace ( <string_literal> + parser . get <identifiersep> text ( ) ) ; } } event <identifiersep> type = parser . next ( ) ; } return mailbox <identifiersep> iq ; } } <ect>
<comment> @ override public string get <identifiersep> child <identifiersep> element <identifiersep> xml ( ) <LOG> { return <string_literal> + <string_literal> + <string_literal> + <string_literal> + get <identifiersep> from ( ) + <string_literal> + <string_literal> + get <identifiersep> to ( ) + <string_literal> + <string_literal> + get <identifiersep> packet <identifiersep> id ( ) + <string_literal> ; } } <ect>
<comment> @ override public string get <identifiersep> child <identifiersep> element <identifiersep> xml ( ) <LOG> { string <identifiersep> buffer xml = new string <identifiersep> buffer ( <string_literal> ) ; if ( get <identifiersep> newer <identifiersep> than <identifiersep> time ( ) != - 1 ) xml . append ( <string_literal> ) . append ( get <identifiersep> newer <identifiersep> than <identifiersep> time ( ) ) . append ( <string_literal> ) ; <ect>
<comment> public packet <identifiersep> extension parse <identifiersep> extension ( xml <identifiersep> pull <identifiersep> parser parser ) throws exception { <LOG> geolocation <identifiersep> packet <identifiersep> extension result = new geolocation <identifiersep> packet <identifiersep> extension ( ) ; boolean done = false ; while ( ! done ) { try { <ect>
<comment> stop ( <string_literal> ) , <comment> <LOG> <comment> <comment> undefined ( <string_literal> ) ; private string name ; <ect>
try { return jabber <identifiersep> provider . get <identifiersep> discovery <identifiersep> manager ( ) . discover <identifiersep> info ( jabber <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> service ( ) ) . contains <identifiersep> feature ( carbon <identifiersep> packet <identifiersep> extension . namespace ) ; } catch ( xmpp <identifiersep> exception e ) <LOG> { } return false ; } <comment> @ suppress <identifiersep> warnings ( <string_literal> ) <ect>
error <identifiersep> reason , new date ( ) , new <identifiersep> message ) ; ( ( chat <identifiersep> room <identifiersep> jabber <identifiersep> impl ) private <identifiersep> contact <identifiersep> room ) . fire <identifiersep> message <identifiersep> event ( evt ) ; } <LOG> return ; } int error <identifiersep> result <identifiersep> code = message <identifiersep> delivery <identifiersep> failed <identifiersep> event . unknown <identifiersep> error ; if ( packet . get <identifiersep> error ( ) != null ) { int error <identifiersep> code = packet . get <identifiersep> error ( ) . get <identifiersep> code ( ) ; if ( error <identifiersep> code == <number_literal> ) <ect>
message <identifiersep> event <identifiersep> manager . add <identifiersep> notifications <identifiersep> requests ( msg , true , false , false , true ) ; <comment> <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + message , operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error , ex ) ; } } <comment> <ect>
try { multi <identifiersep> user <identifiersep> chat . ban <identifiersep> user ( ( ( chat <identifiersep> room <identifiersep> member <identifiersep> jabber <identifiersep> impl ) chat <identifiersep> room <identifiersep> member ) . get <identifiersep> jabber <identifiersep> id ( ) , reason ) ; } catch ( xmpp <identifiersep> exception e ) <LOG> { <comment> <ect>
private void fire <identifiersep> member <identifiersep> presence <identifiersep> event ( chat <identifiersep> room <identifiersep> member member , string event <identifiersep> id , string event <identifiersep> reason ) { chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> change <identifiersep> event evt = new chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> change <identifiersep> event ( <LOG> this , member , event <identifiersep> id , event <identifiersep> reason ) ; iterator < chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> listener > listeners = null ; synchronized ( member <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> listener > ( member <identifiersep> listeners ) . iterator ( ) ; <ect>
chat <identifiersep> room <identifiersep> member <identifiersep> role previous <identifiersep> role , chat <identifiersep> room <identifiersep> member <identifiersep> role new <identifiersep> role ) { member . set <identifiersep> role ( new <identifiersep> role ) ; chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> change <identifiersep> event evt = new chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> change <identifiersep> event ( <LOG> this , member , previous <identifiersep> role , new <identifiersep> role ) ; iterable < chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> listener > listeners ; synchronized ( member <identifiersep> role <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> listener > ( <ect>
members <identifiersep> to <identifiersep> remove . remove <identifiersep> all ( members ) ; if ( members <identifiersep> to <identifiersep> remove . size ( ) > 0 ) multi <identifiersep> user <identifiersep> chat . revoke <identifiersep> membership ( members <identifiersep> to <identifiersep> remove ) ; if ( members . size ( ) > 0 ) multi <identifiersep> user <identifiersep> chat . grant <identifiersep> membership ( members ) ; } catch ( xmpp <identifiersep> exception e ) <LOG> { } } <comment> private class smack <identifiersep> message <identifiersep> listener <ect>
<comment> public void subject <identifiersep> updated ( string subject , string from ) <LOG> { <comment> <ect>
public void grant <identifiersep> membership ( string jid ) { try { multi <identifiersep> user <identifiersep> chat . grant <identifiersep> membership ( jid ) ; } catch ( xmpp <identifiersep> exception ex ) <LOG> { } } <comment> <ect>
public void revoke <identifiersep> membership ( string jid ) { try { multi <identifiersep> user <identifiersep> chat . revoke <identifiersep> membership ( jid ) ; } catch ( xmpp <identifiersep> exception ex ) <LOG> { } } <comment> <ect>
@ override public void process <identifiersep> packet ( packet packet ) { if ( packet == null || ! ( packet instanceof presence ) || packet . get <identifiersep> error ( ) != null ) <LOG> { return ; } presence presence = ( presence ) packet ; string our <identifiersep> occupant <identifiersep> jid = multi <identifiersep> user <identifiersep> chat . get <identifiersep> room ( ) + <string_literal> + multi <identifiersep> user <identifiersep> chat . get <identifiersep> nickname ( ) ; if ( our <identifiersep> occupant <identifiersep> jid . equals ( presence . get <identifiersep> from ( ) ) ) <ect>
for ( payload <identifiersep> type <identifiersep> packet <identifiersep> extension pt <identifiersep> ext : payload <identifiersep> types ) { media <identifiersep> format format = payload <identifiersep> type <identifiersep> to <identifiersep> media <identifiersep> format ( pt <identifiersep> ext , pt <identifiersep> registry ) ; <comment> <LOG> { } else media <identifiersep> fmts . add ( format ) ; } return media <identifiersep> fmts ; } <comment> <ect>
<comment> public void process <identifiersep> packet ( packet packet ) { if ( ! ( packet instanceof stream <identifiersep> initiation ) ) <LOG> return ; stream <identifiersep> initiation stream <identifiersep> initiation = ( stream <identifiersep> initiation ) packet ; file <identifiersep> transfer <identifiersep> request jabber <identifiersep> request = new file <identifiersep> transfer <identifiersep> request ( manager , stream <identifiersep> initiation ) ; <comment> <ect>
{ provider <identifiersep> manager . get <identifiersep> instance ( ) . add <identifiersep> iq <identifiersep> provider ( jingle <identifiersep> iq . element <identifiersep> name , jingle <identifiersep> iq . namespace , new jingle <identifiersep> iq <identifiersep> provider ( ) ) ; <LOG> subscribe <identifiersep> for <identifiersep> jingle <identifiersep> packets ( ) ; } else if ( registration <identifiersep> state == registration <identifiersep> state . unregistered ) { unsubscribe <identifiersep> for <identifiersep> jingle <identifiersep> packets ( ) ; logger . info ( <string_literal> ) ; <ect>
call <identifiersep> jabber <identifiersep> impl call , string callee <identifiersep> address , string full <identifiersep> callee <identifiersep> uri , iterable < packet <identifiersep> extension > session <identifiersep> initiate <identifiersep> extensions ) throws operation <identifiersep> failed <identifiersep> exception <LOG> { if ( protocol <identifiersep> provider . get <identifiersep> connection ( ) == null || call == null ) { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + <string_literal> , <ect>
full <identifiersep> callee <identifiersep> uri ) ; } catch ( xmpp <identifiersep> exception ex ) { logger . warn ( <string_literal> + full <identifiersep> callee <identifiersep> uri , ex ) ; } if ( di != null ) <LOG> { } else { logger . info ( full <identifiersep> callee <identifiersep> uri + <string_literal> ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <ect>
{ <comment> <LOG> { } if ( discover <identifiersep> info != null && discover <identifiersep> info . contains <identifiersep> feature ( protocol <identifiersep> provider <identifiersep> service <identifiersep> jabber <identifiersep> impl . urn <identifiersep> xmpp <identifiersep> jingle ) ) { if ( priority > best <identifiersep> priority ) { <ect>
. get <identifiersep> transport <identifiersep> manager ( ) . wrapup <identifiersep> connectivity <identifiersep> establishment ( ) ; answer = media <identifiersep> handler . generate <identifiersep> session <identifiersep> accept ( ) ; for ( content <identifiersep> packet <identifiersep> extension c : answer ) set <identifiersep> senders ( get <identifiersep> media <identifiersep> type ( c ) , c . get <identifiersep> senders ( ) ) ; } catch ( exception exc ) <LOG> { <comment> <ect>
else if ( prev <identifiersep> peer <identifiersep> state . equals ( call <identifiersep> peer <identifiersep> state . busy ) || prev <identifiersep> peer <identifiersep> state . equals ( call <identifiersep> peer <identifiersep> state . failed ) ) { <comment> <LOG> { } if ( response <identifiersep> iq != null ) { if ( reason <identifiersep> other <identifiersep> extension != null ) { reason <identifiersep> packet <identifiersep> extension reason <ect>
call <identifiersep> peer <identifiersep> media <identifiersep> handler <identifiersep> jabber <identifiersep> impl media <identifiersep> handler = get <identifiersep> media <identifiersep> handler ( ) ; list < content <identifiersep> packet <identifiersep> extension > contents = content . get <identifiersep> content <identifiersep> list ( ) ; iterable < content <identifiersep> packet <identifiersep> extension > answer <identifiersep> contents ; jingle <identifiersep> iq content <identifiersep> iq ; boolean no <identifiersep> cands = false ; <LOG> media <identifiersep> stream old <identifiersep> video <identifiersep> stream = media <identifiersep> handler . get <identifiersep> stream ( media <identifiersep> type . video ) ; try { if ( ! content <identifiersep> add <identifiersep> with <identifiersep> no <identifiersep> cands ) { media <identifiersep> handler . process <identifiersep> offer ( contents ) ; <ect>
. wrapup <identifiersep> connectivity <identifiersep> establishment ( ) ; logger . info ( <string_literal> ) ; answer <identifiersep> contents = media <identifiersep> handler . generate <identifiersep> session <identifiersep> accept ( ) ; content <identifiersep> iq = null ; } catch ( exception e ) <LOG> { answer <identifiersep> contents = null ; content <identifiersep> iq = jingle <identifiersep> packet <identifiersep> factory . create <identifiersep> content <identifiersep> reject ( get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> our <identifiersep> jid ( ) , this . peer <identifiersep> jid , <ect>
!= null ) ; get <identifiersep> media <identifiersep> handler ( ) . reinit <identifiersep> content ( ext . get <identifiersep> name ( ) , ext , modify ) ; set <identifiersep> senders ( media <identifiersep> type , ext . get <identifiersep> senders ( ) ) ; if ( media <identifiersep> type . video . equals ( media <identifiersep> type ) ) get <identifiersep> call ( ) . modify <identifiersep> video <identifiersep> content ( ) ; } catch ( exception e ) <LOG> { <comment> <ect>
. wrapup <identifiersep> connectivity <identifiersep> establishment ( ) ; media <identifiersep> handler . process <identifiersep> answer ( answer ) ; for ( content <identifiersep> packet <identifiersep> extension c : answer ) set <identifiersep> senders ( get <identifiersep> media <identifiersep> type ( c ) , c . get <identifiersep> senders ( ) ) ; } catch ( exception exc ) <LOG> { <comment> <ect>
<comment> if ( coin != null ) { set <identifiersep> conference <identifiersep> focus ( boolean . parse <identifiersep> boolean ( ( string ) coin . get <identifiersep> attribute ( <string_literal> ) ) ) ; } } catch ( exception ex ) <LOG> { <comment> <ect>
session <identifiersep> initiate <identifiersep> sync <identifiersep> root . wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { } } } } get <identifiersep> media <identifiersep> handler ( ) . process <identifiersep> transport <identifiersep> info ( jingle <identifiersep> iq . get <identifiersep> content <identifiersep> list ( ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ofe ) <LOG> { <comment> <ect>
<comment> <LOG> { send <identifiersep> add <identifiersep> video <identifiersep> content ( ) ; return true ; } return false ; } } else { <ect>
<comment> public void send <identifiersep> modify <identifiersep> video <identifiersep> resolution <identifiersep> content ( ) { call <identifiersep> peer <identifiersep> media <identifiersep> handler <identifiersep> jabber <identifiersep> impl media <identifiersep> handler = get <identifiersep> media <identifiersep> handler ( ) ; content <identifiersep> packet <identifiersep> extension remote <identifiersep> content = media <identifiersep> handler . get <identifiersep> remote <identifiersep> content ( media <identifiersep> type . video . to <identifiersep> string ( ) ) ; <LOG> content <identifiersep> packet <identifiersep> extension content ; <comment> <ect>
protocol <identifiersep> provider . get <identifiersep> connection ( ) . send <identifiersep> packet ( content <identifiersep> iq ) ; try { media <identifiersep> handler . reinit <identifiersep> content ( remote <identifiersep> content . get <identifiersep> name ( ) , content , false ) ; media <identifiersep> handler . start ( ) ; } catch ( exception e ) <LOG> { } } <comment> private void send <identifiersep> remove <identifiersep> video <identifiersep> content ( ) { <ect>
{ public void process <identifiersep> packet ( packet packet ) { <comment> <LOG> return ; thumbnail <identifiersep> iq thumbnail <identifiersep> response = ( thumbnail <identifiersep> iq ) packet ; if ( thumbnail <identifiersep> response . get <identifiersep> cid ( ) != null && thumbnail <identifiersep> response . get <identifiersep> cid ( ) . equals ( thumbnail <identifiersep> cid ) ) { thumbnail = thumbnail <identifiersep> response . get <identifiersep> data ( ) ; <ect>
try { provider = select <identifiersep> handling <identifiersep> provider ( uri ) ; } catch ( operation <identifiersep> failed <identifiersep> exception exc ) { <LOG> <comment> <ect>
<comment> <LOG> { return current <identifiersep> time ; } } return last <identifiersep> log <identifiersep> time ; } <comment> <ect>
{ full <identifiersep> callee <identifiersep> uri = callee <identifiersep> address ; } else { full <identifiersep> callee <identifiersep> uri = parent <identifiersep> provider . get <identifiersep> connection ( ) <LOG> . get <identifiersep> roster ( ) . get <identifiersep> presence ( callee <identifiersep> address ) . get <identifiersep> from ( ) ; } discover <identifiersep> info di = null ; try { <comment> <ect>
<comment> } } catch ( xmpp <identifiersep> exception ex ) <LOG> { } if ( parent <identifiersep> provider . get <identifiersep> connection ( ) == null ) { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + <string_literal> <ect>
. remove ( detail <identifiersep> it . next ( ) ) ; } info <identifiersep> retreiver . get <identifiersep> cached <identifiersep> contact <identifiersep> details ( uin ) . add ( display <identifiersep> name <identifiersep> detail ) ; } try { v <identifiersep> card . save ( jabber <identifiersep> provider . get <identifiersep> connection ( ) ) ; } catch ( xmpp <identifiersep> exception xmppe ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , 1 , xmppe ) ; } } <comment> <ect>
early <identifiersep> subscriptions . put ( from <identifiersep> id , display <identifiersep> name ) ; <comment> <LOG> { if ( handler == null ) { logger . warn ( <string_literal> + from <identifiersep> id ) ; <ect>
source <identifiersep> contact , current <identifiersep> avatar , new <identifiersep> avatar ) ; } } catch ( xmpp <identifiersep> exception ex ) { <LOG> logger . info ( <string_literal> + packet . get <identifiersep> from ( ) ) ; } } } <comment> private void initialize <identifiersep> priorities ( ) <ect>
public void run ( ) { synchronized ( jingle <identifiersep> nodes <identifiersep> sync <identifiersep> root ) { long start = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> { } smack <identifiersep> service <identifiersep> node . mapped <identifiersep> nodes nodes ; string search <identifiersep> nodes <identifiersep> with <identifiersep> prefix = jabber <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> settings <identifiersep> string ( jingle <identifiersep> nodes <identifiersep> search <identifiersep> prefix <identifiersep> prop ) ; if ( search <identifiersep> nodes <identifiersep> with <identifiersep> prefix == null <ect>
{ add <identifiersep> iq <identifiersep> provider ( element <identifiersep> name , namespace , provider . new <identifiersep> instance ( ) ) ; } else if ( iq . class . is <identifiersep> assignable <identifiersep> from ( provider ) ) { add <identifiersep> iq <identifiersep> provider ( element <identifiersep> name , namespace , provider ) ; } } catch ( throwable t ) <LOG> { } } <comment> <ect>
throw new xmpp <identifiersep> exception ( error <identifiersep> message , new xmpp <identifiersep> error ( xmpp <identifiersep> error . condition . request <identifiersep> timeout , error <identifiersep> message ) ) ; } if ( result . get <identifiersep> error ( ) != null ) { throw new xmpp <identifiersep> exception ( result . get <identifiersep> error ( ) ) ; } } catch ( class <identifiersep> cast <identifiersep> exception e ) <LOG> { } if ( result == null ) result = new v <identifiersep> card ( ) ; <comment> <ect>
<comment> @ override public void modify <identifiersep> video <identifiersep> content ( ) throws operation <identifiersep> failed <identifiersep> exception <LOG> { boolean change = false ; for ( call <identifiersep> peer <identifiersep> jabber <identifiersep> impl peer : get <identifiersep> call <identifiersep> peer <identifiersep> list ( ) ) change | = peer . send <identifiersep> modify <identifiersep> video <identifiersep> content ( ) ; if ( change ) fire <identifiersep> call <identifiersep> change <identifiersep> event ( <ect>
<comment> @ override public synchronized collection < local <identifiersep> candidate > harvest ( component component ) <LOG> { collection < local <identifiersep> candidate > candidates = new hash <identifiersep> set < local <identifiersep> candidate > ( ) ; string ip = null ; int port = - 1 ; <comment> if ( local <identifiersep> address <identifiersep> second != null && relayed <identifiersep> address <identifiersep> second != null ) <ect>
return candidates ; } <comment> <LOG> { ip = ip . substring ( 0 , scope <identifiersep> index ) ; } <comment> transport <identifiersep> address relayed <identifiersep> address = new transport <identifiersep> address ( ip , port , transport . udp ) ; transport <identifiersep> address local <identifiersep> address = new transport <identifiersep> address ( ip , <ect>
i <identifiersep> support . parse <identifiersep> chan <identifiersep> limit ( destination , raw <identifiersep> chan <identifiersep> limit <identifiersep> value ) ; { logger . debug ( <string_literal> + raw <identifiersep> chan <identifiersep> limit <identifiersep> value ) ; for ( entry < character , integer > e : destination . entry <identifiersep> set ( ) ) <LOG> { } } } <comment> <ect>
join <identifiersep> signal . set <identifiersep> done ( e ) ; join <identifiersep> signal . notify <identifiersep> all ( ) ; } } } } ) ; try { while ( ! join <identifiersep> signal . is <identifiersep> done ( ) ) <LOG> { <comment> <ect>
chat <identifiersep> room <identifiersep> member <identifiersep> role role ; for ( final irc <identifiersep> user <identifiersep> status status : channel . get <identifiersep> statuses <identifiersep> for <identifiersep> user ( user ) ) { try { <LOG> { + <string_literal> + user . get <identifiersep> nick ( ) + <string_literal> + channel . get <identifiersep> name ( ) ) ; } role = convert <identifiersep> member <identifiersep> mode ( status . get <identifiersep> chan <identifiersep> mode <identifiersep> type ( ) ) ; member . add <identifiersep> role ( role ) ; } catch ( unknown <identifiersep> mode <identifiersep> exception e ) <ect>
<comment> public void leave ( final chat <identifiersep> room <identifiersep> irc <identifiersep> impl chatroom ) <LOG> { leave ( chatroom . get <identifiersep> identifier ( ) ) ; } <comment> <ect>
channel <identifiersep> manager . this . away <identifiersep> notify ) ) ; try { channel <identifiersep> manager . this . provider . get <identifiersep> muc ( ) . open <identifiersep> chat <identifiersep> room <identifiersep> window ( chat <identifiersep> room ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) <LOG> { } channel <identifiersep> manager . this . prepare <identifiersep> chat <identifiersep> room ( chat <identifiersep> room , channel ) ; channel <identifiersep> manager . this . provider . get <identifiersep> muc ( ) . fire <identifiersep> local <identifiersep> user <identifiersep> presence <identifiersep> event ( chat <identifiersep> room , local <identifiersep> user <identifiersep> chat <identifiersep> room <identifiersep> presence <identifiersep> change <identifiersep> event . local <identifiersep> user <identifiersep> joined , null ) ; <ect>
this . connection <identifiersep> state = connection <identifiersep> state ; if ( nick <identifiersep> watch <identifiersep> list == null ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } this . nick <identifiersep> watch <identifiersep> list = nick <identifiersep> watch <identifiersep> list ; this . irc . add <identifiersep> listener ( new watch <identifiersep> reply <identifiersep> listener ( monitored , operation <identifiersep> set ) ) ; <LOG> set <identifiersep> up <identifiersep> watch ( this . irc , this . nick <identifiersep> watch <identifiersep> list , max <identifiersep> list <identifiersep> size ) ; } <comment> <ect>
{ logger . trace ( <string_literal> + nick + <string_literal> ) ; this . nick <identifiersep> watch <identifiersep> list . add ( nick ) ; this . irc . raw <identifiersep> message ( <string_literal> + nick ) ; } @ override public void remove ( final string nick ) <LOG> { this . nick <identifiersep> watch <identifiersep> list . remove ( nick ) ; this . irc . raw <identifiersep> message ( <string_literal> + nick ) ; } <comment> <ect>
public void shutdown ( ) { if ( ! is <identifiersep> initialized ) { return ; } <LOG> { } try { synchronized ( this . initialization <identifiersep> lock ) { unregister ( ) ; <ect>
operation <identifiersep> failed <identifiersep> exception . illegal <identifiersep> argument ) ; } try { this . irc . message ( target , message ) ; logger . trace ( <string_literal> ) ; } catch ( runtime <identifiersep> exception e ) <LOG> { throw e ; } } <comment> <ect>
<comment> @ override public void remove <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( final contact <identifiersep> group group ) throws operation <identifiersep> failed <identifiersep> exception <LOG> { if ( ! ( group instanceof contact <identifiersep> group <identifiersep> irc <identifiersep> impl ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } final contact <identifiersep> group <identifiersep> irc <identifiersep> impl irc <identifiersep> group = ( contact <identifiersep> group <identifiersep> irc <identifiersep> impl ) group ; <ect>
<comment> @ override public void move <identifiersep> contact <identifiersep> to <identifiersep> group ( final contact contact <identifiersep> to <identifiersep> move , final contact <identifiersep> group new <identifiersep> parent ) throws operation <identifiersep> failed <identifiersep> exception <LOG> { if ( ! ( contact <identifiersep> to <identifiersep> move instanceof contact <identifiersep> irc <identifiersep> impl ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } final contact <identifiersep> irc <identifiersep> impl contact = ( contact <identifiersep> irc <identifiersep> impl ) contact <identifiersep> to <identifiersep> move ; <ect>
logger . debug ( <string_literal> + i <identifiersep> support . awaylen . name ( ) + <string_literal> + value ) ; } try { return new integer ( value ) ; } catch ( runtime <identifiersep> exception e ) <LOG> { return null ; } } <comment> <ect>
logger . debug ( <string_literal> + i <identifiersep> support . monitor . name ( ) + <string_literal> + value ) ; } try { return new integer ( value ) ; } catch ( runtime <identifiersep> exception e ) <LOG> { return null ; } } <comment> <ect>
if ( value == null ) { logger . trace ( <string_literal> + i <identifiersep> support . watch . name ( ) + <string_literal> ) ; return null ; } <LOG> { + <string_literal> + value ) ; } try { return new integer ( value ) ; } catch ( runtime <identifiersep> exception e ) <ect>
switch ( code ) { case irc <identifiersep> rpl <identifiersep> unaway : presence <identifiersep> manager . this . current <identifiersep> message = <string_literal> ; presence <identifiersep> manager . this . away = false ; operation <identifiersep> set . update <identifiersep> presence <identifiersep> status ( irc <identifiersep> status <identifiersep> enum . away , <LOG> irc <identifiersep> status <identifiersep> enum . online ) ; break ; case irc <identifiersep> rpl <identifiersep> nowaway : presence <identifiersep> manager . this . current <identifiersep> message = presence <identifiersep> manager . this . submitted <identifiersep> message ; presence <identifiersep> manager . this . away = true ; <ect>
final timer presence <identifiersep> watcher = new timer ( ) ; irc . add <identifiersep> listener ( new presence <identifiersep> reply <identifiersep> listener ( presence <identifiersep> watcher , query <identifiersep> list ) ) ; final presence <identifiersep> watcher <identifiersep> task task = new presence <identifiersep> watcher <identifiersep> task ( this . nick <identifiersep> watch <identifiersep> list , query <identifiersep> list , server <identifiersep> identity ) ; presence <identifiersep> watcher . schedule ( task , initial <identifiersep> presence <identifiersep> watcher <identifiersep> delay , <LOG> presence <identifiersep> watcher <identifiersep> period ) ; } @ override public void add ( string nick ) { this . nick <identifiersep> watch <identifiersep> list . add ( nick ) ; } @ override <ect>
<comment> @ override public void stop ( final bundle <identifiersep> context context ) throws exception { <LOG> { } } <comment> <ect>
result . set <identifiersep> done ( state ) ; result . notify <identifiersep> all ( ) ; } } @ override public void on <identifiersep> failure ( final exception e ) { synchronized ( result ) <LOG> { result . set <identifiersep> done ( e ) ; result . notify <identifiersep> all ( ) ; } } } , negotiator ) ; provider . set <identifiersep> current <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . registering , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> user <identifiersep> request ) ; <ect>
<comment> @ override public void on <identifiersep> server <identifiersep> notice ( final server <identifiersep> notice msg ) <LOG> { } <comment> <ect>
logger . info ( <string_literal> + cap . get <identifiersep> id ( ) + <string_literal> ) ; if ( away <identifiersep> notify . equals ( cap . get <identifiersep> id ( ) ) ) { this . away <identifiersep> notify = true ; } } @ override public void reject ( capability cap ) <LOG> { if ( away <identifiersep> notify . equals ( cap . get <identifiersep> id ( ) ) ) { this . away <identifiersep> notify = false ; } } } } <ect>
if ( monitored == null ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } this . monitored <identifiersep> list = monitored ; this . irc . add <identifiersep> listener ( new monitor <identifiersep> reply <identifiersep> listener ( this . monitored <identifiersep> list , operation <identifiersep> set ) ) ; <LOG> set <identifiersep> up <identifiersep> monitor ( this . irc , this . nick <identifiersep> watch <identifiersep> list , max <identifiersep> list <identifiersep> size ) ; } <comment> <ect>
{ logger . trace ( <string_literal> + nick + <string_literal> ) ; this . nick <identifiersep> watch <identifiersep> list . add ( nick ) ; this . irc . raw <identifiersep> message ( <string_literal> + nick ) ; } @ override public void remove ( final string nick ) <LOG> { this . nick <identifiersep> watch <identifiersep> list . remove ( nick ) ; this . irc . raw <identifiersep> message ( <string_literal> + nick ) ; <comment> <ect>
this . provider . set <identifiersep> current <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . registered , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> user <identifiersep> request ) ; } } catch ( io <identifiersep> exception e ) { if ( is <identifiersep> caused <identifiersep> by <identifiersep> certificate <identifiersep> exception ( e ) ) <LOG> { <comment> <ect>
try { certificate <identifiersep> service cs = irc <identifiersep> activator . get <identifiersep> certificate <identifiersep> service ( ) ; x509extended <identifiersep> trust <identifiersep> manager tm = cs . get <identifiersep> trust <identifiersep> manager ( hostname ) ; context = cs . get <identifiersep> ssl <identifiersep> context ( tm ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) <LOG> { } return context ; } <comment> public void disconnect ( ) <ect>
if ( this . session . get ( ) != connection ) { <comment> <LOG> return ; } this . provider . set <identifiersep> current <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> not <identifiersep> specified ) ; } <comment> <ect>
. system <identifiersep> message <identifiersep> received ) ; fire <identifiersep> message <identifiersep> event ( help <identifiersep> event ) ; } } else { connection . get <identifiersep> message <identifiersep> manager ( ) . message ( to , message ) ; } } catch ( runtime <identifiersep> exception e ) <LOG> { throw e ; } } fire <identifiersep> message <identifiersep> delivered ( original , to ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <comment> <ect>
this . channellist . set ( list ) ; logger . trace ( <string_literal> ) ; <comment> <LOG> { { <comment> <ect>
{ logger . trace ( <string_literal> + <string_literal> ) ; return ; } this . container . set ( null ) ; } <comment> <LOG> <comment> <ect>
{ <comment> <LOG> { return null ; } } <comment> <ect>
logger . debug ( <string_literal> + <string_literal> ) ; return ; } call <identifiersep> peer <identifiersep> gibberish <identifiersep> impl call <identifiersep> peer <LOG> = ( call <identifiersep> peer <identifiersep> gibberish <identifiersep> impl ) peer ; call <identifiersep> peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . disconnected , null ) ; call <identifiersep> gibberish <identifiersep> impl call = call <identifiersep> peer . get <identifiersep> call ( ) ; call . remove <identifiersep> call <identifiersep> peer ( call <identifiersep> peer ) ; } <comment> <ect>
byte [ ] image = null ; try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) <LOG> { } return image ; } public static resource <identifiersep> management <identifiersep> service get <identifiersep> resources ( ) { if ( resources <identifiersep> service == null ) { <ect>
<comment> public void shutdown ( ) { if ( ! is <identifiersep> initialized ) { <LOG> return ; } if ( is <identifiersep> registered ( ) ) { try { <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { gibberish <identifiersep> provider <identifiersep> factory . stop ( ) ; <LOG> gibberish <identifiersep> pp <identifiersep> factory <identifiersep> serv <identifiersep> reg . unregister ( ) ; } public static resource <identifiersep> management <identifiersep> service get <identifiersep> resources ( ) { if ( resource <identifiersep> service == null ) { service <identifiersep> reference service <identifiersep> reference = bundle <identifiersep> context <ect>
{ if ( already <identifiersep> set <identifiersep> details . size ( ) > 0 ) replace <identifiersep> detail ( old <identifiersep> display <identifiersep> name , new <identifiersep> display <identifiersep> name <identifiersep> detail ) ; else add <identifiersep> detail ( new <identifiersep> display <identifiersep> name <identifiersep> detail ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { } } <comment> void shutdown ( ) { <ect>
. create <identifiersep> sip <identifiersep> uri ( null , host ) ; intended <identifiersep> destination <identifiersep> uri . set <identifiersep> port ( port ) ; if ( transport != null ) intended <identifiersep> destination <identifiersep> uri . set <identifiersep> transport <identifiersep> param ( transport ) ; } catch ( parse <identifiersep> exception e ) <LOG> { from <identifiersep> header from = ( from <identifiersep> header ) response . get <identifiersep> header ( from . name ) ; intended <identifiersep> destination <identifiersep> uri = ( sip <identifiersep> uri ) from . get <identifiersep> address ( ) . get <identifiersep> uri ( ) ; } contact <identifiersep> header contact <identifiersep> header = protocol <identifiersep> provider . get <identifiersep> contact <identifiersep> header ( intended <identifiersep> destination <identifiersep> uri ) ; response . set <identifiersep> header ( contact <identifiersep> header ) ; <ect>
return ; } try { if ( to . get <identifiersep> tag ( ) == null || to . get <identifiersep> tag ( ) . trim ( ) . length ( ) == 0 ) { <LOG> string to <identifiersep> tag = generate <identifiersep> local <identifiersep> tag ( ) ; to . set <identifiersep> tag ( to <identifiersep> tag ) ; } } catch ( parse <identifiersep> exception ex ) { <comment> <ect>
long version = o . get <identifiersep> session <identifiersep> version ( ) ; o . set <identifiersep> session <identifiersep> version ( version + 1 ) ; update . set <identifiersep> origin ( o ) ; } catch ( exception e ) { <LOG> <comment> <ect>
format <identifiersep> strings = media <identifiersep> desc . get <identifiersep> media ( ) . get <identifiersep> media <identifiersep> formats ( true ) ; } catch ( sdp <identifiersep> parse <identifiersep> exception exc ) { <comment> <LOG> <comment> <ect>
try { advp = find <identifiersep> advanced <identifiersep> attributes ( media <identifiersep> desc . get <identifiersep> attributes ( false ) , pt <identifiersep> str ) ; } catch ( sdp <identifiersep> exception e ) <LOG> { } media <identifiersep> format media <identifiersep> format = null ; try { media <identifiersep> format = create <identifiersep> format ( pt , rtpmap , fmtp , frame <identifiersep> rate , advp , pt <identifiersep> registry ) ; <ect>
attr <identifiersep> value = attr . get <identifiersep> value ( ) ; } catch ( sdp <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
logger . trace ( <string_literal> ) ; return null ; } try { return sdp <identifiersep> uri <identifiersep> field . get ( ) ; } catch ( sdp <identifiersep> parse <identifiersep> exception exc ) <LOG> { return null ; } } <comment> <ect>
{ attr <identifiersep> name = attr . get <identifiersep> name ( ) ; attr <identifiersep> val = attr . get <identifiersep> value ( ) ; } catch ( sdp <identifiersep> parse <identifiersep> exception e ) { <LOG> <comment> <ect>
|| <string_literal> . equals ( name ) || <string_literal> . equals ( name ) ) { i . remove ( ) ; } } catch ( sdp <identifiersep> exception e ) <LOG> { } } } <comment> <ect>
int bind <identifiersep> retries <identifiersep> value = get <identifiersep> bind <identifiersep> retries <identifiersep> value ( ) ; this . create <identifiersep> provider ( this . get <identifiersep> preferred <identifiersep> clear <identifiersep> port ( ) , bind <identifiersep> retries <identifiersep> value , false ) ; this . create <identifiersep> provider ( this . get <identifiersep> preferred <identifiersep> secure <identifiersep> port ( ) , bind <identifiersep> retries <identifiersep> value , true ) ; <LOG> this . stack . start ( ) ; } catch ( exception ex ) { logger . error ( <string_literal> + <string_literal> ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> <ect>
if ( secure ) { tls <identifiersep> lp = this . stack . create <identifiersep> listening <identifiersep> point ( network <identifiersep> utils . in <identifiersep> addr <identifiersep> any , preferred <identifiersep> port <LOG> , listening <identifiersep> point . tls ) ; this . secure <identifiersep> jain <identifiersep> sip <identifiersep> provider = this . stack . create <identifiersep> sip <identifiersep> provider ( tls <identifiersep> lp ) ; this . secure <identifiersep> jain <identifiersep> sip <identifiersep> provider . add <identifiersep> sip <identifiersep> listener ( this ) ; } else { <ect>
{ logger . debug ( <string_literal> + preferred <identifiersep> port + <string_literal> ) ; <comment> <LOG> int currently <identifiersep> tried <identifiersep> port = network <identifiersep> utils . get <identifiersep> random <identifiersep> port <identifiersep> number ( ) ; this . create <identifiersep> provider ( currently <identifiersep> tried <identifiersep> port , retries - 1 , secure ) ; } else throw ex ; } } <comment> <ect>
{ this . stack . delete <identifiersep> listening <identifiersep> point ( it . next ( ) ) ; } this . stack . stop ( ) ; logger . trace ( <string_literal> ) ; } catch ( object <identifiersep> in <identifiersep> use <identifiersep> exception ex ) <LOG> { } } <comment> <ect>
{ try { logger . trace ( event ) ; <LOG> <comment> <ect>
<comment> private protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl find <identifiersep> target <identifiersep> for ( request request ) { if ( request == null ) <LOG> { return null ; } list < protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl > current <identifiersep> listeners <identifiersep> copy = new array <identifiersep> list < protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl > ( this . get <identifiersep> sip <identifiersep> listeners ( ) ) ; <comment> <ect>
list < protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl > candidates = new array <identifiersep> list < protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl > ( ) ; <comment> <LOG> string our <identifiersep> user <identifiersep> id = listener . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> user <identifiersep> id ( ) ; if ( our <identifiersep> user <identifiersep> id . equals ( request <identifiersep> user ) ) { logger . trace ( <string_literal> + listener . get <identifiersep> account <identifiersep> id ( ) ) ; <ect>
protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl target = candidates . iterator ( ) . next ( ) ; logger . info ( <string_literal> + target . get <identifiersep> account <identifiersep> id ( ) + <string_literal> <LOG> + <string_literal> ) ; return target ; } <comment> <ect>
+ <string_literal> + <string_literal> ) ; logger . trace ( <string_literal> + request ) ; return target ; } else <LOG> { } return null ; } <comment> <ect>
return service ; } service = ( protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) sip <identifiersep> application <identifiersep> data . get <identifiersep> application <identifiersep> data ( transaction . get <identifiersep> dialog ( ) , sip <identifiersep> application <identifiersep> data . key <identifiersep> service ) ; if ( service != null ) <LOG> { } return service ; } <comment> <ect>
{ request . add <identifiersep> header ( new header <identifiersep> factory <identifiersep> impl ( ) . create <identifiersep> subscription <identifiersep> state <identifiersep> header ( subscription <identifiersep> state <identifiersep> header . active ) ) ; } } catch ( throwable ex ) <LOG> { } try { <comment> <ect>
client <identifiersep> transaction transac = null ; try { transac = this . parent <identifiersep> provider . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( req ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception e ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure ) ; } try { <ect>
return false ; client <identifiersep> transaction client <identifiersep> transaction = response <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; response response = response <identifiersep> event . get <identifiersep> response ( ) ; c <identifiersep> seq <identifiersep> header cseq = ( c <identifiersep> seq <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> seq <identifiersep> header . name ) ; if ( cseq == null ) <LOG> { return false ; } string method = cseq . get <identifiersep> method ( ) ; boolean processed = false ; <comment> <ect>
return false ; } this . distant <identifiersep> paet = et <identifiersep> header . get <identifiersep> e <identifiersep> tag ( ) ; <comment> <LOG> { return false ; } <comment> <ect>
<comment> <LOG> { return false ; } client <identifiersep> transaction transac = null ; try { transac = this . parent <identifiersep> provider <ect>
logger . error ( <string_literal> , e ) ; return false ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) <LOG> { return false ; } <comment> <ect>
try { transac = this . parent <identifiersep> provider . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( req ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception e ) <LOG> { return false ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) <ect>
node <identifiersep> list pres <identifiersep> list = doc . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name <identifiersep> ns ( pidf <identifiersep> ns <identifiersep> value , presence <identifiersep> element ) ; if ( pres <identifiersep> list . get <identifiersep> length ( ) == 0 ) { pres <identifiersep> list = doc . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name <identifiersep> ns ( any <identifiersep> ns , presence <identifiersep> element ) ; if ( pres <identifiersep> list . get <identifiersep> length ( ) == 0 ) <LOG> { return ; } } if ( pres <identifiersep> list . get <identifiersep> length ( ) > 1 ) { logger . warn ( <string_literal> ) ; } node pres <identifiersep> node = pres <identifiersep> list . item ( 0 ) ; <ect>
return ; } } if ( pres <identifiersep> list . get <identifiersep> length ( ) > 1 ) { logger . warn ( <string_literal> ) ; } node pres <identifiersep> node = pres <identifiersep> list . item ( 0 ) ; if ( pres <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) != node . element <identifiersep> node ) <LOG> { return ; } element presence = ( element ) pres <identifiersep> node ; <comment> <ect>
<comment> <LOG> { return ; } element person = ( element ) person <identifiersep> node ; node <identifiersep> list activity <identifiersep> list = person . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name <identifiersep> ns ( any <identifiersep> ns , activity <identifiersep> element ) ; if ( activity <identifiersep> list . get <identifiersep> length ( ) > 0 ) <ect>
break ; } index -- ; } while ( index >= 0 ) ; element basic = null ; if ( status <identifiersep> node == null ) <LOG> { } else { element status = ( element ) status <identifiersep> node ; <comment> <ect>
<comment> public void set <identifiersep> watcher <identifiersep> info <identifiersep> status ( watcher <identifiersep> info <identifiersep> subscriber <identifiersep> subscription subscriber , string watcher <identifiersep> info <identifiersep> doc ) { if ( this . authorization <identifiersep> handler == null ) <LOG> { return ; } document doc = convert <identifiersep> document ( watcher <identifiersep> info <identifiersep> doc ) ; if ( doc == null ) return ; <ect>
watcherinfo <identifiersep> ns <identifiersep> value , watcherinfo <identifiersep> element ) ; if ( watch <identifiersep> list . get <identifiersep> length ( ) == 0 ) { watch <identifiersep> list = doc . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name <identifiersep> ns ( any <identifiersep> ns , watcherinfo <identifiersep> element ) ; if ( watch <identifiersep> list . get <identifiersep> length ( ) == 0 ) <LOG> { return ; } } if ( watch <identifiersep> list . get <identifiersep> length ( ) > 1 ) { logger . warn ( <string_literal> ) ; } node watcher <identifiersep> info <identifiersep> node = watch <identifiersep> list . item ( 0 ) ; <ect>
return ; } } if ( watch <identifiersep> list . get <identifiersep> length ( ) > 1 ) { logger . warn ( <string_literal> ) ; } node watcher <identifiersep> info <identifiersep> node = watch <identifiersep> list . item ( 0 ) ; if ( watcher <identifiersep> info <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) != node . element <identifiersep> node ) <LOG> { return ; } element watcher <identifiersep> info = ( element ) watcher <identifiersep> info <identifiersep> node ; <comment> <ect>
current <identifiersep> version = integer . parse <identifiersep> int ( watcher <identifiersep> info . get <identifiersep> attribute ( version <identifiersep> attribute ) ) ; } catch ( throwable t ) { logger . error ( <string_literal> , t ) ; } if ( current <identifiersep> version != - 1 && current <identifiersep> version < = subscriber . version ) <LOG> { return ; } else subscriber . version = current <identifiersep> version ; <comment> <ect>
node <identifiersep> list watcher <identifiersep> list = wlist . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name <identifiersep> ns ( any <identifiersep> ns , watcher <identifiersep> element ) ; for ( int i = 0 ; i < watcher <identifiersep> list . get <identifiersep> length ( ) ; i ++ ) { node watcher <identifiersep> node = watcher <identifiersep> list . item ( i ) ; if ( watcher <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) != node . element <identifiersep> node ) <LOG> { return ; } element watcher = ( element ) watcher <identifiersep> node ; string status = watcher . get <identifiersep> attribute ( status <identifiersep> element ) ; string contact <identifiersep> id = get <identifiersep> text <identifiersep> content ( watcher ) ; <comment> <ect>
<comment> private string get <identifiersep> text <identifiersep> content ( element node ) { string res = xml <identifiersep> utils . get <identifiersep> text ( node ) ; if ( res == null ) <LOG> { return <string_literal> ; } return res ; } <comment> <ect>
<comment> public void unsubscribe <identifiersep> to <identifiersep> all <identifiersep> contact ( ) { <LOG> { } <comment> <ect>
else { <comment> <LOG> { return ; } client <identifiersep> transaction transac = null ; try { transac = parent <identifiersep> provider <ect>
logger . error ( <string_literal> , e ) ; return ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) <LOG> { return ; } } } <comment> private class poll <identifiersep> offline <identifiersep> contacts <identifiersep> task extends timer <identifiersep> task <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistering ) ) { <LOG> { } <comment> <ect>
{ logger . error ( <string_literal> , e ) ; } stop <identifiersep> events ( ) ; } else if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { <LOG> { } <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> @ override protected void process <identifiersep> terminated <identifiersep> request ( request <identifiersep> event request <identifiersep> event , string reason <identifiersep> code ) <LOG> { } } } <ect>
{ process <identifiersep> cancel ( server <identifiersep> transaction , request ) ; processed = true ; } <comment> <LOG> { process <identifiersep> refer ( server <identifiersep> transaction , request , jain <identifiersep> sip <identifiersep> provider ) ; processed = true ; } <comment> <ect>
{ logger . debug ( <string_literal> ) ; processed = process <identifiersep> notify ( server <identifiersep> transaction , request ) ; } else if ( request <identifiersep> method . equals ( request . update ) ) <LOG> { processed = process <identifiersep> update ( server <identifiersep> transaction , request ) ; } return processed ; } <comment> <ect>
case response . moved <identifiersep> temporarily : case response . moved <identifiersep> permanently : { call <identifiersep> peer <identifiersep> sip <identifiersep> impl call <identifiersep> peer = active <identifiersep> calls <identifiersep> repository . find <identifiersep> call <identifiersep> peer ( client <identifiersep> transaction . get <identifiersep> dialog ( ) ) ; if ( call <identifiersep> peer == null ) <LOG> { return true ; } contact <identifiersep> header contact <identifiersep> header = ( contact <identifiersep> header ) response . get <identifiersep> header ( contact <identifiersep> header . name ) ; if ( contact <identifiersep> header == null ) { <ect>
logger . error ( <string_literal> + response . get <identifiersep> status <identifiersep> code ( ) + <string_literal> + response . get <identifiersep> reason <identifiersep> phrase ( ) + <string_literal> + warning <identifiersep> header . get <identifiersep> text ( ) + <string_literal> + warning <identifiersep> header . get <identifiersep> agent ( ) + <string_literal> + warning <identifiersep> header . get <identifiersep> name ( ) ) ; } else <LOG> { + <string_literal> + response . get <identifiersep> reason <identifiersep> phrase ( ) ) ; } if ( call <identifiersep> peer != null ) call <identifiersep> peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . failed , reason ) ; processed = true ; <ect>
dialog dialog = client <identifiersep> transaction . get <identifiersep> dialog ( ) ; <comment> <LOG> { return ; } <comment> <ect>
{ dialog dialog = client <identifiersep> transaction . get <identifiersep> dialog ( ) ; <comment> <LOG> { return ; } <comment> <ect>
logger . debug ( <string_literal> ) ; client <identifiersep> transaction retry <identifiersep> tran = protocol <identifiersep> provider . get <identifiersep> sip <identifiersep> security <identifiersep> manager ( ) . handle <identifiersep> challenge ( response , client <identifiersep> transaction , jain <identifiersep> sip <identifiersep> provider ) ; if ( retry <identifiersep> tran == null ) <LOG> { return ; } if ( call <identifiersep> peer != null ) { call <identifiersep> peer . handle <identifiersep> authentication <identifiersep> challenge ( retry <identifiersep> tran ) ; } retry <identifiersep> tran . send <identifiersep> request ( ) ; <ect>
<comment> <LOG> { } try { protocol <identifiersep> provider . say <identifiersep> error ( server <identifiersep> transaction , response . session <identifiersep> not <identifiersep> acceptable , warning ) ; <ect>
{ <comment> <LOG> { return ; } call <identifiersep> peer . process <identifiersep> bye ( server <identifiersep> transaction ) ; } <comment> <ect>
<comment> } if ( no <identifiersep> such <identifiersep> call != null ) { try { <LOG> server <identifiersep> transaction . send <identifiersep> response ( no <identifiersep> such <identifiersep> call ) ; } catch ( exception ex ) { logger . error ( <string_literal> + <string_literal> , ex ) ; } } <comment> <ect>
<comment> <LOG> <comment> <ect>
logger . error ( <string_literal> , e ) ; return ; } try { server <identifiersep> transaction . send <identifiersep> response ( decline <identifiersep> response ) ; } catch ( exception e ) <LOG> { return ; } return ; } } <comment> <ect>
: <string_literal> ) ; } <comment> public synchronized void shutdown ( ) <LOG> { iterator < call <identifiersep> sip <identifiersep> impl > active <identifiersep> calls = this . active <identifiersep> calls <identifiersep> repository . get <identifiersep> active <identifiersep> calls ( ) ; <comment> <ect>
content <identifiersep> length cl = new content <identifiersep> length ( content . length ( ) ) ; info . set <identifiersep> content <identifiersep> length ( cl ) ; try { info . set <identifiersep> content ( content . get <identifiersep> bytes ( ) , ct ) ; } catch ( parse <identifiersep> exception ex ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , ex ) ; } <comment> <ect>
@ override public boolean process <identifiersep> response ( response <identifiersep> event response <identifiersep> event ) { boolean processed = false ; if ( response <identifiersep> event == null ) <LOG> { } else { response response = response <identifiersep> event . get <identifiersep> response ( ) ; if ( response == null ) <ect>
{ <comment> <LOG> { } else { request request = client <identifiersep> transaction . get <identifiersep> request ( ) ; if ( request == null ) <ect>
if ( status <identifiersep> code == <number_literal> ) { logger . debug ( <string_literal> + status <identifiersep> code ) ; } <LOG> else } } } } } return processed ; } <comment> @ override <ect>
{ collection < dtmf <identifiersep> listener > listeners ; synchronized ( this . dtmf <identifiersep> listeners ) { listeners = new array <identifiersep> list < dtmf <identifiersep> listener > ( this . dtmf <identifiersep> listeners ) ; } <LOG> dtmf <identifiersep> received <identifiersep> event evt = new dtmf <identifiersep> received <identifiersep> event ( pps , tone , duration ) ; + <string_literal> + evt ) ; try { for ( dtmf <identifiersep> listener listener : listeners ) { <ect>
catch ( interrupted <identifiersep> exception ie ) { } try { conference <identifiersep> event <identifiersep> package <identifiersep> notifier . this . notify ( subscription , subscription <identifiersep> state , reason ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { } } } ) . start ( ) ; return ; } conference <identifiersep> info <identifiersep> document current <identifiersep> conf <identifiersep> info = get <identifiersep> current <identifiersep> conference <identifiersep> info ( call <identifiersep> peer ) ; conference <identifiersep> info <identifiersep> document last <identifiersep> sent <identifiersep> conf <identifiersep> info <ect>
document convert <identifiersep> document ( byte [ ] document ) { try { return xml <identifiersep> utils . create <identifiersep> document ( new string ( document , <string_literal> ) ) ; } catch ( exception e ) <LOG> { return null ; } } <comment> <ect>
{ if ( raw <identifiersep> content == null ) return ; document doc = convert <identifiersep> document ( raw <identifiersep> content ) ; if ( doc == null ) <LOG> return ; line <identifiersep> details details = ( line <identifiersep> details ) line . get <identifiersep> data ( data <identifiersep> prop ) ; if ( details == null ) { details = new line <identifiersep> details ( ) ; line . set <identifiersep> data ( data <identifiersep> prop , details ) ; <ect>
catch ( exception e ) { } if ( doc == null ) { <comment> <LOG> return false ; } <comment> <ect>
logger . error ( <string_literal> ) ; <comment> <LOG> { <comment> <ect>
{ string refresh <identifiersep> str = xml <identifiersep> utils . get <identifiersep> text ( ( element ) refresh <identifiersep> node ) ; try { refresh = integer . parse <identifiersep> int ( refresh <identifiersep> str ) ; } catch ( exception e ) <LOG> { } } } <comment> <ect>
{ <comment> <LOG> <comment> <ect>
return null ; try { icon = new byte [ is . available ( ) ] ; is . read ( icon ) ; } catch ( io <identifiersep> exception ioex ) <LOG> { } } return icon ; } } <ect>
s <identifiersep> state <identifiersep> header = protocol <identifiersep> provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> subscription <identifiersep> state <identifiersep> header ( subscription <identifiersep> state ) ; if ( ( reason != null ) && ( reason . trim ( ) . length ( ) != 0 ) ) s <identifiersep> state <identifiersep> header . set <identifiersep> reason <identifiersep> code ( reason ) ; } catch ( parse <identifiersep> exception e ) { <LOG> <comment> <ect>
req . set <identifiersep> header ( via <identifiersep> headers . get ( 0 ) ) ; <comment> <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , e ) ; } return transac ; <ect>
response response ; try { response = protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . interval <identifiersep> too <identifiersep> brief , request ) ; } catch ( exception e ) <LOG> { return false ; } min <identifiersep> expires <identifiersep> header min ; try { min <ect>
return false ; } response . set <identifiersep> header ( min ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) <LOG> { return false ; } return true ; } subscription subscription = get <identifiersep> subscription ( call <identifiersep> id ) ; <comment> <ect>
<comment> <LOG> { return false ; } response . set <identifiersep> header ( exp <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; <ect>
try { transac = create <identifiersep> notify ( dialog , subscription , subscription <identifiersep> state <identifiersep> header . terminated , subscription <identifiersep> state <identifiersep> header . rejected ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { return false ; } remove <identifiersep> subscription ( call <identifiersep> id , subscription ) ; try { dialog . send <identifiersep> request ( transac ) ; <ect>
response response ; try { response = protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . ok , request ) ; } catch ( exception e ) <LOG> { return false ; } <comment> <ect>
return false ; } response . set <identifiersep> header ( exp <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) <LOG> { return false ; } <comment> <ect>
public boolean process <identifiersep> response ( response <identifiersep> event response <identifiersep> event ) { response response = response <identifiersep> event . get <identifiersep> response ( ) ; c <identifiersep> seq <identifiersep> header cseq <identifiersep> header = ( c <identifiersep> seq <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> seq <identifiersep> header . name ) ; if ( cseq <identifiersep> header == null ) <LOG> { return false ; } if ( ! request . notify . equals ( cseq <identifiersep> header . get <identifiersep> method ( ) ) ) return false ; client <identifiersep> transaction client <identifiersep> transaction = response <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; <ect>
break ; default : <comment> <LOG> <comment> remove <identifiersep> subscription ( response , event <identifiersep> id , client <identifiersep> transaction ) ; break ; } return true ; } <comment> <ect>
response . set <identifiersep> content ( sdp <identifiersep> answer , get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> content <identifiersep> type <identifiersep> header ( <string_literal> , <string_literal> ) ) ; logger . trace ( <string_literal> + response ) ; <LOG> server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception ex ) <comment> <ect>
<comment> <LOG> { <comment> <ect>
<comment> <LOG> server <identifiersep> transaction . send <identifiersep> response ( ok ) ; } catch ( parse <identifiersep> exception ex ) { log <identifiersep> and <identifiersep> fail ( <string_literal> , ex ) ; return ; } catch ( exception ex ) <ect>
<comment> public void process <identifiersep> session <identifiersep> progress ( client <identifiersep> transaction tran , response response ) { if ( response . get <identifiersep> content <identifiersep> length ( ) . get <identifiersep> content <identifiersep> length ( ) == 0 ) <LOG> { return ; } content <identifiersep> type <identifiersep> header content <identifiersep> type <identifiersep> header = ( content <identifiersep> type <identifiersep> header ) response . get <identifiersep> header ( content <identifiersep> type <identifiersep> header . name ) ; if ( ! content <identifiersep> type <identifiersep> header . get <identifiersep> content <identifiersep> type ( ) . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) || ! content <identifiersep> type <identifiersep> header . get <identifiersep> content <identifiersep> sub <identifiersep> type ( ) . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) <ect>
<comment> <LOG> get <identifiersep> dialog ( ) . send <identifiersep> request ( client <identifiersep> transaction ) ; } catch ( sip <identifiersep> exception ex ) { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , <ect>
<comment> private void say <identifiersep> busy <identifiersep> here ( ) throws operation <identifiersep> failed <identifiersep> exception { if ( ! ( get <identifiersep> latest <identifiersep> invite <identifiersep> transaction ( ) instanceof server <identifiersep> transaction ) ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error ) ; } request request = get <identifiersep> latest <identifiersep> invite <identifiersep> transaction ( ) . get <identifiersep> request ( ) ; response busy <identifiersep> here = null ; <ect>
<comment> private void say <identifiersep> cancel ( ) throws operation <identifiersep> failed <identifiersep> exception { if ( get <identifiersep> latest <identifiersep> invite <identifiersep> transaction ( ) instanceof server <identifiersep> transaction ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error ) ; } client <identifiersep> transaction client <identifiersep> transaction = ( client <identifiersep> transaction ) get <identifiersep> latest <identifiersep> invite <identifiersep> transaction ( ) ; <ect>
. create <identifiersep> reason <identifiersep> header ( <string_literal> , sip <identifiersep> code , reason ) ; bye . set <identifiersep> header ( reason <identifiersep> header ) ; } catch ( throwable e ) <LOG> { } } } get <identifiersep> protocol <identifiersep> provider ( ) . send <identifiersep> in <identifiersep> dialog <identifiersep> request ( get <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) , bye , dialog ) ; <comment> <ect>
. create <identifiersep> content <identifiersep> type <identifiersep> header ( <string_literal> , <string_literal> ) ; invite . set <identifiersep> content ( get <identifiersep> media <identifiersep> handler ( ) . create <identifiersep> offer ( ) , content <identifiersep> type <identifiersep> header ) ; process <identifiersep> extra <identifiersep> headers ( invite ) ; <LOG> invite <identifiersep> tran . send <identifiersep> request ( ) ; } catch ( exception ex ) { protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl . throw <identifiersep> operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , <ect>
cc <identifiersep> entry = create <identifiersep> cc <identifiersep> entry <identifiersep> with <identifiersep> stored <identifiersep> password ( stored <identifiersep> password ) ; logger . trace ( <string_literal> ) ; } else { <LOG> <comment> <ect>
iterator < string > realms <identifiersep> iter = realms . iterator ( ) ; while ( realms <identifiersep> iter . has <identifiersep> next ( ) ) { credentials <identifiersep> cache <identifiersep> entry cc <identifiersep> entry = create <identifiersep> cc <identifiersep> entry <identifiersep> with <identifiersep> stored <identifiersep> password ( <string_literal> ) ; cc <identifiersep> entry . push <identifiersep> branch <identifiersep> id ( retry <identifiersep> tran . get <identifiersep> branch <identifiersep> id ( ) ) ; <LOG> cached <identifiersep> credentials . cache <identifiersep> entry ( realms <identifiersep> iter . next ( ) , cc <identifiersep> entry ) ; } return retry <identifiersep> tran ; } <comment> <ect>
try { message <identifiersep> digest digest = message <identifiersep> digest . get <identifiersep> instance ( <string_literal> ) ; return to <identifiersep> hex <identifiersep> string ( digest . digest ( data . get <identifiersep> bytes ( ) ) ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { <LOG> <comment> <ect>
x <identifiersep> cap <identifiersep> error error = x <identifiersep> cap <identifiersep> error . get <identifiersep> error ( ) ; if ( error == null ) { return null ; } return error . get <identifiersep> phrase ( ) ; } catch ( parsing <identifiersep> exception e ) <LOG> { return null ; } } <comment> private class x <identifiersep> cap <identifiersep> credentials <identifiersep> provider <ect>
<comment> <LOG> + <string_literal> ) ; return false ; } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <comment> <ect>
{ <comment> <LOG> <comment> <ect>
try { ( ( listening <identifiersep> point <identifiersep> ext ) lp ) . send <identifiersep> heartbeat ( address . get <identifiersep> address ( ) . get <identifiersep> host <identifiersep> address ( ) , address . get <identifiersep> port ( ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } } private class registration <identifiersep> listener implements registration <identifiersep> state <identifiersep> change <identifiersep> listener { <comment> <ect>
! ( keep <identifiersep> alive <identifiersep> method . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) || keep <identifiersep> alive <identifiersep> method . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) ) return ; int keep <identifiersep> alive <identifiersep> interval = provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> property <identifiersep> int ( <LOG> protocol <identifiersep> provider <identifiersep> factory . keep <identifiersep> alive <identifiersep> interval , - 1 ) ; if ( keep <identifiersep> alive <identifiersep> interval > 0 && ! provider . get <identifiersep> registrar <identifiersep> connection ( ) . is <identifiersep> registrarless ( ) ) { if ( keep <identifiersep> alive <identifiersep> timer == null ) keep <identifiersep> alive <identifiersep> timer = new timer ( ) ; <ect>
{ call <identifiersep> sip <identifiersep> impl call = active <identifiersep> calls . next ( ) ; call <identifiersep> peer <identifiersep> sip <identifiersep> impl call <identifiersep> peer = call . find <identifiersep> call <identifiersep> peer ( dialog ) ; if ( call <identifiersep> peer != null ) <LOG> { return call <identifiersep> peer ; } } return null ; } <comment> <ect>
catch ( sdp <identifiersep> parse <identifiersep> exception spe ) { logger . error ( <string_literal> , spe ) ; } } } } } } catch ( throwable t ) <LOG> { } fire <identifiersep> call <identifiersep> event ( incoming <identifiersep> call ? call <identifiersep> event . call <identifiersep> received : call <identifiersep> event . call <identifiersep> initiated , this , <ect>
<comment> <LOG> force <identifiersep> transport = <string_literal> ; } else if ( callee <identifiersep> uri . is <identifiersep> sip <identifiersep> uri ( ) && callee <identifiersep> uri instanceof sip <identifiersep> uri ) { sip <identifiersep> uri  <identifiersep> callee <identifiersep> uri = ( sip <identifiersep> uri ) callee <identifiersep> uri ; <comment> <ect>
{ logger . trace ( <string_literal> + force <identifiersep> transport ) ; } } <comment> <LOG> { jain <identifiersep> sip <identifiersep> provider = get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> jain <identifiersep> sip <identifiersep> provider ( force <identifiersep> transport ) ; } else { logger . trace ( <string_literal> ) ; <ect>
jitsi <identifiersep> meet <identifiersep> tools . notify <identifiersep> join <identifiersep> jitsi <identifiersep> meet <identifiersep> room ( this , extract <identifiersep> request <identifiersep> headers ( invite ) ) ; <comment> <LOG> { if ( call <identifiersep> peer <identifiersep> state . incoming <identifiersep> call . equals ( peer . get <identifiersep> state ( ) ) ) { response = message <identifiersep> factory . create <identifiersep> response ( response . ringing , invite ) ; server <identifiersep> tran . send <identifiersep> response ( response ) ; if ( server <identifiersep> tran instanceof sip <identifiersep> transaction <ect>
timer . schedule ( new ringing <identifiersep> response <identifiersep> task ( response , server <identifiersep> tran , peer , timer ) , delay ) ; interval *= <number_literal> ; } } logger . debug ( <string_literal> + response ) ; } } catch ( exception ex ) <LOG> { peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . failed , <string_literal> + ex . get <identifiersep> message ( ) ) ; return peer ; } return peer ; } <comment> <ect>
<comment> <LOG> { + <string_literal> ) ; continue ; } media <identifiersep> direction direction = dev . get <identifiersep> direction ( ) . and ( get <identifiersep> direction <identifiersep> user <identifiersep> preference ( media <identifiersep> type ) ) ; if ( is <identifiersep> locally <identifiersep> on <identifiersep> hold ( ) ) <ect>
{ logger . error ( <string_literal> , e ) ; } } else { <comment> <LOG> srtp <identifiersep> controls . remove ( media <identifiersep> type , srtp <identifiersep> control <identifiersep> type . sdes ) ; } return false ; } } <comment> <ect>
if ( select <identifiersep> sdes <identifiersep> crypto <identifiersep> suite ( true , sdes <identifiersep> control , media <identifiersep> description ) == null ) { sdes <identifiersep> control . cleanup ( null ) ; <LOG> srtp <identifiersep> controls . remove ( media <identifiersep> type , srtp <identifiersep> control <identifiersep> type . sdes ) ; } else { <comment> <ect>
a = attrs . get ( i ) ; if ( a . get <identifiersep> name ( ) . equals ( <string_literal> ) ) { peer <identifiersep> attributes . add ( srtp <identifiersep> crypto <identifiersep> attribute . create ( a . get <identifiersep> value ( ) ) ) ; } } catch ( exception e ) <LOG> { } } if ( is <identifiersep> initiator ) { return s <identifiersep> des <identifiersep> control . initiator <identifiersep> select <identifiersep> attribute ( peer <identifiersep> attributes ) ; } else { <ect>
<comment> <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> + <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , e ) ; <ect>
logger . debug ( <string_literal> ) ; subscription <identifiersep> state <identifiersep> header sstate <identifiersep> header = ( subscription <identifiersep> state <identifiersep> header ) request . get <identifiersep> header ( subscription <identifiersep> state <identifiersep> header . name ) ; <comment> <LOG> { return false ; } string sstate = sstate <identifiersep> header . get <identifiersep> state ( ) ; server <identifiersep> transaction server <identifiersep> transaction = get <identifiersep> or <identifiersep> create <identifiersep> server <identifiersep> transaction ( request <identifiersep> event ) ; <comment> <ect>
= protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . call <identifiersep> or <identifiersep> transaction <identifiersep> does <identifiersep> not <identifiersep> exist , request ) ; } catch ( parse <identifiersep> exception e ) <LOG> { return false ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( sip <identifiersep> exception e ) <ect>
= protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . unsupported <identifiersep> media <identifiersep> type , request ) ; } catch ( parse <identifiersep> exception e ) <LOG> { return false ; } <comment> <ect>
return false ; } response . set <identifiersep> header ( accept <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( sip <identifiersep> exception e ) <LOG> { } catch ( invalid <identifiersep> argument <identifiersep> exception e ) { <comment> <ect>
logger . error ( <string_literal> , e ) ; return false ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) <LOG> { return false ; } return true ; <comment> <ect>
subscription . process <identifiersep> failure <identifiersep> response ( response <identifiersep> event , status <identifiersep> code ) ; } <comment> <LOG> { remove <identifiersep> subscription ( call <identifiersep> id , subscription ) ; subscription . process <identifiersep> failure <identifiersep> response ( response <identifiersep> event , status <identifiersep> code ) ; } } return true ; } <comment> <ect>
remove <identifiersep> subscription ( call <identifiersep> id , subscription ) ; try { dialog . send <identifiersep> request ( subscribe <identifiersep> transaction ) ; } catch ( sip <identifiersep> exception e ) <LOG> { throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , e ) ; <ect>
logger . error ( <string_literal> , e ) ; return ; } try { dialog . send <identifiersep> request ( transac ) ; } catch ( sip <identifiersep> exception e ) <LOG> { } } } } <ect>
{ int tc = get <identifiersep> dscp ( ) ; try { s . set <identifiersep> traffic <identifiersep> class ( tc ) ; } catch ( socket <identifiersep> exception e ) <LOG> { } } <comment> <ect>
list < string > cert <identifiersep> identities = new array <identifiersep> list < string > ( ) ; collection < list < ? > > subj <identifiersep> alt <identifiersep> names = null ; try { subj <identifiersep> alt <identifiersep> names = cert . get <identifiersep> subject <identifiersep> alternative <identifiersep> names ( ) ; } catch ( certificate <identifiersep> parsing <identifiersep> exception ex ) <LOG> { } <comment> <ect>
continue ; <comment> <LOG> { + <string_literal> + alt <identifiersep> host <identifiersep> name ) ; } cert <identifiersep> identities . add ( alt <identifiersep> host <identifiersep> name ) ; } catch ( parse <identifiersep> exception e ) { logger . error ( <string_literal> <ect>
{ logger . debug ( <string_literal> + cname + <string_literal> + dname ) ; } cert <identifiersep> identities . add ( cname ) ; } } catch ( exception ex ) <LOG> { } } return cert <identifiersep> identities ; } } <ect>
{ logger . error ( <string_literal> + address + <string_literal> , e ) ; return false ; } } <comment> <LOG> { lookups = null ; return false ; } <comment> <ect>
{ subscribe <identifiersep> address = get <identifiersep> subscribe <identifiersep> address ( ) ; if ( subscribe <identifiersep> address == null ) { return ; } } catch ( parse <identifiersep> exception e ) <LOG> { } final message <identifiersep> summary <identifiersep> subscriber default <identifiersep> subscriber = new message <identifiersep> summary <identifiersep> subscriber ( subscribe <identifiersep> address ) ; message <identifiersep> waiting <identifiersep> subscriber = new event <identifiersep> package <identifiersep> subscriber ( provider , <ect>
{ try { message <identifiersep> waiting <identifiersep> subscriber . unsubscribe ( get <identifiersep> subscribe <identifiersep> address ( ) , false ) ; } catch ( throwable t ) <LOG> { } } } } <comment> <ect>
<comment> @ override protected void process <identifiersep> failure <identifiersep> response ( response <identifiersep> event response <identifiersep> event , int status <identifiersep> code ) <LOG> { } <comment> <ect>
<comment> @ override protected void process <identifiersep> terminated <identifiersep> request ( request <identifiersep> event request <identifiersep> event , string reason <identifiersep> code ) <LOG> { } } } <ect>
{ cp <identifiersep> dtmf <identifiersep> method = dtmf <identifiersep> method . inband <identifiersep> dtmf ; } } <comment> <LOG> { } ( ( audio <identifiersep> media <identifiersep> stream ) cp . get <identifiersep> media <identifiersep> handler ( ) . get <identifiersep> stream ( media <identifiersep> type . audio ) ) . stop <identifiersep> sending <identifiersep> dtmf ( cp <identifiersep> dtmf <identifiersep> method ) ; } } <comment> <ect>
. handle <identifiersep> challenge ( response , client <identifiersep> transaction , jain <identifiersep> sip <identifiersep> provider ) ; if ( retry <identifiersep> tran == null ) <LOG> { return ; } retry <identifiersep> tran . send <identifiersep> request ( ) ; } catch ( exception exc ) { logger . error ( <string_literal> , <ect>
logger . error ( <string_literal> , e ) ; return false ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) <LOG> { return false ; } return true ; } <comment> <ect>
dictionary < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( protocol <identifiersep> provider <identifiersep> factory . protocol , protocol <identifiersep> names . sip ) ; sip <identifiersep> pp <identifiersep> factory <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> factory . class . get <identifiersep> name ( ) , sip <identifiersep> provider <identifiersep> factory , <LOG> properties ) ; } <comment> protected protocol <identifiersep> provider <identifiersep> factory <identifiersep> sip <identifiersep> impl create <identifiersep> protocol <identifiersep> provider <identifiersep> factory ( ) <ect>
{ throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( root <identifiersep> group . equals ( group ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } <LOG> { } contact <identifiersep> group <identifiersep> sip <identifiersep> impl parent <identifiersep> group = ( contact <identifiersep> group <identifiersep> sip <identifiersep> impl ) group . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) ; parent <identifiersep> group . remove <identifiersep> sub <identifiersep> group ( group ) ; if ( group . is <identifiersep> persistent ( ) ) { <ect>
{ try { if ( add <identifiersep> contact <identifiersep> to <identifiersep> white <identifiersep> list ( contact ) ) update <identifiersep> pres <identifiersep> rules ( ) ; } catch ( x <identifiersep> cap <identifiersep> exception ex ) <LOG> { } } <comment> @ override <ect>
{ try { if ( add <identifiersep> contact <identifiersep> to <identifiersep> polite <identifiersep> block <identifiersep> list ( contact ) ) update <identifiersep> pres <identifiersep> rules ( ) ; } catch ( x <identifiersep> cap <identifiersep> exception ex ) <LOG> { } } <comment> @ override <ect>
{ result . add ( sip <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { contact <identifiersep> id } ) ) ; result . add ( ( ( sip <identifiersep> uri ) address . get <identifiersep> uri ( ) ) . get <identifiersep> user ( ) ) ; } } catch ( exception ex ) <LOG> { result . add ( sip <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> , new string [ ] { contact <identifiersep> id } ) ) ; string user = contact <identifiersep> id ; string remainder = <string_literal> ; <ect>
public void process <identifiersep> response ( response <identifiersep> event response <identifiersep> event ) { client <identifiersep> transaction client <identifiersep> transaction = response <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; if ( client <identifiersep> transaction == null ) <LOG> { return ; } response response = response <identifiersep> event . get <identifiersep> response ( ) ; early <identifiersep> process <identifiersep> message ( response <identifiersep> event ) ; string method = ( ( c <identifiersep> seq <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> seq <identifiersep> header . name ) ) . get <identifiersep> method ( ) ; <ect>
if ( timeout <identifiersep> event . is <identifiersep> server <identifiersep> transaction ( ) ) transaction = timeout <identifiersep> event . get <identifiersep> server <identifiersep> transaction ( ) ; else transaction = timeout <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; if ( transaction == null ) <LOG> { return ; } early <identifiersep> process <identifiersep> message ( timeout <identifiersep> event ) ; request request = transaction . get <identifiersep> request ( ) ; logger . debug ( <string_literal> + request ) ; <ect>
<comment> <LOG> { + <string_literal> + method ) ; for ( method <identifiersep> processor processor : processors ) { if ( processor . process <identifiersep> timeout ( timeout <identifiersep> event ) ) { <ect>
response response = null ; try { response = this . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . bad <identifiersep> event , request ) ; } catch ( parse <identifiersep> exception e ) <LOG> { return ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; return ; <ect>
<comment> <LOG> { + <string_literal> + method ) ; for ( method <identifiersep> processor processor : processors ) { if ( processor . process <identifiersep> request ( request <identifiersep> event ) ) { <ect>
local <identifiersep> address . get <identifiersep> host <identifiersep> address ( ) , local <identifiersep> port , transport , null ) ; <LOG> via <identifiersep> headers . add ( via <identifiersep> header ) ; return via <identifiersep> headers ; } catch ( parse <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; <ect>
<comment> public listening <identifiersep> point get <identifiersep> listening <identifiersep> point ( string transport ) <LOG> { <comment> <ect>
address our <identifiersep> sip <identifiersep> address = get <identifiersep> address <identifiersep> factory ( ) . create <identifiersep> address ( get <identifiersep> our <identifiersep> display <identifiersep> name ( ) , our <identifiersep> sip <identifiersep> uri ) ; our <identifiersep> sip <identifiersep> address . set <identifiersep> display <identifiersep> name ( get <identifiersep> our <identifiersep> display <identifiersep> name ( ) ) ; return our <identifiersep> sip <identifiersep> address ; } catch ( parse <identifiersep> exception exc ) <LOG> { <comment> <ect>
{ protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl . throw <identifiersep> operation <identifiersep> failed <identifiersep> exception ( <string_literal> + request , operation <identifiersep> failed <identifiersep> exception . network <identifiersep> failure , ex , <LOG> logger ) ; } } <comment> <ect>
<comment> <LOG> { destination <identifiersep> inet <identifiersep> address = outbound <identifiersep> proxy ; } else { string transport = destination . get <identifiersep> transport <identifiersep> param ( ) ; if ( transport == null ) <ect>
listener . process <identifiersep> message ( ( request <identifiersep> event ) message ) ; else if ( message instanceof response <identifiersep> event ) listener . process <identifiersep> response ( ( response <identifiersep> event ) message , null ) ; else if ( message instanceof timeout <identifiersep> event ) listener . process <identifiersep> timeout ( ( timeout <identifiersep> event ) message , null ) ; } catch ( throwable t ) <LOG> { } } } } <comment> <ect>
sip <identifiersep> application <identifiersep> data . key <identifiersep> service ) ; if ( service instanceof protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) { protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl sip <identifiersep> provider = ( ( protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) service ) ; final proxy <identifiersep> connection connection = sip <identifiersep> provider . get <identifiersep> connection ( ) ; <LOG> final string proxy = connection . get <identifiersep> outbound <identifiersep> proxy <identifiersep> string ( ) ; boolean force <identifiersep> loose <identifiersep> routing = sip <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> account <identifiersep> property <identifiersep> boolean ( protocol <identifiersep> provider <identifiersep> factory . force <identifiersep> proxy <identifiersep> bypass , false ) ; <comment> <ect>
router <identifiersep> cache . put ( proxy , router ) ; } return router ; } <comment> <LOG> + <string_literal> ) ; return this . get <identifiersep> default <identifiersep> router ( ) ; } <comment> <ect>
<comment> <LOG> { content = new string ( req . get <identifiersep> raw <identifiersep> content ( ) ) ; } <comment> <ect>
<comment> <LOG> <comment> <ect>
logger . debug ( <string_literal> ) ; content = new string ( request <identifiersep> event . get <identifiersep> request ( ) . get <identifiersep> raw <identifiersep> content ( ) ) ; } <comment> <LOG> { return false ; } contact from = op <identifiersep> set <identifiersep> pers <identifiersep> presence . resolve <identifiersep> contact <identifiersep> id ( from <identifiersep> header . get <identifiersep> address ( ) . get <identifiersep> uri ( ) . to <identifiersep> string ( ) ) ; content <identifiersep> type <identifiersep> header ctheader = ( content <identifiersep> type <identifiersep> header ) req . get <identifiersep> header ( content <identifiersep> type <identifiersep> header . name ) ; <ect>
string content = null ; try { content = new string ( req . get <identifiersep> raw <identifiersep> content ( ) , get <identifiersep> charset ( req ) ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception exc ) <LOG> { content = new string ( req . get <identifiersep> raw <identifiersep> content ( ) ) ; } <comment> <ect>
<comment> <LOG> <comment> <ect>
response response , sip <identifiersep> provider jain <identifiersep> sip <identifiersep> provider ) throws operation <identifiersep> failed <identifiersep> exception { try <LOG> { client <identifiersep> transaction retry <identifiersep> tran = null ; <comment> <ect>
try { server <identifiersep> transaction = sip <identifiersep> stack <identifiersep> sharing . get <identifiersep> or <identifiersep> create <identifiersep> server <identifiersep> transaction ( request <identifiersep> event ) ; } catch ( exception e ) <LOG> { return false ; } if ( server <identifiersep> transaction == null ) return false ; call <identifiersep> peer <identifiersep> sip <identifiersep> impl call <identifiersep> peer = basic <identifiersep> telephony . get <identifiersep> active <identifiersep> calls <identifiersep> repository ( ) . find <identifiersep> call <identifiersep> peer ( <ect>
<comment> <comment> public void log <identifiersep> stack <identifiersep> trace ( ) <LOG> { } <comment> <ect>
<comment> public void log <identifiersep> exception ( throwable ex ) <LOG> { logger . info ( <string_literal> , ex ) ; } <comment> <ect>
<comment> public void log <identifiersep> debug ( string message ) <LOG> { } <comment> <ect>
<comment> public void log <identifiersep> error ( string message ) <LOG> { } <comment> <ect>
<comment> public void log <identifiersep> warning ( string string ) <LOG> { } <comment> <ect>
<comment> public void set <identifiersep> build <identifiersep> time <identifiersep> stamp ( string build <identifiersep> time <identifiersep> stamp ) <LOG> { } <comment> public void set <identifiersep> stack <identifiersep> properties ( properties stack <identifiersep> properties ) { } <ect>
src <identifiersep> addr , src <identifiersep> port , dst <identifiersep> addr , dst <identifiersep> port , is <identifiersep> transport <identifiersep> udp ? packet <identifiersep> logging <identifiersep> service . transport <identifiersep> name . udp : packet <identifiersep> logging <identifiersep> service . transport <identifiersep> name . tcp , sender , msg ) ; } catch ( throwable e ) <LOG> { } } <comment> <ect>
thread thread = new thread ( this , this . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; thread . set <identifiersep> daemon ( true ) ; thread . start ( ) ; if ( ! login ( username ) ) { show <identifiersep> error ( null , null , <LOG> <string_literal> ) ; return ; } } catch ( throwable t ) { logger . error ( <string_literal> ) ; } } <comment> <ect>
<comment> public void run ( ) { if ( connection == null ) <LOG> { return ; } try { connection <identifiersep> reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( connection . get <identifiersep> input <identifiersep> stream ( ) ) ) ; <ect>
return ; } string line ; while ( ( line = connection <identifiersep> reader . read <identifiersep> line ( ) ) != null || ! stopped ) { try <LOG> { handle ( ( json <identifiersep> object ) json <identifiersep> value . parse <identifiersep> with <identifiersep> exception ( line ) ) ; } catch ( throwable ex ) { logger . error ( <string_literal> + line , ex ) ; } } } catch ( io <identifiersep> exception ex ) <ect>
obj . put ( <string_literal> , username + <string_literal> + os ) ; obj . put ( <string_literal> , username ) ; obj . put ( <string_literal> , <string_literal> ) ; obj . put ( <string_literal> , <string_literal> ) ; return send ( obj ) ; } catch ( exception e ) <LOG> { return false ; } } <comment> <ect>
obj . put ( <string_literal> , capalist <identifiersep> param . get ( 0 ) ) ; obj . put ( <string_literal> , <string_literal> ) ; obj . put ( <string_literal> , <string_literal> ) ; obj . put ( <string_literal> , <string_literal> ) ; return send ( obj ) ; } catch ( exception e ) <LOG> { return false ; } } <comment> <ect>
try { obj . put ( <string_literal> , <string_literal> ) ; obj . put ( <string_literal> , <string_literal> ) ; return send ( obj ) ; } catch ( exception e ) <LOG> { return false ; } } <comment> <ect>
contact . set <identifiersep> display <identifiersep> name ( phone . get ( <string_literal> ) + <string_literal> + phone . get ( <string_literal> ) ) ; contact . set <identifiersep> resolved ( true ) ; fire <identifiersep> contact <identifiersep> resolved ( parent <identifiersep> group , contact ) ; } } catch ( throwable t ) <LOG> { } } } catch ( throwable t ) { logger . error ( <string_literal> , t ) ; } } <comment> <ect>
sip <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( message , title , popup <identifiersep> dialog . error <identifiersep> message ) ; } catch ( throwable t ) <LOG> { } } } <ect>
catch ( exception ex ) { if ( ex . get <identifiersep> cause ( ) instanceof socket <identifiersep> exception || ex . get <identifiersep> cause ( ) instanceof io <identifiersep> exception ) { if ( sip <identifiersep> provider . register <identifiersep> using <identifiersep> next <identifiersep> address ( ) ) <LOG> return ; } set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , ex . get <identifiersep> message ( ) ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> <ect>
{ logger . trace ( <string_literal> ) ; return ; } cancel <identifiersep> pending <identifiersep> registrations ( ) ; if ( this . register <identifiersep> request == null ) <LOG> { set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , <string_literal> ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> <ect>
client <identifiersep> transaction unregister <identifiersep> transaction = null ; try { unregister <identifiersep> transaction = get <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( unregister <identifiersep> request ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception ex ) <LOG> { set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , <string_literal> ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <ect>
, registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> user <identifiersep> request , null ) ; <comment> <LOG> { reg <identifiersep> trans . terminate ( ) ; logger . trace ( <string_literal> ) ; } } } catch ( sip <identifiersep> exception ex ) { <ect>
logger . trace ( <string_literal> ) ; reg <identifiersep> trans . terminate ( ) ; logger . trace ( <string_literal> ) ; } } } catch ( sip <identifiersep> exception ex ) <LOG> { set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> internal <identifiersep> error , <string_literal> ) ; throw new operation <identifiersep> failed <identifiersep> exception ( <ect>
client <identifiersep> transaction client <identifiersep> transaction , response response , sip <identifiersep> provider jain <identifiersep> sip <identifiersep> provider ) { try <LOG> { client <identifiersep> transaction retry <identifiersep> tran ; if ( response . get <identifiersep> status <identifiersep> code ( ) == response . unauthorized || response . get <identifiersep> status <identifiersep> code ( ) == response . proxy <identifiersep> authentication <identifiersep> required ) { <ect>
this . set <identifiersep> registration <identifiersep> state ( registration <identifiersep> state . authentication <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> authentication <identifiersep> failed , <string_literal> ) ; } } catch ( exception exc ) <LOG> { <comment> <ect>
desktop <identifiersep> sharing <identifiersep> call <identifiersep> sip <identifiersep> impl . dssid <identifiersep> header , ( ( desktop <identifiersep> sharing <identifiersep> call <identifiersep> sip <identifiersep> impl ) r <identifiersep> control <identifiersep> subs . call <identifiersep> peer . get <identifiersep> call ( ) ) . get <identifiersep> desktop <identifiersep> sharing <identifiersep> session <identifiersep> id ( ) ) ; req . set <identifiersep> header ( dssid <identifiersep> header ) ; } catch ( parse <identifiersep> exception ex ) <LOG> { } } } } ; } <comment> <ect>
{ exception = pce ; } catch ( sax <identifiersep> exception saxe ) { exception = saxe ; } if ( exception != null ) <LOG> { } else { element root = document . get <identifiersep> document <identifiersep> element ( ) ; list < component <identifiersep> event > events = null ; point p = get <identifiersep> origin ( ) ; <ect>
<comment> public void purge <identifiersep> locally <identifiersep> stored <identifiersep> history ( history <identifiersep> id id ) throws io <identifiersep> exception { <comment> <LOG> file dir = this . create <identifiersep> history <identifiersep> directories ( id ) ; delete <identifiersep> dir <identifiersep> and <identifiersep> content ( dir ) ; history history = histories . remove ( id ) ; if ( history == null ) { <comment> <ect>
= get <identifiersep> file <identifiersep> access <identifiersep> service ( ) . get <identifiersep> private <identifiersep> persistent <identifiersep> directory ( ( user <identifiersep> set <identifiersep> data <identifiersep> directory == null ) ? data <identifiersep> directory : user <identifiersep> set <identifiersep> data <identifiersep> directory , file <identifiersep> category . profile ) ; } catch ( exception e ) <LOG> { } return new file ( hist <identifiersep> dir , dir <identifiersep> name . to <identifiersep> string ( ) ) ; } <comment> <ect>
try { file db <identifiersep> dat <identifiersep> file = new file ( directory , history <identifiersep> service <identifiersep> impl . data <identifiersep> file ) ; db <identifiersep> struct <identifiersep> serializer dbss = new db <identifiersep> struct <identifiersep> serializer ( history <identifiersep> service <identifiersep> impl ) ; dbss . write <identifiersep> history ( db <identifiersep> dat <identifiersep> file , this ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } public history <identifiersep> reader get <identifiersep> reader ( ) { if ( this . reader == null ) { this . reader = new history <identifiersep> reader <identifiersep> impl ( this ) ; <ect>
<comment> public void start ( bundle <identifiersep> context bc ) <LOG> { this . bundle <identifiersep> context = bc ; <comment> <ect>
= provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> file <identifiersep> transfer . class ) ; if ( op <identifiersep> set <identifiersep> file <identifiersep> transfer != null ) { op <identifiersep> set <identifiersep> file <identifiersep> transfer . add <identifiersep> file <identifiersep> transfer <identifiersep> listener ( this ) ; } else <LOG> { } } <comment> <ect>
<comment> public void service <identifiersep> changed ( service <identifiersep> event service <identifiersep> event ) { <LOG> object s <identifiersep> service = bundle <identifiersep> context . get <identifiersep> service ( service <identifiersep> event . get <identifiersep> service <identifiersep> reference ( ) ) ; <comment> <ect>
{ return ; } logger . debug ( <string_literal> ) ; if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . registered ) <LOG> { this . handle <identifiersep> provider <identifiersep> added ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } else if ( service <identifiersep> event . get <identifiersep> type ( ) == service <identifiersep> event . unregistering ) { this . handle <identifiersep> provider <identifiersep> removed ( ( protocol <identifiersep> provider <identifiersep> service ) s <identifiersep> service ) ; } } <comment> <ect>
get <identifiersep> direction ( file <identifiersep> transfer . in ) , sdf . format ( event . get <identifiersep> timestamp ( ) ) , file <identifiersep> transfer <identifiersep> active , req . get <identifiersep> id ( ) } ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } <comment> public void file <identifiersep> transfer <identifiersep> created ( file <identifiersep> transfer <identifiersep> created <identifiersep> event event ) <ect>
structure <identifiersep> names [ <number_literal> ] , req . get <identifiersep> id ( ) , structure <identifiersep> names [ <number_literal> ] , file <identifiersep> record . refused ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } public void file <identifiersep> transfer <identifiersep> request <identifiersep> canceled ( file <identifiersep> transfer <identifiersep> request <identifiersep> event event ) { try { incoming <identifiersep> file <identifiersep> transfer <identifiersep> request req = event . get <identifiersep> request ( ) ; <ect>
file <identifiersep> history <identifiersep> service . set <identifiersep> history <identifiersep> service ( history <identifiersep> service ) ; file <identifiersep> history <identifiersep> service . start ( bundle <identifiersep> context ) ; bundle <identifiersep> context . register <identifiersep> service ( file <identifiersep> history <identifiersep> service . class . get <identifiersep> name ( ) , file <identifiersep> history <identifiersep> service , <LOG> null ) ; } finally { logger . log <identifiersep> exit ( ) ; } } <comment> <ect>
bundle <identifiersep> context . add <identifiersep> service <identifiersep> listener ( new service <identifiersep> listener ( ) { public void service <identifiersep> changed ( service <identifiersep> event service <identifiersep> event ) { global <identifiersep> shortcut <identifiersep> activator . this . service <identifiersep> changed ( service <identifiersep> event ) ; } <LOG> } ) ; } <comment> <ect>
<comment> public void test ( ) { global <identifiersep> shortcut <identifiersep> listener l = new global <identifiersep> shortcut <identifiersep> listener ( ) { public void shortcut <identifiersep> received ( global <identifiersep> shortcut <identifiersep> event evt ) <LOG> { } } ; awt <identifiersep> key <identifiersep> stroke ks = awt <identifiersep> key <identifiersep> stroke . get <identifiersep> awt <identifiersep> key <identifiersep> stroke ( <string_literal> ) ; awt <identifiersep> key <identifiersep> stroke ks2 = awt <identifiersep> key <identifiersep> stroke . get <identifiersep> awt <identifiersep> key <identifiersep> stroke ( <string_literal> ) ; if ( ks == null ) { <ect>
system . out . println ( <string_literal> ) ; } } ; awt <identifiersep> key <identifiersep> stroke ks = awt <identifiersep> key <identifiersep> stroke . get <identifiersep> awt <identifiersep> key <identifiersep> stroke ( <string_literal> ) ; awt <identifiersep> key <identifiersep> stroke ks2 = awt <identifiersep> key <identifiersep> stroke . get <identifiersep> awt <identifiersep> key <identifiersep> stroke ( <string_literal> ) ; if ( ks == null ) { <LOG> logger . info ( <string_literal> ) ; return ; } this . register <identifiersep> shortcut ( l , ks ) ; this . register <identifiersep> shortcut ( l , ks2 ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } this . unregister <identifiersep> shortcut ( l , ks ) ; <ect>
this . unregister <identifiersep> shortcut ( l , ks ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } this . unregister <identifiersep> shortcut ( l , ks2 ) ; <comment> <LOG> system . out . println ( <string_literal> + ret ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } system . out . println ( <string_literal> ) ; keyboard <identifiersep> hook . unregister <identifiersep> shortcut ( ks . get <identifiersep> key <identifiersep> code ( ) , get <identifiersep> modifiers ( ks ) ) ; system . out . println ( <string_literal> ) ; <ect>
get <identifiersep> modifiers ( ks ) ) ; system . out . println ( <string_literal> + ret ) ; system . out . println ( <string_literal> ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { } system . out . println ( <string_literal> ) ; keyboard <identifiersep> hook . unregister <identifiersep> shortcut ( ks . get <identifiersep> key <identifiersep> code ( ) , <LOG> <comment> } } <ect>
. set <identifiersep> property ( recorder . saved <identifiersep> calls <identifiersep> path , saved <identifiersep> calls <identifiersep> dir ) ; logger . debug ( <string_literal> + saved <identifiersep> calls <identifiersep> dir ) ; return true ; } else <LOG> { return false ; } } <comment> <ect>
<comment> <LOG> null ) ; media <identifiersep> configuration = new media <identifiersep> configuration <identifiersep> impl ( ) ; bundle <identifiersep> context . register <identifiersep> service ( media <identifiersep> configuration <identifiersep> service . class . get <identifiersep> name ( ) , get <identifiersep> media <identifiersep> configuration ( ) , <ect>
+ <string_literal> , true ) ) ; bundle <identifiersep> context . register <identifiersep> service ( audio <identifiersep> notifier <identifiersep> service . class . get <identifiersep> name ( ) , audio <identifiersep> notifier <identifiersep> service , <LOG> null ) ; <comment> <ect>
{ presence . publish <identifiersep> presence <identifiersep> status ( status , <string_literal> ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e1 ) { logger . error ( <string_literal> , e1 ) ; } catch ( illegal <identifiersep> state <identifiersep> exception e1 ) <LOG> { } catch ( operation <identifiersep> failed <identifiersep> exception e1 ) { if ( e1 . get <identifiersep> error <identifiersep> code ( ) == operation <identifiersep> failed <identifiersep> exception . general <identifiersep> error ) { <ect>
bundle <identifiersep> context = bc ; set <identifiersep> name ( get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; <comment> <LOG> tests = <string_literal> ; } string <identifiersep> tokenizer st = new string <identifiersep> tokenizer ( tests ) ; string [ ] ids = new string [ st . count <identifiersep> tokens ( ) ] ; int n = 0 ; while ( st . has <identifiersep> more <identifiersep> tokens ( ) ) { <ect>
@ override public test <identifiersep> suite <identifiersep> loader get <identifiersep> loader ( ) { return new standard <identifiersep> test <identifiersep> suite <identifiersep> loader ( ) ; } @ override public void test <identifiersep> failed ( int status , test test , throwable t ) <LOG> { } @ override public void test <identifiersep> started ( string test <identifiersep> name ) { logger . debug ( <string_literal> + test <identifiersep> name ) ; } @ override <ect>
@ override public void test <identifiersep> started ( string test <identifiersep> name ) { logger . debug ( <string_literal> + test <identifiersep> name ) ; } @ override public void test <identifiersep> ended ( string test <identifiersep> name ) <LOG> { } <comment> protected test <identifiersep> result create <identifiersep> test <identifiersep> result ( ) { <ect>
network <identifiersep> address <identifiersep> manager <identifiersep> service <identifiersep> lick . bc = bundle <identifiersep> context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; <comment> <LOG> bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; } <comment> <ect>
mock <identifiersep> prov <identifiersep> properties . put ( meta <identifiersep> contact <identifiersep> list <identifiersep> service . provider <identifiersep> mask <identifiersep> property , <string_literal> ) ; mock <identifiersep> pr <identifiersep> service <identifiersep> registration = msg <identifiersep> history <identifiersep> service <identifiersep> lick . bc . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , mock <identifiersep> provider , <LOG> mock <identifiersep> prov <identifiersep> properties ) ; test <identifiersep> meta <identifiersep> contact = meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) . get <identifiersep> meta <identifiersep> contact ( mock <identifiersep> provider , test <identifiersep> contact <identifiersep> name <identifiersep> 1 ) ; <comment> <ect>
logger . info ( <string_literal> + control <identifiersep> date1 . get <identifiersep> time ( ) ) ; wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ 1 ] ) ; wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; <LOG> test <identifiersep> msg <identifiersep> history <identifiersep> service <identifiersep> multi <identifiersep> chat . control <identifiersep> date2 = new date ( ) ; wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; room . send <identifiersep> message ( messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; <ect>
catch ( operation <identifiersep> failed <identifiersep> exception ex ) { fail ( <string_literal> + ex . get <identifiersep> message ( ) ) ; logger . error ( <string_literal> , ex ) ; } catch ( operation <identifiersep> not <identifiersep> supported <identifiersep> exception ex ) { <LOG> fail ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } } <comment> public void read <identifiersep> records <identifiersep> from <identifiersep> multi <identifiersep> chat ( ) { <ect>
mock <identifiersep> prov <identifiersep> properties . put ( meta <identifiersep> contact <identifiersep> list <identifiersep> service . provider <identifiersep> mask <identifiersep> property , <string_literal> ) ; mock <identifiersep> pr <identifiersep> service <identifiersep> registration = msg <identifiersep> history <identifiersep> service <identifiersep> lick . bc . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , mock <identifiersep> provider , <LOG> mock <identifiersep> prov <identifiersep> properties ) ; test <identifiersep> meta <identifiersep> contact = meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) . get <identifiersep> meta <identifiersep> contact ( mock <identifiersep> provider , test <identifiersep> contact <identifiersep> name <identifiersep> 1 ) ; <comment> <ect>
logger . info ( <string_literal> ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , test <identifiersep> meta <identifiersep> contact ) ; <comment> <LOG> test <identifiersep> msg <identifiersep> history <identifiersep> service . control <identifiersep> date1 = new date ( ) ; wait <identifiersep> write ( <number_literal> ) ; mock <identifiersep> b <identifiersep> im <identifiersep> op <identifiersep> set . deliver <identifiersep> message ( test <identifiersep> contact <identifiersep> name <identifiersep> 1 , messages <identifiersep> to <identifiersep> send [ 1 ] ) ; mock <identifiersep> b <identifiersep> im <identifiersep> op <identifiersep> set . deliver <identifiersep> message ( test <identifiersep> contact <identifiersep> name <identifiersep> <number_literal> , messages <identifiersep> to <identifiersep> send [ <number_literal> ] ) ; wait <identifiersep> write ( <number_literal> ) ; test <identifiersep> msg <identifiersep> history <identifiersep> service . control <identifiersep> date2 = new date ( ) ; <ect>
get <identifiersep> message ( ) . get <identifiersep> content ( ) ) ; } return result ; } <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
mock <identifiersep> prov <identifiersep> properties . put ( meta <identifiersep> contact <identifiersep> list <identifiersep> service . provider <identifiersep> mask <identifiersep> property , <string_literal> ) ; mock <identifiersep> pr <identifiersep> service <identifiersep> registration = call <identifiersep> history <identifiersep> service <identifiersep> lick . bc . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , mock <identifiersep> provider , <LOG> mock <identifiersep> prov <identifiersep> properties ) ; call <identifiersep> history <identifiersep> service <identifiersep> ref = call <identifiersep> history <identifiersep> service <identifiersep> lick . bc . get <identifiersep> service <identifiersep> reference ( call <identifiersep> history <identifiersep> service . class . get <identifiersep> name ( ) ) ; call <identifiersep> history <identifiersep> service = ( call <identifiersep> history <identifiersep> service ) call <identifiersep> history <identifiersep> service <identifiersep> lick . bc . <ect>
iter = v . iterator ( ) ; while ( iter . has <identifiersep> next ( ) ) { call <identifiersep> peer item = iter . next ( ) ; mock <identifiersep> b <identifiersep> telphony <identifiersep> op <identifiersep> set . hangup <identifiersep> call <identifiersep> peer ( item ) ; } } catch ( exception ex1 ) <LOG> { fail ( <string_literal> + participant ) ; } } private void wait <identifiersep> seconds ( long secs ) { object lock = new object ( ) ; synchronized ( lock ) { <ect>
iter = v . iterator ( ) ; while ( iter . has <identifiersep> next ( ) ) { call <identifiersep> peer item = iter . next ( ) ; mock <identifiersep> b <identifiersep> telphony <identifiersep> op <identifiersep> set . hangup <identifiersep> call <identifiersep> peer ( item ) ; } } catch ( exception ex1 ) <LOG> { fail ( <string_literal> ) ; } collection < call <identifiersep> record > last <identifiersep> call = call <identifiersep> history <identifiersep> service . find <identifiersep> last ( 1 ) ; assert <identifiersep> equals ( <string_literal> , 1 , last <identifiersep> call . size ( ) ) ; call <identifiersep> record call <identifiersep> record = last <identifiersep> call . iterator ( ) . next ( ) ; assert <identifiersep> equals ( <string_literal> , <ect>
add <identifiersep> test ( test <identifiersep> support <identifiersep> for <identifiersep> multiple <identifiersep> providers . suite ( ) ) ; <comment> <LOG> , slick <identifiersep> service <identifiersep> properties ) ; } <comment> <ect>
<comment> public void test <identifiersep> contact <identifiersep> list <identifiersep> retrieving ( ) { mock <identifiersep> contact <identifiersep> group expected <identifiersep> root = ( mock <identifiersep> contact <identifiersep> group ) <LOG> mcl <identifiersep> slick <identifiersep> fixture . mock <identifiersep> pres <identifiersep> op <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . info ( <string_literal> + expected <identifiersep> root . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> contacts ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> subgroups ( ) + <string_literal> + expected <identifiersep> root . to <identifiersep> string ( ) ) ; meta <identifiersep> contact <identifiersep> group actual <identifiersep> root = fixture . meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) ; <ect>
mcl <identifiersep> slick <identifiersep> fixture . mock <identifiersep> pres <identifiersep> op <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . info ( <string_literal> ) ; logger . info ( <string_literal> + expected <identifiersep> root . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> contacts ( ) + <string_literal> + expected <identifiersep> root . count <identifiersep> subgroups ( ) + <string_literal> + expected <identifiersep> root . to <identifiersep> string ( ) ) ; <LOG> meta <identifiersep> contact <identifiersep> group actual <identifiersep> root = fixture . meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) ; logger . info ( <string_literal> + actual <identifiersep> root . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + actual <identifiersep> root . count <identifiersep> child <identifiersep> contacts ( ) + <string_literal> + actual <identifiersep> root . count <identifiersep> subgroups ( ) + <string_literal> + actual <identifiersep> root . to <identifiersep> string ( ) ) ; mcl <identifiersep> slick <identifiersep> fixture . assert <identifiersep> group <identifiersep> equals ( expected <identifiersep> root , actual <identifiersep> root <ect>
set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test <identifiersep> suite ( test <identifiersep> configuration <identifiersep> service . class ) ; <comment> <LOG> bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; } <comment> <ect>
private static logger logger = logger . get <identifiersep> logger ( popup <identifiersep> message <identifiersep> handler <identifiersep> s <identifiersep> lick . class ) ; <comment> protected static bundle <identifiersep> context bundle <identifiersep> context = null ; <comment> public void start ( bundle <identifiersep> context bc ) throws exception <LOG> { bundle <identifiersep> context = bc ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; <comment> <ect>
{ logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + evt . get <identifiersep> source <identifiersep> message ( ) . get <identifiersep> content ( ) ) ; message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <LOG> <string_literal> ) ; return new message <identifiersep> delivered <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) ; } public message <identifiersep> delivery <identifiersep> failed <identifiersep> event message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { <ect>
{ logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + evt . get <identifiersep> source <identifiersep> message ( ) . get <identifiersep> content ( ) ) ; message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <LOG> <string_literal> ) ; return new message <identifiersep> delivery <identifiersep> failed <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> error <identifiersep> code ( ) ) ; } public message <identifiersep> delivered <identifiersep> event [ ] message <identifiersep> delivery <identifiersep> pending ( message <identifiersep> delivered <identifiersep> event evt ) { <ect>
{ logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + evt . get <identifiersep> source <identifiersep> message ( ) . get <identifiersep> content ( ) ) ; message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <LOG> <string_literal> ) ; return new message <identifiersep> delivered <identifiersep> event [ ] { new message <identifiersep> delivered <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> destination <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) } ; } public message <identifiersep> received <identifiersep> event message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) { <ect>
{ logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + evt . get <identifiersep> source <identifiersep> message ( ) . get <identifiersep> content ( ) ) ; message transformed <identifiersep> message = create <identifiersep> message ( evt . get <identifiersep> source <identifiersep> contact ( ) , evt . get <identifiersep> source <identifiersep> message ( ) , <LOG> <string_literal> ) ; return new message <identifiersep> received <identifiersep> event ( transformed <identifiersep> message , evt . get <identifiersep> source <identifiersep> contact ( ) , evt . get <identifiersep> timestamp ( ) ) ; } private message create <identifiersep> message ( contact contact , message message , string action ) { <ect>
ft <identifiersep> op <identifiersep> set1 . remove <identifiersep> file <identifiersep> transfer <identifiersep> listener ( sender <identifiersep> ft <identifiersep> listerner ) ; ft <identifiersep> op <identifiersep> set2 . add <identifiersep> file <identifiersep> transfer <identifiersep> listener ( receiver <identifiersep> ft <identifiersep> listerner ) ; } } public void test <identifiersep> receiver <identifiersep> decline ( ) throws exception { if ( ! enable <identifiersep> test <identifiersep> receiver <identifiersep> decline ( ) ) <LOG> return ; file file <identifiersep> to <identifiersep> transfer = get <identifiersep> temp <identifiersep> file <identifiersep> to <identifiersep> transfer ( <number_literal> ) ; operation <identifiersep> set <identifiersep> file <identifiersep> transfer ft <identifiersep> op <identifiersep> set1 = get <identifiersep> op <identifiersep> set <identifiersep> fil <identifiersep> transfer1 ( ) ; operation <identifiersep> set <identifiersep> file <identifiersep> transfer ft <identifiersep> op <identifiersep> set2 = get <identifiersep> op <identifiersep> set <identifiersep> fil <identifiersep> transfer2 ( ) ; file <identifiersep> transfer <identifiersep> status <identifiersep> event <identifiersep> collector sender <identifiersep> status <identifiersep> listener = new file <identifiersep> transfer <identifiersep> status <identifiersep> event <identifiersep> collector ( <string_literal> ) ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { logger . trace ( <string_literal> ) ; synchronized ( this ) { <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) { return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <ect>
logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <LOG> else } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
{ this . events <identifiersep> num = events <identifiersep> num ; logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > ( events <identifiersep> num - 1 ) ) <LOG> { return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > ( events <identifiersep> num - 1 ) ) <ect>
{ op <identifiersep> set <identifiersep> presence3 . set <identifiersep> authorization <identifiersep> handler ( new auth <identifiersep> handler ( ) ) ; op <identifiersep> set <identifiersep> presence3 . subscribe ( fixture . user <identifiersep> id1 ) ; op <identifiersep> set <identifiersep> presence3 . subscribe ( fixture . user <identifiersep> id2 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> <comment> <ect>
<comment> public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
op <identifiersep> set <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> info . get <identifiersep> details ( tester <identifiersep> agent <identifiersep> contact , server <identifiersep> stored <identifiersep> details . country <identifiersep> detail . class ) ; while ( iter . has <identifiersep> next ( ) ) { server <identifiersep> stored <identifiersep> details . country <identifiersep> detail item <LOG> = ( server <identifiersep> stored <identifiersep> details . country <identifiersep> detail ) iter . next ( ) ; assert <identifiersep> equals ( <string_literal> , item . get <identifiersep> locale ( ) , new locale ( <string_literal> , country <identifiersep> abr ) ) ; break ; } } <comment> <ect>
<string_literal> , ex ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { throw new runtime <identifiersep> exception ( <string_literal> , ex ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { throw new runtime <identifiersep> exception ( <string_literal> , ex ) ; } catch ( class <identifiersep> cast <identifiersep> exception ex ) { throw new runtime <identifiersep> exception ( <ect>
{ } } iter = op <identifiersep> set <identifiersep> server <identifiersep> stored <identifiersep> account <identifiersep> info . get <identifiersep> details ( server <identifiersep> stored <identifiersep> details . spoken <identifiersep> language <identifiersep> detail . class ) ; list < generic <identifiersep> detail > languages = new array <identifiersep> list < generic <identifiersep> detail > ( ) ; while ( iter . has <identifiersep> next ( ) ) <LOG> languages . add ( iter . next ( ) ) ; <comment> <ect>
default <identifiersep> values . set <identifiersep> password ( password . to <identifiersep> char <identifiersep> array ( ) ) ; return default <identifiersep> values ; } public void set <identifiersep> user <identifiersep> name <identifiersep> editable ( boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ) { } public boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ( ) { return false ; } } ) ; synchronized ( registration <identifiersep> lock ) <LOG> { registration <identifiersep> lock . wait ( <number_literal> ) ; logger . info ( <string_literal> ) ; } fixture . provider . add <identifiersep> registration <identifiersep> state <identifiersep> change <identifiersep> listener ( new registration <identifiersep> state <identifiersep> change <identifiersep> listener ( ) { public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { <ect>
{ prepare <identifiersep> contact <identifiersep> list ( ) ; synchronized ( registration <identifiersep> lock ) { registration <identifiersep> lock . notify <identifiersep> all ( ) ; } } catch ( exception e ) <LOG> { } } } } ) ; fixture . provider . register ( new security <identifiersep> authority ( ) { public user <identifiersep> credentials obtain <identifiersep> credentials ( string realm , user <identifiersep> credentials default <identifiersep> values , int reason <identifiersep> code ) { <ect>
new get <identifiersep> info <identifiersep> cmd ( get <identifiersep> info <identifiersep> cmd . cmd <identifiersep> new <identifiersep> get <identifiersep> info | get <identifiersep> info <identifiersep> cmd . flag <identifiersep> awaymsg | get <identifiersep> info <identifiersep> cmd . flag <identifiersep> info , new screenname ( screenname ) . get <identifiersep> formatted ( ) ) ; conn . get <identifiersep> info <identifiersep> service ( ) . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac <identifiersep> request ( get <identifiersep> info <identifiersep> cmd , response <identifiersep> retriever ) ; synchronized ( response <identifiersep> retriever . waiting <identifiersep> for <identifiersep> response <identifiersep> lock ) { <LOG> try { response <identifiersep> retriever . waiting <identifiersep> for <identifiersep> response <identifiersep> lock . wait ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } logger . debug ( <string_literal> + response <identifiersep> retriever . status ) ; return response <identifiersep> retriever . status == null <ect>
synchronized ( response <identifiersep> retriever . waiting <identifiersep> for <identifiersep> response <identifiersep> lock ) { try { logger . debug ( <string_literal> + screenname ) ; response <identifiersep> retriever . waiting <identifiersep> for <identifiersep> response <identifiersep> lock . wait ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> logger . debug ( <string_literal> , ex ) ; } } return response <identifiersep> retriever . status == null ? icq <identifiersep> status <identifiersep> enum . offline : response <identifiersep> retriever . status ; } <comment> <ect>
system . out . println ( <string_literal> + e <identifiersep> info <identifiersep> blocks . size ( ) + <string_literal> ) ; for ( extra <identifiersep> info <identifiersep> block block : e <identifiersep> info <identifiersep> blocks ) { system . out . println ( <string_literal> + block . to <identifiersep> string ( ) ) ; } } <LOG> else synchronized ( waiting <identifiersep> for <identifiersep> response <identifiersep> lock ) { waiting <identifiersep> for <identifiersep> response <identifiersep> lock . notify <identifiersep> all ( ) ; } } } else if ( snac instanceof snac <identifiersep> error ) { <comment> <ect>
<comment> <LOG> try { bos <identifiersep> event <identifiersep> notifier . info <identifiersep> lock . wait ( <number_literal> ) ; } conn . get <identifiersep> bos <identifiersep> service ( ) . remove <identifiersep> main <identifiersep> bos <identifiersep> service <identifiersep> listener ( bos <identifiersep> event <identifiersep> notifier ) ; if ( bos <identifiersep> event <identifiersep> notifier . last <identifiersep> user <identifiersep> info == null ) { logger . debug ( <string_literal> ) ; return false ; } return true ; <ect>
public full <identifiersep> user <identifiersep> info last <identifiersep> user <identifiersep> info = null ; <comment> public void handle <identifiersep> your <identifiersep> extra <identifiersep> info ( list < extra <identifiersep> info <identifiersep> block > extra <identifiersep> infos ) <LOG> { synchronized ( extra <identifiersep> info <identifiersep> lock ) { extra <identifiersep> info <identifiersep> lock . notify <identifiersep> all ( ) ; } } <comment> <ect>
{ synchronized ( this . added <identifiersep> buddies ) { if ( ! added <identifiersep> buddies . is <identifiersep> empty ( ) ) { return ; } try { this . added <identifiersep> buddies . wait ( milliseconds ) ; } <LOG> catch ( interrupted <identifiersep> exception ex ) { } } } <comment> <ect>
{ return ; } try { this . removed <identifiersep> buddies . wait ( milliseconds ) ; } catch ( interrupted <identifiersep> exception ex ) <LOG> { } } } <comment> <ect>
<comment> public void buddy <identifiersep> added ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> items , list < ? extends buddy > new <identifiersep> items , buddy buddy ) <LOG> { + <string_literal> + group . get <identifiersep> name ( ) ) ; synchronized ( this . added <identifiersep> buddies ) { this . added <identifiersep> buddies . add ( buddy ) ; this . added <identifiersep> buddies . notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> <LOG> { } <comment> <ect>
{ logger . debug ( <string_literal> + buddy ) ; } <comment> <LOG> { } } <comment> <ect>
+ <string_literal> + info . get <identifiersep> icq <identifiersep> status ( ) ) ; list < extra <identifiersep> info <identifiersep> block > e <identifiersep> info <identifiersep> blocks = info . get <identifiersep> extra <identifiersep> info <identifiersep> blocks ( ) ; if ( e <identifiersep> info <identifiersep> blocks != null ) { system . out . println ( <string_literal> + e <identifiersep> info <identifiersep> blocks . size ( ) + <string_literal> ) ; <LOG> for ( extra <identifiersep> info <identifiersep> block block : e <identifiersep> info <identifiersep> blocks ) } else logger . trace ( <string_literal> ) ; } public void buddy <identifiersep> offline ( buddy <identifiersep> service service , screenname buddy ) { system . out . println ( <string_literal> + buddy . to <identifiersep> string ( ) ) ; <ect>
+ e <identifiersep> info <identifiersep> blocks . size ( ) + <string_literal> ) ; for ( extra <identifiersep> info <identifiersep> block block : e <identifiersep> info <identifiersep> blocks ) system . out . println ( <string_literal> + block ) ; } else logger . trace ( <string_literal> ) ; } public void buddy <identifiersep> offline ( buddy <identifiersep> service service , screenname buddy ) <LOG> { } } private class global <identifiersep> buddy <identifiersep> listener implements global <identifiersep> buddy <identifiersep> info <identifiersep> listener { public void buddy <identifiersep> info <identifiersep> changed ( buddy <identifiersep> info <identifiersep> manager manager , screenname buddy , buddy <identifiersep> info info , property <identifiersep> change <identifiersep> event event ) { <ect>
buddy <identifiersep> info info ) { system . out . println ( <string_literal> + buddy . to <identifiersep> string ( ) + <string_literal> + info . is <identifiersep> online ( ) + <string_literal> + info . get <identifiersep> status <identifiersep> message ( ) <LOG> + <string_literal> + info . get <identifiersep> away <identifiersep> message ( ) ) ; } public void received <identifiersep> status <identifiersep> update ( buddy <identifiersep> info <identifiersep> manager manager , screenname buddy , buddy <identifiersep> info info ) { system . out . println ( <string_literal> + buddy . to <identifiersep> string ( ) <ect>
private class retro <identifiersep> listener implements buddy <identifiersep> list <identifiersep> layout <identifiersep> listener , group <identifiersep> listener { public void groups <identifiersep> reordered ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> order , list < ? extends group > new <identifiersep> order ) <LOG> { } public void group <identifiersep> added ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group , list < ? extends buddy > buddies ) <ect>
public void group <identifiersep> added ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group , list < ? extends buddy > buddies ) { <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + new <identifiersep> items . index <identifiersep> of ( group ) ) ; for ( int i = 0 ; i < buddies . size ( ) ; i ++ ) { system . out . println ( <string_literal> + buddies . get ( i ) . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) ) ; <ect>
new buddy <identifiersep> info <identifiersep> tracker <identifiersep> listener ( ) { } ) ; } group . add <identifiersep> group <identifiersep> listener ( this ) ; } public void group <identifiersep> removed ( buddy <identifiersep> list list , list < ? extends group > old <identifiersep> items , list < ? extends group > new <identifiersep> items , group group ) <LOG> { } public void buddy <identifiersep> added ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> items , list < ? extends buddy > new <identifiersep> items , buddy buddy ) <ect>
system . out . println ( <string_literal> + buddy ) ; } public void buddy <identifiersep> removed ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> items , list < ? extends buddy > new <identifiersep> items , buddy buddy ) <LOG> { } public void buddies <identifiersep> reordered ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> buddies , list < ? extends buddy > new <identifiersep> buddies ) { <ect>
{ list < ? extends buddy > buddies = group . get <identifiersep> buddies <identifiersep> copy ( ) ; for ( buddy buddy : buddies ) { if ( buddy . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) . equals ( <string_literal> ) ) moved <identifiersep> buddy = buddy ; } } <LOG> if ( buddy <identifiersep> to <identifiersep> move == moved <identifiersep> buddy ) } public void delete <identifiersep> buddy ( string screenname ) { logger . debug ( <string_literal> + screenname ) ; mutable <identifiersep> buddy <identifiersep> list joust <identifiersep> sim <identifiersep> buddy <identifiersep> list = conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; <ect>
if ( is <identifiersep> deleted ) break ; } if ( is <identifiersep> deleted ) evt <identifiersep> collector . wait <identifiersep> for <identifiersep> removed <identifiersep> buddy ( <number_literal> ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . remove <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; } public void add <identifiersep> buddy ( string screenname ) <LOG> { mutable <identifiersep> buddy <identifiersep> list joust <identifiersep> sim <identifiersep> buddy <identifiersep> list = conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; list < ? extends group > gr <identifiersep> list = joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . get <identifiersep> groups ( ) ; iterator < ? extends group > iter = gr <identifiersep> list . iterator ( ) ; while ( iter . has <identifiersep> next ( ) ) <ect>
mutable <identifiersep> group item = ( mutable <identifiersep> group ) iter . next ( ) ; logger . debug ( <string_literal> + item ) ; list < ? extends buddy > bs = item . get <identifiersep> buddies <identifiersep> copy ( ) ; iterator < ? extends buddy > iter1 = bs . iterator ( ) ; while ( iter1 . has <identifiersep> next ( ) ) { <LOG> object b = iter1 . next ( ) ; } } mutable <identifiersep> group target <identifiersep> group = null ; if ( gr <identifiersep> list . size ( ) < 1 ) { logger . debug ( <string_literal> ) ; layout <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new layout <identifiersep> event <identifiersep> collector ( ) ; <ect>
logger . debug ( <string_literal> + b ) ; } } mutable <identifiersep> group target <identifiersep> group = null ; if ( gr <identifiersep> list . size ( ) < 1 ) { logger . debug ( <string_literal> ) ; layout <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new layout <identifiersep> event <identifiersep> collector ( ) ; <LOG> string group <identifiersep> name = <string_literal> ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> group ( group <identifiersep> name ) ; <comment> <ect>
ssi <identifiersep> item buddy <identifiersep> item = items . get ( i ) ; string uin <identifiersep> to <identifiersep> ask <identifiersep> for <identifiersep> auth = buddy <identifiersep> item . get <identifiersep> name ( ) ; vector < ssi <identifiersep> item > buddies <identifiersep> to <identifiersep> be <identifiersep> added = new vector < ssi <identifiersep> item > ( ) ; buddy <identifiersep> awaiting <identifiersep> auth new <identifiersep> buddy = new buddy <identifiersep> awaiting <identifiersep> auth ( buddy <identifiersep> item ) ; buddies <identifiersep> to <identifiersep> be <identifiersep> added . add ( new <identifiersep> buddy ) ; <LOG> create <identifiersep> items <identifiersep> cmd add <identifiersep> cmd = new create <identifiersep> items <identifiersep> cmd ( buddies <identifiersep> to <identifiersep> be <identifiersep> added ) ; mutable <identifiersep> buddy <identifiersep> list joust <identifiersep> sim <identifiersep> buddy <identifiersep> list = conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; layout <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new layout <identifiersep> event <identifiersep> collector ( ) ; joust <identifiersep> sim <identifiersep> buddy <identifiersep> list . add <identifiersep> layout <identifiersep> listener ( evt <identifiersep> collector ) ; conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> oscar <identifiersep> connection ( ) . send <identifiersep> snac ( add <identifiersep> cmd ) ; <ect>
{ reason = <string_literal> ; } byte [ ] reason <identifiersep> bytes = binary <identifiersep> tools . get <identifiersep> ascii <identifiersep> bytes ( reason ) ; binary <identifiersep> tools . write <identifiersep> u <identifiersep> short ( out , reason <identifiersep> bytes . length ) ; out . write ( reason <identifiersep> bytes ) ; } } public void set <identifiersep> authorization <identifiersep> required ( ) <LOG> { full <identifiersep> user <identifiersep> info <identifiersep> cmd cmd = new full <identifiersep> user <identifiersep> info <identifiersep> cmd ( get <identifiersep> icq <identifiersep> uin ( ) ) ; cmd . write <identifiersep> out <identifiersep> byte ( 0x030c , 0 ) ; <comment> <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group <LOG> = op <identifiersep> set <identifiersep> pers <identifiersep> presence . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list <ect>
logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list <LOG> = icq <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; logger . debug ( expected <identifiersep> contact <identifiersep> list ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> persistent <identifiersep> unsubscribe ( ) throws exception <LOG> { <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> remove <identifiersep> group ( ) <LOG> { <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> rename <identifiersep> group ( ) <LOG> { contact <identifiersep> group group = op <identifiersep> set <identifiersep> pers <identifiersep> presence . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( test <identifiersep> group <identifiersep> name ) ; <comment> <ect>
<comment> public void group <identifiersep> created ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> removed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; <ect>
if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
string message = hostname + <string_literal> + system . get <identifiersep> property ( <string_literal> ) + <string_literal> + new date ( ) . to <identifiersep> string ( ) + <string_literal> ; <LOG> string list = system . get <identifiersep> property ( <string_literal> ) ; <comment> <ect>
public void subtest <identifiersep> state <identifiersep> transition ( icq <identifiersep> status <identifiersep> enum new <identifiersep> status ) throws exception { logger . trace ( <string_literal> ) ; presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = operation <identifiersep> set <identifiersep> presence . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; <LOG> string new <identifiersep> status <identifiersep> message = status <identifiersep> message <identifiersep> root + new <identifiersep> status ; + <string_literal> + new <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) ) ; <comment> <ect>
( ( property <identifiersep> change <identifiersep> event ) status <identifiersep> event <identifiersep> collector . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . get ( 0 ) ) . get <identifiersep> new <identifiersep> value ( ) ) ; <comment> <LOG> operation <identifiersep> set <identifiersep> presence . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ) ; <comment> <ect>
<comment> public void test <identifiersep> query <identifiersep> contact <identifiersep> status ( ) throws exception { <LOG> <comment> <ect>
pause <identifiersep> between <identifiersep> state <identifiersep> changes ( ) ; <comment> <LOG> <comment> <ect>
pause <identifiersep> between <identifiersep> state <identifiersep> changes ( ) ; <comment> <LOG> <comment> <ect>
pause <identifiersep> between <identifiersep> state <identifiersep> changes ( ) ; <comment> <LOG> <comment> <ect>
public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception { logger . debug ( <string_literal> ) ; <comment> <LOG> = new subscription <identifiersep> event <identifiersep> collector ( ) ; operation <identifiersep> set <identifiersep> presence . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector ) ; synchronized ( auth <identifiersep> event <identifiersep> collector ) { auth <identifiersep> event <identifiersep> collector . authorization <identifiersep> request <identifiersep> reason = <string_literal> ; <ect>
logger . debug ( <string_literal> + c + <string_literal> + c . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) ) ; unsubscribe <identifiersep> wait unsubscribe <identifiersep> evt <identifiersep> collector = new unsubscribe <identifiersep> wait ( ) ; operation <identifiersep> set <identifiersep> presence . add <identifiersep> subscription <identifiersep> listener ( unsubscribe <identifiersep> evt <identifiersep> collector ) ; synchronized ( unsubscribe <identifiersep> evt <identifiersep> collector ) { <LOG> operation <identifiersep> set <identifiersep> presence . unsubscribe ( c ) ; unsubscribe <identifiersep> evt <identifiersep> collector . wait <identifiersep> for <identifiersep> unsubscribre ( <number_literal> ) ; logger . debug ( <string_literal> ) ; <comment> <ect>
) ; <comment> <LOG> { obj . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } sub <identifiersep> evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; <comment> <ect>
src <identifiersep> contact . get <identifiersep> address ( ) ) ; assert <identifiersep> same ( <string_literal> , fixture . provider , src <identifiersep> provider ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . clear ( ) ; <comment> <LOG> <comment> <ect>
icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . response <identifiersep> reason <identifiersep> str , icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . accept ) ; object obj = new object ( ) ; synchronized ( obj ) { logger . debug ( <string_literal> ) ; <LOG> obj . wait ( <number_literal> ) ; } tester <identifiersep> agent <identifiersep> old <identifiersep> status = icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> presnece <identifiersep> status ( ) ; tester <identifiersep> agent <identifiersep> new <identifiersep> status <identifiersep> long = full <identifiersep> user <identifiersep> info . icqstatus <identifiersep> ffc ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> unsubscribe ( ) throws exception <LOG> { <comment> <ect>
{ public array <identifiersep> list < event <identifiersep> object > collected <identifiersep> pres <identifiersep> events = new array <identifiersep> list < event <identifiersep> object > ( ) ; public array <identifiersep> list < event <identifiersep> object > collected <identifiersep> stat <identifiersep> msg <identifiersep> events = new array <identifiersep> list < event <identifiersep> object > ( ) ; public void provider <identifiersep> status <identifiersep> changed ( provider <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> pres <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } public void provider <identifiersep> status <identifiersep> message <identifiersep> changed ( property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) <ect>
<comment> public void wait <identifiersep> for <identifiersep> pres <identifiersep> event ( long wait <identifiersep> for ) { logger . trace ( <string_literal> ) ; synchronized ( this ) { <LOG> if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <ect>
logger . trace ( <string_literal> + collected <identifiersep> pres <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <LOG> else } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
<comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
string authorization <identifiersep> response <identifiersep> string = null ; <comment> <LOG> { synchronized ( this ) { logger . trace ( <string_literal> + req + <string_literal> + source <identifiersep> contact ) ; is <identifiersep> authorization <identifiersep> request <identifiersep> received = true ; <ect>
logger . debug ( <string_literal> , ex ) ; } } } @ override public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { notify <identifiersep> all ( ) ; } } } <comment> public void post <identifiersep> test <identifiersep> receive <identifiersep> authorizatinon <identifiersep> request ( ) <ect>
logger . debug ( <string_literal> ) ; <comment> <LOG> auth <identifiersep> event <identifiersep> collector . response <identifiersep> to <identifiersep> request = new authorization <identifiersep> response ( authorization <identifiersep> response . reject , first <identifiersep> request <identifiersep> response ) ; auth <identifiersep> event <identifiersep> collector . is <identifiersep> authorization <identifiersep> request <identifiersep> received = false ; auth <identifiersep> event <identifiersep> collector . authorization <identifiersep> request <identifiersep> reason = null ; icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . request <identifiersep> reason <identifiersep> str = <string_literal> ; icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . is <identifiersep> error <identifiersep> adding <identifiersep> received = false ; icq <identifiersep> slick <identifiersep> fixture . tester <identifiersep> agent . get <identifiersep> auth <identifiersep> cmd <identifiersep> factory ( ) . response <identifiersep> reason <identifiersep> str = null ; <ect>
icq <identifiersep> provider <identifiersep> refs . length > 0 ) ; <comment> <LOG> new registration <identifiersep> failed <identifiersep> event <identifiersep> collector ( ) ; provider . add <identifiersep> registration <identifiersep> state <identifiersep> change <identifiersep> listener ( reg <identifiersep> failed <identifiersep> evt <identifiersep> collector ) ; provider . register ( new security <identifiersep> authority <identifiersep> impl ( passwd . to <identifiersep> char <identifiersep> array ( ) ) ) ; <comment> <ect>
<comment> <LOG> registration <identifiersep> lock . wait ( <number_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) { <ect>
registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) <LOG> { } assert <identifiersep> true ( <string_literal> + <string_literal> + reg <identifiersep> failed <identifiersep> evt <identifiersep> collector . collected <identifiersep> new <identifiersep> states , reg <identifiersep> failed <identifiersep> evt <identifiersep> collector . collected <identifiersep> new <identifiersep> states . contains ( registration <identifiersep> state . authentication <identifiersep> failed ) ) ; <ect>
icq <identifiersep> provider <identifiersep> refs . length > 0 ) ; <comment> <LOG> new registration <identifiersep> failed <identifiersep> event <identifiersep> collector ( ) ; provider . add <identifiersep> registration <identifiersep> state <identifiersep> change <identifiersep> listener ( reg <identifiersep> failed <identifiersep> evt <identifiersep> collector ) ; provider . register ( new security <identifiersep> authority <identifiersep> impl ( passwd . to <identifiersep> char <identifiersep> array ( ) ) ) ; <comment> <ect>
<comment> <LOG> registration <identifiersep> lock . wait ( <number_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) { <ect>
registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) <LOG> { } assert <identifiersep> true ( <string_literal> + <string_literal> + reg <identifiersep> failed <identifiersep> evt <identifiersep> collector . collected <identifiersep> new <identifiersep> states , reg <identifiersep> failed <identifiersep> evt <identifiersep> collector . collected <identifiersep> new <identifiersep> states . contains ( registration <identifiersep> state . authentication <identifiersep> failed ) ) ; <ect>
if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . authentication <identifiersep> failed ) ) { failed <identifiersep> code = evt . get <identifiersep> reason <identifiersep> code ( ) ; failed <identifiersep> reason = evt . get <identifiersep> reason ( ) ; logger . debug ( <string_literal> + failed <identifiersep> code + <string_literal> + failed <identifiersep> reason ) ; synchronized ( registration <identifiersep> lock ) <LOG> { registration <identifiersep> lock . notify <identifiersep> all ( ) ; logger . debug ( <string_literal> ) ; } } } } <comment> <ect>
<comment> <LOG> { } <comment> <ect>
fixture . provider . add <identifiersep> registration <identifiersep> state <identifiersep> change <identifiersep> listener ( reg <identifiersep> evt <identifiersep> collector ) ; fixture . provider . register ( new security <identifiersep> authority <identifiersep> impl ( ) ) ; <comment> <LOG> synchronized ( registration <identifiersep> lock ) { registration <identifiersep> lock . wait ( <number_literal> ) ; logger . debug ( <string_literal> ) ; } } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } catch ( throwable t ) <ect>
<comment> <LOG> catch ( interrupted <identifiersep> exception ex ) { } catch ( throwable t ) { logger . debug ( <string_literal> , t ) ; } <comment> <ect>
<comment> <LOG> { lock . wait ( <number_literal> ) ; } catch ( exception ex ) { } } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { logger . debug ( <string_literal> + evt ) ; collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) <LOG> { synchronized ( registration <identifiersep> lock ) { registration <identifiersep> lock . notify <identifiersep> all ( ) ; } } } } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) <LOG> { if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) ) { logger . debug ( <string_literal> ) ; state <identifiersep> recieved = evt . get <identifiersep> new <identifiersep> state ( ) ; event <identifiersep> reason = evt . get <identifiersep> reason <identifiersep> code ( ) ; <ect>
logger . debug ( <string_literal> ) ; logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list <LOG> = jabber <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; logger . debug ( expected <identifiersep> contact <identifiersep> list ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> remove <identifiersep> group ( ) <LOG> { <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> rename <identifiersep> group ( ) <LOG> { contact <identifiersep> group group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( test <identifiersep> group <identifiersep> name ) ; <comment> <ect>
contact <identifiersep> group newly <identifiersep> created <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( group <identifiersep> name ) ; iterator < string > contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group = contact <identifiersep> list <identifiersep> to <identifiersep> create . get ( group <identifiersep> name ) . iterator ( ) ; while ( contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . has <identifiersep> next ( ) ) { <LOG> string id = contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . next ( ) ; op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . subscribe ( newly <identifiersep> created <identifiersep> group , id ) ; } } <comment> <ect>
<comment> public void group <identifiersep> name <identifiersep> changed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> resolved ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) <LOG> { return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <ect>
logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <LOG> else } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void contact <identifiersep> modified ( contact <identifiersep> property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } } <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) <LOG> { collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) { logger . debug ( <string_literal> ) ; synchronized ( this ) <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> new <identifiersep> states . contains ( registration <identifiersep> state . registered ) ) { logger . trace ( <string_literal> <ect>
<comment> public void test <identifiersep> conference <identifiersep> chat ( ) throws operation <identifiersep> failed <identifiersep> exception , operation <identifiersep> not <identifiersep> supported <identifiersep> exception { <LOG> string test <identifiersep> room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ++ ; <comment> <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string test <identifiersep> room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ++ ; <comment> <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string test <identifiersep> room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ++ ; <comment> <ect>
<comment> public void test <identifiersep> initial <identifiersep> participants <identifiersep> roles ( ) throws operation <identifiersep> failed <identifiersep> exception , operation <identifiersep> not <identifiersep> supported <identifiersep> exception { <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; <comment> <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user2 = op <identifiersep> set <identifiersep> muc2 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user2 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user2 = op <identifiersep> set <identifiersep> muc2 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user2 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user2 = op <identifiersep> set <identifiersep> muc2 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user2 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user3col = new muc <identifiersep> event <identifiersep> collector ( <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > wait <identifiersep> count ) { wait <identifiersep> count ++ ; <ect>
logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > wait <identifiersep> count ) <LOG> { } else { logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } wait <identifiersep> count ++ ; <ect>
evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> typing <identifiersep> notifs1 . remove <identifiersep> typing <identifiersep> notifications <identifiersep> listener ( evt <identifiersep> collector ) ; <comment> <LOG> + <string_literal> ) ; evt = ( typing <identifiersep> notification <identifiersep> event ) evt <identifiersep> collector . collected <identifiersep> events . get ( 0 ) ; assert <identifiersep> equals ( <string_literal> , fixture . user <identifiersep> id2 , evt . get <identifiersep> source <identifiersep> contact ( ) . get <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> <ect>
<comment> <comment> <LOG> <comment> <ect>
+ <string_literal> + new date ( ) . to <identifiersep> string ( ) ; im <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new im <identifiersep> event <identifiersep> collector ( ) ; <comment> <LOG> = op <identifiersep> set <identifiersep> presence2 . find <identifiersep> contact <identifiersep> by <identifiersep> id ( fixture . user <identifiersep> id1 ) ; op <identifiersep> set <identifiersep> basic <identifiersep> im2 . send <identifiersep> instant <identifiersep> message ( tester <identifiersep> agent <identifiersep> contact , op <identifiersep> set <identifiersep> basic <identifiersep> im2 . create <identifiersep> message ( body ) ) ; evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> basic <identifiersep> im1 . remove <identifiersep> message <identifiersep> listener ( evt <identifiersep> collector ) ; <comment> <ect>
<comment> public void then <identifiersep> test <identifiersep> send <identifiersep> message ( ) { logger . debug ( <string_literal> ) ; contact <identifiersep> group root <identifiersep> group1 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence1 ) . <LOG> get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> + root <identifiersep> group1 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 <ect>
logger . debug ( <string_literal> + root <identifiersep> group1 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence2 ) . <LOG> get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> + root <identifiersep> group2 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group2 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group2 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group2 . to <identifiersep> string ( ) ) ; string body = <string_literal> <ect>
<comment> public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
subtest <identifiersep> query <identifiersep> contact <identifiersep> status ( jabber <identifiersep> status <identifiersep> enum . away , jabber <identifiersep> status <identifiersep> enum . away ) ; <comment> <LOG> <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception <LOG> { logger . trace ( <string_literal> ) ; operation <identifiersep> set <identifiersep> presence1 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector1 ) ; operation <identifiersep> set <identifiersep> presence2 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector2 ) ; <comment> <ect>
fixture . provider1 , sub <identifiersep> evt . get <identifiersep> source <identifiersep> provider ( ) ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> subscription <identifiersep> events . clear ( ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> subscription <identifiersep> moved <identifiersep> events . clear ( ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> contact <identifiersep> property <identifiersep> change <identifiersep> events . clear ( ) ; <comment> <LOG> <comment> <ect>
fixture . provider1 , sub <identifiersep> evt . get <identifiersep> source <identifiersep> provider ( ) ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> subscription <identifiersep> events . clear ( ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> subscription <identifiersep> moved <identifiersep> events . clear ( ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> contact <identifiersep> property <identifiersep> change <identifiersep> events . clear ( ) ; <comment> <LOG> <comment> <ect>
= new array <identifiersep> list < provider <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event > ( ) ; public array <identifiersep> list < property <identifiersep> change <identifiersep> event > collected <identifiersep> stat <identifiersep> msg <identifiersep> events = new array <identifiersep> list < property <identifiersep> change <identifiersep> event > ( ) ; public void provider <identifiersep> status <identifiersep> changed ( provider <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) <LOG> { + <string_literal> + evt ) ; collected <identifiersep> pres <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } public void provider <identifiersep> status <identifiersep> message <identifiersep> changed ( property <identifiersep> change <identifiersep> event evt ) { <ect>
<comment> public void wait <identifiersep> for <identifiersep> stat <identifiersep> msg <identifiersep> event ( long wait <identifiersep> for ) <LOG> { test <identifiersep> operation <identifiersep> set <identifiersep> presence . wait <identifiersep> for <identifiersep> event ( this , wait <identifiersep> for , collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; } } <comment> <ect>
authorization <identifiersep> response response = null ; <comment> <LOG> { synchronized ( this ) { logger . trace ( <string_literal> + req + <string_literal> + source <identifiersep> contact ) ; is <identifiersep> authorization <identifiersep> request <identifiersep> received = true ; <ect>
notify <identifiersep> all ( ) ; } } public void wait <identifiersep> for <identifiersep> auth <identifiersep> response ( long wait <identifiersep> for ) { synchronized ( this ) { if ( is <identifiersep> authorization <identifiersep> response <identifiersep> received ) <LOG> { return ; } try { wait ( wait <identifiersep> for ) ; } catch ( interrupted <identifiersep> exception ex ) { <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; <ect>
if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) { <ect>
listened <identifiersep> call <identifiersep> peer . remove <identifiersep> call <identifiersep> peer <identifiersep> listener ( this ) ; return ; } } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; listened <identifiersep> call <identifiersep> peer . remove <identifiersep> call <identifiersep> peer <identifiersep> listener ( this ) ; <ect>
collected <identifiersep> events ) ; listened <identifiersep> call . remove <identifiersep> call <identifiersep> change <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; listened <identifiersep> call . remove <identifiersep> call <identifiersep> change <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; <LOG> logger . debug ( <string_literal> ) ; + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = gibberish <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; <ect>
{ <comment> <LOG> o . wait ( <number_literal> ) ; } <comment> <ect>
{ <comment> <LOG> { } group <identifiersep> change <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . remove <identifiersep> server <identifiersep> stored <identifiersep> group <identifiersep> change <identifiersep> listener ( group <identifiersep> change <identifiersep> collector ) ; <comment> <ect>
uin <identifiersep> in <identifiersep> this <identifiersep> group . add ( uin ) ; } <comment> <LOG> string group <identifiersep> name = new <identifiersep> groups <identifiersep> enum . next <identifiersep> element ( ) ; op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . create <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , group <identifiersep> name ) ; contact <identifiersep> group newly <identifiersep> created <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( group <identifiersep> name ) ; iterator < string > contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group <ect>
<comment> public void group <identifiersep> created ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void typing <identifiersep> notification <identifiersep> received ( typing <identifiersep> notification <identifiersep> event event ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( event ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
+ protocol <identifiersep> provider <identifiersep> factory . password ) . to <identifiersep> char <identifiersep> array ( ) ) ) ; fixture . provider2 . register ( new security <identifiersep> authority <identifiersep> impl ( system . get <identifiersep> property ( gibberish <identifiersep> protocol <identifiersep> provider <identifiersep> service <identifiersep> lick . account <identifiersep> <number_literal> <identifiersep> prefix + protocol <identifiersep> provider <identifiersep> factory . password ) . to <identifiersep> char <identifiersep> array ( ) ) ) ; <comment> <LOG> <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { logger . debug ( <string_literal> + evt ) ; collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) <LOG> { synchronized ( this ) { notify <identifiersep> all ( ) ; } } } <comment> <ect>
+ <string_literal> + new date ( ) . to <identifiersep> string ( ) ; im <identifiersep> event <identifiersep> collector evt <identifiersep> collector = new im <identifiersep> event <identifiersep> collector ( ) ; <comment> <LOG> = op <identifiersep> set <identifiersep> presence2 . find <identifiersep> contact <identifiersep> by <identifiersep> id ( fixture . user <identifiersep> id1 ) ; op <identifiersep> set <identifiersep> basic <identifiersep> im2 . send <identifiersep> instant <identifiersep> message ( tester <identifiersep> agent <identifiersep> contact , op <identifiersep> set <identifiersep> basic <identifiersep> im2 . create <identifiersep> message ( body ) ) ; evt <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; op <identifiersep> set <identifiersep> basic <identifiersep> im1 . remove <identifiersep> message <identifiersep> listener ( evt <identifiersep> collector ) ; <comment> <ect>
<comment> public void then <identifiersep> test <identifiersep> send <identifiersep> message ( ) { logger . debug ( <string_literal> ) ; contact <identifiersep> group root <identifiersep> group1 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence1 ) . <LOG> get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> + root <identifiersep> group1 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 <ect>
logger . debug ( <string_literal> + root <identifiersep> group1 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group1 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group1 . to <identifiersep> string ( ) ) ; contact <identifiersep> group root <identifiersep> group2 = ( ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence ) op <identifiersep> set <identifiersep> presence2 ) . <LOG> get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> + root <identifiersep> group2 . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group2 . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group2 . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group2 . to <identifiersep> string ( ) ) ; string body = <string_literal> <ect>
<comment> public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> delivered ( message <identifiersep> delivered <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
public void subtest <identifiersep> state <identifiersep> transition ( presence <identifiersep> status new <identifiersep> status ) throws exception { logger . trace ( <string_literal> ) ; presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; <LOG> string new <identifiersep> status <identifiersep> message = status <identifiersep> message <identifiersep> root + new <identifiersep> status ; + <string_literal> + new <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) ) ; <comment> <ect>
private void pause <identifiersep> after <identifiersep> state <identifiersep> changes ( ) { try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) <LOG> { } } <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception { <LOG> logger . debug ( <string_literal> ) ; operation <identifiersep> set <identifiersep> presence1 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector1 ) ; operation <identifiersep> set <identifiersep> presence2 . set <identifiersep> authorization <identifiersep> handler ( auth <identifiersep> event <identifiersep> collector2 ) ; <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> unsubscribe ( ) throws exception <LOG> { <comment> <ect>
<comment> public void clear <identifiersep> lists ( ) throws exception <LOG> { fixture . clear <identifiersep> providers <identifiersep> lists ( ) ; object o = new object ( ) ; synchronized ( o ) { o . wait ( <number_literal> ) ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> pres <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> pres <identifiersep> events ) ; return ; <ect>
<comment> public void contact <identifiersep> modified ( contact <identifiersep> property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
if ( this . tracked <identifiersep> screen <identifiersep> name != null && ! evt . get <identifiersep> source <identifiersep> contact ( ) . get <identifiersep> address ( ) . equals ( tracked <identifiersep> screen <identifiersep> name ) ) return ; if ( status != null && status != evt . get <identifiersep> new <identifiersep> status ( ) ) <LOG> return ; collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
{ lock . wait ( <number_literal> ) ; } catch ( exception ex ) { } } return response <identifiersep> to <identifiersep> request ; } } public authorization <identifiersep> request create <identifiersep> authorization <identifiersep> request ( contact contact ) <LOG> { authorization <identifiersep> request auth <identifiersep> req = new authorization <identifiersep> request ( ) ; is <identifiersep> authorization <identifiersep> request <identifiersep> sent = true ; return auth <identifiersep> req ; } public void process <identifiersep> authorization <identifiersep> response ( authorization <identifiersep> response response , contact source <identifiersep> contact ) <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group = this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; <LOG> logger . debug ( <string_literal> ) ; + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = sip <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; <ect>
{ <comment> <LOG> o . wait ( <number_literal> ) ; } <comment> <ect>
{ <comment> <LOG> { } group <identifiersep> change <identifiersep> collector . wait <identifiersep> for <identifiersep> event ( <number_literal> ) ; this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . remove <identifiersep> server <identifiersep> stored <identifiersep> group <identifiersep> change <identifiersep> listener ( group <identifiersep> change <identifiersep> collector ) ; <comment> <ect>
uin <identifiersep> in <identifiersep> this <identifiersep> group . add ( uin ) ; } <comment> <LOG> string group <identifiersep> name = new <identifiersep> groups <identifiersep> enum . next <identifiersep> element ( ) ; this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . create <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , group <identifiersep> name ) ; contact <identifiersep> group newly <identifiersep> created <identifiersep> group = this . op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . get <identifiersep> group ( group <identifiersep> name ) ; <ect>
<comment> public void group <identifiersep> created ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> removed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
iter = op <identifiersep> set <identifiersep> presence2 . get <identifiersep> supported <identifiersep> status <identifiersep> set ( ) ; while ( iter . has <identifiersep> next ( ) ) { presence <identifiersep> status stat = iter . next ( ) ; if ( stat . is <identifiersep> online ( ) ) { op <identifiersep> set <identifiersep> presence2 . publish <identifiersep> presence <identifiersep> status ( stat , <string_literal> ) ; <LOG> break ; } } synchronized ( o ) { o . wait ( <number_literal> ) ; } } <comment> <ect>
assert <identifiersep> equals ( <string_literal> , encoding , msg . get <identifiersep> encoding ( ) ) ; try { assert <identifiersep> true ( <string_literal> , arrays . equals ( body . get <identifiersep> bytes ( encoding ) , msg . get <identifiersep> raw <identifiersep> data ( ) ) ) ; assert <identifiersep> equals ( <string_literal> , body . get <identifiersep> bytes ( encoding ) . length , msg . get <identifiersep> size ( ) ) ; <LOG> } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { assert <identifiersep> true ( <string_literal> , arrays . equals ( body . get <identifiersep> bytes ( ) , msg . get <identifiersep> raw <identifiersep> data ( ) ) ) ; assert <identifiersep> equals ( <string_literal> , body . get <identifiersep> bytes ( ) . length , msg . get <identifiersep> size ( ) ) ; } assert <identifiersep> equals ( <string_literal> , content <identifiersep> type , msg . get <identifiersep> content <identifiersep> type ( ) ) ; <ect>
<comment> public void message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
string message = hostname + <string_literal> + system . get <identifiersep> property ( <string_literal> ) + <string_literal> + new date ( ) . to <identifiersep> string ( ) + <string_literal> ; <LOG> string list = system . get <identifiersep> property ( <string_literal> ) ; <comment> <ect>
logger . trace ( <string_literal> ) ; presence <identifiersep> status old <identifiersep> status = this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; string new <identifiersep> status <identifiersep> message = <LOG> this . status <identifiersep> message <identifiersep> root + new <identifiersep> status ; + <string_literal> + new <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) ) ; <comment> <ect>
( ( property <identifiersep> change <identifiersep> event ) status <identifiersep> event <identifiersep> collector . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . get ( 0 ) ) . get <identifiersep> new <identifiersep> value ( ) ) ; <comment> <LOG> this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ) ; } <comment> private void pause <identifiersep> after <identifiersep> state <identifiersep> changes ( ) { <ect>
<comment> public void post <identifiersep> test <identifiersep> subscribe ( ) throws exception <LOG> { this . operation <identifiersep> set <identifiersep> presence2 . subscribe ( this . fixture . user <identifiersep> id1 ) ; subscription <identifiersep> event <identifiersep> collector sub <identifiersep> evt <identifiersep> collector = new subscription <identifiersep> event <identifiersep> collector ( ) ; this . operation <identifiersep> set <identifiersep> presence1 . add <identifiersep> subscription <identifiersep> listener ( sub <identifiersep> evt <identifiersep> collector ) ; synchronized ( sub <identifiersep> evt <identifiersep> collector ) <ect>
{ public array <identifiersep> list < event <identifiersep> object > collected <identifiersep> pres <identifiersep> events = new array <identifiersep> list < event <identifiersep> object > ( ) ; public array <identifiersep> list < event <identifiersep> object > collected <identifiersep> stat <identifiersep> msg <identifiersep> events = new array <identifiersep> list < event <identifiersep> object > ( ) ; public void provider <identifiersep> status <identifiersep> changed ( provider <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) <LOG> { + <string_literal> + evt ) ; this . collected <identifiersep> pres <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } public void provider <identifiersep> status <identifiersep> message <identifiersep> changed ( property <identifiersep> change <identifiersep> event evt ) { <ect>
if ( this . collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + this . collected <identifiersep> pres <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( this . collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , <ect>
if ( this . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + this . collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( this . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> + <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) { synchronized ( this ) <LOG> { + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { + <string_literal> + evt ) ; this . collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
+ protocol <identifiersep> provider <identifiersep> factory . password ) . to <identifiersep> char <identifiersep> array ( ) ) ) ; fixture . provider2 . register ( new security <identifiersep> authority <identifiersep> impl ( system . get <identifiersep> property ( sip <identifiersep> protocol <identifiersep> provider <identifiersep> service <identifiersep> lick . account <identifiersep> <number_literal> <identifiersep> prefix + protocol <identifiersep> provider <identifiersep> factory . password ) . to <identifiersep> char <identifiersep> array ( ) ) ) ; <comment> <LOG> <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { logger . debug ( <string_literal> + evt ) ; collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . registered ) ) <LOG> { synchronized ( this ) { notify <identifiersep> all ( ) ; } } } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) <LOG> { collected <identifiersep> new <identifiersep> states . add ( evt . get <identifiersep> new <identifiersep> state ( ) ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) ) { logger . debug ( <string_literal> ) ; synchronized ( this ) <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> new <identifiersep> states . contains ( registration <identifiersep> state . unregistered ) ) { logger . trace ( <string_literal> <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) { logger . trace ( <string_literal> ) ; synchronized ( this ) { <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) { listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) <ect>
listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; <LOG> else listened <identifiersep> op <identifiersep> set . remove <identifiersep> call <identifiersep> listener ( this ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( listened <identifiersep> call . get <identifiersep> call <identifiersep> state ( ) == awaited <identifiersep> state ) { logger . trace ( <string_literal> + <ect>
{ history <identifiersep> service <identifiersep> lick . bc = bundle <identifiersep> context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test ( test <identifiersep> history <identifiersep> service . suite ( ) ) ; <LOG> bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; } <comment> <ect>
base <identifiersep> dir = new file ( dir ) ; } public void set <identifiersep> recorder ( boolean rec ) { include <identifiersep> recorder = rec ; } public void execute ( ) throws build <identifiersep> exception { <comment> <LOG> throw new build <identifiersep> exception ( <string_literal> ) ; } file graphics <identifiersep> file = new file ( base <identifiersep> dir , <string_literal> ) ; file applet <identifiersep> file = new file ( base <identifiersep> dir , <string_literal> ) ; file image <identifiersep> file = new file ( base <identifiersep> dir , <string_literal> ) ; if ( ! graphics <identifiersep> file . exists ( ) || ! graphics <identifiersep> file . can <identifiersep> read ( ) ) { throw new build <identifiersep> exception ( <string_literal> + <ect>
<comment> <LOG> comment <identifiersep> buffer . append ( ' \\ n' ) ; comments -- ; <comment> <ect>
if ( kid != null ) add <identifiersep> child ( kid ) ; } children = ( p <identifiersep> shape [ ] ) p <identifiersep> applet . subset ( children , 0 , child <identifiersep> count ) ; } <comment> <LOG> protected p <identifiersep> shape parse <identifiersep> child ( xml elem ) { string name = elem . get <identifiersep> name ( ) ; p <identifiersep> shape <identifiersep> svg shape = null ; if ( name == null ) { <comment> <ect>
<comment> <LOG> } else { return 0 ; } } <comment> <ect>
if ( fg . is <identifiersep> legit ( ) ) { if ( fg . name != null ) { named <identifiersep> glyphs . put ( fg . name , fg ) ; } if ( fg . unicode != 0 ) { unicode <identifiersep> glyphs . put ( character . value <identifiersep> of ( fg . unicode ) , fg ) ; } } glyphs [ glyph <identifiersep> count ++ ] = fg ; <LOG> } else if ( name . equals ( <string_literal> ) ) { missing <identifiersep> glyph = new font <identifiersep> glyph ( this , elem , this ) ; } else if ( name . equals ( <string_literal> ) ) { face = new font <identifiersep> face ( this , elem ) ; } else { system . err . println ( <string_literal> + name + <string_literal> ) ; <ect>
protected void draw <identifiersep> shape ( ) { <comment> <LOG> float s = size / face . units <identifiersep> per <identifiersep> em ; <comment> <ect>
super . parse <identifiersep> path ( ) ; <comment> <LOG> unicode = u . char <identifiersep> at ( 0 ) ; } else { system . err . println ( <string_literal> + name + <string_literal> + u ) ; } } if ( properties . has <identifiersep> attribute ( <string_literal> ) ) { horiz <identifiersep> adv <identifiersep> x = properties . get <identifiersep> int ( <string_literal> ) ; <ect>
<comment> <LOG> <comment> <ect>
max ( max ( abs ( m30 ) , abs ( m31 ) ) , max ( abs ( m32 ) , abs ( m33 ) ) ) ) ) ) ; int digits = 1 ; if ( float . is <identifiersep> na <identifiersep> n ( big ) || float . is <identifiersep> infinite ( big ) ) { <comment> <LOG> while ( ( big /= <number_literal> ) != 0 ) digits ++ ; <comment> <ect>
p <identifiersep> applet . nfs ( m01 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m02 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m03 , digits , <number_literal> ) ) ; system . out . println ( p <identifiersep> applet . nfs ( m10 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m11 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m12 , digits , <number_literal> ) + <string_literal> + <LOG> p <identifiersep> applet . nfs ( m13 , digits , <number_literal> ) ) ; p <identifiersep> applet . nfs ( m21 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m22 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m23 , digits , <number_literal> ) ) ; system . out . println ( p <identifiersep> applet . nfs ( m30 , digits , <number_literal> ) + <string_literal> + p <identifiersep> applet . nfs ( m31 , digits , <number_literal> ) + <string_literal> + <ect>
g . stroke ( stroke <identifiersep> color ) ; g . stroke <identifiersep> weight ( stroke <identifiersep> weight ) ; g . stroke <identifiersep> cap ( stroke <identifiersep> cap ) ; g . stroke <identifiersep> join ( stroke <identifiersep> join ) ; } else { g . no <identifiersep> stroke ( ) ; } <LOG> if ( fill ) { g . fill ( fill <identifiersep> color ) ; } else { g . no <identifiersep> fill ( ) ; } } protected void post ( p <identifiersep> graphics g ) { <comment> <ect>
boolean inside <identifiersep> settings ( string method , object . . . args ) { if ( inside <identifiersep> settings ) { return true ; } final string url = <string_literal> + method + <string_literal> ; if ( ! external ) { <comment> <LOG> system . err . println ( <string_literal> + method + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + method + <string_literal> + arg <identifiersep> list . join ( <string_literal> ) + <string_literal> ) ; system . err . println ( <string_literal> ) ; } throw new illegal <identifiersep> state <identifiersep> exception ( method + <string_literal> + url ) ; } void handle <identifiersep> settings ( ) { <ect>
return true ; } final string url = <string_literal> + method + <string_literal> ; if ( ! external ) { <comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } throw new illegal <identifiersep> state <identifiersep> exception ( method + <string_literal> + url ) ; } void handle <identifiersep> settings ( ) { inside <identifiersep> settings = true ; <comment> <ect>
final string msg = <string_literal> + <string_literal> ; j <identifiersep> option <identifiersep> pane . show <identifiersep> message <identifiersep> dialog ( null , msg , <string_literal> , j <identifiersep> option <identifiersep> pane . warning <identifiersep> message ) ; } } ) ; <LOG> } else if ( ! <string_literal> . equals ( result ) ) { system . err . format ( <string_literal> , trim ( stderr . to <identifiersep> string ( ) ) , result <identifiersep> code ) ; } } inside <identifiersep> settings = false ; } <comment> <ect>
if ( density != this . pixel <identifiersep> density ) { if ( inside <identifiersep> settings ( <string_literal> , density ) ) { if ( density != 1 && density != <number_literal> ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } if ( ! fx2d . equals ( renderer ) && density == <number_literal> && display <identifiersep> density ( ) == 1 ) { <comment> <LOG> <comment> <ect>
synchronized ( register <identifiersep> lock ) { registered <identifiersep> methods meth = register <identifiersep> map . get ( method <identifiersep> name ) ; if ( meth != null ) { meth . handle ( args ) ; } } } <comment> <LOG> public void register <identifiersep> size ( object o ) { <comment> <ect>
<comment> public void draw ( ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
string . format ( <string_literal> + <string_literal> , w , h , renderer , path ) ; throw new runtime <identifiersep> exception ( msg ) ; } else { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> <comment> <comment> <ect>
<comment> static public void println ( object what ) { <LOG> if ( what == null ) { } else if ( what . get <identifiersep> class ( ) . is <identifiersep> array ( ) ) { print <identifiersep> array ( what ) ; } else { system . out . println ( what . to <identifiersep> string ( ) ) ; system . out . flush ( ) ; <ect>
system . out . println ( what ) ; break ; case 'l' : <comment> <LOG> if ( poo [ i ] instanceof string ) { } else { system . out . println ( <string_literal> + i + <string_literal> + poo [ i ] ) ; } } break ; case 'z' : <comment> <ect>
system . out . println ( <string_literal> + i + <string_literal> + poo [ i ] + <string_literal> ) ; } else { system . out . println ( <string_literal> + i + <string_literal> + poo [ i ] ) ; } } break ; case 'z' : <comment> <LOG> for ( int i = 0 ; i < zz . length ; i ++ ) { } break ; case 'b' : <comment> <ect>
byte bb [ ] = ( byte [ ] ) what ; for ( int i = 0 ; i < bb . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + bb [ i ] ) ; } break ; case 'c' : <comment> <LOG> for ( int i = 0 ; i < cc . length ; i ++ ) { } break ; case 'i' : <comment> <ect>
int ii [ ] = ( int [ ] ) what ; for ( int i = 0 ; i < ii . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + ii [ i ] ) ; } break ; case 'j' : <comment> <LOG> for ( int i = 0 ; i < jj . length ; i ++ ) { } break ; case 'f' : <comment> <ect>
float ff [ ] = ( float [ ] ) what ; for ( int i = 0 ; i < ff . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + ff [ i ] ) ; } break ; case 'd' : <comment> <LOG> for ( int i = 0 ; i < dd . length ; i ++ ) { } break ; default : system . out . println ( what ) ; } } else { <comment> <ect>
<comment> <LOG> if ( stream == null ) { return null ; } try { buffered <identifiersep> image bi = image <identifiersep> io . read ( stream ) ; p <identifiersep> image outgoing = new p <identifiersep> image ( bi . get <identifiersep> width ( ) , bi . get <identifiersep> height ( ) ) ; outgoing . parent = this ; <ect>
table dictionary = null ; for ( string opt : option <identifiersep> list ) { if ( opt . starts <identifiersep> with ( <string_literal> ) ) { dictionary = load <identifiersep> table ( opt . substring ( opt . index <identifiersep> of ( ' = ' ) + 1 ) , <string_literal> ) ; return dictionary . typed <identifiersep> parse ( create <identifiersep> input ( filename ) , option <identifiersep> str ) ; } } input <identifiersep> stream input = create <identifiersep> input ( filename ) ; <LOG> if ( input == null ) { return null ; } return new table ( input , option <identifiersep> str ) ; } catch ( io <identifiersep> exception e ) { print <identifiersep> stack <identifiersep> trace ( e ) ; return null ; <ect>
callback <identifiersep> class . get <identifiersep> method ( callback <identifiersep> method , new class [ ] { file . class } ) ; select <identifiersep> method . invoke ( callback <identifiersep> object , new object [ ] { selected <identifiersep> file } ) ; } catch ( illegal <identifiersep> access <identifiersep> exception iae ) { system . err . println ( callback <identifiersep> method + <string_literal> ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ite ) { ite . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception nsme ) { } } <comment> <ect>
public input <identifiersep> stream create <identifiersep> input <identifiersep> raw ( string filename ) { if ( filename == null ) return null ; if ( sketch <identifiersep> path == null ) { system . err . println ( <string_literal> ) ; throw new runtime <identifiersep> exception ( <string_literal> ) ; } if ( filename . length ( ) == 0 ) { <LOG> <comment> <ect>
<comment> static public input <identifiersep> stream create <identifiersep> input ( file file ) { if ( file == null ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } <LOG> if ( ! file . exists ( ) ) { return null ; } try { input <identifiersep> stream input = new file <identifiersep> input <identifiersep> stream ( file ) ; final string lower = file . get <identifiersep> name ( ) . to <identifiersep> lower <identifiersep> case ( ) ; if ( lower . ends <identifiersep> with ( <string_literal> ) || lower . ends <identifiersep> with ( <string_literal> ) ) { <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; } return null ; } <comment> static public byte [ ] load <identifiersep> bytes ( file file ) { <LOG> if ( ! file . exists ( ) ) { return null ; } try { input <identifiersep> stream input ; int length ; if ( file . get <identifiersep> name ( ) . to <identifiersep> lower <identifiersep> case ( ) . ends <identifiersep> with ( <string_literal> ) ) { <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; return null ; } } <comment> static public string [ ] load <identifiersep> strings ( file file ) { <LOG> if ( ! file . exists ( ) ) { return null ; } input <identifiersep> stream is = create <identifiersep> input ( file ) ; if ( is != null ) { string [ ] outgoing = load <identifiersep> strings ( is ) ; try { <ect>
if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { system . err . println ( <string_literal> + file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } } if ( ! temp <identifiersep> file . rename <identifiersep> to ( file ) ) { system . err . println ( <string_literal> + temp <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } <LOG> } catch ( io <identifiersep> exception e ) { if ( temp <identifiersep> file != null ) { temp <identifiersep> file . delete ( ) ; } e . print <identifiersep> stack <identifiersep> trace ( ) ; } } <comment> <ect>
<comment> <comment> <LOG> } catch ( headless <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } <comment> <ect>
} catch ( headless <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } <comment> <LOG> if ( args . length < 1 ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } boolean external = false ; int [ ] location = null ; int [ ] editor <identifiersep> location = null ; <ect>
value = args [ arg <identifiersep> index ] . substring ( equals + 1 ) ; if ( param . equals ( args <identifiersep> editor <identifiersep> location ) ) { external = true ; editor <identifiersep> location = parse <identifiersep> int ( split ( value , ' , ' ) ) ; } else if ( param . equals ( args <identifiersep> display ) ) { display <identifiersep> num = parse <identifiersep> int ( value , - 1 ) ; <LOG> if ( display <identifiersep> num == - 1 ) { } } else if ( param . equals ( args <identifiersep> window <identifiersep> color ) ) { if ( value . char <identifiersep> at ( 0 ) == ' # ' && value . length ( ) == <number_literal> ) { value = value . substring ( 1 ) ; window <identifiersep> color = 0xff000000 | integer . parse <identifiersep> int ( value , <number_literal> ) ; } else { <ect>
} else { surface . init <identifiersep> offscreen ( this ) ; <comment> <LOG> <comment> <ect>
if ( application == null ) { application = application . get <identifiersep> application ( ) ; } application . set <identifiersep> quit <identifiersep> handler ( null ) ; } <comment> <LOG> <comment> <ect>
int big = ( int ) abs ( max ( p <identifiersep> applet . max ( abs ( m00 ) , abs ( m01 ) , abs ( m02 ) ) , p <identifiersep> applet . max ( abs ( m10 ) , abs ( m11 ) , abs ( m12 ) ) ) ) ; int digits = 1 ; if ( float . is <identifiersep> na <identifiersep> n ( big ) || float . is <identifiersep> infinite ( big ) ) { <comment> <LOG> while ( ( big /= <number_literal> ) != 0 ) digits ++ ; <comment> <ect>
int contours = 0 ; <comment> <LOG> case path <identifiersep> iterator . seg <identifiersep> moveto : <comment> <ect>
break ; case path <identifiersep> iterator . seg <identifiersep> lineto : <comment> <LOG> case path <identifiersep> iterator . seg <identifiersep> quadto : <comment> <ect>
<comment> <LOG> case path <identifiersep> iterator . seg <identifiersep> close : if ( contours > 1 ) { <comment> <ect>
<comment> <LOG> if ( primary <identifiersep> graphics ) { background ( background <identifiersep> color ) ; } blend <identifiersep> mode ( blend ) ; settings <identifiersep> inited = true ; <comment> <ect>
base <identifiersep> font = font . create <identifiersep> font ( font . truetype <identifiersep> font , parent . create <identifiersep> input ( name ) ) ; } else { base <identifiersep> font = p <identifiersep> font . find <identifiersep> font ( name ) ; } return new p <identifiersep> font ( base <identifiersep> font . derive <identifiersep> font ( size * parent . pixel <identifiersep> density ) , smooth , charset , stream != null , parent . pixel <identifiersep> density ) ; <LOG> } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return null ; } } public void text <identifiersep> align ( int align <identifiersep> x ) { text <identifiersep> align ( align <identifiersep> x , baseline ) ; } <comment> <ect>
<comment> <LOG> if ( ( buffer [ index ] == ' ' ) || ( index == stop ) ) { float word <identifiersep> width = 0 ; if ( index > word <identifiersep> start ) { <comment> <ect>
return null ; } <comment> <LOG> if ( tiff [ i ] != tiff <identifiersep> header [ i ] ) { return null ; } } p <identifiersep> image outgoing = new p <identifiersep> image ( width , height , rgb ) ; int index = <number_literal> ; count /= <number_literal> ; for ( int i = 0 ; i < count ; i ++ ) { <ect>
output <identifiersep> stream os = null ; if ( save <identifiersep> image <identifiersep> formats == null ) { save <identifiersep> image <identifiersep> formats = javax . imageio . image <identifiersep> io . get <identifiersep> writer <identifiersep> format <identifiersep> names ( ) ; } if ( save <identifiersep> image <identifiersep> formats != null ) { for ( int i = 0 ; i < save <identifiersep> image <identifiersep> formats . length ; i ++ ) { if ( filename . ends <identifiersep> with ( <string_literal> + save <identifiersep> image <identifiersep> formats [ i ] ) ) { <LOG> if ( ! save <identifiersep> image <identifiersep> io ( filename ) ) { return false ; } return true ; } } } if ( filename . to <identifiersep> lower <identifiersep> case ( ) . ends <identifiersep> with ( <string_literal> ) ) { os = new buffered <identifiersep> output <identifiersep> stream ( new file <identifiersep> output <identifiersep> stream ( filename ) , <number_literal> ) ; success = save <identifiersep> tga ( os ) ; <comment> <ect>
image <identifiersep> cache cash = ( image <identifiersep> cache ) get <identifiersep> cache ( who ) ; <comment> <LOG> if ( cash == null ) { cash = new image <identifiersep> cache ( ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
if ( p <identifiersep> applet . platform == p <identifiersep> constants . macosx ) { for ( screen s : screen . get <identifiersep> screens ( ) ) { render <identifiersep> scale = math . max ( render <identifiersep> scale , s . get <identifiersep> render <identifiersep> scale ( ) ) ; } } float ui <identifiersep> scale = screen . get <identifiersep> main <identifiersep> screen ( ) . get <identifiersep> ui <identifiersep> scale ( ) ; if ( sketch . pixel <identifiersep> density == <number_literal> && render <identifiersep> scale < <number_literal> ) { sketch . pixel <identifiersep> density = 1 ; <LOG> sketch . g . pixel <identifiersep> density = 1 ; } <comment> <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; smooth = 0 ; } scene <identifiersep> antialiasing scene <identifiersep> antialiasing = ( smooth == 0 ) ? scene <identifiersep> antialiasing . disabled : scene <identifiersep> antialiasing . balanced ; stage . set <identifiersep> scene ( new scene ( stack <identifiersep> pane , width , height , false , scene <identifiersep> antialiasing ) ) ; <comment> <ect>
try { draw <identifiersep> exception = draw <identifiersep> exception <identifiersep> queue . take ( ) ; } catch ( interrupted <identifiersep> exception e ) { return ; } <comment> <LOG> if ( draw <identifiersep> exception instanceof thread <identifiersep> death ) { <comment> <ect>
int index = index ( key ) ; if ( index != - 1 ) { remove <identifiersep> index ( index ) ; } return index ; } public string remove <identifiersep> index ( int index ) { if ( index < 0 || index >= count ) { <LOG> throw new array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception ( index ) ; } string key = keys [ index ] ; indices . remove ( keys [ index ] ) ; for ( int i = index ; i < count - 1 ; i ++ ) { keys [ i ] = keys [ i + 1 ] ; values [ i ] = values [ i + 1 ] ; <ect>
row ++ ; } if ( row % <number_literal> == 0 ) { <comment> <LOG> <comment> try { <comment> <ect>
char [ ] temp = new char [ c . length + 1 + next <identifiersep> line . length ( ) ] ; p <identifiersep> applet . array <identifiersep> copy ( c , temp , c . length ) ; <comment> <LOG> return handle ( new string ( temp ) , reader ) ; <comment> <ect>
<comment> <LOG> for ( xml sheet : sheets ) { if ( worksheet == null || worksheet . equals ( sheet . get <identifiersep> string ( <string_literal> ) ) ) { ods <identifiersep> parse <identifiersep> sheet ( sheet , header ) ; found = true ; if ( worksheet == null ) { break ; <comment> <ect>
<comment> <LOG> ods <identifiersep> append <identifiersep> not <identifiersep> null ( kid , cell <identifiersep> buffer ) ; <comment> <ect>
if ( enclosing <identifiersep> class == null ) { con = target . get <identifiersep> declared <identifiersep> constructor ( ) ; <comment> <LOG> if ( ! con . is <identifiersep> accessible ( ) ) { con . set <identifiersep> accessible ( true ) ; } } catch ( security <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
if ( get <identifiersep> column <identifiersep> index ( name , false ) != - 1 ) { <comment> <LOG> } else { } } int index = 0 ; try { for ( table <identifiersep> row row : rows ( ) ) { object item = null ; if ( enclosing <identifiersep> class == null ) { <ect>
string s = get <identifiersep> string ( row , column ) ; index <identifiersep> data [ row ] = categories . index ( s ) ; } column <identifiersep> categories [ column ] = categories ; columns [ column ] = index <identifiersep> data ; break ; } default : { <LOG> throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } } column <identifiersep> types [ column ] = new <identifiersep> type ; } <comment> public void set <identifiersep> table <identifiersep> type ( string type ) { <ect>
private void writeln ( print <identifiersep> writer writer ) throws io <identifiersep> exception { for ( string str : index <identifiersep> to <identifiersep> data ) { writer . println ( str ) ; } writer . flush ( ) ; writer . close ( ) ; } void read ( data <identifiersep> input <identifiersep> stream input ) throws io <identifiersep> exception { <LOG> int count = input . read <identifiersep> int ( ) ; data <identifiersep> to <identifiersep> index = new hash <identifiersep> map < > ( count ) ; for ( int i = 0 ; i < count ; i ++ ) { string str = input . read <identifiersep> utf ( ) ; <comment> <ect>
while ( ( line = reader . read <identifiersep> line ( ) ) != null ) { convert <identifiersep> row ( output , tsv ? p <identifiersep> applet . split ( line , ' \\ t' ) : split <identifiersep> line <identifiersep> csv ( line , reader ) ) ; row ++ ; if ( row % <number_literal> == 0 ) { if ( row < row <identifiersep> count ) { int pct = ( <number_literal> * row ) / row <identifiersep> count ; <LOG> if ( pct != prev ) { prev = pct ; } } <comment> <ect>
return false ; } protected int create <identifiersep> shader ( int shader <identifiersep> type , string source ) { int shader = create <identifiersep> shader ( shader <identifiersep> type ) ; if ( shader != 0 ) { shader <identifiersep> source ( shader , source ) ; compile <identifiersep> shader ( shader ) ; <LOG> if ( ! compiled ( shader ) ) { system . err . println ( get <identifiersep> shader <identifiersep> info <identifiersep> log ( shader ) ) ; delete <identifiersep> shader ( shader ) ; shader = 0 ; } } return shader ; } protected int create <identifiersep> program ( int vertex <identifiersep> shader , int fragment <identifiersep> shader ) { <ect>
long dy = ( long ) miter [ 1 ] - y0 ; long a = ( dy * m00 - dx * m10 ) > > <number_literal> ; long b = ( dy * m01 - dx * m11 ) > > <number_literal> ; long len <identifiersep> sq = a * a + b * b ; if ( len <identifiersep> sq < miter <identifiersep> limit <identifiersep> sq ) { emit <identifiersep> line <identifiersep> to ( miter [ 0 ] , miter [ 1 ] , color , rev ) ; } } <LOG> public void move <identifiersep> to ( int x0 , int y0 , int c0 ) { if ( line <identifiersep> to <identifiersep> origin ) { <comment> <ect>
this . join <identifiersep> segment = false ; this . prev = line <identifiersep> path . seg <identifiersep> moveto ; } boolean join <identifiersep> segment = false ; public void line <identifiersep> join ( ) { <comment> <LOG> public void line <identifiersep> to ( int x1 , int y1 , int c1 ) { if ( line <identifiersep> to <identifiersep> origin ) { if ( x1 == sx0 && y1 == sy0 ) { <comment> <ect>
int h = sketch . height ; if ( sketch . display <identifiersep> width < w ) { w = sketch . display <identifiersep> width ; } if ( sketch . display <identifiersep> height < h ) { h = sketch . display <identifiersep> height ; } <comment> <LOG> <comment> sketch <identifiersep> width = sketch . sketch <identifiersep> width ( ) ; sketch <identifiersep> height = sketch . sketch <identifiersep> height ( ) ; <comment> <ect>
} ) ; draw <identifiersep> exception <identifiersep> handler = new thread ( new runnable ( ) { public void run ( ) { synchronized ( draw <identifiersep> exception <identifiersep> mutex ) { try { while ( draw <identifiersep> exception == null ) { <LOG> draw <identifiersep> exception <identifiersep> mutex . wait ( ) ; } if ( draw <identifiersep> exception != null ) { throwable cause = draw <identifiersep> exception . get <identifiersep> cause ( ) ; if ( cause instanceof thread <identifiersep> death ) { <comment> <ect>
if ( sketch . sketch <identifiersep> full <identifiersep> screen ( ) ) { return ; } int x = window . get <identifiersep> x ( ) - window . get <identifiersep> insets ( ) . get <identifiersep> left <identifiersep> width ( ) ; int y = window . get <identifiersep> y ( ) - window . get <identifiersep> insets ( ) . get <identifiersep> top <identifiersep> height ( ) ; int w = window . get <identifiersep> width ( ) + window . get <identifiersep> insets ( ) . get <identifiersep> total <identifiersep> width ( ) ; int h = window . get <identifiersep> height ( ) + window . get <identifiersep> insets ( ) . get <identifiersep> total <identifiersep> height ( ) ; <LOG> if ( location != null ) { window . set <identifiersep> top <identifiersep> level <identifiersep> position ( location [ 0 ] , location [ 1 ] ) ; } else if ( editor <identifiersep> location != null ) { <comment> <ect>
if ( display . get <identifiersep> edt <identifiersep> util ( ) . is <identifiersep> current <identifiersep> thread <identifiersep> edt ( ) ) { <comment> <LOG> p <identifiersep> graphics . show <identifiersep> warning ( <string_literal> ) ; } request <identifiersep> focus ( ) ; } if ( ! sketch . finished ) { pgl . get <identifiersep> gl ( drawable ) ; int pframe <identifiersep> count = sketch . frame <identifiersep> count ; sketch . handle <identifiersep> draw ( ) ; <ect>
native <identifiersep> mouse <identifiersep> event ( e , mouse <identifiersep> event . wheel ) ; } @ override public void mouse <identifiersep> entered ( com . jogamp . newt . event . mouse <identifiersep> event e ) { <comment> <LOG> public void mouse <identifiersep> exited ( com . jogamp . newt . event . mouse <identifiersep> event e ) { native <identifiersep> mouse <identifiersep> event ( e , mouse <identifiersep> event . exit ) ; } } <comment> <ect>
<comment> <LOG> public void paint ( graphics screen ) { <comment> <ect>
<comment> <LOG> <comment> synchronized protected void render ( ) { <ect>
@ override public void init <identifiersep> frame ( final p <identifiersep> applet sketch ) { <comment> this . sketch = sketch ; graphics <identifiersep> environment environment = graphics <identifiersep> environment . get <identifiersep> local <identifiersep> graphics <identifiersep> environment ( ) ; <LOG> int display <identifiersep> num = sketch . sketch <identifiersep> display ( ) ; if ( display <identifiersep> num > 0 ) { <comment> <ect>
sketch <identifiersep> width , sketch <identifiersep> height ) ; <comment> <LOG> frame . set <identifiersep> visible ( true ) ; <comment> <ect>
<comment> <LOG> if ( gc == null ) { graphics <identifiersep> environment ge = graphics <identifiersep> environment . get <identifiersep> local <identifiersep> graphics <identifiersep> environment ( ) ; gc = ge . get <identifiersep> default <identifiersep> screen <identifiersep> device ( ) . get <identifiersep> default <identifiersep> configuration ( ) ; } <comment> <ect>
} else { int [ ] [ ] interp = new int [ span ] [ <number_literal> ] ; int prev = 0 ; for ( int i = 1 ; i < count ; i ++ ) { int c0 = color [ i - 1 ] ; int c1 = color [ i ] ; <LOG> int last = ( int ) ( offset [ i ] * ( span - 1 ) ) ; for ( int j = prev ; j < = last ; j ++ ) { float btwn = p <identifiersep> applet . norm ( j , prev , last ) ; interp [ j ] [ 0 ] = ( int ) p <identifiersep> applet . lerp ( ( c0 > > <number_literal> ) & 0xff , ( c1 > > <number_literal> ) & 0xff , btwn ) ; interp [ j ] [ 1 ] = ( int ) p <identifiersep> applet . lerp ( ( c0 > > <number_literal> ) & 0xff , ( c1 > > <number_literal> ) & 0xff , btwn ) ; interp [ j ] [ <number_literal> ] = ( int ) p <identifiersep> applet . lerp ( c0 & 0xff , c1 & 0xff , btwn ) ; <ect>
float px = ( x + i ) - tx1 ; float py = ( y + j ) - ty1 ; <comment> <LOG> if ( which > interp . length - 1 ) which = interp . length - 1 ; data [ index ++ ] = interp [ which ] [ 0 ] ; data [ index ++ ] = interp [ which ] [ 1 ] ; data [ index ++ ] = interp [ which ] [ <number_literal> ] ; data [ index ++ ] = interp [ which ] [ <number_literal> ] ; } } } raster . set <identifiersep> pixels ( 0 , 0 , w , h , data ) ; <ect>
if ( gradient instanceof linear <identifiersep> gradient ) { <comment> <LOG> } else if ( gradient instanceof radial <identifiersep> gradient ) { radial <identifiersep> gradient grad = ( radial <identifiersep> gradient ) gradient ; return new radial <identifiersep> gradient <identifiersep> paint ( grad . cx , grad . cy , grad . r , grad . offset , grad . color , grad . count , opacity ) ; } return null ; <ect>
<comment> <LOG> if ( comp == null ) { comp = parent . frame ; } if ( comp != null ) { gc = comp . get <identifiersep> graphics <identifiersep> configuration ( ) ; } } <comment> <ect>
<comment> <LOG> int high = height * pixel <identifiersep> density ; image = gc . create <identifiersep> compatible <identifiersep> image ( wide , high , transparency . translucent ) ; <comment> <ect>
redraw ( ) ; <comment> <LOG> synchronized ( image ) { image . get <identifiersep> graphics ( ) . draw <identifiersep> image ( offscreen , 0 , 0 , null ) ; } } else { <comment> <ect>
<comment> <LOG> <comment> <ect>
} else if ( mode == pie ) { <comment> <LOG> if ( fill ) { arc . set <identifiersep> arc ( x , y , w , h , start , sweep , fill <identifiersep> mode ) ; fill <identifiersep> shape ( arc ) ; } if ( stroke ) { <comment> <ect>
image <identifiersep> cache cash = ( image <identifiersep> cache ) get <identifiersep> cache ( who ) ; <comment> <LOG> if ( cash == null ) { cash = new image <identifiersep> cache ( ) ; <comment> <ect>
buffered <identifiersep> image image ; <comment> <LOG> <comment> <ect>
buffered <identifiersep> image . type <identifiersep> int <identifiersep> argb ) ; } writable <identifiersep> raster wr = image . get <identifiersep> raster ( ) ; if ( tint ) { if ( tinted <identifiersep> temp == null || tinted <identifiersep> temp . length != source . pixel <identifiersep> width ) { tinted <identifiersep> temp = new int [ source . pixel <identifiersep> width ] ; } int a2 = ( tint <identifiersep> color > > <number_literal> ) & 0xff ; <LOG> <comment> <ect>
<comment> <LOG> if ( font != null ) { <comment> <ect>
<string_literal> ) ; system . out . println ( <string_literal> + current <identifiersep> version ) ; if ( current <identifiersep> version != null ) { string java <identifiersep> home = registry . get <identifiersep> string <identifiersep> value ( registry <identifiersep> root <identifiersep> key . local <identifiersep> machine , jdk <identifiersep> key + <string_literal> + current <identifiersep> version , <LOG> <string_literal> ) ; if ( java <identifiersep> home != null ) { string jcp = system . get <identifiersep> property ( <string_literal> ) ; string tools <identifiersep> jar = java <identifiersep> home + <string_literal> ; system . set <identifiersep> property ( <string_literal> , jcp + file . path <identifiersep> separator + tools <identifiersep> jar ) ; <ect>
<string_literal> + e + <string_literal> ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> <comment> } public file get <identifiersep> settings <identifiersep> folder ( ) throws exception { return new file ( get <identifiersep> library <identifiersep> folder ( ) , <string_literal> ) ; } public file get <identifiersep> default <identifiersep> sketchbook <identifiersep> folder ( ) throws exception { <ect>
line = line . substring ( 0 , comment <identifiersep> marker ) ; } <comment> <LOG> if ( filename != null ) { system . err . println ( <string_literal> + line ) ; } } else { string attr = line . substring ( 0 , equals ) . trim ( ) ; string valu = line . substring ( equals + 1 ) . trim ( ) ; settings . set ( attr , valu ) ; <ect>
if ( ! files . is <identifiersep> symbolic <identifiersep> link ( dir . to <identifiersep> path ( ) ) ) { file [ ] files = dir . list <identifiersep> files ( ) ; if ( files != null ) { for ( file child : files ) { if ( child . is <identifiersep> file ( ) ) { boolean deleted = child . delete ( ) ; <LOG> if ( ! deleted && print <identifiersep> error <identifiersep> messages ) { } result & = deleted ; } else if ( child . is <identifiersep> directory ( ) ) { result & = remove <identifiersep> dir ( child , print <identifiersep> error <identifiersep> messages ) ; } } } } boolean deleted = dir . delete ( ) ; if ( ! deleted && print <identifiersep> error <identifiersep> messages ) { <ect>
<comment> static public string <identifiersep> list package <identifiersep> list <identifiersep> from <identifiersep> class <identifiersep> path ( string path ) { <comment> <LOG> for ( int i = 0 ; i < pieces . length ; i ++ ) { if ( pieces [ i ] . length ( ) == 0 ) continue ; if ( pieces [ i ] . to <identifiersep> lower <identifiersep> case ( ) . ends <identifiersep> with ( <string_literal> ) || pieces [ i ] . to <identifiersep> lower <identifiersep> case ( ) . ends <identifiersep> with ( <string_literal> ) ) { <comment> <ect>
string pname = name . substring ( 0 , slash ) ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> font [ ] fonts = ge . get <identifiersep> all <identifiersep> fonts ( ) ; <comment> <ect>
<comment> string [ ] font <identifiersep> list = new string [ fonts . length ] ; table = new hash <identifiersep> map < string , font > ( ) ; int index = 0 ; for ( int i = 0 ; i < fonts . length ; i ++ ) { <LOG> <comment> <ect>
char <identifiersep> selector = new character <identifiersep> selector ( ) ; } public void run ( ) { set <identifiersep> visible ( true ) ; } public void update ( ) { int fontsize = 0 ; try { <LOG> fontsize = integer . parse <identifiersep> int ( size <identifiersep> selector . get <identifiersep> text ( ) . trim ( ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e2 ) { } <comment> <ect>
null , <comment> <LOG> public void paint <identifiersep> component ( graphics g ) { graphics2d g2 = ( graphics2d ) g ; g2 . set <identifiersep> color ( color . white ) ; dimension dim = get <identifiersep> size ( ) ; g2 . fill <identifiersep> rect ( 0 , 0 , dim . width , dim . height ) ; g2 . set <identifiersep> color ( color . black ) ; <ect>
default <identifiersep> list <identifiersep> model model = ( default <identifiersep> list <identifiersep> model ) charset <identifiersep> list . get <identifiersep> model ( ) ; int index = 0 ; for ( int i = 0 ; i < blocks . length ; i ++ ) { if ( ( ( j <identifiersep> check <identifiersep> box ) model . get ( i ) ) . is <identifiersep> selected ( ) ) { for ( int j = block <identifiersep> start [ i ] ; j < = block <identifiersep> stop [ i ] ; j ++ ) { charset [ index ++ ] = ( char ) j ; } } } <LOG> charset = p <identifiersep> applet . subset ( charset , 0 , index ) ; } return charset ; } <comment> <ect>
util . copy <identifiersep> dir ( template <identifiersep> folder , sketch <identifiersep> folder ) ; file template <identifiersep> file = new file ( sketch <identifiersep> folder , <string_literal> + get <identifiersep> default <identifiersep> extension ( ) ) ; if ( ! template <identifiersep> file . rename <identifiersep> to ( newbie <identifiersep> file ) ) { system . err . println ( <string_literal> ) ; } } else { <LOG> if ( ! newbie <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ) { } } } catch ( exception e ) { <comment> <ect>
if ( import <identifiersep> menu == null ) { rebuild <identifiersep> import <identifiersep> menu ( ) ; } return import <identifiersep> menu ; } public void rebuild <identifiersep> import <identifiersep> menu ( ) { <comment> <LOG> } else { import <identifiersep> menu . remove <identifiersep> all ( ) ; } j <identifiersep> menu <identifiersep> item add <identifiersep> lib = new j <identifiersep> menu <identifiersep> item ( language . text ( <string_literal> ) ) ; add <identifiersep> lib . add <identifiersep> action <identifiersep> listener ( new action <identifiersep> listener ( ) { public void action <identifiersep> performed ( action <identifiersep> event e ) { contribution <identifiersep> manager . open <identifiersep> libraries ( ) ; <ect>
<comment> <LOG> <comment> <ect>
if ( android <identifiersep> export <identifiersep> str != null ) { android <identifiersep> export <identifiersep> list = p <identifiersep> applet . split <identifiersep> tokens ( android <identifiersep> export <identifiersep> str , <string_literal> ) ; } else { android <identifiersep> export <identifiersep> list = base <identifiersep> list ; } <comment> <LOG> string host <identifiersep> platform = platform . get <identifiersep> name ( ) ; <comment> <ect>
<comment> <LOG> native <identifiersep> library <identifiersep> folder = host <identifiersep> library ; } if ( host <identifiersep> platform . equals ( <string_literal> ) && system . get <identifiersep> property ( <string_literal> ) . equals ( <string_literal> ) ) { host <identifiersep> library = new file ( library <identifiersep> folder , <string_literal> ) ; if ( host <identifiersep> library . exists ( ) ) { native <identifiersep> library <identifiersep> folder = host <identifiersep> library ; } } if ( host <identifiersep> platform . equals ( <string_literal> ) && system . get <identifiersep> property ( <string_literal> ) . equals ( <string_literal> ) ) { <ect>
<comment> <LOG> if ( base . debug ) { system . err . println ( get <identifiersep> path ( ) ) ; system . err . println ( <string_literal> ) ; for ( library library : libraries ) { system . err . println ( library . get <identifiersep> path ( ) ) ; } system . err . println ( <string_literal> + pkg ) ; <ect>
<comment> public process <identifiersep> result execute ( string outgoing ) throws interrupted <identifiersep> exception , io <identifiersep> exception { final string <identifiersep> writer out <identifiersep> writer = new string <identifiersep> writer ( ) ; final string <identifiersep> writer err <identifiersep> writer = new string <identifiersep> writer ( ) ; final long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> final string pretty <identifiersep> command = to <identifiersep> string ( ) ; <comment> <ect>
public stream <identifiersep> pump add <identifiersep> target ( final writer out ) { outs . add ( new writer <identifiersep> line <identifiersep> processor ( out ) ) ; return this ; } public stream <identifiersep> pump add <identifiersep> target ( final line <identifiersep> processor out ) { outs . add ( out ) ; return this ; } <LOG> public void start ( ) { <comment> <ect>
<comment> <LOG> } catch ( exception e ) { <comment> <ect>
} catch ( exception e ) { <comment> <LOG> <comment> <ect>
public sketch <identifiersep> code ( file file , string extension ) { this . file = file ; this . extension = extension ; make <identifiersep> pretty <identifiersep> name ( ) ; try { load ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } protected void make <identifiersep> pretty <identifiersep> name ( ) { pretty <identifiersep> name = file . get <identifiersep> name ( ) ; int dot = pretty <identifiersep> name . last <identifiersep> index <identifiersep> of ( ' . ' ) ; pretty <identifiersep> name = pretty <identifiersep> name . substring ( 0 , dot ) ; } public file get <identifiersep> file ( ) { <ect>
return file . exists ( ) ; } protected boolean file <identifiersep> read <identifiersep> only ( ) { return ! file . can <identifiersep> write ( ) ; } protected boolean delete <identifiersep> file ( ) { return file . delete ( ) ; } protected boolean rename <identifiersep> to ( file what , string ext ) { <LOG> <comment> <ect>
<comment> public void load ( ) throws io <identifiersep> exception { program = util . load <identifiersep> file ( file ) ; if ( program == null ) { <LOG> system . err . println ( <string_literal> + file ) ; throw new io <identifiersep> exception ( <string_literal> + file ) ; } <comment> <ect>
if ( program . index <identifiersep> of ( ' \\ 0' ) != - 1 ) { program = program . replace <identifiersep> all ( <string_literal> , <string_literal> ) ; } saved <identifiersep> program = program ; <comment> <LOG> system . err . println ( file . get <identifiersep> name ( ) + <string_literal> ) ; <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( ) ; } set <identifiersep> last <identifiersep> modified ( ) ; <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( ) ; } set <identifiersep> last <identifiersep> modified ( ) ; set <identifiersep> modified ( false ) ; } <comment> <ect>
if ( c instanceof j <identifiersep> popup <identifiersep> menu ) c = ( ( j <identifiersep> popup <identifiersep> menu ) c ) . get <identifiersep> invoker ( ) ; else c = c . get <identifiersep> parent ( ) ; } } } <comment> <LOG> system . err . println ( <string_literal> ) ; return null ; } <comment> <ect>
<comment> <LOG> if ( ! font <identifiersep> family . equals ( plain <identifiersep> font . get <identifiersep> family ( ) ) ) { font <identifiersep> family = <string_literal> ; preferences . set ( <string_literal> , font <identifiersep> family ) ; plain <identifiersep> font = new font ( font <identifiersep> family , font . plain , font <identifiersep> size ) ; } bold <identifiersep> font = new font ( font <identifiersep> family , font . bold , font <identifiersep> size ) ; antialias = preferences . get <identifiersep> boolean ( <string_literal> ) ; <ect>
<comment> <LOG> if ( text <identifiersep> area . is <identifiersep> caret <identifiersep> visible ( ) ) { int offset = text <identifiersep> area . get <identifiersep> caret <identifiersep> position ( ) - text <identifiersep> area . get <identifiersep> line <identifiersep> start <identifiersep> offset ( line ) ; int caret <identifiersep> x = text <identifiersep> area .  <identifiersep> offset <identifiersep> to <identifiersep> x ( line , offset ) ; int caret <identifiersep> width = ( ( defaults . block <identifiersep> caret || text <identifiersep> area . is <identifiersep> overwrite <identifiersep> enabled ( ) ) ? <ect>
* the syntax package . * < p > * to use it in your app , treat it like any other component , for example : * < pre > j <identifiersep> edit <identifiersep> text <identifiersep> area ta = new j <identifiersep> edit <identifiersep> text <identifiersep> area ( ) ; * ta . set <identifiersep> token <identifiersep> marker ( new java <identifiersep> token <identifiersep> marker ( ) ) ; * ta . set <identifiersep> text ( <string_literal> <LOG> <comment> <ect>
@ override public void mouse <identifiersep> wheel <identifiersep> moved ( mouse <identifiersep> wheel <identifiersep> event e ) { if ( scroll <identifiersep> bars <identifiersep> initialized ) { if ( e . get <identifiersep> scroll <identifiersep> type ( ) == mouse <identifiersep> wheel <identifiersep> event . wheel <identifiersep> unit <identifiersep> scroll ) { int scroll <identifiersep> amount = e . get <identifiersep> units <identifiersep> to <identifiersep> scroll ( ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
} catch ( exception e ) { get <identifiersep> toolkit ( ) . beep ( ) ; system . err . println ( <string_literal> ) ; data <identifiersep> flavor [ ] flavors = clipboard . get <identifiersep> available <identifiersep> data <identifiersep> flavors ( ) ; for ( data <identifiersep> flavor f : flavors ) { try { <LOG> object o = clipboard . get <identifiersep> contents ( this ) . get <identifiersep> transfer <identifiersep> data ( f ) ; } catch ( exception ex ) { ex . print <identifiersep> stack <identifiersep> trace ( ) ; } } } } } <comment> <ect>
<comment> <LOG> if ( ! has <identifiersep> focus ( ) ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
<comment> <LOG> } catch ( no <identifiersep> such <identifiersep> method <identifiersep> error nsme ) { if ( debug ) nsme . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { system . err . println ( folder . get <identifiersep> name ( ) + <string_literal> ) ; if ( debug ) ncdfe . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ite ) { <ect>
} catch ( no <identifiersep> such <identifiersep> method <identifiersep> error nsme ) { system . err . println ( folder . get <identifiersep> name ( ) + <string_literal> ) ; if ( debug ) nsme . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { system . err . println ( folder . get <identifiersep> name ( ) + <string_literal> ) ; if ( debug ) ncdfe . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( invocation <identifiersep> target <identifiersep> exception ite ) { if ( debug ) ite . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( ignorable <identifiersep> exception ig ) { messages . log ( ig . get <identifiersep> message ( ) ) ; if ( debug ) ig . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( throwable e ) { <ect>
<comment> <LOG> final string mode <identifiersep> resource <identifiersep> path = mode <identifiersep> info [ 1 ] ; mode <identifiersep> contribution mc = mode <identifiersep> contribution . load ( this , new file ( mode <identifiersep> resource <identifiersep> path ) , mode <identifiersep> class ) ; contrib <identifiersep> modes . add ( mc ) ; file key = get <identifiersep> file <identifiersep> for <identifiersep> contrib ( mc , known ) ; if ( key != null ) { known . remove ( key ) ; <ect>
for ( tool tool : contrib <identifiersep> tools ) { try { tool . init ( this ) ; <comment> <LOG> } catch ( verify <identifiersep> error ve ) { <string_literal> ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> error nsme ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; system . err . println ( <string_literal> + nsme . get <identifiersep> message ( ) + <string_literal> ) ; <ect>
<comment> <LOG> <string_literal> ) ; messages . loge ( <string_literal> , nsme ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; system . err . println ( <string_literal> + ncdfe . get <identifiersep> message ( ) + <string_literal> ) ; <ect>
system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; system . err . println ( <string_literal> + nsme . get <identifiersep> message ( ) + <string_literal> ) ; messages . loge ( <string_literal> , nsme ) ; } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <LOG> <string_literal> ) ; messages . loge ( <string_literal> , ncdfe ) ; } catch ( abstract <identifiersep> method <identifiersep> error ame ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; <comment> <ect>
system . err . println ( <string_literal> + ncdfe . get <identifiersep> message ( ) + <string_literal> ) ; messages . loge ( <string_literal> , ncdfe ) ; } catch ( abstract <identifiersep> method <identifiersep> error ame ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> + <string_literal> ) ; <comment> <LOG> } catch ( error err ) { err . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( exception ex ) { system . err . println ( <string_literal> + tool . get <identifiersep> menu <identifiersep> title ( ) + <string_literal> ) ; ex . print <identifiersep> stack <identifiersep> trace ( ) ; } } } protected void init <identifiersep> internal <identifiersep> tool ( string class <identifiersep> name ) { <ect>
private void save <identifiersep> mode <identifiersep> settings ( final file sketch <identifiersep> props , final mode mode ) { try { final settings settings = new settings ( sketch <identifiersep> props ) ; settings . set ( <string_literal> , mode . get <identifiersep> title ( ) ) ; settings . set ( <string_literal> , mode . get <identifiersep> identifier ( ) ) ; settings . save ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } string get <identifiersep> default <identifiersep> mode <identifiersep> identifier ( ) { return <string_literal> ; } public mode get <identifiersep> default <identifiersep> mode ( ) { return core <identifiersep> modes [ 0 ] ; } <comment> <ect>
public boolean handle <identifiersep> close ( editor editor , boolean mode <identifiersep> switch ) { <comment> <LOG> editor . internal <identifiersep> close <identifiersep> runner ( ) ; if ( editors . size ( ) == 1 ) { <comment> <ect>
return new tool <identifiersep> contribution ( folder ) ; } catch ( ignorable <identifiersep> exception ig ) { messages . log ( ig . get <identifiersep> message ( ) ) ; } catch ( verify <identifiersep> error ve ) { <comment> <LOG> if ( ncdfe . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { } } catch ( throwable e ) { <comment> <ect>
string arg = <string_literal> ; system . err . println ( language . interpolate ( arg , contrib . get <identifiersep> name ( ) ) ) ; } } catch ( malformed <identifiersep> url <identifiersep> exception e1 ) { system . err . println ( language . interpolate ( <string_literal> , contrib . get <identifiersep> name ( ) ) ) ; } } editor . get <identifiersep> text <identifiersep> area ( ) . set <identifiersep> editable ( true ) ; <LOG> editor . status <identifiersep> empty ( ) ; for ( string l : installed <identifiersep> lib <identifiersep> list ) { system . out . println ( <string_literal> + l ) ; } } <comment> <ect>
static public mode <identifiersep> contribution load ( base base , file folder , string search <identifiersep> name ) { try { return new mode <identifiersep> contribution ( base , folder , search <identifiersep> name ) ; } catch ( ignorable <identifiersep> exception ig ) { messages . log ( ig . get <identifiersep> message ( ) ) ; <LOG> } catch ( throwable err ) { <comment> <ect>
<comment> <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; } set <identifiersep> pretty <identifiersep> version ( properties . get ( <string_literal> ) ) ; try { last <identifiersep> updated = long . parse <identifiersep> long ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <ect>
system . err . println ( <string_literal> ) ; } set <identifiersep> pretty <identifiersep> version ( properties . get ( <string_literal> ) ) ; try { last <identifiersep> updated = long . parse <identifiersep> long ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { last <identifiersep> updated = 0 ; <LOG> <comment> <ect>
url [ ] url <identifiersep> list = new url [ archives . length ] ; for ( int j = 0 ; j < url <identifiersep> list . length ; j ++ ) { messages . log ( <string_literal> + archives [ j ] + <string_literal> + get <identifiersep> name ( ) ) ; url <identifiersep> list [ j ] = archives [ j ] . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ; } <comment> <LOG> messages . log ( <string_literal> + loader ) ; <comment> <ect>
return is <identifiersep> flagged ( folder , update <identifiersep> flagged ) ; } <comment> <LOG> boolean is <identifiersep> restart <identifiersep> flagged ( ) { return is <identifiersep> flagged ( get <identifiersep> folder ( ) , restart <identifiersep> flag ) ; } static void clear <identifiersep> restart <identifiersep> flags ( file folder ) { file restart <identifiersep> flag = new file ( folder , restart <identifiersep> flag ) ; if ( restart <identifiersep> flag . exists ( ) ) { restart <identifiersep> flag . delete ( ) ; <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } return null ; } } <ect>
field . add <identifiersep> key <identifiersep> listener ( new key <identifiersep> adapter ( ) { <comment> <LOG> public void key <identifiersep> typed ( key <identifiersep> event event ) { char ch = event . get <identifiersep> key <identifiersep> char ( ) ; if ( ( ch == ' <identifiersep> ' ) || ( ch == ' . ' ) || <comment> <ect>
for ( int i = 0 ; i < code <identifiersep> count ; i ++ ) { if ( code [ i ] == which ) { for ( int j = i ; j < code <identifiersep> count - 1 ; j ++ ) { code [ j ] = code [ j + 1 ] ; } code <identifiersep> count -- ; code = ( sketch <identifiersep> code [ ] ) p <identifiersep> applet . shorten ( code ) ; <LOG> return ; } } } <comment> public void handle <identifiersep> prev <identifiersep> code ( ) { int prev = current <identifiersep> index - 1 ; <ect>
code <identifiersep> folder = new file ( folder , <string_literal> ) ; data <identifiersep> folder = new file ( folder , <string_literal> ) ; <comment> <LOG> calc <identifiersep> modified ( ) ; editor . update <identifiersep> title ( ) ; editor . get <identifiersep> base ( ) . rebuild <identifiersep> sketchbook <identifiersep> menus ( ) ; recent . rename ( editor , old <identifiersep> path ) ; <comment> <ect>
return true ; } } <comment> <LOG> code [ i ] . file <identifiersep> exists ( ) ) { return true ; } } return false ; } <comment> <ect>
show <identifiersep> warning ( title , message , null ) ; } <comment> static public void show <identifiersep> warning ( string title , string message , throwable e ) { if ( title == null ) title = <string_literal> ; <LOG> if ( base . is <identifiersep> command <identifiersep> line ( ) ) { } else { j <identifiersep> option <identifiersep> pane . show <identifiersep> message <identifiersep> dialog ( new frame ( ) , message , title , j <identifiersep> option <identifiersep> pane . warning <identifiersep> message ) ; } if ( e != null ) e . print <identifiersep> stack <identifiersep> trace ( ) ; } <comment> <ect>
<comment> static public void show <identifiersep> error ( string title , string message , throwable e ) { if ( title == null ) title = <string_literal> ; <LOG> if ( base . is <identifiersep> command <identifiersep> line ( ) ) { } else { j <identifiersep> option <identifiersep> pane . show <identifiersep> message <identifiersep> dialog ( new frame ( ) , message , title , j <identifiersep> option <identifiersep> pane . error <identifiersep> message ) ; } if ( e != null ) e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( 1 ) ; <ect>
result = pane . get <identifiersep> value ( ) ; } for ( int i = 0 ; i < options . length ; i ++ ) { if ( result != null && result . equals ( options [ i ] ) ) return i ; } return - 1 ; } <comment> <LOG> if ( base . debug ) { } } static public void log ( string message ) { if ( base . debug ) { system . out . println ( message ) ; } } static public void logf ( string message , object . . . args ) { if ( base . debug ) { <ect>
string [ ] pieces = pair . split ( <string_literal> ) ; string attr = p <identifiersep> applet . url <identifiersep> decode ( pieces [ 0 ] ) ; string valu = p <identifiersep> applet . url <identifiersep> decode ( pieces [ 1 ] ) ; dict . set ( attr , valu ) ; } } <comment> <LOG> } else if ( e . get <identifiersep> event <identifiersep> type ( ) == hyperlink <identifiersep> event . event <identifiersep> type . activated ) { handle <identifiersep> link ( e . get <identifiersep> url ( ) . to <identifiersep> external <identifiersep> form ( ) ) ; } } } ) ; } <comment> <ect>
font . can <identifiersep> display ( 'i' ) && font . can <identifiersep> display ( 'm' ) && font . can <identifiersep> display ( ' ' ) && font . can <identifiersep> display ( ' . ' ) ) { <comment> <LOG> <comment> <ect>
if ( w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) && w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) && w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) ) { <comment> <LOG> <comment> <ect>
update <identifiersep> rgb ( color . get <identifiersep> rgb ( ) ) ; } public string get <identifiersep> hex <identifiersep> color ( ) { return <string_literal> + p <identifiersep> applet . hex ( red , <number_literal> ) + p <identifiersep> applet . hex ( green , <number_literal> ) + p <identifiersep> applet . hex ( blue , <number_literal> ) ; } public class color <identifiersep> listener implements document <identifiersep> listener { public void changed <identifiersep> update ( document <identifiersep> event e ) { <comment> <LOG> public void remove <identifiersep> update ( document <identifiersep> event e ) { } boolean updating ; public void insert <identifiersep> update ( document <identifiersep> event e ) { if ( updating ) return ; <comment> <ect>
<comment> static class number <identifiersep> document extends plain <identifiersep> document { number <identifiersep> field parent <identifiersep> field ; public number <identifiersep> document ( number <identifiersep> field parent <identifiersep> field ) { <LOG> this . parent <identifiersep> field = parent <identifiersep> field ; } public void insert <identifiersep> string ( int offs , string str , attribute <identifiersep> set a ) throws bad <identifiersep> location <identifiersep> exception { if ( str == null ) return ; char chars [ ] = str . to <identifiersep> char <identifiersep> array ( ) ; int char <identifiersep> count = 0 ; <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
view . set <identifiersep> visible ( true ) ; } <comment> public void sketchbook <identifiersep> callback ( file folder ) { if ( folder != null ) { if ( base != null ) { base . set <identifiersep> sketchbook <identifiersep> folder ( folder ) ; <LOG> <comment> <ect>
super ( language . text ( <string_literal> ) ) ; this . set <identifiersep> enabled ( false ) ; } public void action <identifiersep> performed ( action <identifiersep> event e ) { stop <identifiersep> compound <identifiersep> edit ( ) ; try { undo . redo ( ) ; <LOG> } catch ( cannot <identifiersep> redo <identifiersep> exception ex ) { <comment> <ect>
case ' \\ n' : case ' \\ r' : index ++ ; break ; default : <comment> <LOG> return false ; } } return false ; } protected boolean functionable ( char c ) { return ( c == ' <identifiersep> ' ) || ( c >= 'a' && c < = 'z' ) || ( c >= 'a' && c < = 'z' ) ; } <comment> <ect>
char [ ] c = textarea . get <identifiersep> text ( ) . to <identifiersep> char <identifiersep> array ( ) ; <comment> <LOG> stop ++ ; } } string text = new string ( c , start , stop - start ) . trim ( ) ; <comment> <ect>
if ( text . length ( ) == 0 ) { status <identifiersep> notice ( <string_literal> ) ; } else { char [ ] c = textarea . get <identifiersep> text ( ) . to <identifiersep> char <identifiersep> array ( ) ; int after = math . max ( textarea . get <identifiersep> selection <identifiersep> start ( ) , textarea . get <identifiersep> selection <identifiersep> stop ( ) ) ; if ( check <identifiersep> paren ( c , after , c . length ) ) { <LOG> text += <string_literal> ; } string reference <identifiersep> file = mode . lookup <identifiersep> reference ( text ) ; system . out . println ( <string_literal> + reference <identifiersep> file ) ; if ( reference <identifiersep> file == null ) { status <identifiersep> notice ( <string_literal> + text + <string_literal> ) ; } else { <ect>
show <identifiersep> reference ( reference <identifiersep> file + <string_literal> ) ; } } } protected void handle <identifiersep> find <identifiersep> reference ( ) { string text = textarea . get <identifiersep> selected <identifiersep> text ( ) . trim ( ) ; if ( text . length ( ) == 0 ) { status <identifiersep> notice ( <string_literal> ) ; } else { <LOG> <comment> <ect>
jtp . set <identifiersep> font ( new font ( preferences . get ( <string_literal> ) , font . plain , <number_literal> ) ) ; jtp . set <identifiersep> text ( html . to <identifiersep> string ( ) . replace ( <string_literal> , <string_literal> ) <comment> <LOG> if ( page <identifiersep> format != null ) { printer <identifiersep> job . set <identifiersep> printable ( jtp . get <identifiersep> printable ( null , null ) , page <identifiersep> format ) ; } else { printer <identifiersep> job . set <identifiersep> printable ( jtp . get <identifiersep> printable ( null , null ) ) ; } <comment> <ect>
<comment> <LOG> if ( line < 0 || line >= textarea . get <identifiersep> line <identifiersep> count ( ) ) { } else { textarea . select ( textarea . get <identifiersep> line <identifiersep> start <identifiersep> offset ( line ) , textarea . get <identifiersep> line <identifiersep> stop <identifiersep> offset ( line ) - 1 ) ; } } } <comment> <ect>
<comment> public void rebuild ( ) { <comment> <LOG> public void rebuild <identifiersep> menu ( ) { if ( menu != null ) { menu . remove <identifiersep> all ( ) ; } else { menu = new j <identifiersep> menu ( ) ; popup = menu . get <identifiersep> popup <identifiersep> menu ( ) ; <ect>
void default <identifiersep> location ( list < editor > editors ) { int default <identifiersep> width = toolkit . zoom ( preferences . get <identifiersep> integer ( <string_literal> ) ) ; int default <identifiersep> height = toolkit . zoom ( preferences . get <identifiersep> integer ( <string_literal> ) ) ; default <identifiersep> width = math . min ( default <identifiersep> width , device <identifiersep> bounds . width ) ; <LOG> default <identifiersep> height = math . min ( default <identifiersep> height , device <identifiersep> bounds . height ) ; if ( editors . size ( ) == 0 ) { <comment> <ect>
expand <identifiersep> tree ( tree , nodes [ 0 ] , items , nodes , 1 ) ; } else if ( index < items . length ) { <comment> <LOG> int count = model . get <identifiersep> child <identifiersep> count ( node ) ; for ( int i = 0 ; i < count ; i ++ ) { default <identifiersep> mutable <identifiersep> tree <identifiersep> node child = ( default <identifiersep> mutable <identifiersep> tree <identifiersep> node ) model . get <identifiersep> child ( node , i ) ; if ( items [ index ] . equals ( child . get <identifiersep> user <identifiersep> object ( ) ) ) { nodes [ index ] = child ; expand <identifiersep> tree ( tree , child , items , nodes , index + 1 ) ; <ect>
public void action <identifiersep> performed ( action <identifiersep> event action <identifiersep> event ) { handle <identifiersep> close ( ) ; } } ) ; toolkit . set <identifiersep> icon ( this ) ; <comment> <LOG> public void window <identifiersep> activated ( window <identifiersep> event e ) { <comment> find <identifiersep> field . request <identifiersep> focus <identifiersep> in <identifiersep> window ( ) ; <comment> <ect>
<comment> <LOG> public void handle <identifiersep> close ( ) { find <identifiersep> string = find <identifiersep> field . get <identifiersep> text ( ) ; replace <identifiersep> string = replace <identifiersep> field . get <identifiersep> text ( ) ; <comment> <ect>
static { try { base . init <identifiersep> platform ( ) ; compiler = new ut <identifiersep> compiler ( new file ( <string_literal> ) , new file ( <string_literal> ) ) ; preferences . load ( new file <identifiersep> input <identifiersep> stream ( res ( <string_literal> ) ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> throw new runtime <identifiersep> exception ( e ) ; } } static string normalize ( final object s ) { return string . value <identifiersep> of ( s ) . replace ( <string_literal> , <string_literal> ) ; } static string preprocess ( final string name , final file resource ) throws sketch <identifiersep> exception , antlr <identifiersep> exception { final string program = read ( resource ) ; <ect>
print <identifiersep> headers ( conn ) ; system . exit ( 1 ) ; } } static void print <identifiersep> headers ( url <identifiersep> connection conn ) { map < string , list < string > > headers = conn . get <identifiersep> header <identifiersep> fields ( ) ; set < map . entry < string , list < string > > > entry <identifiersep> set = headers . entry <identifiersep> set ( ) ; for ( map . entry < string , list < string > > entry : entry <identifiersep> set ) { <LOG> string header <identifiersep> name = entry . get <identifiersep> key ( ) ; list < string > header <identifiersep> values = entry . get <identifiersep> value ( ) ; for ( string value : header <identifiersep> values ) { system . out . print ( <string_literal> + value ) ; } system . out . println ( ) ; system . out . println ( ) ; <ect>
try { return load <identifiersep> image <identifiersep> tga ( file ) ; } catch ( io <identifiersep> exception e ) { cannot <identifiersep> read ( file ) ; return null ; } } else if ( path <identifiersep> lower . ends <identifiersep> with ( <string_literal> ) || path <identifiersep> lower . ends <identifiersep> with ( <string_literal> ) ) { <LOG> cannot <identifiersep> read ( file ) ; return null ; } else { cannot <identifiersep> read ( file ) ; return null ; } } else { <ect>
try { qt <identifiersep> out = new quick <identifiersep> time <identifiersep> writer ( tmp <identifiersep> file ) ; if ( audio <identifiersep> file . get <identifiersep> name ( ) . to <identifiersep> lower <identifiersep> case ( ) . ends <identifiersep> with ( <string_literal> ) ) { audio <identifiersep> in = new mp3audio <identifiersep> input <identifiersep> stream ( audio <identifiersep> file ) ; } else { audio <identifiersep> in = audio <identifiersep> system . get <identifiersep> audio <identifiersep> input <identifiersep> stream ( audio <identifiersep> file ) ; } <LOG> audio <identifiersep> format audio <identifiersep> format = audio <identifiersep> in . get <identifiersep> format ( ) ; qt <identifiersep> out . add <identifiersep> audio <identifiersep> track ( audio <identifiersep> format ) ; boolean is <identifiersep> vbr = audio <identifiersep> format . get <identifiersep> property ( <string_literal> ) != null && ( ( boolean ) audio <identifiersep> format . get <identifiersep> property ( <string_literal> ) ) . boolean <identifiersep> value ( ) ; int as <identifiersep> size = audio <identifiersep> format . get <identifiersep> frame <identifiersep> size ( ) ; int nb <identifiersep> of <identifiersep> frames <identifiersep> in <identifiersep> buffer = is <identifiersep> vbr ? 1 : math . max ( 1 , <number_literal> / as <identifiersep> size ) ; int as <identifiersep> duration = ( int ) ( audio <identifiersep> format . get <identifiersep> sample <identifiersep> rate ( ) / audio <identifiersep> format . get <identifiersep> frame <identifiersep> rate ( ) ) ; <ect>
<comment> <LOG> <comment> <ect>
if ( last <identifiersep> was <identifiersep> cr ) { if ( last < ( nch - 1 ) ) { sb . append ( buff , last , nch - last - 1 ) ; } } else { sb . append ( buff , last , nch - last ) ; } } } if ( last <identifiersep> was <identifiersep> cr ) { <LOG> sb . append ( ' \\ n' ) ; } c . replace <identifiersep> selection ( sb != null ? sb . to <identifiersep> string ( ) : <string_literal> ) ; } } <comment> <ect>
header <identifiersep> size = buf . size ( ) ; } else { free <identifiersep> size = header <identifiersep> size + free <identifiersep> size - buf . size ( ) ; header <identifiersep> size = buf . size ( ) ; break ; } } if ( max <identifiersep> iteration < 0 || buf . size ( ) == 0 ) { <LOG> compress <identifiersep> header = false ; } else { out = new file <identifiersep> image <identifiersep> output <identifiersep> stream ( output <identifiersep> file ) ; write <identifiersep> prolog ( ) ; <comment> <ect>
scanline : for ( ; ymax > ymin ; ymax -= scanline <identifiersep> stride ) { int xy = ymax - scanline <identifiersep> stride ; int xymax = ymax - scanline <identifiersep> stride + width ; for ( ; xy < xymax ; ++ xy ) { if ( data [ xy ] != prev [ xy ] ) { <LOG> break scanline ; } } } <comment> <ect>
byte <identifiersep> array <identifiersep> output <identifiersep> stream buf = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; apple <identifiersep> rle <identifiersep> encoder enc = new apple <identifiersep> rle <identifiersep> encoder ( ) ; try { enc . write <identifiersep> key24 ( buf , data , w - <number_literal> , h , 1 , w ) ; buf . close ( ) ; byte [ ] result = buf . to <identifiersep> byte <identifiersep> array ( ) ; <LOG> int full <identifiersep> size = ( w - <number_literal> ) * h * <number_literal> ; system . out . println ( <string_literal> + result . length ) ; system . out . println ( <string_literal> + ( <number_literal> * ( result . length / ( float ) full <identifiersep> size ) ) ) ; <comment> <ect>
try { enc . write <identifiersep> key24 ( buf , data , w - <number_literal> , h , 1 , w ) ; buf . close ( ) ; byte [ ] result = buf . to <identifiersep> byte <identifiersep> array ( ) ; int full <identifiersep> size = ( w - <number_literal> ) * h * <number_literal> ; system . out . println ( <string_literal> + full <identifiersep> size ) ; <LOG> system . out . println ( <string_literal> + result . length ) ; <comment> <ect>
message <identifiersep> consumer message <identifiersep> consumer ; public message <identifiersep> stream ( message <identifiersep> consumer message <identifiersep> consumer ) { this . message <identifiersep> consumer = message <identifiersep> consumer ; } public void close ( ) { } public void flush ( ) { } public void write ( byte b [ ] ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> static private void check <identifiersep> local <identifiersep> host ( ) throws sketch <identifiersep> exception { try { inet <identifiersep> address address = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( <string_literal> ) ; <LOG> if ( ! address . get <identifiersep> host <identifiersep> address ( ) . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + platform . get <identifiersep> name ( ) ) ; throw new sketch <identifiersep> exception ( <string_literal> + <ect>
<comment> static private void check <identifiersep> local <identifiersep> host ( ) throws sketch <identifiersep> exception { try { inet <identifiersep> address address = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( <string_literal> ) ; if ( ! address . get <identifiersep> host <identifiersep> address ( ) . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + platform . get <identifiersep> name ( ) ) ; throw new sketch <identifiersep> exception ( <string_literal> + <string_literal> , false ) ; } } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <ect>
try { inet <identifiersep> address address = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( <string_literal> ) ; if ( ! address . get <identifiersep> host <identifiersep> address ( ) . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; throw new sketch <identifiersep> exception ( <string_literal> + <string_literal> , false ) ; } } catch ( unknown <identifiersep> host <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } public virtual <identifiersep> machine launch ( string [ ] args ) { <ect>
<comment> <LOG> if ( run <identifiersep> display > 0 ) { <comment> <ect>
boolean connected = true ; while ( connected ) { event <identifiersep> queue event <identifiersep> queue = vm . event <identifiersep> queue ( ) ; <comment> <LOG> for ( event event : event <identifiersep> set ) { if ( event instanceof vm <identifiersep> start <identifiersep> event ) { vm . resume ( ) ; } else if ( event instanceof exception <identifiersep> event ) { <comment> <ect>
return null ; <comment> <LOG> field message <identifiersep> field = rt . field <identifiersep> by <identifiersep> name ( <string_literal> ) ; value message <identifiersep> value = or . get <identifiersep> value ( message <identifiersep> field ) ; <comment> <ect>
int last = exception <identifiersep> name . last <identifiersep> index <identifiersep> of ( ' . ' ) ; string message = exception <identifiersep> name . substring ( last + 1 ) ; if ( message <identifiersep> value != null ) { string message <identifiersep> str = message <identifiersep> value . to <identifiersep> string ( ) ; if ( message <identifiersep> str . starts <identifiersep> with ( <string_literal> ) ) { message <identifiersep> str = message <identifiersep> str . substring ( 1 , message <identifiersep> str . length ( ) - 1 ) ; } <LOG> message += <string_literal> + message <identifiersep> str ; } <comment> <ect>
integer <identifiersep> value intval = ( integer <identifiersep> value ) ref . invoke <identifiersep> method ( thread , method , new array <identifiersep> list < value > ( ) , object <identifiersep> reference . invoke <identifiersep> single <identifiersep> threaded ) ; int line <identifiersep> number = intval . int <identifiersep> value ( ) - 1 ; sketch <identifiersep> exception rex = build . place <identifiersep> exception ( message , filename , line <identifiersep> number ) ; if ( rex != null ) { return rex ; } } <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
synchronized public void message ( string s ) { <comment> <LOG> if ( s . index <identifiersep> of ( p <identifiersep> applet . external <identifiersep> stop ) == 0 ) { if ( editor != null ) { <comment> <ect>
editor . set <identifiersep> sketch <identifiersep> location ( new point ( left , top ) ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> public void set <identifiersep> mode ( final mode mode ) { this . mode = mode ; } common <identifiersep> hidden <identifiersep> stream <identifiersep> token get <identifiersep> hidden <identifiersep> after ( final common <identifiersep> hidden <identifiersep> stream <identifiersep> token t ) { return filter . get <identifiersep> hidden <identifiersep> after ( t ) ; } common <identifiersep> hidden <identifiersep> stream <identifiersep> token get <identifiersep> initial <identifiersep> hidden <identifiersep> token ( ) { return filter . get <identifiersep> initial <identifiersep> hidden <identifiersep> token ( ) ; <ect>
string piece = m . group ( <number_literal> ) + m . group ( <number_literal> ) + m . group ( <number_literal> ) ; <comment> <LOG> int stop = start + piece . length ( ) ; <comment> <ect>
if ( ! ignore <identifiersep> import ( m . group ( <number_literal> ) ) ) { program <identifiersep> imports . add ( m . group ( <number_literal> ) ) ; <comment> <LOG> <comment> <ect>
<comment> string get <identifiersep> first <identifiersep> class <identifiersep> name ( ast ast ) { string t = adv <identifiersep> class <identifiersep> name ; adv <identifiersep> class <identifiersep> name = <string_literal> ; return t ; } <LOG> public void debug <identifiersep> ast ( final ast ast , final boolean include <identifiersep> hidden ) { debug <identifiersep> ast ( ast , include <identifiersep> hidden , 0 ) ; } private void debug <identifiersep> ast ( final ast ast , final boolean include <identifiersep> hidden , final int indent ) { for ( int i = 0 ; i < indent ; i ++ ) system . err . print ( <string_literal> ) ; <ect>
( e . get <identifiersep> source ( ) == option <identifiersep> pane ) && ( prop . equals ( j <identifiersep> option <identifiersep> pane . value <identifiersep> property ) ) ) { <comment> <LOG> dialog . pack ( ) ; <comment> <ect>
<comment> <LOG> string old <identifiersep> name = get <identifiersep> sketch ( ) . get <identifiersep> code ( 0 ) . get <identifiersep> file <identifiersep> name ( ) ; boolean saved = super . handle <identifiersep> save <identifiersep> as ( ) ; if ( saved ) { <comment> <ect>
<comment> <LOG> line <identifiersep> id line = new line <identifiersep> id ( new <identifiersep> name , bp . line <identifiersep> id ( ) . line <identifiersep> idx ( ) ) ; debugger . set <identifiersep> breakpoint ( line ) ; } <comment> <ect>
<comment> <LOG> bps . add ( line <identifiersep> id ) ; <comment> <ect>
<comment> <LOG> string code = tab . get <identifiersep> program ( ) ; string lines [ ] = code . split ( <string_literal> ) ; <comment> <ect>
string code = tab . get <identifiersep> program ( ) ; <comment> <LOG> code = p <identifiersep> applet . join ( lines , <string_literal> ) ; tab . set <identifiersep> program ( code ) ; tab . save ( ) ; } catch ( io <identifiersep> exception ex ) { messages . loge ( null , ex ) ; } } @ override <ect>
<comment> @ override public void set <identifiersep> code ( sketch <identifiersep> code code ) { <LOG> document old <identifiersep> doc = code . get <identifiersep> document ( ) ; <comment> <ect>
<comment> public static class <identifiersep> member resolve <identifiersep> expression3rd <identifiersep> party ( preprocessed <identifiersep> sketch ps , ast <identifiersep> node nearest <identifiersep> node , <LOG> ast <identifiersep> node ast <identifiersep> node , boolean no <identifiersep> compare ) { + <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( nearest <identifiersep> node ) ) ; if ( ast <identifiersep> node == null ) return null ; class <identifiersep> member scope <identifiersep> parent ; simple <identifiersep> type stp ; if ( ast <identifiersep> node instanceof simple <identifiersep> name ) { <ect>
switch ( ast <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) ) { <comment> <LOG> <comment> <ect>
if ( teh <identifiersep> class != null ) { <comment> <LOG> return null ; } scope <identifiersep> parent = defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) , <string_literal> ) ; } else { scope <identifiersep> parent = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , fa . get <identifiersep> expression ( ) , no <identifiersep> compare ) ; } log ( <string_literal> + scope <identifiersep> parent ) ; <ect>
log ( <string_literal> + scope <identifiersep> parent ) ; return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , scope <identifiersep> parent , fa . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } case ast <identifiersep> node . method <identifiersep> invocation : method <identifiersep> invocation mi = ( method <identifiersep> invocation ) ast <identifiersep> node ; ast <identifiersep> node temp = find <identifiersep> declaration2 ( mi . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; if ( temp instanceof method <identifiersep> declaration ) { <LOG> <comment> <ect>
<comment> class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , mi . get <identifiersep> expression ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <LOG> . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } return null ; } log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( stp ) ) ; ast <identifiersep> node type <identifiersep> dec = find <identifiersep> declaration2 ( stp . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; if ( type <identifiersep> dec == null ) { log ( stp . get <identifiersep> name ( ) + <string_literal> ) ; <ect>
return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( teh <identifiersep> class ) , mi . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } log ( <string_literal> + mi . get <identifiersep> expression ( ) ) ; return null ; } log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( stp ) ) ; ast <identifiersep> node type <identifiersep> dec = find <identifiersep> declaration2 ( stp . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; <LOG> if ( type <identifiersep> dec == null ) { class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <ect>
return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( ps , type <identifiersep> dec ) , mi . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } } else { log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( mi . get <identifiersep> expression ( ) ) ) ; <comment> <LOG> mi . get <identifiersep> expression ( ) , no <identifiersep> compare ) ; return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , scope <identifiersep> parent , mi . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } } break ; case ast <identifiersep> node . qualified <identifiersep> name : qualified <identifiersep> name qn = ( qualified <identifiersep> name ) ast <identifiersep> node ; ast <identifiersep> node temp2 = find <identifiersep> declaration2 ( qn . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; <ect>
qualified <identifiersep> name qn = ( qualified <identifiersep> name ) ast <identifiersep> node ; ast <identifiersep> node temp2 = find <identifiersep> declaration2 ( qn . get <identifiersep> name ( ) , nearest <identifiersep> node ) ; if ( temp2 instanceof field <identifiersep> declaration ) { <comment> <LOG> if ( qn . get <identifiersep> qualifier ( ) == null ) { return null ; } else { if ( qn . get <identifiersep> qualifier ( ) instanceof simple <identifiersep> name ) { stp = extrac <identifiersep> type <identifiersep> info ( find <identifiersep> declaration2 ( qn . get <identifiersep> qualifier ( ) , nearest <identifiersep> node ) ) ; if ( stp == null ) { <ect>
class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , qn . get <identifiersep> qualifier ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <LOG> return null ; } <comment> <ect>
if ( type <identifiersep> dec == null ) { log ( stp . get <identifiersep> name ( ) + <string_literal> ) ; class < ? > teh <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , stp . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; if ( teh <identifiersep> class != null ) { <comment> <LOG> . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } return null ; } return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( ps , type <identifiersep> dec ) , qn . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } else { scope <identifiersep> parent = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , <ect>
qn . get <identifiersep> qualifier ( ) , no <identifiersep> compare ) ; log ( <string_literal> + scope <identifiersep> parent ) ; return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , scope <identifiersep> parent , qn . get <identifiersep> name ( ) . to <identifiersep> string ( ) ) ; } } case ast <identifiersep> node . array <identifiersep> access : array <identifiersep> access arac = ( array <identifiersep> access ) ast <identifiersep> node ; return resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , arac . get <identifiersep> array ( ) , no <identifiersep> compare ) ; <LOG> default : break ; } return null ; } public static class < ? > get <identifiersep> array <identifiersep> class ( string element <identifiersep> class , class <identifiersep> loader class <identifiersep> loader ) { string name ; if ( element <identifiersep> class . starts <identifiersep> with ( <string_literal> ) ) { <ect>
boolean static <identifiersep> only ) { array <identifiersep> list < completion <identifiersep> candidate > candidates = new array <identifiersep> list < > ( ) ; log ( <string_literal> + child + <string_literal> + type <identifiersep> name + <string_literal> + no <identifiersep> compare + <string_literal> + static <identifiersep> only ) ; class < ? > probable <identifiersep> class = find <identifiersep> class <identifiersep> if <identifiersep> exists ( ps , type <identifiersep> name ) ; <LOG> if ( probable <identifiersep> class == null ) { return candidates ; } return get <identifiersep> members <identifiersep> for <identifiersep> type ( ps , new class <identifiersep> member ( probable <identifiersep> class ) , child , no <identifiersep> compare , static <identifiersep> only ) ; } public static array <identifiersep> list < completion <identifiersep> candidate > get <identifiersep> members <identifiersep> for <identifiersep> type ( preprocessed <identifiersep> sketch ps , class <identifiersep> member teh <identifiersep> class , string child <identifiersep> to <identifiersep> look <identifiersep> for , <ect>
<comment> <LOG> if ( probable <identifiersep> class == null ) { return candidates ; } log ( <string_literal> + probable <identifiersep> class . to <identifiersep> string ( ) ) ; } for ( method method : probable <identifiersep> class . get <identifiersep> methods ( ) ) { if ( ! modifier . is <identifiersep> static ( method . get <identifiersep> modifiers ( ) ) && static <identifiersep> only ) { continue ; <ect>
class < ? > teh <identifiersep> class = load <identifiersep> class ( class <identifiersep> name , ps . class <identifiersep> loader ) ; if ( teh <identifiersep> class != null ) { <comment> <LOG> return null ; } <comment> <ect>
. starts <identifiersep> with ( member <identifiersep> name <identifiersep> l ) ) return new class <identifiersep> member ( ps , vdf ) ; } } for ( int i = 0 ; i < td . get <identifiersep> methods ( ) . length ; i ++ ) { if ( td . get <identifiersep> methods ( ) [ i ] . get <identifiersep> name ( ) . to <identifiersep> string ( ) . to <identifiersep> lower <identifiersep> case ( ) . starts <identifiersep> with ( member <identifiersep> name <identifiersep> l ) ) return new class <identifiersep> member ( ps , td . get <identifiersep> methods ( ) [ i ] ) ; } <LOG> if ( td . get <identifiersep> superclass <identifiersep> type ( ) != null ) { return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( ps , td . get <identifiersep> superclass <identifiersep> type ( ) ) , member <identifiersep> name ) ; } else { return defined <identifiersep> in3rd <identifiersep> party <identifiersep> class ( ps , new class <identifiersep> member ( object . class ) , member <identifiersep> name ) ; } } class < ? > probable <identifiersep> class ; <ect>
int c <identifiersep> line <identifiersep> num = ( ( compilation <identifiersep> unit ) cnode . get <identifiersep> root ( ) ) . get <identifiersep> line <identifiersep> number ( cnode . get <identifiersep> start <identifiersep> position ( ) + cnode . get <identifiersep> length ( ) ) ; <comment> <LOG> protected static ast <identifiersep> node find <identifiersep> closest <identifiersep> node ( int line <identifiersep> number , ast <identifiersep> node node ) { ast <identifiersep> node parent = find <identifiersep> closest <identifiersep> parent <identifiersep> node ( line <identifiersep> number , node ) ; log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( parent ) ) ; if ( parent == null ) return null ; if ( get <identifiersep> line <identifiersep> number ( parent ) == line <identifiersep> number ) { <ect>
protected static ast <identifiersep> node find <identifiersep> closest <identifiersep> node ( int line <identifiersep> number , ast <identifiersep> node node ) { log ( <string_literal> + line <identifiersep> number ) ; ast <identifiersep> node parent = find <identifiersep> closest <identifiersep> parent <identifiersep> node ( line <identifiersep> number , node ) ; log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( parent ) ) ; if ( parent == null ) return null ; <LOG> if ( get <identifiersep> line <identifiersep> number ( parent ) == line <identifiersep> number ) { return parent ; } list < ast <identifiersep> node > nodes ; if ( parent instanceof type <identifiersep> declaration ) { nodes = ( ( type <identifiersep> declaration ) parent ) . body <identifiersep> declarations ( ) ; } else if ( parent instanceof block ) { <ect>
last <identifiersep> predicted <identifiersep> phrase = phrase ; return candidates ; } <comment> <LOG> if ( comm <identifiersep> line <identifiersep> no == line <identifiersep> number ) { log ( <string_literal> + java <identifiersep> code <identifiersep> offset <identifiersep> to <identifiersep> line <identifiersep> start <identifiersep> offset ( compilation <identifiersep> unit . get <identifiersep> line <identifiersep> number ( comm . get <identifiersep> start <identifiersep> position ( ) ) , comm . get <identifiersep> start <identifiersep> position ( ) ) ) ; break ; <ect>
while ( nearest <identifiersep> node != null ) { <comment> <LOG> simple <identifiersep> type st = ( simple <identifiersep> type ) td . get <identifiersep> structural <identifiersep> property ( type <identifiersep> declaration . superclass <identifiersep> type <identifiersep> property ) ; array <identifiersep> list < completion <identifiersep> candidate > temp <identifiersep> candidates = get <identifiersep> members <identifiersep> for <identifiersep> type ( ps , st . get <identifiersep> name ( ) . to <identifiersep> string ( ) , phrase , false , false ) ; for ( completion <identifiersep> candidate can : temp <identifiersep> candidates ) { candidates . add ( can ) ; } <comment> <ect>
candidates . add ( new completion <identifiersep> candidate ( matched <identifiersep> class , html , matched <identifiersep> class , completion <identifiersep> candidate . predef <identifiersep> class ) ) ; } } } } else { <comment> <LOG> messages . loge ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; ast <identifiersep> node child <identifiersep> expr = get <identifiersep> child <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> parent <identifiersep> expression ( testnode ) ) ; log ( <string_literal> + child <identifiersep> expr ) ; if ( ! no <identifiersep> compare ) { log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; <ect>
} else { <comment> <LOG> log ( <string_literal> + get <identifiersep> parent <identifiersep> expression ( testnode ) ) ; if ( ! no <identifiersep> compare ) { log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; testnode = get <identifiersep> parent <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; } class <identifiersep> member expr = <ect>
log ( <string_literal> ) ; ast <identifiersep> node child <identifiersep> expr = get <identifiersep> child <identifiersep> expression ( testnode ) ; log ( <string_literal> + get <identifiersep> parent <identifiersep> expression ( testnode ) ) ; log ( <string_literal> + child <identifiersep> expr ) ; if ( ! no <identifiersep> compare ) { log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( testnode ) ) ; <LOG> testnode = get <identifiersep> parent <identifiersep> expression ( testnode ) ; } class <identifiersep> member expr = resolve <identifiersep> expression3rd <identifiersep> party ( ps , nearest <identifiersep> node , testnode , no <identifiersep> compare ) ; if ( expr == null ) { log ( <string_literal> ) ; } else { <ect>
log ( <string_literal> ) ; } else { boolean is <identifiersep> array = expr . thisclass != null && expr . thisclass . is <identifiersep> array ( ) ; boolean is <identifiersep> simple <identifiersep> type = ( expr . ast <identifiersep> node != null ) && expr . ast <identifiersep> node . get <identifiersep> node <identifiersep> type ( ) == ast <identifiersep> node . simple <identifiersep> type ; boolean is <identifiersep> method = expr . method != null ; <LOG> boolean static <identifiersep> only = ! is <identifiersep> method && ! is <identifiersep> array && ! is <identifiersep> simple <identifiersep> type ; string look <identifiersep> for = ( no <identifiersep> compare || ( child <identifiersep> expr == null ) ) ? <string_literal> : child <identifiersep> expr . to <identifiersep> string ( ) ; candidates = get <identifiersep> members <identifiersep> for <identifiersep> type ( ps , expr , look <identifiersep> for , no <identifiersep> compare , static <identifiersep> only ) ; } } return candidates ; } protected static default <identifiersep> list <identifiersep> model < completion <identifiersep> candidate > filter <identifiersep> predictions ( list < completion <identifiersep> candidate > candidates ) { <ect>
new <identifiersep> label = cc . get <identifiersep> element <identifiersep> name ( ) + <string_literal> + label . substring ( x + 1 ) ; } string new <identifiersep> comp <identifiersep> string = cc . get <identifiersep> element <identifiersep> name ( ) + <string_literal> ; candidates . set ( i - 1 , cc . with <identifiersep> label <identifiersep> and <identifiersep> comp <identifiersep> string ( new <identifiersep> label , new <identifiersep> comp <identifiersep> string ) ) ; ignored <identifiersep> some = true ; continue ; } } def <identifiersep> list <identifiersep> model . add <identifiersep> element ( candidates . get ( i ) ) ; } <LOG> if ( ignored <identifiersep> some ) { } } return def <identifiersep> list <identifiersep> model ; } <comment> <ect>
string methodmatch = candidate . to <identifiersep> string ( ) ; if ( methodmatch . index <identifiersep> of ( ' ( ' ) != - 1 ) { methodmatch = methodmatch . substring ( 0 , methodmatch . index <identifiersep> of ( ' ( ' ) ) ; } <comment> <LOG> if ( key . starts <identifiersep> with ( methodmatch ) && key . length ( ) > <number_literal> ) { if ( candidate . get <identifiersep> wrapped <identifiersep> object ( ) != null ) { string defining <identifiersep> class = <string_literal> ; if ( candidate . get <identifiersep> wrapped <identifiersep> object ( ) instanceof field ) defining <identifiersep> class = ( ( field ) candidate . get <identifiersep> wrapped <identifiersep> object ( ) ) . get <identifiersep> declaring <identifiersep> class ( ) . get <identifiersep> name ( ) ; <ect>
<comment> <LOG> java <identifiersep> build build = new java <identifiersep> build ( sketch ) ; <comment> <ect>
<comment> <LOG> src <identifiersep> path = build . get <identifiersep> src <identifiersep> folder ( ) . get <identifiersep> path ( ) ; <comment> <ect>
src <identifiersep> path = build . get <identifiersep> src <identifiersep> folder ( ) . get <identifiersep> path ( ) ; log ( <string_literal> + src <identifiersep> path ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> breakpoints . remove ( bp ) ; } } <comment> synchronized void clear <identifiersep> breakpoints ( ) { <comment> <ect>
<comment> synchronized void clear <identifiersep> breakpoints ( string tab <identifiersep> filename ) { <comment> <LOG> if ( is <identifiersep> busy ( ) ) { return ; } iterator < line <identifiersep> breakpoint > i = breakpoints . iterator ( ) ; while ( i . has <identifiersep> next ( ) ) { line <identifiersep> breakpoint bp = i . next ( ) ; if ( bp . line <identifiersep> id ( ) . file <identifiersep> name ( ) . equals ( tab <identifiersep> filename ) ) { <ect>
line <identifiersep> breakpoint bp = breakpoint <identifiersep> on <identifiersep> line ( line ) ; return bp != null ; } <comment> <LOG> <comment> <ect>
editor . status <identifiersep> empty ( ) ; } } } private void create <identifiersep> class <identifiersep> prepare <identifiersep> request ( string name ) { class <identifiersep> prepare <identifiersep> request class <identifiersep> prepare <identifiersep> request = runtime . vm ( ) . event <identifiersep> request <identifiersep> manager ( ) . create <identifiersep> class <identifiersep> prepare <identifiersep> request ( ) ; class <identifiersep> prepare <identifiersep> request . add <identifiersep> class <identifiersep> filter ( name ) ; class <identifiersep> prepare <identifiersep> request . enable ( ) ; } private void vm <identifiersep> start <identifiersep> event ( ) { <LOG> <comment> <ect>
reference <identifiersep> type rt = ce . reference <identifiersep> type ( ) ; current <identifiersep> thread = ce . thread ( ) ; paused = true ; <comment> <LOG> classes . add ( rt ) ; started = true ; <comment> <ect>
<comment> protected void step <identifiersep> out <identifiersep> into <identifiersep> view <identifiersep> or <identifiersep> continue ( ) { try { list < stack <identifiersep> frame > frames = current <identifiersep> thread . frames ( ) ; if ( frames . size ( ) > 1 ) { <LOG> if ( location <identifiersep> is <identifiersep> visible ( frames . get ( 1 ) . location ( ) ) ) { step <identifiersep> out ( ) ; return ; } } continue <identifiersep> debug ( ) ; } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { logitse ( ex ) ; <ect>
try { if ( t . frame <identifiersep> count ( ) == 0 ) { system . out . println ( <string_literal> ) ; } else { stack <identifiersep> frame sf = t . frame ( 0 ) ; list < local <identifiersep> variable > locals = sf . visible <identifiersep> variables ( ) ; <LOG> if ( locals . is <identifiersep> empty ( ) ) { return ; } for ( local <identifiersep> variable lv : locals ) { system . out . println ( lv . type <identifiersep> name ( ) + <string_literal> + lv . name ( ) + <string_literal> + sf . get <identifiersep> value ( lv ) ) ; } } } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { logitse ( ex ) ; <ect>
system . out . println ( <string_literal> ) ; return ; } for ( local <identifiersep> variable lv : locals ) { system . out . println ( lv . type <identifiersep> name ( ) + <string_literal> + lv . name ( ) + <string_literal> + sf . get <identifiersep> value ( lv ) ) ; } } } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { logitse ( ex ) ; <LOG> } catch ( absent <identifiersep> information <identifiersep> exception ex ) { } } <comment> <ect>
final list < variable <identifiersep> node > this <identifiersep> fields = get <identifiersep> this <identifiersep> fields ( t , 0 , true ) ; final list < variable <identifiersep> node > declared <identifiersep> this <identifiersep> fields = get <identifiersep> this <identifiersep> fields ( t , 0 , false ) ; final string this <identifiersep> name = this <identifiersep> name ( t ) ; <comment> <LOG> public void run ( ) { vi . update <identifiersep> call <identifiersep> stack ( stack <identifiersep> trace , <string_literal> ) ; vi . update <identifiersep> locals ( locals , <string_literal> + current <identifiersep> location ) ; vi . update <identifiersep> this <identifiersep> fields ( this <identifiersep> fields , <string_literal> + this <identifiersep> name ) ; vi . update <identifiersep> declared <identifiersep> this <identifiersep> fields ( declared <identifiersep> this <identifiersep> fields , <string_literal> + this <identifiersep> name ) ; vi . unlock ( ) ; <comment> <ect>
protected list < variable <identifiersep> node > get <identifiersep> locals ( thread <identifiersep> reference t , int depth ) { <comment> <LOG> for ( local <identifiersep> variable lv : sf . visible <identifiersep> variables ( ) ) { value val = sf . get <identifiersep> value ( lv ) ; variable <identifiersep> node var = new local <identifiersep> variable <identifiersep> node ( lv . name ( ) , lv . type <identifiersep> name ( ) , val , lv , sf ) ; if ( depth > 0 ) { var . add <identifiersep> children ( get <identifiersep> fields ( val , depth - 1 , true ) ) ; } vars . add ( var ) ; <ect>
<comment> <LOG> reference <identifiersep> type type = this <identifiersep> object . reference <identifiersep> type ( ) ; for ( field f : type . visible <identifiersep> fields ( ) ) { system . out . println ( f . type <identifiersep> name ( ) + <string_literal> + f . name ( ) + <string_literal> + this <identifiersep> object . get <identifiersep> value ( f ) ) ; } } else { system . out . println ( <string_literal> ) ; } } } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { <ect>
object <identifiersep> reference this <identifiersep> object = sf . this <identifiersep> object ( ) ; if ( this <identifiersep> object != null ) { reference <identifiersep> type type = this <identifiersep> object . reference <identifiersep> type ( ) ; system . out . println ( <string_literal> + type . name ( ) + <string_literal> ) ; for ( field f : type . visible <identifiersep> fields ( ) ) { system . out . println ( f . type <identifiersep> name ( ) + <string_literal> + f . name ( ) + <string_literal> + this <identifiersep> object . get <identifiersep> value ( f ) ) ; } <LOG> } else { } } } catch ( incompatible <identifiersep> thread <identifiersep> state <identifiersep> exception ex ) { logitse ( ex ) ; } } <comment> <ect>
logitse ( ex ) ; } } <comment> protected void print <identifiersep> source <identifiersep> location ( location l ) { <LOG> try { system . out . println ( <string_literal> + l . method ( ) + <string_literal> ) ; system . out . println ( get <identifiersep> source <identifiersep> line ( l . source <identifiersep> path ( ) , l . line <identifiersep> number ( ) , <number_literal> ) ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { log ( <string_literal> , ex ) ; } } <comment> <ect>
<comment> protected void print <identifiersep> source <identifiersep> location ( location l ) { try { <comment> <LOG> } catch ( absent <identifiersep> information <identifiersep> exception ex ) { } } <comment> <ect>
return <string_literal> ; } } <comment> <LOG> protected void print <identifiersep> type ( reference <identifiersep> type rt ) { system . out . println ( <string_literal> + rt . name ( ) ) ; try { system . out . println ( <string_literal> + rt . source <identifiersep> name ( ) ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { system . out . println ( <string_literal> ) ; <ect>
<comment> protected void print <identifiersep> type ( reference <identifiersep> type rt ) { system . out . println ( <string_literal> + rt ) ; system . out . println ( <string_literal> + rt . name ( ) ) ; <LOG> try { } catch ( absent <identifiersep> information <identifiersep> exception ex ) { system . out . println ( <string_literal> ) ; } system . out . println ( <string_literal> ) ; for ( method m : rt . methods ( ) ) { system . out . println ( m . to <identifiersep> string ( ) ) ; <ect>
protected void print <identifiersep> type ( reference <identifiersep> type rt ) { system . out . println ( <string_literal> + rt ) ; system . out . println ( <string_literal> + rt . name ( ) ) ; try { system . out . println ( <string_literal> + rt . source <identifiersep> name ( ) ) ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { <LOG> system . out . println ( <string_literal> ) ; } for ( method m : rt . methods ( ) ) { system . out . println ( m . to <identifiersep> string ( ) ) ; } } <comment> <ect>
line <identifiersep> id tracked = new line <identifiersep> id ( tab . get <identifiersep> file <identifiersep> name ( ) , i ) ; tracked . start <identifiersep> tracking ( editor . current <identifiersep> document ( ) ) ; runtime <identifiersep> line <identifiersep> changes . put ( old , tracked ) ; } runtime <identifiersep> tabs <identifiersep> tracked . add ( tab . get <identifiersep> file <identifiersep> name ( ) ) ; <comment> <LOG> protected void stop <identifiersep> tracking <identifiersep> line <identifiersep> changes ( ) { for ( line <identifiersep> id tracked : runtime <identifiersep> line <identifiersep> changes . values ( ) ) { tracked . stop <identifiersep> tracking ( ) ; } runtime <identifiersep> line <identifiersep> changes . clear ( ) ; runtime <identifiersep> tabs <identifiersep> tracked . clear ( ) ; } private void log ( string msg , object . . . args ) { <ect>
super ( editor ) ; <comment> <LOG> final boolean debug = ( ( java <identifiersep> editor ) editor ) . is <identifiersep> debugger <identifiersep> enabled ( ) ; list < editor <identifiersep> button > outgoing = new array <identifiersep> list < > ( ) ; final string run <identifiersep> text = debug ? language . text ( <string_literal> ) : language . text ( <string_literal> ) ; run <identifiersep> button = new editor <identifiersep> button ( this , <string_literal> , <ect>
tree . set <identifiersep> column <identifiersep> hiding <identifiersep> allowed ( false ) ; <comment> <LOG> <comment> <ect>
<comment> protected class expansion <identifiersep> handler implements ext <identifiersep> tree <identifiersep> will <identifiersep> expand <identifiersep> listener , tree <identifiersep> expansion <identifiersep> listener { @ override <LOG> public void tree <identifiersep> will <identifiersep> expand ( tree <identifiersep> expansion <identifiersep> event tee ) throws expand <identifiersep> veto <identifiersep> exception { object last = tee . get <identifiersep> path ( ) . get <identifiersep> last <identifiersep> path <identifiersep> component ( ) ; if ( ! ( last instanceof variable <identifiersep> node ) ) { return ; } variable <identifiersep> node var = ( variable <identifiersep> node ) last ; var . remove <identifiersep> all <identifiersep> children ( ) ; <comment> <ect>
@ override public void tree <identifiersep> expanded ( tree <identifiersep> expansion <identifiersep> event tee ) { <comment> <LOG> public void tree <identifiersep> collapsed ( tree <identifiersep> expansion <identifiersep> event tee ) { <comment> <ect>
root <identifiersep> node . add ( builtins ) ; } <comment> <LOG> for ( tree <identifiersep> path path : expanded <identifiersep> nodes ) { path = synthesize <identifiersep> path ( path ) ; if ( path != null ) { tree . expand <identifiersep> path ( path ) ; } else { <comment> <ect>
<comment> <LOG> public synchronized void start <identifiersep> tracking ( document doc ) { if ( doc == null ) { return ; <comment> <ect>
<comment> protected void edit <identifiersep> event ( document <identifiersep> event de ) { <comment> <LOG> update <identifiersep> position ( ) ; } } <comment> @ override public void insert <identifiersep> update ( document <identifiersep> event de ) { <ect>
<comment> protected boolean attach ( reference <identifiersep> type the <identifiersep> class ) { if ( the <identifiersep> class == null || class <identifiersep> name == null || ! class <identifiersep> name . equals ( parse <identifiersep> top <identifiersep> level <identifiersep> class <identifiersep> name ( the <identifiersep> class . name ( ) ) ) ) { return false ; } log ( <string_literal> + line . file <identifiersep> name + <string_literal> + line . line <identifiersep> idx + <string_literal> + the <identifiersep> class . name ( ) ) ; <LOG> if ( ! dbg . is <identifiersep> paused ( ) ) { return false ; } <comment> <ect>
return false ; } <comment> <LOG> try { list < location > locations = the <identifiersep> class . locations <identifiersep> of <identifiersep> line ( java <identifiersep> line . line <identifiersep> idx ( ) + 1 ) ; if ( locations . is <identifiersep> empty ( ) ) { log ( <string_literal> + line + <string_literal> + java <identifiersep> line ) ; return false ; } <comment> <ect>
list < location > locations = the <identifiersep> class . locations <identifiersep> of <identifiersep> line ( java <identifiersep> line . line <identifiersep> idx ( ) + 1 ) ; if ( locations . is <identifiersep> empty ( ) ) { log ( <string_literal> + line + <string_literal> + java <identifiersep> line ) ; return false ; } <comment> <LOG> bpr . enable ( ) ; return true ; } catch ( absent <identifiersep> information <identifiersep> exception ex ) { messages . loge ( null , ex ) ; } return false ; } protected boolean is <identifiersep> attached ( ) { <ect>
<comment> public string preprocess ( file src <identifiersep> folder , string package <identifiersep> name , pde <identifiersep> preprocessor preprocessor , boolean size <identifiersep> warning ) throws sketch <identifiersep> exception { <comment> <LOG> sketch . ensure <identifiersep> existence ( ) ; class <identifiersep> path = bin <identifiersep> folder . get <identifiersep> absolute <identifiersep> path ( ) ; <comment> <ect>
<comment> <LOG> error <identifiersep> line -= sketch . get <identifiersep> code ( error <identifiersep> file ) . get <identifiersep> preproc <identifiersep> offset ( ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
throw new sketch <identifiersep> exception ( <string_literal> + <string_literal> , error <identifiersep> file , error <identifiersep> line , re . get <identifiersep> column ( ) , false ) ; } if ( msg . index <identifiersep> of ( <string_literal> ) != - 1 ) { throw new sketch <identifiersep> exception ( <string_literal> + <string_literal> , <LOG> error <identifiersep> file , error <identifiersep> line , re . get <identifiersep> column ( ) , false ) ; } throw new sketch <identifiersep> exception ( msg , error <identifiersep> file , error <identifiersep> line , re . get <identifiersep> column ( ) , false ) ; } catch ( antlr . token <identifiersep> stream <identifiersep> recognition <identifiersep> exception tsre ) { <comment> <ect>
throw new sketch <identifiersep> exception ( msg , 0 , - 1 , - 1 ) ; } } catch ( sketch <identifiersep> exception pe ) { <comment> <LOG> <comment> <ect>
library core = mode . get <identifiersep> core <identifiersep> library ( ) ; if ( core != null ) { imported <identifiersep> libraries . add ( core ) ; class <identifiersep> path += core . get <identifiersep> class <identifiersep> path ( ) ; java <identifiersep> library <identifiersep> path += file . path <identifiersep> separator + core . get <identifiersep> native <identifiersep> path ( ) ; } <comment> <LOG> for ( string item : result . extra <identifiersep> imports ) { <comment> <ect>
<comment> <LOG> library library = mode . get <identifiersep> library ( entry ) ; if ( library != null ) { if ( ! imported <identifiersep> libraries . contains ( library ) ) { imported <identifiersep> libraries . add ( library ) ; class <identifiersep> path += library . get <identifiersep> class <identifiersep> path ( ) ; java <identifiersep> library <identifiersep> path += file . path <identifiersep> separator + library . get <identifiersep> native <identifiersep> path ( ) ; <ect>
<comment> public sketch <identifiersep> exception place <identifiersep> exception ( string message , string dot <identifiersep> java <identifiersep> filename , int dot <identifiersep> java <identifiersep> line ) { int code <identifiersep> index = 0 ; <comment> <LOG> int code <identifiersep> line = - 1 ; <comment> <ect>
return null ; } <comment> <LOG> if ( code . is <identifiersep> extension ( <string_literal> ) ) { <comment> <ect>
for ( int i = 0 ; i < sketch . get <identifiersep> code <identifiersep> count ( ) ; i ++ ) { sketch <identifiersep> code code = sketch . get <identifiersep> code ( i ) ; if ( code . is <identifiersep> extension ( <string_literal> ) ) { <comment> <LOG> code <identifiersep> index = i ; code <identifiersep> line = dot <identifiersep> java <identifiersep> line - code . get <identifiersep> preproc <identifiersep> offset ( ) ; } } } <comment> <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; } } <comment> <LOG> } else { } <comment> <ect>
protected void add <identifiersep> classes ( zip <identifiersep> output <identifiersep> stream zos , file dir , string root <identifiersep> path ) throws io <identifiersep> exception { file files [ ] = dir . list <identifiersep> files ( new filename <identifiersep> filter ( ) { public boolean accept ( file dir , string name ) { return ( name . char <identifiersep> at ( 0 ) != ' . ' ) ; } } ) ; for ( file sub : files ) { <LOG> string relative <identifiersep> path = sub . get <identifiersep> absolute <identifiersep> path ( ) . substring ( root <identifiersep> path . length ( ) ) ; if ( sub . is <identifiersep> directory ( ) ) { add <identifiersep> classes ( zos , sub , root <identifiersep> path ) ; } else if ( sub . get <identifiersep> name ( ) . ends <identifiersep> with ( <string_literal> ) ) { <comment> <ect>
exception . set <identifiersep> message ( what + <string_literal> + what . substring ( 1 ) ) ; handle <identifiersep> crusty <identifiersep> code ( ) ; } else { exception . set <identifiersep> message ( <string_literal> + <string_literal> + what + <string_literal> ) ; string suggestion = import <identifiersep> suggestions . get ( what ) ; <LOG> if ( suggestion != null ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } } else if ( error <identifiersep> message . ends <identifiersep> with ( <string_literal> ) ) { <comment> <ect>
} else { exception . set <identifiersep> message ( <string_literal> + <string_literal> + what + <string_literal> ) ; string suggestion = import <identifiersep> suggestions . get ( what ) ; if ( suggestion != null ) { system . err . println ( <string_literal> + suggestion + <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; } } } else if ( error <identifiersep> message . ends <identifiersep> with ( <string_literal> ) ) { <comment> <ect>
if ( hidden <identifiersep> copy != null ) { link <identifiersep> and <identifiersep> copy <identifiersep> token ( hidden <identifiersep> copy , monitored ) ; } else { link <identifiersep> and <identifiersep> copy <identifiersep> token ( prev , monitored ) ; } <comment> <LOG> <comment> <ect>
<comment> <LOG> hidden <identifiersep> copy = null ; } return monitored ; } } <ect>
found = i ; break ; } } if ( found == - 1 ) { return 0 ; } <comment> <LOG> if ( dest . length < to <identifiersep> copy ) { <string_literal> + to <identifiersep> copy + <string_literal> + <string_literal> + ( byte ) in <identifiersep> byte ) ; return - 1 ; } system . arraycopy ( buffer , read <identifiersep> offset , dest , 0 , to <identifiersep> copy ) ; read <identifiersep> offset += to <identifiersep> copy ; <ect>
<comment> <LOG> <comment> <ect>
throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( native <identifiersep> interface . is <identifiersep> simulated ( ) ) { return ; } string fn = string . format ( <string_literal> , pin ) ; int ret = native <identifiersep> interface . write <identifiersep> file ( fn , out ) ; if ( ret < 0 ) { <LOG> if ( ret == - <number_literal> ) { <comment> <ect>
<comment> <LOG> if ( ret == - <number_literal> ) { <comment> <ect>
check <identifiersep> valid <identifiersep> pin ( pin ) ; if ( native <identifiersep> interface . is <identifiersep> simulated ( ) ) { return ; } string fn = <string_literal> ; int ret = native <identifiersep> interface . write <identifiersep> file ( fn , integer . to <identifiersep> string ( pin ) ) ; if ( ret < 0 ) { <LOG> if ( ret == - <number_literal> ) { <comment> <ect>
package processing . io ; public class native <identifiersep> interface { protected static boolean loaded = false ; protected static boolean always <identifiersep> simulate = false ; public static void load <identifiersep> library ( ) { if ( ! loaded ) { <LOG> if ( is <identifiersep> simulated ( ) ) { } else { system . load <identifiersep> library ( <string_literal> ) ; } loaded = true ; } } public static void always <identifiersep> simulate ( ) { always <identifiersep> simulate = true ; <ect>
<comment> public void write ( float angle ) { if ( attached ( ) == false ) { system . err . println ( <string_literal> ) ; throw new runtime <identifiersep> exception ( <string_literal> ) ; } <LOG> if ( angle < 0 || <number_literal> < angle ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } pulse = ( int ) ( min <identifiersep> pulse + ( angle / <number_literal> . 0 ) * ( max <identifiersep> pulse - min <identifiersep> pulse ) ) ; if ( handle < 0 ) { <comment> <ect>
<comment> public void brightness ( float bright ) { <LOG> if ( bright < 0 . 0 || 1 . 0 < bright ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( native <identifiersep> interface . is <identifiersep> simulated ( ) ) { return ; } string fn = <string_literal> + dev + <string_literal> ; int ret = native <identifiersep> interface . write <identifiersep> file ( fn , integer . to <identifiersep> string ( ( int ) ( bright * max <identifiersep> brightness ) ) ) ; <ect>
return ; } <comment> <LOG> if ( ret == - <number_literal> ) { <comment> <ect>
<comment> public void write ( int out ) { <LOG> if ( out < - <number_literal> || <number_literal> < out ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } byte [ ] tmp = new byte [ 1 ] ; tmp [ 0 ] = ( byte ) out ; write ( tmp ) ; } <comment> <ect>
string fn = <string_literal> + chip + <string_literal> ; int ret = native <identifiersep> interface . write <identifiersep> file ( fn , integer . to <identifiersep> string ( this . channel ) ) ; if ( ret < 0 ) { if ( ret == - <number_literal> ) { <comment> <LOG> if ( ret == - <number_literal> ) { <comment> <ect>
<comment> <LOG> if ( duty < 0 . 0 || 1 . 0 < duty ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } <comment> <ect>
for ( int i = 0 ; i < vertex <identifiersep> count - 1 ; i ++ ) { write <identifiersep> line ( i , i + 1 ) ; } if ( mode == close ) { write <identifiersep> line ( vertex <identifiersep> count - 1 , 0 ) ; } } <comment> <LOG> <comment> } } <ect>
<comment> <LOG> <comment> <ect>
<string_literal> ) ; } else if ( text <identifiersep> mode != shape ) { if ( text <identifiersep> font . is <identifiersep> stream ( ) ) { throw new runtime <identifiersep> exception ( <string_literal> + <string_literal> ) ; } else if ( mapper . get <identifiersep> aliases ( ) . get ( text <identifiersep> font . get <identifiersep> name ( ) ) == null ) { <LOG> <comment> <ect>
while ( input != null ) { int read <identifiersep> count ; <comment> <LOG> } catch ( socket <identifiersep> exception e ) { <comment> <ect>
system . arraycopy ( read <identifiersep> buffer , 0 , buffer , buffer <identifiersep> last , read <identifiersep> count ) ; buffer <identifiersep> last += read <identifiersep> count ; } <comment> <LOG> } catch ( exception e ) { throwable cause = e ; <comment> <ect>
client client = new client ( parent , socket ) ; synchronized ( clients <identifiersep> lock ) { add <identifiersep> client ( client ) ; if ( server <identifiersep> event <identifiersep> method != null ) { try { server <identifiersep> event <identifiersep> method . invoke ( parent , this , client ) ; <LOG> } catch ( exception e ) { throwable cause = e ; <comment> <ect>
<comment> @ override public boolean displayable ( ) { return false ; } <comment> <LOG> <comment> <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
<comment> <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
logger . warn ( <string_literal> ) ; } <comment> <LOG> } catch ( exception e ) { } } private static void make <identifiersep> final <identifiersep> field <identifiersep> accessible ( field field ) throws no <identifiersep> such <identifiersep> field <identifiersep> exception , illegal <identifiersep> access <identifiersep> exception { field . set <identifiersep> accessible ( true ) ; field modifiers <identifiersep> field = field . class . get <identifiersep> declared <identifiersep> field ( <string_literal> ) ; modifiers <identifiersep> field . set <identifiersep> accessible ( true ) ; modifiers <identifiersep> field . set <identifiersep> int ( field , field . get <identifiersep> modifiers ( ) & ~modifier . final ) ; <ect>
log . info ( <string_literal> ) while ( ! threads . is <identifiersep> empty ( ) ) { if ( ! threads <identifiersep> changed . await <identifiersep> until ( timeout ) ) { failed ( new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ) break ; } } threads . each { thread - > <LOG> thread . interrupt ( ) } if ( ! failures . is <identifiersep> empty ( ) ) { throw failures [ 0 ] } } finally { failure <identifiersep> handler = null threads . clear ( ) <ect>
if ( complete ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) } } finally { lock . unlock ( ) } } void completes <identifiersep> before ( date timeout ) { lock . lock ( ) <LOG> try { while ( ! complete ) { if ( ! state <identifiersep> changed . await <identifiersep> until ( timeout ) ) { interrupt ( ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) } } log . info ( <string_literal> ) <ect>
} catch ( throwable t ) { failure = t } lock . lock ( ) try { complete = true state <identifiersep> changed . signal <identifiersep> all ( ) <LOG> owner . on <identifiersep> thread <identifiersep> complete ( this , failure ) } finally { lock . unlock ( ) } } } <comment> <ect>
instant . done } then : wait <identifiersep> for . notified when : write <identifiersep> to <identifiersep> file <identifiersep> multiple <identifiersep> times ( instant , testfile ) and : <LOG> def timestamp <identifiersep> for <identifiersep> last <identifiersep> change = system . nano <identifiersep> time ( ) testfile < < <string_literal> logger . log ( <string_literal> ) then : wait <identifiersep> for . done math . round ( ( system . nano <identifiersep> time ( ) - timestamp <identifiersep> for <identifiersep> last <identifiersep> change ) / 1000000l ) >= quiet <identifiersep> period <ect>
math . round ( ( system . nano <identifiersep> time ( ) - timestamp <identifiersep> for <identifiersep> last <identifiersep> change ) / 1000000l ) >= quiet <identifiersep> period continuous <identifiersep> execution <identifiersep> gate . wait <identifiersep> for <identifiersep> open ( ) cleanup : w . stop ( ) } private void write <identifiersep> to <identifiersep> file <identifiersep> multiple <identifiersep> times ( instant , testfile ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> instant . assert <identifiersep> not <identifiersep> reached ( 'done' ) testfile < < <string_literal> logger . log ( <string_literal> ) sleep ( <number_literal> ) } } class logging <identifiersep> file <identifiersep> watch <identifiersep> event <identifiersep> listener implements file <identifiersep> watcher <identifiersep> event <identifiersep> listener { @ override <ect>
if ( operating <identifiersep> system . current . windows ) { return <string_literal> } return <string_literal> } private void generate <identifiersep> main <identifiersep> java <identifiersep> file <identifiersep> echoing ( string out , string err ) { file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> public static void main ( string [ ] args ) { system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
public void set <identifiersep> prop2 ( boolean prop2 ) { this . prop2 = prop2 ; } @ option ( option = <string_literal> , description = <string_literal> ) public void set <identifiersep> prop3 ( string prop3 ) { this . prop3 = prop3 ; } @ task <identifiersep> action <LOG> public void render <identifiersep> option <identifiersep> value ( ) { system . out . println ( <string_literal> + prop2 ) ; system . out . println ( <string_literal> + prop3 ) ; } } <string_literal> <string_literal> <ect>
@ option ( option = <string_literal> , description = <string_literal> ) public void set <identifiersep> prop3 ( string prop3 ) { this . prop3 = prop3 ; } @ task <identifiersep> action public void render <identifiersep> option <identifiersep> value ( ) { system . out . println ( <string_literal> + prop1 ) ; <LOG> system . out . println ( <string_literal> + prop2 ) ; } } <string_literal> <string_literal> <ect>
result . assert <identifiersep> tasks <identifiersep> executed <identifiersep> in <identifiersep> order ( <string_literal> , <string_literal> ) } def <string_literal> ( ) { file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> @ task <identifiersep> action public void log <identifiersep> stuff ( ) { } } <string_literal> <string_literal> task foo ( type : foo <identifiersep> task ) <string_literal> foo <string_literal> - s <string_literal> <ect>
import java . io . serializable ; public class output <identifiersep> on <identifiersep> shutdown <identifiersep> hook <identifiersep> process implements action < worker <identifiersep> process <identifiersep> context > , serializable { @ override public void execute ( worker <identifiersep> process <identifiersep> context worker <identifiersep> process <identifiersep> context ) { runtime . get <identifiersep> runtime ( ) . add <identifiersep> shutdown <identifiersep> hook ( new thread ( new runnable ( ) { @ override <LOG> public void run ( ) { } } ) ) ; } } <ect>
set < ? extends task > dep <identifiersep> tasks = task . get <identifiersep> task <identifiersep> dependencies ( ) . get <identifiersep> dependencies ( task ) ; for ( task dep <identifiersep> task : dep <identifiersep> tasks ) { names . add ( match <identifiersep> on <identifiersep> paths ? dep <identifiersep> task . get <identifiersep> path ( ) : dep <identifiersep> task . get <identifiersep> name ( ) ) ; } boolean matches = matcher . matches ( names ) ; if ( ! matches ) { string <identifiersep> description description = new string <identifiersep> description ( ) ; <LOG> matcher . describe <identifiersep> to ( description ) ; } return matches ; } public void describe <identifiersep> to ( description description ) { description . append <identifiersep> text ( <string_literal> ) . append <identifiersep> description <identifiersep> of ( matcher ) ; } } ; } @ factory <ect>
return new base <identifiersep> matcher < t > ( ) { public boolean matches ( object o ) { file <identifiersep> collection actual = ( file <identifiersep> collection ) o ; list < ? extends file <identifiersep> collection > actual <identifiersep> collections = unpack ( actual ) ; list < ? extends file <identifiersep> collection > expected <identifiersep> collections = unpack ( expected ) ; boolean equals = actual <identifiersep> collections . equals ( expected <identifiersep> collections ) ; <LOG> if ( ! equals ) { system . out . println ( <string_literal> + actual <identifiersep> collections ) ; } return equals ; } private list < ? extends file <identifiersep> collection > unpack ( file <identifiersep> collection expected ) { if ( expected instanceof union <identifiersep> file <identifiersep> collection ) { union <identifiersep> file <identifiersep> collection collection = ( union <identifiersep> file <identifiersep> collection ) expected ; <ect>
thread . start ( ) ; return new thread <identifiersep> handle <identifiersep> impl ( thread ) ; } private void test <identifiersep> thread <identifiersep> started ( thread thread ) { lock . lock ( ) ; try { if ( stopped ) { <LOG> throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } active . add ( thread ) ; condition . signal <identifiersep> all ( ) ; } finally { lock . unlock ( ) ; } } private void test <identifiersep> thread <identifiersep> finished ( thread thread , throwable failure ) { <ect>
try { active . remove ( thread ) ; matcher < ? extends throwable > matcher = expected <identifiersep> failure . get ( ) ; if ( failure != null ) { if ( matcher != null && matcher . matches ( failure ) ) { logger . debug ( <string_literal> , thread ) ; <LOG> } else { failures . add ( failure ) ; } } else { if ( matcher != null ) { string message = string . format ( <string_literal> , thread ) ; logger . error ( message ) ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> all ( ) { date expiry = new date ( system . current <identifiersep> time <identifiersep> millis ( ) + <number_literal> * max <identifiersep> wait <identifiersep> time ) ; lock . lock ( ) ; <LOG> try { if ( active . contains ( thread . current <identifiersep> thread ( ) ) ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } try { while ( ! active . is <identifiersep> empty ( ) ) { boolean signaled = condition . await <identifiersep> until ( expiry ) ; <ect>
<comment> <LOG> public void sync <identifiersep> at ( int tick ) { lock . lock ( ) ; try { clock <identifiersep> tick <identifiersep> impl clock <identifiersep> tick = get <identifiersep> tick ( tick ) ; if ( ! clock <identifiersep> tick . is <identifiersep> immediately <identifiersep> after ( current <identifiersep> tick ) ) { throw new runtime <identifiersep> exception ( string . format ( <string_literal> , clock <identifiersep> tick , <ect>
<comment> public void expect <identifiersep> later ( final int tick ) { <LOG> final thread target <identifiersep> thread = thread . current <identifiersep> thread ( ) ; start ( new runnable ( ) { public void run ( ) { try { thread . sleep ( 500l ) ; } catch ( interrupted <identifiersep> exception e ) { <ect>
this . logger = logger ; result <identifiersep> loggers . add ( new build <identifiersep> exception <identifiersep> reporter ( text <identifiersep> output <identifiersep> factory , start <identifiersep> parameter , request <identifiersep> meta <identifiersep> data . get <identifiersep> client ( ) ) ) ; result <identifiersep> loggers . add ( new build <identifiersep> result <identifiersep> logger ( text <identifiersep> output <identifiersep> factory , build <identifiersep> started <identifiersep> time , clock , new terse <identifiersep> pretty <identifiersep> duration <identifiersep> formatter ( ) ) ) ; } public void build <identifiersep> started ( gradle gradle ) { start <identifiersep> parameter start <identifiersep> parameter = gradle . get <identifiersep> start <identifiersep> parameter ( ) ; <LOG> logger . info ( <string_literal> ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> current <identifiersep> dir ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> settings <identifiersep> file ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> build <identifiersep> file ( ) ) ; } } public void settings <identifiersep> evaluated ( settings settings ) { <ect>
result <identifiersep> loggers . add ( new build <identifiersep> result <identifiersep> logger ( text <identifiersep> output <identifiersep> factory , build <identifiersep> started <identifiersep> time , clock , new terse <identifiersep> pretty <identifiersep> duration <identifiersep> formatter ( ) ) ) ; } public void build <identifiersep> started ( gradle gradle ) { start <identifiersep> parameter start <identifiersep> parameter = gradle . get <identifiersep> start <identifiersep> parameter ( ) ; logger . info ( <string_literal> ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( ) ) ; <LOG> logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> current <identifiersep> dir ( ) ) ; logger . debug ( <string_literal> , start <identifiersep> parameter . get <identifiersep> build <identifiersep> file ( ) ) ; } } public void settings <identifiersep> evaluated ( settings settings ) { settings <identifiersep> internal settings <identifiersep> internal = ( settings <identifiersep> internal ) settings ; logger . info ( <string_literal> , <ect>
logger . info ( <string_literal> , settings <identifiersep> internal . get <identifiersep> settings <identifiersep> script ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; } } public void projects <identifiersep> loaded ( gradle gradle ) { project <identifiersep> internal project <identifiersep> internal = ( project <identifiersep> internal ) gradle . get <identifiersep> root <identifiersep> project ( ) ; logger . info ( <string_literal> , <LOG> project <identifiersep> internal . get <identifiersep> build <identifiersep> script <identifiersep> source ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; } } public void projects <identifiersep> evaluated ( gradle gradle ) { logger . info ( <string_literal> ) ; } public void graph <identifiersep> populated ( task <identifiersep> execution <identifiersep> graph graph ) { logger . info ( <string_literal> , graph . get <identifiersep> all <identifiersep> tasks ( ) ) ; <ect>
logger . info ( <string_literal> , project <identifiersep> internal . get <identifiersep> build <identifiersep> script <identifiersep> source ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; logger . info ( <string_literal> , project <identifiersep> internal . get <identifiersep> allprojects ( ) ) ; } } public void projects <identifiersep> evaluated ( gradle gradle ) { logger . info ( <string_literal> ) ; } <LOG> public void graph <identifiersep> populated ( task <identifiersep> execution <identifiersep> graph graph ) { } } public void build <identifiersep> finished ( build <identifiersep> result result ) { for ( build <identifiersep> listener logger : result <identifiersep> loggers ) { logger . build <identifiersep> finished ( result ) ; } } } <ect>
default <identifiersep> build <identifiersep> operation <identifiersep> context context = new default <identifiersep> build <identifiersep> operation <identifiersep> context ( ) ; logger . debug ( <string_literal> , descriptor . get <identifiersep> display <identifiersep> name ( ) ) ; try { worker . execute ( build <identifiersep> operation , context ) ; } catch ( throwable t ) { context . thrown ( t ) ; <LOG> failure = t ; } progress <identifiersep> logger . completed ( context . status , context . failure != null ) ; listener . finished ( descriptor , new operation <identifiersep> finish <identifiersep> event ( new <identifiersep> operation . get <identifiersep> start <identifiersep> time ( ) , clock . get <identifiersep> current <identifiersep> time ( ) , context . failure , context . result ) ) ; assert <identifiersep> parent <identifiersep> running ( <string_literal> , descriptor , parent ) ; if ( failure != null ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( failure , true ) ; <ect>
return description . get <identifiersep> parent <identifiersep> id ( ) ; } private object write <identifiersep> replace ( ) throws object <identifiersep> stream <identifiersep> exception { return new default <identifiersep> build <identifiersep> operation <identifiersep> ref ( description . get <identifiersep> id ( ) , description . get <identifiersep> parent <identifiersep> id ( ) ) ; } } private static class unmanaged <identifiersep> thread <identifiersep> operation extends build <identifiersep> operation <identifiersep> state { private static final atomic <identifiersep> long unmanaged <identifiersep> thread <identifiersep> operation <identifiersep> counter = new atomic <identifiersep> long ( - 1 ) ; private static unmanaged <identifiersep> thread <identifiersep> operation create ( clock clock ) { <LOG> <comment> <ect>
void watch ( file <identifiersep> system <identifiersep> subset file <identifiersep> system <identifiersep> subset ) throws io <identifiersep> exception { lock . lock ( ) ; try { log . debug ( <string_literal> , file <identifiersep> system <identifiersep> subset ) ; final watch <identifiersep> points <identifiersep> registry . delta delta = watch <identifiersep> points <identifiersep> registry . append <identifiersep> file <identifiersep> system <identifiersep> subset ( file <identifiersep> system <identifiersep> subset , get <identifiersep> current <identifiersep> watch <identifiersep> points ( ) ) ; iterable < ? extends file > starting <identifiersep> watch <identifiersep> points = delta . get <identifiersep> starting <identifiersep> watch <identifiersep> points ( ) ; <LOG> for ( file dir : starting <identifiersep> watch <identifiersep> points ) { final path dir <identifiersep> path = dir . to <identifiersep> path ( ) ; watch <identifiersep> dir ( dir <identifiersep> path ) ; if ( ! file <identifiersep> tree <identifiersep> watching <identifiersep> supported ) { files . walk <identifiersep> file <identifiersep> tree ( dir <identifiersep> path , new simple <identifiersep> file <identifiersep> visitor < path > ( ) { @ override <ect>
return file <identifiersep> visit <identifiersep> result . continue ; } else { log . debug ( <string_literal> , path ) ; return file <identifiersep> visit <identifiersep> result . skip <identifiersep> subtree ; } } else { return file <identifiersep> visit <identifiersep> result . continue ; } } <LOG> } ) ; } } log . debug ( <string_literal> , file <identifiersep> system <identifiersep> subset ) ; } finally { lock . unlock ( ) ; } } private iterable < file > get <identifiersep> current <identifiersep> watch <identifiersep> points ( ) { list < file > current <identifiersep> watch <identifiersep> points = new linked <identifiersep> list < file > ( ) ; <ect>
private iterable < file > get <identifiersep> current <identifiersep> watch <identifiersep> points ( ) { list < file > current <identifiersep> watch <identifiersep> points = new linked <identifiersep> list < file > ( ) ; for ( map . entry < path , watch <identifiersep> key > entry : watch <identifiersep> keys . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> value ( ) . is <identifiersep> valid ( ) ) { current <identifiersep> watch <identifiersep> points . add ( entry . get <identifiersep> key ( ) . to <identifiersep> file ( ) ) ; } } return current <identifiersep> watch <identifiersep> points ; } <LOG> protected void watch <identifiersep> dir ( path dir ) throws io <identifiersep> exception { if ( thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ) { log . debug ( <string_literal> ) ; } <comment> <ect>
if ( thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ) { log . debug ( <string_literal> ) ; } <comment> <LOG> if ( previous <identifiersep> watch <identifiersep> key != null && previous <identifiersep> watch <identifiersep> key . is <identifiersep> valid ( ) ) { return ; } } int retry <identifiersep> count = 0 ; io <identifiersep> exception last <identifiersep> exception = null ; while ( retry <identifiersep> count ++ < <number_literal> ) { try { <ect>
watch <identifiersep> key watch <identifiersep> key = dir . register ( watch <identifiersep> service , watch <identifiersep> kinds , watch <identifiersep> modifiers ) ; watch <identifiersep> keys . put ( dir , watch <identifiersep> key ) ; return ; } catch ( io <identifiersep> exception e ) { log . debug ( <string_literal> + dir , e ) ; last <identifiersep> exception = e ; <LOG> if ( e instanceof no <identifiersep> such <identifiersep> file <identifiersep> exception ) { return ; } if ( e instanceof file <identifiersep> system <identifiersep> exception && e . get <identifiersep> message ( ) != null && e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <comment> <ect>
log . debug ( <string_literal> ) ; continue ; } <comment> <LOG> <comment> <ect>
log . debug ( <string_literal> ) ; throw last <identifiersep> exception ; } @ override public void on <identifiersep> change ( file <identifiersep> watcher watcher , file <identifiersep> watcher <identifiersep> event event ) { lock . lock ( ) ; try { <LOG> if ( event . get <identifiersep> type ( ) . equals ( file <identifiersep> watcher <identifiersep> event . type . undefined ) || event . get <identifiersep> file ( ) == null ) { deliver <identifiersep> event <identifiersep> to <identifiersep> delegate ( watcher , event ) ; return ; } file file = event . get <identifiersep> file ( ) ; maybe <identifiersep> fire ( watcher , event ) ; if ( event . get <identifiersep> type ( ) . equals ( file <identifiersep> watcher <identifiersep> event . type . create ) && file . is <identifiersep> directory ( ) ) { <ect>
<comment> <LOG> if ( watch <identifiersep> points <identifiersep> registry . should <identifiersep> fire ( event . get <identifiersep> file ( ) ) ) { deliver <identifiersep> event <identifiersep> to <identifiersep> delegate ( watcher , event ) ; } else { log . debug ( <string_literal> , event ) ; } } private void maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( file <identifiersep> watcher watcher , file dir ) throws io <identifiersep> exception { log . debug ( <string_literal> , dir ) ; <ect>
private void maybe <identifiersep> fire ( file <identifiersep> watcher watcher , file <identifiersep> watcher <identifiersep> event event ) { if ( watch <identifiersep> points <identifiersep> registry . should <identifiersep> fire ( event . get <identifiersep> file ( ) ) ) { log . debug ( <string_literal> , event ) ; deliver <identifiersep> event <identifiersep> to <identifiersep> delegate ( watcher , event ) ; } else { log . debug ( <string_literal> , event ) ; } } <LOG> private void maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( file <identifiersep> watcher watcher , file dir ) throws io <identifiersep> exception { if ( is <identifiersep> stop <identifiersep> requested ( watcher ) ) { log . debug ( <string_literal> ) ; return ; } if ( ! watch <identifiersep> points <identifiersep> registry . should <identifiersep> watch ( dir ) ) { log . debug ( <string_literal> , dir ) ; <ect>
log . debug ( <string_literal> , event ) ; } } private void maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( file <identifiersep> watcher watcher , file dir ) throws io <identifiersep> exception { log . debug ( <string_literal> , dir ) ; if ( is <identifiersep> stop <identifiersep> requested ( watcher ) ) { log . debug ( <string_literal> ) ; return ; } <LOG> if ( ! watch <identifiersep> points <identifiersep> registry . should <identifiersep> watch ( dir ) ) { return ; } if ( dir . exists ( ) ) { if ( ! file <identifiersep> tree <identifiersep> watching <identifiersep> supported ) { watch <identifiersep> dir ( dir . to <identifiersep> path ( ) ) ; } file [ ] contents = dir . list <identifiersep> files ( ) ; <ect>
for ( file file : contents ) { if ( is <identifiersep> stop <identifiersep> requested ( watcher ) ) { log . debug ( <string_literal> ) ; return ; } maybe <identifiersep> fire ( watcher , file <identifiersep> watcher <identifiersep> event . create ( file ) ) ; if ( file . is <identifiersep> directory ( ) ) { <LOG> maybe <identifiersep> watch <identifiersep> new <identifiersep> directory ( watcher , file ) ; } } } } } private boolean is <identifiersep> stop <identifiersep> requested ( file <identifiersep> watcher watcher ) { return thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) || ! watcher . is <identifiersep> running ( ) ; } } <ect>
deliver <identifiersep> events ( events ) ; } } catch ( closed <identifiersep> watch <identifiersep> service <identifiersep> exception e ) { logger . debug ( <string_literal> ) ; stop ( ) ; } } } private void deliver <identifiersep> events ( list < file <identifiersep> watcher <identifiersep> event > events ) { for ( file <identifiersep> watcher <identifiersep> event event : events ) { <LOG> if ( ! is <identifiersep> running ( ) ) { break ; logger . debug ( <string_literal> , event ) ; } watch <identifiersep> service <identifiersep> registrar . on <identifiersep> change ( file <identifiersep> watcher , event ) ; } } private boolean is <identifiersep> running ( ) { <ect>
logger . debug ( <string_literal> , event ) ; } watch <identifiersep> service <identifiersep> registrar . on <identifiersep> change ( file <identifiersep> watcher , event ) ; } } private boolean is <identifiersep> running ( ) { return running . get ( ) && ! thread . current <identifiersep> thread ( ) . is <identifiersep> interrupted ( ) ; } private void stop ( ) { if ( stopped . compare <identifiersep> and <identifiersep> set ( false , true ) ) { <LOG> if ( running . compare <identifiersep> and <identifiersep> set ( true , false ) ) { interrupt <identifiersep> poller <identifiersep> thread ( ) ; try { watch <identifiersep> service . close ( ) ; } catch ( io <identifiersep> exception e ) { <comment> <ect>
return new jdk7file <identifiersep> watcher <identifiersep> factory ( executor , file <identifiersep> system ) ; } @ override public void stop ( ) { try { executor . stop ( stop <identifiersep> timeout <identifiersep> seconds , time <identifiersep> unit . seconds ) ; } catch ( exception e ) { <LOG> <comment> <ect>
public void on <identifiersep> pending <identifiersep> changes ( ) { <comment> <LOG> } else { } } } <ect>
public void execute ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { if ( state . get <identifiersep> executed ( ) ) { return ; } logger . debug ( <string_literal> , task ) ; try { executer . execute ( task , state , context ) ; <LOG> } finally { } } } <ect>
logger . debug ( <string_literal> , task ) ; task <identifiersep> properties task <identifiersep> properties = context . get <identifiersep> task <identifiersep> properties ( ) ; task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key cache <identifiersep> key = context . get <identifiersep> build <identifiersep> cache <identifiersep> key ( ) ; boolean task <identifiersep> output <identifiersep> caching <identifiersep> enabled = state . get <identifiersep> task <identifiersep> output <identifiersep> caching ( ) . is <identifiersep> enabled ( ) ; sorted <identifiersep> set < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > output <identifiersep> properties = null ; if ( task <identifiersep> output <identifiersep> caching <identifiersep> enabled ) { <LOG> if ( task . is <identifiersep> has <identifiersep> custom <identifiersep> actions ( ) ) { } if ( cache <identifiersep> key . is <identifiersep> valid ( ) ) { task <identifiersep> artifact <identifiersep> state task <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; <comment> <ect>
private final task <identifiersep> execution <identifiersep> graph task <identifiersep> execution <identifiersep> graph ; private final task <identifiersep> executer executer ; public skip <identifiersep> task <identifiersep> with <identifiersep> no <identifiersep> actions <identifiersep> executer ( task <identifiersep> execution <identifiersep> graph task <identifiersep> execution <identifiersep> graph , task <identifiersep> executer executer ) { this . task <identifiersep> execution <identifiersep> graph = task <identifiersep> execution <identifiersep> graph ; this . executer = executer ; } public void execute ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { <LOG> if ( ! task . has <identifiersep> task <identifiersep> actions ( ) ) { boolean up <identifiersep> to <identifiersep> date = true ; <comment> <ect>
executer . execute ( task , state , context ) ; } private static void ensure <identifiersep> output ( task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec output <identifiersep> property , file output , output <identifiersep> type type ) { if ( output == null ) { logger . debug ( <string_literal> , output <identifiersep> property ) ; return ; } switch ( type ) { <LOG> case directory : mkdirs ( output ) ; break ; case file : logger . debug ( <string_literal> , output <identifiersep> property , output ) ; mkdirs ( output . get <identifiersep> parent <identifiersep> file ( ) ) ; <ect>
@ override public void execute ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { if ( task <identifiersep> output <identifiersep> cache <identifiersep> enabled ) { try { task <identifiersep> output <identifiersep> caching <identifiersep> state task <identifiersep> output <identifiersep> caching <identifiersep> state = task . get <identifiersep> outputs ( ) . get <identifiersep> caching <identifiersep> state ( context . get <identifiersep> task <identifiersep> properties ( ) ) ; state . set <identifiersep> task <identifiersep> output <identifiersep> caching ( task <identifiersep> output <identifiersep> caching <identifiersep> state ) ; <LOG> if ( ! task <identifiersep> output <identifiersep> caching <identifiersep> state . is <identifiersep> enabled ( ) ) { } } catch ( exception t ) { throw new gradle <identifiersep> exception ( string . format ( <string_literal> , task ) , t ) ; } } else { state . set <identifiersep> task <identifiersep> output <identifiersep> caching ( default <identifiersep> task <identifiersep> outputs . disabled ) ; } delegate . execute ( task , state , context ) ; <ect>
logger . debug ( <string_literal> , task , clock . get <identifiersep> elapsed ( ) ) ; try { executer . execute ( task , state , context ) ; } finally { outputs . set <identifiersep> history ( null ) ; context . set <identifiersep> task <identifiersep> artifact <identifiersep> state ( null ) ; <LOG> context . set <identifiersep> task <identifiersep> properties ( null ) ; } } } <ect>
file <identifiersep> collection source <identifiersep> files = task <identifiersep> properties . get <identifiersep> source <identifiersep> files ( ) ; if ( task <identifiersep> properties . has <identifiersep> source <identifiersep> files ( ) && source <identifiersep> files . is <identifiersep> empty ( ) ) { task <identifiersep> artifact <identifiersep> state task <identifiersep> artifact <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; task <identifiersep> execution <identifiersep> history execution <identifiersep> history = task <identifiersep> artifact <identifiersep> state . get <identifiersep> execution <identifiersep> history ( ) ; set < file > output <identifiersep> files = execution <identifiersep> history . get <identifiersep> output <identifiersep> files ( ) ; if ( output <identifiersep> files . is <identifiersep> empty ( ) ) { <LOG> state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . no <identifiersep> source ) ; } else { boolean cleanup <identifiersep> directories = execution <identifiersep> history . get <identifiersep> overlapping <identifiersep> outputs ( ) == null ; if ( ! cleanup <identifiersep> directories ) { logger . info ( <string_literal> , task ) ; <ect>
boolean deleted <identifiersep> files = false ; for ( file file : output <identifiersep> files ) { if ( file . exists ( ) && build <identifiersep> output <identifiersep> cleanup <identifiersep> registry . is <identifiersep> output <identifiersep> owned <identifiersep> by <identifiersep> build ( file ) ) { if ( ! cleanup <identifiersep> directories && file . is <identifiersep> directory ( ) ) { continue ; } <LOG> if ( debug <identifiersep> enabled ) { } g <identifiersep> file <identifiersep> utils . force <identifiersep> delete ( file ) ; deleted <identifiersep> files = true ; } } if ( deleted <identifiersep> files ) { logger . info ( <string_literal> , task ) ; state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . executed ) ; <ect>
} ) ; } private task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key do <identifiersep> resolve ( task <identifiersep> internal task , task <identifiersep> execution <identifiersep> context context ) { task <identifiersep> artifact <identifiersep> state task <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key cache <identifiersep> key = task <identifiersep> state . calculate <identifiersep> cache <identifiersep> key ( ) ; if ( context . get <identifiersep> task <identifiersep> properties ( ) . has <identifiersep> declared <identifiersep> outputs ( ) ) { <comment> <LOG> log <identifiersep> level log <identifiersep> level = build <identifiersep> cache <identifiersep> debug <identifiersep> logging ? log <identifiersep> level . lifecycle : log <identifiersep> level . info ; } } return cache <identifiersep> key ; } private static class operation <identifiersep> details <identifiersep> impl implements snapshot <identifiersep> task <identifiersep> inputs <identifiersep> build <identifiersep> operation <identifiersep> type . details { private static final operation <identifiersep> details <identifiersep> impl instance = new operation <identifiersep> details <identifiersep> impl ( ) ; } @ visible <identifiersep> for <identifiersep> testing static class operation <identifiersep> result <identifiersep> impl implements snapshot <identifiersep> task <identifiersep> inputs <identifiersep> build <identifiersep> operation <identifiersep> type . result { <ect>
public skip <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> task <identifiersep> executer ( task <identifiersep> executer executer ) { this . executer = executer ; } public void execute ( task <identifiersep> internal task , task <identifiersep> state <identifiersep> internal state , task <identifiersep> execution <identifiersep> context context ) { logger . debug ( <string_literal> , task ) ; task <identifiersep> artifact <identifiersep> state task <identifiersep> artifact <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; list < string > messages = new array <identifiersep> list < string > ( task <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> state . max <identifiersep> out <identifiersep> of <identifiersep> date <identifiersep> messages ) ; <LOG> if ( task <identifiersep> artifact <identifiersep> state . is <identifiersep> up <identifiersep> to <identifiersep> date ( messages ) ) { state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . up <identifiersep> to <identifiersep> date ) ; context . set <identifiersep> origin <identifiersep> execution <identifiersep> metadata ( task <identifiersep> artifact <identifiersep> state . get <identifiersep> execution <identifiersep> history ( ) . get <identifiersep> origin <identifiersep> execution <identifiersep> metadata ( ) ) ; return ; } context . set <identifiersep> up <identifiersep> to <identifiersep> date <identifiersep> messages ( immutable <identifiersep> list . copy <identifiersep> of ( messages ) ) ; log <identifiersep> out <identifiersep> of <identifiersep> date <identifiersep> messages ( messages , task ) ; <ect>
for ( context <identifiersep> aware <identifiersep> task <identifiersep> action action : actions ) { state . set <identifiersep> did <identifiersep> work ( true ) ; task . get <identifiersep> standard <identifiersep> output <identifiersep> capture ( ) . start ( ) ; try { execute <identifiersep> action ( action . get <identifiersep> display <identifiersep> name ( ) , task , action , context ) ; } catch ( stop <identifiersep> action <identifiersep> exception e ) { <LOG> <comment> <ect>
private set < module > load <identifiersep> modules ( properties properties ) { set < module > modules = new linked <identifiersep> hash <identifiersep> set < module > ( ) ; for ( string plugin <identifiersep> module : properties . get <identifiersep> property ( <string_literal> ) . split ( <string_literal> ) ) { try { modules . add ( module <identifiersep> registry . get <identifiersep> module ( plugin <identifiersep> module ) ) ; } catch ( unknown <identifiersep> module <identifiersep> exception e ) { <LOG> <comment> <ect>
while ( it . has <identifiersep> next ( ) ) { object class <identifiersep> info = it . next ( ) ; if ( class <identifiersep> info != null ) { class clazz = ( class ) clazz <identifiersep> field . get ( class <identifiersep> info ) ; if ( clazz . get <identifiersep> class <identifiersep> loader ( ) == class <identifiersep> loader ) { <LOG> remove <identifiersep> from <identifiersep> global <identifiersep> class <identifiersep> value . invoke ( global <identifiersep> class <identifiersep> value , clazz ) ; } } } } } catch ( exception e ) { throw new gradle <identifiersep> exception ( <string_literal> + class <identifiersep> loader + <string_literal> + leaking <identifiersep> loader , e ) ; } } private iterator < ? > global <identifiersep> class <identifiersep> set <identifiersep> iterator ( ) throws illegal <identifiersep> access <identifiersep> exception , invocation <identifiersep> target <identifiersep> exception { return ( iterator ) global <identifiersep> class <identifiersep> set <identifiersep> iterator <identifiersep> method . invoke ( global <identifiersep> class <identifiersep> set <identifiersep> items ) ; } } <ect>
managed <identifiersep> class <identifiersep> loader <identifiersep> spec spec = new managed <identifiersep> class <identifiersep> loader <identifiersep> spec ( parent , class <identifiersep> path , implementation <identifiersep> hash , filter <identifiersep> spec ) ; synchronized ( lock ) { cached <identifiersep> class <identifiersep> loader cached <identifiersep> loader = by <identifiersep> id . get ( id ) ; if ( cached <identifiersep> loader == null || ! cached <identifiersep> loader . is ( spec ) ) { cached <identifiersep> class <identifiersep> loader new <identifiersep> loader = get <identifiersep> and <identifiersep> retain <identifiersep> loader ( class <identifiersep> path , spec , id ) ; by <identifiersep> id . put ( id , new <identifiersep> loader ) ; <LOG> if ( cached <identifiersep> loader != null ) { cached <identifiersep> loader . release ( id ) ; } return new <identifiersep> loader . class <identifiersep> loader ; } else { return cached <identifiersep> loader . class <identifiersep> loader ; } } } @ override <ect>
} ; } private current <identifiersep> task <identifiersep> execution create <identifiersep> execution ( task <identifiersep> internal task , task <identifiersep> properties task <identifiersep> properties , @ nullable historical <identifiersep> task <identifiersep> execution previous <identifiersep> execution , input <identifiersep> normalization <identifiersep> strategy normalization <identifiersep> strategy ) { class < ? extends task <identifiersep> internal > task <identifiersep> class = task . get <identifiersep> class ( ) ; list < context <identifiersep> aware <identifiersep> task <identifiersep> action > task <identifiersep> actions = task . get <identifiersep> task <identifiersep> actions ( ) ; implementation <identifiersep> snapshot task <identifiersep> implementation = new implementation <identifiersep> snapshot ( task <identifiersep> class . get <identifiersep> name ( ) , class <identifiersep> loader <identifiersep> hierarchy <identifiersep> hasher . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( task <identifiersep> class . get <identifiersep> class <identifiersep> loader ( ) ) ) ; <LOG> immutable <identifiersep> list < implementation <identifiersep> snapshot > task <identifiersep> action <identifiersep> implementations = collect <identifiersep> action <identifiersep> implementations ( task <identifiersep> actions , class <identifiersep> loader <identifiersep> hierarchy <identifiersep> hasher ) ; logger . debug ( <string_literal> , task , task <identifiersep> action <identifiersep> implementations ) ; } immutable <identifiersep> sorted <identifiersep> map < string , value <identifiersep> snapshot > previous <identifiersep> input <identifiersep> properties = previous <identifiersep> execution == null ? immutable <identifiersep> sorted <identifiersep> map . < string , value <identifiersep> snapshot > of ( ) : previous <identifiersep> execution . get <identifiersep> input <identifiersep> properties ( ) ; immutable <identifiersep> sorted <identifiersep> map < string , value <identifiersep> snapshot > input <identifiersep> properties = snapshot <identifiersep> task <identifiersep> input <identifiersep> properties ( task , task <identifiersep> properties , previous <identifiersep> input <identifiersep> properties , value <identifiersep> snapshotter ) ; immutable <identifiersep> sorted <identifiersep> set < string > output <identifiersep> property <identifiersep> names = get <identifiersep> output <identifiersep> property <identifiersep> names <identifiersep> for <identifiersep> cache <identifiersep> key ( task <identifiersep> properties ) ; immutable <identifiersep> set < string > declared <identifiersep> output <identifiersep> file <identifiersep> paths = get <identifiersep> declared <identifiersep> output <identifiersep> file <identifiersep> paths ( task <identifiersep> properties , string <identifiersep> interner ) ; <ect>
discovered <identifiersep> files <identifiersep> snapshot = snapshot <identifiersep> discovered <identifiersep> inputs ( task , normalization <identifiersep> strategy , task <identifiersep> inputs . get <identifiersep> discovered <identifiersep> inputs ( ) , snapshotter <identifiersep> registry , file <identifiersep> collection <identifiersep> factory ) ; } else { discovered <identifiersep> files <identifiersep> snapshot = empty <identifiersep> file <identifiersep> collection <identifiersep> snapshot . instance ; } current <identifiersep> execution . set <identifiersep> discovered <identifiersep> input <identifiersep> files <identifiersep> snapshot ( discovered <identifiersep> files <identifiersep> snapshot ) ; } private static file <identifiersep> collection <identifiersep> snapshot snapshot <identifiersep> discovered <identifiersep> inputs ( task task , input <identifiersep> normalization <identifiersep> strategy normalization <identifiersep> strategy , collection < file > discovered <identifiersep> inputs , file <identifiersep> collection <identifiersep> snapshotter <identifiersep> registry snapshotter <identifiersep> registry , file <identifiersep> collection <identifiersep> factory file <identifiersep> collection <identifiersep> factory ) { file <identifiersep> collection <identifiersep> snapshotter snapshotter = snapshotter <identifiersep> registry . get <identifiersep> snapshotter ( generic <identifiersep> file <identifiersep> normalizer . class ) ; <LOG> if ( discovered <identifiersep> inputs . is <identifiersep> empty ( ) ) { return empty <identifiersep> file <identifiersep> collection <identifiersep> snapshot . instance ; } logger . debug ( <string_literal> , task ) ; try { return snapshotter . snapshot ( file <identifiersep> collection <identifiersep> factory . fixed ( <string_literal> , discovered <identifiersep> inputs ) , absolute , normalization <identifiersep> strategy ) ; } catch ( exception e ) { <ect>
@ visible <identifiersep> for <identifiersep> testing static immutable <identifiersep> sorted <identifiersep> map < string , file <identifiersep> collection <identifiersep> snapshot > snapshot <identifiersep> task <identifiersep> files ( task <identifiersep> internal task , string title , input <identifiersep> normalization <identifiersep> strategy normalization <identifiersep> strategy , sorted <identifiersep> set < ? extends task <identifiersep> file <identifiersep> property <identifiersep> spec > file <identifiersep> properties , file <identifiersep> collection <identifiersep> snapshotter <identifiersep> registry snapshotter <identifiersep> registry ) { immutable <identifiersep> sorted <identifiersep> map . builder < string , file <identifiersep> collection <identifiersep> snapshot > builder = immutable <identifiersep> sorted <identifiersep> map . natural <identifiersep> order ( ) ; for ( task <identifiersep> file <identifiersep> property <identifiersep> spec property <identifiersep> spec : file <identifiersep> properties ) { file <identifiersep> collection <identifiersep> snapshot result ; try { <LOG> file <identifiersep> collection <identifiersep> snapshotter snapshotter = snapshotter <identifiersep> registry . get <identifiersep> snapshotter ( property <identifiersep> spec . get <identifiersep> normalizer ( ) ) ; result = snapshotter . snapshot ( property <identifiersep> spec . get <identifiersep> property <identifiersep> files ( ) , property <identifiersep> spec . get <identifiersep> path <identifiersep> normalization <identifiersep> strategy ( ) , normalization <identifiersep> strategy ) ; } catch ( exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( string . format ( <string_literal> , title . to <identifiersep> lower <identifiersep> case ( ) , task , property <identifiersep> spec . get <identifiersep> property <identifiersep> name ( ) ) , e ) ; } builder . put ( property <identifiersep> spec . get <identifiersep> property <identifiersep> name ( ) , result ) ; } return builder . build ( ) ; <ect>
this . log <identifiersep> interval = max <identifiersep> size / <number_literal> ; } public void set <identifiersep> cache ( cache < object , object > cache ) { this . cache = cache ; } @ override public void on <identifiersep> removal ( removal <identifiersep> notification < object , object > notification ) { if ( notification . get <identifiersep> cause ( ) == removal <identifiersep> cause . size ) { <LOG> if ( eviction <identifiersep> counter % log <identifiersep> interval == 0 ) { } eviction <identifiersep> counter ++ ; } } } <ect>
return new in <identifiersep> memory <identifiersep> decorated <identifiersep> cache < k , v > ( backing <identifiersep> cache , cache <identifiersep> details . entries , cache <identifiersep> id , cache <identifiersep> details . lock <identifiersep> state ) ; } private cache <identifiersep> details get <identifiersep> cache ( final string cache <identifiersep> id , final int max <identifiersep> size ) { cache <identifiersep> details cache <identifiersep> details = caches . get ( cache <identifiersep> id , new transformer < cache <identifiersep> details , string > ( ) { @ override public cache <identifiersep> details transform ( string cache <identifiersep> id ) { cache < object , object > entries = create <identifiersep> in <identifiersep> memory <identifiersep> cache ( cache <identifiersep> id , max <identifiersep> size ) ; <LOG> cache <identifiersep> details cache <identifiersep> details = new cache <identifiersep> details ( cache <identifiersep> id , max <identifiersep> size , entries , new atomic <identifiersep> reference < file <identifiersep> lock . state > ( null ) ) ; return cache <identifiersep> details ; } } ) ; if ( cache <identifiersep> details . max <identifiersep> entries != max <identifiersep> size ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + cache <identifiersep> id + <string_literal> + max <identifiersep> size + <string_literal> + cache <identifiersep> details . max <identifiersep> entries ) ; } return cache <identifiersep> details ; <ect>
cleanup entry = ( cleanup ) reference <identifiersep> queue . remove ( ) ; class <identifiersep> path key = entry . get <identifiersep> key ( ) ; remove <identifiersep> cache <identifiersep> entry ( key , entry , dont <identifiersep> close <identifiersep> classloader ) ; } } catch ( interrupted <identifiersep> exception ex ) { log . debug ( <string_literal> ) ; } } <LOG> private void remove <identifiersep> cache <identifiersep> entry ( class <identifiersep> path key , cleanup entry , cleanup . mode mode ) { } lock . lock ( ) ; try { cache <identifiersep> entries . remove ( key ) ; cleanups . remove ( key ) ; } finally { <ect>
stopped . set ( true ) ; interrupt ( ) ; lock . lock ( ) ; try { while ( ! cleanups . is <identifiersep> empty ( ) ) { map . entry < class <identifiersep> path , cleanup > entry = cleanups . entry <identifiersep> set ( ) . iterator ( ) . next ( ) ; <LOG> remove <identifiersep> cache <identifiersep> entry ( entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) , close <identifiersep> classloader ) ; } } finally { lock . unlock ( ) ; } } public void put <identifiersep> cleanup ( class <identifiersep> path key , cleanup cleanup ) { cleanups . put ( key , cleanup ) ; } } <ect>
<comment> <LOG> default <identifiersep> tasks = collections . singleton <identifiersep> list ( project <identifiersep> internal . help <identifiersep> task ) ; } else { logger . info ( <string_literal> , g <identifiersep> util . to <identifiersep> string ( default <identifiersep> tasks ) ) ; } start <identifiersep> parameter . set <identifiersep> task <identifiersep> names ( default <identifiersep> tasks ) ; context . proceed ( ) ; } } <ect>
worker <identifiersep> lease parent <identifiersep> worker <identifiersep> lease = worker <identifiersep> lease <identifiersep> service . get <identifiersep> current <identifiersep> worker <identifiersep> lease ( ) ; start <identifiersep> additional <identifiersep> workers ( task <identifiersep> execution <identifiersep> plan , task <identifiersep> worker , executor , parent <identifiersep> worker <identifiersep> lease ) ; task <identifiersep> worker ( task <identifiersep> execution <identifiersep> plan , task <identifiersep> worker , parent <identifiersep> worker <identifiersep> lease ) . run ( ) ; task <identifiersep> execution <identifiersep> plan . await <identifiersep> completion ( ) ; } finally { executor . stop ( ) ; } } <LOG> private void start <identifiersep> additional <identifiersep> workers ( task <identifiersep> execution <identifiersep> plan task <identifiersep> execution <identifiersep> plan , action < ? super task <identifiersep> internal > task <identifiersep> worker , executor executor , worker <identifiersep> lease parent <identifiersep> worker <identifiersep> lease ) { for ( int i = 1 ; i < executor <identifiersep> count ; i ++ ) { runnable worker = task <identifiersep> worker ( task <identifiersep> execution <identifiersep> plan , task <identifiersep> worker , parent <identifiersep> worker <identifiersep> lease ) ; executor . execute ( worker ) ; } } private runnable task <identifiersep> worker ( task <identifiersep> execution <identifiersep> plan task <identifiersep> execution <identifiersep> plan , action < ? super task <identifiersep> internal > task <identifiersep> worker , worker <identifiersep> lease parent <identifiersep> worker <identifiersep> lease ) { return new task <identifiersep> executor <identifiersep> worker ( task <identifiersep> execution <identifiersep> plan , task <identifiersep> worker , parent <identifiersep> worker <identifiersep> lease ) ; <ect>
final string task <identifiersep> path = task . get <identifiersep> path ( ) ; logger . info ( <string_literal> , task <identifiersep> path , thread . current <identifiersep> thread ( ) ) ; task <identifiersep> timer . reset ( ) ; task <identifiersep> worker . execute ( task ) ; long task <identifiersep> duration = task <identifiersep> timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; <LOG> busy . add <identifiersep> and <identifiersep> get ( task <identifiersep> duration ) ; } } } ) ; } long total = total <identifiersep> timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) , time <identifiersep> formatting . format <identifiersep> duration <identifiersep> verbose ( busy . get ( ) ) , time <identifiersep> formatting . format <identifiersep> duration <identifiersep> verbose ( total - busy . get ( ) ) ) ; } } } } <ect>
final timer clock = time . start <identifiersep> timer ( ) ; set < task > task <identifiersep> set = new linked <identifiersep> hash <identifiersep> set < task > ( ) ; for ( task task : tasks ) { task <identifiersep> set . add ( task ) ; requested <identifiersep> tasks . add ( task ) ; } task <identifiersep> execution <identifiersep> plan . add <identifiersep> to <identifiersep> task <identifiersep> graph ( task <identifiersep> set ) ; <LOG> task <identifiersep> graph <identifiersep> state = task <identifiersep> graph <identifiersep> state . dirty ; } @ override public void populate ( ) { ensure <identifiersep> populated ( ) ; } public void execute ( ) { timer clock = time . start <identifiersep> timer ( ) ; <ect>
configuration . set <identifiersep> target <identifiersep> directory ( classes <identifiersep> dir ) ; try { compile <identifiersep> script ( source , class <identifiersep> loader , configuration , metadata <identifiersep> dir , extracting <identifiersep> transformer , verifier ) ; } catch ( gradle <identifiersep> exception e ) { g <identifiersep> file <identifiersep> utils . delete <identifiersep> directory ( classes <identifiersep> dir ) ; g <identifiersep> file <identifiersep> utils . delete <identifiersep> directory ( metadata <identifiersep> dir ) ; <LOG> throw e ; } } private void compile <identifiersep> script ( final script <identifiersep> source source , class <identifiersep> loader class <identifiersep> loader , compiler <identifiersep> configuration configuration , file metadata <identifiersep> dir , final compile <identifiersep> operation < ? > extracting <identifiersep> transformer , final action < ? super class <identifiersep> node > custom <identifiersep> verifier ) { final transformer transformer = extracting <identifiersep> transformer != null ? extracting <identifiersep> transformer . get <identifiersep> transformer ( ) : null ; logger . info ( <string_literal> , source . get <identifiersep> display <identifiersep> name ( ) , transformer != null ? transformer . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) : <string_literal> ) ; final empty <identifiersep> script <identifiersep> detector empty <identifiersep> script <identifiersep> detector = new empty <identifiersep> script <identifiersep> detector ( ) ; <ect>
deployment . up <identifiersep> to <identifiersep> date ( failure ) ; } } } finally { lock . unlock ( ) ; } } @ override public void stop ( ) { lock . lock ( ) ; <LOG> try { composite <identifiersep> stoppable . stoppable ( deployments . values ( ) ) . stop ( ) ; } finally { logger . debug ( <string_literal> ) ; stopped = true ; deployments . clear ( ) ; <ect>
private void set <identifiersep> project <identifiersep> properties ( project project , caching <identifiersep> property <identifiersep> applicator applicator ) { add <identifiersep> properties <identifiersep> to <identifiersep> project ( project , applicator ) ; for ( project child <identifiersep> project : project . get <identifiersep> child <identifiersep> projects ( ) . values ( ) ) { set <identifiersep> project <identifiersep> properties ( child <identifiersep> project , applicator ) ; } } private void add <identifiersep> properties <identifiersep> to <identifiersep> project ( project project , caching <identifiersep> property <identifiersep> applicator applicator ) { properties project <identifiersep> properties = new properties ( ) ; <LOG> file project <identifiersep> properties <identifiersep> file = new file ( project . get <identifiersep> project <identifiersep> dir ( ) , project . gradle <identifiersep> properties ) ; if ( project <identifiersep> properties <identifiersep> file . is <identifiersep> file ( ) ) { project <identifiersep> properties = g <identifiersep> util . load <identifiersep> properties ( project <identifiersep> properties <identifiersep> file ) ; logger . debug ( <string_literal> , project <identifiersep> properties . key <identifiersep> set ( ) ) ; } else { <ect>
file project <identifiersep> properties <identifiersep> file = new file ( project . get <identifiersep> project <identifiersep> dir ( ) , project . gradle <identifiersep> properties ) ; logger . debug ( <string_literal> , project <identifiersep> properties <identifiersep> file ) ; if ( project <identifiersep> properties <identifiersep> file . is <identifiersep> file ( ) ) { project <identifiersep> properties = g <identifiersep> util . load <identifiersep> properties ( project <identifiersep> properties <identifiersep> file ) ; logger . debug ( <string_literal> , project <identifiersep> properties . key <identifiersep> set ( ) ) ; <LOG> } else { } <comment> <ect>
logger . debug ( <string_literal> , system <identifiersep> project <identifiersep> properties . key <identifiersep> set ( ) ) ; return system <identifiersep> project <identifiersep> properties ; } private map < string , string > get <identifiersep> env <identifiersep> project <identifiersep> properties ( map < string , string > env <identifiersep> properties ) { map < string , string > env <identifiersep> project <identifiersep> properties = new hash <identifiersep> map < string , string > ( ) ; for ( map . entry < string , string > entry : env <identifiersep> properties . entry <identifiersep> set ( ) ) { if ( entry . get <identifiersep> key ( ) . starts <identifiersep> with ( env <identifiersep> project <identifiersep> properties <identifiersep> prefix ) && entry . get <identifiersep> key ( ) . length ( ) > env <identifiersep> project <identifiersep> properties <identifiersep> prefix . length ( ) ) { <LOG> env <identifiersep> project <identifiersep> properties . put ( entry . get <identifiersep> key ( ) . substring ( env <identifiersep> project <identifiersep> properties <identifiersep> prefix . length ( ) ) , entry . get <identifiersep> value ( ) ) ; } } return env <identifiersep> project <identifiersep> properties ; } private void set <identifiersep> system <identifiersep> properties ( map < string , string > properties ) { add <identifiersep> system <identifiersep> properties <identifiersep> from <identifiersep> gradle <identifiersep> properties ( default <identifiersep> properties ) ; add <identifiersep> system <identifiersep> properties <identifiersep> from <identifiersep> gradle <identifiersep> properties ( override <identifiersep> properties ) ; system . get <identifiersep> properties ( ) . put <identifiersep> all ( properties ) ; <ect>
private final cached <identifiersep> classpath <identifiersep> transformer cached <identifiersep> classpath <identifiersep> transformer ; public build <identifiersep> src <identifiersep> update <identifiersep> factory ( build <identifiersep> controller build <identifiersep> controller , build <identifiersep> src <identifiersep> build <identifiersep> listener <identifiersep> factory listener <identifiersep> factory , cached <identifiersep> classpath <identifiersep> transformer cached <identifiersep> classpath <identifiersep> transformer ) { this . build <identifiersep> controller = build <identifiersep> controller ; this . listener <identifiersep> factory = listener <identifiersep> factory ; this . cached <identifiersep> classpath <identifiersep> transformer = cached <identifiersep> classpath <identifiersep> transformer ; } public class <identifiersep> path create ( ) { <LOG> collection < file > classpath = build ( ) ; return cached <identifiersep> classpath <identifiersep> transformer . transform ( new default <identifiersep> class <identifiersep> path ( classpath ) ) ; } private collection < file > build ( ) { build <identifiersep> src <identifiersep> build <identifiersep> listener <identifiersep> factory . listener listener = listener <identifiersep> factory . create ( ) ; gradle <identifiersep> internal gradle = build <identifiersep> controller . get <identifiersep> gradle ( ) ; gradle . add <identifiersep> listener ( listener ) ; <ect>
public class build <identifiersep> script <identifiersep> processor implements project <identifiersep> configure <identifiersep> action { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( build <identifiersep> script <identifiersep> processor . class ) ; private final script <identifiersep> plugin <identifiersep> factory configurer <identifiersep> factory ; public build <identifiersep> script <identifiersep> processor ( script <identifiersep> plugin <identifiersep> factory configurer <identifiersep> factory ) { this . configurer <identifiersep> factory = configurer <identifiersep> factory ; } <LOG> public void execute ( project <identifiersep> internal project ) { } final timer clock = time . start <identifiersep> timer ( ) ; try { script <identifiersep> plugin configurer = configurer <identifiersep> factory . create ( project . get <identifiersep> build <identifiersep> script <identifiersep> source ( ) , project . get <identifiersep> buildscript ( ) , project . get <identifiersep> class <identifiersep> loader <identifiersep> scope ( ) , project . get <identifiersep> base <identifiersep> class <identifiersep> loader <identifiersep> scope ( ) , true ) ; configurer . apply ( project ) ; <ect>
if ( state . has <identifiersep> failure ( ) ) { <comment> <LOG> } else { } return ; } add <identifiersep> configuration <identifiersep> failure ( project , state , e ) ; } } private void add <identifiersep> configuration <identifiersep> failure ( project <identifiersep> internal project , project <identifiersep> state <identifiersep> internal state , exception e ) { project <identifiersep> configuration <identifiersep> exception failure = new project <identifiersep> configuration <identifiersep> exception ( string . format ( <string_literal> , project . get <identifiersep> display <identifiersep> name ( ) ) , e ) ; state . executed ( failure ) ; <ect>
public class debugging <identifiersep> task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder implements task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder { private static final logger logger = logging . get <identifiersep> logger ( debugging <identifiersep> task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder . class ) ; private final task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder delegate ; public debugging <identifiersep> task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder ( task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key <identifiersep> builder delegate ) { this . delegate = delegate ; } @ override <LOG> public void append <identifiersep> task <identifiersep> implementation ( implementation <identifiersep> snapshot task <identifiersep> implementation ) { if ( ! task <identifiersep> implementation . has <identifiersep> unknown <identifiersep> class <identifiersep> loader ( ) ) { log ( <string_literal> , task <identifiersep> implementation . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( ) ) ; } delegate . append <identifiersep> task <identifiersep> implementation ( task <identifiersep> implementation ) ; } @ override public void append <identifiersep> task <identifiersep> action <identifiersep> implementations ( collection < implementation <identifiersep> snapshot > task <identifiersep> action <identifiersep> implementations ) { <ect>
log ( <string_literal> , task <identifiersep> implementation . get <identifiersep> type <identifiersep> name ( ) ) ; if ( ! task <identifiersep> implementation . has <identifiersep> unknown <identifiersep> class <identifiersep> loader ( ) ) { log ( <string_literal> , task <identifiersep> implementation . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( ) ) ; } delegate . append <identifiersep> task <identifiersep> implementation ( task <identifiersep> implementation ) ; } @ override public void append <identifiersep> task <identifiersep> action <identifiersep> implementations ( collection < implementation <identifiersep> snapshot > task <identifiersep> action <identifiersep> implementations ) { <LOG> for ( implementation <identifiersep> snapshot action <identifiersep> impl : task <identifiersep> action <identifiersep> implementations ) { log ( <string_literal> , action <identifiersep> impl . has <identifiersep> unknown <identifiersep> class <identifiersep> loader ( ) ? null : action <identifiersep> impl . get <identifiersep> class <identifiersep> loader <identifiersep> hash ( ) ) ; } delegate . append <identifiersep> task <identifiersep> action <identifiersep> implementations ( task <identifiersep> action <identifiersep> implementations ) ; } @ override public void append <identifiersep> input <identifiersep> property <identifiersep> hash ( string property <identifiersep> name , hash <identifiersep> code hash <identifiersep> code ) { logger . lifecycle ( <string_literal> , property <identifiersep> name , hash <identifiersep> code ) ; <ect>
delegate . append <identifiersep> input <identifiersep> property <identifiersep> hash ( property <identifiersep> name , hash <identifiersep> code ) ; } @ override public void input <identifiersep> property <identifiersep> loaded <identifiersep> by <identifiersep> unknown <identifiersep> class <identifiersep> loader ( string property <identifiersep> name ) { logger . lifecycle ( <string_literal> , property <identifiersep> name ) ; delegate . input <identifiersep> property <identifiersep> loaded <identifiersep> by <identifiersep> unknown <identifiersep> class <identifiersep> loader ( property <identifiersep> name ) ; } @ override <LOG> public void append <identifiersep> output <identifiersep> property <identifiersep> name ( string property <identifiersep> name ) { delegate . append <identifiersep> output <identifiersep> property <identifiersep> name ( property <identifiersep> name ) ; } @ override public task <identifiersep> output <identifiersep> caching <identifiersep> build <identifiersep> cache <identifiersep> key build ( ) { return delegate . build ( ) ; } private void log ( string name , @ nullable object value ) { <ect>
try { return state ; } finally { lock . unlock ( ) ; } } private void set <identifiersep> state ( exec <identifiersep> handle <identifiersep> state state ) { lock . lock ( ) ; <LOG> try { this . state = state ; this . state <identifiersep> changed . signal <identifiersep> all ( ) ; } finally { lock . unlock ( ) ; } } private boolean state <identifiersep> in ( exec <identifiersep> handle <identifiersep> state . . . states ) { <ect>
return current <identifiersep> state == exec <identifiersep> handle <identifiersep> state . starting ? format ( <string_literal> , display <identifiersep> name ) : format ( <string_literal> , display <identifiersep> name ) ; } public exec <identifiersep> handle start ( ) { logger . info ( <string_literal> , <LOG> display <identifiersep> name , directory , command + ' ' + joiner . on ( ' ' ) . use <identifiersep> for <identifiersep> null ( <string_literal> ) . join ( arguments ) ) ; } lock . lock ( ) ; try { if ( ! state <identifiersep> in ( exec <identifiersep> handle <identifiersep> state . init ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( format ( <string_literal> , display <identifiersep> name ) ) ; } set <identifiersep> state ( exec <identifiersep> handle <identifiersep> state . starting ) ; <ect>
logger . debug ( <string_literal> , display <identifiersep> name ) ; try { state <identifiersep> changed . await ( ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> exec <identifiersep> result . rethrow <identifiersep> failure ( ) ; } } finally { lock . unlock ( ) ; } return this ; } public void abort ( ) { lock . lock ( ) ; <ect>
synchronized ( lock ) { if ( worker <identifiersep> class <identifiersep> path == null ) { worker <identifiersep> class <identifiersep> path <identifiersep> cache = cache <identifiersep> repository . cache ( <string_literal> ) . with <identifiersep> initializer ( new cache <identifiersep> initializer ( ) ) . open ( ) ; <LOG> worker <identifiersep> class <identifiersep> path = new default <identifiersep> class <identifiersep> path ( jar <identifiersep> file ( worker <identifiersep> class <identifiersep> path <identifiersep> cache ) ) ; } return worker <identifiersep> class <identifiersep> path ; } } return null ; } public void close ( ) { <comment> <ect>
this . action = action ; this . worker <identifiersep> id = worker <identifiersep> id ; this . display <identifiersep> name = display <identifiersep> name ; this . gradle <identifiersep> user <identifiersep> home <identifiersep> dir = gradle <identifiersep> user <identifiersep> home <identifiersep> dir ; } public void execute ( final worker <identifiersep> context worker <identifiersep> context ) { final object <identifiersep> connection client <identifiersep> connection = worker <identifiersep> context . get <identifiersep> server <identifiersep> connection ( ) ; <LOG> final service <identifiersep> registry service <identifiersep> registry = worker <identifiersep> context . get <identifiersep> service <identifiersep> registry ( ) ; worker <identifiersep> process <identifiersep> context context = new worker <identifiersep> process <identifiersep> context ( ) { public object <identifiersep> connection get <identifiersep> server <identifiersep> connection ( ) { return client <identifiersep> connection ; } public class <identifiersep> loader get <identifiersep> application <identifiersep> class <identifiersep> loader ( ) { return worker <identifiersep> context . get <identifiersep> application <identifiersep> class <identifiersep> loader ( ) ; <ect>
lock . unlock ( ) ; } } public void on <identifiersep> connect ( object <identifiersep> connection connection ) { on <identifiersep> connect ( connection , null ) ; } public void on <identifiersep> connect ( object <identifiersep> connection connection , runnable connection <identifiersep> handler ) { async <identifiersep> stoppable stoppable ; lock . lock ( ) ; <LOG> try { if ( connection <identifiersep> handler != null && running ) { connection <identifiersep> handler . run ( ) ; } this . connection = connection ; if ( aborted ) { connection . abort ( ) ; <ect>
} ) ; worker <identifiersep> process . start <identifiersep> accepting ( acceptor ) ; address local <identifiersep> address = acceptor . get <identifiersep> address ( ) ; <comment> <LOG> logger . debug ( <string_literal> , display <identifiersep> name ) ; logger . debug ( <string_literal> , implementation <identifiersep> class <identifiersep> path ) ; java <identifiersep> exec <identifiersep> handle <identifiersep> builder java <identifiersep> command = get <identifiersep> java <identifiersep> command ( ) ; java <identifiersep> command . set <identifiersep> display <identifiersep> name ( display <identifiersep> name ) ; worker <identifiersep> implementation <identifiersep> factory . prepare <identifiersep> java <identifiersep> command ( id , display <identifiersep> name , this , implementation <identifiersep> class <identifiersep> path , local <identifiersep> address , java <identifiersep> command , should <identifiersep> publish <identifiersep> jvm <identifiersep> memory <identifiersep> info ) ; java <identifiersep> command . args ( <string_literal> + display <identifiersep> name + <string_literal> ) ; <ect>
if ( exec <identifiersep> handle == null ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } this . exec <identifiersep> handle = exec <identifiersep> handle ; } public void run ( ) { try { exec <identifiersep> handle . abort ( ) ; <LOG> } catch ( throwable t ) { } } } <ect>
log . done ( ) } def <string_literal> ( ) { given : log . start ( ) when : log . operation <identifiersep> success ( <string_literal> , <string_literal> ) <LOG> then : 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <string_literal> <ect>
log . done ( ) } def <string_literal> ( ) { given : log . start ( ) when : log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) <LOG> then : 1 * logger . log ( error , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <string_literal> <ect>
log . done ( ) } def <string_literal> ( ) { when : log . start ( ) <number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) <LOG> then : <number_literal> * logger . log ( debug , <string_literal> ) <number_literal> * logger . log ( error , <string_literal> ) 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
when : log . start ( ) <number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <LOG> <number_literal> * logger . log ( debug , <string_literal> ) 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
<string_literal> <string_literal> logs continued message at end of overall operation <string_literal> < operation > <string_literal> < output > <string_literal> <LOG> then : <number_literal> * logger . log ( debug , <string_literal> ) <number_literal> * logger . log ( error , <string_literal> ) 1 * logger . log ( error , <string_literal> ) 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
when : log . start ( ) <number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <LOG> <number_literal> * logger . log ( debug , <string_literal> ) 1 * logger . log ( error , <string_literal> ) 1 * logger . log ( info , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
<number_literal> . times { log . operation <identifiersep> failed ( <string_literal> , <string_literal> ) } log . done ( ) then : 1 * logger . log ( info , <string_literal> ) <number_literal> * logger . log ( debug , <string_literal> ) <number_literal> * logger . log ( error , <string_literal> ) <LOG> 1 * logger . log ( error , <string_literal> ) log <identifiersep> output ( ) == <string_literal> <string_literal> <ect>
attributes . is this . attributes } } def <string_literal> ( ) { when : config ( <string_literal> ) then : thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception <LOG> when : then : not <identifiersep> thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception when : config ( <string_literal> ) then : <ect>
config ( <string_literal> ) then : not <identifiersep> thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception } def <string_literal> ( ) { given : attributes . is <identifiersep> root <identifiersep> project <identifiersep> has <identifiersep> vcs <identifiersep> mappings ( ) > > true <LOG> when : then : thrown unsupported <identifiersep> build <identifiersep> scan <identifiersep> plugin <identifiersep> version <identifiersep> exception } @ unroll def <string_literal> ( ) { given : <ect>
package org . gradle . testng ; import org . testng . annotations . after <identifiersep> class ; import org . testng . annotations . before <identifiersep> class ; import org . testng . annotations . test ; public class test1 { @ before <identifiersep> class <LOG> public void before <identifiersep> class ( ) { } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { <ect>
public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) <LOG> public void test2 ( ) { } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } } <ect>
import org . testng . annotations . before <identifiersep> class ; import org . testng . annotations . test ; public class test2 { public static class c implements serializable { private static final long serial <identifiersep> version <identifiersep> uid = 1l ; } @ before <identifiersep> class <LOG> public void before <identifiersep> class ( ) { } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { <ect>
public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) <LOG> public void test2 ( ) { } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } } <ect>
package org . gradle . junit ; import org . junit . test ; import org . junit . experimental . categories . category ; public class categorized <identifiersep> j <identifiersep> unit <identifiersep> test { @ category ( category <identifiersep> a . class ) @ test <LOG> public void a ( ) { } @ category ( category <identifiersep> b . class ) @ test public void b ( ) { system . out . println ( <string_literal> ) ; } <ect>
<comment> package org . gradle . junit ; import org . junit . test ; import java . lang . system ; public class simple <identifiersep> j <identifiersep> unit <identifiersep> test { @ test <LOG> public void ok ( ) { } <ect>
package org . gradle . sample ; import org . junit . test ; import java . lang . system ; public class util <identifiersep> test { @ test <LOG> public void ok ( ) { } } <ect>
package org . gradle . junitplatform ; import junit . framework . test <identifiersep> case ; public class j <identifiersep> unit3test extends test <identifiersep> case { <LOG> public void test <identifiersep> ok ( ) { } } <ect>
<comment> <LOG> public void ok ( ) { } } <comment> <ect>
import org . junit . jupiter . api . * ; public class jupiter <identifiersep> test { @ test public void ok ( ) { system . out . println ( <string_literal> ) ; } @ repeated <identifiersep> test ( <number_literal> ) <LOG> public void repeated ( ) { } @ before <identifiersep> each public void before <identifiersep> each ( ) { system . out . println ( <string_literal> ) ; } @ before <identifiersep> all public static void before <identifiersep> all ( ) { <ect>
public void repeated ( ) { system . out . println ( <string_literal> ) ; } @ before <identifiersep> each public void before <identifiersep> each ( ) { system . out . println ( <string_literal> ) ; } @ before <identifiersep> all <LOG> public static void before <identifiersep> all ( ) { } @ disabled @ test public void disabled ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } @ test <ect>
package org . gradle . sample . services ; import org . gradle . sample . api . person ; import org . gradle . sample . shared . helper ; public class person <identifiersep> service { <LOG> boolean check <identifiersep> person ( person person ) { if ( person . get <identifiersep> firstname ( ) . length ( ) < <number_literal> ) { return false ; } return true ; } <ect>
public class hello { <LOG> public static void main ( string [ ] args ) { } } <ect>
import org . apache . log4j . logger ; public class main { private static final logger logger = logger . get <identifiersep> logger ( main . class ) ; <LOG> public static void main ( string args [ ] ) { } } <ect>
import org . apache . log4j . logger ; public class main { private static final logger logger = logger . get <identifiersep> logger ( main . class ) ; <LOG> public static void main ( string args [ ] ) { } } <ect>
if ( args . length > 1 ) { connector . use <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( new file ( args [ 1 ] ) ) ; } } connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> custom <identifiersep> model model = connection . get <identifiersep> model ( custom <identifiersep> model . class ) ; system . out . println ( <string_literal> ) ; for ( string task : model . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task ) ; } } finally { <comment> <ect>
project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> for ( string task : model . get <identifiersep> tasks ( ) ) { } } finally { <comment> <ect>
system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <LOG> for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; <ect>
system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { <LOG> system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; <ect>
for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { <LOG> system . out . println ( <string_literal> + dir ) ; } for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; <ect>
system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { <LOG> system . out . println ( <string_literal> + dir ) ; } for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> dependency dependency : module . get <identifiersep> dependencies ( ) ) { system . out . println ( <string_literal> + dependency ) ; <ect>
system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> test <identifiersep> directories ( ) ) { system . out . println ( <string_literal> + dir ) ; } system . out . println ( <string_literal> ) ; for ( file dir : root . get <identifiersep> exclude <identifiersep> directories ( ) ) { <LOG> system . out . println ( <string_literal> + dir ) ; } } for ( idea <identifiersep> dependency dependency : module . get <identifiersep> dependencies ( ) ) { system . out . println ( <string_literal> + dependency ) ; } } } finally { <comment> <ect>
if ( args . length > 1 ) { connector . use <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( new file ( args [ 1 ] ) ) ; } } connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> gradle <identifiersep> project project = connection . get <identifiersep> model ( gradle <identifiersep> project . class ) ; system . out . println ( <string_literal> ) ; for ( task task : project . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } } finally { <comment> <ect>
project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> for ( task task : project . get <identifiersep> tasks ( ) ) { } } finally { <comment> <ect>
connector . use <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( new file ( args [ 1 ] ) ) ; } } connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { <comment> <LOG> system . out . println ( <string_literal> + project . get <identifiersep> name ( ) ) ; system . out . println ( <string_literal> ) ; for ( eclipse <identifiersep> source <identifiersep> directory src <identifiersep> dir : project . get <identifiersep> source <identifiersep> directories ( ) ) { system . out . println ( src <identifiersep> dir . get <identifiersep> path ( ) ) ; } system . out . println ( <string_literal> ) ; for ( external <identifiersep> dependency external <identifiersep> dependency : project . get <identifiersep> classpath ( ) ) { <ect>
<comment> <LOG> system . out . println ( src <identifiersep> dir . get <identifiersep> path ( ) ) ; } for ( external <identifiersep> dependency external <identifiersep> dependency : project . get <identifiersep> classpath ( ) ) { system . out . println ( external <identifiersep> dependency . get <identifiersep> file ( ) . get <identifiersep> name ( ) ) ; } system . out . println ( <string_literal> ) ; system . out . println ( project . get <identifiersep> gradle <identifiersep> project ( ) ) ; } finally { <ect>
import org . gradle . api . tasks . input ; import org . gradle . api . tasks . task <identifiersep> action ; public class greeting <identifiersep> task extends default <identifiersep> task { @ input public string who = <string_literal> ; @ task <identifiersep> action <LOG> public void greet ( ) { } } <ect>
import org . apache . commons . collections . list . growth <identifiersep> list ; public class main { public static void main ( string [ ] args ) { growth <identifiersep> list l = new growth <identifiersep> list ( ) ; if ( system . get <identifiersep> property ( <string_literal> ) . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; <LOG> } else { } } <ect>
@ unroll def <string_literal> ( ) { given : temporary <identifiersep> folder . file ( <string_literal> ) < < ''' <comment> <LOG> system . out . println ( <string_literal> ) ''' when : system . out . println ( <string_literal> ) system . err . println ( <string_literal> ) def result1 = executer <ect>
<comment> <LOG> system . out . println ( <string_literal> ) def result1 = executer . in <identifiersep> directory ( temporary <identifiersep> folder . test <identifiersep> directory ) . with <identifiersep> tasks ( <string_literal> ) . with <identifiersep> console ( console ) . run ( ) <ect>
system . err . println ( <string_literal> ) def result1 = executer . in <identifiersep> directory ( temporary <identifiersep> folder . test <identifiersep> directory ) . with <identifiersep> tasks ( <string_literal> ) . with <identifiersep> console ( console ) . run ( ) <LOG> system . out . println ( <string_literal> ) def result2 = executer . in <identifiersep> directory ( temporary <identifiersep> folder . test <identifiersep> directory ) . with <identifiersep> tasks ( <string_literal> ) . with <identifiersep> console ( console ) . run ( ) <ect>
while ( ! pending . is <identifiersep> empty ( ) && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; if ( wait <identifiersep> ms < 0 ) { system . out . println ( string . format ( <string_literal> , id ) ) ; failure = new assertion <identifiersep> error ( string . format ( <string_literal> , pending . key <identifiersep> set ( ) , received ) ) ; condition . signal <identifiersep> all ( ) ; <LOG> throw failure ; } condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } if ( failure != null ) { <comment> <ect>
if ( most <identifiersep> recent <identifiersep> event < now ) { most <identifiersep> recent <identifiersep> event = now ; } request <identifiersep> started = true ; condition . signal <identifiersep> all ( ) ; while ( ! released && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - clock . get <identifiersep> current <identifiersep> time ( ) ; <LOG> if ( wait <identifiersep> ms < 0 ) { failure = new assertion <identifiersep> error ( <string_literal> ) ; condition . signal <identifiersep> all ( ) ; throw failure ; } try { condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; <ect>
@ override public void handle ( http <identifiersep> exchange http <identifiersep> exchange ) throws io <identifiersep> exception { try { int id = counter . increment <identifiersep> and <identifiersep> get ( ) ; system . out . println ( string . format ( <string_literal> , id , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) . get <identifiersep> path ( ) ) ) ; resource <identifiersep> handler resource <identifiersep> handler = select <identifiersep> handler ( id , http <identifiersep> exchange ) ; <LOG> if ( resource <identifiersep> handler != null ) { try { resource <identifiersep> handler . write <identifiersep> to ( id , http <identifiersep> exchange ) ; } catch ( throwable e ) { failures . add ( e ) ; } } else { <ect>
private void handle <identifiersep> connection ( output <identifiersep> stream output <identifiersep> stream ) throws io <identifiersep> exception { system . out . println ( <string_literal> ) ; synchronized ( lock ) { if ( connected ) { system . out . println ( <string_literal> ) ; output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; <LOG> return ; } connected = true ; lock . notify <identifiersep> all ( ) ; long expiry = monotonic <identifiersep> clock <identifiersep> millis ( ) + <number_literal> ; while ( ! released && ! stopped ) { long delay = expiry - monotonic <identifiersep> clock <identifiersep> millis ( ) ; <ect>
output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; return ; } try { lock . wait ( delay ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } } <LOG> if ( stopped ) { output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; return ; } connected = false ; released = false ; lock . notify <identifiersep> all ( ) ; <ect>
connected = false ; released = false ; lock . notify <identifiersep> all ( ) ; } system . out . println ( <string_literal> ) ; output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; } } ) ; } <LOG> void stop ( ) { synchronized ( lock ) { stopped = true ; lock . notify <identifiersep> all ( ) ; } try { server <identifiersep> socket . close ( ) ; <ect>
system . out . println ( <string_literal> ) ; try { lock . wait ( delay ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } } if ( stopped ) { <LOG> throw new assertion <identifiersep> failed <identifiersep> error ( string . format ( <string_literal> , get <identifiersep> uri ( ) ) ) ; } return true ; } } private long monotonic <identifiersep> clock <identifiersep> millis ( ) { return system . nano <identifiersep> time ( ) / 1000000l ; } <comment> <ect>
uri uri = uri ( resource ) ; return <string_literal> + uri + <string_literal> + uri + <string_literal> ; } <comment> public string call <identifiersep> from <identifiersep> build <identifiersep> using <identifiersep> expression ( string expression ) { <LOG> string uri <identifiersep> expression = <string_literal> + get <identifiersep> uri ( ) + <string_literal> + expression ; } public void with <identifiersep> basic <identifiersep> authentication ( final string username , final string password ) { context . set <identifiersep> authenticator ( new basic <identifiersep> authenticator ( <string_literal> ) { @ override public boolean check <identifiersep> credentials ( string u , string pwd ) { return u . equals ( username ) && password . equals ( pwd ) ; <ect>
condition . signal <identifiersep> all ( ) ; } while ( ! released . contains ( path ) && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - clock . get <identifiersep> current <identifiersep> time ( ) ; if ( wait <identifiersep> ms < 0 ) { if ( waiting <identifiersep> for > 0 ) { system . out . println ( string . format ( <string_literal> , id ) ) ; <LOG> throw timeout <identifiersep> waiting <identifiersep> for <identifiersep> requests ( ) ; } failure = new assertion <identifiersep> error ( string . format ( <string_literal> , waiting <identifiersep> for , received , released , expected . key <identifiersep> set ( ) ) ) ; condition . signal <identifiersep> all ( ) ; throw failure ; } system . out . println ( string . format ( <string_literal> , id , waiting <identifiersep> for , received ) ) ; condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; <ect>
failure = new assertion <identifiersep> error ( string . format ( <string_literal> , waiting <identifiersep> for , received , released , expected . key <identifiersep> set ( ) ) ) ; condition . signal <identifiersep> all ( ) ; throw failure ; } system . out . println ( string . format ( <string_literal> , id , waiting <identifiersep> for , received ) ) ; condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } if ( failure != null ) { <LOG> <comment> <ect>
lock . unlock ( ) ; } } protected void do <identifiersep> release <identifiersep> all ( ) { lock . lock ( ) ; try { int count = 0 ; for ( string path : received ) { <LOG> if ( ! released . contains ( path ) ) { released . add ( path ) ; all . get ( path ) . released ( ) ; count ++ ; } } do <identifiersep> release ( count ) ; } finally { <ect>
if ( release <identifiersep> count != count ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } do <identifiersep> release ( count ) ; } finally { lock . unlock ( ) ; } } private void do <identifiersep> release ( int count ) { <LOG> waiting <identifiersep> for = math . min ( expected . size ( ) , waiting <identifiersep> for + count ) ; condition . signal <identifiersep> all ( ) ; } @ override public void wait <identifiersep> for <identifiersep> all <identifiersep> pending <identifiersep> calls ( ) { lock . lock ( ) ; try { <ect>
if ( most <identifiersep> recent <identifiersep> event < now ) { most <identifiersep> recent <identifiersep> event = now ; } while ( waiting <identifiersep> for > 0 && failure == null ) { long wait <identifiersep> ms = most <identifiersep> recent <identifiersep> event + timeout <identifiersep> ms - clock . get <identifiersep> current <identifiersep> time ( ) ; if ( wait <identifiersep> ms < 0 ) { system . out . println ( string . format ( <string_literal> , test <identifiersep> id ) ) ; <LOG> throw timeout <identifiersep> waiting <identifiersep> for <identifiersep> requests ( ) ; } try { condition . await ( wait <identifiersep> ms , time <identifiersep> unit . milliseconds ) ; } catch ( interrupted <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } } if ( failure != null ) { <ect>
sample <identifiersep> name = get <identifiersep> sample <identifiersep> name ( method ) ; return new statement ( ) { @ override public void evaluate ( ) throws throwable { if ( sample <identifiersep> name != null ) { string hint <identifiersep> for <identifiersep> missing <identifiersep> sample = string . format ( <string_literal> , sample <identifiersep> name ) ; <LOG> test <identifiersep> file src <identifiersep> dir = new integration <identifiersep> test <identifiersep> build <identifiersep> context ( ) . get <identifiersep> samples <identifiersep> dir ( ) . file ( sample <identifiersep> name ) . assert <identifiersep> is <identifiersep> dir ( hint <identifiersep> for <identifiersep> missing <identifiersep> sample ) ; src <identifiersep> dir . copy <identifiersep> to ( get <identifiersep> dir ( ) ) ; } else { logger . debug ( <string_literal> ) ; } base . evaluate ( ) ; } } ; <ect>
} ; } <comment> public void maybe <identifiersep> copy ( string resource ) { test <identifiersep> file dir = resources . find <identifiersep> resource ( resource ) ; <LOG> if ( dir != null ) { dir . copy <identifiersep> to ( get <identifiersep> dir ( ) ) ; } else { logger . debug ( <string_literal> , resource ) ; } } } <ect>
test <identifiersep> file get <identifiersep> gradle <identifiersep> home <identifiersep> dir ( ) { download ( ) super . get <identifiersep> gradle <identifiersep> home <identifiersep> dir ( ) } private void download ( ) { if ( cache == null ) { def download <identifiersep> action = { cache - > <LOG> url url = get <identifiersep> download <identifiersep> url ( ) ; super . bin <identifiersep> distribution . copy <identifiersep> from ( url ) super . bin <identifiersep> distribution . using <identifiersep> native <identifiersep> tools ( ) . unzip <identifiersep> to ( version <identifiersep> dir ) } <comment> <ect>
jvms . add <identifiersep> all ( new base <identifiersep> dir <identifiersep> jvm <identifiersep> locator ( file <identifiersep> canonicalizer , new file ( <string_literal> ) ) . find <identifiersep> jvms ( ) ) ; } jvms . add <identifiersep> all ( new home <identifiersep> dir <identifiersep> jvm <identifiersep> locator ( file <identifiersep> canonicalizer ) . find <identifiersep> jvms ( ) ) ; <comment> <LOG> } ) ; } for ( jvm <identifiersep> installation jvm : jvms ) { system . out . println ( <string_literal> + jvm ) ; } return jvms ; } private static class dev <identifiersep> infrastructure <identifiersep> jvm <identifiersep> locator { final file <identifiersep> canonicalizer file <identifiersep> canonicalizer ; <ect>
result . assert <identifiersep> not <identifiersep> output ( <string_literal> ) result . assert <identifiersep> not <identifiersep> output ( <string_literal> ) result . assert <identifiersep> not <identifiersep> output ( <string_literal> ) when : result . assert <identifiersep> not <identifiersep> output ( text ) then : <LOG> def e = thrown ( assertion <identifiersep> error ) found unexpected text in build output . expected not present : $ { text } output : <string_literal> <string_literal> <ect>
connection . set <identifiersep> request <identifiersep> property ( <string_literal> , <string_literal> + credentials ) ; final output <identifiersep> stream output <identifiersep> stream = connection . get <identifiersep> output <identifiersep> stream ( ) ; io <identifiersep> utils . write ( <string_literal> + url <identifiersep> encoder . encode ( message , <string_literal> ) , output <identifiersep> stream ) ; io <identifiersep> utils . close <identifiersep> quietly ( output <identifiersep> stream ) ; logger . info ( <string_literal> + message + <string_literal> + username + <string_literal> ) ; <LOG> final input <identifiersep> stream input <identifiersep> stream = connection . get <identifiersep> input <identifiersep> stream ( ) ; io <identifiersep> utils . close <identifiersep> quietly ( input <identifiersep> stream ) ; } } catch ( exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } finally { if ( connection != null ) { <ect>
<comment> public void announce ( string msg , string type ) { try { announcer <identifiersep> factory . create <identifiersep> announcer ( type ) . send ( project . get <identifiersep> name ( ) , msg ) ; <LOG> } catch ( exception e ) { } } <comment> public string get <identifiersep> username ( ) { return username ; <ect>
if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { logger . debug ( <string_literal> , candidate ) ; loopback . add ( candidate ) ; } else { logger . debug ( <string_literal> , candidate ) ; } } else { <LOG> if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { } else { logger . debug ( <string_literal> , candidate ) ; remote . add ( candidate ) ; is <identifiersep> remote = true ; } } } if ( is <identifiersep> multicast ) { <ect>
} else { logger . debug ( <string_literal> , candidate ) ; remote . add ( candidate ) ; is <identifiersep> remote = true ; } } } if ( is <identifiersep> multicast ) { <comment> <LOG> if ( is <identifiersep> remote ) { multicast <identifiersep> interfaces . add ( 0 , network <identifiersep> interface ) ; } else { logger . debug ( <string_literal> , network <identifiersep> interface . get <identifiersep> display <identifiersep> name ( ) ) ; multicast <identifiersep> interfaces . add ( network <identifiersep> interface ) ; } } } catch ( socket <identifiersep> exception e ) { <ect>
logger . debug ( <string_literal> , network <identifiersep> interface . get <identifiersep> display <identifiersep> name ( ) ) ; multicast <identifiersep> interfaces . add ( 0 , network <identifiersep> interface ) ; } else { logger . debug ( <string_literal> , network <identifiersep> interface . get <identifiersep> display <identifiersep> name ( ) ) ; multicast <identifiersep> interfaces . add ( network <identifiersep> interface ) ; } } } catch ( socket <identifiersep> exception e ) { <LOG> <comment> <ect>
server <identifiersep> socket . socket ( ) . bind ( new inet <identifiersep> socket <identifiersep> address ( address <identifiersep> factory . get <identifiersep> local <identifiersep> binding <identifiersep> address ( ) , 0 ) ) ; local <identifiersep> port = server <identifiersep> socket . socket ( ) . get <identifiersep> local <identifiersep> port ( ) ; } catch ( exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } uuid id = id <identifiersep> generator . generate <identifiersep> id ( ) ; list < inet <identifiersep> address > addresses = address <identifiersep> factory . get <identifiersep> communication <identifiersep> addresses ( ) ; <LOG> final address address = new multi <identifiersep> choice <identifiersep> address ( id , local <identifiersep> port , addresses ) ; final managed <identifiersep> executor executor = executor <identifiersep> factory . create ( <string_literal> + ( allow <identifiersep> remote ? <string_literal> : <string_literal> ) + <string_literal> + local <identifiersep> port ) ; executor . execute ( new receiver ( server <identifiersep> socket , action , allow <identifiersep> remote ) ) ; return new connection <identifiersep> acceptor ( ) { public address get <identifiersep> address ( ) { return address ; <ect>
final socket <identifiersep> channel socket = server <identifiersep> socket . accept ( ) ; inet <identifiersep> socket <identifiersep> address remote <identifiersep> socket <identifiersep> address = ( inet <identifiersep> socket <identifiersep> address ) socket . socket ( ) . get <identifiersep> remote <identifiersep> socket <identifiersep> address ( ) ; inet <identifiersep> address remote <identifiersep> inet <identifiersep> address = remote <identifiersep> socket <identifiersep> address . get <identifiersep> address ( ) ; if ( ! allow <identifiersep> remote && ! address <identifiersep> factory . is <identifiersep> communication <identifiersep> address ( remote <identifiersep> inet <identifiersep> address ) ) { logger . error ( <string_literal> , remote <identifiersep> inet <identifiersep> address ) ; socket . close ( ) ; <LOG> continue ; } try { action . execute ( new socket <identifiersep> connect <identifiersep> completion ( socket ) ) ; } catch ( throwable t ) { socket . close ( ) ; throw t ; <ect>
public class tcp <identifiersep> outgoing <identifiersep> connector implements outgoing <identifiersep> connector { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( tcp <identifiersep> outgoing <identifiersep> connector . class ) ; private static final int connect <identifiersep> timeout = <number_literal> ; public connect <identifiersep> completion connect ( address destination <identifiersep> address ) throws org . gradle . internal . remote . internal . connect <identifiersep> exception { if ( ! ( destination <identifiersep> address instanceof inet <identifiersep> endpoint ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( string . format ( <string_literal> , destination <identifiersep> address ) ) ; } <LOG> inet <identifiersep> endpoint address = ( inet <identifiersep> endpoint ) destination <identifiersep> address ; <comment> <ect>
exception last <identifiersep> failure = null ; for ( inet <identifiersep> address candidate : candidate <identifiersep> addresses ) { logger . debug ( <string_literal> , candidate ) ; socket <identifiersep> channel socket <identifiersep> channel ; try { socket <identifiersep> channel = try <identifiersep> connect ( address , candidate ) ; <LOG> } catch ( socket <identifiersep> exception e ) { last <identifiersep> failure = e ; continue ; } catch ( socket <identifiersep> timeout <identifiersep> exception e ) { logger . debug ( <string_literal> , candidate ) ; last <identifiersep> failure = e ; <ect>
logger . debug ( <string_literal> , candidate ) ; last <identifiersep> failure = e ; continue ; } catch ( socket <identifiersep> timeout <identifiersep> exception e ) { logger . debug ( <string_literal> , candidate ) ; last <identifiersep> failure = e ; <LOG> continue ; } return new socket <identifiersep> connect <identifiersep> completion ( socket <identifiersep> channel ) ; } throw new org . gradle . internal . remote . internal . connect <identifiersep> exception ( string . format ( <string_literal> , destination <identifiersep> address , candidate <identifiersep> addresses ) , last <identifiersep> failure ) ; } catch ( org . gradle . internal . remote . internal . connect <identifiersep> exception e ) { throw e ; <ect>
throw new runtime <identifiersep> exception ( string . format ( <string_literal> , ip <identifiersep> address , key ) , e ) ; } } } return null ; } private void find <identifiersep> communication <identifiersep> addresses ( ) throws unknown <identifiersep> host <identifiersep> exception { communication <identifiersep> addresses = new array <identifiersep> list < inet <identifiersep> address > ( ) ; if ( inet <identifiersep> addresses . get <identifiersep> loopback ( ) . is <identifiersep> empty ( ) ) { if ( inet <identifiersep> addresses . get <identifiersep> remote ( ) . is <identifiersep> empty ( ) ) { <LOG> inet <identifiersep> address fallback = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( null ) ; communication <identifiersep> addresses . add ( fallback ) ; } else { logger . debug ( <string_literal> ) ; communication <identifiersep> addresses . add <identifiersep> all ( inet <identifiersep> addresses . get <identifiersep> remote ( ) ) ; } } else { <ect>
public string to <identifiersep> string ( ) { return <string_literal> + local <identifiersep> address + <string_literal> + remote <identifiersep> address ; } public t receive ( ) throws message <identifiersep> io <identifiersep> exception { try { return object <identifiersep> reader . read ( ) ; <LOG> } catch ( eof <identifiersep> exception e ) { } return null ; } catch ( object <identifiersep> stream <identifiersep> exception e ) { throw new recoverable <identifiersep> message <identifiersep> io <identifiersep> exception ( string . format ( <string_literal> , remote <identifiersep> address ) , e ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { throw new recoverable <identifiersep> message <identifiersep> io <identifiersep> exception ( string . format ( <string_literal> , remote <identifiersep> address ) , e ) ; <ect>
private throwable get <identifiersep> message <identifiersep> exec ; public exception <identifiersep> placeholder ( final throwable throwable , transformer < exception <identifiersep> replacing <identifiersep> object <identifiersep> output <identifiersep> stream , output <identifiersep> stream > object <identifiersep> output <identifiersep> stream <identifiersep> creator ) throws io <identifiersep> exception { type = throwable . get <identifiersep> class ( ) . get <identifiersep> name ( ) ; try { stack <identifiersep> trace = throwable . get <identifiersep> stack <identifiersep> trace ( ) == null ? new stack <identifiersep> trace <identifiersep> element [ 0 ] : throwable . get <identifiersep> stack <identifiersep> trace ( ) ; } catch ( throwable ignored ) { <LOG> <comment> <ect>
} ) ; try { oos . write <identifiersep> object ( throwable ) ; oos . close ( ) ; serialized <identifiersep> exception = buffer . read <identifiersep> as <identifiersep> byte <identifiersep> array ( ) ; } catch ( throwable ignored ) { <LOG> <comment> <ect>
reconstructed . set <identifiersep> stack <identifiersep> trace ( stack <identifiersep> trace ) ; return reconstructed ; } } catch ( unchecked <identifiersep> exception ignore ) { <comment> <LOG> } catch ( throwable ignored ) { } throwable placeholder = new placeholder <identifiersep> exception ( type , message , get <identifiersep> message <identifiersep> exec , to <identifiersep> string , to <identifiersep> string <identifiersep> runtime <identifiersep> exec , cause <identifiersep> throwable ) ; placeholder . set <identifiersep> stack <identifiersep> trace ( stack <identifiersep> trace ) ; return placeholder ; } private throwable get <identifiersep> cause ( transformer < class < ? > , string > class <identifiersep> name <identifiersep> transformer , transformer < exception <identifiersep> replacing <identifiersep> object <identifiersep> input <identifiersep> stream , input <identifiersep> stream > object <identifiersep> input <identifiersep> stream <identifiersep> creator ) throws io <identifiersep> exception { return cause != null ? cause . read ( class <identifiersep> name <identifiersep> transformer , object <identifiersep> input <identifiersep> stream <identifiersep> creator ) : null ; <ect>
private static final logger logger = logging . get <identifiersep> logger ( js <identifiersep> hint <identifiersep> worker . class ) ; @ override public js <identifiersep> hint <identifiersep> result process ( js <identifiersep> hint <identifiersep> spec spec ) { scriptable js <identifiersep> hint <identifiersep> scope = rhino <identifiersep> worker <identifiersep> utils . parse ( spec . get <identifiersep> js <identifiersep> hint ( ) , <string_literal> ) ; string encoding = spec . get <identifiersep> encoding ( ) ; map < file , map < string , object > > results = new linked <identifiersep> hash <identifiersep> map < file , map < string , object > > ( ) ; <LOG> for ( file target : spec . get <identifiersep> source ( ) ) { string source = read <identifiersep> file ( target , encoding ) ; map < string , object > result = js <identifiersep> hint ( js <identifiersep> hint <identifiersep> scope , source , target . get <identifiersep> name ( ) ) ; results . put ( target , result ) ; } return new js <identifiersep> hint <identifiersep> result ( results ) ; } private map < string , object > js <identifiersep> hint ( scriptable js <identifiersep> hint <identifiersep> scope , final string source , final string source <identifiersep> name ) { <ect>
uri relative <identifiersep> path = project <identifiersep> dir <identifiersep> uri . relativize ( file . to <identifiersep> uri ( ) ) ; logger . warn ( <string_literal> , relative <identifiersep> path . get <identifiersep> path ( ) ) ; for ( map . entry < string , object > error <identifiersep> entry : errors . entry <identifiersep> set ( ) ) { @ suppress <identifiersep> warnings ( <string_literal> ) map < string , object > error = ( map < string , object > ) error <identifiersep> entry . get <identifiersep> value ( ) ; int line = float . value <identifiersep> of ( error . get ( <string_literal> ) . to <identifiersep> string ( ) ) . int <identifiersep> value ( ) ; int character = float . value <identifiersep> of ( error . get ( <string_literal> ) . to <identifiersep> string ( ) ) . int <identifiersep> value ( ) ; <LOG> string reason = error . get ( <string_literal> ) . to <identifiersep> string ( ) ; } } } } file json <identifiersep> report <identifiersep> file = get <identifiersep> json <identifiersep> report ( ) ; if ( json <identifiersep> report <identifiersep> file != null ) { try { file <identifiersep> writer report <identifiersep> writer = new file <identifiersep> writer ( json <identifiersep> report <identifiersep> file ) ; new gson <identifiersep> builder ( ) . set <identifiersep> pretty <identifiersep> printing ( ) . create ( ) . to <identifiersep> json ( report <identifiersep> data , report <identifiersep> writer ) ; <ect>
build <identifiersep> file < < <string_literal> <string_literal> <LOG> all { component <identifiersep> selection selection - > fired < < <string_literal> } with <identifiersep> module ( 'org : parent' ) { component <identifiersep> selection selection - > logger . warn ( <string_literal> ) selection . reject ( <string_literal> ) } } } } dependencies { <ect>
''' ) src { main { java { 'hello . java' ( '''import org . apache . commons . lang3 . string <identifiersep> utils ; public class hello { <LOG> public static void main ( string . . . args ) { } } ''' ) } } } } when : run 'compile <identifiersep> java <identifiersep> free <identifiersep> debug' then : executed <identifiersep> and <identifiersep> not <identifiersep> skipped ' : compile <identifiersep> java <identifiersep> free <identifiersep> debug' <ect>
<comment> <LOG> module <identifiersep> version <identifiersep> publisher publisher = repository . create <identifiersep> publisher ( ) ; publisher . publish ( publish <identifiersep> meta <identifiersep> data ) ; } } private default <identifiersep> ivy <identifiersep> module <identifiersep> publish <identifiersep> metadata to <identifiersep> publish <identifiersep> meta <identifiersep> data ( module module , set < ? extends configuration <identifiersep> internal > configurations , boolean validate <identifiersep> artifacts ) { module <identifiersep> component <identifiersep> identifier id = default <identifiersep> module <identifiersep> component <identifiersep> identifier . new <identifiersep> id ( module . get <identifiersep> group ( ) , module . get <identifiersep> name ( ) , module . get <identifiersep> version ( ) ) ; default <identifiersep> ivy <identifiersep> module <identifiersep> publish <identifiersep> metadata publish <identifiersep> meta <identifiersep> data = new default <identifiersep> ivy <identifiersep> module <identifiersep> publish <identifiersep> metadata ( id , module . get <identifiersep> status ( ) ) ; add <identifiersep> configurations ( publish <identifiersep> meta <identifiersep> data , configurations , validate <identifiersep> artifacts ) ; <ect>
public < t extends has <identifiersep> attributes > list < t > match ( attribute <identifiersep> selection <identifiersep> schema schema , collection < ? extends t > candidates , attribute <identifiersep> container <identifiersep> internal requested , @ nullable t fallback ) { if ( candidates . size ( ) == 0 ) { if ( fallback != null && is <identifiersep> matching ( schema , ( attribute <identifiersep> container <identifiersep> internal ) fallback . get <identifiersep> attributes ( ) , requested ) ) { logger . debug ( <string_literal> , requested , fallback ) ; } <LOG> return immutable <identifiersep> list . of ( fallback ) ; } } return immutable <identifiersep> list . of ( ) ; } if ( candidates . size ( ) == 1 ) { t candidate = candidates . iterator ( ) . next ( ) ; if ( is <identifiersep> matching ( schema , ( attribute <identifiersep> container <identifiersep> internal ) candidate . get <identifiersep> attributes ( ) , requested ) ) { <ect>
if ( candidates . size ( ) == 1 ) { t candidate = candidates . iterator ( ) . next ( ) ; if ( is <identifiersep> matching ( schema , ( attribute <identifiersep> container <identifiersep> internal ) candidate . get <identifiersep> attributes ( ) , requested ) ) { logger . debug ( <string_literal> , candidate , candidates , requested ) ; } <LOG> return collections . singleton <identifiersep> list ( candidate ) ; } } return immutable <identifiersep> list . of ( ) ; } immutable <identifiersep> attributes requested <identifiersep> attributes = requested . as <identifiersep> immutable ( ) ; list < t > matches = new multiple <identifiersep> candidate <identifiersep> matcher < t > ( schema , candidates , requested <identifiersep> attributes ) . get <identifiersep> matches ( ) ; logger . debug ( <string_literal> , matches , candidates , requested ) ; <ect>
string key = metadata <identifiersep> location . to <identifiersep> string ( ) ; return resources <identifiersep> file <identifiersep> store . move ( key , downloaded <identifiersep> resource ) ; } } , null ) ; if ( resource == null ) { throw new missing <identifiersep> resource <identifiersep> exception ( metadata <identifiersep> location . get <identifiersep> uri ( ) , string . format ( <string_literal> , metadata <identifiersep> location ) ) ; } parse <identifiersep> maven <identifiersep> metadata <identifiersep> into ( resource , metadata ) ; } <LOG> private void parse <identifiersep> maven <identifiersep> metadata <identifiersep> into ( external <identifiersep> resource metadata <identifiersep> resource , final maven <identifiersep> metadata maven <identifiersep> metadata ) { metadata <identifiersep> resource . with <identifiersep> content ( new erroring <identifiersep> action < input <identifiersep> stream > ( ) { public void do <identifiersep> execute ( input <identifiersep> stream input <identifiersep> stream ) throws parser <identifiersep> configuration <identifiersep> exception , sax <identifiersep> exception , io <identifiersep> exception { xml <identifiersep> helper . parse ( input <identifiersep> stream , null , new contextual <identifiersep> sax <identifiersep> handler ( ) { public void end <identifiersep> element ( string uri , string local <identifiersep> name , string q <identifiersep> name ) throws sax <identifiersep> exception { <ect>
list < string > collector = lists . new <identifiersep> array <identifiersep> list ( ) ; for ( resource <identifiersep> pattern pattern : patterns ) { visit ( pattern , artifact , module , collector , result ) ; } if ( ! collector . is <identifiersep> empty ( ) ) { result . listed ( collector ) ; } } private void visit ( resource <identifiersep> pattern pattern , ivy <identifiersep> artifact <identifiersep> name artifact , module <identifiersep> identifier module , list < string > collector , buildable <identifiersep> module <identifiersep> version <identifiersep> listing <identifiersep> resolve <identifiersep> result result ) { <LOG> external <identifiersep> resource <identifiersep> name version <identifiersep> list <identifiersep> pattern = pattern . to <identifiersep> version <identifiersep> list <identifiersep> pattern ( module , artifact ) ; try { list < string > version <identifiersep> strings = list <identifiersep> revision <identifiersep> token ( version <identifiersep> list <identifiersep> pattern , result ) ; for ( string version <identifiersep> string : version <identifiersep> strings ) { collector . add ( version <identifiersep> string ) ; } } catch ( exception e ) { <ect>
if ( revision <identifiersep> matches <identifiersep> directory <identifiersep> name ( pattern ) ) { external <identifiersep> resource <identifiersep> name parent = version <identifiersep> list <identifiersep> pattern . get <identifiersep> root ( ) . resolve ( prefix ) ; return list <identifiersep> all ( parent , result ) ; } else { int parent <identifiersep> folder <identifiersep> slash <identifiersep> index = prefix . last <identifiersep> index <identifiersep> of ( file <identifiersep> separator ) ; string revision <identifiersep> parent <identifiersep> folder = parent <identifiersep> folder <identifiersep> slash <identifiersep> index == - 1 ? <string_literal> : prefix . substring ( 0 , parent <identifiersep> folder <identifiersep> slash <identifiersep> index + 1 ) ; <LOG> external <identifiersep> resource <identifiersep> name parent = version <identifiersep> list <identifiersep> pattern . get <identifiersep> root ( ) . resolve ( revision <identifiersep> parent <identifiersep> folder ) ; if ( ! visited <identifiersep> directories . add ( parent ) ) { return collections . empty <identifiersep> list ( ) ; } result . attempted ( parent ) ; list < string > all = repository . resource ( parent ) . list ( ) ; if ( all == null ) { <ect>
result . attempted ( parent ) ; list < string > all = repository . resource ( parent ) . list ( ) ; if ( all == null ) { return collections . empty <identifiersep> list ( ) ; } logger . debug ( <string_literal> , all . size ( ) ) ; pattern regex <identifiersep> pattern = create <identifiersep> regex <identifiersep> pattern ( pattern , parent <identifiersep> folder <identifiersep> slash <identifiersep> index ) ; <LOG> list < string > ret = filter <identifiersep> matched <identifiersep> values ( all , regex <identifiersep> pattern ) ; return ret ; } } private list < string > filter <identifiersep> matched <identifiersep> values ( list < string > all , final pattern p ) { list < string > ret = new array <identifiersep> list < string > ( all . size ( ) ) ; for ( string path : all ) { matcher m = p . matcher ( path ) ; <ect>
if ( ! visited <identifiersep> directories . add ( parent ) ) { return collections . empty <identifiersep> list ( ) ; } logger . debug ( <string_literal> , repository , parent ) ; result . attempted ( parent . to <identifiersep> string ( ) ) ; list < string > paths = repository . resource ( parent ) . list ( ) ; if ( paths == null ) { <LOG> return collections . empty <identifiersep> list ( ) ; } return paths ; } } <ect>
protected final void resolve <identifiersep> static <identifiersep> dependency ( module <identifiersep> component <identifiersep> identifier module <identifiersep> version <identifiersep> identifier , component <identifiersep> override <identifiersep> metadata prescribed <identifiersep> meta <identifiersep> data , buildable <identifiersep> module <identifiersep> component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> result result , external <identifiersep> resource <identifiersep> artifact <identifiersep> resolver artifact <identifiersep> resolver ) { for ( metadata <identifiersep> source < ? > source : metadata <identifiersep> sources . sources ( ) ) { mutable <identifiersep> module <identifiersep> component <identifiersep> resolve <identifiersep> metadata value = source . create ( name , component <identifiersep> resolvers , module <identifiersep> version <identifiersep> identifier , prescribed <identifiersep> meta <identifiersep> data , artifact <identifiersep> resolver , result ) ; if ( value != null ) { value . set <identifiersep> source ( artifact <identifiersep> resolver . get <identifiersep> source ( ) ) ; result . resolved ( value . as <identifiersep> immutable ( ) ) ; <LOG> return ; } } result . missing ( ) ; } protected abstract boolean is <identifiersep> meta <identifiersep> data <identifiersep> artifact ( artifact <identifiersep> type artifact <identifiersep> type ) ; protected set < module <identifiersep> component <identifiersep> artifact <identifiersep> metadata > find <identifiersep> optional <identifiersep> artifacts ( module <identifiersep> component <identifiersep> resolve <identifiersep> metadata module , string type , string classifier ) { module <identifiersep> component <identifiersep> artifact <identifiersep> metadata artifact = module . artifact ( type , <string_literal> , classifier ) ; if ( create <identifiersep> artifact <identifiersep> resolver ( module . get <identifiersep> source ( ) ) . artifact <identifiersep> exists ( artifact , new default <identifiersep> resource <identifiersep> aware <identifiersep> resolve <identifiersep> result ( ) ) ) { <ect>
return static <identifiersep> resource <identifiersep> exists ( artifact <identifiersep> patterns , artifact , result ) ; } private boolean static <identifiersep> resource <identifiersep> exists ( list < resource <identifiersep> pattern > pattern <identifiersep> list , module <identifiersep> component <identifiersep> artifact <identifiersep> metadata artifact , resource <identifiersep> aware <identifiersep> resolve <identifiersep> result result ) { for ( resource <identifiersep> pattern resource <identifiersep> pattern : pattern <identifiersep> list ) { if ( is <identifiersep> incomplete ( resource <identifiersep> pattern , artifact ) ) { continue ; } external <identifiersep> resource <identifiersep> name location = resource <identifiersep> pattern . get <identifiersep> location ( artifact ) ; <LOG> result . attempted ( location ) ; try { if ( repository . resource ( location , true ) . get <identifiersep> meta <identifiersep> data ( ) != null ) { return true ; } } catch ( exception e ) { throw resource <identifiersep> exceptions . get <identifiersep> failed ( location . get <identifiersep> uri ( ) , e ) ; <ect>
return null ; } private locally <identifiersep> available <identifiersep> external <identifiersep> resource download <identifiersep> by <identifiersep> coords ( list < resource <identifiersep> pattern > pattern <identifiersep> list , final module <identifiersep> component <identifiersep> artifact <identifiersep> metadata artifact , resource <identifiersep> aware <identifiersep> resolve <identifiersep> result result ) { for ( resource <identifiersep> pattern resource <identifiersep> pattern : pattern <identifiersep> list ) { if ( is <identifiersep> incomplete ( resource <identifiersep> pattern , artifact ) ) { continue ; } external <identifiersep> resource <identifiersep> name location = resource <identifiersep> pattern . get <identifiersep> location ( artifact ) ; <LOG> result . attempted ( location ) ; locally <identifiersep> available <identifiersep> resource <identifiersep> candidates local <identifiersep> candidates = locally <identifiersep> available <identifiersep> resource <identifiersep> finder . find <identifiersep> candidates ( artifact ) ; try { locally <identifiersep> available <identifiersep> external <identifiersep> resource resource = resource <identifiersep> accessor . get <identifiersep> resource ( location , null , new cache <identifiersep> aware <identifiersep> external <identifiersep> resource <identifiersep> accessor . resource <identifiersep> file <identifiersep> store ( ) { public locally <identifiersep> available <identifiersep> resource move <identifiersep> into <identifiersep> cache ( file downloaded <identifiersep> resource ) { return file <identifiersep> store . move ( artifact . get <identifiersep> id ( ) , downloaded <identifiersep> resource ) ; <ect>
file <identifiersep> resource <identifiersep> repository file <identifiersep> resource <identifiersep> repository ) { this . metadata <identifiersep> artifact <identifiersep> provider = metadata <identifiersep> artifact <identifiersep> provider ; this . file <identifiersep> resource <identifiersep> repository = file <identifiersep> resource <identifiersep> repository ; } @ override public s create ( string repository <identifiersep> name , component <identifiersep> resolvers component <identifiersep> resolvers , module <identifiersep> component <identifiersep> identifier module <identifiersep> version <identifiersep> identifier , component <identifiersep> override <identifiersep> metadata prescribed <identifiersep> meta <identifiersep> data , external <identifiersep> resource <identifiersep> artifact <identifiersep> resolver artifact <identifiersep> resolver , buildable <identifiersep> module <identifiersep> component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> result result ) { s parsed <identifiersep> metadata <identifiersep> from <identifiersep> repository = parse <identifiersep> meta <identifiersep> data <identifiersep> from <identifiersep> artifact ( repository <identifiersep> name , component <identifiersep> resolvers , module <identifiersep> version <identifiersep> identifier , artifact <identifiersep> resolver , result ) ; <LOG> if ( parsed <identifiersep> metadata <identifiersep> from <identifiersep> repository != null ) { } return parsed <identifiersep> metadata <identifiersep> from <identifiersep> repository ; } @ nullable private s parse <identifiersep> meta <identifiersep> data <identifiersep> from <identifiersep> artifact ( string repository <identifiersep> name , component <identifiersep> resolvers component <identifiersep> resolvers , module <identifiersep> component <identifiersep> identifier module <identifiersep> component <identifiersep> identifier , external <identifiersep> resource <identifiersep> artifact <identifiersep> resolver artifact <identifiersep> resolver , resource <identifiersep> aware <identifiersep> resolve <identifiersep> result result ) { module <identifiersep> component <identifiersep> artifact <identifiersep> metadata artifact = get <identifiersep> meta <identifiersep> data <identifiersep> artifact <identifiersep> for ( module <identifiersep> component <identifiersep> identifier ) ; locally <identifiersep> available <identifiersep> external <identifiersep> resource metadata <identifiersep> artifact = artifact <identifiersep> resolver . resolve <identifiersep> artifact ( artifact , result ) ; <ect>
this . time <identifiersep> provider = time <identifiersep> provider ; } public cached <identifiersep> metadata get <identifiersep> cached <identifiersep> module <identifiersep> descriptor ( module <identifiersep> component <identifiersep> repository repository , module <identifiersep> component <identifiersep> identifier component <identifiersep> id ) { final module <identifiersep> component <identifiersep> at <identifiersep> repository <identifiersep> key key = create <identifiersep> key ( repository , component <identifiersep> id ) ; return get ( key ) ; } protected cached <identifiersep> metadata get ( module <identifiersep> component <identifiersep> at <identifiersep> repository <identifiersep> key key ) { return in <identifiersep> memory <identifiersep> cache . get ( key ) ; } <LOG> public cached <identifiersep> metadata cache <identifiersep> missing ( module <identifiersep> component <identifiersep> repository repository , module <identifiersep> component <identifiersep> identifier id ) { module <identifiersep> component <identifiersep> at <identifiersep> repository <identifiersep> key key = create <identifiersep> key ( repository , id ) ; module <identifiersep> metadata <identifiersep> cache <identifiersep> entry entry = module <identifiersep> metadata <identifiersep> cache <identifiersep> entry . for <identifiersep> missing <identifiersep> module ( time <identifiersep> provider . get <identifiersep> current <identifiersep> time ( ) ) ; default <identifiersep> cached <identifiersep> metadata cached <identifiersep> meta <identifiersep> data = new default <identifiersep> cached <identifiersep> metadata ( entry , null , time <identifiersep> provider ) ; store ( key , entry , cached <identifiersep> meta <identifiersep> data ) ; return cached <identifiersep> meta <identifiersep> data ; <ect>
public class in <identifiersep> memory <identifiersep> module <identifiersep> versions <identifiersep> cache implements module <identifiersep> versions <identifiersep> cache { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( default <identifiersep> module <identifiersep> versions <identifiersep> cache . class ) ; private final build <identifiersep> commenced <identifiersep> time <identifiersep> provider time <identifiersep> provider ; private final map < module <identifiersep> at <identifiersep> repository <identifiersep> key , module <identifiersep> versions <identifiersep> cache <identifiersep> entry > in <identifiersep> memory <identifiersep> cache = maps . new <identifiersep> concurrent <identifiersep> map ( ) ; public in <identifiersep> memory <identifiersep> module <identifiersep> versions <identifiersep> cache ( build <identifiersep> commenced <identifiersep> time <identifiersep> provider time <identifiersep> provider ) { this . time <identifiersep> provider = time <identifiersep> provider ; } <LOG> public void cache <identifiersep> module <identifiersep> version <identifiersep> list ( module <identifiersep> component <identifiersep> repository repository , module <identifiersep> identifier module <identifiersep> id , set < string > listed <identifiersep> versions ) { module <identifiersep> at <identifiersep> repository <identifiersep> key key = create <identifiersep> key ( repository , module <identifiersep> id ) ; module <identifiersep> versions <identifiersep> cache <identifiersep> entry entry = create <identifiersep> entry ( listed <identifiersep> versions ) ; store ( key , entry ) ; } protected void store ( module <identifiersep> at <identifiersep> repository <identifiersep> key key , module <identifiersep> versions <identifiersep> cache <identifiersep> entry entry ) { in <identifiersep> memory <identifiersep> cache . put ( key , entry ) ; <ect>
private map < component <identifiersep> artifact <identifiersep> identifier , resolvable <identifiersep> artifact > get <identifiersep> resolved <identifiersep> artifact <identifiersep> cache ( module <identifiersep> component <identifiersep> repository input ) { map < component <identifiersep> artifact <identifiersep> identifier , resolvable <identifiersep> artifact > resolved <identifiersep> artifact <identifiersep> cache = cache <identifiersep> per <identifiersep> repo . get ( input . get <identifiersep> id ( ) ) ; if ( resolved <identifiersep> artifact <identifiersep> cache == null ) { log . debug ( <string_literal> , input . get <identifiersep> name ( ) , input . get <identifiersep> id ( ) ) ; resolved <identifiersep> artifact <identifiersep> cache = maps . new <identifiersep> concurrent <identifiersep> map ( ) ; cache <identifiersep> per <identifiersep> repo . put ( input . get <identifiersep> id ( ) , resolved <identifiersep> artifact <identifiersep> cache ) ; <LOG> } else { } return resolved <identifiersep> artifact <identifiersep> cache ; } public void stop ( ) { cache <identifiersep> per <identifiersep> repo . clear ( ) ; } private static class resolved <identifiersep> artifact <identifiersep> cache <identifiersep> providing <identifiersep> module <identifiersep> component <identifiersep> repository extends base <identifiersep> module <identifiersep> component <identifiersep> repository { private final map < component <identifiersep> artifact <identifiersep> identifier , resolvable <identifiersep> artifact > resolved <identifiersep> artifact <identifiersep> cache ; <ect>
return ; } <comment> <LOG> <comment> <ect>
<comment> <LOG> final immutable <identifiersep> list < edge <identifiersep> state > to <identifiersep> download <identifiersep> in <identifiersep> parallel = immutable <identifiersep> list . copy <identifiersep> of ( requiring <identifiersep> download ) ; build <identifiersep> operation <identifiersep> executor . run <identifiersep> all ( new action < build <identifiersep> operation <identifiersep> queue < runnable <identifiersep> build <identifiersep> operation > > ( ) { @ override public void execute ( build <identifiersep> operation <identifiersep> queue < runnable <identifiersep> build <identifiersep> operation > build <identifiersep> operation <identifiersep> queue ) { for ( final edge <identifiersep> state dependency : to <identifiersep> download <identifiersep> in <identifiersep> parallel ) { build <identifiersep> operation <identifiersep> queue . add ( new download <identifiersep> metadata <identifiersep> operation ( dependency . get <identifiersep> target <identifiersep> component ( ) ) ) ; <ect>
<comment> <LOG> clean <identifiersep> up <identifiersep> later . stop ( ) ; } finally { old <identifiersep> model <identifiersep> cache = null ; new <identifiersep> model <identifiersep> cache = null ; stores . clear ( ) ; } } } <ect>
public void done ( final long id ) { binary <identifiersep> store . write ( new binary <identifiersep> store . write <identifiersep> action ( ) { @ override public void write ( encoder encoder ) throws io <identifiersep> exception { encoder . write <identifiersep> byte ( root ) ; encoder . write <identifiersep> small <identifiersep> long ( id ) ; } <LOG> } ) ; binary <identifiersep> data = binary <identifiersep> store . done ( ) ; } public void first <identifiersep> level <identifiersep> dependency ( final long id ) { binary <identifiersep> store . write ( new binary <identifiersep> store . write <identifiersep> action ( ) { @ override public void write ( encoder encoder ) throws io <identifiersep> exception { <ect>
this . version <identifiersep> comparator = version <identifiersep> comparator ; this . module <identifiersep> exclusions = module <identifiersep> exclusions ; this . build <identifiersep> operation <identifiersep> executor = build <identifiersep> operation <identifiersep> executor ; this . component <identifiersep> selector <identifiersep> converter = component <identifiersep> selector <identifiersep> converter ; this . attributes <identifiersep> factory = attributes <identifiersep> factory ; } @ override <LOG> public void resolve ( resolve <identifiersep> context resolve <identifiersep> context , list < ? extends resolution <identifiersep> aware <identifiersep> repository > repositories , global <identifiersep> dependency <identifiersep> resolution <identifiersep> rules metadata <identifiersep> handler , spec < ? super dependency <identifiersep> metadata > edge <identifiersep> filter , dependency <identifiersep> graph <identifiersep> visitor graph <identifiersep> visitor , dependency <identifiersep> artifacts <identifiersep> visitor artifacts <identifiersep> visitor , attributes <identifiersep> schema <identifiersep> internal consumer <identifiersep> schema , artifact <identifiersep> type <identifiersep> registry artifact <identifiersep> type <identifiersep> registry ) { component <identifiersep> resolvers <identifiersep> chain resolvers = create <identifiersep> resolvers ( resolve <identifiersep> context , repositories , metadata <identifiersep> handler , artifact <identifiersep> type <identifiersep> registry ) ; dependency <identifiersep> graph <identifiersep> builder builder = create <identifiersep> dependency <identifiersep> graph <identifiersep> builder ( resolvers , resolve <identifiersep> context . get <identifiersep> resolution <identifiersep> strategy ( ) , metadata <identifiersep> handler , edge <identifiersep> filter , consumer <identifiersep> schema , module <identifiersep> exclusions , build <identifiersep> operation <identifiersep> executor ) ; dependency <identifiersep> graph <identifiersep> visitor artifacts <identifiersep> graph <identifiersep> visitor = new resolved <identifiersep> artifacts <identifiersep> graph <identifiersep> visitor ( artifacts <identifiersep> visitor , resolvers . get <identifiersep> artifact <identifiersep> selector ( ) , module <identifiersep> exclusions ) ; <comment> <ect>
if ( cached <identifiersep> module <identifiersep> version <identifiersep> list != null ) { set < string > version <identifiersep> list = cached <identifiersep> module <identifiersep> version <identifiersep> list . get <identifiersep> module <identifiersep> versions ( ) ; set < module <identifiersep> version <identifiersep> identifier > versions = collection <identifiersep> utils . collect ( version <identifiersep> list , new transformer < module <identifiersep> version <identifiersep> identifier , string > ( ) { public module <identifiersep> version <identifiersep> identifier transform ( string original ) { return new default <identifiersep> module <identifiersep> version <identifiersep> identifier ( module <identifiersep> id , original ) ; } } ) ; <LOG> if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> version <identifiersep> list ( module <identifiersep> id , versions , cached <identifiersep> module <identifiersep> version <identifiersep> list . get <identifiersep> age <identifiersep> millis ( ) ) ) { } else { result . listed ( version <identifiersep> list ) ; <comment> <ect>
module <identifiersep> metadata <identifiersep> cache . cached <identifiersep> metadata cached <identifiersep> metadata = module <identifiersep> metadata <identifiersep> cache . get <identifiersep> cached <identifiersep> module <identifiersep> descriptor ( delegate , module <identifiersep> component <identifiersep> identifier ) ; if ( cached <identifiersep> metadata == null ) { return ; } if ( cached <identifiersep> metadata . is <identifiersep> missing ( ) ) { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> missing <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; <LOG> return ; } result . missing ( ) ; <comment> <ect>
result . set <identifiersep> authoritative ( cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) == 0 ) ; return ; } module <identifiersep> component <identifiersep> resolve <identifiersep> metadata metadata = get <identifiersep> processed <identifiersep> metadata ( cached <identifiersep> metadata ) ; if ( request <identifiersep> meta <identifiersep> data . is <identifiersep> changing ( ) || metadata . is <identifiersep> changing ( ) ) { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> changing <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> module <identifiersep> version ( ) , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; <LOG> return ; } } else { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> module <identifiersep> version ( ) , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; return ; } } logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; <ect>
logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; return ; } logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; } else { if ( cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> module ( module <identifiersep> component <identifiersep> identifier , cached <identifiersep> metadata . get <identifiersep> module <identifiersep> version ( ) , cached <identifiersep> metadata . get <identifiersep> age <identifiersep> millis ( ) ) ) { logger . debug ( <string_literal> , module <identifiersep> component <identifiersep> identifier , delegate . get <identifiersep> name ( ) ) ; <LOG> return ; } } metadata = metadata . with <identifiersep> source ( new caching <identifiersep> module <identifiersep> source ( metadata . get <identifiersep> content <identifiersep> hash ( ) . as <identifiersep> big <identifiersep> integer ( ) , metadata . is <identifiersep> changing ( ) , metadata . get <identifiersep> source ( ) ) ) ; result . resolved ( metadata ) ; <comment> <ect>
final big <identifiersep> integer descriptor <identifiersep> hash = module <identifiersep> source . get <identifiersep> descriptor <identifiersep> hash ( ) ; if ( cached != null ) { long age = time <identifiersep> provider . get <identifiersep> current <identifiersep> time ( ) - cached . get <identifiersep> cached <identifiersep> at ( ) ; final boolean is <identifiersep> changing <identifiersep> module = module <identifiersep> source . is <identifiersep> changing <identifiersep> module ( ) ; artifact <identifiersep> identifier artifact <identifiersep> identifier = ( ( module <identifiersep> component <identifiersep> artifact <identifiersep> metadata ) artifact ) . to <identifiersep> artifact <identifiersep> identifier ( ) ; if ( cached . is <identifiersep> missing ( ) ) { <LOG> if ( ! cache <identifiersep> policy . must <identifiersep> refresh <identifiersep> artifact ( artifact <identifiersep> identifier , null , age , is <identifiersep> changing <identifiersep> module , descriptor <identifiersep> hash . equals ( cached . get <identifiersep> descriptor <identifiersep> hash ( ) ) ) ) { for ( string location : cached . attempted <identifiersep> locations ( ) ) { result . attempted ( location ) ; } result . not <identifiersep> found ( artifact . get <identifiersep> id ( ) ) ; } } else { file cached <identifiersep> artifact <identifiersep> file = cached . get <identifiersep> cached <identifiersep> file ( ) ; <ect>
if ( result . get <identifiersep> failure ( ) == null ) { fixed <identifiersep> component <identifiersep> artifacts artifacts = ( fixed <identifiersep> component <identifiersep> artifacts ) result . get <identifiersep> result ( ) ; module <identifiersep> artifacts <identifiersep> cache . cache <identifiersep> artifacts ( delegate , component . get <identifiersep> id ( ) , <string_literal> , module <identifiersep> source . get <identifiersep> descriptor <identifiersep> hash ( ) , artifacts . get <identifiersep> artifacts ( ) ) ; } } @ override public void resolve <identifiersep> artifact ( component <identifiersep> artifact <identifiersep> metadata artifact , module <identifiersep> source module <identifiersep> source , buildable <identifiersep> artifact <identifiersep> resolve <identifiersep> result result ) { final caching <identifiersep> module <identifiersep> source caching <identifiersep> module <identifiersep> source = ( caching <identifiersep> module <identifiersep> source ) module <identifiersep> source ; <LOG> delegate . get <identifiersep> remote <identifiersep> access ( ) . resolve <identifiersep> artifact ( artifact , caching <identifiersep> module <identifiersep> source . get <identifiersep> delegate ( ) , result ) ; artifact <identifiersep> resolve <identifiersep> exception failure = result . get <identifiersep> failure ( ) ; if ( failure == null ) { module <identifiersep> artifact <identifiersep> cache . store ( artifact <identifiersep> cache <identifiersep> key ( artifact . get <identifiersep> id ( ) ) , result . get <identifiersep> result ( ) , caching <identifiersep> module <identifiersep> source . get <identifiersep> descriptor <identifiersep> hash ( ) ) ; } else if ( failure instanceof artifact <identifiersep> not <identifiersep> found <identifiersep> exception ) { module <identifiersep> artifact <identifiersep> cache . store <identifiersep> missing ( artifact <identifiersep> cache <identifiersep> key ( artifact . get <identifiersep> id ( ) ) , result . get <identifiersep> attempted ( ) , caching <identifiersep> module <identifiersep> source . get <identifiersep> descriptor <identifiersep> hash ( ) ) ; <ect>
} else if ( <string_literal> . equals ( q <identifiersep> name ) ) { dependency <identifiersep> started ( attributes ) ; } else if ( <string_literal> . equals ( q <identifiersep> name ) ) { conf <identifiersep> started ( attributes ) ; } else if ( <string_literal> . equals ( q <identifiersep> name ) ) { dd . add <identifiersep> dependency <identifiersep> configuration ( conf , substitute ( attributes . get <identifiersep> value ( <string_literal> ) ) ) ; <LOG> } else if ( ( <string_literal> . equals ( q <identifiersep> name ) && state == state . deps ) || <string_literal> . equals ( q <identifiersep> name ) && state == state . conflict ) { } else if ( <string_literal> . equals ( q <identifiersep> name ) && state == state . deps ) { logger . debug ( <string_literal> , get <identifiersep> resource ( ) . get <identifiersep> display <identifiersep> name ( ) ) ; } else if ( <string_literal> . equals ( q <identifiersep> name ) && state == state . conf ) { include <identifiersep> conf <identifiersep> started ( attributes ) ; } else if ( validate && state != state . extra <identifiersep> info && state != state . description ) { <ect>
string parent <identifiersep> module = attributes . get <identifiersep> value ( <string_literal> ) ; string parent <identifiersep> revision = attributes . get <identifiersep> value ( <string_literal> ) ; string location = elvis ( attributes . get <identifiersep> value ( <string_literal> ) , <string_literal> ) ; string extend <identifiersep> type = elvis ( attributes . get <identifiersep> value ( <string_literal> ) , <string_literal> ) . to <identifiersep> lower <identifiersep> case ( ) ; list < string > extend <identifiersep> types = arrays . as <identifiersep> list ( extend <identifiersep> type . split ( <string_literal> ) ) ; module <identifiersep> descriptor parent ; <LOG> try { parent = parse <identifiersep> other <identifiersep> ivy <identifiersep> file <identifiersep> on <identifiersep> file <identifiersep> system ( location ) ; if ( parent != null ) { <comment> <ect>
linked <identifiersep> hash <identifiersep> map dup = new linked <identifiersep> hash <identifiersep> map ( inherited . size ( ) + overrides . size ( ) ) ; dup . put <identifiersep> all ( inherited ) ; dup . put <identifiersep> all ( overrides ) ; return dup ; } private void merge <identifiersep> configurations ( module <identifiersep> revision <identifiersep> id source <identifiersep> mrid , configuration [ ] configurations ) { default <identifiersep> module <identifiersep> descriptor md = get <identifiersep> md ( ) ; <LOG> for ( configuration configuration : configurations ) { <comment> <ect>
private void merge <identifiersep> description ( string description ) { string current = get <identifiersep> md ( ) . get <identifiersep> description ( ) ; if ( current == null || current . trim ( ) . length ( ) == 0 ) { get <identifiersep> md ( ) . set <identifiersep> description ( description ) ; } } private module <identifiersep> descriptor parse <identifiersep> other <identifiersep> ivy <identifiersep> file <identifiersep> on <identifiersep> file <identifiersep> system ( string location ) throws parse <identifiersep> exception , io <identifiersep> exception { <LOG> url url = relative <identifiersep> url <identifiersep> resolver . get <identifiersep> url ( descriptor <identifiersep> url , location ) ; external <identifiersep> resource resource = url <identifiersep> external <identifiersep> resource . open ( url ) ; try { return parse <identifiersep> module <identifiersep> descriptor ( resource , url ) ; } catch ( missing <identifiersep> resource <identifiersep> exception e ) { <comment> <ect>
configuration [ ] configs = parser . get <identifiersep> module <identifiersep> descriptor ( ) . get <identifiersep> configurations ( ) ; for ( configuration config : configs ) { get <identifiersep> md ( ) . add <identifiersep> configuration ( config ) ; } if ( parser . get <identifiersep> default <identifiersep> conf <identifiersep> mapping ( ) != null ) { logger . debug ( <string_literal> , parser . get <identifiersep> default <identifiersep> conf <identifiersep> mapping ( ) ) ; set <identifiersep> default <identifiersep> conf <identifiersep> mapping ( parser . get <identifiersep> default <identifiersep> conf <identifiersep> mapping ( ) ) ; } <LOG> if ( parser . get <identifiersep> default <identifiersep> conf ( ) != null ) { set <identifiersep> default <identifiersep> conf ( parser . get <identifiersep> default <identifiersep> conf ( ) ) ; } if ( parser . get <identifiersep> md ( ) . is <identifiersep> mapping <identifiersep> override ( ) ) { logger . debug ( <string_literal> ) ; get <identifiersep> md ( ) . set <identifiersep> mapping <identifiersep> override ( true ) ; } } private void conf <identifiersep> started ( attributes attributes ) { <ect>
private void ivy <identifiersep> module <identifiersep> started ( attributes attributes ) throws sax <identifiersep> exception { descriptor <identifiersep> version = attributes . get <identifiersep> value ( <string_literal> ) ; int version <identifiersep> index = allowed <identifiersep> versions . index <identifiersep> of ( descriptor <identifiersep> version ) ; if ( version <identifiersep> index == - 1 ) { add <identifiersep> error ( <string_literal> + descriptor <identifiersep> version ) ; throw new sax <identifiersep> exception ( <string_literal> + descriptor <identifiersep> version ) ; } <LOG> if ( version <identifiersep> index >= allowed <identifiersep> versions . index <identifiersep> of ( <string_literal> ) ) { default <identifiersep> matcher = get <identifiersep> matcher ( pattern <identifiersep> matcher . exact ) ; } else { logger . debug ( <string_literal> , pattern <identifiersep> matcher . exact <identifiersep> or <identifiersep> regexp ) ; default <identifiersep> matcher = get <identifiersep> matcher ( pattern <identifiersep> matcher . exact <identifiersep> or <identifiersep> regexp ) ; } for ( int i = 0 ; i < attributes . get <identifiersep> length ( ) ; i ++ ) { <ect>
string version = pom <identifiersep> reader . get <identifiersep> version ( ) ; md <identifiersep> builder . set <identifiersep> module <identifiersep> rev <identifiersep> id ( group <identifiersep> id , artifact <identifiersep> id , version ) ; module <identifiersep> version <identifiersep> identifier relocation = pom <identifiersep> reader . get <identifiersep> relocation ( ) ; if ( relocation != null ) { if ( group <identifiersep> id != null && artifact <identifiersep> id != null && artifact <identifiersep> id . equals ( relocation . get <identifiersep> name ( ) ) && group <identifiersep> id . equals ( relocation . get <identifiersep> group ( ) ) ) { logger . error ( <string_literal> , <LOG> md <identifiersep> builder . get <identifiersep> component <identifiersep> identifier ( ) , relocation ) ; logger . warn ( <string_literal> ) ; pom <identifiersep> reader relocated <identifiersep> module = parse <identifiersep> pom <identifiersep> for <identifiersep> id ( parser <identifiersep> settings , default <identifiersep> module <identifiersep> component <identifiersep> identifier . new <identifiersep> id ( relocation ) , maps . < string , string > new <identifiersep> hash <identifiersep> map ( ) ) ; add <identifiersep> dependencies ( md <identifiersep> builder , relocated <identifiersep> module ) ; } else { logger . info ( md <identifiersep> builder . get <identifiersep> component <identifiersep> identifier ( ) <ect>
logger . warn ( <string_literal> ) ; pom <identifiersep> reader relocated <identifiersep> module = parse <identifiersep> pom <identifiersep> for <identifiersep> id ( parser <identifiersep> settings , default <identifiersep> module <identifiersep> component <identifiersep> identifier . new <identifiersep> id ( relocation ) , maps . < string , string > new <identifiersep> hash <identifiersep> map ( ) ) ; add <identifiersep> dependencies ( md <identifiersep> builder , relocated <identifiersep> module ) ; } else { logger . info ( md <identifiersep> builder . get <identifiersep> component <identifiersep> identifier ( ) + <string_literal> + relocation <LOG> + <string_literal> ) ; module <identifiersep> component <identifiersep> selector selector = default <identifiersep> module <identifiersep> component <identifiersep> selector . new <identifiersep> selector ( relocation . get <identifiersep> group ( ) , relocation . get <identifiersep> name ( ) , new default <identifiersep> mutable <identifiersep> version <identifiersep> constraint ( relocation . get <identifiersep> version ( ) ) ) ; md <identifiersep> builder . add <identifiersep> dependency <identifiersep> for <identifiersep> relocation ( selector ) ; } } else { override <identifiersep> dependency <identifiersep> mgts <identifiersep> with <identifiersep> imported ( parser <identifiersep> settings , pom <identifiersep> reader ) ; add <identifiersep> dependencies ( md <identifiersep> builder , pom <identifiersep> reader ) ; <ect>
private final implementation <identifiersep> dependency <identifiersep> relocator remapper ; private final directory <identifiersep> file <identifiersep> tree <identifiersep> factory directory <identifiersep> file <identifiersep> tree <identifiersep> factory ; public runtime <identifiersep> shaded <identifiersep> jar <identifiersep> creator ( progress <identifiersep> logger <identifiersep> factory progress <identifiersep> logger <identifiersep> factory , implementation <identifiersep> dependency <identifiersep> relocator remapper , directory <identifiersep> file <identifiersep> tree <identifiersep> factory directory <identifiersep> file <identifiersep> tree <identifiersep> factory ) { this . progress <identifiersep> logger <identifiersep> factory = progress <identifiersep> logger <identifiersep> factory ; this . remapper = remapper ; this . directory <identifiersep> file <identifiersep> tree <identifiersep> factory = directory <identifiersep> file <identifiersep> tree <identifiersep> factory ; } <LOG> public void create ( final file output <identifiersep> jar , final iterable < ? extends file > files ) { progress <identifiersep> logger progress <identifiersep> logger = progress <identifiersep> logger <identifiersep> factory . new <identifiersep> operation ( runtime <identifiersep> shaded <identifiersep> jar <identifiersep> creator . class ) ; progress <identifiersep> logger . set <identifiersep> description ( <string_literal> ) ; progress <identifiersep> logger . set <identifiersep> logging <identifiersep> header ( <string_literal> + output <identifiersep> jar . get <identifiersep> name ( ) + <string_literal> ) ; progress <identifiersep> logger . started ( ) ; try { <ect>
import javax . inject . inject public class alternate <identifiersep> parallel <identifiersep> runnable implements runnable { final string item <identifiersep> name @ inject public alternate <identifiersep> parallel <identifiersep> runnable ( string item <identifiersep> name ) { this . item <identifiersep> name = item <identifiersep> name } <LOG> public void run ( ) { new uri ( <string_literal> , null , <string_literal> , $ { blocking <identifiersep> http <identifiersep> server . get <identifiersep> port ( ) } , <string_literal> , null , null ) . to <identifiersep> url ( ) . text } } <string_literal> <string_literal> <string_literal> $alternate <identifiersep> parallel <identifiersep> runnable <ect>
logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) . warn ( <string_literal> ) ; logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) . debug ( <string_literal> ) ; logger <identifiersep> factory . get <identifiersep> logger ( get <identifiersep> class ( ) ) . error ( <string_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . warning ( <string_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . fine ( <string_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . severe ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
return new integer ( o1 . get <identifiersep> uses ( ) ) . compare <identifiersep> to ( o2 . get <identifiersep> uses ( ) ) ; } } ) ; list < worker <identifiersep> daemon <identifiersep> client > clients <identifiersep> to <identifiersep> stop = selection <identifiersep> function . transform ( new array <identifiersep> list < worker <identifiersep> daemon <identifiersep> client > ( sorted <identifiersep> clients ) ) ; if ( ! clients <identifiersep> to <identifiersep> stop . is <identifiersep> empty ( ) ) { stop <identifiersep> workers ( clients <identifiersep> to <identifiersep> stop ) ; } } } private void stop <identifiersep> workers ( list < worker <identifiersep> daemon <identifiersep> client > clients <identifiersep> to <identifiersep> stop ) { <LOG> if ( clients <identifiersep> to <identifiersep> stop . size ( ) > 0 ) { composite <identifiersep> stoppable . stoppable ( clients <identifiersep> to <identifiersep> stop ) . stop ( ) ; logger . info ( <string_literal> , clients <identifiersep> to <identifiersep> stop . size ( ) ) ; idle <identifiersep> clients . remove <identifiersep> all ( clients <identifiersep> to <identifiersep> stop ) ; all <identifiersep> clients . remove <identifiersep> all ( clients <identifiersep> to <identifiersep> stop ) ; } } private class stop <identifiersep> session <identifiersep> scoped <identifiersep> workers implements session <identifiersep> lifecycle <identifiersep> listener { <ect>
this . clients <identifiersep> manager = clients <identifiersep> manager ; this . os <identifiersep> total <identifiersep> memory = os <identifiersep> total <identifiersep> memory ; } @ override public long attempt <identifiersep> to <identifiersep> release ( long memory <identifiersep> amount <identifiersep> bytes ) throws illegal <identifiersep> argument <identifiersep> exception { if ( memory <identifiersep> amount <identifiersep> bytes < 0 ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } <LOG> if ( boolean . value <identifiersep> of ( system . get <identifiersep> property ( disable <identifiersep> expiration <identifiersep> property <identifiersep> key , <string_literal> ) ) ) { return 0l ; } logger . debug ( <string_literal> , memory <identifiersep> amount <identifiersep> bytes / <number_literal> / <number_literal> ) ; simple <identifiersep> memory <identifiersep> expiration <identifiersep> selector selector = new simple <identifiersep> memory <identifiersep> expiration <identifiersep> selector ( memory <identifiersep> amount <identifiersep> bytes ) ; clients <identifiersep> manager . select <identifiersep> idle <identifiersep> clients <identifiersep> to <identifiersep> stop ( selector ) ; return selector . get <identifiersep> released <identifiersep> bytes ( ) ; <ect>
to <identifiersep> expire . add ( idle <identifiersep> client ) ; long freed = get <identifiersep> memory <identifiersep> usage ( idle <identifiersep> client ) ; released <identifiersep> bytes += freed ; if ( released <identifiersep> bytes >= memory <identifiersep> bytes <identifiersep> to <identifiersep> release ) { break ; } } <LOG> <comment> <ect>
builder . application <identifiersep> classpath ( fork <identifiersep> options . get <identifiersep> classpath ( ) ) ; builder . shared <identifiersep> packages ( fork <identifiersep> options . get <identifiersep> shared <identifiersep> packages ( ) ) ; java <identifiersep> exec <identifiersep> handle <identifiersep> builder java <identifiersep> command = builder . get <identifiersep> java <identifiersep> command ( ) ; fork <identifiersep> options . get <identifiersep> java <identifiersep> fork <identifiersep> options ( ) . copy <identifiersep> to ( java <identifiersep> command ) ; worker <identifiersep> daemon <identifiersep> process worker <identifiersep> daemon <identifiersep> process = builder . build ( ) ; worker <identifiersep> process worker <identifiersep> process = worker <identifiersep> daemon <identifiersep> process . start ( ) ; <LOG> worker <identifiersep> daemon <identifiersep> client client = new worker <identifiersep> daemon <identifiersep> client ( fork <identifiersep> options , worker <identifiersep> daemon <identifiersep> process , worker <identifiersep> process , logging <identifiersep> manager . get <identifiersep> level ( ) ) ; return client ; } } <ect>
return no <identifiersep> op <identifiersep> build <identifiersep> cache <identifiersep> controller . instance ; } build <identifiersep> cache local = build <identifiersep> cache <identifiersep> configuration . get <identifiersep> local ( ) ; build <identifiersep> cache remote = build <identifiersep> cache <identifiersep> configuration . get <identifiersep> remote ( ) ; boolean local <identifiersep> enabled = local != null && local . is <identifiersep> enabled ( ) ; boolean remote <identifiersep> enabled = remote != null && remote . is <identifiersep> enabled ( ) ; if ( remote <identifiersep> enabled && remote <identifiersep> access <identifiersep> mode == remote <identifiersep> access <identifiersep> mode . offline ) { <LOG> remote <identifiersep> enabled = false ; } described <identifiersep> build <identifiersep> cache <identifiersep> service local <identifiersep> described <identifiersep> service = local <identifiersep> enabled ? create <identifiersep> build <identifiersep> cache <identifiersep> service ( local , build <identifiersep> cache <identifiersep> service <identifiersep> role . local , build <identifiersep> identity <identifiersep> path , build <identifiersep> cache <identifiersep> configuration , instantiator ) : null ; described <identifiersep> build <identifiersep> cache <identifiersep> service remote <identifiersep> described <identifiersep> service = remote <identifiersep> enabled ? create <identifiersep> build <identifiersep> cache <identifiersep> service ( remote , build <identifiersep> cache <identifiersep> service <identifiersep> role . remote , build <identifiersep> identity <identifiersep> path , build <identifiersep> cache <identifiersep> configuration , instantiator ) <ect>
private void failure ( string verb , string preposition , build <identifiersep> cache <identifiersep> key key , throwable e ) { disabled = true ; string description = <string_literal> + verb + <string_literal> + key . get <identifiersep> display <identifiersep> name ( ) + <string_literal> + preposition + <string_literal> + role . get <identifiersep> display <identifiersep> name ( ) + <string_literal> ; if ( log <identifiersep> stack <identifiersep> traces ) { logger . warn ( description , e ) ; <LOG> } else { } } } @ override public void close ( ) { logger . debug ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) ) ; if ( disabled ) { logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) ) ; <ect>
logger . warn ( description , e ) ; } else { logger . warn ( description + <string_literal> + e . get <identifiersep> message ( ) ) ; } } } @ override public void close ( ) { logger . debug ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) ) ; <LOG> if ( disabled ) { } try { service . close ( ) ; } catch ( exception e ) { if ( log <identifiersep> stack <identifiersep> traces ) { logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) , e ) ; <ect>
logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) ) ; } try { service . close ( ) ; } catch ( exception e ) { if ( log <identifiersep> stack <identifiersep> traces ) { logger . warn ( <string_literal> , role . get <identifiersep> display <identifiersep> name ( ) , e ) ; <LOG> } else { } } } } <ect>
@ override public < t extends build <identifiersep> cache > t remote ( class < t > type ) { return remote ( type , actions . do <identifiersep> nothing ( ) ) ; } @ override public < t extends build <identifiersep> cache > t remote ( class < t > type , action < ? super t > configuration ) { if ( ! type . is <identifiersep> instance ( remote ) ) { <LOG> if ( remote != null ) { } remote = create <identifiersep> remote <identifiersep> cache <identifiersep> configuration ( instantiator , type , registrations ) ; } t configuration <identifiersep> object = cast . unchecked <identifiersep> cast ( remote ) ; configuration . execute ( configuration <identifiersep> object ) ; return configuration <identifiersep> object ; } @ override <ect>
if ( cache <identifiersep> directory != null ) { target = resolver . resolve ( cache <identifiersep> directory ) ; } else { target = cache <identifiersep> scope <identifiersep> mapping . get <identifiersep> base <identifiersep> directory ( null , build <identifiersep> cache <identifiersep> key , version <identifiersep> strategy . shared <identifiersep> cache ) ; } check <identifiersep> directory ( target ) ; int remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days = configuration . get <identifiersep> remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days ( ) ; <LOG> describer . type ( directory <identifiersep> build <identifiersep> cache <identifiersep> type ) . config ( <string_literal> , string . value <identifiersep> of ( remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days ) + <string_literal> ) ; path <identifiersep> key <identifiersep> file <identifiersep> store file <identifiersep> store = file <identifiersep> store <identifiersep> factory . create <identifiersep> file <identifiersep> store ( target ) ; persistent <identifiersep> cache persistent <identifiersep> cache = cache <identifiersep> repository . cache ( target ) . with <identifiersep> cleanup ( cleanup <identifiersep> action <identifiersep> factory . create ( new fixed <identifiersep> age <identifiersep> oldest <identifiersep> cache <identifiersep> cleanup ( remove <identifiersep> unused <identifiersep> entries <identifiersep> after <identifiersep> days ) ) ) <ect>
protected abstract string get <identifiersep> packer <identifiersep> name ( ) ; protected abstract string get <identifiersep> accessor <identifiersep> name ( ) ; @ setup ( level . trial ) public void setup <identifiersep> trial ( ) throws io <identifiersep> exception { directory <identifiersep> provider . setup <identifiersep> trial ( ) ; string packer <identifiersep> name = get <identifiersep> packer <identifiersep> name ( ) ; <LOG> string accessor <identifiersep> name = get <identifiersep> accessor <identifiersep> name ( ) ; packer packer = packers . get ( packer <identifiersep> name ) ; data <identifiersep> accessor accessor = accessors . get ( accessor <identifiersep> name ) ; this . inputs = create <identifiersep> input <identifiersep> files ( file <identifiersep> count , min <identifiersep> file <identifiersep> size , max <identifiersep> file <identifiersep> size , accessor ) ; this . sample = pack <identifiersep> sample ( <string_literal> + packer <identifiersep> name , inputs , packer , accessor ) ; } @ tear <identifiersep> down ( level . trial ) <ect>
private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( gcs <identifiersep> resource <identifiersep> connector . class ) ; private final gcs <identifiersep> client gcs <identifiersep> client ; public gcs <identifiersep> resource <identifiersep> connector ( gcs <identifiersep> client gcs <identifiersep> client ) { this . gcs <identifiersep> client = gcs <identifiersep> client ; } @ nullable @ override <LOG> public list < string > list ( uri parent ) throws resource <identifiersep> exception { return gcs <identifiersep> client . list ( parent ) ; } @ nullable @ override public external <identifiersep> resource <identifiersep> read <identifiersep> response open <identifiersep> resource ( uri location , boolean revalidate ) throws resource <identifiersep> exception { logger . debug ( <string_literal> , location ) ; <ect>
storage <identifiersep> object gcs <identifiersep> object = gcs <identifiersep> client . get <identifiersep> resource ( location ) ; if ( gcs <identifiersep> object == null ) { return null ; } return new gcs <identifiersep> resource ( gcs <identifiersep> client , gcs <identifiersep> object , location ) ; } @ nullable @ override <LOG> public external <identifiersep> resource <identifiersep> meta <identifiersep> data get <identifiersep> meta <identifiersep> data ( uri location , boolean revalidate ) throws resource <identifiersep> exception { storage <identifiersep> object gcs <identifiersep> object = gcs <identifiersep> client . get <identifiersep> resource ( location ) ; if ( gcs <identifiersep> object == null ) { return null ; } return to <identifiersep> external <identifiersep> resource <identifiersep> meta <identifiersep> data ( location , gcs <identifiersep> object ) ; } @ override <ect>
<comment> <LOG> storage . objects . insert put <identifiersep> request = storage . objects ( ) . insert ( bucket , object <identifiersep> metadata , content <identifiersep> stream ) ; put <identifiersep> request . execute ( ) ; } catch ( io <identifiersep> exception e ) { throw resource <identifiersep> exceptions . put <identifiersep> failed ( destination , e ) ; } } @ nullable public storage <identifiersep> object get <identifiersep> resource ( uri uri ) throws resource <identifiersep> exception { <ect>
map < java <identifiersep> library , java <identifiersep> library > java <identifiersep> libs <identifiersep> by <identifiersep> identity = new identity <identifiersep> hash <identifiersep> map < java <identifiersep> library , java <identifiersep> library > ( ) ; map < object , object > java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity = new identity <identifiersep> hash <identifiersep> map < object , object > ( ) ; set < android <identifiersep> library > libs <identifiersep> by <identifiersep> equality = new hash <identifiersep> set < android <identifiersep> library > ( ) ; map < file , android <identifiersep> library > libs <identifiersep> by <identifiersep> file = new hash <identifiersep> map < file , android <identifiersep> library > ( ) ; map < android <identifiersep> library , android <identifiersep> library > libs <identifiersep> by <identifiersep> identity = new identity <identifiersep> hash <identifiersep> map < android <identifiersep> library , android <identifiersep> library > ( ) ; map < object , object > libs <identifiersep> backing <identifiersep> by <identifiersep> identity = new identity <identifiersep> hash <identifiersep> map < object , object > ( ) ; <LOG> void inspect <identifiersep> model ( map < string , android <identifiersep> project > models ) { timer timer = new timer ( ) ; for ( android <identifiersep> project android <identifiersep> project : models . values ( ) ) { if ( android <identifiersep> project == null ) { continue ; } inspect ( android <identifiersep> project ) ; <ect>
timer timer = new timer ( ) ; for ( android <identifiersep> project android <identifiersep> project : models . values ( ) ) { if ( android <identifiersep> project == null ) { continue ; } inspect ( android <identifiersep> project ) ; } timer . stop ( ) ; <LOG> system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; <ect>
if ( android <identifiersep> project == null ) { continue ; } inspect ( android <identifiersep> project ) ; } timer . stop ( ) ; system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; <ect>
inspect ( android <identifiersep> project ) ; } timer . stop ( ) ; system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; <LOG> system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> + timer . duration ( ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; <LOG> system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> ) ; } private void inspect ( android <identifiersep> project android <identifiersep> project ) { for ( variant variant : android <identifiersep> project . get <identifiersep> variants ( ) ) { <ect>
system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> file . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + libs <identifiersep> backing <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> equality . size ( ) ) ; system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> file . size ( ) ) ; <LOG> system . out . println ( <string_literal> + java <identifiersep> libs <identifiersep> by <identifiersep> identity . size ( ) ) ; system . out . println ( <string_literal> ) ; } private void inspect ( android <identifiersep> project android <identifiersep> project ) { for ( variant variant : android <identifiersep> project . get <identifiersep> variants ( ) ) { inspect ( variant . get <identifiersep> main <identifiersep> artifact ( ) . get <identifiersep> dependencies ( ) ) ; for ( android <identifiersep> artifact other <identifiersep> artifact : variant . get <identifiersep> extra <identifiersep> android <identifiersep> artifacts ( ) ) { <ect>
option <identifiersep> parser parser = new option <identifiersep> parser ( ) ; argument <identifiersep> accepting <identifiersep> option <identifiersep> spec < string > project <identifiersep> flag = parser . accepts ( <string_literal> , <string_literal> ) . with <identifiersep> required <identifiersep> arg ( ) ; argument <identifiersep> accepting <identifiersep> option <identifiersep> spec < string > gradle <identifiersep> install <identifiersep> flag = parser . accepts ( <string_literal> , <string_literal> ) . with <identifiersep> required <identifiersep> arg ( ) ; option <identifiersep> spec <identifiersep> builder sync = parser . accepts ( <string_literal> , <string_literal> ) ; option <identifiersep> spec <identifiersep> builder embedded <identifiersep> flag = parser . accepts ( <string_literal> , <string_literal> ) ; option <identifiersep> set options = parser . parse ( args ) ; <LOG> if ( ! options . has ( project <identifiersep> flag ) ) { system . out . println ( ) ; parser . print <identifiersep> help <identifiersep> on ( system . out ) ; return ; } file build <identifiersep> dir = new file ( options . value <identifiersep> of ( project <identifiersep> flag ) ) ; file gradle <identifiersep> install <identifiersep> dir = options . has <identifiersep> argument ( gradle <identifiersep> install <identifiersep> flag ) ? new file ( options . value <identifiersep> of ( gradle <identifiersep> install <identifiersep> flag ) ) : null ; <ect>
boolean has <identifiersep> simulation = options . has ( sync ) ; if ( options . has ( sync ) || has <identifiersep> simulation ) { <comment> <LOG> system . out . println ( <string_literal> + build <identifiersep> dir ) ; timer timer = new timer ( ) ; gradle <identifiersep> connector gradle <identifiersep> connector = gradle <identifiersep> connector . new <identifiersep> connector ( ) ; gradle <identifiersep> connector . for <identifiersep> project <identifiersep> directory ( build <identifiersep> dir ) ; ( ( default <identifiersep> gradle <identifiersep> connector ) gradle <identifiersep> connector ) . embedded ( embedded ) ; if ( gradle <identifiersep> install <identifiersep> dir != null ) { <ect>
final header header = response . get <identifiersep> first <identifiersep> header ( http <identifiersep> headers . content <identifiersep> type ) ; return header == null ? null : header . get <identifiersep> value ( ) ; } public boolean is <identifiersep> local ( ) { return false ; } public input <identifiersep> stream open <identifiersep> stream ( ) throws io <identifiersep> exception { if ( was <identifiersep> opened ) { <LOG> throw new io <identifiersep> exception ( <string_literal> ) ; } this . was <identifiersep> opened = true ; final http <identifiersep> entity entity = response . get <identifiersep> entity ( ) ; if ( entity == null ) { throw new io <identifiersep> exception ( string . format ( <string_literal> , get <identifiersep> status <identifiersep> code ( ) , response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> reason <identifiersep> phrase ( ) ) ) ; } return entity . get <identifiersep> content ( ) ; <ect>
if ( authentication instanceof all <identifiersep> schemes <identifiersep> authentication ) { ntlm <identifiersep> credentials ntlm <identifiersep> credentials = new ntlm <identifiersep> credentials ( credentials ) ; http <identifiersep> credentials = new nt <identifiersep> credentials ( ntlm <identifiersep> credentials . get <identifiersep> username ( ) , ntlm <identifiersep> credentials . get <identifiersep> password ( ) , ntlm <identifiersep> credentials . get <identifiersep> workstation ( ) , ntlm <identifiersep> credentials . get <identifiersep> domain ( ) ) ; credentials <identifiersep> provider . set <identifiersep> credentials ( new auth <identifiersep> scope ( host , port , auth <identifiersep> scope . any <identifiersep> realm , auth <identifiersep> schemes . ntlm ) , http <identifiersep> credentials ) ; logger . debug ( <string_literal> , credentials , ntlm <identifiersep> credentials , host , port , auth <identifiersep> schemes . ntlm ) ; } http <identifiersep> credentials = new username <identifiersep> password <identifiersep> credentials ( credentials . get <identifiersep> username ( ) , credentials . get <identifiersep> password ( ) ) ; <LOG> credentials <identifiersep> provider . set <identifiersep> credentials ( new auth <identifiersep> scope ( host , port , auth <identifiersep> scope . any <identifiersep> realm , scheme ) , http <identifiersep> credentials ) ; } } private boolean is <identifiersep> preemptive <identifiersep> enabled ( collection < authentication > authentications ) { return collection <identifiersep> utils . any ( authentications , new spec < authentication > ( ) { @ override public boolean is <identifiersep> satisfied <identifiersep> by ( authentication element ) { return element instanceof basic <identifiersep> authentication ; <ect>
string key = property <identifiersep> prefix + <string_literal> ; logger . warn ( <string_literal> , key , system . get <identifiersep> property ( key ) , default <identifiersep> port ) ; return default <identifiersep> port ; } } private list < pattern > init <identifiersep> non <identifiersep> proxy <identifiersep> hosts ( string non <identifiersep> proxy <identifiersep> hosts <identifiersep> string ) { if ( string <identifiersep> utils . is <identifiersep> blank ( non <identifiersep> proxy <identifiersep> hosts <identifiersep> string ) ) { <LOG> return collections . empty <identifiersep> list ( ) ; } list < pattern > patterns = new array <identifiersep> list < pattern > ( ) ; for ( string non <identifiersep> proxy <identifiersep> host : non <identifiersep> proxy <identifiersep> hosts <identifiersep> string . split ( <string_literal> ) ) { patterns . add ( create <identifiersep> host <identifiersep> matcher ( non <identifiersep> proxy <identifiersep> host ) ) ; } return patterns ; } private pattern create <identifiersep> host <identifiersep> matcher ( string non <identifiersep> proxy <identifiersep> host ) { <ect>
return null ; } <comment> public http <identifiersep> response <identifiersep> resource get <identifiersep> raw <identifiersep> resource ( final uri uri , boolean revalidate ) { <LOG> string location = uri . to <identifiersep> string ( ) ; closeable <identifiersep> http <identifiersep> response response = http . perform <identifiersep> raw <identifiersep> get ( location , revalidate ) ; return wrap <identifiersep> response ( uri , response ) ; } public external <identifiersep> resource <identifiersep> meta <identifiersep> data get <identifiersep> meta <identifiersep> data ( uri uri , boolean revalidate ) { string location = uri . to <identifiersep> string ( ) ; logger . debug ( <string_literal> , location ) ; <ect>
http <identifiersep> context context = shared <identifiersep> context . poll ( ) ; if ( context == null ) { return new basic <identifiersep> http <identifiersep> context ( ) ; } return context ; } private closeable <identifiersep> http <identifiersep> response perform <identifiersep> http <identifiersep> request ( http <identifiersep> request <identifiersep> base request , http <identifiersep> context http <identifiersep> context ) throws io <identifiersep> exception { <comment> <LOG> http <identifiersep> context . remove <identifiersep> attribute ( http <identifiersep> client <identifiersep> context . redirect <identifiersep> locations ) ; return get <identifiersep> client ( ) . execute ( request , http <identifiersep> context ) ; } private closeable <identifiersep> http <identifiersep> response process <identifiersep> response ( string source , string method , closeable <identifiersep> http <identifiersep> response response ) { if ( was <identifiersep> missing ( response ) ) { logger . info ( <string_literal> , method , source ) ; return null ; <ect>
logger . debug ( <string_literal> , request . get <identifiersep> method ( ) , request . get <identifiersep> uri ( ) ) ; return get <identifiersep> client ( ) . execute ( request , http <identifiersep> context ) ; } private closeable <identifiersep> http <identifiersep> response process <identifiersep> response ( string source , string method , closeable <identifiersep> http <identifiersep> response response ) { if ( was <identifiersep> missing ( response ) ) { logger . info ( <string_literal> , method , source ) ; return null ; } <LOG> if ( ! was <identifiersep> successful ( response ) ) { throw new http <identifiersep> error <identifiersep> status <identifiersep> code <identifiersep> exception ( method , source , response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> status <identifiersep> code ( ) , response . get <identifiersep> status <identifiersep> line ( ) . get <identifiersep> reason <identifiersep> phrase ( ) ) ; } return response ; } private synchronized closeable <identifiersep> http <identifiersep> client get <identifiersep> client ( ) { if ( client == null ) { http <identifiersep> client <identifiersep> builder builder = http <identifiersep> client <identifiersep> builder . create ( ) ; <ect>
public class unresolved <identifiersep> ide <identifiersep> dependency <identifiersep> handler { private final logger logger = logging . get <identifiersep> logger ( unresolved <identifiersep> ide <identifiersep> dependency <identifiersep> handler . class ) ; public void log ( collection < unresolved <identifiersep> dependency <identifiersep> result > deps ) { for ( unresolved <identifiersep> dependency <identifiersep> result dep : deps ) { log ( dep ) ; } } public void log ( unresolved <identifiersep> dependency <identifiersep> result dep ) { <LOG> logger . warn ( <string_literal> + dep . get <identifiersep> attempted ( ) ) ; } public file as <identifiersep> file ( unresolved <identifiersep> dependency <identifiersep> result dep ) { return new file ( <string_literal> + dep . get <identifiersep> attempted ( ) . get <identifiersep> display <identifiersep> name ( ) . replace <identifiersep> all ( <string_literal> , <string_literal> ) ) ; } } <ect>
<comment> private collection < file > collect <identifiersep> classpath <identifiersep> files ( source <identifiersep> set source <identifiersep> set ) { immutable <identifiersep> list . builder < file > result = immutable <identifiersep> list . builder ( ) ; try { result . add <identifiersep> all ( source <identifiersep> set . get <identifiersep> runtime <identifiersep> classpath ( ) ) ; <LOG> } catch ( exception e ) { } return result . build ( ) ; } private abstract <identifiersep> library create <identifiersep> library <identifiersep> entry ( file binary , file source , file javadoc , eclipse <identifiersep> classpath classpath , module <identifiersep> version <identifiersep> identifier id , multimap < string , string > path <identifiersep> to <identifiersep> source <identifiersep> sets ) { file <identifiersep> reference <identifiersep> factory reference <identifiersep> factory = classpath . get <identifiersep> file <identifiersep> reference <identifiersep> factory ( ) ; file <identifiersep> reference binary <identifiersep> ref = reference <identifiersep> factory . from <identifiersep> file ( binary ) ; file <identifiersep> reference source <identifiersep> ref = reference <identifiersep> factory . from <identifiersep> file ( source ) ; <ect>
private final int number ; @ inject public custom <identifiersep> task ( string message , int number ) { this . message = message ; this . number = number ; } @ task <identifiersep> action <LOG> void print <identifiersep> it ( ) { } } @ override public void apply ( project p ) { p . get <identifiersep> tasks ( ) . create ( <string_literal> , custom <identifiersep> task . class , <string_literal> , <number_literal> ) ; } } ''' file ( 'build <identifiersep> src / src / main / resources / meta - <number_literal> / gradle - plugins / custom . properties' ) < < 'implementation - class = custom <identifiersep> plugin' <ect>
void add <identifiersep> grammar <identifiersep> file ( grammar <identifiersep> file <identifiersep> metadata grammar <identifiersep> file <identifiersep> metadata ) { files <identifiersep> by <identifiersep> path . put ( grammar <identifiersep> file <identifiersep> metadata . get <identifiersep> file <identifiersep> path ( ) . get <identifiersep> path ( ) , grammar <identifiersep> file <identifiersep> metadata ) ; for ( grammar <identifiersep> metadata grammar <identifiersep> metadata : grammar <identifiersep> file <identifiersep> metadata . get <identifiersep> grammars ( ) ) { files <identifiersep> by <identifiersep> class <identifiersep> name . put ( grammar <identifiersep> metadata . get <identifiersep> class <identifiersep> name ( ) , grammar <identifiersep> file <identifiersep> metadata ) ; string export <identifiersep> vocab <identifiersep> name = grammar <identifiersep> metadata . get <identifiersep> export <identifiersep> vocab ( ) != null ? grammar <identifiersep> metadata . get <identifiersep> export <identifiersep> vocab ( ) : grammar <identifiersep> metadata . get <identifiersep> class <identifiersep> name ( ) ; grammar <identifiersep> file <identifiersep> metadata old = files <identifiersep> by <identifiersep> export <identifiersep> vocab . put ( export <identifiersep> vocab <identifiersep> name , grammar <identifiersep> file <identifiersep> metadata ) ; <LOG> if ( old != null && old != grammar <identifiersep> file <identifiersep> metadata ) { } } } public iterator < grammar <identifiersep> file <identifiersep> metadata > iterate <identifiersep> grammar <identifiersep> files ( ) { return files <identifiersep> by <identifiersep> path . values ( ) . iterator ( ) ; } <comment> <ect>
public antlr <identifiersep> result run <identifiersep> antlr ( antlr <identifiersep> spec spec ) { antlr <identifiersep> tool antlr <identifiersep> tool = new antlr4tool ( ) ; if ( antlr <identifiersep> tool . available ( ) ) { logger . info ( <string_literal> ) ; return antlr <identifiersep> tool . process ( spec ) ; } antlr <identifiersep> tool = new antlr3tool ( ) ; <LOG> if ( antlr <identifiersep> tool . available ( ) ) { return antlr <identifiersep> tool . process ( spec ) ; } antlr <identifiersep> tool = new antlr2tool ( ) ; if ( antlr <identifiersep> tool . available ( ) ) { logger . info ( <string_literal> ) ; return antlr <identifiersep> tool . process ( spec ) ; <ect>
void create <identifiersep> person ( person person ) { person . set <identifiersep> first <identifiersep> name ( <string_literal> ) ; person . set <identifiersep> last <identifiersep> name ( <string_literal> ) ; } @ mutate void add <identifiersep> person <identifiersep> task ( model <identifiersep> map < task > tasks , person person ) { tasks . create ( <string_literal> , task - > { <LOG> task . do <identifiersep> last ( unused - > { } ) ; } ) ; } } ''' build <identifiersep> script ''' apply type : rule <identifiersep> plugin <ect>
out . format ( <string_literal> , indent , node ) ; indent . append ( <string_literal> ) ; } } return new configuration <identifiersep> cycle <identifiersep> exception ( out . to <identifiersep> string ( ) ) ; } @ override public void transition ( model <identifiersep> node <identifiersep> internal node , model <identifiersep> node . state desired , boolean later <identifiersep> ok ) { model <identifiersep> path path = node . get <identifiersep> path ( ) ; <LOG> model <identifiersep> node . state state = node . get <identifiersep> state ( ) ; if ( desired . ordinal ( ) < state . ordinal ( ) ) { if ( later <identifiersep> ok ) { return ; } else { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + path + <string_literal> + desired . name ( ) + <string_literal> + state . name ( ) ) ; <ect>
return do <identifiersep> calculate <identifiersep> dependencies ( graph , dependencies ) ; } boolean do <identifiersep> calculate <identifiersep> dependencies ( goal <identifiersep> graph graph , collection < model <identifiersep> goal > dependencies ) { return true ; } @ override public final void apply ( ) { if ( ! node . get <identifiersep> state ( ) . equals ( get <identifiersep> target <identifiersep> state ( ) . previous ( ) ) ) { <LOG> throw new illegal <identifiersep> state <identifiersep> exception ( string . format ( <string_literal> , node . get <identifiersep> path ( ) , get <identifiersep> target <identifiersep> state ( ) , node . get <identifiersep> state ( ) ) ) ; } node . set <identifiersep> state ( get <identifiersep> target <identifiersep> state ( ) ) ; } @ override void attach <identifiersep> to <identifiersep> cycle ( list < string > display <identifiersep> value ) { display <identifiersep> value . add ( get <identifiersep> path ( ) . to <identifiersep> string ( ) ) ; } } private class discover extends model <identifiersep> node <identifiersep> goal { <ect>
return acquire <identifiersep> client ( sftp <identifiersep> host ) ; } } private lockable <identifiersep> sftp <identifiersep> client acquire <identifiersep> client ( sftp <identifiersep> host sftp <identifiersep> host ) { return idle <identifiersep> clients . contains <identifiersep> key ( sftp <identifiersep> host ) ? reuse <identifiersep> existing <identifiersep> or <identifiersep> create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) : create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) ; } private lockable <identifiersep> sftp <identifiersep> client reuse <identifiersep> existing <identifiersep> or <identifiersep> create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host sftp <identifiersep> host ) { list < lockable <identifiersep> sftp <identifiersep> client > clients <identifiersep> by <identifiersep> host = idle <identifiersep> clients . get ( sftp <identifiersep> host ) ; lockable <identifiersep> sftp <identifiersep> client client = null ; <LOG> if ( clients <identifiersep> by <identifiersep> host . is <identifiersep> empty ( ) ) { client = create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) ; } else { client = clients <identifiersep> by <identifiersep> host . remove ( 0 ) ; if ( ! client . is <identifiersep> connected ( ) ) { logger . info ( <string_literal> ) ; <ect>
} else { client = clients <identifiersep> by <identifiersep> host . remove ( 0 ) ; if ( ! client . is <identifiersep> connected ( ) ) { logger . info ( <string_literal> ) ; discard ( client ) ; client = reuse <identifiersep> existing <identifiersep> or <identifiersep> create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) ; <LOG> } else { } } return client ; } private lockable <identifiersep> sftp <identifiersep> client create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host sftp <identifiersep> host ) { lockable <identifiersep> sftp <identifiersep> client client = sftp <identifiersep> client <identifiersep> creator . create <identifiersep> new <identifiersep> client ( sftp <identifiersep> host ) ; all <identifiersep> clients . add ( client ) ; return client ; <ect>
private final s3client s3client ; public s3resource <identifiersep> connector ( s3client s3client ) { this . s3client = s3client ; } public list < string > list ( uri parent ) { logger . debug ( <string_literal> , parent ) ; return s3client . list <identifiersep> direct <identifiersep> children ( parent ) ; } <LOG> public external <identifiersep> resource <identifiersep> read <identifiersep> response open <identifiersep> resource ( uri location , boolean revalidate ) { s3object s3object = s3client . get <identifiersep> resource ( location ) ; if ( s3object == null ) { return null ; } return new s3resource ( s3object , location ) ; } public external <identifiersep> resource <identifiersep> meta <identifiersep> data get <identifiersep> meta <identifiersep> data ( uri location , boolean revalidate ) { <ect>
object <identifiersep> metadata . get <identifiersep> content <identifiersep> type ( ) , object <identifiersep> metadata . get <identifiersep> e <identifiersep> tag ( ) , null ) ; <comment> <LOG> public void upload ( readable <identifiersep> content resource , uri destination ) throws io <identifiersep> exception { input <identifiersep> stream input <identifiersep> stream = resource . open ( ) ; try { s3client . put ( input <identifiersep> stream , resource . get <identifiersep> content <identifiersep> length ( ) , destination ) ; } finally { input <identifiersep> stream . close ( ) ; <ect>
object <identifiersep> metadata . set <identifiersep> content <identifiersep> length ( content <identifiersep> length ) ; put <identifiersep> object <identifiersep> request put <identifiersep> object <identifiersep> request = new put <identifiersep> object <identifiersep> request ( bucket <identifiersep> name , s3bucket <identifiersep> key , input <identifiersep> stream , object <identifiersep> metadata ) ; logger . debug ( <string_literal> , s3bucket <identifiersep> key , bucket <identifiersep> name ) ; amazon <identifiersep> s3client . put <identifiersep> object ( put <identifiersep> object <identifiersep> request ) ; } catch ( amazon <identifiersep> client <identifiersep> exception e ) { throw resource <identifiersep> exceptions . put <identifiersep> failed ( destination , e ) ; } } <LOG> public s3object get <identifiersep> meta <identifiersep> data ( uri uri ) { <comment> <ect>
build <identifiersep> file < < gradle <identifiersep> api <identifiersep> dependency ( ) file ( 'src / main / java / my <identifiersep> plugin . java' ) < < <string_literal> <string_literal> <LOG> public void apply ( project project ) { } } <string_literal> <string_literal> can compile typical groovy - based gradle plugin using gradle api without having to declare groovy dependency <string_literal> <ect>
public default <identifiersep> worker <identifiersep> lease <identifiersep> service ( resource <identifiersep> lock <identifiersep> coordination <identifiersep> service coordination <identifiersep> service , parallelism <identifiersep> configuration <identifiersep> manager parallelism <identifiersep> configuration <identifiersep> manager ) { this . max <identifiersep> worker <identifiersep> count = parallelism <identifiersep> configuration <identifiersep> manager . get <identifiersep> parallelism <identifiersep> configuration ( ) . get <identifiersep> max <identifiersep> worker <identifiersep> count ( ) ; this . coordination <identifiersep> service = coordination <identifiersep> service ; this . project <identifiersep> lock <identifiersep> registry = new project <identifiersep> lock <identifiersep> registry ( coordination <identifiersep> service , parallelism <identifiersep> configuration <identifiersep> manager . get <identifiersep> parallelism <identifiersep> configuration ( ) . is <identifiersep> parallel <identifiersep> project <identifiersep> execution <identifiersep> enabled ( ) ) ; this . worker <identifiersep> lease <identifiersep> lock <identifiersep> registry = new worker <identifiersep> lease <identifiersep> lock <identifiersep> registry ( coordination <identifiersep> service ) ; this . parallelism <identifiersep> configuration <identifiersep> manager = parallelism <identifiersep> configuration <identifiersep> manager ; <LOG> parallelism <identifiersep> configuration <identifiersep> manager . add <identifiersep> listener ( this ) ; } @ override public void on <identifiersep> parallelism <identifiersep> configuration <identifiersep> change ( parallelism <identifiersep> configuration parallelism <identifiersep> configuration ) { this . max <identifiersep> worker <identifiersep> count = parallelism <identifiersep> configuration . get <identifiersep> max <identifiersep> worker <identifiersep> count ( ) ; project <identifiersep> lock <identifiersep> registry . set <identifiersep> parallel <identifiersep> enabled ( parallelism <identifiersep> configuration . is <identifiersep> parallel <identifiersep> project <identifiersep> execution <identifiersep> enabled ( ) ) ; } @ override <ect>
protected boolean acquire <identifiersep> lock ( ) { if ( parent . grant <identifiersep> lease ( ) ) { active = true ; logger . debug ( <string_literal> , get <identifiersep> display <identifiersep> name ( ) , root . leases <identifiersep> in <identifiersep> use ) ; } <LOG> } else { } } return active ; } @ override protected void release <identifiersep> lock ( ) { if ( thread . current <identifiersep> thread ( ) != owner <identifiersep> thread ) { <comment> <ect>
this . lock <identifiersep> action = lock <identifiersep> action ; this . unlock <identifiersep> action = unlock <identifiersep> action ; } @ override public boolean try <identifiersep> lock ( ) { fail <identifiersep> if <identifiersep> not <identifiersep> in <identifiersep> resource <identifiersep> lock <identifiersep> state <identifiersep> change ( ) ; if ( ! is <identifiersep> locked <identifiersep> by <identifiersep> current <identifiersep> thread ( ) ) { <LOG> if ( acquire <identifiersep> lock ( ) ) { lock <identifiersep> action . execute ( this ) ; coordination <identifiersep> service . get <identifiersep> current ( ) . register <identifiersep> locked ( this ) ; return true ; } else { return false ; <ect>
for ( stoppable element : elements ) { try { element . stop ( ) ; } catch ( throwable throwable ) { if ( failure == null ) { failure = throwable ; <LOG> } else { } } } } finally { elements . clear ( ) ; } if ( failure != null ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( failure ) ; } } } <ect>
public class hello { public static void main ( string . . . args ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <string_literal> public class hello { <LOG> public static void main ( string . . . args ) { } } <string_literal> <string_literal> <string_literal> <ect>
return false ; } } ) ; closeable <identifiersep> http <identifiersep> response response = null ; try { response = http <identifiersep> client <identifiersep> helper . perform <identifiersep> http <identifiersep> request ( http <identifiersep> put ) ; <LOG> status <identifiersep> line status <identifiersep> line = response . get <identifiersep> status <identifiersep> line ( ) ; } int status <identifiersep> code = status <identifiersep> line . get <identifiersep> status <identifiersep> code ( ) ; if ( ! is <identifiersep> http <identifiersep> success ( status <identifiersep> code ) ) { string default <identifiersep> message = string . format ( <string_literal> , safe <identifiersep> uri ( uri ) , status <identifiersep> code , status <identifiersep> line . get <identifiersep> reason <identifiersep> phrase ( ) ) ; if ( is <identifiersep> redirect ( status <identifiersep> code ) ) { handle <identifiersep> redirect ( uri , response , status <identifiersep> code , default <identifiersep> message , <string_literal> ) ; <ect>
system . err . println <string_literal> println <string_literal> project . logger . error ( <string_literal> ) ; project . logger . warn ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; <LOG> project . logger . info ( <string_literal> ) ; <string_literal> <string_literal> <ect>
no <identifiersep> exception <identifiersep> thrown ( ) } def <string_literal> ( ) { <comment> <LOG> logger . debug ( <string_literal> ) <string_literal> <string_literal> <ect>
class standard <identifiersep> streams <identifiersep> cross <identifiersep> version <identifiersep> spec extends tooling <identifiersep> api <identifiersep> logging <identifiersep> specification { @ rule redirect <identifiersep> std <identifiersep> out <identifiersep> and <identifiersep> err std <identifiersep> out <identifiersep> and <identifiersep> err = new redirect <identifiersep> std <identifiersep> out <identifiersep> and <identifiersep> err ( ) def escape <identifiersep> header = <string_literal> @ target <identifiersep> gradle <identifiersep> version ( <string_literal> ) def <string_literal> ( ) { file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> project . logger . error ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; task log { <ect>
build . run ( ) } then : ! std <identifiersep> out <identifiersep> and <identifiersep> err . std <identifiersep> out . contains ( <string_literal> ) ! std <identifiersep> out <identifiersep> and <identifiersep> err . std <identifiersep> err . contains ( <string_literal> ) } @ target <identifiersep> gradle <identifiersep> version ( <string_literal> ) def <string_literal> ( ) { <LOG> file ( <string_literal> ) < < <string_literal> <string_literal> warn logging <string_literal> lifecycle logging <string_literal> quiet logging <string_literal> info logging <string_literal> debug logging <string_literal> <ect>
def <string_literal> ( ) { file ( <string_literal> ) < < <string_literal> <string_literal> error logging <string_literal> warn logging <string_literal> lifecycle logging <string_literal> quiet logging <string_literal> <LOG> project . logger . info ( <string_literal> ) ; task log { do <identifiersep> last { println <string_literal> } } <string_literal> <string_literal> <ect>
<comment> <LOG> launcher . set <identifiersep> color <identifiersep> output ( $ { with <identifiersep> color } ) ; <comment> <ect>
launcher . set <identifiersep> color <identifiersep> output ( $ { with <identifiersep> color } ) ; system . out . println ( <string_literal> + $ { with <identifiersep> color } ) ; <comment> <LOG> <comment> <ect>
if ( isolated <identifiersep> tooling <identifiersep> client != null ) { isolated <identifiersep> tooling <identifiersep> client . close ( ) } if ( require <identifiersep> isolated <identifiersep> daemons ) { try { get <identifiersep> daemons ( ) . kill <identifiersep> all ( ) } catch ( runtime <identifiersep> exception ex ) { <LOG> <comment> <ect>
version <identifiersep> details version <identifiersep> details = adapted <identifiersep> connection . get <identifiersep> version <identifiersep> details ( ) ; consumer <identifiersep> connection delegate = version <identifiersep> details . supports <identifiersep> cancellation ( ) ? adapted <identifiersep> connection : new non <identifiersep> cancellable <identifiersep> consumer <identifiersep> connection <identifiersep> adapter ( adapted <identifiersep> connection ) ; return new parameter <identifiersep> validating <identifiersep> consumer <identifiersep> connection ( version <identifiersep> details , delegate ) ; } private consumer <identifiersep> connection create <identifiersep> deprecated <identifiersep> connection ( abstract <identifiersep> consumer <identifiersep> connection adapted <identifiersep> connection , connection <identifiersep> parameters connection <identifiersep> parameters ) { return new deprecated <identifiersep> version <identifiersep> consumer <identifiersep> connection ( create <identifiersep> connection ( adapted <identifiersep> connection , connection <identifiersep> parameters ) , adapted <identifiersep> connection . get <identifiersep> version <identifiersep> details ( ) ) ; } private class <identifiersep> loader create <identifiersep> implementation <identifiersep> class <identifiersep> loader ( distribution distribution , progress <identifiersep> logger <identifiersep> factory progress <identifiersep> logger <identifiersep> factory , internal <identifiersep> build <identifiersep> progress <identifiersep> listener progress <identifiersep> listener , file user <identifiersep> home <identifiersep> dir , build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token ) { <LOG> class <identifiersep> path implementation <identifiersep> classpath = distribution . get <identifiersep> tooling <identifiersep> implementation <identifiersep> classpath ( progress <identifiersep> logger <identifiersep> factory , progress <identifiersep> listener , user <identifiersep> home <identifiersep> dir , cancellation <identifiersep> token ) ; filtering <identifiersep> class <identifiersep> loader . spec filter <identifiersep> spec = new filtering <identifiersep> class <identifiersep> loader . spec ( ) ; filter <identifiersep> spec . allow <identifiersep> package ( <string_literal> ) ; filtering <identifiersep> class <identifiersep> loader filtering <identifiersep> class <identifiersep> loader = new filtering <identifiersep> class <identifiersep> loader ( class <identifiersep> loader , filter <identifiersep> spec ) ; return new visitable <identifiersep> url <identifiersep> class <identifiersep> loader ( filtering <identifiersep> class <identifiersep> loader , implementation <identifiersep> classpath ) ; } } <ect>
<comment> public default <identifiersep> gradle <identifiersep> connector set <identifiersep> verbose <identifiersep> logging ( boolean verbose <identifiersep> logging ) { connection <identifiersep> params <identifiersep> builder . set <identifiersep> verbose <identifiersep> logging ( verbose <identifiersep> logging ) ; return this ; } <LOG> public project <identifiersep> connection connect ( ) throws gradle <identifiersep> connection <identifiersep> exception { connection <identifiersep> parameters connection <identifiersep> parameters = connection <identifiersep> params <identifiersep> builder . build ( ) ; if ( connection <identifiersep> parameters . get <identifiersep> project <identifiersep> dir ( ) == null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } if ( distribution == null ) { distribution = distribution <identifiersep> factory . get <identifiersep> default <identifiersep> distribution ( connection <identifiersep> parameters . get <identifiersep> project <identifiersep> dir ( ) , connection <identifiersep> parameters . is <identifiersep> search <identifiersep> upwards ( ) != null ? connection <identifiersep> parameters . is <identifiersep> search <identifiersep> upwards ( ) : true ) ; <ect>
* < pre class = 'auto <identifiersep> tested' > * project <identifiersep> connection connection = gradle <identifiersep> connector . new <identifiersep> connector ( ) * . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) * . connect ( ) ; * * try { <LOG> * build <identifiersep> environment env = connection . get <identifiersep> model ( build <identifiersep> environment . class ) ; * system . out . println ( <string_literal> + env . get <identifiersep> java ( ) . get <identifiersep> java <identifiersep> home ( ) ) ; * } finally { * connection . close ( ) ; * } * < / pre > <ect>
<string_literal> <string_literal> <string_literal> import java . nio . file . files ; import java . nio . file . paths ; public class main { public static void main ( string . . . args ) throws exception { <LOG> <comment> <ect>
compile <identifiersep> java { options . annotation <identifiersep> processor <identifiersep> path = configurations . apt } <string_literal> <string_literal> <LOG> public static void main ( string [ ] args ) { } } ''' expect : succeeds <string_literal> ! file ( 'build / classes / java / main / test <identifiersep> app <identifiersep> helper . class' ) . exists ( ) } def <string_literal> ( ) { <ect>
with <identifiersep> build <identifiersep> cache ( ) . run 'clean' , 'assemble' then : executed <identifiersep> and <identifiersep> not <identifiersep> skipped ' : b : jar' , ' : a : compile <identifiersep> java' } void make <identifiersep> abi <identifiersep> compatible <identifiersep> change <identifiersep> on <identifiersep> b ( ) { file ( 'b / src / main / java / b . java' ) . text = ''' public class b { <LOG> public int truth ( ) { return <number_literal> ; } } ''' } void make <identifiersep> abi <identifiersep> breaking <identifiersep> change <identifiersep> on <identifiersep> b ( ) { file ( 'b / src / main / java / b . java' ) . text = ''' public class b { <ect>
and : succeeds ' : main <identifiersep> jar' when : update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { private string name ; <LOG> public void say <identifiersep> hello ( string greeting ) { } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' <ect>
given : apply <identifiersep> java <identifiersep> plugin ( build <identifiersep> file ) main <identifiersep> library <identifiersep> depending <identifiersep> on <identifiersep> api ( dependency <identifiersep> scope . sources , api ) file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { private string name ; <LOG> public void say <identifiersep> hello ( ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
given : apply <identifiersep> java <identifiersep> plugin ( build <identifiersep> file ) main <identifiersep> library <identifiersep> depending <identifiersep> on <identifiersep> api ( dependency <identifiersep> scope . sources , api ) file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { private string name ; <LOG> public void say <identifiersep> hello ( ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
''' file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { private string name ; public void say <identifiersep> hello ( @ ann1 ( <string_literal> ) <LOG> @ ann2 ( a = <string_literal> , b = <string_literal> ) string intro ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
''' file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { @ ann1 ( <string_literal> ) @ ann2 ( a = <string_literal> , b = <string_literal> ) public string name ; <LOG> public void say <identifiersep> hello ( ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
public class jdk <identifiersep> java <identifiersep> compiler implements compiler < java <identifiersep> compile <identifiersep> spec > , serializable { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( jdk <identifiersep> java <identifiersep> compiler . class ) ; private final factory < java <identifiersep> compiler > java <identifiersep> home <identifiersep> based <identifiersep> java <identifiersep> compiler <identifiersep> factory ; public jdk <identifiersep> java <identifiersep> compiler ( factory < java <identifiersep> compiler > java <identifiersep> home <identifiersep> based <identifiersep> java <identifiersep> compiler <identifiersep> factory ) { this . java <identifiersep> home <identifiersep> based <identifiersep> java <identifiersep> compiler <identifiersep> factory = java <identifiersep> home <identifiersep> based <identifiersep> java <identifiersep> compiler <identifiersep> factory ; } @ override <LOG> public work <identifiersep> result execute ( java <identifiersep> compile <identifiersep> spec spec ) { jdk <identifiersep> java <identifiersep> compiler <identifiersep> result result = new jdk <identifiersep> java <identifiersep> compiler <identifiersep> result ( ) ; java <identifiersep> compiler . compilation <identifiersep> task task = create <identifiersep> compile <identifiersep> task ( spec , result ) ; boolean success = task . call ( ) ; if ( ! success ) { throw new compilation <identifiersep> failed <identifiersep> exception ( ) ; <ect>
logger . debug ( <string_literal> , joined <identifiersep> args ) ; } private work <identifiersep> result delegate <identifiersep> and <identifiersep> handle <identifiersep> errors ( java <identifiersep> compile <identifiersep> spec spec ) { try { return delegate . execute ( spec ) ; } catch ( compilation <identifiersep> failed <identifiersep> exception e ) { if ( spec . get <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> fail <identifiersep> on <identifiersep> error ( ) ) { <LOG> throw e ; } return work <identifiersep> results . did <identifiersep> work ( false ) ; } } } <ect>
try { map < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > processor <identifiersep> types = get <identifiersep> processor <identifiersep> types ( classes <identifiersep> dir ) ; return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , processor <identifiersep> types ) ; } catch ( exception e ) { logger . warn ( <string_literal> + classes <identifiersep> dir + <string_literal> , log <identifiersep> stack <identifiersep> traces ? e : null ) ; return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , collections . < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > empty <identifiersep> map ( ) ) ; } <LOG> } catch ( exception e ) { return collections . empty <identifiersep> list ( ) ; } } private list < string > get <identifiersep> processor <identifiersep> class <identifiersep> names ( file classes <identifiersep> dir ) throws io <identifiersep> exception { file processor <identifiersep> declaration = new file ( classes <identifiersep> dir , processor <identifiersep> declaration ) ; if ( ! processor <identifiersep> declaration . is <identifiersep> file ( ) ) { return collections . empty <identifiersep> list ( ) ; <ect>
return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , processor <identifiersep> types ) ; } catch ( exception e ) { logger . warn ( <string_literal> + jar + <string_literal> , log <identifiersep> stack <identifiersep> traces ? e : null ) ; return to <identifiersep> processor <identifiersep> declarations ( processor <identifiersep> class <identifiersep> names , collections . < string , incremental <identifiersep> annotation <identifiersep> processor <identifiersep> type > empty <identifiersep> map ( ) ) ; } } finally { zip <identifiersep> file . close ( ) ; } <LOG> } catch ( exception e ) { return collections . empty <identifiersep> list ( ) ; } } private list < string > get <identifiersep> processor <identifiersep> class <identifiersep> names ( zip <identifiersep> file zip <identifiersep> file ) throws io <identifiersep> exception { zip <identifiersep> entry processor <identifiersep> declaration = zip <identifiersep> file . get <identifiersep> entry ( processor <identifiersep> declaration ) ; if ( processor <identifiersep> declaration == null ) { return collections . empty <identifiersep> list ( ) ; <ect>
args . add ( use <identifiersep> unshared <identifiersep> compiler <identifiersep> table <identifiersep> option ) ; } private void add <identifiersep> user <identifiersep> provided <identifiersep> args ( list < string > compiler <identifiersep> args ) { if ( ! include <identifiersep> main <identifiersep> options ) { return ; } if ( compiler <identifiersep> args != null ) { if ( compiler <identifiersep> args . contains ( <string_literal> ) ) { <LOG> if ( ! extract <identifiersep> sourcepath <identifiersep> from ( args , true ) . is <identifiersep> empty ( ) ) { } } args . add <identifiersep> all ( compiler <identifiersep> args ) ; } } private string extract <identifiersep> sourcepath <identifiersep> from ( list < string > compiler <identifiersep> args , boolean silently ) { iterator < string > arg <identifiersep> iterator = compiler <identifiersep> args . iterator ( ) ; string user <identifiersep> provided <identifiersep> sourcepath = <string_literal> ; while ( arg <identifiersep> iterator . has <identifiersep> next ( ) ) { <ect>
if ( jar <identifiersep> classpath <identifiersep> snapshot != null ) { return ; } timer clock = time . start <identifiersep> timer ( ) ; iterable < jar <identifiersep> archive > jar <identifiersep> archives = classpath <identifiersep> jar <identifiersep> finder . find <identifiersep> jar <identifiersep> archives ( classpath ) ; jar <identifiersep> classpath <identifiersep> snapshot = classpath <identifiersep> snapshot <identifiersep> factory . create <identifiersep> snapshot ( jar <identifiersep> archives ) ; int duplicates <identifiersep> count = jar <identifiersep> classpath <identifiersep> snapshot . get <identifiersep> data ( ) . get <identifiersep> duplicate <identifiersep> classes ( ) . size ( ) ; <LOG> string duplicate <identifiersep> classes <identifiersep> message = duplicates <identifiersep> count == 0 ? <string_literal> : <string_literal> + duplicates <identifiersep> count + <string_literal> ; log . debug ( <string_literal> , duplicates <identifiersep> count , jar <identifiersep> classpath <identifiersep> snapshot . get <identifiersep> data ( ) . get <identifiersep> duplicate <identifiersep> classes ( ) ) ; } } <ect>
this . annotation <identifiersep> processor <identifiersep> detector = annotation <identifiersep> processor <identifiersep> detector ; } public compiler < java <identifiersep> compile <identifiersep> spec > prepare <identifiersep> compiler ( incremental <identifiersep> task <identifiersep> inputs inputs ) { compiler < java <identifiersep> compile <identifiersep> spec > compiler = get <identifiersep> compiler ( inputs , source <identifiersep> dirs ) ; incremental <identifiersep> result <identifiersep> storing <identifiersep> decorator compilation <identifiersep> finalizer = new incremental <identifiersep> result <identifiersep> storing <identifiersep> decorator ( compiler , jar <identifiersep> classpath <identifiersep> snapshot <identifiersep> maker , class <identifiersep> set <identifiersep> analysis <identifiersep> updater , compile <identifiersep> caches . get <identifiersep> annotation <identifiersep> processor <identifiersep> path <identifiersep> store ( ) ) ; return new incremental <identifiersep> annotation <identifiersep> processing <identifiersep> compiler ( compilation <identifiersep> finalizer , annotation <identifiersep> processor <identifiersep> detector ) ; } private compiler < java <identifiersep> compile <identifiersep> spec > get <identifiersep> compiler ( incremental <identifiersep> task <identifiersep> inputs inputs , compilation <identifiersep> source <identifiersep> dirs source <identifiersep> dirs ) { <LOG> if ( ! inputs . is <identifiersep> incremental ( ) ) { return cleaning <identifiersep> compiler ; } if ( ! source <identifiersep> dirs . can <identifiersep> infer <identifiersep> source <identifiersep> roots ( ) ) { log . info ( <string_literal> , display <identifiersep> name ) ; return cleaning <identifiersep> compiler ; } list < annotation <identifiersep> processor <identifiersep> declaration > non <identifiersep> incremental <identifiersep> processors = get <identifiersep> non <identifiersep> incremental <identifiersep> processors ( ) ; <ect>
return cleaning <identifiersep> compiler ; } list < annotation <identifiersep> processor <identifiersep> declaration > non <identifiersep> incremental <identifiersep> processors = get <identifiersep> non <identifiersep> incremental <identifiersep> processors ( ) ; if ( ! non <identifiersep> incremental <identifiersep> processors . is <identifiersep> empty ( ) ) { warn <identifiersep> about <identifiersep> non <identifiersep> incremental <identifiersep> processors ( non <identifiersep> incremental <identifiersep> processors ) ; return cleaning <identifiersep> compiler ; } class <identifiersep> set <identifiersep> analysis <identifiersep> data data = compile <identifiersep> caches . get <identifiersep> local <identifiersep> class <identifiersep> set <identifiersep> analysis <identifiersep> store ( ) . get ( ) ; <LOG> if ( data == null ) { return cleaning <identifiersep> compiler ; } previous <identifiersep> compilation previous <identifiersep> compilation = new previous <identifiersep> compilation ( new class <identifiersep> set <identifiersep> analysis ( data ) , compile <identifiersep> caches . get <identifiersep> local <identifiersep> jar <identifiersep> classpath <identifiersep> snapshot <identifiersep> store ( ) , compile <identifiersep> caches . get <identifiersep> jar <identifiersep> snapshot <identifiersep> cache ( ) , compile <identifiersep> caches . get <identifiersep> annotation <identifiersep> processor <identifiersep> path <identifiersep> store ( ) ) ; return new selective <identifiersep> compiler ( inputs , previous <identifiersep> compilation , cleaning <identifiersep> compiler , stale <identifiersep> class <identifiersep> detecter , compilation <identifiersep> initializer , jar <identifiersep> classpath <identifiersep> snapshot <identifiersep> maker ) ; } private list < annotation <identifiersep> processor <identifiersep> declaration > get <identifiersep> non <identifiersep> incremental <identifiersep> processors ( ) { map < string , annotation <identifiersep> processor <identifiersep> declaration > all <identifiersep> processors = annotation <identifiersep> processor <identifiersep> detector . detect <identifiersep> processors ( annotation <identifiersep> processor <identifiersep> path ) ; <ect>
this . jar <identifiersep> classpath <identifiersep> snapshot <identifiersep> provider = jar <identifiersep> classpath <identifiersep> snapshot <identifiersep> provider ; } @ override public work <identifiersep> result execute ( java <identifiersep> compile <identifiersep> spec spec ) { timer clock = time . start <identifiersep> timer ( ) ; current <identifiersep> compilation current <identifiersep> compilation = new current <identifiersep> compilation ( inputs , spec , jar <identifiersep> classpath <identifiersep> snapshot <identifiersep> provider ) ; recompilation <identifiersep> spec recompilation <identifiersep> spec = recompilation <identifiersep> spec <identifiersep> provider . provide <identifiersep> recompilation <identifiersep> spec ( current <identifiersep> compilation , previous <identifiersep> compilation ) ; <LOG> if ( recompilation <identifiersep> spec . is <identifiersep> full <identifiersep> rebuild <identifiersep> needed ( ) ) { return cleaning <identifiersep> compiler . execute ( spec ) ; } incremental <identifiersep> compilation <identifiersep> initilizer . initialize <identifiersep> compilation ( spec , recompilation <identifiersep> spec ) ; if ( spec . get <identifiersep> source ( ) . is <identifiersep> empty ( ) && spec . get <identifiersep> classes ( ) . is <identifiersep> empty ( ) ) { log . info ( <string_literal> , clock . get <identifiersep> elapsed ( ) ) ; return new recompilation <identifiersep> not <identifiersep> necessary ( ) ; <ect>
if ( spec . get <identifiersep> source ( ) . is <identifiersep> empty ( ) && spec . get <identifiersep> classes ( ) . is <identifiersep> empty ( ) ) { log . info ( <string_literal> , clock . get <identifiersep> elapsed ( ) ) ; return new recompilation <identifiersep> not <identifiersep> necessary ( ) ; } try { return cleaning <identifiersep> compiler . get <identifiersep> compiler ( ) . execute ( spec ) ; } finally { <LOG> collection < string > classes <identifiersep> to <identifiersep> compile = recompilation <identifiersep> spec . get <identifiersep> classes <identifiersep> to <identifiersep> compile ( ) ; log . debug ( <string_literal> , classes <identifiersep> to <identifiersep> compile ) ; } } } <ect>
return ; } timer clock = time . start <identifiersep> timer ( ) ; compilation <identifiersep> result <identifiersep> analyzer analyzer = new compilation <identifiersep> result <identifiersep> analyzer ( this . analyzer , file <identifiersep> hasher ) ; visit <identifiersep> annotation <identifiersep> processing <identifiersep> result ( spec , result , analyzer ) ; visit <identifiersep> class <identifiersep> files ( spec , analyzer ) ; class <identifiersep> set <identifiersep> analysis <identifiersep> data data = analyzer . get <identifiersep> analysis ( ) ; <LOG> stash . put ( data ) ; } private void visit <identifiersep> annotation <identifiersep> processing <identifiersep> result ( java <identifiersep> compile <identifiersep> spec spec , work <identifiersep> result result , compilation <identifiersep> result <identifiersep> analyzer analyzer ) { if ( ! spec . get <identifiersep> effective <identifiersep> annotation <identifiersep> processors ( ) . is <identifiersep> empty ( ) ) { annotation <identifiersep> processing <identifiersep> result annotation <identifiersep> processing <identifiersep> result = null ; if ( result instanceof jdk <identifiersep> java <identifiersep> compiler <identifiersep> result ) { annotation <identifiersep> processing <identifiersep> result = ( ( jdk <identifiersep> java <identifiersep> compiler <identifiersep> result ) result ) . get <identifiersep> annotation <identifiersep> processing <identifiersep> result ( ) ; <ect>
def jar = tmp <identifiersep> dir . file ( <string_literal> ) jar < < <string_literal> def cp = files ( jar ) when : def processors = detector . detect <identifiersep> processors ( cp ) then : <LOG> processors == [ : ] } def <string_literal> ( ) { given : def jar = tmp <identifiersep> dir . file ( <string_literal> ) jar < < jar <identifiersep> utils . jar <identifiersep> with <identifiersep> contents ( ( processor <identifiersep> declaration ) : <string_literal> ) def dir = tmp <identifiersep> dir . file ( <string_literal> ) <ect>
package $ { package <identifiersep> name } ; import static org . junit . assert . * ; public class $ { test <identifiersep> class <identifiersep> name } { private final $ { production <identifiersep> class <identifiersep> name } production = new $ { production <identifiersep> class <identifiersep> name } ( <string_literal> ) ; @ org . junit . test public void test <identifiersep> one ( ) { <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) { <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . err . println ( <string_literal> + i ) ; } string expected = < % = binding . has <identifiersep> variable ( <string_literal> ) && binding . half <identifiersep> tests <identifiersep> fail ? <string_literal> : <string_literal> % > ; assert <identifiersep> equals ( production . get <identifiersep> property ( ) , expected ) ; } } <ect>
import org . testng . annotations . * ; import static org . testng . assert . * ; public class $ { test <identifiersep> class <identifiersep> name } { private final $ { production <identifiersep> class <identifiersep> name } production = new $ { production <identifiersep> class <identifiersep> name } ( <string_literal> ) ; @ test public void test <identifiersep> one ( ) { <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ test public void test <identifiersep> two ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <ect>
logger . info ( event . get <identifiersep> exception ( ) . get <identifiersep> message ( ) ) ; } else { logger . error ( event . get <identifiersep> exception ( ) . get <identifiersep> message ( ) ) ; } reset <identifiersep> current <identifiersep> build <identifiersep> operation <identifiersep> ref ( ) ; } public void transfer <identifiersep> succeeded ( transfer <identifiersep> event event ) { long content <identifiersep> length = event . get <identifiersep> resource ( ) . get <identifiersep> content <identifiersep> length ( ) ; <LOG> if ( content <identifiersep> length > 0 && event . get <identifiersep> request <identifiersep> type ( ) == request <identifiersep> type . put ) { } reset <identifiersep> current <identifiersep> build <identifiersep> operation <identifiersep> ref ( ) ; } private void reset <identifiersep> current <identifiersep> build <identifiersep> operation <identifiersep> ref ( ) { current <identifiersep> build <identifiersep> operation <identifiersep> ref . set ( previous <identifiersep> build <identifiersep> operation <identifiersep> ref . get ( ) ) ; } } <ect>
this . passphrase = settings . get <identifiersep> passphrase ( ) ; } @ override public string get <identifiersep> name ( ) { return name ; } @ override public void sign ( final input <identifiersep> stream input , final output <identifiersep> stream output ) { <LOG> final list < string > arguments = build <identifiersep> argument <identifiersep> list ( ) ; project . exec ( new action < exec <identifiersep> spec > ( ) { @ override public void execute ( exec <identifiersep> spec spec ) { spec . set <identifiersep> executable ( executable ) ; spec . set <identifiersep> args ( arguments ) ; <ect>
class thing { thing ( ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> new thing ( ) <string_literal> root <identifiersep> project . name = 'some <identifiersep> build' <string_literal> <string_literal> <LOG> class thing { } <string_literal> <string_literal> new thing ( ) <string_literal> help <string_literal> <ect>
apply plugin : 'java' <string_literal> <string_literal> src / main / java / org / test / library . java <string_literal> <string_literal> package org . test ; public class library { <LOG> public static void print ( string who ) { } } <string_literal> <string_literal> <string_literal> root <identifiersep> project . name = <string_literal> include <identifiersep> build <string_literal> include <string_literal> <ect>
dependency <identifiersep> substitution . use <identifiersep> target ( default <identifiersep> project <identifiersep> component <identifiersep> selector . new <identifiersep> selector ( replacement ) , version <identifiersep> selection <identifiersep> reasons . composite <identifiersep> build ) ; } } } private project <identifiersep> component <identifiersep> identifier get <identifiersep> replacement <identifiersep> for ( module <identifiersep> component <identifiersep> selector selector ) { module <identifiersep> identifier candidate <identifiersep> id = module <identifiersep> identifier <identifiersep> factory . module ( selector . get <identifiersep> group ( ) , selector . get <identifiersep> module ( ) ) ; collection < project <identifiersep> component <identifiersep> identifier > providing <identifiersep> projects = replacement <identifiersep> map . get ( candidate <identifiersep> id ) ; <LOG> if ( providing <identifiersep> projects . is <identifiersep> empty ( ) ) { return null ; } if ( providing <identifiersep> projects . size ( ) == 1 ) { project <identifiersep> component <identifiersep> identifier match = providing <identifiersep> projects . iterator ( ) . next ( ) ; logger . info ( <string_literal> + match + <string_literal> + candidate <identifiersep> id + <string_literal> ) ; return match ; <ect>
return available <identifiersep> modules ; } private void register <identifiersep> project ( set < pair < module <identifiersep> version <identifiersep> identifier , project <identifiersep> component <identifiersep> identifier > > available <identifiersep> modules , project <identifiersep> internal project ) { local <identifiersep> component <identifiersep> registry local <identifiersep> component <identifiersep> registry = project . get <identifiersep> services ( ) . get ( local <identifiersep> component <identifiersep> registry . class ) ; project <identifiersep> component <identifiersep> identifier original <identifiersep> identifier = new <identifiersep> project <identifiersep> id ( project ) ; default <identifiersep> local <identifiersep> component <identifiersep> metadata original <identifiersep> component = ( default <identifiersep> local <identifiersep> component <identifiersep> metadata ) local <identifiersep> component <identifiersep> registry . get <identifiersep> component ( original <identifiersep> identifier ) ; project <identifiersep> component <identifiersep> identifier component <identifiersep> identifier = new <identifiersep> project <identifiersep> id ( this , project . get <identifiersep> path ( ) ) ; <LOG> module <identifiersep> version <identifiersep> identifier module <identifiersep> id = original <identifiersep> component . get <identifiersep> module <identifiersep> version <identifiersep> id ( ) ; available <identifiersep> modules . add ( pair . of ( module <identifiersep> id , component <identifiersep> identifier ) ) ; } @ override public settings <identifiersep> internal get <identifiersep> loaded <identifiersep> settings ( ) { return get <identifiersep> gradle <identifiersep> launcher ( ) . get <identifiersep> loaded <identifiersep> settings ( ) ; } @ override <ect>
and : file ( <string_literal> , <string_literal> , <string_literal> ) . mkdirs ( ) file ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) . write <string_literal> <string_literal> <LOG> public static void main ( string [ ] args ) { } } <string_literal> <string_literal> <string_literal> apply plugin : <string_literal> task echo <identifiersep> default <identifiersep> encoding ( type : java <identifiersep> exec ) { <ect>
list < string > jvm <identifiersep> arguments = operation <identifiersep> parameters . get <identifiersep> jvm <identifiersep> arguments ( ) ; if ( jvm <identifiersep> arguments != null ) { daemon <identifiersep> params . set <identifiersep> jvm <identifiersep> args ( jvm <identifiersep> arguments ) ; } map < string , string > env <identifiersep> variables = null ; try { env <identifiersep> variables = operation <identifiersep> parameters . get <identifiersep> environment <identifiersep> variables ( ) ; <LOG> } catch ( unsupported <identifiersep> method <identifiersep> exception e ) { } if ( env <identifiersep> variables != null ) { daemon <identifiersep> params . set <identifiersep> environment <identifiersep> variables ( env <identifiersep> variables ) ; } file java <identifiersep> home = operation <identifiersep> parameters . get <identifiersep> java <identifiersep> home ( ) ; if ( java <identifiersep> home != null ) { daemon <identifiersep> params . set <identifiersep> jvm ( jvm . for <identifiersep> home ( java <identifiersep> home ) ) ; <ect>
throws build <identifiersep> exception <identifiersep> version1 , internal <identifiersep> unsupported <identifiersep> build <identifiersep> argument <identifiersep> exception , illegal <identifiersep> state <identifiersep> exception { provider <identifiersep> operation <identifiersep> parameters provider <identifiersep> parameters = validate <identifiersep> and <identifiersep> convert ( operation <identifiersep> parameters ) ; provider <identifiersep> internal <identifiersep> test <identifiersep> execution <identifiersep> request test <identifiersep> execution <identifiersep> request <identifiersep> version2 = adapter . adapt ( provider <identifiersep> internal <identifiersep> test <identifiersep> execution <identifiersep> request . class , test <identifiersep> execution <identifiersep> request ) ; build <identifiersep> cancellation <identifiersep> token build <identifiersep> cancellation <identifiersep> token = new internal <identifiersep> cancellation <identifiersep> token <identifiersep> adapter ( cancellation <identifiersep> token ) ; object results = connection . run <identifiersep> tests ( test <identifiersep> execution <identifiersep> request <identifiersep> version2 , build <identifiersep> cancellation <identifiersep> token , provider <identifiersep> parameters ) ; return new provider <identifiersep> build <identifiersep> result < object > ( results ) ; } <LOG> private provider <identifiersep> operation <identifiersep> parameters validate <identifiersep> and <identifiersep> convert ( build <identifiersep> parameters build <identifiersep> parameters ) { assert <identifiersep> using <identifiersep> java7 ( ) ; check <identifiersep> unsupported <identifiersep> tapi <identifiersep> version ( ) ; provider <identifiersep> operation <identifiersep> parameters parameters = adapter . builder ( provider <identifiersep> operation <identifiersep> parameters . class ) . mix <identifiersep> in <identifiersep> to ( provider <identifiersep> operation <identifiersep> parameters . class , build <identifiersep> log <identifiersep> level <identifiersep> mix <identifiersep> in . class ) . build ( build <identifiersep> parameters ) ; check <identifiersep> deprecated <identifiersep> tapi <identifiersep> version ( parameters ) ; deprecation <identifiersep> logger . reset ( ) ; <ect>
if ( ! visited . add ( target ) ) { <comment> <LOG> if ( resource == null ) { return ; } file class <identifiersep> path <identifiersep> root = classpath <identifiersep> util . get <identifiersep> classpath <identifiersep> for <identifiersep> class ( target ) ; dest . add ( class <identifiersep> path <identifiersep> root . to <identifiersep> uri ( ) . to <identifiersep> url ( ) ) ; <comment> <ect>
exception <identifiersep> analyser exception <identifiersep> analyser = new multiple <identifiersep> build <identifiersep> failures <identifiersep> exception <identifiersep> analyser ( new default <identifiersep> exception <identifiersep> analyser ( new default <identifiersep> listener <identifiersep> manager ( ) ) ) ; if ( action . get <identifiersep> start <identifiersep> parameter ( ) . get <identifiersep> show <identifiersep> stacktrace ( ) != show <identifiersep> stacktrace . always <identifiersep> full ) { exception <identifiersep> analyser = new stack <identifiersep> trace <identifiersep> sanitizing <identifiersep> exception <identifiersep> analyser ( exception <identifiersep> analyser ) ; } throwable failure = e ; try { failure = exception <identifiersep> analyser . transform ( e ) ; <LOG> } catch ( throwable inner <identifiersep> failure ) { } build <identifiersep> started <identifiersep> time build <identifiersep> started <identifiersep> time = build <identifiersep> started <identifiersep> time . starting <identifiersep> at ( request <identifiersep> context . get <identifiersep> start <identifiersep> time ( ) ) ; build <identifiersep> logger build <identifiersep> logger = new build <identifiersep> logger ( logging . get <identifiersep> logger ( services <identifiersep> setup <identifiersep> build <identifiersep> action <identifiersep> executer . class ) , styled <identifiersep> text <identifiersep> output <identifiersep> factory , action . get <identifiersep> start <identifiersep> parameter ( ) , request <identifiersep> context , build <identifiersep> started <identifiersep> time , clock ) ; build <identifiersep> logger . build <identifiersep> finished ( new build <identifiersep> result ( null , failure ) ) ; throw new reported <identifiersep> exception ( failure ) ; } } } <ect>
old <identifiersep> value . remove <identifiersep> info ( address ) ; return old <identifiersep> value ; } } ) ; } finally { lock . unlock ( ) ; } } public void mark <identifiersep> state ( final address address , final state state ) { <LOG> lock . lock ( ) ; try { cache . update ( new persistent <identifiersep> state <identifiersep> cache . update <identifiersep> action < daemon <identifiersep> registry <identifiersep> content > ( ) { public daemon <identifiersep> registry <identifiersep> content update ( daemon <identifiersep> registry <identifiersep> content old <identifiersep> value ) { daemon <identifiersep> info daemon <identifiersep> info = old <identifiersep> value != null ? old <identifiersep> value . get <identifiersep> info ( address ) : null ; if ( daemon <identifiersep> info != null ) { <ect>
return content ; } } ) ; } finally { lock . unlock ( ) ; } } @ override public list < daemon <identifiersep> stop <identifiersep> event > get <identifiersep> stop <identifiersep> events ( ) { <LOG> lock . lock ( ) ; try { daemon <identifiersep> registry <identifiersep> content content = cache . get ( ) ; if ( content == null ) { <comment> <ect>
lock . unlock ( ) ; } } public void store ( final daemon <identifiersep> info info ) { final address address = info . get <identifiersep> address ( ) ; final daemon <identifiersep> context daemon <identifiersep> context = info . get <identifiersep> context ( ) ; final byte [ ] token = info . get <identifiersep> token ( ) ; final state state = info . get <identifiersep> state ( ) ; <LOG> lock . lock ( ) ; try { cache . update ( new persistent <identifiersep> state <identifiersep> cache . update <identifiersep> action < daemon <identifiersep> registry <identifiersep> content > ( ) { public daemon <identifiersep> registry <identifiersep> content update ( daemon <identifiersep> registry <identifiersep> content old <identifiersep> value ) { if ( old <identifiersep> value == null ) { <comment> <ect>
daemon <identifiersep> expiration <identifiersep> strategy expiration <identifiersep> strategy = daemon <identifiersep> services . get ( master <identifiersep> expiration <identifiersep> strategy . class ) ; daemon . stop <identifiersep> on <identifiersep> expiration ( expiration <identifiersep> strategy , parameters . get <identifiersep> periodic <identifiersep> check <identifiersep> interval <identifiersep> ms ( ) ) ; } finally { daemon . stop ( ) ; <comment> <LOG> private static void invalid <identifiersep> args ( string message ) { system . out . println ( message ) ; system . exit ( 1 ) ; } protected void daemon <identifiersep> started ( long pid , string uid , address address , file daemon <identifiersep> log ) { <comment> <ect>
private input <identifiersep> stream process <identifiersep> std <identifiersep> output ; @ override public void connect <identifiersep> streams ( process process , string process <identifiersep> name , executor executor ) { process <identifiersep> std <identifiersep> output = process . get <identifiersep> input <identifiersep> stream ( ) ; } public void start ( ) { if ( process <identifiersep> std <identifiersep> output == null ) { <LOG> throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <comment> <ect>
return daemon <identifiersep> registry ; } public daemon <identifiersep> client <identifiersep> connection maybe <identifiersep> connect ( explaining <identifiersep> spec < daemon <identifiersep> context > constraint ) { return find <identifiersep> connection ( get <identifiersep> compatible <identifiersep> daemons ( daemon <identifiersep> registry . get <identifiersep> all ( ) , constraint ) ) ; } public daemon <identifiersep> client <identifiersep> connection maybe <identifiersep> connect ( daemon <identifiersep> connect <identifiersep> details daemon ) { try { return connect <identifiersep> to <identifiersep> daemon ( daemon , new cleanup <identifiersep> on <identifiersep> stale <identifiersep> address ( daemon , true ) ) ; <LOG> } catch ( connect <identifiersep> exception e ) { } return null ; } public daemon <identifiersep> client <identifiersep> connection connect ( explaining <identifiersep> spec < daemon <identifiersep> context > constraint ) { final pair < collection < daemon <identifiersep> info > , collection < daemon <identifiersep> info > > idle <identifiersep> busy = partition <identifiersep> by <identifiersep> state ( daemon <identifiersep> registry . get <identifiersep> all ( ) , idle ) ; final collection < daemon <identifiersep> info > idle <identifiersep> daemons = idle <identifiersep> busy . get <identifiersep> left ( ) ; final collection < daemon <identifiersep> info > busy <identifiersep> daemons = idle <identifiersep> busy . get <identifiersep> right ( ) ; <ect>
for ( int i = 1 ; i < sane <identifiersep> number <identifiersep> of <identifiersep> attempts ; i ++ ) { final daemon <identifiersep> client <identifiersep> connection connection = connector . connect ( compatibility <identifiersep> spec ) ; try { build build = new build ( build <identifiersep> id , connection . get <identifiersep> daemon ( ) . get <identifiersep> token ( ) , action , request <identifiersep> context . get <identifiersep> client ( ) , request <identifiersep> context . get <identifiersep> start <identifiersep> time ( ) , parameters ) ; return execute <identifiersep> build ( build , connection , request <identifiersep> context . get <identifiersep> cancellation <identifiersep> token ( ) , request <identifiersep> context . get <identifiersep> event <identifiersep> consumer ( ) ) ; } catch ( daemon <identifiersep> initial <identifiersep> connect <identifiersep> exception e ) { <LOG> <comment> <ect>
protected object execute <identifiersep> build ( build build , daemon <identifiersep> client <identifiersep> connection connection , build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token , build <identifiersep> event <identifiersep> consumer build <identifiersep> event <identifiersep> consumer ) throws daemon <identifiersep> initial <identifiersep> connect <identifiersep> exception { object result ; try { logger . debug ( <string_literal> , connection . get <identifiersep> daemon ( ) , build ) ; connection . dispatch ( build ) ; result = connection . receive ( ) ; <LOG> } catch ( stale <identifiersep> daemon <identifiersep> address <identifiersep> exception e ) { <comment> <ect>
if ( result == null ) { throw new daemon <identifiersep> initial <identifiersep> connect <identifiersep> exception ( <string_literal> ) ; } logger . debug ( <string_literal> , result , connection . get <identifiersep> daemon ( ) ) ; daemon <identifiersep> diagnostics diagnostics = null ; if ( result instanceof build <identifiersep> started ) { diagnostics = ( ( build <identifiersep> started ) result ) . get <identifiersep> diagnostics ( ) ; <LOG> result = monitor <identifiersep> build ( build , diagnostics , connection , cancellation <identifiersep> token , build <identifiersep> event <identifiersep> consumer ) ; } connection . dispatch ( new finished ( ) ) ; if ( result instanceof failure ) { throwable failure = ( ( failure ) result ) . get <identifiersep> value ( ) ; if ( failure instanceof daemon <identifiersep> stopped <identifiersep> exception && cancellation <identifiersep> token . is <identifiersep> cancellation <identifiersep> requested ( ) ) { logger . error ( <string_literal> ) ; <ect>
daemon <identifiersep> cancel <identifiersep> forwarder cancel <identifiersep> forwarder = new daemon <identifiersep> cancel <identifiersep> forwarder ( connection , cancellation <identifiersep> token ) ; try { cancel <identifiersep> forwarder . start ( ) ; input <identifiersep> forwarder . start ( ) ; int objects <identifiersep> received = 0 ; while ( true ) { <LOG> message object = connection . receive ( ) ; if ( object == null ) { return handle <identifiersep> daemon <identifiersep> disappearance ( build , diagnostics ) ; } else if ( object instanceof output <identifiersep> message ) { output <identifiersep> event <identifiersep> listener . on <identifiersep> output ( ( ( output <identifiersep> message ) object ) . get <identifiersep> event ( ) ) ; } else if ( object instanceof build <identifiersep> event ) { <ect>
if ( result instanceof failure ) { failure = ( ( failure ) result ) . get <identifiersep> value ( ) ; } connection . dispatch ( new finished ( ) ) ; } catch ( throwable e ) { failure = e ; } if ( failure != null ) { <LOG> logger . lifecycle ( daemon <identifiersep> messages . unable <identifiersep> to <identifiersep> stop <identifiersep> daemon ) ; } return failure == null ; } } <ect>
<comment> public void graceful <identifiersep> stop ( collection < daemon <identifiersep> connect <identifiersep> details > daemons ) { for ( daemon <identifiersep> connect <identifiersep> details daemon : daemons ) { daemon <identifiersep> client <identifiersep> connection connection = connector . maybe <identifiersep> connect ( daemon ) ; if ( connection == null ) { continue ; } <LOG> try { stop <identifiersep> dispatcher . dispatch ( connection , new stop <identifiersep> when <identifiersep> idle ( id <identifiersep> generator . generate <identifiersep> id ( ) , connection . get <identifiersep> daemon ( ) . get <identifiersep> token ( ) ) ) ; logger . lifecycle ( <string_literal> ) ; } finally { connection . stop ( ) ; } } } <comment> <ect>
daemon <identifiersep> args . add ( daemon <identifiersep> parameters . get <identifiersep> effective <identifiersep> jvm ( ) . get <identifiersep> java <identifiersep> executable ( ) . get <identifiersep> absolute <identifiersep> path ( ) ) ; list < string > daemon <identifiersep> opts = daemon <identifiersep> parameters . get <identifiersep> effective <identifiersep> jvm <identifiersep> args ( ) ; daemon <identifiersep> args . add <identifiersep> all ( daemon <identifiersep> opts ) ; daemon <identifiersep> args . add ( <string_literal> ) ; daemon <identifiersep> args . add ( collection <identifiersep> utils . join ( file . path <identifiersep> separator , classpath . get <identifiersep> as <identifiersep> files ( ) ) ) ; if ( boolean . get <identifiersep> boolean ( <string_literal> ) ) { <LOG> daemon <identifiersep> args . add ( <string_literal> ) ; } daemon <identifiersep> args . add ( gradle <identifiersep> daemon . class . get <identifiersep> name ( ) ) ; <comment> <ect>
g <identifiersep> file <identifiersep> utils . mkdirs ( working <identifiersep> dir ) ; daemon <identifiersep> output <identifiersep> consumer output <identifiersep> consumer = new daemon <identifiersep> output <identifiersep> consumer ( ) ; <comment> <LOG> handle . start ( ) ; handle . wait <identifiersep> for <identifiersep> finish ( ) ; logger . debug ( <string_literal> ) ; } finally { exec <identifiersep> action <identifiersep> factory . stop ( ) ; } return daemon <identifiersep> greeter . parse <identifiersep> daemon <identifiersep> output ( output <identifiersep> consumer . get <identifiersep> process <identifiersep> output ( ) ) ; <ect>
exec <identifiersep> action <identifiersep> factory . stop ( ) ; } return daemon <identifiersep> greeter . parse <identifiersep> daemon <identifiersep> output ( output <identifiersep> consumer . get <identifiersep> process <identifiersep> output ( ) ) ; } catch ( gradle <identifiersep> exception e ) { throw e ; } catch ( exception e ) { throw new gradle <identifiersep> exception ( <string_literal> , e ) ; <LOG> } finally { } } } <ect>
dispatch <identifiersep> lock . lock ( ) ; try { connection . dispatch ( message ) ; connection . flush ( ) ; } finally { dispatch <identifiersep> lock . unlock ( ) ; } <LOG> } catch ( message <identifiersep> io <identifiersep> exception e ) { if ( ! has <identifiersep> received && stale <identifiersep> address <identifiersep> detector . maybe <identifiersep> stale <identifiersep> address ( e ) ) { throw new stale <identifiersep> daemon <identifiersep> address <identifiersep> exception ( <string_literal> , e ) ; } throw new daemon <identifiersep> connection <identifiersep> exception ( <string_literal> , e ) ; } } @ nullable public message receive ( ) throws daemon <identifiersep> connection <identifiersep> exception { <ect>
log . debug ( <string_literal> ) ; if ( ! has <identifiersep> received && stale <identifiersep> address <identifiersep> detector . maybe <identifiersep> stale <identifiersep> address ( e ) ) { throw new stale <identifiersep> daemon <identifiersep> address <identifiersep> exception ( <string_literal> , e ) ; } throw new daemon <identifiersep> connection <identifiersep> exception ( <string_literal> , e ) ; } finally { has <identifiersep> received = true ; } } <LOG> public void stop ( ) { connection . stop ( ) ; } interface stale <identifiersep> address <identifiersep> detector { <comment> <ect>
return math . min ( max <identifiersep> value , math . max ( min <identifiersep> value , threshold <identifiersep> in ) ) ; } public daemon <identifiersep> expiration <identifiersep> result check <identifiersep> expiration ( ) { lock . lock ( ) ; try { if ( memory <identifiersep> status != null ) { long free <identifiersep> mem = memory <identifiersep> status . get <identifiersep> free <identifiersep> physical <identifiersep> memory ( ) ; <LOG> if ( free <identifiersep> mem < memory <identifiersep> threshold <identifiersep> in <identifiersep> bytes ) { return new daemon <identifiersep> expiration <identifiersep> result ( graceful <identifiersep> expire , expiration <identifiersep> reason ) ; } } } finally { lock . unlock ( ) ; } return daemon <identifiersep> expiration <identifiersep> result . not <identifiersep> triggered ; } @ override <ect>
private static final logger log = logging . get <identifiersep> logger ( low <identifiersep> perm <identifiersep> gen <identifiersep> daemon <identifiersep> expiration <identifiersep> strategy . class ) ; public static final string expiration <identifiersep> reason = <string_literal> ; public low <identifiersep> perm <identifiersep> gen <identifiersep> daemon <identifiersep> expiration <identifiersep> strategy ( daemon <identifiersep> memory <identifiersep> status status ) { this . status = status ; } @ override public daemon <identifiersep> expiration <identifiersep> result check <identifiersep> expiration ( ) { <LOG> if ( status . is <identifiersep> perm <identifiersep> gen <identifiersep> space <identifiersep> exhausted ( ) ) { return new daemon <identifiersep> expiration <identifiersep> result ( graceful <identifiersep> expire , expiration <identifiersep> reason ) ; } else { return daemon <identifiersep> expiration <identifiersep> result . not <identifiersep> triggered ; } } } <ect>
private boolean exceeds <identifiersep> threshold ( string pool , garbage <identifiersep> collection <identifiersep> stats gc <identifiersep> stats , spec < garbage <identifiersep> collection <identifiersep> stats > spec ) { if ( is <identifiersep> enabled ( ) && strategy != garbage <identifiersep> collector <identifiersep> monitoring <identifiersep> strategy . unknown && spec . is <identifiersep> satisfied <identifiersep> by ( gc <identifiersep> stats ) ) { if ( gc <identifiersep> stats . get <identifiersep> usage ( ) > 0 ) { logger . debug ( string . format ( <string_literal> , gc <identifiersep> stats . get <identifiersep> rate ( ) , pool , gc <identifiersep> stats . get <identifiersep> usage ( ) ) ) ; <LOG> } else { } return true ; } return false ; } private boolean is <identifiersep> enabled ( ) { string enabled <identifiersep> value = system . get <identifiersep> property ( enable <identifiersep> performance <identifiersep> monitoring , <string_literal> ) ; return boolean . parse <identifiersep> boolean ( enabled <identifiersep> value ) ; <ect>
private final byte [ ] token ; private address connector <identifiersep> address ; public daemon <identifiersep> registry <identifiersep> updater ( daemon <identifiersep> registry daemon <identifiersep> registry , daemon <identifiersep> context daemon <identifiersep> context , byte [ ] token ) { this . daemon <identifiersep> registry = daemon <identifiersep> registry ; this . daemon <identifiersep> context = daemon <identifiersep> context ; this . token = token ; } <LOG> public void on <identifiersep> start <identifiersep> activity ( ) { try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , busy ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } public void on <identifiersep> complete <identifiersep> activity ( ) { <ect>
public void on <identifiersep> start <identifiersep> activity ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , busy ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } <LOG> public void on <identifiersep> complete <identifiersep> activity ( ) { try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , idle ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } public void on <identifiersep> cancel ( ) { <ect>
public void on <identifiersep> complete <identifiersep> activity ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , idle ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } <LOG> public void on <identifiersep> cancel ( ) { try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , canceled ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } public void on <identifiersep> start ( address connector <identifiersep> address ) { <ect>
} finally { daemon <identifiersep> connection . stop ( ) ; } } finally { connection . stop ( ) ; } } private command receive <identifiersep> command ( daemon <identifiersep> connection daemon <identifiersep> connection ) { try { <LOG> command command = ( command ) daemon <identifiersep> connection . receive ( <number_literal> , time <identifiersep> unit . seconds ) ; return command ; } catch ( throwable e ) { logger . warn ( string . format ( <string_literal> , connection ) , e ) ; return null ; } } private void handle <identifiersep> command ( command command , daemon <identifiersep> connection daemon <identifiersep> connection ) { <ect>
command command = ( command ) daemon <identifiersep> connection . receive ( <number_literal> , time <identifiersep> unit . seconds ) ; logger . info ( <string_literal> , command ) ; return command ; } catch ( throwable e ) { logger . warn ( string . format ( <string_literal> , connection ) , e ) ; return null ; } } <LOG> private void handle <identifiersep> command ( command command , daemon <identifiersep> connection daemon <identifiersep> connection ) { try { if ( ! arrays . equals ( command . get <identifiersep> token ( ) , token ) ) { throw new badly <identifiersep> formed <identifiersep> request <identifiersep> exception ( string . format ( <string_literal> , command , connection ) ) ; } command <identifiersep> executer . execute <identifiersep> command ( daemon <identifiersep> connection , command , daemon <identifiersep> context , daemon <identifiersep> state <identifiersep> control ) ; } catch ( throwable e ) { <ect>
if ( ! arrays . equals ( command . get <identifiersep> token ( ) , token ) ) { throw new badly <identifiersep> formed <identifiersep> request <identifiersep> exception ( string . format ( <string_literal> , command , connection ) ) ; } command <identifiersep> executer . execute <identifiersep> command ( daemon <identifiersep> connection , command , daemon <identifiersep> context , daemon <identifiersep> state <identifiersep> control ) ; } catch ( throwable e ) { logger . warn ( string . format ( <string_literal> , command , connection ) , e ) ; daemon <identifiersep> connection . completed ( new failure ( e ) ) ; <LOG> } finally { } object finished = daemon <identifiersep> connection . receive ( <number_literal> , time <identifiersep> unit . seconds ) ; logger . debug ( <string_literal> , finished ) ; } } } <ect>
return this . daemon <identifiersep> registry ; } <comment> <LOG> public void start ( ) { lifecycle <identifiersep> lock . lock ( ) ; try { if ( state <identifiersep> coordinator != null ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <comment> <ect>
connection <identifiersep> handler = new default <identifiersep> incoming <identifiersep> connection <identifiersep> handler ( command <identifiersep> executer , daemon <identifiersep> context , state <identifiersep> coordinator , executor <identifiersep> factory , token ) ; runnable connection <identifiersep> error <identifiersep> handler = new runnable ( ) { @ override public void run ( ) { state <identifiersep> coordinator . stop ( ) ; } } ; <LOG> connector <identifiersep> address = connector . start ( connection <identifiersep> handler , connection <identifiersep> error <identifiersep> handler ) ; registry <identifiersep> updater . on <identifiersep> start ( connector <identifiersep> address ) ; } finally { lifecycle <identifiersep> lock . unlock ( ) ; } logger . lifecycle ( daemon <identifiersep> messages . process <identifiersep> started ) ; } <comment> <ect>
<comment> <LOG> public void stop <identifiersep> on <identifiersep> expiration ( daemon <identifiersep> expiration <identifiersep> strategy expiration <identifiersep> strategy , int check <identifiersep> interval <identifiersep> mills ) { schedule <identifiersep> expiration <identifiersep> checks ( expiration <identifiersep> strategy , check <identifiersep> interval <identifiersep> mills ) ; await <identifiersep> expiration ( ) ; } private void schedule <identifiersep> expiration <identifiersep> checks ( daemon <identifiersep> expiration <identifiersep> strategy expiration <identifiersep> strategy , int check <identifiersep> interval <identifiersep> mills ) { daemon <identifiersep> expiration <identifiersep> periodic <identifiersep> check periodic <identifiersep> check = new daemon <identifiersep> expiration <identifiersep> periodic <identifiersep> check ( expiration <identifiersep> strategy , listener <identifiersep> manager ) ; listener <identifiersep> manager . add <identifiersep> listener ( new default <identifiersep> daemon <identifiersep> expiration <identifiersep> listener ( state <identifiersep> coordinator , registry <identifiersep> updater ) ) ; <ect>
daemon <identifiersep> expiration <identifiersep> periodic <identifiersep> check ( daemon <identifiersep> expiration <identifiersep> strategy expiration <identifiersep> strategy , listener <identifiersep> manager listener <identifiersep> manager ) { this . expiration <identifiersep> strategy = expiration <identifiersep> strategy ; this . listener <identifiersep> broadcast = listener <identifiersep> manager . get <identifiersep> broadcaster ( daemon <identifiersep> expiration <identifiersep> listener . class ) ; } @ override public void run ( ) { if ( lock . try <identifiersep> lock ( ) ) { <LOG> try { final daemon <identifiersep> expiration <identifiersep> result result = expiration <identifiersep> strategy . check <identifiersep> expiration ( ) ; if ( result . get <identifiersep> status ( ) != do <identifiersep> not <identifiersep> expire ) { listener <identifiersep> broadcast . on <identifiersep> expiration <identifiersep> event ( result ) ; } } catch ( throwable t ) { logger . error ( <string_literal> , t ) ; <ect>
logger . error ( <string_literal> , t ) ; if ( t instanceof error ) { <comment> <LOG> } else { } } } private static class default <identifiersep> daemon <identifiersep> expiration <identifiersep> listener implements daemon <identifiersep> expiration <identifiersep> listener { private final daemon <identifiersep> state <identifiersep> control state <identifiersep> control ; private final daemon <identifiersep> registry <identifiersep> updater registry <identifiersep> updater ; public default <identifiersep> daemon <identifiersep> expiration <identifiersep> listener ( daemon <identifiersep> state <identifiersep> control state <identifiersep> control , daemon <identifiersep> registry <identifiersep> updater registry <identifiersep> updater ) { this . state <identifiersep> control = state <identifiersep> control ; <ect>
switch ( state ) { case idle : case busy : logger . debug ( <string_literal> ) ; condition . await ( ) ; break ; <LOG> case canceled : cancel <identifiersep> now ( ) ; break ; case broken : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; case stop <identifiersep> requested : <ect>
case broken : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; case stop <identifiersep> requested : logger . debug ( <string_literal> ) ; condition . await ( ) ; break ; <LOG> case stopped : return true ; } } catch ( interrupted <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } } finally { lock . unlock ( ) ; <ect>
try { switch ( state ) { case idle : case busy : case canceled : case broken : <LOG> case stop <identifiersep> requested : stop <identifiersep> reason = reason ; set <identifiersep> state ( state . stopped ) ; break ; case stopped : break ; <ect>
lock . unlock ( ) ; } } private void cancel <identifiersep> now ( ) { countdown <identifiersep> timer timer = time . start <identifiersep> countdown <identifiersep> timer ( cancel <identifiersep> timeout <identifiersep> ms ) ; logger . debug ( <string_literal> ) ; try { cancellation <identifiersep> token . cancel ( ) ; <LOG> } catch ( exception ex ) { } lock . lock ( ) ; try { while ( ! timer . has <identifiersep> expired ( ) ) { try { switch ( state ) { <ect>
switch ( state ) { case idle : logger . debug ( <string_literal> ) ; return ; case busy : case canceled : <LOG> case stop <identifiersep> requested : condition . await ( timer . get <identifiersep> remaining <identifiersep> millis ( ) , time <identifiersep> unit . milliseconds ) ; break ; case broken : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; case stopped : <ect>
case broken : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; case stopped : logger . debug ( <string_literal> ) ; return ; } } catch ( interrupted <identifiersep> exception e ) { <LOG> throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } stop <identifiersep> now ( <string_literal> ) ; } finally { lock . unlock ( ) ; } } @ override public void run <identifiersep> command ( final runnable command , string command <identifiersep> display <identifiersep> name ) throws daemon <identifiersep> unavailable <identifiersep> exception { <ect>
case stop <identifiersep> requested : throw new daemon <identifiersep> unavailable <identifiersep> exception ( <string_literal> ) ; case stopped : throw new daemon <identifiersep> unavailable <identifiersep> exception ( <string_literal> ) ; case busy : case canceled : <LOG> throw new daemon <identifiersep> unavailable <identifiersep> exception ( string . format ( <string_literal> , current <identifiersep> command <identifiersep> execution ) ) ; } try { set <identifiersep> state ( state . busy ) ; on <identifiersep> start <identifiersep> command . run ( ) ; current <identifiersep> command <identifiersep> execution = command <identifiersep> display <identifiersep> name ; result = null ; <ect>
case stopped : break ; default : throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + state ) ; } } finally { lock . unlock ( ) ; } } <LOG> private void update <identifiersep> activity <identifiersep> timestamp ( ) { idle <identifiersep> timer . reset ( ) ; } private double get <identifiersep> idle <identifiersep> minutes ( ) { lock . lock ( ) ; try { return idle <identifiersep> timer . get <identifiersep> elapsed <identifiersep> millis ( ) / <number_literal> / <number_literal> ; <ect>
message = connection . receive ( ) ; } catch ( exception e ) { logger . debug ( string . format ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) ) , e ) ; } failure = e ; return ; } <LOG> if ( message == null ) { return ; } if ( message instanceof input <identifiersep> message ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; stdin <identifiersep> queue . add ( ( input <identifiersep> message ) message ) ; } else if ( message instanceof cancel ) { <ect>
list < long > all <identifiersep> daemon <identifiersep> pids = lists . transform ( daemon . get <identifiersep> daemon <identifiersep> registry ( ) . get <identifiersep> all ( ) , new function < daemon <identifiersep> info , long > ( ) { public long apply ( daemon <identifiersep> info info ) { return info . get <identifiersep> pid ( ) ; } } ) ; if ( ! all <identifiersep> daemon <identifiersep> pids . contains ( daemon <identifiersep> context . get <identifiersep> pid ( ) ) ) { return new daemon <identifiersep> expiration <identifiersep> result ( graceful <identifiersep> expire , registry <identifiersep> entry <identifiersep> unexpectedly <identifiersep> lost ) ; } } <LOG> } catch ( security <identifiersep> exception se ) { return new daemon <identifiersep> expiration <identifiersep> result ( graceful <identifiersep> expire , registry <identifiersep> became <identifiersep> inaccessible ) ; } return daemon <identifiersep> expiration <identifiersep> result . not <identifiersep> triggered ; } } <ect>
import org . gradle . api . logging . logging ; import org . gradle . launcher . daemon . server . api . daemon <identifiersep> command <identifiersep> action ; import org . gradle . launcher . daemon . server . api . daemon <identifiersep> command <identifiersep> execution ; public class request <identifiersep> stop <identifiersep> if <identifiersep> single <identifiersep> used <identifiersep> daemon implements daemon <identifiersep> command <identifiersep> action { private static final logger logger = logging . get <identifiersep> logger ( request <identifiersep> stop <identifiersep> if <identifiersep> single <identifiersep> used <identifiersep> daemon . class ) ; public void execute ( daemon <identifiersep> command <identifiersep> execution execution ) { <LOG> if ( execution . is <identifiersep> single <identifiersep> use <identifiersep> daemon ( ) ) { <comment> <ect>
execution . proceed ( ) ; result result ; throwable command <identifiersep> exception = execution . get <identifiersep> exception ( ) ; if ( command <identifiersep> exception != null ) { result = new failure ( command <identifiersep> exception ) ; } else { <LOG> result = new success ( execution . get <identifiersep> result ( ) ) ; } execution . get <identifiersep> connection ( ) . completed ( result ) ; } } <ect>
throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } execution . get <identifiersep> connection ( ) . on <identifiersep> stdin ( new stdin <identifiersep> handler ( ) { public void on <identifiersep> input ( forward <identifiersep> input input ) { logger . debug ( <string_literal> ) ; try { input <identifiersep> source . write ( input . get <identifiersep> bytes ( ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } public void on <identifiersep> end <identifiersep> of <identifiersep> input ( ) { logger . info ( <string_literal> ) ; try { input <identifiersep> source . close ( ) ; } catch ( io <identifiersep> exception e ) { <ect>
} catch ( io <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } public void on <identifiersep> end <identifiersep> of <identifiersep> input ( ) { logger . info ( <string_literal> ) ; try { input <identifiersep> source . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } finally { logger . info ( <string_literal> ) ; } } } ) ; try { try { <ect>
public class watch <identifiersep> for <identifiersep> disconnection implements daemon <identifiersep> command <identifiersep> action { private static final logger logger = logging . get <identifiersep> logger ( watch <identifiersep> for <identifiersep> disconnection . class ) ; public static final string expiration <identifiersep> reason = <string_literal> ; public void execute ( final daemon <identifiersep> command <identifiersep> execution execution ) { <comment> <LOG> public void run ( ) { execution . get <identifiersep> daemon <identifiersep> state <identifiersep> control ( ) . request <identifiersep> cancel ( ) ; } } ) ; try { execution . proceed ( ) ; } finally { <ect>
public start <identifiersep> build <identifiersep> or <identifiersep> respond <identifiersep> with <identifiersep> busy ( daemon <identifiersep> diagnostics diagnostics ) { this . diagnostics = diagnostics ; } protected void do <identifiersep> build ( final daemon <identifiersep> command <identifiersep> execution execution , final build build ) { daemon <identifiersep> state <identifiersep> control state <identifiersep> coordinator = execution . get <identifiersep> daemon <identifiersep> state <identifiersep> control ( ) ; try { runnable command = new runnable ( ) { <LOG> public void run ( ) { execution . get <identifiersep> connection ( ) . build <identifiersep> started ( new build <identifiersep> started ( diagnostics ) ) ; execution . proceed ( ) ; } } ; state <identifiersep> coordinator . run <identifiersep> command ( command , execution . to <identifiersep> string ( ) ) ; } catch ( daemon <identifiersep> unavailable <identifiersep> exception e ) { <ect>
final private service <identifiersep> registry context <identifiersep> services ; public execute <identifiersep> build ( build <identifiersep> action <identifiersep> executer < build <identifiersep> action <identifiersep> parameters > action <identifiersep> executer , daemon <identifiersep> running <identifiersep> stats running <identifiersep> stats , service <identifiersep> registry context <identifiersep> services ) { this . action <identifiersep> executer = action <identifiersep> executer ; this . running <identifiersep> stats = running <identifiersep> stats ; this . context <identifiersep> services = context <identifiersep> services ; } protected void do <identifiersep> build ( final daemon <identifiersep> command <identifiersep> execution execution , build build ) { <LOG> logger . debug ( daemon <identifiersep> messages . started <identifiersep> build ) ; running <identifiersep> stats . build <identifiersep> started ( ) ; try { build <identifiersep> cancellation <identifiersep> token cancellation <identifiersep> token = execution . get <identifiersep> daemon <identifiersep> state <identifiersep> control ( ) . get <identifiersep> cancellation <identifiersep> token ( ) ; build <identifiersep> request <identifiersep> context build <identifiersep> request <identifiersep> context = new default <identifiersep> build <identifiersep> request <identifiersep> context ( build . get <identifiersep> build <identifiersep> request <identifiersep> meta <identifiersep> data ( ) , cancellation <identifiersep> token , new daemon <identifiersep> connection <identifiersep> backed <identifiersep> event <identifiersep> consumer ( execution ) ) ; if ( ! build . get <identifiersep> parameters ( ) . is <identifiersep> continuous ( ) ) { <ect>
public void flush ( ) throws message <identifiersep> io <identifiersep> exception { synchronized ( lock ) { delegate . flush ( ) ; } } public t receive ( ) { <comment> <LOG> t result = delegate . receive ( ) ; return result ; } public void stop ( ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) ) ; delegate . stop ( ) ; } public string to <identifiersep> string ( ) { <ect>
add <identifiersep> provider ( new daemon <identifiersep> registry <identifiersep> services ( configuration . get <identifiersep> base <identifiersep> dir ( ) ) ) ; add <identifiersep> provider ( new global <identifiersep> scope <identifiersep> services ( true , additional <identifiersep> module <identifiersep> class <identifiersep> path ) ) ; } protected daemon <identifiersep> context create <identifiersep> daemon <identifiersep> context ( ) { daemon <identifiersep> context <identifiersep> builder builder = new daemon <identifiersep> context <identifiersep> builder ( get ( process <identifiersep> environment . class ) ) ; builder . set <identifiersep> daemon <identifiersep> registry <identifiersep> dir ( configuration . get <identifiersep> base <identifiersep> dir ( ) ) ; builder . set <identifiersep> idle <identifiersep> timeout ( configuration . get <identifiersep> idle <identifiersep> timeout ( ) ) ; <LOG> builder . set <identifiersep> uid ( configuration . get <identifiersep> uid ( ) ) ; builder . set <identifiersep> daemon <identifiersep> opts ( configuration . get <identifiersep> jvm <identifiersep> options ( ) ) ; return builder . create ( ) ; } public file get <identifiersep> daemon <identifiersep> log <identifiersep> file ( ) { final daemon <identifiersep> context daemon <identifiersep> context = get ( daemon <identifiersep> context . class ) ; final long pid = daemon <identifiersep> context . get <identifiersep> pid ( ) ; <ect>
builder . append ( file ) ; } logger . quiet ( builder . to <identifiersep> string ( ) ) ; } private void log <identifiersep> compiler <identifiersep> arguments ( groovy <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { return ; } list < string > compiler <identifiersep> args = new java <identifiersep> compiler <identifiersep> arguments <identifiersep> builder ( spec ) . include <identifiersep> launcher <identifiersep> options ( true ) . include <identifiersep> source <identifiersep> files ( true ) . build ( ) ; <LOG> string joined <identifiersep> args = joiner . on ( ' ' ) . join ( compiler <identifiersep> args ) ; } private work <identifiersep> result delegate <identifiersep> and <identifiersep> handle <identifiersep> errors ( groovy <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { try { return delegate . execute ( spec ) ; } catch ( runtime <identifiersep> exception e ) { <comment> <ect>
private final directory <identifiersep> file <identifiersep> tree <identifiersep> factory directory <identifiersep> file <identifiersep> tree <identifiersep> factory ; public default <identifiersep> header <identifiersep> dependencies <identifiersep> collector ( directory <identifiersep> file <identifiersep> tree <identifiersep> factory directory <identifiersep> file <identifiersep> tree <identifiersep> factory ) { this . directory <identifiersep> file <identifiersep> tree <identifiersep> factory = directory <identifiersep> file <identifiersep> tree <identifiersep> factory ; } @ override public immutable <identifiersep> sorted <identifiersep> set < file > collect <identifiersep> existing <identifiersep> header <identifiersep> dependencies ( string task <identifiersep> path , list < file > include <identifiersep> roots , incremental <identifiersep> compilation incremental <identifiersep> compilation ) { final set < file > header <identifiersep> dependencies = new hash <identifiersep> set < file > ( ) ; <LOG> if ( incremental <identifiersep> compilation . is <identifiersep> unresolved <identifiersep> headers ( ) ) { add <identifiersep> include <identifiersep> roots ( task <identifiersep> path , include <identifiersep> roots , header <identifiersep> dependencies ) ; } else { logger . info ( <string_literal> , task <identifiersep> path ) ; header <identifiersep> dependencies . add <identifiersep> all ( incremental <identifiersep> compilation . get <identifiersep> existing <identifiersep> headers ( ) ) ; } return immutable <identifiersep> sorted <identifiersep> set . copy <identifiersep> of ( header <identifiersep> dependencies ) ; <ect>
add <identifiersep> include <identifiersep> roots ( task <identifiersep> path , include <identifiersep> roots , header <identifiersep> dependencies ) ; } else { logger . info ( <string_literal> , task <identifiersep> path ) ; header <identifiersep> dependencies . add <identifiersep> all ( incremental <identifiersep> compilation . get <identifiersep> existing <identifiersep> headers ( ) ) ; } return immutable <identifiersep> sorted <identifiersep> set . copy <identifiersep> of ( header <identifiersep> dependencies ) ; } private void add <identifiersep> include <identifiersep> roots ( string task <identifiersep> path , list < file > include <identifiersep> roots , final set < file > header <identifiersep> dependencies ) { <LOG> for ( final file include <identifiersep> root : include <identifiersep> roots ) { directory <identifiersep> file <identifiersep> tree <identifiersep> factory . create ( include <identifiersep> root ) . visit ( new empty <identifiersep> file <identifiersep> visitor ( ) { @ override public void visit <identifiersep> file ( file <identifiersep> visit <identifiersep> details file <identifiersep> details ) { header <identifiersep> dependencies . add ( file <identifiersep> details . get <identifiersep> file ( ) ) ; } } ) ; <ect>
@ override public int get <identifiersep> cols ( ) { final string columns = system . getenv ( <string_literal> ) ; if ( columns != null ) { try { return integer . parse <identifiersep> int ( columns ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception ex ) { } } return 0 ; } @ override public int get <identifiersep> rows ( ) { final string rows = system . getenv ( <string_literal> ) ; if ( rows != null ) { <ect>
link <identifiersep> file = files . create <identifiersep> temp <identifiersep> file ( <string_literal> , <string_literal> ) ; files . delete ( link <identifiersep> file ) ; files . create <identifiersep> symbolic <identifiersep> link ( link <identifiersep> file , source <identifiersep> file ) ; return true ; } catch ( internal <identifiersep> error e ) { if ( e . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <LOG> <comment> <ect>
try { file upper <identifiersep> cased = new file ( file . get <identifiersep> path ( ) . to <identifiersep> upper <identifiersep> case ( ) ) ; return ! has <identifiersep> content ( upper <identifiersep> cased , content ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> boolean result = ! new file ( <string_literal> ) . equals ( new file ( <string_literal> ) ) ; return result ; } } private boolean has <identifiersep> content ( file file , string content ) throws io <identifiersep> exception { return file . exists ( ) && files . read <identifiersep> first <identifiersep> line ( file , charsets . utf <identifiersep> <number_literal> ) . equals ( content ) ; } private void check <identifiersep> java <identifiersep> io <identifiersep> tmp <identifiersep> dir <identifiersep> exists ( ) throws io <identifiersep> exception { file dir = new file ( system . get <identifiersep> property ( <string_literal> ) ) ; <ect>
return java <identifiersep> reflection <identifiersep> util . new <identifiersep> instance <identifiersep> or <identifiersep> fallback ( <string_literal> , file <identifiersep> system <identifiersep> services . class . get <identifiersep> class <identifiersep> loader ( ) , fallback <identifiersep> file <identifiersep> canonicalizer . class ) ; } @ suppress <identifiersep> warnings ( <string_literal> ) public file <identifiersep> system create <identifiersep> file <identifiersep> system ( operating <identifiersep> system operating <identifiersep> system , posix <identifiersep> files posix <identifiersep> files , file <identifiersep> metadata <identifiersep> accessor metadata <identifiersep> accessor ) throws exception { if ( operating <identifiersep> system . is <identifiersep> windows ( ) ) { symlink symlink = java <identifiersep> reflection <identifiersep> util . new <identifiersep> instance <identifiersep> or <identifiersep> fallback ( <string_literal> , file <identifiersep> system <identifiersep> services . class . get <identifiersep> class <identifiersep> loader ( ) , windows <identifiersep> symlink . class ) ; return new generic <identifiersep> file <identifiersep> system ( new empty <identifiersep> chmod ( ) , new fallback <identifiersep> stat ( ) , symlink , metadata <identifiersep> accessor ) ; } <LOG> if ( posix <identifiersep> files instanceof unavailable <identifiersep> posix <identifiersep> files ) { } else { symlink symlink = new native <identifiersep> platform <identifiersep> backed <identifiersep> symlink ( posix <identifiersep> files ) ; file <identifiersep> mode <identifiersep> mutator chmod = new native <identifiersep> platform <identifiersep> backed <identifiersep> chmod ( posix <identifiersep> files ) ; file <identifiersep> mode <identifiersep> accessor stat = new native <identifiersep> platform <identifiersep> backed <identifiersep> stat ( posix <identifiersep> files ) ; return new generic <identifiersep> file <identifiersep> system ( chmod , stat , symlink , metadata <identifiersep> accessor ) ; <ect>
return jvm . current ( ) ; } protected process <identifiersep> environment create <identifiersep> process <identifiersep> environment ( operating <identifiersep> system operating <identifiersep> system ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { net . rubygrapefruit . platform . process process = net . rubygrapefruit . platform . native . get ( process . class ) ; return new native <identifiersep> platform <identifiersep> backed <identifiersep> process <identifiersep> environment ( process ) ; <LOG> } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception ex ) { } } return new unsupported <identifiersep> environment ( ) ; } protected console <identifiersep> detector create <identifiersep> console <identifiersep> detector ( operating <identifiersep> system operating <identifiersep> system ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { terminals terminals = net . rubygrapefruit . platform . native . get ( terminals . class ) ; <ect>
if ( use <identifiersep> native <identifiersep> integrations ) { try { terminals terminals = net . rubygrapefruit . platform . native . get ( terminals . class ) ; return new native <identifiersep> platform <identifiersep> console <identifiersep> detector ( terminals ) ; } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception ex ) { logger . debug ( <string_literal> ) ; <LOG> } catch ( native <identifiersep> exception ex ) { } try { if ( operating <identifiersep> system . is <identifiersep> windows ( ) ) { return new windows <identifiersep> console <identifiersep> detector ( ) ; } } catch ( linkage <identifiersep> error e ) { <comment> <ect>
return net . rubygrapefruit . platform . native . get ( windows <identifiersep> registry . class ) ; } return not <identifiersep> available ( windows <identifiersep> registry . class ) ; } protected system <identifiersep> info create <identifiersep> system <identifiersep> info ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( system <identifiersep> info . class ) ; <LOG> } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception e ) { } } return not <identifiersep> available ( system <identifiersep> info . class ) ; } protected memory create <identifiersep> memory ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( memory . class ) ; <ect>
logger . debug ( <string_literal> ) ; } } return not <identifiersep> available ( memory . class ) ; } protected process <identifiersep> launcher create <identifiersep> process <identifiersep> launcher ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( process <identifiersep> launcher . class ) ; <LOG> } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception e ) { } } return new default <identifiersep> process <identifiersep> launcher ( ) ; } protected posix <identifiersep> files create <identifiersep> posix <identifiersep> files ( ) { if ( use <identifiersep> native <identifiersep> integrations ) { try { return net . rubygrapefruit . platform . native . get ( posix <identifiersep> files . class ) ; <ect>
<comment> <LOG> } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception e ) { } } if ( java <identifiersep> version . current ( ) . is <identifiersep> java7compatible ( ) ) { return java <identifiersep> reflection <identifiersep> util . new <identifiersep> instance <identifiersep> or <identifiersep> fallback ( <string_literal> , native <identifiersep> services . class . get <identifiersep> class <identifiersep> loader ( ) , fallback <identifiersep> file <identifiersep> metadata <identifiersep> accessor . class ) ; } return new fallback <identifiersep> file <identifiersep> metadata <identifiersep> accessor ( ) ; } private < t > t not <identifiersep> available ( class < t > type ) { return ( t ) proxy . new <identifiersep> proxy <identifiersep> instance ( type . get <identifiersep> class <identifiersep> loader ( ) , new class [ ] { type } , new broken <identifiersep> service ( type . get <identifiersep> simple <identifiersep> name ( ) ) ) ; <ect>
return false ; } } private void start ( ) { scheduler . schedule <identifiersep> at <identifiersep> fixed <identifiersep> rate ( new memory <identifiersep> check ( ) , status <identifiersep> interval <identifiersep> seconds , status <identifiersep> interval <identifiersep> seconds , time <identifiersep> unit . seconds ) ; logger . debug ( <string_literal> ) ; if ( os <identifiersep> memory <identifiersep> status <identifiersep> supported ) { add <identifiersep> listener ( os <identifiersep> memory <identifiersep> status <identifiersep> listener ) ; <LOG> } else { } } @ override public void stop ( ) { scheduler . stop ( ) ; listener <identifiersep> manager . remove <identifiersep> listener ( os <identifiersep> memory <identifiersep> status <identifiersep> listener ) ; } @ override <ect>
if ( new <identifiersep> free <identifiersep> memory > free <identifiersep> memory ) { current <identifiersep> os <identifiersep> memory <identifiersep> status = null ; } } else { logger . debug ( <string_literal> ) ; } } } private long do <identifiersep> request <identifiersep> free <identifiersep> memory ( long requested <identifiersep> free <identifiersep> memory , long free <identifiersep> memory ) { long to <identifiersep> release <identifiersep> memory = requested <identifiersep> free <identifiersep> memory ; <LOG> if ( free <identifiersep> memory < requested <identifiersep> free <identifiersep> memory ) { list < memory <identifiersep> holder > memory <identifiersep> holders ; synchronized ( holders <identifiersep> lock ) { memory <identifiersep> holders = new array <identifiersep> list < memory <identifiersep> holder > ( holders ) ; } for ( memory <identifiersep> holder holder : memory <identifiersep> holders ) { long released = holder . attempt <identifiersep> to <identifiersep> release ( to <identifiersep> release <identifiersep> memory ) ; <ect>
return math . max ( min <identifiersep> threshold <identifiersep> bytes , ( long ) ( total <identifiersep> physical <identifiersep> memory * min <identifiersep> free <identifiersep> memory <identifiersep> percentage ) ) ; } private class memory <identifiersep> check implements runnable { @ override public void run ( ) { try { if ( os <identifiersep> memory <identifiersep> status <identifiersep> supported ) { <LOG> os <identifiersep> memory <identifiersep> status os = os <identifiersep> memory <identifiersep> info . get <identifiersep> os <identifiersep> snapshot ( ) ; os <identifiersep> broadcast . on <identifiersep> os <identifiersep> memory <identifiersep> status ( os ) ; } jvm <identifiersep> memory <identifiersep> status jvm = jvm <identifiersep> memory <identifiersep> info . get <identifiersep> jvm <identifiersep> snapshot ( ) ; logger . debug ( <string_literal> , jvm ) ; jvm <identifiersep> broadcast . on <identifiersep> jvm <identifiersep> memory <identifiersep> status ( jvm ) ; } catch ( exception ex ) { <ect>
os <identifiersep> memory <identifiersep> status os = os <identifiersep> memory <identifiersep> info . get <identifiersep> os <identifiersep> snapshot ( ) ; logger . debug ( <string_literal> , os ) ; os <identifiersep> broadcast . on <identifiersep> os <identifiersep> memory <identifiersep> status ( os ) ; } jvm <identifiersep> memory <identifiersep> status jvm = jvm <identifiersep> memory <identifiersep> info . get <identifiersep> jvm <identifiersep> snapshot ( ) ; logger . debug ( <string_literal> , jvm ) ; jvm <identifiersep> broadcast . on <identifiersep> jvm <identifiersep> memory <identifiersep> status ( jvm ) ; <LOG> } catch ( exception ex ) { } } } private class os <identifiersep> memory <identifiersep> listener implements os <identifiersep> memory <identifiersep> status <identifiersep> listener { private final boolean auto <identifiersep> free ; private os <identifiersep> memory <identifiersep> listener ( boolean auto <identifiersep> free ) { this . auto <identifiersep> free = auto <identifiersep> free ; } @ override <ect>
def logger = logging . get <identifiersep> logger ( 'init - script' ) public void build <identifiersep> finished ( build <identifiersep> result result ) { logger . info ( <string_literal> ) println 'init callback quiet out' } public void before <identifiersep> evaluate ( project project ) { logger . lifecycle ( <string_literal> ) } <LOG> public void after <identifiersep> evaluate ( project project , project <identifiersep> state state ) { } public void before <identifiersep> execute ( task task ) { logger . lifecycle ( <string_literal> ) } public void after <identifiersep> execute ( task task , task <identifiersep> state state ) { logger . info ( <string_literal> ) } public void before <identifiersep> actions ( task task ) { <ect>
public void after <identifiersep> evaluate ( project project , project <identifiersep> state state ) { logger . info ( <string_literal> ) } public void before <identifiersep> execute ( task task ) { logger . lifecycle ( <string_literal> ) } public void after <identifiersep> execute ( task task , task <identifiersep> state state ) { logger . info ( <string_literal> ) } <LOG> public void before <identifiersep> actions ( task task ) { } public void after <identifiersep> actions ( task task ) { logger . info ( <string_literal> ) } <ect>
def task <identifiersep> output = get <identifiersep> task <identifiersep> output ( result ) matches <identifiersep> task <identifiersep> output ( task <identifiersep> output , test <identifiersep> log <identifiersep> event <identifiersep> regex ( test <identifiersep> log <identifiersep> event . started . console <identifiersep> marker ) ) } def <string_literal> ( ) { given : build <identifiersep> file < < test <identifiersep> logging <identifiersep> standard <identifiersep> stream ( ) file ( java <identifiersep> test <identifiersep> file <identifiersep> path ) < < java <identifiersep> test <identifiersep> class { <LOG> <string_literal> <string_literal> standard error <string_literal> <string_literal> } when : executer . with <identifiersep> console ( console <identifiersep> type ) succeeds ( test <identifiersep> task <identifiersep> name ) <ect>
standard error <string_literal> <string_literal> can group multiple test log events with task <string_literal> <LOG> <string_literal> <string_literal> expected <string_literal> <string_literal> } when : executer . with <identifiersep> console ( console <identifiersep> type ) fails ( test <identifiersep> task <identifiersep> name ) <ect>
def <string_literal> ( ) { given : build <identifiersep> file < < <string_literal> <string_literal> <LOG> system . out . println ( <string_literal> ) } } <string_literal> <string_literal> standard out \\ n <identifiersep> standard err <string_literal> <ect>
public class deprecated <identifiersep> task extends default <identifiersep> task { @ task <identifiersep> action void cause <identifiersep> deprecation <identifiersep> warning ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> replaced <identifiersep> task ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> ) ; } public static void some <identifiersep> feature ( ) { <LOG> deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> discontinued <identifiersep> method ( <string_literal> ) ; } void other <identifiersep> feature ( ) { deprecation <identifiersep> logger . nag <identifiersep> user <identifiersep> of <identifiersep> discontinued <identifiersep> method ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <string_literal> <ect>
converter instanceof logging <identifiersep> command <identifiersep> line <identifiersep> converter } def resets <identifiersep> slf4j <identifiersep> when <identifiersep> started ( ) { given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> command <identifiersep> line <identifiersep> process <identifiersep> logging ( ) def logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) when : <LOG> def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) then : output <identifiersep> event <identifiersep> listener . to <identifiersep> string ( ) == ' [ [ warn ] [ category ] before ] ' when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . info logging <identifiersep> manager . start ( ) <ect>
logger . warn ( <string_literal> ) then : output <identifiersep> event <identifiersep> listener . to <identifiersep> string ( ) == ' [ [ warn ] [ category ] before ] ' when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . info logging <identifiersep> manager . start ( ) <LOG> logger . info ( <string_literal> ) then : output <identifiersep> event <identifiersep> listener . to <identifiersep> string ( ) == ' [ [ warn ] [ category ] before ] ' } def consumes <identifiersep> slf4j <identifiersep> when <identifiersep> started ( ) { standard <identifiersep> output <identifiersep> listener listener = mock ( ) given : <ect>
logger . warning ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : <LOG> logging <identifiersep> manager . stop ( ) then : 0 * listener .  <identifiersep>  } def configures <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> and <identifiersep> restores <identifiersep> settings <identifiersep> when <identifiersep> stopped ( ) { given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> command <identifiersep> line <identifiersep> process <identifiersep> logging ( ) <ect>
logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . start ( ) then : system . out != outputs . std <identifiersep> out <identifiersep> print <identifiersep> stream system . err != outputs . std <identifiersep> err <identifiersep> print <identifiersep> stream when : <LOG> system . out . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) <ect>
logging <identifiersep> manager . start ( ) when : def nested <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) nested <identifiersep> manager . capture <identifiersep> standard <identifiersep> error ( log <identifiersep> level . info ) nested <identifiersep> manager . capture <identifiersep> standard <identifiersep> output ( log <identifiersep> level . debug ) nested <identifiersep> manager . start ( ) <LOG> system . out . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : <ect>
then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : nested <identifiersep> manager . stop ( ) <LOG> system . out . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) <ect>
0 * listener .  <identifiersep>  } def routes <identifiersep> logging <identifiersep> output <identifiersep> to <identifiersep> original <identifiersep> system <identifiersep> out <identifiersep> and <identifiersep> err <identifiersep> when <identifiersep> started ( ) { given : def logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> command <identifiersep> line <identifiersep> process <identifiersep> logging ( ) def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) <LOG> when : logger . error ( <string_literal> ) then : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' when : <ect>
logger . error ( <string_literal> ) then : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn <LOG> logging <identifiersep> manager . start ( ) logger . error ( <string_literal> ) then : outputs . std <identifiersep> out == text <identifiersep> util . to <identifiersep> platform <identifiersep> line <identifiersep> separators ( 'warning \\ n' ) outputs . std <identifiersep> err == text <identifiersep> util . to <identifiersep> platform <identifiersep> line <identifiersep> separators ( 'error \\ n' ) } def consumes <identifiersep> slf4j <identifiersep> when <identifiersep> embedded ( ) { <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) def listener = mock ( standard <identifiersep> output <identifiersep> listener ) when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) <LOG> logging <identifiersep> manager . start ( ) logger . error ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( <string_literal> ) <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . set <identifiersep> level <identifiersep> internal ( log <identifiersep> level . info ) logging <identifiersep> manager . start ( ) when : <LOG> def logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) logger . error ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( <string_literal> ) <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) def logger = logger . get <identifiersep> logger ( <string_literal> ) <LOG> when : logger . warning ( <string_literal> ) logger . severe ( <string_literal> ) then : 0 * listener .  <identifiersep>  and : <ect>
logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) def logger = logger . get <identifiersep> logger ( <string_literal> ) when : logger . info ( <string_literal> ) <LOG> logger . warning ( <string_literal> ) then : 0 * listener .  <identifiersep>  and : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) when : <LOG> logger . severe ( <string_literal> ) logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) <ect>
logger . severe ( <string_literal> ) logger . warning ( <string_literal> ) logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : <LOG> logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) logger . warning ( <string_literal> ) logger . severe ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) <ect>
logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) logger . info ( <string_literal> ) <LOG> logger . warning ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( 'error' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) <ect>
1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 1 * listener . on <identifiersep> output ( 'error' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . stop ( ) <LOG> logger . severe ( <string_literal> ) logger . info ( <string_literal> ) then : 0 * listener .  <identifiersep>  } def restores <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> settings <identifiersep> when <identifiersep> embedded <identifiersep> and <identifiersep> stopped ( ) { given : <ect>
system . err == outputs . std <identifiersep> err <identifiersep> print <identifiersep> stream when : logging <identifiersep> manager . capture <identifiersep> system <identifiersep> sources ( ) then : system . out != outputs . std <identifiersep> out <identifiersep> print <identifiersep> stream system . err != outputs . std <identifiersep> err <identifiersep> print <identifiersep> stream <LOG> when : system . err . println ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( <string_literal> ) 1 * listener . on <identifiersep> output ( system <identifiersep> properties . instance . line <identifiersep> separator ) then : <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) def listener = mock ( standard <identifiersep> output <identifiersep> listener ) when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> error <identifiersep> listener ( listener ) <LOG> logging <identifiersep> manager . start ( ) logger . error ( <string_literal> ) then : 0 * listener .  <identifiersep>  } def does <identifiersep> not <identifiersep> consume <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> when <identifiersep> nested ( ) { given : <ect>
given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> nested <identifiersep> logging ( ) def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) def logger = logger . get <identifiersep> logger ( <string_literal> ) <LOG> when : logger . severe ( <string_literal> ) then : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' } def does <identifiersep> not <identifiersep> consume <identifiersep> from <identifiersep> system <identifiersep> output <identifiersep> and <identifiersep> error <identifiersep> when <identifiersep> nested ( ) { <ect>
<comment> package org . gradle . performance . mutator class apply <identifiersep> non <identifiersep> abi <identifiersep> change <identifiersep> to <identifiersep> java <identifiersep> source <identifiersep> file <identifiersep> mutator extends abstract <identifiersep> java <identifiersep> source <identifiersep> file <identifiersep> mutator { apply <identifiersep> non <identifiersep> abi <identifiersep> change <identifiersep> to <identifiersep> java <identifiersep> source <identifiersep> file <identifiersep> mutator ( string source <identifiersep> file <identifiersep> path ) { super ( source <identifiersep> file <identifiersep> path ) } @ override <LOG> protected void apply <identifiersep> change <identifiersep> at ( string <identifiersep> builder text , int last <identifiersep> method <identifiersep> end <identifiersep> pos ) { } } <ect>
public action < measured <identifiersep> operation > runner ( final build <identifiersep> experiment <identifiersep> invocation <identifiersep> info invocation <identifiersep> info , final invocation <identifiersep> customizer invocation <identifiersep> customizer ) { return new action < measured <identifiersep> operation > ( ) { @ override public void execute ( measured <identifiersep> operation measured <identifiersep> operation ) { system . out . println ( <string_literal> + iterables . concat ( build <identifiersep> spec . get <identifiersep> maven <identifiersep> opts ( ) , build <identifiersep> spec . get <identifiersep> jvm <identifiersep> opts ( ) ) ) ; list < string > clean <identifiersep> tasks = build <identifiersep> spec . get <identifiersep> clean <identifiersep> tasks ( ) ; <LOG> if ( ! clean <identifiersep> tasks . is <identifiersep> empty ( ) ) { exec <identifiersep> action clean = create <identifiersep> maven <identifiersep> invocation ( build <identifiersep> spec , clean <identifiersep> tasks ) ; execute <identifiersep> with <identifiersep> file <identifiersep> logging ( experiment , clean ) ; } maven <identifiersep> invocation <identifiersep> spec invocation = invocation <identifiersep> customizer . customize ( invocation <identifiersep> info , build <identifiersep> spec ) ; final exec <identifiersep> action run = create <identifiersep> maven <identifiersep> invocation ( invocation , invocation . get <identifiersep> tasks <identifiersep> to <identifiersep> run ( ) ) ; system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( build <identifiersep> spec . get <identifiersep> tasks <identifiersep> to <identifiersep> run ( ) ) ) ; <ect>
clean <identifiersep> launcher = configure <identifiersep> launcher ( invocation , clean <identifiersep> tasks ) } else { clean <identifiersep> launcher = null } def tasks <identifiersep> to <identifiersep> run = invocation . tasks <identifiersep> to <identifiersep> run build <identifiersep> launcher build <identifiersep> launcher = configure <identifiersep> launcher ( invocation , tasks <identifiersep> to <identifiersep> run ) return { measured <identifiersep> operation measured <identifiersep> operation - > <LOG> if ( clean <identifiersep> launcher != null ) { clean <identifiersep> launcher . run ( ) } system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( tasks <identifiersep> to <identifiersep> run ) ) ; duration <identifiersep> measurement <identifiersep> impl . measure ( measured <identifiersep> operation , new runnable ( ) { @ override void run ( ) { <ect>
cleanup ( ) } @ override action < measured <identifiersep> operation > runner ( build <identifiersep> experiment <identifiersep> invocation <identifiersep> info invocation <identifiersep> info , invocation <identifiersep> customizer invocation <identifiersep> customizer ) { def invocation = invocation <identifiersep> customizer ? invocation <identifiersep> customizer . customize ( invocation <identifiersep> info , this . invocation ) : this . invocation return { measured <identifiersep> operation measured <identifiersep> operation - > def clean <identifiersep> tasks = invocation . clean <identifiersep> tasks <LOG> if ( clean <identifiersep> tasks ) { run ( invocation <identifiersep> info , invocation , clean <identifiersep> tasks ) } def tasks <identifiersep> to <identifiersep> run = invocation . tasks <identifiersep> to <identifiersep> run system . out . println ( <string_literal> + joiner . on ( <string_literal> ) . join ( tasks <identifiersep> to <identifiersep> run ) ) ; duration <identifiersep> measurement <identifiersep> impl . measure ( measured <identifiersep> operation ) { run ( invocation <identifiersep> info , invocation , tasks <identifiersep> to <identifiersep> run ) <ect>
this . executer <identifiersep> provider = executer <identifiersep> provider ; profiler = new jfr <identifiersep> profiler ( ) ; data <identifiersep> collector = new composite <identifiersep> data <identifiersep> collector ( profiler ) ; } public profiler get <identifiersep> profiler ( ) { return profiler ; } public void run ( build <identifiersep> experiment <identifiersep> spec experiment , measured <identifiersep> operation <identifiersep> list results ) { <LOG> system . out . println ( ) ; system . out . println ( ) ; invocation <identifiersep> spec invocation <identifiersep> spec = experiment . get <identifiersep> invocation ( ) ; file working <identifiersep> directory = invocation <identifiersep> spec . get <identifiersep> working <identifiersep> directory ( ) ; working <identifiersep> directory . mkdirs ( ) ; copy <identifiersep> template <identifiersep> to ( experiment , working <identifiersep> directory ) ; <ect>
protected invocation <identifiersep> customizer create <identifiersep> invocation <identifiersep> customizer ( final build <identifiersep> experiment <identifiersep> invocation <identifiersep> info info ) { if ( info . get <identifiersep> build <identifiersep> experiment <identifiersep> spec ( ) instanceof gradle <identifiersep> build <identifiersep> experiment <identifiersep> spec ) { return new invocation <identifiersep> customizer ( ) { @ override public < t extends invocation <identifiersep> spec > t customize ( build <identifiersep> experiment <identifiersep> invocation <identifiersep> info info , t invocation <identifiersep> spec ) { final list < string > iteration <identifiersep> info <identifiersep> arguments = create <identifiersep> iteration <identifiersep> info <identifiersep> arguments ( info . get <identifiersep> phase ( ) , info . get <identifiersep> iteration <identifiersep> number ( ) , info . get <identifiersep> iteration <identifiersep> max ( ) ) ; <LOG> gradle <identifiersep> invocation <identifiersep> spec gradle <identifiersep> invocation <identifiersep> spec = ( ( gradle <identifiersep> invocation <identifiersep> spec ) invocation <identifiersep> spec ) . with <identifiersep> additional <identifiersep> args ( iteration <identifiersep> info <identifiersep> arguments ) ; if ( info . get <identifiersep> build <identifiersep> experiment <identifiersep> spec ( ) . get <identifiersep> invocation <identifiersep> customizer ( ) != null ) { gradle <identifiersep> invocation <identifiersep> spec = info . get <identifiersep> build <identifiersep> experiment <identifiersep> spec ( ) . get <identifiersep> invocation <identifiersep> customizer ( ) . customize ( info , gradle <identifiersep> invocation <identifiersep> spec ) ; } return ( t ) gradle <identifiersep> invocation <identifiersep> spec ; } } ; } return null ; <ect>
public < t > t with <identifiersep> connection ( connection <identifiersep> action < t > action ) throws sql <identifiersep> exception { if ( connection == null ) { connection = driver <identifiersep> manager . get <identifiersep> connection ( get <identifiersep> url ( ) , get <identifiersep> user <identifiersep> name ( ) , get <identifiersep> password ( ) ) ; try { schema <identifiersep> initializer . execute ( connection ) ; } catch ( sql <identifiersep> exception e ) { <LOG> if ( e . get <identifiersep> error <identifiersep> code ( ) == <number_literal> ) { } else { connection . close ( ) ; connection = null ; throw e ; } } } return action . execute ( connection ) ; <ect>
@ override source <identifiersep> file get <identifiersep> source <identifiersep> file ( ) { return source <identifiersep> file ( <string_literal> , <string_literal> , <string_literal> <string_literal> <LOG> public func say <identifiersep> hello ( ) { } } <string_literal> <string_literal> $ { hello <identifiersep> world <identifiersep> app . hello <identifiersep> world } \\ n <string_literal> <ect>
<comment> public void initialise <identifiersep> environment ( ) { string compiler <identifiersep> path = joiner . on ( file . path <identifiersep> separator ) . join ( path <identifiersep> entries ) ; if ( compiler <identifiersep> path . length ( ) > 0 ) { original <identifiersep> path = system . getenv ( path <identifiersep> var <identifiersep> name ) ; <LOG> string path = compiler <identifiersep> path + file . path <identifiersep> separator + original <identifiersep> path ; process <identifiersep> environment . set <identifiersep> environment <identifiersep> variable ( path <identifiersep> var <identifiersep> name , path ) ; } } public void reset <identifiersep> environment ( ) { if ( original <identifiersep> path != null ) { process <identifiersep> environment . set <identifiersep> environment <identifiersep> variable ( path <identifiersep> var <identifiersep> name , original <identifiersep> path ) ; } } public abstract string get <identifiersep> build <identifiersep> script <identifiersep> config ( ) ; <ect>
exec . set <identifiersep> error <identifiersep> output ( null <identifiersep> output <identifiersep> stream . instance ) ; exec . set <identifiersep> ignore <identifiersep> exit <identifiersep> value ( true ) ; exec <identifiersep> result result = exec . execute ( ) ; int exit <identifiersep> value = result . get <identifiersep> exit <identifiersep> value ( ) ; if ( exit <identifiersep> value == 0 ) { return buffer . read <identifiersep> as <identifiersep> string ( <string_literal> ) ; <LOG> } else { return null ; } } private list < visual <identifiersep> studio <identifiersep> install <identifiersep> candidate > parse <identifiersep> json ( string json ) { list < visual <identifiersep> studio <identifiersep> install <identifiersep> candidate > installs = lists . new <identifiersep> array <identifiersep> list ( ) ; json <identifiersep> reader reader = new json <identifiersep> reader ( new string <identifiersep> reader ( json ) ) ; try { <ect>
this . version <identifiersep> determiner = version <identifiersep> determiner ; } @ nonnull @ override public list < visual <identifiersep> studio <identifiersep> install <identifiersep> candidate > get <identifiersep> visual <identifiersep> studio <identifiersep> installs ( ) { list < visual <identifiersep> studio <identifiersep> install <identifiersep> candidate > installs = lists . new <identifiersep> array <identifiersep> list ( ) ; file compiler <identifiersep> in <identifiersep> path = os . find <identifiersep> in <identifiersep> path ( legacy <identifiersep> compiler <identifiersep> filename ) ; <LOG> if ( compiler <identifiersep> in <identifiersep> path == null ) { } else { visual <identifiersep> studio <identifiersep> install <identifiersep> candidate install = version <identifiersep> determiner . get <identifiersep> visual <identifiersep> studio <identifiersep> metadata <identifiersep> from <identifiersep> compiler ( compiler <identifiersep> in <identifiersep> path ) ; if ( install != null ) { installs . add ( install ) ; } } return installs ; <ect>
file sdk <identifiersep> dir = file <identifiersep> utils . canonicalize ( new file ( windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> path , registry <identifiersep> folder ) ) ) ; string version = format <identifiersep> version ( windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> path , registry <identifiersep> version ) ) ; string name = windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> path , registry <identifiersep> name ) ; if ( is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { logger . debug ( <string_literal> , version , sdk <identifiersep> dir ) ; add <identifiersep> sdk ( sdk <identifiersep> dir , version , name ) ; <LOG> } else { } } catch ( missing <identifiersep> registry <identifiersep> entry <identifiersep> exception e ) { <comment> <ect>
for ( int i = 0 ; i != keys . length ; ++ i ) { try { file kit <identifiersep> dir = file <identifiersep> utils . canonicalize ( new file ( windows <identifiersep> registry . get <identifiersep> string <identifiersep> value ( windows <identifiersep> registry . key . hkey <identifiersep> local <identifiersep> machine , base <identifiersep> key + registry <identifiersep> rootpath <identifiersep> kit , keys [ i ] ) ) ) ; if ( is <identifiersep> windows <identifiersep> sdk ( kit <identifiersep> dir ) ) { logger . debug ( <string_literal> , versions [ i ] , kit <identifiersep> dir ) ; add <identifiersep> sdk ( kit <identifiersep> dir , versions [ i ] , name <identifiersep> kit + <string_literal> + versions [ i ] ) ; <LOG> } else { } } catch ( missing <identifiersep> registry <identifiersep> entry <identifiersep> exception e ) { <comment> <ect>
if ( resource <identifiersep> compiler == null ) { logger . debug ( <string_literal> ) ; return ; } file sdk <identifiersep> dir = file <identifiersep> utils . canonicalize ( resource <identifiersep> compiler . get <identifiersep> parent <identifiersep> file ( ) . get <identifiersep> parent <identifiersep> file ( ) ) ; if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { sdk <identifiersep> dir = sdk <identifiersep> dir . get <identifiersep> parent <identifiersep> file ( ) ; <LOG> if ( ! is <identifiersep> windows <identifiersep> sdk ( sdk <identifiersep> dir ) ) { } } logger . debug ( <string_literal> , sdk <identifiersep> dir ) ; if ( ! found <identifiersep> sdks . contains <identifiersep> key ( sdk <identifiersep> dir ) ) { add <identifiersep> sdk ( sdk <identifiersep> dir , <string_literal> , <string_literal> ) ; } path <identifiersep> sdk = found <identifiersep> sdks . get ( sdk <identifiersep> dir ) ; } private search <identifiersep> result < windows <identifiersep> sdk <identifiersep> install > locate <identifiersep> user <identifiersep> specified <identifiersep> sdk ( file candidate ) { <ect>
} catch ( missing <identifiersep> registry <identifiersep> entry <identifiersep> exception e ) { <comment> <LOG> version <identifiersep> number version = version <identifiersep> number . with <identifiersep> patch <identifiersep> number ( ) . parse ( version <identifiersep> dir ) ; file bin <identifiersep> dir = new file ( windows <identifiersep> kit <identifiersep> dir , <string_literal> + version <identifiersep> dir ) ; file unversioned <identifiersep> bin <identifiersep> dir = new file ( windows <identifiersep> kit <identifiersep> dir , <string_literal> ) ; if ( is <identifiersep> valid <identifiersep> component <identifiersep> bin <identifiersep> dir ( bin <identifiersep> dir ) ) { t component = new <identifiersep> component ( windows <identifiersep> kit <identifiersep> dir , bin <identifiersep> dir , version , discovery <identifiersep> type ) ; found . add ( component ) ; <ect>
file visual <identifiersep> cpp <identifiersep> dir = install . get <identifiersep> visual <identifiersep> cpp <identifiersep> dir ( ) ; file visual <identifiersep> studio <identifiersep> dir = install . get <identifiersep> install <identifiersep> dir ( ) ; if ( found <identifiersep> installs . contains <identifiersep> key ( visual <identifiersep> studio <identifiersep> dir ) ) { return true ; } if ( broken <identifiersep> installs . contains ( visual <identifiersep> studio <identifiersep> dir ) ) { return false ; } <LOG> if ( is <identifiersep> valid <identifiersep> install ( install ) && install . get <identifiersep> visual <identifiersep> cpp <identifiersep> version ( ) != version <identifiersep> number . unknown ) { version <identifiersep> number visual <identifiersep> studio <identifiersep> version = install . get <identifiersep> version ( ) ; string visual <identifiersep> studio <identifiersep> display <identifiersep> version = install . get <identifiersep> version ( ) == version <identifiersep> number . unknown ? <string_literal> + source : install . get <identifiersep> version ( ) . to <identifiersep> string ( ) ; visual <identifiersep> cpp <identifiersep> install visual <identifiersep> cpp = build <identifiersep> visual <identifiersep> cpp <identifiersep> install ( <string_literal> + install . get <identifiersep> visual <identifiersep> cpp <identifiersep> version ( ) , visual <identifiersep> studio <identifiersep> dir , visual <identifiersep> cpp <identifiersep> dir , install . get <identifiersep> visual <identifiersep> cpp <identifiersep> version ( ) , install . get <identifiersep> compatibility ( ) ) ; visual <identifiersep> studio <identifiersep> install visual <identifiersep> studio = new visual <identifiersep> studio <identifiersep> install ( <string_literal> + visual <identifiersep> studio <identifiersep> display <identifiersep> version , visual <identifiersep> studio <identifiersep> dir , visual <identifiersep> studio <identifiersep> version , visual <identifiersep> cpp ) ; found <identifiersep> installs . put ( visual <identifiersep> studio <identifiersep> dir , visual <identifiersep> studio ) ; <ect>
broken <identifiersep> installs . add ( visual <identifiersep> studio <identifiersep> dir ) ; return false ; } } private search <identifiersep> result < visual <identifiersep> studio <identifiersep> install > locate <identifiersep> user <identifiersep> specified <identifiersep> install ( file candidate ) { visual <identifiersep> studio <identifiersep> install <identifiersep> candidate install = version <identifiersep> determiner . get <identifiersep> visual <identifiersep> studio <identifiersep> metadata <identifiersep> from <identifiersep> install <identifiersep> dir ( candidate ) ; if ( install != null && add <identifiersep> install <identifiersep> if <identifiersep> valid ( install , <string_literal> ) ) { return new component <identifiersep> found < visual <identifiersep> studio <identifiersep> install > ( found <identifiersep> installs . get ( install . get <identifiersep> install <identifiersep> dir ( ) ) ) ; <LOG> } else { return new component <identifiersep> not <identifiersep> found < visual <identifiersep> studio <identifiersep> install > ( string . format ( <string_literal> , candidate ) ) ; } } private visual <identifiersep> cpp <identifiersep> install build <identifiersep> visual <identifiersep> cpp <identifiersep> install ( string name , file vs <identifiersep> path , file base <identifiersep> path , version <identifiersep> number version , compatibility compatibility ) { switch ( compatibility ) { case legacy : return build <identifiersep> legacy <identifiersep> visual <identifiersep> cpp <identifiersep> install ( name , vs <identifiersep> path , base <identifiersep> path , version ) ; <ect>
@ override public work <identifiersep> result execute ( scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { return compiler . execute ( scala <identifiersep> classpath , zinc <identifiersep> classpath , gradle <identifiersep> user <identifiersep> home , spec ) ; } <comment> <LOG> static work <identifiersep> result execute ( final iterable < file > scala <identifiersep> classpath , final iterable < file > zinc <identifiersep> classpath , file gradle <identifiersep> user <identifiersep> home , final scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { final xsbti . logger logger = new sbt <identifiersep> logger <identifiersep> adapter ( ) ; timer timer = time . start <identifiersep> timer ( ) ; com . typesafe . zinc . compiler compiler = zinc <identifiersep> scala <identifiersep> compiler <identifiersep> factory . create <identifiersep> parallel <identifiersep> safe <identifiersep> compiler ( scala <identifiersep> classpath , zinc <identifiersep> classpath , logger , gradle <identifiersep> user <identifiersep> home ) ; logger . info ( <string_literal> , timer . get <identifiersep> elapsed ( ) ) ; list < string > scalac <identifiersep> options = new zinc <identifiersep> scala <identifiersep> compiler <identifiersep> arguments <identifiersep> generator ( ) . generate ( spec ) ; <ect>
list < string > javac <identifiersep> options = new java <identifiersep> compiler <identifiersep> arguments <identifiersep> builder ( spec ) . include <identifiersep> classpath ( false ) . no <identifiersep> empty <identifiersep> source <identifiersep> path ( ) . build ( ) ; inputs inputs = inputs . create ( immutable <identifiersep> list . copy <identifiersep> of ( spec . get <identifiersep> compile <identifiersep> classpath ( ) ) , immutable <identifiersep> list . copy <identifiersep> of ( spec . get <identifiersep> source ( ) ) , spec . get <identifiersep> destination <identifiersep> dir ( ) , scalac <identifiersep> options , javac <identifiersep> options , spec . get <identifiersep> scala <identifiersep> compile <identifiersep> options ( ) . get <identifiersep> incremental <identifiersep> options ( ) . get <identifiersep> analysis <identifiersep> file ( ) , spec . get <identifiersep> analysis <identifiersep> map ( ) , <string_literal> , get <identifiersep> inc <identifiersep> options ( ) , true ) ; inputs . debug ( inputs , logger ) ; } if ( spec . get <identifiersep> scala <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> force ( ) ) { <LOG> g <identifiersep> file <identifiersep> utils . delete <identifiersep> directory ( spec . get <identifiersep> destination <identifiersep> dir ( ) ) ; } try { compiler . compile ( inputs , logger ) ; } catch ( xsbti . compile <identifiersep> failed e ) { throw new compilation <identifiersep> failed <identifiersep> exception ( e ) ; } logger . info ( <string_literal> , timer . get <identifiersep> elapsed ( ) ) ; <ect>
spec . set <identifiersep> annotation <identifiersep> processor <identifiersep> path ( immutable <identifiersep> list . copy <identifiersep> of ( get <identifiersep> effective <identifiersep> annotation <identifiersep> processor <identifiersep> path ( ) ) ) ; return spec ; } protected void configure <identifiersep> incremental <identifiersep> compilation ( scala <identifiersep> compile <identifiersep> spec spec ) { map < file , file > global <identifiersep> analysis <identifiersep> map = create <identifiersep> or <identifiersep> get <identifiersep> global <identifiersep> analysis <identifiersep> map ( ) ; hash <identifiersep> map < file , file > filtered <identifiersep> map = filter <identifiersep> for <identifiersep> classpath ( global <identifiersep> analysis <identifiersep> map , spec . get <identifiersep> compile <identifiersep> classpath ( ) ) ; <LOG> spec . set <identifiersep> analysis <identifiersep> map ( filtered <identifiersep> map ) ; logger . debug ( <string_literal> , scala <identifiersep> compile <identifiersep> options . get <identifiersep> incremental <identifiersep> options ( ) . get <identifiersep> published <identifiersep> code ( ) ) ; logger . debug ( <string_literal> , filtered <identifiersep> map ) ; } } @ suppress <identifiersep> warnings ( <string_literal> ) protected map < file , file > create <identifiersep> or <identifiersep> get <identifiersep> global <identifiersep> analysis <identifiersep> map ( ) { extra <identifiersep> properties <identifiersep> extension extra <identifiersep> properties = get <identifiersep> project ( ) . get <identifiersep> root <identifiersep> project ( ) . get <identifiersep> extensions ( ) . get <identifiersep> extra <identifiersep> properties ( ) ; <ect>
protected void configure <identifiersep> incremental <identifiersep> compilation ( scala <identifiersep> compile <identifiersep> spec spec ) { map < file , file > global <identifiersep> analysis <identifiersep> map = create <identifiersep> or <identifiersep> get <identifiersep> global <identifiersep> analysis <identifiersep> map ( ) ; hash <identifiersep> map < file , file > filtered <identifiersep> map = filter <identifiersep> for <identifiersep> classpath ( global <identifiersep> analysis <identifiersep> map , spec . get <identifiersep> compile <identifiersep> classpath ( ) ) ; spec . set <identifiersep> analysis <identifiersep> map ( filtered <identifiersep> map ) ; logger . debug ( <string_literal> , scala <identifiersep> compile <identifiersep> options . get <identifiersep> incremental <identifiersep> options ( ) . get <identifiersep> analysis <identifiersep> file ( ) ) ; <LOG> logger . debug ( <string_literal> , scala <identifiersep> compile <identifiersep> options . get <identifiersep> incremental <identifiersep> options ( ) . get <identifiersep> published <identifiersep> code ( ) ) ; } } @ suppress <identifiersep> warnings ( <string_literal> ) protected map < file , file > create <identifiersep> or <identifiersep> get <identifiersep> global <identifiersep> analysis <identifiersep> map ( ) { extra <identifiersep> properties <identifiersep> extension extra <identifiersep> properties = get <identifiersep> project ( ) . get <identifiersep> root <identifiersep> project ( ) . get <identifiersep> extensions ( ) . get <identifiersep> extra <identifiersep> properties ( ) ; map < file , file > analysis <identifiersep> map ; if ( extra <identifiersep> properties . has ( <string_literal> ) ) { <ect>
worker <identifiersep> server . stop ( ) ; wait <identifiersep> for <identifiersep> event ( stop <identifiersep> event ) ; process . wait <identifiersep> for <identifiersep> stop ( ) ; stopped . set ( true ) ; } @ override public void update ( play <identifiersep> app <identifiersep> lifecycle <identifiersep> update update ) { <LOG> try { if ( update instanceof play <identifiersep> app <identifiersep> start ) { start <identifiersep> event . put ( ( play <identifiersep> app <identifiersep> start ) update ) ; } else if ( update instanceof play <identifiersep> app <identifiersep> stop ) { stop <identifiersep> event . put ( ( play <identifiersep> app <identifiersep> stop ) update ) ; } else if ( update instanceof play <identifiersep> app <identifiersep> reload ) { <ect>
} finally { lock . unlock ( ) ; } } @ override public void current <identifiersep> status ( boolean has <identifiersep> changed , throwable throwable ) { lock . lock ( ) ; try { <LOG> latest <identifiersep> status = new result ( has <identifiersep> changed , throwable ) ; signal . signal <identifiersep> all ( ) ; } finally { lock . unlock ( ) ; } } @ override public result require <identifiersep> up <identifiersep> to <identifiersep> date ( ) throws interrupted <identifiersep> exception { <ect>
@ override public result require <identifiersep> up <identifiersep> to <identifiersep> date ( ) throws interrupted <identifiersep> exception { lock . lock ( ) ; try { if ( ! stop <identifiersep> requested ) { logger . debug ( <string_literal> ) ; <LOG> events . put ( play <identifiersep> app <identifiersep> lifecycle <identifiersep> update . reload <identifiersep> requested ( ) ) ; result old <identifiersep> status = latest <identifiersep> status ; while ( latest <identifiersep> status == old <identifiersep> status && ! stop <identifiersep> requested ) { signal . await ( ) ; } logger . debug ( <string_literal> , latest <identifiersep> status ) ; return latest <identifiersep> status ; <ect>
throwable failure = result . failure ; if ( failure == null ) { return null ; } else { try { return direct <identifiersep> instantiator . instantiate ( play <identifiersep> exception <identifiersep> class , <string_literal> , failure . get <identifiersep> message ( ) , failure ) ; <LOG> } catch ( exception e ) { return failure ; } } } } else if ( method . get <identifiersep> name ( ) . equals ( <string_literal> ) ) { return new hash <identifiersep> map < string , string > ( ) ; } <comment> <ect>
<comment> <LOG> } catch ( exception e ) { } } if ( file <identifiersep> lock <identifiersep> held <identifiersep> by <identifiersep> owner != null ) { file <identifiersep> lock <identifiersep> held <identifiersep> by <identifiersep> owner . run ( ) ; } cross <identifiersep> process <identifiersep> cache <identifiersep> access . close ( ) ; if ( cache <identifiersep> closed <identifiersep> count != 1 ) { log . debug ( <string_literal> , cache <identifiersep> display <identifiersep> name , cache <identifiersep> closed <identifiersep> count ) ; <ect>
@ override public < k , v > multi <identifiersep> process <identifiersep> safe <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > new <identifiersep> cache ( final persistent <identifiersep> indexed <identifiersep> cache <identifiersep> parameters < k , v > parameters ) { state <identifiersep> lock . lock ( ) ; indexed <identifiersep> cache <identifiersep> entry < k , v > entry = cast . unchecked <identifiersep> cast ( caches . get ( parameters . get <identifiersep> cache <identifiersep> name ( ) ) ) ; try { if ( entry == null ) { <LOG> final file cache <identifiersep> file = new file ( base <identifiersep> dir , parameters . get <identifiersep> cache <identifiersep> name ( ) + <string_literal> ) ; factory < b <identifiersep> tree <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > > indexed <identifiersep> cache <identifiersep> factory = new factory < b <identifiersep> tree <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > > ( ) { public b <identifiersep> tree <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > create ( ) { return do <identifiersep> create <identifiersep> cache ( cache <identifiersep> file , parameters . get <identifiersep> key <identifiersep> serializer ( ) , parameters . get <identifiersep> value <identifiersep> serializer ( ) ) ; } } ; multi <identifiersep> process <identifiersep> safe <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > indexed <identifiersep> cache = new default <identifiersep> multi <identifiersep> process <identifiersep> safe <identifiersep> persistent <identifiersep> indexed <identifiersep> cache < k , v > ( indexed <identifiersep> cache <identifiersep> factory , file <identifiersep> access ) ; <ect>
long removed <identifiersep> size = 0 ; for ( file file : files ) { try { long size = file . length ( ) ; if ( g <identifiersep> file <identifiersep> utils . delete <identifiersep> quietly ( file ) ) { removed <identifiersep> size += size ; } <LOG> } catch ( exception e ) { } } return removed <identifiersep> size ; } } <ect>
} <comment> <LOG> return ; } } try { on <identifiersep> close . execute ( file <identifiersep> lock ) ; } finally { file <identifiersep> lock . close ( ) ; file <identifiersep> lock = null ; <ect>
state <identifiersep> lock . lock ( ) ; try { if ( lock <identifiersep> count == 0 ) { logger . debug ( <string_literal> , cache <identifiersep> display <identifiersep> name ) ; release <identifiersep> lock <identifiersep> if <identifiersep> held ( ) ; } else { <LOG> <comment> <ect>
public default <identifiersep> file <identifiersep> lock <identifiersep> contention <identifiersep> handler ( executor <identifiersep> factory executor <identifiersep> factory , inet <identifiersep> address <identifiersep> factory address <identifiersep> factory ) { this . executor <identifiersep> factory = executor <identifiersep> factory ; this . address <identifiersep> factory = address <identifiersep> factory ; } private runnable listener ( ) { return new runnable ( ) { public void run ( ) { <LOG> try { do <identifiersep> run ( ) ; } catch ( throwable t ) { <comment> <ect>
try { logger . debug ( <string_literal> ) ; do <identifiersep> run ( ) ; } catch ( throwable t ) { <comment> <LOG> } finally { } } private void do <identifiersep> run ( ) { while ( true ) { datagram <identifiersep> packet packet ; long lock <identifiersep> id ; try { <ect>
open ( ) ; } catch ( exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( string . format ( <string_literal> , this ) , e ) ; } } @ override public string to <identifiersep> string ( ) { return <string_literal> + cache <identifiersep> file . get <identifiersep> name ( ) + <string_literal> + cache <identifiersep> file + <string_literal> ; } <LOG> private void open ( ) throws exception { try { do <identifiersep> open ( ) ; } catch ( corrupted <identifiersep> cache <identifiersep> exception e ) { rebuild ( ) ; } } private void do <identifiersep> open ( ) throws exception { <ect>
try { store . close ( ) ; } catch ( exception e ) { throw new unchecked <identifiersep> io <identifiersep> exception ( e ) ; } } public boolean is <identifiersep> open ( ) { return store . is <identifiersep> open ( ) ; } <LOG> private void rebuild ( ) throws exception { store . clear ( ) ; close ( ) ; do <identifiersep> open ( ) ; } public void verify ( ) { try { <ect>
throw new runtime <identifiersep> exception ( <string_literal> + display <identifiersep> name , e ) ; } } } ) ; stoppable . add ( new stoppable ( ) { public void stop ( ) { if ( lock <identifiersep> file <identifiersep> access == null ) { return ; } <LOG> try { try { if ( lock != null && ! lock . is <identifiersep> shared ( ) ) { <comment> <ect>
try { lock <identifiersep> file <identifiersep> access . write <identifiersep> lock <identifiersep> info ( port , lock <identifiersep> id , meta <identifiersep> data <identifiersep> provider . get <identifiersep> process <identifiersep> identifier ( ) , operation <identifiersep> display <identifiersep> name ) ; } finally { information <identifiersep> region <identifiersep> lock . release ( ) ; } } else { <comment> <LOG> lock <identifiersep> state = lock <identifiersep> file <identifiersep> access . read <identifiersep> lock <identifiersep> state ( ) ; } lock = state <identifiersep> region <identifiersep> lock ; return lock <identifiersep> state ; } catch ( throwable t ) { state <identifiersep> region <identifiersep> lock . release ( ) ; throw t ; <ect>
if ( lock <identifiersep> info . port != - 1 ) { if ( lock <identifiersep> info . port != last <identifiersep> lock <identifiersep> holder <identifiersep> port ) { backoff . restart <identifiersep> timer ( ) ; last <identifiersep> lock <identifiersep> holder <identifiersep> port = lock <identifiersep> info . port ; last <identifiersep> ping <identifiersep> time = 0 ; } if ( file <identifiersep> lock <identifiersep> contention <identifiersep> handler . maybe <identifiersep> ping <identifiersep> owner ( lock <identifiersep> info . port , lock <identifiersep> info . lock <identifiersep> id , display <identifiersep> name , backoff . timer . get <identifiersep> elapsed <identifiersep> millis ( ) - last <identifiersep> ping <identifiersep> time ) ) { <LOG> last <identifiersep> ping <identifiersep> time = backoff . timer . get <identifiersep> elapsed <identifiersep> millis ( ) ; } } else { logger . debug ( <string_literal> ) ; } } return null ; } } ) ; } private java . nio . channels . file <identifiersep> lock lock <identifiersep> information <identifiersep> region ( final lock <identifiersep> mode lock <identifiersep> mode , exponential <identifiersep> backoff backoff ) throws io <identifiersep> exception , interrupted <identifiersep> exception { <ect>
operating <identifiersep> system . current ( ) . is <identifiersep> windows ( ) ? run <identifiersep> via <identifiersep> windows <identifiersep> start <identifiersep> script ( ) : run <identifiersep> via <identifiersep> unix <identifiersep> start <identifiersep> script ( ) } private void create <identifiersep> sample <identifiersep> project <identifiersep> setup ( ) { create <identifiersep> main <identifiersep> class ( ) populate <identifiersep> build <identifiersep> file ( ) populate <identifiersep> settings <identifiersep> file ( ) } private void create <identifiersep> main <identifiersep> class ( ) { <LOG> generate <identifiersep> main <identifiersep> class <string_literal> <string_literal> app pid : <string_literal> @ <string_literal> hello world ! <string_literal> <string_literal> } private void generate <identifiersep> main <identifiersep> class ( string main <identifiersep> method <identifiersep> body ) { file ( 'src / main / java / org / gradle / test / main . java' ) . text = <string_literal> <string_literal> <ect>
create <identifiersep> main <identifiersep> class ( ) populate <identifiersep> build <identifiersep> file ( ) populate <identifiersep> settings <identifiersep> file ( ) } private void create <identifiersep> main <identifiersep> class ( ) { generate <identifiersep> main <identifiersep> class <string_literal> <string_literal> app home : <string_literal> app <identifiersep> home <identifiersep> system <identifiersep> prop <string_literal> <LOG> system . out . println ( <string_literal> + java . lang . management . management <identifiersep> factory . get <identifiersep> runtime <identifiersep> mx <identifiersep> bean ( ) . get <identifiersep> name ( ) . split ( <string_literal> ) [ 0 ] ) ; <string_literal> <string_literal> <string_literal> package org . gradle . test ; public class main { <ect>
unix <identifiersep> script . text = unix <identifiersep> script . text . replace ( <string_literal> , <string_literal> ) } } <string_literal> <string_literal> <string_literal> package org . gradle . test ; public class main { <LOG> public static void main ( string [ ] args ) { system . out . println ( <string_literal> ) ; for ( string arg : args ) { system . out . println ( <string_literal> + arg ) ; } } } <string_literal> <string_literal> <ect>
file ( 'src / main / java / org / gradle / test / main . java' ) < < <string_literal> <string_literal> app home : <string_literal> app <identifiersep> home <identifiersep> system <identifiersep> prop <string_literal> hello world ! <string_literal> <LOG> for ( string arg : args ) { } } } <string_literal> <string_literal> <string_literal> apply plugin : 'application' main <identifiersep> class <identifiersep> name = 'org . gradle . test . main' <ect>
package org . test import java . security . * ; class security <identifiersep> test extends security <identifiersep> test <identifiersep> support { public void test <identifiersep> security <identifiersep> manager ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; <LOG> set <identifiersep> up ( ) ; } } } class security <identifiersep> test <identifiersep> support extends groovy <identifiersep> test <identifiersep> case { <comment> <ect>
id 'groovy' } dependencies { compile local <identifiersep> groovy ( ) } <string_literal> <string_literal> <string_literal> public class required <identifiersep> by <identifiersep> groovy { <LOG> public static void print <identifiersep> something ( ) { } } <string_literal> <string_literal> <string_literal> @ groovy . transform . compile <identifiersep> static class uses <identifiersep> java { <ect>
build <identifiersep> file < < <string_literal> <string_literal> <string_literal> file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> public static void main ( string [ ] args ) { system . out . println ( <string_literal> + system . get <identifiersep> property ( <string_literal> ) ) ; } } <string_literal> <string_literal> java home : $ { file <identifiersep> utils . canonicalize ( target . java <identifiersep> home ) } <string_literal> <ect>
$ { maven <identifiersep> central <identifiersep> repository ( ) } dependencies { compile 'org . codehaus . groovy : groovy - all : <number_literal> . <number_literal> . 10' } <string_literal> <string_literal> <string_literal> public class hello { <LOG> public static void main ( string . . . args ) { } } <string_literal> <string_literal> up - to - date incremental compilation is cached if nothing to recompile <string_literal> <string_literal> <ect>
<comment> private string serialize <identifiersep> object ( pbx <identifiersep> object obj ) { if ( obj . get <identifiersep> global <identifiersep> id ( ) == null ) { <LOG> obj . set <identifiersep> global <identifiersep> id ( obj . generate <identifiersep> gid ( gid <identifiersep> generator ) ) ; } else { <comment> <ect>
} else { <comment> <LOG> } else { } } <comment> <ect>
static uri safe <identifiersep> uri ( uri uri ) throws uri <identifiersep> syntax <identifiersep> exception { return new uri ( uri . get <identifiersep> scheme ( ) , null , uri . get <identifiersep> host ( ) , uri . get <identifiersep> port ( ) , uri . get <identifiersep> path ( ) , uri . get <identifiersep> query ( ) , uri . get <identifiersep> fragment ( ) ) ; } private void add <identifiersep> basic <identifiersep> authentication ( uri address , url <identifiersep> connection connection ) throws io <identifiersep> exception { string user <identifiersep> info = calculate <identifiersep> user <identifiersep> info ( address ) ; if ( user <identifiersep> info == null ) { return ; } <LOG> if ( ! <string_literal> . equals ( address . get <identifiersep> scheme ( ) ) ) { } connection . set <identifiersep> request <identifiersep> property ( <string_literal> , <string_literal> + base64encode ( user <identifiersep> info ) ) ; } <comment> <ect>
file tmp <identifiersep> zip <identifiersep> file = new file ( local <identifiersep> zip <identifiersep> file . get <identifiersep> parent <identifiersep> file ( ) , local <identifiersep> zip <identifiersep> file . get <identifiersep> name ( ) + <string_literal> ) ; tmp <identifiersep> zip <identifiersep> file . delete ( ) ; logger . log ( <string_literal> + safe <identifiersep> distribution <identifiersep> url ) ; download . download ( distribution <identifiersep> url , tmp <identifiersep> zip <identifiersep> file ) ; tmp <identifiersep> zip <identifiersep> file . rename <identifiersep> to ( local <identifiersep> zip <identifiersep> file ) ; } list < file > top <identifiersep> level <identifiersep> dirs = list <identifiersep> dirs ( dist <identifiersep> dir ) ; <LOG> for ( file dir : top <identifiersep> level <identifiersep> dirs ) { delete <identifiersep> dir ( dir ) ; } verify <identifiersep> download <identifiersep> checksum ( configuration . get <identifiersep> distribution ( ) . to <identifiersep> string ( ) , local <identifiersep> zip <identifiersep> file , distribution <identifiersep> sha256sum ) ; logger . log ( <string_literal> + local <identifiersep> zip <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) + <string_literal> + dist <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; unzip ( local <identifiersep> zip <identifiersep> file , dist <identifiersep> dir ) ; file root = get <identifiersep> and <identifiersep> verify <identifiersep> distribution <identifiersep> root ( dist <identifiersep> dir , safe <identifiersep> distribution <identifiersep> url . to <identifiersep> string ( ) ) ; <ect>
return ; } file gradle <identifiersep> command = new file ( gradle <identifiersep> home , <string_literal> ) ; string error <identifiersep> message = null ; try { process <identifiersep> builder pb = new process <identifiersep> builder ( <string_literal> , <string_literal> , gradle <identifiersep> command . get <identifiersep> canonical <identifiersep> path ( ) ) ; process p = pb . start ( ) ; <LOG> if ( p . wait <identifiersep> for ( ) == 0 ) { } else { buffered <identifiersep> reader is = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( p . get <identifiersep> input <identifiersep> stream ( ) ) ) ; formatter stdout = new formatter ( ) ; string line ; while ( ( line = is . read <identifiersep> line ( ) ) != null ) { <ect>
error <identifiersep> message = stdout . to <identifiersep> string ( ) ; } } catch ( io <identifiersep> exception e ) { error <identifiersep> message = e . get <identifiersep> message ( ) ; } catch ( interrupted <identifiersep> exception e ) { error <identifiersep> message = e . get <identifiersep> message ( ) ; } if ( error <identifiersep> message != null ) { <LOG> logger . log ( <string_literal> + gradle <identifiersep> command . get <identifiersep> absolute <identifiersep> path ( ) ) ; } } private boolean is <identifiersep> windows ( ) { string os <identifiersep> name = system . get <identifiersep> property ( <string_literal> ) . to <identifiersep> lower <identifiersep> case ( locale . us ) ; if ( os <identifiersep> name . index <identifiersep> of ( <string_literal> ) > - 1 ) { return true ; } return false ; <ect>
if ( package <identifiersep> tests ) { build += ' <comment> <LOG> build <identifiersep> file . rename <identifiersep> to ( new file ( working <identifiersep> dir , <string_literal> ) ) } build <identifiersep> file . text = build } def global <identifiersep> exclusions = { project - > def exclusions = '' def enforcer <identifiersep> plugin = plugin ( 'maven - enforcer - plugin' , project ) def enforce <identifiersep> goal = plugin <identifiersep> goal ( 'enforce' , enforcer <identifiersep> plugin ) <ect>
import org . junit . experimental . categories . category ; import org . junit . runner . run <identifiersep> with ; @ run <identifiersep> with ( org . gradle . locales . class ) @ category ( org . gradle . category <identifiersep> a . class ) public class some <identifiersep> more <identifiersep> local <identifiersep> tests { @ test <LOG> public void some <identifiersep> more <identifiersep> test1 ( ) { } @ test public void some <identifiersep> more <identifiersep> test2 ( ) { system . out . println ( <string_literal> + locale <identifiersep> holder . get ( ) ) ; } } <ect>
import org . junit . test ; import org . junit . experimental . categories . category ; import org . junit . runner . run <identifiersep> with ; @ run <identifiersep> with ( org . gradle . locales . class ) public class some <identifiersep> locale <identifiersep> tests { @ test <LOG> public void ok1 ( ) { } @ test @ category ( org . gradle . category <identifiersep> a . class ) public void ok2 ( ) { system . out . println ( <string_literal> + locale <identifiersep> holder . get ( ) ) ; } <ect>
<comment> package org . gradle ; public class other <identifiersep> test { @ org . junit . test <LOG> public void ok ( ) throws exception { } <ect>
package org . gradle ; public class ok <identifiersep> test { @ org . junit . test public void ok ( ) throws exception { system . err . println ( <string_literal> ) ; } @ org . junit . test <LOG> public void another <identifiersep> ok ( ) { system . err . println ( <string_literal> ) ; } } <ect>
package org . gradle ; import org . junit . runner . run <identifiersep> with ; import org . junit . runners . suite ; @ run <identifiersep> with ( suite . class ) @ suite . suite <identifiersep> classes ( { ok <identifiersep> test . class , other <identifiersep> test . class } ) public class a <identifiersep> suite { <LOG> static { } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { <ect>
@ run <identifiersep> with ( suite . class ) @ suite . suite <identifiersep> classes ( { ok <identifiersep> test . class , other <identifiersep> test . class } ) public class a <identifiersep> suite { static { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { <LOG> system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <ect>
static { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ org . junit . after <identifiersep> class public static void end ( ) { system . err . println ( <string_literal> ) ; } } <ect>
public class some <identifiersep> suite extends test <identifiersep> case { public static test suite ( ) { final test <identifiersep> suite suite = new test <identifiersep> suite ( ) ; suite . add <identifiersep> test <identifiersep> suite ( some <identifiersep> test1 . class ) ; suite . add <identifiersep> test <identifiersep> suite ( some <identifiersep> test2 . class ) ; test <identifiersep> setup wrapped <identifiersep> suite = new junit . extensions . test <identifiersep> setup ( suite ) { <LOG> protected void set <identifiersep> up ( ) { system . err . println ( <string_literal> ) ; } protected void tear <identifiersep> down ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } ; <ect>
suite . add <identifiersep> test <identifiersep> suite ( some <identifiersep> test1 . class ) ; suite . add <identifiersep> test <identifiersep> suite ( some <identifiersep> test2 . class ) ; test <identifiersep> setup wrapped <identifiersep> suite = new junit . extensions . test <identifiersep> setup ( suite ) { protected void set <identifiersep> up ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> protected void tear <identifiersep> down ( ) { system . err . println ( <string_literal> ) ; } } ; return wrapped <identifiersep> suite ; } } <ect>
import cucumber . api . java . en . given ; import cucumber . api . java . en . then ; import cucumber . api . java . en . when ; public class hello <identifiersep> stepdefs { @ given ( <string_literal> ) <LOG> public void i <identifiersep> have <identifiersep> a <identifiersep> hello <identifiersep> app <identifiersep> with ( ) { } @ when ( <string_literal> ) public void i <identifiersep> ask <identifiersep> it <identifiersep> to <identifiersep> say <identifiersep> hi ( ) { system . out . println ( <string_literal> ) ; } @ then ( <string_literal> ) public void it <identifiersep> should <identifiersep> answer <identifiersep> with ( ) { <ect>
public void i <identifiersep> have <identifiersep> a <identifiersep> hello <identifiersep> app <identifiersep> with ( ) { system . out . println ( <string_literal> ) ; } @ when ( <string_literal> ) public void i <identifiersep> ask <identifiersep> it <identifiersep> to <identifiersep> say <identifiersep> hi ( ) { system . out . println ( <string_literal> ) ; } @ then ( <string_literal> ) <LOG> public void it <identifiersep> should <identifiersep> answer <identifiersep> with ( ) { } <ect>
$ { maven <identifiersep> central <identifiersep> repository ( ) } dependencies { test <identifiersep> compile 'junit : junit : <number_literal> . 12' } <string_literal> <string_literal> src / test / java / some <identifiersep> test . java <string_literal> <string_literal> import org . junit . * ; public class some <identifiersep> test { <LOG> @ test public void foo ( ) { } } <string_literal> <string_literal> test <string_literal> some <identifiersep> test <string_literal> <ect>
test { use <identifiersep> test <identifiersep> ng ( ) reports . junit <identifiersep> xml . output <identifiersep> per <identifiersep> test <identifiersep> case = true on <identifiersep> output { test , event - > print <string_literal> } } <string_literal> <string_literal> src / test / java / foo <identifiersep> test . java <string_literal> <string_literal> import org . testng . annotations . * ; <LOG> public class foo <identifiersep> test { public foo <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { <ect>
<string_literal> <string_literal> src / test / java / foo <identifiersep> test . java <string_literal> <string_literal> import org . testng . annotations . * ; public class foo <identifiersep> test { static { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } public foo <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ before <identifiersep> class public static void before <identifiersep> class ( ) { } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . print ( <string_literal> ) ; system . out . print ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . print ( <string_literal> ) ; system . out . print ( <string_literal> ) ; <LOG> system . out . println ( ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { <ect>
system . out . print ( <string_literal> ) ; system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ after <identifiersep> test public void after <identifiersep> test ( ) { } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> attaches events to correct test descriptors of a suite <string_literal> test . use <identifiersep> test <identifiersep> ng { suites 'suite . xml' } <string_literal> <ect>
public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) <LOG> public void test2 ( ) { } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> <ect>
package org . company ; import org . testng . assert ; import org . testng . annotations . test ; @ test public class system <identifiersep> out <identifiersep> test { @ test <LOG> public void test <identifiersep> out ( ) { assert . assert <identifiersep> true ( true ) ; } } <string_literal> <string_literal> <string_literal> < ! doctype suite system <string_literal> > < suite name = <string_literal> > <ect>
def create <identifiersep> tests ( int test <identifiersep> count , int thread <identifiersep> count ) { string suite <identifiersep> xml = <string_literal> test <identifiersep> count . times { x - > file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) { } } } <string_literal> <string_literal> < test name = 't$ { x } ' > < classes > < class name = 'foo$ { x } test' / > < / classes > < / test > \\ n <string_literal> suite . xml <string_literal> <string_literal> < ? xml version = <string_literal> encoding = <string_literal> ? > < ! doctype suite system <string_literal> > < suite name = <string_literal> parallel = <string_literal> thread - count = <string_literal> > <ect>
} ; } private string data ; @ factory ( data <identifiersep> provider = <string_literal> ) public test <identifiersep> factory ( string data ) { this . data = data ; } @ before <identifiersep> class <LOG> public void before <identifiersep> class ( ) { } @ test public void test1 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { <ect>
public void before <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test public void test1 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) <LOG> public void test2 ( ) { } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> <ect>
true } private void setup <identifiersep> test <identifiersep> cases ( ) { file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> @ test public void passing ( ) { system . err . println ( <string_literal> ) ; } @ test public void failing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; <ect>
import org . testng . annotations . * ; import static org . testng . assert . * ; public class mixed <identifiersep> methods <identifiersep> test { @ test public void passing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ test public void failing ( ) { system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } @ test public void passing2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void failing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } <LOG> @ test public void passing2 ( ) { system . err . println ( <string_literal> ) ; } @ test public void failing2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } @ test public void passing2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ test public void failing2 ( ) { system . err . println ( <string_literal> ) ; fail ( <string_literal> ) ; } @ test ( enabled = false ) public void skipped ( ) { } } <string_literal> <string_literal> src / test / java / org / passing <identifiersep> test . java <string_literal> <string_literal> package org ; <ect>
fail ( <string_literal> ) ; } @ test ( enabled = false ) public void skipped ( ) { } } <string_literal> <string_literal> src / test / java / org / passing <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; public class passing <identifiersep> test { <LOG> @ test public void passing ( ) { } @ test public void passing2 ( ) { } } <string_literal> <string_literal> src / test / java / org / failing <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; import static org . testng . assert . * ; <ect>
@ test ( enabled = false ) public void skipped ( ) { } @ test public void passing ( ) { } } <string_literal> <string_literal> src / test / java / org / encoding <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; public class encoding <identifiersep> test { <LOG> @ test public void encodes <identifiersep> cdata ( ) { system . out . print ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> < html allowed , cdata closing token ] ] > encoded ! <string_literal> no eol , <string_literal> <LOG> system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / org / parameterized <identifiersep> test . java <string_literal> <string_literal> package org ; <ect>
<string_literal> <string_literal> src / test / java / org / parameterized <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; import static org . testng . assert . * ; public class parameterized <identifiersep> test { @ test ( data <identifiersep> provider = <string_literal> ) <LOG> public void p1 ( string var1 , string var2 ) { system . err . println ( <string_literal> + var2 ) ; assert <identifiersep> equals ( var1 , <string_literal> ) ; } @ data <identifiersep> provider ( name = <string_literal> ) public object [ ] [ ] provider1 ( ) { return new object [ ] [ ] { <ect>
} ; } } <string_literal> <string_literal> src / test / java / org / output <identifiersep> lifecycle <identifiersep> test . java <string_literal> <string_literal> package org ; import org . testng . annotations . * ; import static org . testng . assert . * ; public class output <identifiersep> lifecycle <identifiersep> test { <LOG> public output <identifiersep> lifecycle <identifiersep> test ( ) { system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
import static org . testng . assert . * ; public class output <identifiersep> lifecycle <identifiersep> test { public output <identifiersep> lifecycle <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> class <LOG> public static void before <identifiersep> class ( ) { system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test <LOG> public void before <identifiersep> test ( ) { system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ test public void m1 ( ) { system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> test <ect>
test . working <identifiersep> dir = <string_literal> <string_literal> <string_literal> src / test / java / some <identifiersep> test . java <string_literal> <string_literal> import org . junit . * ; public class some <identifiersep> test { <LOG> @ test public void foo ( ) { } } <string_literal> <string_literal> test <string_literal> https : <comment> <ect>
<string_literal> ) test <identifiersep> directory . file ( 'src / test / java / org / gradle / abstract <identifiersep> test . java' ) . writelns ( <string_literal> , <string_literal> , <string_literal> , <LOG> <string_literal> , <string_literal> , <string_literal> ) test <identifiersep> directory . file ( 'src / test / java / org / gradle / some <identifiersep> test . java' ) . writelns ( <string_literal> , <string_literal> , <ect>
$ { maven <identifiersep> central <identifiersep> repository ( ) } dependencies { test <identifiersep> compile 'junit : junit : <number_literal> . 12' } <string_literal> <string_literal> src / test / java / encoding <identifiersep> test . java <string_literal> <string_literal> import org . junit . * ; public class encoding <identifiersep> test { <LOG> @ test public void encodes <identifiersep> cdata ( ) { system . out . print ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> < html allowed , cdata closing token ] ] > encoded ! <string_literal> no eol , <string_literal> <LOG> system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void encodes <identifiersep> attribute <identifiersep> values ( ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
<string_literal> <string_literal> src / test / java / conditional <identifiersep> failing <identifiersep> test <identifiersep> $ { it } . java <string_literal> <string_literal> import org . junit . test ; public class conditional <identifiersep> failing <identifiersep> test <identifiersep> $ { it } { @ test <LOG> public void failed <identifiersep> test ( ) { if ( <string_literal> . equals ( system . get <identifiersep> property ( <string_literal> ) ) ) { throw new runtime <identifiersep> exception ( ) ; } } } <string_literal> <string_literal> <string_literal> <ect>
<string_literal> <string_literal> captures logging output events <string_literal> src / test / java / ok <identifiersep> test . java <string_literal> <string_literal> public class ok <identifiersep> test { static { system . out . println ( <string_literal> ) ; } <LOG> public ok <identifiersep> test ( ) { } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; <ect>
public class ok <identifiersep> test { static { system . out . println ( <string_literal> ) ; } public ok <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . before public void before ( ) { <ect>
public ok <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; } @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . before public void before ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <ect>
system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . before public void before ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . after public void after ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . test <ect>
@ org . junit . before public void before ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after public void after ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . test public void ok ( ) { system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; <ect>
@ org . junit . test public void ok ( ) { system . out . print ( <string_literal> ) ; system . out . println ( ) ; system . err . println ( <string_literal> ) ; } @ org . junit . test <LOG> public void another <identifiersep> ok ( ) { system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> <string_literal> test class ok <identifiersep> test - > class loaded <ect>
<comment> <LOG> system . out . print ( <string_literal> ) ; <comment> <ect>
private create <identifiersep> test <identifiersep> abc ( ) { file ( 'src / test / java / a <identifiersep> test . java' ) < < <string_literal> <string_literal> a <identifiersep> test ! <string_literal> <string_literal> file ( 'src / test / java / b <identifiersep> test . java' ) < < <string_literal> <string_literal> <LOG> public class b <identifiersep> test { } <string_literal> <string_literal> <string_literal> import $imports ; public class c <identifiersep> test { @ test public void test ( ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
def <string_literal> ( ) { given : def test = file ( <string_literal> ) test < < <string_literal> <string_literal> <LOG> @ test public void shows <identifiersep> output <identifiersep> when <identifiersep> passing ( ) { system . err . println ( <string_literal> ) ; assert . assert <identifiersep> true ( true ) ; } @ test public void shows <identifiersep> output <identifiersep> when <identifiersep> failing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
import org . junit . * ; public class some <identifiersep> test { @ test public void shows <identifiersep> output <identifiersep> when <identifiersep> passing ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; assert . assert <identifiersep> true ( true ) ; } <LOG> @ test public void shows <identifiersep> output <identifiersep> when <identifiersep> failing ( ) { system . err . println ( <string_literal> ) ; assert . assert <identifiersep> true ( false ) ; } } <string_literal> <string_literal> <string_literal> <ect>
def <string_literal> ( ) { given : def test = file ( <string_literal> ) test < < <string_literal> <string_literal> <LOG> @ test public void foo ( ) { } } <string_literal> <string_literal> <string_literal> apply plugin : 'java' $ { maven <identifiersep> central <identifiersep> repository ( ) } <ect>
ignore <identifiersep> when <identifiersep> j <identifiersep> unit <identifiersep> platform ( ) def test = file ( <string_literal> ) test < < <string_literal> <string_literal> <LOG> @ test public void foo ( ) { system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <string_literal> apply plugin : 'java' <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> org . gradle . testing . super <identifiersep> test # failing <string_literal> failing test <string_literal> <LOG> @ category ( super <identifiersep> class <identifiersep> tests . class ) @ test public void passing ( ) { } } <string_literal> <string_literal> src / test / java / org / gradle / testing / sub <identifiersep> test . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude public class sub <identifiersep> test { @ category ( sub <identifiersep> class <identifiersep> tests . class ) @ test public void only <identifiersep> sub ( ) { <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> org . gradle . testing . sub <identifiersep> test # only <identifiersep> sub <string_literal> category <string_literal> sub <string_literal> category <string_literal> <LOG> @ category ( sub <identifiersep> class <identifiersep> tests . class ) @ test public void passing ( ) { } } <string_literal> <string_literal> src / test / java / org / gradle / testing / super <identifiersep> class <identifiersep> tests . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude public class super <identifiersep> class <identifiersep> tests { } <string_literal> <string_literal> <ect>
test . reports . junit <identifiersep> xml . output <identifiersep> per <identifiersep> test <identifiersep> case = true <string_literal> <string_literal> src / test / java / output <identifiersep> lifecycle <identifiersep> test . java <string_literal> <string_literal> import org . junit . * ; public class output <identifiersep> lifecycle <identifiersep> test { public output <identifiersep> lifecycle <identifiersep> test ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <ect>
public class output <identifiersep> lifecycle <identifiersep> test { public output <identifiersep> lifecycle <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before <identifiersep> class public static void before <identifiersep> class ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ before public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { <ect>
@ before <identifiersep> class public static void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ before public void before <identifiersep> test ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; } @ before public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after public void after <identifiersep> test ( ) { <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ after public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class <ect>
system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after public void after <identifiersep> test ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
@ after public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { <LOG> system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> test <string_literal> output <identifiersep> lifecycle <identifiersep> test <string_literal> <ect>
default collection < dynamic <identifiersep> test > dynamic <identifiersep> tests <identifiersep> from <identifiersep> collection ( ) { return arrays . as <identifiersep> list ( dynamic <identifiersep> test . dynamic <identifiersep> test ( <string_literal> , ( ) - > assert <identifiersep> true ( true ) ) , dynamic <identifiersep> test . dynamic <identifiersep> test ( <string_literal> , ( ) - > assert <identifiersep> equals ( <number_literal> , <number_literal> * <number_literal> ) ) ) ; } @ before <identifiersep> each <LOG> default void before <identifiersep> each ( ) { } } ''' file ( 'src / test / java / org / gradle / test . java' ) < < ''' package org . gradle ; public class test implements test <identifiersep> interface <identifiersep> dynamic <identifiersep> tests <identifiersep> demo { } ''' <ect>
result <identifiersep> processor <identifiersep> actor = actor <identifiersep> factory . create <identifiersep> blocking <identifiersep> actor ( event <identifiersep> generator ) ; test <identifiersep> result <identifiersep> processor thread <identifiersep> safe <identifiersep> result <identifiersep> processor = result <identifiersep> processor <identifiersep> actor . get <identifiersep> proxy ( test <identifiersep> result <identifiersep> processor . class ) ; test <identifiersep> class <identifiersep> execution <identifiersep> listener thread <identifiersep> safe <identifiersep> test <identifiersep> class <identifiersep> listener = result <identifiersep> processor <identifiersep> actor . get <identifiersep> proxy ( test <identifiersep> class <identifiersep> execution <identifiersep> listener . class ) ; executor = create <identifiersep> test <identifiersep> executor ( thread <identifiersep> safe <identifiersep> result <identifiersep> processor , thread <identifiersep> safe <identifiersep> test <identifiersep> class <identifiersep> listener ) ; } protected abstract action < string > create <identifiersep> test <identifiersep> executor ( test <identifiersep> result <identifiersep> processor thread <identifiersep> safe <identifiersep> result <identifiersep> processor , test <identifiersep> class <identifiersep> execution <identifiersep> listener thread <identifiersep> safe <identifiersep> test <identifiersep> class <identifiersep> listener ) ; @ override <LOG> public void process <identifiersep> test <identifiersep> class ( test <identifiersep> class <identifiersep> run <identifiersep> info test <identifiersep> class ) { executor . execute ( test <identifiersep> class . get <identifiersep> test <identifiersep> class <identifiersep> name ( ) ) ; } @ override public void stop ( ) { result <identifiersep> processor <identifiersep> actor . stop ( ) ; } @ override <ect>
try { class <identifiersep> file <identifiersep> extracted = jar <identifiersep> util . extract <identifiersep> zip <identifiersep> entry ( jar <identifiersep> file , class <identifiersep> file <identifiersep> name , extracted <identifiersep> class <identifiersep> file ) ; if ( class <identifiersep> file <identifiersep> extracted ) { class <identifiersep> file <identifiersep> source <identifiersep> jar = jar <identifiersep> file ; } } catch ( io <identifiersep> exception e ) { throw new gradle <identifiersep> exception ( <string_literal> + jar <identifiersep> file + <string_literal> , e ) ; } } <LOG> if ( class <identifiersep> file <identifiersep> extracted ) { extracted <identifiersep> jar <identifiersep> classes . put ( class <identifiersep> name , extracted <identifiersep> class <identifiersep> file ) ; } } <comment> <ect>
<comment> package org . gradle ; import org . testng . assert ; public class foo <identifiersep> test { @ org . testng . annotations . test public void ok ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . testng . annotations . test public void fail ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; assert . fail ( ) ; } } <ect>
import org . testng . assert ; public class foo <identifiersep> test { @ org . testng . annotations . test public void ok ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . testng . annotations . test public void fail ( ) { <LOG> system . out . println ( <string_literal> ) ; assert . fail ( ) ; } } <ect>
<comment> package org . gradle ; import org . junit . assert ; public class other <identifiersep> test { @ org . junit . test public void other <identifiersep> ok ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . test public void other <identifiersep> fail ( ) { assert . fail ( ) ; } } <ect>
<comment> package org . gradle ; import org . junit . assert ; public class test { @ org . junit . test public void ok ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . test public void fail ( ) { assert . fail ( ) ; } } <ect>
import org . junit . runner . run <identifiersep> with ; import org . junit . runners . suite ; @ run <identifiersep> with ( suite . class ) @ suite . suite <identifiersep> classes ( { test . class , other <identifiersep> test . class } ) public class test <identifiersep> suite { @ org . junit . before <identifiersep> class public static void init ( ) { <LOG> system . out . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <ect>
* * < pre class = 'auto <identifiersep> tested' > * apply plugin : 'java' * * test { * on <identifiersep> output { descriptor , event - & gt ; <LOG> * if ( event . destination == test <identifiersep> output <identifiersep> event . destination . std <identifiersep> err ) { * } * } * } * < / pre > * <ect>
return ; } } simple <identifiersep> names . put ( class <identifiersep> meta <identifiersep> data . get <identifiersep> simple <identifiersep> name ( ) , class <identifiersep> meta <identifiersep> data . get <identifiersep> class <identifiersep> name ( ) ) ; packages . add ( package <identifiersep> name ) ; } } ) ; try ( print <identifiersep> writer mapping <identifiersep> file <identifiersep> writer = new print <identifiersep> writer ( new file <identifiersep> writer ( get <identifiersep> mapping <identifiersep> dest <identifiersep> file ( ) . get <identifiersep> as <identifiersep> file ( ) . get ( ) ) ) ) { for ( map . entry < string , collection < string > > entry : simple <identifiersep> names . as <identifiersep> map ( ) . entry <identifiersep> set ( ) ) { <LOG> if ( entry . get <identifiersep> value ( ) . size ( ) > 1 ) { for ( string class <identifiersep> name : entry . get <identifiersep> value ( ) ) { system . out . println ( <string_literal> + class <identifiersep> name ) ; } } mapping <identifiersep> file <identifiersep> writer . print ( entry . get <identifiersep> key ( ) ) ; mapping <identifiersep> file <identifiersep> writer . print ( <string_literal> ) ; for ( string class <identifiersep> name : entry . get <identifiersep> value ( ) ) { <ect>
if ( last <identifiersep> child instanceof text ) { last <identifiersep> child . set <identifiersep> text <identifiersep> content ( last <identifiersep> child . get <identifiersep> text <identifiersep> content ( ) . replace <identifiersep> first ( <string_literal> , <string_literal> ) ) ; } value <identifiersep> titles . add ( element ) ; } <comment> <LOG> for ( class <identifiersep> doc super <identifiersep> type : super <identifiersep> types ) { for ( property <identifiersep> doc property <identifiersep> doc : super <identifiersep> type . get <identifiersep> class <identifiersep> properties ( ) ) { map < string , extra <identifiersep> attribute <identifiersep> doc > additional <identifiersep> values = new linked <identifiersep> hash <identifiersep> map < string , extra <identifiersep> attribute <identifiersep> doc > ( ) ; for ( extra <identifiersep> attribute <identifiersep> doc attribute <identifiersep> doc : property <identifiersep> doc . get <identifiersep> additional <identifiersep> values ( ) ) { string key = attribute <identifiersep> doc . get <identifiersep> key ( ) ; if ( inherited <identifiersep> value <identifiersep> title <identifiersep> mapping . get ( key ) != null ) { <ect>
import org . gradle . api . logging . logger import org . gradle . api . logging . logging class default <identifiersep> remote <identifiersep> gradle <identifiersep> version <identifiersep> resolver implements remote <identifiersep> gradle <identifiersep> version <identifiersep> resolver { private static final logger logger = logging . get <identifiersep> logger ( default <identifiersep> remote <identifiersep> gradle <identifiersep> version <identifiersep> resolver ) public static final string base <identifiersep> url = 'https : <comment> <LOG> url url = new url ( <string_literal> ) def version = new json <identifiersep> slurper ( ) . parse <identifiersep> text ( new url ( <string_literal> ) . text ) if ( version . empty ) { throw new gradle <identifiersep> exception ( <string_literal> ) } version } } <ect>
< property name = <string_literal> value = <string_literal> / > < property name = <string_literal> value = <string_literal> / > < property name = <string_literal> value = <string_literal> / > < / properties > $ { render <identifiersep> last <identifiersep> change ( last <identifiersep> change <identifiersep> id ) } < / build > <LOG> <string_literal> <string_literal> build <identifiersep> queue <string_literal> <ect>
val daemon <identifiersep> pids = new <identifiersep> key <identifiersep> set < string > ( ) @ task <identifiersep> action fun clean <identifiersep> up <identifiersep> daemons ( ) : unit = project . run { val already <identifiersep> killed = mutable <identifiersep> set <identifiersep> of < string > ( ) for <identifiersep> each <identifiersep> java <identifiersep> process { suspicious <identifiersep> daemons . for <identifiersep> each { ( suite , pids ) - > <LOG> if ( pid in pids && pid ! in already <identifiersep> killed ) { pkill ( pid ) } } } } fun new <identifiersep> daemon <identifiersep> listener ( ) = object : test <identifiersep> listener { override fun before <identifiersep> test ( test : test <identifiersep> descriptor ) = unit override fun after <identifiersep> test ( test : test <identifiersep> descriptor , result : test <identifiersep> result ) = unit <ect>
<comment> if ( is <identifiersep> function ) functions <identifiersep> from <identifiersep> current . filter { it . name == name } else list <identifiersep> of ( ) , containing <identifiersep> class , object : non <identifiersep> reporting <identifiersep> override <identifiersep> strategy ( ) { override fun add <identifiersep> fake <identifiersep> override ( fake <identifiersep> override : callable <identifiersep> member <identifiersep> descriptor ) { overriding <identifiersep> util . resolve <identifiersep> unknown <identifiersep> visibility <identifiersep> for <identifiersep> member ( fake <identifiersep> override , null ) result . add ( fake <identifiersep> override ) } <LOG> override fun conflict ( from <identifiersep> super : callable <identifiersep> member <identifiersep> descriptor , from <identifiersep> current : callable <identifiersep> member <identifiersep> descriptor ) { } } ) } } return result . compact ( ) } override fun print <identifiersep> scope <identifiersep> structure ( p : printer ) { p . println ( <string_literal> ) } } <ect>
if ( predicate ( start ) ) return true initialize ( ) val deque = supertypes <identifiersep> deque ! ! val visited <identifiersep> supertypes = supertypes <identifiersep> set ! ! deque . push ( start ) while ( deque . is <identifiersep> not <identifiersep> empty ( ) ) { <LOG> if ( visited <identifiersep> supertypes . size > <number_literal> ) { } val current = deque . pop ( ) if ( ! visited <identifiersep> supertypes . add ( current ) ) continue val policy = supertypes <identifiersep> policy ( current ) . take <identifiersep> if { it != supertypes <identifiersep> policy . none } ? : continue for ( supertype in current . constructor . supertypes ) { val new <identifiersep> type = policy . transform <identifiersep> type ( supertype ) <ect>
} ) load <identifiersep> descriptor <identifiersep> util . compile <identifiersep> java <identifiersep> with <identifiersep> annotations <identifiersep> jar ( sources , tmpdir ) } file <identifiersep> name . ends <identifiersep> with ( <string_literal> ) - > { val environment = kotlin <identifiersep> test <identifiersep> utils . create <identifiersep> environment <identifiersep> with <identifiersep> jdk <identifiersep> and <identifiersep> nullability <identifiersep> annotations <identifiersep> from <identifiersep> idea ( my <identifiersep> test <identifiersep> root <identifiersep> disposable , configuration <identifiersep> kind . all , jdk <identifiersep> kind ) <LOG> for ( root in environment . configuration . get <identifiersep> list ( jvm <identifiersep> configuration <identifiersep> keys . content <identifiersep> roots ) ) { } val kt <identifiersep> file = kotlin <identifiersep> test <identifiersep> utils . create <identifiersep> file ( file . path , text , environment . project ) generation <identifiersep> utils . compile <identifiersep> file <identifiersep> to ( kt <identifiersep> file , environment , tmpdir ) } } } private fun create <identifiersep> reflected <identifiersep> package <identifiersep> view ( class <identifiersep> loader : url <identifiersep> class <identifiersep> loader , module <identifiersep> name : string ) : synthetic <identifiersep> package <identifiersep> view <identifiersep> for <identifiersep> test { val module <identifiersep> data = runtime <identifiersep> module <identifiersep> data . create ( class <identifiersep> loader ) module <identifiersep> data . package <identifiersep> part <identifiersep> provider . register <identifiersep> module ( module <identifiersep> name ) <ect>
public class a { public void a <identifiersep> void ( ) { <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) ; } <ect>
<LOG> <comment> <ect>
public class test { public static class b { public static class c { } public c c ( ) { return new c ( ) ; } } public void a ( ) { <LOG> b b = new b ( ) ; string a = 1 + <string_literal> ; system . out . println ( b . c ( ) + <string_literal> ) ; } public static void main ( string [ ] args ) { string p = new test ( ) + <string_literal> ; } <ect>
class c { void foo ( object o ) { <LOG> if ( ! ( o instanceof string ) ) return ; } <ect>
<comment> <LOG> public void run ( ) { <string_literal> + to <identifiersep> string ( ) ) ; } <ect>
package foo ; <comment> <LOG> <comment> <ect>
import java . util . array <identifiersep> list ; <comment> <LOG> system . out . println ( <string_literal> ) ; <comment> <ect>
class a { <LOG> public void foo ( int p ) { } public synchronized void foo ( ) { foo ( calc <identifiersep> something ( ) ) ; } <comment> <ect>
interface i { void foo ( int i , char c , string s ) ; void bar ( ) ; } class a implements i { <LOG> public void foo ( int i , char c , string s ) { } public void foo ( int i , char c ) { foo ( i , c , <string_literal> ) ; } public void foo ( int i ) { foo ( i , 'a' , <string_literal> ) ; } public void bar ( ) { <ect>
file <identifiersep> input <identifiersep> stream fstream = new file <identifiersep> input <identifiersep> stream ( ) ; data <identifiersep> input <identifiersep> stream in = new data <identifiersep> input <identifiersep> stream ( fstream ) ; buffered <identifiersep> reader br = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( in ) ) ; string str <identifiersep> line ; while ( ( str <identifiersep> line = br . read <identifiersep> line ( ) ) != null ) { system . out . println ( str <identifiersep> line ) ; } in . close ( ) ; <LOG> } catch ( exception e ) { } } <ect>
static container my <identifiersep> container = new container ( ) ; } class test { void test ( ) { if ( one . my <identifiersep> container . my <identifiersep> boolean ) system . out . println ( <string_literal> ) ; string s = one . my <identifiersep> container . my <identifiersep> boolean ? <string_literal> : <string_literal> ; <LOG> while ( one . my <identifiersep> container . my <identifiersep> boolean ) do { system . out . println ( <string_literal> ) ; } while ( one . my <identifiersep> container . my <identifiersep> boolean ) } <ect>
<comment> <LOG> public static void main ( string [ ] args ) { } <ect>
<comment> <LOG> else if ( b ) else system . out . println ( <string_literal> ) if ( c ) { system . out . println ( <string_literal> ) } else if ( d ) { <ect>
if ( a ) system . out . println ( <string_literal> ) else if ( b ) system . out . println ( <string_literal> ) else system . out . println ( <string_literal> ) <LOG> if ( c ) { } else if ( d ) { system . out . println ( <string_literal> ) } <ect>
public class a { public void a <identifiersep> void ( ) { int i = 0 ; <LOG> if ( i > <number_literal> ) ; } <ect>
<comment> <LOG> if ( null == c . s ) { } } } <ect>
<comment> <LOG> if ( b ) else system . out . println ( <string_literal> ) <ect>
try ( input <identifiersep> stream stream = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( new byte [ <number_literal> ] ) ) { <comment> <LOG> finally { } } } <ect>
class a { void foo ( ) { system . out . println ( ) ; <LOG> system . out . println ( 1 ) ; system . out . print ( <string_literal> ) ; system . out . print ( 1 ) ; system . err . println ( ) ; system . err . println ( 1 ) ; } <ect>
private string x = <string_literal> ; public string get <identifiersep> x ( ) { system . out . println ( <string_literal> ) ; return x ; } public void set <identifiersep> x ( string x ) { this . x = x ; } <LOG> void foo ( ) { } <ect>
public class c { private string x = <string_literal> ; <LOG> public string get <identifiersep> x ( ) { return x ; } public void set <identifiersep> x ( string x ) { this . x = x ; } <ect>
public class c { private string x = <string_literal> ; c other = null ; public string get <identifiersep> x ( ) { return x ; } <LOG> void set <identifiersep> x ( string x ) { if ( other != null ) { this . other . x = x ; } this . x = x ; } <ect>
public class c { public string x = <string_literal> ; <LOG> public string get <identifiersep> x ( ) { return x ; } public void set <identifiersep> x ( string x ) { this . x = x ; } <ect>
public class c { protected string x = <string_literal> ; public string get <identifiersep> x ( ) { return x ; } <LOG> public void set <identifiersep> x ( string x ) { this . x = x ; } <ect>
public class c { private string x = <string_literal> ; public string get <identifiersep> x ( ) { return x ; } <LOG> public void set <identifiersep> x ( string x ) { this . x = x ; } <ect>
<comment> <LOG> case <number_literal> : system . out . println ( <string_literal> ) ; return <number_literal> ; default : system . out . println ( <string_literal> ) ; return 0 ; } <ect>
break } else { if ( result . properties . is <identifiersep> not <identifiersep> empty ( ) ) { expect <identifiersep> char <identifiersep> and <identifiersep> advance ( ' , ' ) } skip <identifiersep> spaces ( ) val key = parse <identifiersep> string ( ) <LOG> if ( key in result . properties ) { } skip <identifiersep> spaces ( ) expect <identifiersep> char <identifiersep> and <identifiersep> advance ( ' : ' ) result . properties [ key ] = parse <identifiersep> node ( ) } } return result } private fun parse <identifiersep> string ( ) : string { <ect>
val lhs = arg1 when ( lhs ) { is js <identifiersep> name <identifiersep> ref - > { lhs . qualifier = lhs . qualifier ? . extract <identifiersep> to <identifiersep> temporary ( ) } is js <identifiersep> array <identifiersep> access - > { lhs . array = lhs . array . extract <identifiersep> to <identifiersep> temporary ( ) } <LOG> else - > { } } } else { arg1 = arg1 . extract <identifiersep> to <identifiersep> temporary ( ) } arg2 = accept ( arg2 ) } override fun visit ( x : js <identifiersep> array <identifiersep> literal , ctx : js <identifiersep> context < js <identifiersep> node > ) : boolean { val elements = x . expressions <ect>
val should <identifiersep> not <identifiersep> be <identifiersep> escaped <identifiersep> file = file ( <string_literal> ) val cases <identifiersep> file = file ( <string_literal> ) val should <identifiersep> be <identifiersep> escaped <identifiersep> from <identifiersep> file = should <identifiersep> be <identifiersep> escaped <identifiersep> file . read <identifiersep> lines <identifiersep> or <identifiersep> null ( ) ? . drop ( 1 ) val should <identifiersep> not <identifiersep> be <identifiersep> escaped <identifiersep> from <identifiersep> file = should <identifiersep> not <identifiersep> be <identifiersep> escaped <identifiersep> file . read <identifiersep> lines <identifiersep> or <identifiersep> null ( ) ? . drop ( 1 ) val cases <identifiersep> from <identifiersep> file = cases <identifiersep> file . read <identifiersep> lines <identifiersep> or <identifiersep> null ( ) ? . drop ( 1 ) val is <identifiersep> creating <identifiersep> from <identifiersep> scratch = should <identifiersep> be <identifiersep> escaped <identifiersep> from <identifiersep> file != should <identifiersep> be <identifiersep> escaped || should <identifiersep> not <identifiersep> be <identifiersep> escaped <identifiersep> from <identifiersep> file != should <identifiersep> not <identifiersep> be <identifiersep> escaped || cases <identifiersep> from <identifiersep> file != cases <LOG> if ( ! test <identifiersep> data <identifiersep> dir . exists ( ) && ! test <identifiersep> data <identifiersep> dir . mkdirs ( ) ) { } else if ( is <identifiersep> creating <identifiersep> from <identifiersep> scratch ) { if ( test <identifiersep> data <identifiersep> dir . list <identifiersep> files ( ) ? . all { it . delete ( ) } != false ) { println ( <string_literal> ) } else { error ( <string_literal> ) <ect>
. replace ( test <identifiersep> block <identifiersep> marker , case . test <identifiersep> block ) . replace ( <string_literal> , <string_literal> ) . replace ( keyword <identifiersep> marker , keyword <identifiersep> with <identifiersep> escape <identifiersep> if <identifiersep> need ) val file <identifiersep> name = <string_literal> val test <identifiersep> data <identifiersep> file = file ( test <identifiersep> data <identifiersep> dir <identifiersep> path + <string_literal> + file <identifiersep> name ) if ( test <identifiersep> data <identifiersep> file . exists ( ) ) { <LOG> if ( is <identifiersep> creating <identifiersep> from <identifiersep> scratch ) { } } else if ( ! is <identifiersep> creating <identifiersep> from <identifiersep> scratch ) { error ( <string_literal> + <string_literal> ) } generators <identifiersep> file <identifiersep> util . write <identifiersep> file <identifiersep> if <identifiersep> content <identifiersep> changed ( test <identifiersep> data <identifiersep> file , out , false ) } } } if ( is <identifiersep> creating <identifiersep> from <identifiersep> scratch ) { <ect>
<comment> <LOG> get ( ) { return null } set ( v ) { log ( <string_literal> ) } public inline fun array < string > . boo ( ) { var a = g <ect>
<comment> <comment> <LOG> val a = get <identifiersep> a ( ) if ( a > b ) return a return b } fun box ( ) : string { val one = 1 val two = <number_literal> <ect>
<comment> <LOG> fun multiply <identifiersep> fun ( ) : ( int , int ) - > int { return { x , y - > x * y } } inline fun multiply <identifiersep> fun <identifiersep> inline ( ) : ( int , int ) - > int { log ( <string_literal> ) return { x , y - > x * y } <ect>
<comment> <LOG> fun sum ( a : int , b : int , c : int , d : int ) : int { return a + b + c + d } fun box ( ) : string { assert <identifiersep> equals ( <number_literal> , sum ( fizz ( 1 ) , buzz ( <number_literal> ) , fizz ( <number_literal> ) , buzz ( <number_literal> ) ) ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
<comment> <LOG> get ( ) { return array <identifiersep> of ( <string_literal> ) } val aa : array < string > get ( ) { log ( <string_literal> ) return array <identifiersep> of ( <string_literal> ) <ect>
fun log ( string : string ) { log += <string_literal> } fun pull <identifiersep> log ( ) : string { val string = log log = <string_literal> return string } <LOG> fun < t > fizz ( x : t ) : t { return x } inline fun < t > buzz ( x : t ) : t { log ( <string_literal> ) return x <ect>
<comment> <LOG> init { } val x = <number_literal> } inline fun bar ( value : int ) { log ( <string_literal> ) log ( <string_literal> ) log ( <string_literal> ) <ect>
package foo object a { init { log ( <string_literal> ) } val x = <number_literal> } inline fun bar ( value : int ) { <LOG> log ( <string_literal> ) log ( <string_literal> ) } fun box ( ) : string { bar ( a . x ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
package foo interface a { val b : b } interface b { fun c ( a : any ? ) } val a : a <LOG> get ( ) { return object : a { override val b : b get ( ) { log ( <string_literal> ) return object : b { <ect>
log ( <string_literal> ) return object : a { override val b : b get ( ) { log ( <string_literal> ) return object : b { <LOG> override fun c ( a : any ? ) { } } } } } val g : any ? get ( ) { log ( <string_literal> ) return <string_literal> } inline fun foo ( ) : any ? { <ect>
override fun c ( a : any ? ) { log ( <string_literal> ) } } } } } val g : any ? get ( ) { log ( <string_literal> ) return <string_literal> } <LOG> inline fun foo ( ) : any ? { return g ; } inline fun bar ( ) : any ? { return g ; } inline fun baz ( ) : any ? { return log ( <string_literal> ) ; <ect>
inline fun baz ( ) : any ? { return log ( <string_literal> ) ; } inline fun boo ( a : any ? ) : any ? { return log ( <string_literal> ) ; } fun box ( ) : string { log ( <string_literal> ) <LOG> a . b . c ( g ) a . b . c ( foo ( ) ) log ( <string_literal> ) a . b . c ( bar ( ) ) log ( <string_literal> ) a . b . c ( baz ( ) ) <ect>
var j = - 1 do { ++ j if ( j == 1 ) { if ( i == <number_literal> ) continue @ outer else continue } log ( <string_literal> ) <LOG> } while ( j < <number_literal> ) } while ( predicate ( i ) ) } fun box ( ) : string { bar { log ( <string_literal> ) it < <number_literal> <ect>
<comment> <LOG> init { } val value = x + y } fun box ( ) : string { assert <identifiersep> equals ( <number_literal> , sum ( fizz ( 1 ) , buzz ( <number_literal> ) ) . value ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
<comment> <LOG> return { a + it } } } inline fun < t : any > id ( x : t ) : t { log ( x . to <identifiersep> string ( ) ) return x } fun box ( ) : string { <ect>
a , b { init { log ( <string_literal> ) } } , c ; <LOG> init { } } var l = <string_literal> fun log ( s : string ) { l += s + <string_literal> } fun box ( ) : string { log ( <string_literal> ) <ect>
log ( <string_literal> ) } } var l = <string_literal> fun log ( s : string ) { l += s + <string_literal> } fun box ( ) : string { log ( <string_literal> ) <LOG> e . a . to <identifiersep> string ( ) e . b . to <identifiersep> string ( ) log ( <string_literal> ) e . c . to <identifiersep> string ( ) if ( l != <string_literal> ) return <string_literal> return <string_literal> <ect>
fun baz ( x : string ) = <string_literal> inline fun foo ( ) : string { return baz ( bar { <string_literal> } ) } inline fun bar ( noinline x : ( ) - > string ) : string { return <string_literal> + baz ( boo { should <identifiersep> be <identifiersep> inlined ( ) ; x ( ) } ) + <string_literal> } fun boo ( x : ( ) - > string ) = x ( ) <LOG> inline fun should <identifiersep> be <identifiersep> inlined ( ) { } fun box ( ) : string { val result = foo ( ) if ( result != <string_literal> ) return <string_literal> if ( global != <string_literal> ) return <string_literal> return <string_literal> <ect>
<comment> <LOG> fun baz ( x : string ) { } fun baz ( x : string , i : int ) { log ( <string_literal> ) } inline fun bar ( ) { boo { baz ( <string_literal> ) <ect>
log ( <string_literal> ) } inline fun bar ( ) { boo { baz ( <string_literal> ) foo ( ) } } fun boo ( x : ( ) - > unit ) = x ( ) <LOG> inline fun foo ( ) { baz ( <string_literal> , <number_literal> ) } fun box ( ) : string { bar ( ) if ( l != <string_literal> ) return <string_literal> return <string_literal> <ect>
) : virtual <identifiersep> file ? { val top <identifiersep> level <identifiersep> class <identifiersep> name = class <identifiersep> name <identifiersep> with <identifiersep> inner <identifiersep> classes . substring <identifiersep> before ( ' . ' ) val v <identifiersep> file = when ( root <identifiersep> type ) { java <identifiersep> root . root <identifiersep> type . binary - > package <identifiersep> dir . find <identifiersep> child ( <string_literal> ) java <identifiersep> root . root <identifiersep> type . source - > package <identifiersep> dir . find <identifiersep> child ( <string_literal> ) } ? : return null <LOG> if ( ! v <identifiersep> file . is <identifiersep> valid ) { return null } return v <identifiersep> file } private fun virtual <identifiersep> file . find <identifiersep> psi <identifiersep> class <identifiersep> in <identifiersep> virtual <identifiersep> file ( class <identifiersep> name <identifiersep> with <identifiersep> inner <identifiersep> classes : string ) : psi <identifiersep> class ? { <ect>
import java . net . url import java . util . * object main { private val kotlin <identifiersep> home : file init { val home = system . get <identifiersep> property ( <string_literal> ) <LOG> if ( home == null ) { system . exit ( 1 ) } kotlin <identifiersep> home = file ( home ) } private fun run ( args : array < string > ) { val classpath = array <identifiersep> list <identifiersep> of < url > ( ) var runner : runner ? = null <ect>
value is psi <identifiersep> annotation - > { val origin = kt <identifiersep> origin ( ) val kt <identifiersep> call <identifiersep> element = origin ? . as <identifiersep> kt <identifiersep> call ( ) val qualified <identifiersep> name = value . qualified <identifiersep> name if ( qualified <identifiersep> name != null && kt <identifiersep> call <identifiersep> element != null ) kt <identifiersep> light <identifiersep> annotation <identifiersep> for <identifiersep> source <identifiersep> entry ( qualified <identifiersep> name , kt <identifiersep> call <identifiersep> element , parent , { value } ) <LOG> else { attachment ( <string_literal> , <string_literal> ) ) light <identifiersep> element <identifiersep> value ( value , parent , kt <identifiersep> origin ) <comment> <ect>
get ( ) { val descriptor = get <identifiersep> descriptor ( ) ? : return common <identifiersep> class <identifiersep> names . java <identifiersep> lang <identifiersep> object val super <identifiersep> types = descriptor . type <identifiersep> constructor . supertypes if ( super <identifiersep> types . is <identifiersep> empty ( ) ) return common <identifiersep> class <identifiersep> names . java <identifiersep> lang <identifiersep> object val super <identifiersep> type = super <identifiersep> types . iterator ( ) . next ( ) val super <identifiersep> class <identifiersep> descriptor = super <identifiersep> type . constructor . declaration <identifiersep> descriptor <LOG> if ( super <identifiersep> class <identifiersep> descriptor == null ) { <comment> <ect>
else this val function <identifiersep> descriptor . deserialized <identifiersep> property <identifiersep> if <identifiersep> accessor : deserialized <identifiersep> callable <identifiersep> member <identifiersep> descriptor get ( ) { val member = this . property <identifiersep> if <identifiersep> accessor if ( member is deserialized <identifiersep> callable <identifiersep> member <identifiersep> descriptor ) return member <LOG> else } val callable <identifiersep> member <identifiersep> descriptor . is <identifiersep> deserializable <identifiersep> callable <ect>
<comment> group , <comment> functions <identifiersep> from <identifiersep> current . filter { it . name == name } , current , object : non <identifiersep> reporting <identifiersep> override <identifiersep> strategy ( ) { override fun add <identifiersep> fake <identifiersep> override ( fake <identifiersep> override : callable <identifiersep> member <identifiersep> descriptor ) { result . add ( fake <identifiersep> override ) } <LOG> override fun conflict ( from <identifiersep> super : callable <identifiersep> member <identifiersep> descriptor , from <identifiersep> current : callable <identifiersep> member <identifiersep> descriptor ) { } } ) } return result } class simple <identifiersep> member <identifiersep> scope ( val members : list < declaration <identifiersep> descriptor > ) : member <identifiersep> scope <identifiersep> impl ( ) { override fun get <identifiersep> contributed <identifiersep> classifier ( name : name , location : lookup <identifiersep> location ) : classifier <identifiersep> descriptor ? = members . filter <identifiersep> is <identifiersep> instance < classifier <identifiersep> descriptor > ( ) <ect>
private fun ir <identifiersep> block <identifiersep> body <identifiersep> builder . generate <identifiersep> type <identifiersep> check <identifiersep> barrier <identifiersep> if <identifiersep> needed ( override <identifiersep> descriptor : function <identifiersep> descriptor , bridge <identifiersep> descriptor : function <identifiersep> descriptor , delegate <identifiersep> parameter <identifiersep> types : array < type > ? ) { val type <identifiersep> safe <identifiersep> barrier <identifiersep> description = builtin <identifiersep> methods <identifiersep> with <identifiersep> special <identifiersep> generic <identifiersep> signature . get <identifiersep> default <identifiersep> value <identifiersep> for <identifiersep> overridden <identifiersep> builtin <identifiersep> function ( override <identifiersep> descriptor ) ? : return <LOG> builtin <identifiersep> methods <identifiersep> with <identifiersep> special <identifiersep> generic <identifiersep> signature . get <identifiersep> overridden <identifiersep> builtin <identifiersep> function <identifiersep> with <identifiersep> erased <identifiersep> value <identifiersep> parameters <identifiersep> in <identifiersep> java ( override <identifiersep> descriptor ) ? : val conditions = bridge <identifiersep> descriptor . value <identifiersep> parameters . with <identifiersep> index ( ) . filter { ( i , parameter <identifiersep> descriptor ) - > type <identifiersep> safe <identifiersep> barrier <identifiersep> description . check <identifiersep> parameter ( i ) || ! ( delegate <identifiersep> parameter <identifiersep> types == null || object <identifiersep> type == delegate <identifiersep> parameter <identifiersep> types [ i ] ) || ! type <identifiersep> utils . is <identifiersep> nullable <identifiersep> type ( parameter <identifiersep> descriptor . type ) } . map { ( i , parameter <identifiersep> descriptor ) - > <ect>
import java . util . concurrent . executors import java . util . concurrent . scheduled <identifiersep> future import java . util . concurrent . time <identifiersep> unit fun get <identifiersep> generated <identifiersep> class ( class <identifiersep> loader : class <identifiersep> loader , class <identifiersep> name : string ) : class < * > { try { return class <identifiersep> loader . load <identifiersep> class ( class <identifiersep> name ) } <LOG> catch ( e : class <identifiersep> not <identifiersep> found <identifiersep> exception ) { } } fun get <identifiersep> box <identifiersep> method <identifiersep> or <identifiersep> null ( a <identifiersep> class : class < * > ) : method ? { try { return a <identifiersep> class . get <identifiersep> method ( <string_literal> ) } catch ( e : no <identifiersep> such <identifiersep> method <identifiersep> exception ) { return null <ect>
import org . jetbrains . kotlin . resolve . multiplatform . expected <identifiersep> actual <identifiersep> resolver import org . jetbrains . kotlin . resolve . scopes . receivers . receiver <identifiersep> value <identifiersep> with <identifiersep> smart <identifiersep> cast <identifiersep> info import org . jetbrains . kotlin . types . unwrapped <identifiersep> type import org . jetbrains . kotlin . types . checker . intersect <identifiersep> wrapped <identifiersep> types import org . jetbrains . kotlin . utils . dfs import org . jetbrains . kotlin . utils . add <identifiersep> to <identifiersep> stdlib . safe <identifiersep> as <LOG> internal fun unexpected <identifiersep> argument ( argument : kotlin <identifiersep> call <identifiersep> argument ) : nothing = <comment> <ect>
if ( at ( else <identifiersep> keyword ) ) { advance ( ) ; <comment> <LOG> if ( at <identifiersep> set ( when <identifiersep> condition <identifiersep> recovery <identifiersep> set ) ) { } else { parse <identifiersep> control <identifiersep> structure <identifiersep> body ( ) ; } } else if ( at ( lbrace ) ) { <comment> <ect>
psi <identifiersep> builder . marker condition = mark ( ) ; my <identifiersep> builder . disable <identifiersep> newlines ( ) ; if ( at ( in <identifiersep> keyword ) || at ( not <identifiersep> in ) ) { psi <identifiersep> builder . marker mark = mark ( ) ; advance ( ) ; <comment> <LOG> if ( at <identifiersep> set ( when <identifiersep> condition <identifiersep> recovery <identifiersep> set <identifiersep> with <identifiersep> arrow ) ) { } else { parse <identifiersep> expression ( ) ; } condition . done ( when <identifiersep> condition <identifiersep> in <identifiersep> range ) ; } else if ( at ( is <identifiersep> keyword ) || at ( not <identifiersep> is ) ) { advance ( ) ; <comment> <ect>
if ( at <identifiersep> set ( when <identifiersep> condition <identifiersep> recovery <identifiersep> set <identifiersep> with <identifiersep> arrow ) ) { error ( <string_literal> ) ; } else { my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> type <identifiersep> ref ( ) ; } condition . done ( when <identifiersep> condition <identifiersep> is <identifiersep> pattern ) ; } else { <LOG> if ( at <identifiersep> set ( when <identifiersep> condition <identifiersep> recovery <identifiersep> set <identifiersep> with <identifiersep> arrow ) ) { } else { parse <identifiersep> expression ( ) ; } condition . done ( when <identifiersep> condition <identifiersep> expression ) ; } my <identifiersep> builder . restore <identifiersep> newlines <identifiersep> state ( ) ; } <comment> <ect>
my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> type <identifiersep> ref ( token <identifiersep> set . create ( arrow , comma ) ) ; } parameter . done ( value <identifiersep> parameter ) ; if ( at ( arrow ) ) { break ; } else if ( at ( comma ) ) { advance ( ) ; <comment> <LOG> else { break ; } } parameter <identifiersep> list . done ( value <identifiersep> parameter <identifiersep> list ) ; } <comment> <ect>
boolean catch <identifiersep> or <identifiersep> finally = false ; while ( at ( catch <identifiersep> keyword ) ) { catch <identifiersep> or <identifiersep> finally = true ; psi <identifiersep> builder . marker catch <identifiersep> block = mark ( ) ; advance ( ) ; <comment> <LOG> if ( at <identifiersep> set ( recovery <identifiersep> set ) ) { } else { psi <identifiersep> builder . marker parameters = mark ( ) ; expect ( lpar , <string_literal> , recovery <identifiersep> set ) ; if ( ! at <identifiersep> set ( recovery <identifiersep> set ) ) { my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> value <identifiersep> parameter ( <comment> true ) ; <ect>
expect ( rpar , <string_literal> , recovery <identifiersep> set ) ; } else { error ( <string_literal> ) ; } parameters . done ( value <identifiersep> parameter <identifiersep> list ) ; } if ( at ( lbrace ) ) { my <identifiersep> kotlin <identifiersep> parsing . parse <identifiersep> block ( ) ; } <LOG> else { } catch <identifiersep> block . done ( catch ) ; } if ( at ( finally <identifiersep> keyword ) ) { catch <identifiersep> or <identifiersep> finally = true ; psi <identifiersep> builder . marker finally <identifiersep> block = mark ( ) ; advance ( ) ; <comment> <ect>
return <identifiersep> expression . done ( return ) ; } <comment> private void parse <identifiersep> label <identifiersep> reference <identifiersep> with <identifiersep> no <identifiersep> whitespace ( ) { if ( at ( at ) && ! my <identifiersep> builder . newline <identifiersep> before <identifiersep> current <identifiersep> token ( ) ) { <LOG> if ( white <identifiersep> space <identifiersep> or <identifiersep> comment <identifiersep> bit <identifiersep> set . contains ( my <identifiersep> builder . raw <identifiersep> lookup ( - 1 ) ) ) { } parse <identifiersep> label <identifiersep> reference ( ) ; } } <comment> private void parse <identifiersep> label <identifiersep> definition ( ) { <ect>
while ( at ( comma ) ) error <identifiersep> and <identifiersep> advance ( <string_literal> ) ; parse <identifiersep> value <identifiersep> argument ( ) ; if ( at ( colon ) && lookahead ( 1 ) == identifier ) { error <identifiersep> and <identifiersep> advance ( <string_literal> , <number_literal> ) ; } if ( ! at ( comma ) ) break ; advance ( ) ; <comment> <LOG> if ( at ( rpar ) ) { break ; } } } expect ( rpar , <string_literal> , expression <identifiersep> follow ) ; } my <identifiersep> builder . restore <identifiersep> newlines <identifiersep> state ( ) ; list . done ( value <identifiersep> argument <identifiersep> list ) ; } <comment> <ect>
<comment> private void parse <identifiersep> file <identifiersep> annotation <identifiersep> list ( annotation <identifiersep> parsing <identifiersep> mode mode ) { <LOG> if ( ! mode . is <identifiersep> file <identifiersep> annotation <identifiersep> parsing <identifiersep> mode ) { } psi <identifiersep> builder . marker file <identifiersep> annotations <identifiersep> list = mark ( ) ; if ( parse <identifiersep> annotations ( mode ) ) { file <identifiersep> annotations <identifiersep> list . done ( file <identifiersep> annotation <identifiersep> list ) ; } else { file <identifiersep> annotations <identifiersep> list . drop ( ) ; <ect>
else if ( has <identifiersep> constructor <identifiersep> modifiers || has <identifiersep> constructor <identifiersep> keyword ) { <comment> <LOG> if ( has <identifiersep> constructor <identifiersep> keyword ) { } else { error ( <string_literal> ) ; } } else { primary <identifiersep> constructor <identifiersep> marker . drop ( ) ; } if ( at ( colon ) ) { <ect>
if ( at ( lbrace ) ) { if ( enum <identifiersep> class ) { parse <identifiersep> enum <identifiersep> class <identifiersep> body ( ) ; } else { parse <identifiersep> class <identifiersep> body ( ) ; } } else if ( ! optional <identifiersep> body ) { <LOG> psi <identifiersep> builder . marker fake <identifiersep> body = mark ( ) ; fake <identifiersep> body . done ( class <identifiersep> body ) ; } return object ? object <identifiersep> declaration : class ; } i <identifiersep> element <identifiersep> type parse <identifiersep> class ( boolean enum <identifiersep> class ) { return parse <identifiersep> class <identifiersep> or <identifiersep> object ( false , name <identifiersep> parsing <identifiersep> mode . required , true , enum <identifiersep> class ) ; } void parse <identifiersep> object ( name <identifiersep> parsing <identifiersep> mode name <identifiersep> parsing <identifiersep> mode , boolean optional <identifiersep> body ) { <ect>
else { mark ( ) . error ( <string_literal> ) ; } decl <identifiersep> type = class <identifiersep> initializer ; } else if ( at ( constructor <identifiersep> keyword ) ) { parse <identifiersep> secondary <identifiersep> constructor ( ) ; decl <identifiersep> type = secondary <identifiersep> constructor ; } <LOG> else if ( at ( lbrace ) ) { parse <identifiersep> block ( ) ; decl <identifiersep> type = fun ; } return decl <identifiersep> type ; } <comment> <ect>
parse <identifiersep> type <identifiersep> ref ( ) ; error <identifiersep> if ( type , multi <identifiersep> declaration , <string_literal> ) ; } parse <identifiersep> type <identifiersep> constraints <identifiersep> guarded ( type <identifiersep> parameters <identifiersep> declared ) ; if ( ! parse <identifiersep> property <identifiersep> delegate <identifiersep> or <identifiersep> assignment ( ) && is <identifiersep> name <identifiersep> on <identifiersep> the <identifiersep> next <identifiersep> line && no <identifiersep> type <identifiersep> reference && ! receiver <identifiersep> type <identifiersep> declared ) { <comment> <LOG> before <identifiersep> name . rollback <identifiersep> to ( ) ; return property ; } before <identifiersep> name . drop ( ) ; if ( mode . accessors <identifiersep> allowed ) { <comment> <ect>
<comment> @ contract ( <string_literal> ) i <identifiersep> element <identifiersep> type parse <identifiersep> function ( boolean fail <identifiersep> if <identifiersep> identifier <identifiersep> exists ) { assert  <identifiersep> at ( fun <identifiersep> keyword ) ; advance ( ) ; <comment> <LOG> if ( at ( rbrace ) ) { return fun ; } boolean type <identifiersep> parameter <identifiersep> list <identifiersep> occurred = false ; if ( at ( lt ) ) { parse <identifiersep> type <identifiersep> parameter <identifiersep> list ( token <identifiersep> set . create ( lbracket , lbrace , rbrace , lpar ) ) ; type <identifiersep> parameter <identifiersep> list <identifiersep> occurred = true ; <ect>
if ( at ( lbrace ) ) { parse <identifiersep> block ( ) ; } else if ( at ( eq ) ) { advance ( ) ; <comment> <LOG> else { } } <comment> <ect>
psi <identifiersep> builder . marker receiver <identifiersep> type = receiver <identifiersep> type <identifiersep> ref . precede ( ) ; receiver <identifiersep> type <identifiersep> ref . done ( type <identifiersep> reference ) ; receiver <identifiersep> type . done ( function <identifiersep> type <identifiersep> receiver ) ; advance ( ) ; <comment> <LOG> else { } function <identifiersep> type . done ( function <identifiersep> type ) ; } type <identifiersep> element <identifiersep> marker . drop ( ) ; return type <identifiersep> ref <identifiersep> marker ; } @ not <identifiersep> null private psi <identifiersep> builder . marker parse <identifiersep> nullable <identifiersep> type <identifiersep> suffix ( @ not <identifiersep> null psi <identifiersep> builder . marker type <identifiersep> element <identifiersep> marker ) { <ect>
my <identifiersep> builder . disable <identifiersep> newlines ( ) ; advance ( ) ; <comment> <LOG> else if ( at ( rpar ) ) { break ; } if ( is <identifiersep> function <identifiersep> type <identifiersep> contents ) { if ( ! try <identifiersep> parse <identifiersep> value <identifiersep> parameter ( type <identifiersep> required ) ) { psi <identifiersep> builder . marker value <identifiersep> parameter = mark ( ) ; parse <identifiersep> function <identifiersep> type <identifiersep> value <identifiersep> parameter <identifiersep> modifier <identifiersep> list ( ) ; <ect>
try { val input <identifiersep> stream = file <identifiersep> input <identifiersep> stream ( manifest <identifiersep> file ) try { return manifest ( input <identifiersep> stream ) } finally { input <identifiersep> stream . close ( ) } } <LOG> catch ( ignored : io <identifiersep> exception ) { return null } } private fun get <identifiersep> manifest <identifiersep> from <identifiersep> jar <identifiersep> or <identifiersep> directory ( library : file ) : manifest ? = if ( library . is <identifiersep> directory ) get <identifiersep> manifest <identifiersep> from <identifiersep> directory ( library ) else get <identifiersep> manifest <identifiersep> from <identifiersep> jar ( library ) private fun get <identifiersep> manifest <identifiersep> main <identifiersep> attributes <identifiersep> from <identifiersep> jar <identifiersep> or <identifiersep> directory ( library : file ) : attributes ? = get <identifiersep> manifest <identifiersep> from <identifiersep> jar <identifiersep> or <identifiersep> directory ( library ) ? . main <identifiersep> attributes <ect>
@ run <identifiersep> with ( all <identifiersep> tests . class ) public class android <identifiersep> runner { private static path <identifiersep> manager path <identifiersep> manager ; @ not <identifiersep> null public static path <identifiersep> manager get <identifiersep> path <identifiersep> manager ( ) { if ( path <identifiersep> manager == null ) { <LOG> file tmp <identifiersep> folder = files . create <identifiersep> temp <identifiersep> dir ( ) ; file root <identifiersep> folder = new file ( <string_literal> ) ; path <identifiersep> manager = new path <identifiersep> manager ( root <identifiersep> folder . get <identifiersep> absolute <identifiersep> path ( ) , tmp <identifiersep> folder . get <identifiersep> absolute <identifiersep> path ( ) ) ; } return path <identifiersep> manager ; } public static test <identifiersep> suite suite ( ) throws throwable { path <identifiersep> manager path <identifiersep> manager = get <identifiersep> path <identifiersep> manager ( ) ; <ect>
<comment> <LOG> string sdk <identifiersep> root = files <identifiersep> kt . get <identifiersep> invariant <identifiersep> separators <identifiersep> path ( new file ( path <identifiersep> manager . get <identifiersep> android <identifiersep> sdk <identifiersep> root ( ) ) ) ; file file = new file ( path <identifiersep> manager . get <identifiersep> tmp <identifiersep> folder ( ) + <string_literal> ) ; try ( file <identifiersep> writer fw = new file <identifiersep> writer ( file ) ) { fw . write ( <string_literal> + sdk <identifiersep> root ) ; } } } <ect>
byte [ ] buf ; int read ; <comment> <LOG> if ( output <identifiersep> file . exists ( ) ) { return ; } output <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ; file <identifiersep> output <identifiersep> stream output <identifiersep> stream = new file <identifiersep> output <identifiersep> stream ( output <identifiersep> file ) ; out <identifiersep> stream = new buffered <identifiersep> output <identifiersep> stream ( output <identifiersep> stream ) ; url <identifiersep> connection = url . open <identifiersep> connection ( ) ; <ect>
<comment> <LOG> protected void unzip ( string path <identifiersep> to <identifiersep> file , string output <identifiersep> folder ) { string path <identifiersep> to <identifiersep> unzip ; if ( output <identifiersep> folder . equals ( path <identifiersep> manager . get <identifiersep> platform <identifiersep> folder <identifiersep> in <identifiersep> android <identifiersep> sdk ( ) ) ) { path <identifiersep> to <identifiersep> unzip = output <identifiersep> folder ; } else { path <identifiersep> to <identifiersep> unzip = output <identifiersep> folder + <string_literal> + file <identifiersep> util . get <identifiersep> name <identifiersep> without <identifiersep> extension ( new file ( path <identifiersep> to <identifiersep> file ) ) ; <ect>
try ( file <identifiersep> output <identifiersep> stream file <identifiersep> output <identifiersep> stream = new file <identifiersep> output <identifiersep> stream ( output <identifiersep> file ) ) { while ( ( n = zip <identifiersep> input <identifiersep> stream . read ( buf , 0 , <number_literal> ) ) > - 1 ) { file <identifiersep> output <identifiersep> stream . write ( buf , 0 , n ) ; } } zip <identifiersep> input <identifiersep> stream . close <identifiersep> entry ( ) ; zip <identifiersep> entry = zip <identifiersep> input <identifiersep> stream . get <identifiersep> next <identifiersep> entry ( ) ; } } catch ( io <identifiersep> exception e ) { <LOG> if ( zip <identifiersep> entry != null ) { } e . print <identifiersep> stack <identifiersep> trace ( ) ; } } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } system . out . println ( <string_literal> + path <identifiersep> to <identifiersep> file + <string_literal> + output <identifiersep> folder ) ; } private static void delete ( string file <identifiersep> path ) { <ect>
public static run <identifiersep> result execute ( @ not <identifiersep> null run <identifiersep> settings settings ) { assert settings . wait <identifiersep> for <identifiersep> end : <string_literal> ; return run ( settings ) ; } public static void execute <identifiersep> on <identifiersep> separate <identifiersep> thread ( @ not <identifiersep> null run <identifiersep> settings settings ) { assert ! settings . wait <identifiersep> for <identifiersep> end : <string_literal> ; new thread ( ( ) - > run ( settings ) ) . start ( ) ; } <LOG> private static run <identifiersep> result run ( run <identifiersep> settings settings ) { string <identifiersep> builder std <identifiersep> out = new string <identifiersep> builder ( ) ; string <identifiersep> builder std <identifiersep> err = new string <identifiersep> builder ( ) ; os <identifiersep> process <identifiersep> handler handler ; try { handler = new os <identifiersep> process <identifiersep> handler ( settings . command <identifiersep> line . create <identifiersep> process ( ) , settings . command <identifiersep> line . get <identifiersep> command <identifiersep> line <identifiersep> string ( ) , charsets . utf <identifiersep> <number_literal> ) ; <ect>
return ( settings . output <identifiersep> prefix != null ) ? settings . output <identifiersep> prefix + <string_literal> : <string_literal> ; } } ) ; handler . start <identifiersep> notify ( ) ; if ( settings . wait <identifiersep> for <identifiersep> end ) { string timeout <identifiersep> as <identifiersep> string = system . getenv ( <string_literal> ) ; if ( timeout <identifiersep> as <identifiersep> string == null ) { <LOG> timeout <identifiersep> as <identifiersep> string = <string_literal> ; } int timeout ; try { timeout = integer . parse <identifiersep> int ( timeout <identifiersep> as <identifiersep> string ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { timeout = <number_literal> ; <ect>
try { timeout = integer . parse <identifiersep> int ( timeout <identifiersep> as <identifiersep> string ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { timeout = <number_literal> ; system . err . println ( <string_literal> ) ; } handler . wait <identifiersep> for ( timeout * <number_literal> * <number_literal> ) ; <LOG> if ( ! handler . is <identifiersep> process <identifiersep> terminated ( ) ) { system . out . println ( std <identifiersep> out ) ; system . err . println ( std <identifiersep> err ) ; return new run <identifiersep> result ( false , <string_literal> ) ; } } else { handler . wait <identifiersep> for ( ) ; <ect>
list <identifiersep> of <identifiersep> commands . add ( <string_literal> ) ; list <identifiersep> of <identifiersep> commands . add ( path <identifiersep> manager . get <identifiersep> tmp <identifiersep> folder ( ) + <string_literal> ) ; } public void clean ( ) { system . out . println ( <string_literal> ) ; run <identifiersep> result result = run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; output <identifiersep> utils . check <identifiersep> result ( result ) ; } <LOG> public void build ( ) { general <identifiersep> command <identifiersep> line build = generate <identifiersep> command <identifiersep> line ( <string_literal> ) ; build . add <identifiersep> parameter ( <string_literal> ) ; run <identifiersep> result result = run <identifiersep> utils . execute ( build ) ; output <identifiersep> utils . check <identifiersep> result ( result ) ; } public void install <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { <ect>
run <identifiersep> result result = run <identifiersep> utils . execute ( build ) ; output <identifiersep> utils . check <identifiersep> result ( result ) ; } public void install <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ) ; output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ) ; } <LOG> public void uninstall <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; } public string connected <identifiersep> debug <identifiersep> android <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; run <identifiersep> result result = run <identifiersep> utils . execute ( generate <identifiersep> command <identifiersep> line ( <string_literal> ) ) ; <ect>
command <identifiersep> line . set <identifiersep> exe <identifiersep> path ( <string_literal> ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> + platform + <string_literal> ) ; return command <identifiersep> line ; } return null ; } <LOG> public void create <identifiersep> emulator ( ) { output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( new run <identifiersep> utils . run <identifiersep> settings ( get <identifiersep> create <identifiersep> command ( ) , <string_literal> , true , null , false ) ) ) ; } private general <identifiersep> command <identifiersep> line create <identifiersep> adb <identifiersep> command ( ) { general <identifiersep> command <identifiersep> line command <identifiersep> line = new general <identifiersep> command <identifiersep> line ( ) ; string adb <identifiersep> cmd <identifiersep> name = system <identifiersep> info . is <identifiersep> windows ? <string_literal> : <string_literal> ; command <identifiersep> line . set <identifiersep> exe <identifiersep> path ( path <identifiersep> manager . get <identifiersep> platform <identifiersep> tools <identifiersep> folder <identifiersep> in <identifiersep> android <identifiersep> sdk ( ) + <string_literal> + adb <identifiersep> cmd <identifiersep> name ) ; <ect>
public void start <identifiersep> server ( ) { general <identifiersep> command <identifiersep> line command <identifiersep> line = create <identifiersep> adb <identifiersep> command ( ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; system . out . println ( <string_literal> ) ; output <identifiersep> utils . check <identifiersep> result ( run <identifiersep> utils . execute ( new run <identifiersep> utils . run <identifiersep> settings ( command <identifiersep> line , null , true , <string_literal> , true ) ) ) ; } public void start <identifiersep> emulator ( ) { <LOG> start <identifiersep> server ( ) ; run <identifiersep> utils . execute <identifiersep> on <identifiersep> separate <identifiersep> thread ( new run <identifiersep> utils . run <identifiersep> settings ( get <identifiersep> start <identifiersep> command ( ) , null , false , <string_literal> , true ) ) ; print <identifiersep> log ( ) ; } public void print <identifiersep> log ( ) { general <identifiersep> command <identifiersep> line command <identifiersep> line = create <identifiersep> adb <identifiersep> command ( ) ; command <identifiersep> line . add <identifiersep> parameter ( <string_literal> ) ; <ect>
boot <identifiersep> check <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; boot <identifiersep> check <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; int counter = 0 ; run <identifiersep> result execute = run <identifiersep> utils . execute ( boot <identifiersep> check <identifiersep> command ) ; while ( counter < <number_literal> ) { string output = execute . get <identifiersep> output ( ) ; <LOG> if ( output . trim ( ) . ends <identifiersep> with ( <string_literal> ) ) { return ; } system . out . println ( <string_literal> + counter + <string_literal> ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { <ect>
thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } counter ++ ; execute = run <identifiersep> utils . execute ( boot <identifiersep> check <identifiersep> command ) ; } assert . fail ( <string_literal> + execute . get <identifiersep> output ( ) ) ; } <LOG> public void stop <identifiersep> emulator ( ) { general <identifiersep> command <identifiersep> line command = create <identifiersep> adb <identifiersep> command ( ) ; command . add <identifiersep> parameter ( <string_literal> ) ; command . add <identifiersep> parameter ( <string_literal> ) ; command . add <identifiersep> parameter ( <string_literal> ) ; command . add <identifiersep> parameter ( <string_literal> ) ; <ect>
general <identifiersep> command <identifiersep> line kill <identifiersep> command = new general <identifiersep> command <identifiersep> line ( ) ; kill <identifiersep> command . set <identifiersep> exe <identifiersep> path ( <string_literal> ) ; kill <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; kill <identifiersep> command . add <identifiersep> parameter ( <string_literal> ) ; kill <identifiersep> command . add <identifiersep> parameter ( pid ) ; run <identifiersep> utils . execute ( kill <identifiersep> command ) ; } } } <LOG> public string run <identifiersep> tests <identifiersep> via <identifiersep> adb ( ) { general <identifiersep> command <identifiersep> line adb <identifiersep> command = create <identifiersep> adb <identifiersep> command ( ) ; <comment> <ect>
environment : env ) : exit <identifiersep> code ? protected fun exit <identifiersep> code <identifiersep> from <identifiersep> process <identifiersep> exit <identifiersep> code ( code : int ) : exit <identifiersep> code = companion . exit <identifiersep> code <identifiersep> from <identifiersep> process <identifiersep> exit <identifiersep> code ( log , code ) companion object { fun exit <identifiersep> code <identifiersep> from <identifiersep> process <identifiersep> exit <identifiersep> code ( log : kotlin <identifiersep> logger , code : int ) : exit <identifiersep> code { val exit <identifiersep> code = exit <identifiersep> code . values ( ) . find { it . code == code } <LOG> if ( exit <identifiersep> code != null ) return exit <identifiersep> code return if ( code == 0 ) exit <identifiersep> code . ok else exit <identifiersep> code . compilation <identifiersep> error } } } <ect>
method main <identifiersep> method = main <identifiersep> class . get <identifiersep> method ( <string_literal> , string [ ] . class ) ; runtime . get <identifiersep> runtime ( ) . add <identifiersep> shutdown <identifiersep> hook ( new thread ( new runnable ( ) { @ override public void run ( ) { if ( options . measure ) { <LOG> system . out . println ( ) ; system . out . format ( <string_literal> , ( system . nano <identifiersep> time ( ) - start <identifiersep> time ) / <number_literal> ) ; } handler . done ( ) ; } } ) ) ; <comment> <ect>
public void before <identifiersep> define <identifiersep> class ( string name , int size <identifiersep> in <identifiersep> bytes ) { counter [ 0 ] ++ ; size [ 0 ] += size <identifiersep> in <identifiersep> bytes ; } @ override public void done ( ) { system . out . println ( ) ; <LOG> system . out . println ( <string_literal> + counter [ 0 ] ) ; system . out . println ( ) ; instrumenter . dump ( system . out ) ; } @ override public byte [ ] instrument ( string resource <identifiersep> name , byte [ ] data ) { return instrumenter . instrument ( resource <identifiersep> name , data ) ; <ect>
iterator < instrumenter > instrumenters = loader . iterator ( ) ; if ( instrumenters . has <identifiersep> next ( ) ) { instrumenter instrumenter = instrumenters . next ( ) ; if ( instrumenters . has <identifiersep> next ( ) ) { system . err . println ( <string_literal> + instrumenter . get <identifiersep> class ( ) ) ; } return instrumenter ; } <LOG> else { return instrumenter . do <identifiersep> nothing ; } } private static void print <identifiersep> usage ( print <identifiersep> stream out ) { out . println ( <string_literal> ) ; out . println ( <string_literal> ) ; out . println ( <string_literal> ) ; <ect>
val exit <identifiersep> code = process <identifiersep> output . exit <identifiersep> code try { assert <identifiersep> equals ( expected <identifiersep> stdout , stdout ) assert <identifiersep> equals ( expected <identifiersep> stderr , stderr ) assert <identifiersep> equals ( expected <identifiersep> exit <identifiersep> code , exit <identifiersep> code ) } catch ( e : throwable ) { <LOG> system . err . println ( <string_literal> ) system . err . println ( stdout ) system . err . println ( <string_literal> ) system . err . println ( stderr ) throw e } } private val test <identifiersep> data <identifiersep> directory : string <ect>
internal inline fun with <identifiersep> log <identifiersep> file ( prefix : string , suffix : string = <string_literal> , print <identifiersep> log <identifiersep> on <identifiersep> exception : boolean = true , body : ( file ) - > unit ) { val log <identifiersep> file = create <identifiersep> temp <identifiersep> file ( prefix , suffix ) try { body ( log <identifiersep> file ) } catch ( e : exception ) { if ( print <identifiersep> log <identifiersep> on <identifiersep> exception ) { <LOG> thread . sleep ( <number_literal> ) <comment> <ect>
fun test <identifiersep> fun ( ) { system . out . println ( <string_literal> ) } var test <identifiersep> prop : any <LOG> get ( ) { return <number_literal> } set ( value ) { system . out . println ( <string_literal> ) } class test <identifiersep> class { val test = when { <ect>
system . out . println ( <string_literal> ) return <number_literal> } set ( value ) { system . out . println ( <string_literal> ) } class test <identifiersep> class { val test = when { <LOG> else - > { <number_literal> } } init { system . out . println ( <string_literal> ) } <ect>
package a import java . lang . deprecated as deprecated import java . lang . suppress <identifiersep> warnings as suppresswarnings < ! deprecated <identifiersep> java <identifiersep> annotation ! > @ deprecated < ! > @ suppresswarnings val s : string = <string_literal> ; <LOG> < ! deprecated <identifiersep> java <identifiersep> annotation ! > @ deprecated < ! > @ suppresswarnings fun main ( args : array < string > ) { } class test ( < ! deprecated <identifiersep> java <identifiersep> annotation ! > @ deprecated < ! > val s : string , @ suppresswarnings val x : int ) { } <ect>
fun evaluate ( expr : string <identifiersep> builder , numbers : array <identifiersep> list < int > ) : int { val lhs = evaluate <identifiersep> add ( expr , numbers ) if ( expr . length > 0 ) { val < ! unused <identifiersep> variable ! > c < ! > = expr . get ( 0 ) expr . delete <identifiersep> char <identifiersep> at ( 0 ) } return lhs } <LOG> fun main ( args : array < string > ) { val numbers = array <identifiersep> list < int > ( <number_literal> ) val rnd = random ( ) ; val prompt = string <identifiersep> builder ( ) for ( i in 0 . . <number_literal> ) { val n = rnd . next <identifiersep> int ( <number_literal> ) + 1 <ect>
val prompt = string <identifiersep> builder ( ) for ( i in 0 . . <number_literal> ) { val n = rnd . next <identifiersep> int ( <number_literal> ) + 1 numbers . add ( n ) if ( i > 0 ) prompt . append ( <string_literal> ) ; prompt . append ( n ) } <LOG> system . out . println ( <string_literal> + prompt ) val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) if ( result != <number_literal> ) <ect>
val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) if ( result != <number_literal> ) system . out . println ( <string_literal> + result ) <LOG> else } catch ( e : throwable ) { system . out . println ( e . message ) } } <ect>
<LOG> public fun foo <identifiersep> not <identifiersep> null ( s : string ) { } public fun foo ( ) { var s : string ? = <string_literal> if ( s == null ) { <comment> <ect>
<LOG> public fun foo <identifiersep> not <identifiersep> null ( s : string ) { } public fun foo ( ) { var s : string ? = <string_literal> if ( s != null ) foo <identifiersep> not <identifiersep> null ( < ! debug <identifiersep> info <identifiersep> smartcast ! > s < ! > ) } <ect>
<LOG> public fun bar ( s : string ) { } public fun foo ( ) { var s : any = <string_literal> if ( s is string ) { s = <number_literal> bar ( < ! type <identifiersep> mismatch ! > s < ! > ) <ect>
<comment> <LOG> catch ( e : exception ) { } } } fun log ( str : string ) : int { print ( <string_literal> ) return 0 } fun print ( < ! unused <identifiersep> parameter ! > obj < ! > : any ) { } fun string . prt ( action : ( string ) - > unit ) { <ect>
package hello <LOG> fun main ( args : array < string > ) { } <ect>
package inline <identifiersep> only <LOG> fun main ( args : array < string > ) { } <ect>
fun test2 ( ) { log = <string_literal> val h1 = h ( object : c { } ) h1 . foo ( <number_literal> ) h1 . foo ( ) val h2 = h ( object : c { <LOG> override fun foo ( x : int ) { } } ) h2 . foo ( <number_literal> ) h2 . foo ( ) } fun box ( ) : string { test1 ( ) <ect>
try { if ( a > 0 ) throw exception ( ) log ( <string_literal> ) } catch ( e : exception ) { bar ( a ) } } inline fun bar ( a : int ) { <LOG> my <identifiersep> run { if ( a == <number_literal> ) return log ( <string_literal> ) } } var log : string = <string_literal> fun log ( s : string ) : string { log += s + <string_literal> <ect>
<comment> <LOG> if ( a > 0 ) throw exception ( ) } catch ( e : exception ) { my <identifiersep> run { log ( <string_literal> ) if ( a > 1 ) return log ( <string_literal> ) <ect>
try { if ( a > 0 ) throw exception ( ) log ( <string_literal> ) } catch ( e : exception ) { my <identifiersep> run { log ( <string_literal> ) <LOG> if ( a > 1 ) return } } log ( <string_literal> ) } var log : string = <string_literal> fun log ( s : string ) : string { log += s + <string_literal> return log <ect>
fun foobar ( x : string , y : string ) = x + y fun box ( ) : string { var result = <string_literal> fun log ( x : string ) { if ( result . is <identifiersep> not <identifiersep> empty ( ) ) result += <string_literal> result += x } <LOG> val future = async < string > { val x = await ( foo ( ) ) log ( <string_literal> ) val y = foobar ( <string_literal> , await ( bar ( x ) ) ) log ( <string_literal> ) y <ect>
if ( result . is <identifiersep> not <identifiersep> empty ( ) ) result += <string_literal> result += x } val future = async < string > { log ( <string_literal> ) val x = await ( foo ( ) ) log ( <string_literal> ) <LOG> val y = foobar ( <string_literal> , await ( bar ( x ) ) ) y } future . when <identifiersep> complete { value , t - > log ( <string_literal> ) } . join ( ) val expected <identifiersep> result = <ect>
import com . intellij . openapi . diagnostic . attachment import com . intellij . openapi . diagnostic . logger import com . intellij . psi . psi <identifiersep> element import org . jetbrains . kotlin . psi . psi <identifiersep> util . get <identifiersep> element <identifiersep> text <identifiersep> with <identifiersep> context object exception <identifiersep> logger { @ jvm <identifiersep> static <LOG> fun log <identifiersep> descriptor <identifiersep> not <identifiersep> found ( problem <identifiersep> description : string , psi : psi <identifiersep> element ) : assertion <identifiersep> error { throw assertion <identifiersep> error ( problem <identifiersep> description ) } private val log = logger . get <identifiersep> instance ( exception <identifiersep> logger : : class . java ) <ect>
override fun generate <identifiersep> body ( mv : method <identifiersep> visitor , frame <identifiersep> map : frame <identifiersep> map , signature : jvm <identifiersep> method <identifiersep> signature , context : method <identifiersep> context , parent <identifiersep> codegen : member <identifiersep> codegen < * > <LOG> ) { } } <ect>
val top = frame . top ( ) ? : error ( <string_literal> ) if ( top is uninitialized <identifiersep> new <identifiersep> value ) { uninitialized <identifiersep> values <identifiersep> to <identifiersep> removable <identifiersep> usages [ top . new <identifiersep> insn ] ! ! . add ( insn ) } } private fun analyze <identifiersep> pop2 ( insn : abstract <identifiersep> insn <identifiersep> node , frame : frame < basic <identifiersep> value > ) { val top2 = frame . peek <identifiersep> words ( <number_literal> ) ? : error ( <string_literal> ) for ( value in top2 ) { <LOG> if ( value is uninitialized <identifiersep> new <identifiersep> value ) { } } } } } <ect>
lateinit var node : smap <identifiersep> and <identifiersep> method <identifiersep> node abstract fun generate <identifiersep> lambda <identifiersep> body ( source <identifiersep> compiler : source <identifiersep> compiler <identifiersep> for <identifiersep> inline , reified <identifiersep> type <identifiersep> inliner : reified <identifiersep> type <identifiersep> inliner ) open val has <identifiersep> dispatch <identifiersep> receiver = true fun add <identifiersep> all <identifiersep> parameters ( remapper : field <identifiersep> remapper ) : parameters { val builder = parameters <identifiersep> builder . initialize <identifiersep> builder <identifiersep> from ( asm <identifiersep> types . object <identifiersep> type , invoke <identifiersep> method . descriptor , this ) for ( info in captured <identifiersep> vars ) { <LOG> val field = remapper . find <identifiersep> field ( field <identifiersep> insn <identifiersep> node ( 0 , info . containing <identifiersep> lambda <identifiersep> name , info . field <identifiersep> name , <string_literal> ) ) ? : builder . add <identifiersep> captured <identifiersep> param ( field , info . field <identifiersep> name ) } return builder . build <identifiersep> parameters ( ) } companion object { fun lambda <identifiersep> info . get <identifiersep> captured <identifiersep> param <identifiersep> info ( descriptor : enclosed <identifiersep> value <identifiersep> descriptor ) : captured <identifiersep> param <identifiersep> desc { return captured <identifiersep> param <identifiersep> desc ( descriptor . field <identifiersep> name , descriptor . type ) <ect>
val actual <identifiersep> extension <identifiersep> receiver = declaration . extension <identifiersep> receiver <identifiersep> parameter ? . descriptor require ( expected <identifiersep> extension <identifiersep> receiver == actual <identifiersep> extension <identifiersep> receiver ) { <string_literal> + <string_literal> } val declared <identifiersep> value <identifiersep> parameters = declaration . value <identifiersep> parameters . map { it . descriptor } val actual <identifiersep> value <identifiersep> parameters = function <identifiersep> descriptor . value <identifiersep> parameters <LOG> if ( declared <identifiersep> value <identifiersep> parameters . size != actual <identifiersep> value <identifiersep> parameters . size ) { } else { declared <identifiersep> value <identifiersep> parameters . zip ( actual <identifiersep> value <identifiersep> parameters ) . for <identifiersep> each { ( declared <identifiersep> value <identifiersep> parameter , actual <identifiersep> value <identifiersep> parameter ) - > require ( declared <identifiersep> value <identifiersep> parameter == actual <identifiersep> value <identifiersep> parameter ) { <string_literal> } } } } override fun visit <identifiersep> declaration <identifiersep> reference ( expression : ir <identifiersep> declaration <identifiersep> reference ) { <ect>
expression . getter . check <identifiersep> binding ( <string_literal> , expression ) expression . setter ? . check <identifiersep> binding ( <string_literal> , expression ) } private fun ir <identifiersep> symbol . check <identifiersep> binding ( kind : string , ir <identifiersep> element : ir <identifiersep> element ) { if ( ! is <identifiersep> bound ) { error ( <string_literal> ) } val other <identifiersep> symbol = symbol <identifiersep> for <identifiersep> declaration . get <identifiersep> or <identifiersep> put ( owner ) { this } <LOG> if ( this != other <identifiersep> symbol ) { } } override fun visit <identifiersep> class ( declaration : ir <identifiersep> class ) { visit <identifiersep> declaration ( declaration ) check <identifiersep> type <identifiersep> parameters ( declaration . descriptor , declaration , declaration . descriptor . declared <identifiersep> type <identifiersep> parameters ) } private fun check <identifiersep> type <identifiersep> parameters ( descriptor : declaration <identifiersep> descriptor , <ect>
configuration configuration ) { boolean fail = false ; try { expected <identifiersep> load <identifiersep> errors <identifiersep> util . check <identifiersep> for <identifiersep> load <identifiersep> errors ( java <identifiersep> package , binding <identifiersep> context ) ; } catch ( comparison <identifiersep> failure e ) { <LOG> <comment> <ect>
declaration <identifiersep> to <identifiersep> position . put ( entry . get <identifiersep> key ( ) , new position ( kt <identifiersep> file , entry . get <identifiersep> value ( ) ) ) ; } for ( map . entry < integer , string > entry : int <identifiersep> position <identifiersep> to <identifiersep> reference . entry <identifiersep> set ( ) ) { position <identifiersep> to <identifiersep> reference . put ( new position ( kt <identifiersep> file , entry . get <identifiersep> key ( ) ) , entry . get <identifiersep> value ( ) ) ; } return kt <identifiersep> file ; } protected abstract kt <identifiersep> file create <identifiersep> kt <identifiersep> file ( string file <identifiersep> name , string text ) ; protected static binding <identifiersep> context analyze ( list < kt <identifiersep> file > files , kotlin <identifiersep> core <identifiersep> environment environment ) { <LOG> if ( files . is <identifiersep> empty ( ) ) { return binding <identifiersep> context . empty ; } return jvm <identifiersep> resolve <identifiersep> util . analyze ( files , environment ) . get <identifiersep> binding <identifiersep> context ( ) ; } public final void check <identifiersep> result ( binding <identifiersep> context binding <identifiersep> context ) { set < psi <identifiersep> element > unresolved <identifiersep> references = sets . new <identifiersep> hash <identifiersep> set ( ) ; for ( diagnostic diagnostic : binding <identifiersep> context . get <identifiersep> diagnostics ( ) ) { <ect>
new no <identifiersep> scope <identifiersep> record <identifiersep> cli <identifiersep> binding <identifiersep> trace ( ) ) ; class <identifiersep> file <identifiersep> factory = generation <identifiersep> state . get <identifiersep> factory ( ) ; if ( verify <identifiersep> with <identifiersep> dex ( ) && dx <identifiersep> checker . run <identifiersep> dx <identifiersep> checker ) { dx <identifiersep> checker . check ( class <identifiersep> file <identifiersep> factory ) ; } } catch ( throwable e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; try { if ( class <identifiersep> file <identifiersep> factory == null ) { system . err . println ( <string_literal> ) ; } else { system . err . println ( class <identifiersep> file <identifiersep> factory . create <identifiersep> text ( ) ) ; <ect>
system . err . println ( <string_literal> ) ; try { if ( class <identifiersep> file <identifiersep> factory == null ) { system . err . println ( <string_literal> ) ; } else { system . err . println ( class <identifiersep> file <identifiersep> factory . create <identifiersep> text ( ) ) ; } } <LOG> catch ( throwable e1 ) { e1 . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; } fail ( <string_literal> ) ; } } return class <identifiersep> file <identifiersep> factory ; } protected boolean verify <identifiersep> with <identifiersep> dex ( ) { <ect>
analyzer < basic <identifiersep> value > analyzer = new analyzer < > ( verifier ) ; boolean no <identifiersep> errors = true ; for ( method <identifiersep> node method : class <identifiersep> node . methods ) { try { analyzer . analyze ( class <identifiersep> node . name , method ) ; } catch ( throwable e ) { <LOG> system . err . println ( file . as <identifiersep> text ( ) ) ; <comment> <ect>
if ( compiler <identifiersep> id . compiler <identifiersep> classpath . none ( ) ) throw illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) else println ( <string_literal> + compiler <identifiersep> id . compiler <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( file . path <identifiersep> separator ) ) } val daemon = connect <identifiersep> to <identifiersep> compile <identifiersep> service ( compiler <identifiersep> id , daemon <identifiersep> launching <identifiersep> options , daemon <identifiersep> options , daemon <identifiersep> reporting <identifiersep> targets ( out = system . out ) , autostart = ! client <identifiersep> options . stop , check <identifiersep> id = ! client <identifiersep> options . stop ) if ( daemon == null ) { <LOG> if ( client <identifiersep> options . stop ) { } else throw exception ( <string_literal> ) } else when { client <identifiersep> options . stop - > { println ( <string_literal> ) daemon . shutdown ( ) <ect>
<comment> <LOG> if ( ! it . file . exists ( ) ) { true } <comment> <ect>
true } <comment> <LOG> catch ( e : io <identifiersep> exception ) { true <comment> <ect>
override fun get <identifiersep> daemon <identifiersep> options ( ) : compile <identifiersep> service . call <identifiersep> result < daemon <identifiersep> options > = if <identifiersep> alive { compile <identifiersep> service . call <identifiersep> result . good ( daemon <identifiersep> options ) } override fun get <identifiersep> daemon <identifiersep> jvm <identifiersep> options ( ) : compile <identifiersep> service . call <identifiersep> result < daemon <identifiersep> jvm <identifiersep> options > = if <identifiersep> alive { log . info ( <string_literal> ) <comment> <LOG> state . add <identifiersep> client ( alive <identifiersep> flag <identifiersep> path ) compile <identifiersep> service . call <identifiersep> result . ok ( ) } override fun get <identifiersep> clients ( ) : compile <identifiersep> service . call <identifiersep> result < list < string > > = if <identifiersep> alive { compile <identifiersep> service . call <identifiersep> result . good ( state . get <identifiersep> clients <identifiersep> flag <identifiersep> paths ( ) ) } <comment> <ect>
override fun lease <identifiersep> compile <identifiersep> session ( alive <identifiersep> flag <identifiersep> path : string ? ) : compile <identifiersep> service . call <identifiersep> result < int > = if <identifiersep> alive ( min <identifiersep> aliveness = aliveness . alive ) { compile <identifiersep> service . call <identifiersep> result . good ( state . sessions . lease <identifiersep> session ( client <identifiersep> or <identifiersep> session <identifiersep> proxy < any > ( alive <identifiersep> flag <identifiersep> path ) ) . apply { log . info ( <string_literal> ) } ) } override fun release <identifiersep> compile <identifiersep> session ( session <identifiersep> id : int ) = if <identifiersep> alive ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { <LOG> state . sessions . remove ( session <identifiersep> id ) rwlock . write { clear <identifiersep> jar <identifiersep> cache ( ) } if ( state . sessions . is <identifiersep> empty ( ) ) { <comment> <ect>
exception <identifiersep> logging <identifiersep> timer <identifiersep> thread { periodic <identifiersep> and <identifiersep> after <identifiersep> session <identifiersep> check ( ) } } timer . schedule ( delay = daemon <identifiersep> periodic <identifiersep> seldom <identifiersep> check <identifiersep> interval <identifiersep> ms + <number_literal> , period = daemon <identifiersep> periodic <identifiersep> seldom <identifiersep> check <identifiersep> interval <identifiersep> ms ) { exception <identifiersep> logging <identifiersep> timer <identifiersep> thread { periodic <identifiersep> seldom <identifiersep> check ( ) } } } private inline fun exception <identifiersep> logging <identifiersep> timer <identifiersep> thread ( body : ( ) - > unit ) { try { body ( ) } <LOG> catch ( e : throwable ) { e . print <identifiersep> stack <identifiersep> trace ( system . err ) log . log ( level . severe , <string_literal> , e ) } } private fun periodic <identifiersep> and <identifiersep> after <identifiersep> session <identifiersep> check ( ) { if ( state . delayed <identifiersep> shutdown <identifiersep> queued . get ( ) ) return val any <identifiersep> dead = state . sessions . clean <identifiersep> dead ( ) || state . clean <identifiersep> dead <identifiersep> clients ( ) <ect>
private fun periodic <identifiersep> and <identifiersep> after <identifiersep> session <identifiersep> check ( ) { if ( state . delayed <identifiersep> shutdown <identifiersep> queued . get ( ) ) return val any <identifiersep> dead = state . sessions . clean <identifiersep> dead ( ) || state . clean <identifiersep> dead <identifiersep> clients ( ) if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { when { <comment> <LOG> state . alive . get ( ) == aliveness . last <identifiersep> session . ordinal && state . sessions . is <identifiersep> empty ( ) - > { shutdown <identifiersep> with <identifiersep> delay ( ) return } state . alive <identifiersep> clients <identifiersep> count == 0 - > { log . info ( <string_literal> ) shutdown <identifiersep> with <identifiersep> delay ( ) <ect>
return } state . alive <identifiersep> clients <identifiersep> count == 0 - > { log . info ( <string_literal> ) shutdown <identifiersep> with <identifiersep> delay ( ) return } <comment> <LOG> ! run <identifiersep> file . exists ( ) - > { shutdown <identifiersep> with <identifiersep> delay ( ) return } } } if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . alive ) { when { daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds != compile <identifiersep> daemon <identifiersep> timeout <identifiersep> infinite <identifiersep> s && compilations <identifiersep> counter . get ( ) == 0 && now <identifiersep> seconds ( ) - last <identifiersep> used <identifiersep> seconds > daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds - > { <ect>
return } } } if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . alive ) { when { daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds != compile <identifiersep> daemon <identifiersep> timeout <identifiersep> infinite <identifiersep> s && compilations <identifiersep> counter . get ( ) == 0 && now <identifiersep> seconds ( ) - last <identifiersep> used <identifiersep> seconds > daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds - > { log . info ( <string_literal> ) graceful <identifiersep> shutdown ( false ) } <LOG> daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds != compile <identifiersep> daemon <identifiersep> timeout <identifiersep> infinite <identifiersep> s && now <identifiersep> seconds ( ) - last <identifiersep> used <identifiersep> seconds > daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds - > { graceful <identifiersep> shutdown ( false ) } any <identifiersep> dead - > { clear <identifiersep> jar <identifiersep> cache ( ) } } } } private fun periodic <identifiersep> seldom <identifiersep> check ( ) { if <identifiersep> alive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . alive ) { <ect>
<comment> <LOG> if <identifiersep> alive <identifiersep> unit { val alive <identifiersep> with <identifiersep> opts = walk <identifiersep> daemons ( file ( daemon <identifiersep> options . run <identifiersep> files <identifiersep> path <identifiersep> or <identifiersep> default ) , compiler <identifiersep> id , run <identifiersep> file , filter = {  <identifiersep>  , p - > p != port } , report = {  <identifiersep>  , msg - > log . info ( msg ) } ) . to <identifiersep> list ( ) val comparator = compare <identifiersep> by <identifiersep> descending < daemon <identifiersep> with <identifiersep> metadata , daemon <identifiersep> jvm <identifiersep> options > ( daemon <identifiersep> jvm <identifiersep> options <identifiersep> memory <identifiersep> comparator ( ) , { it . jvm <identifiersep> options } ) . then <identifiersep> by ( file <identifiersep> age <identifiersep> comparator ( ) ) { it . run <identifiersep> file } alive <identifiersep> with <identifiersep> opts . max <identifiersep> with ( comparator ) ? . let { best <identifiersep> daemon <identifiersep> with <identifiersep> metadata - > val fattest <identifiersep> opts = best <identifiersep> daemon <identifiersep> with <identifiersep> metadata . jvm <identifiersep> options <ect>
log . info ( <string_literal> ) alive <identifiersep> with <identifiersep> opts . for <identifiersep> each { ( daemon , run <identifiersep> file ,  <identifiersep>  ) - > try { daemon . get <identifiersep> clients ( ) . take <identifiersep> if { it . is <identifiersep> good } ? . let { it . get ( ) . for <identifiersep> each { client <identifiersep> alive <identifiersep> file - > register <identifiersep> client ( client <identifiersep> alive <identifiersep> file ) } } daemon . schedule <identifiersep> shutdown ( true ) } <LOG> catch ( e : throwable ) { } } } <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> with ( runtime . get <identifiersep> runtime ( ) ) { } state . alive . set ( aliveness . dying . ordinal ) unicast <identifiersep> remote <identifiersep> object . unexport <identifiersep> object ( this , true ) log . info ( <string_literal> ) on <identifiersep> shutdown ( ) log . handlers . for <identifiersep> each { it . flush ( ) } <ect>
on <identifiersep> shutdown ( ) log . handlers . for <identifiersep> each { it . flush ( ) } } private fun shutdown <identifiersep> with <identifiersep> delay ( ) { state . delayed <identifiersep> shutdown <identifiersep> queued . set ( true ) val current <identifiersep> clients <identifiersep> count = state . clients <identifiersep> counter val current <identifiersep> session <identifiersep> id = state . sessions . last <identifiersep> session <identifiersep> id <LOG> val current <identifiersep> compilations <identifiersep> count = compilations <identifiersep> counter . get ( ) timer . schedule ( daemon <identifiersep> options . shutdown <identifiersep> delay <identifiersep> milliseconds ) { state . delayed <identifiersep> shutdown <identifiersep> queued . set ( false ) if ( current <identifiersep> clients <identifiersep> count == state . clients <identifiersep> counter && current <identifiersep> compilations <identifiersep> count == compilations <identifiersep> counter . get ( ) && current <identifiersep> session <identifiersep> id == state . sessions . last <identifiersep> session <identifiersep> id ) <ect>
current <identifiersep> compilations <identifiersep> count == compilations <identifiersep> counter . get ( ) && current <identifiersep> session <identifiersep> id == state . sessions . last <identifiersep> session <identifiersep> id ) { if <identifiersep> alive <identifiersep> exclusive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { log . fine ( <string_literal> ) shutdown <identifiersep> now ( ) } } <LOG> else { } } } private fun graceful <identifiersep> shutdown ( on <identifiersep> another <identifiersep> thread : boolean ) : boolean { fun shutdown <identifiersep> if <identifiersep> idle ( ) = when { state . sessions . is <identifiersep> empty ( ) - > shutdown <identifiersep> with <identifiersep> delay ( ) else - > { daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds = time <identifiersep> unit . milliseconds . to <identifiersep> seconds ( daemon <identifiersep> options . force <identifiersep> shutdown <identifiersep> timeout <identifiersep> milliseconds ) . to <identifiersep> int ( ) <ect>
private fun graceful <identifiersep> shutdown ( on <identifiersep> another <identifiersep> thread : boolean ) : boolean { fun shutdown <identifiersep> if <identifiersep> idle ( ) = when { state . sessions . is <identifiersep> empty ( ) - > shutdown <identifiersep> with <identifiersep> delay ( ) else - > { daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds = time <identifiersep> unit . milliseconds . to <identifiersep> seconds ( daemon <identifiersep> options . force <identifiersep> shutdown <identifiersep> timeout <identifiersep> milliseconds ) . to <identifiersep> int ( ) daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds = daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds <LOG> log . info ( <string_literal> ) } } if ( ! state . alive . compare <identifiersep> and <identifiersep> set ( aliveness . alive . ordinal , aliveness . last <identifiersep> session . ordinal ) ) { log . info ( <string_literal> ) return false } log . info ( <string_literal> ) if ( ! on <identifiersep> another <identifiersep> thread ) { <ect>
daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds = time <identifiersep> unit . milliseconds . to <identifiersep> seconds ( daemon <identifiersep> options . force <identifiersep> shutdown <identifiersep> timeout <identifiersep> milliseconds ) . to <identifiersep> int ( ) daemon <identifiersep> options . autoshutdown <identifiersep> unused <identifiersep> seconds = daemon <identifiersep> options . autoshutdown <identifiersep> idle <identifiersep> seconds log . info ( <string_literal> ) log . info ( <string_literal> ) } } if ( ! state . alive . compare <identifiersep> and <identifiersep> set ( aliveness . alive . ordinal , aliveness . last <identifiersep> session . ordinal ) ) { log . info ( <string_literal> ) <LOG> return false } if ( ! on <identifiersep> another <identifiersep> thread ) { shutdown <identifiersep> if <identifiersep> idle ( ) } else { timer . schedule ( 1 ) { if <identifiersep> alive <identifiersep> exclusive <identifiersep> unit ( min <identifiersep> aliveness = aliveness . last <identifiersep> session ) { <ect>
catch ( e : io <identifiersep> exception ) { } } return null } @ jvm <identifiersep> static fun main ( args : array < string > ) { ensure <identifiersep> server <identifiersep> hostname <identifiersep> is <identifiersep> set <identifiersep> up ( ) val jvm <identifiersep> arguments = management <identifiersep> factory . get <identifiersep> runtime <identifiersep> mx <identifiersep> bean ( ) . input <identifiersep> arguments <LOG> log . info ( <string_literal> + ( load <identifiersep> version <identifiersep> from <identifiersep> resource ( ) ? : <string_literal> ) ) log . info ( <string_literal> + args . join <identifiersep> to <identifiersep> string ( <string_literal> ) ) set <identifiersep> idea <identifiersep> io <identifiersep> use <identifiersep> fallback ( ) val compiler <identifiersep> id = compiler <identifiersep> id ( ) val daemon <identifiersep> options = daemon <identifiersep> options ( ) try { <ect>
inherit <identifiersep> additional <identifiersep> properties = true ) val filtered <identifiersep> args = args . as <identifiersep> iterable ( ) . filter <identifiersep> extract <identifiersep> props ( compiler <identifiersep> id , daemon <identifiersep> options , prefix = compile <identifiersep> daemon <identifiersep> cmdline <identifiersep> options <identifiersep> prefix ) if ( filtered <identifiersep> args . any ( ) ) { val help <identifiersep> line = <string_literal> log . info ( help <identifiersep> line ) println ( help <identifiersep> line ) <LOG> throw illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + filtered <identifiersep> args . join <identifiersep> to <identifiersep> string ( <string_literal> ) ) } <comment> <ect>
cancel ( ) log . info ( <string_literal> ) system . exit ( 0 ) } } else { timer . cancel ( ) } } ) <LOG> println ( compile <identifiersep> daemon <identifiersep> is <identifiersep> ready <identifiersep> message ) <comment> <ect>
system . err . close ( ) system . set <identifiersep> err ( print <identifiersep> stream ( log <identifiersep> stream ( <string_literal> ) ) ) system . set <identifiersep> out ( print <identifiersep> stream ( log <identifiersep> stream ( <string_literal> ) ) ) } catch ( e : exception ) { system . err . println ( <string_literal> + e . message ) e . print <identifiersep> stack <identifiersep> trace ( system . err ) <LOG> <comment> <ect>
return accept ( debug <identifiersep> text <identifiersep> building <identifiersep> visitor , unit ) } private object debug <identifiersep> text <identifiersep> building <identifiersep> visitor : kt <identifiersep> visitor < string , unit > ( ) { private val log = logger . get <identifiersep> instance ( this : : class . java ) override fun visit <identifiersep> kt <identifiersep> file ( file : kt <identifiersep> file , data : unit ? ) : string ? { return <string_literal> } override fun visit <identifiersep> kt <identifiersep> element ( element : kt <identifiersep> element , data : unit ? ) : string ? { <LOG> if ( element is kt <identifiersep> element <identifiersep> impl <identifiersep> stub < * > ) { } return element . text } override fun visit <identifiersep> import <identifiersep> directive ( import <identifiersep> directive : kt <identifiersep> import <identifiersep> directive , data : unit ? ) : string ? { val import <identifiersep> path = import <identifiersep> directive . import <identifiersep> path ? : return <string_literal> val alias <identifiersep> str = if ( import <identifiersep> path . has <identifiersep> alias ( ) ) <string_literal> + import <identifiersep> path . alias ! ! . as <identifiersep> string ( ) else <string_literal> return <string_literal> + alias <identifiersep> str <ect>
@ jvm <identifiersep> static fun render <identifiersep> no <identifiersep> information <identifiersep> for <identifiersep> parameter <identifiersep> error ( inference <identifiersep> error <identifiersep> data : inference <identifiersep> error <identifiersep> data , result : tabled <identifiersep> descriptor <identifiersep> renderer ) : tabled <identifiersep> descriptor <identifiersep> renderer { val first <identifiersep> unknown <identifiersep> variable = inference <identifiersep> error <identifiersep> data . constraint <identifiersep> system . type <identifiersep> variables . first <identifiersep> or <identifiersep> null { variable - > inference <identifiersep> error <identifiersep> data . constraint <identifiersep> system . get <identifiersep> type <identifiersep> bounds ( variable ) . values . is <identifiersep> empty ( ) <LOG> } ? : return result . apply { } return result . text ( new <identifiersep> text ( ) . normal ( <string_literal> ) . strong ( first <identifiersep> unknown <identifiersep> variable . name ) . normal ( <string_literal> ) <ect>
fun render <identifiersep> cannot <identifiersep> capture <identifiersep> type <identifiersep> parameter <identifiersep> error ( inference <identifiersep> error <identifiersep> data : inference <identifiersep> error <identifiersep> data , result : tabled <identifiersep> descriptor <identifiersep> renderer ) : tabled <identifiersep> descriptor <identifiersep> renderer { val system = inference <identifiersep> error <identifiersep> data . constraint <identifiersep> system val errors = system . status . constraint <identifiersep> errors val type <identifiersep> variable <identifiersep> with <identifiersep> captured <identifiersep> constraint = errors . first <identifiersep> is <identifiersep> instance <identifiersep> or <identifiersep> null < cannot <identifiersep> capture > ( ) ? . type <identifiersep> variable <LOG> if ( type <identifiersep> variable <identifiersep> with <identifiersep> captured <identifiersep> constraint == null ) { return result } val type <identifiersep> bounds = system . get <identifiersep> type <identifiersep> bounds ( type <identifiersep> variable <identifiersep> with <identifiersep> captured <identifiersep> constraint ) val bound <identifiersep> with <identifiersep> captured <identifiersep> type = type <identifiersep> bounds . bounds . first <identifiersep> or <identifiersep> null { it . constraining <identifiersep> type . is <identifiersep> captured ( ) } val captured <identifiersep> type <identifiersep> constructor = bound <identifiersep> with <identifiersep> captured <identifiersep> type ? . constraining <identifiersep> type ? . constructor as ? captured <identifiersep> type <identifiersep> constructor if ( captured <identifiersep> type <identifiersep> constructor == null ) { <ect>
val expression = ( resolved <identifiersep> call . extension <identifiersep> receiver as ? expression <identifiersep> receiver ) ? . expression ? . let ( kt <identifiersep> psi <identifiersep> util : : safe <identifiersep> deparenthesize ) if ( expression ! is kt <identifiersep> callable <identifiersep> reference <identifiersep> expression ) { context . trace . report ( lateinit <identifiersep> intrinsic <identifiersep> call <identifiersep> on <identifiersep> non <identifiersep> literal . on ( report <identifiersep> on ) ) } else { val property <identifiersep> reference <identifiersep> resolved <identifiersep> call = expression . callable <identifiersep> reference . get <identifiersep> resolved <identifiersep> call ( context . trace . binding <identifiersep> context ) ? : return val referenced <identifiersep> property = property <identifiersep> reference <identifiersep> resolved <identifiersep> call . resulting <identifiersep> descriptor <LOG> if ( referenced <identifiersep> property ! is property <identifiersep> descriptor ) { } if ( ! referenced <identifiersep> property . is <identifiersep> late <identifiersep> init ) { context . trace . report ( lateinit <identifiersep> intrinsic <identifiersep> call <identifiersep> on <identifiersep> non <identifiersep> lateinit . on ( report <identifiersep> on ) ) } else if ( ! is <identifiersep> backing <identifiersep> field <identifiersep> accessible ( referenced <identifiersep> property , context ) ) { context . trace . report ( lateinit <identifiersep> intrinsic <identifiersep> call <identifiersep> on <identifiersep> non <identifiersep> accessible <identifiersep> property . on ( report <identifiersep> on , referenced <identifiersep> property ) ) } else if ( ( context . scope . owner <identifiersep> descriptor as ? function <identifiersep> descriptor ) ? . is <identifiersep> inline == true ) { <ect>
kt <identifiersep> expression callee <identifiersep> expression = call . get <identifiersep> callee <identifiersep> expression ( ) ; if ( callee <identifiersep> expression instanceof kt <identifiersep> when <identifiersep> expression || callee <identifiersep> expression instanceof kt <identifiersep> if <identifiersep> expression ) { if ( status . has <identifiersep> conflicting <identifiersep> constraints ( ) || status . has <identifiersep> type <identifiersep> inference <identifiersep> incorporation <identifiersep> error ( ) ) { <comment> <LOG> kt <identifiersep> declaration parent <identifiersep> declaration = psi <identifiersep> tree <identifiersep> util . get <identifiersep> parent <identifiersep> of <identifiersep> type ( expression , kt <identifiersep> named <identifiersep> declaration . class ) ; <string_literal> + constraints <identifiersep> util . get <identifiersep> debug <identifiersep> message <identifiersep> for <identifiersep> status ( status ) ) ; } private boolean no <identifiersep> type <identifiersep> checking <identifiersep> errors <identifiersep> in <identifiersep> expression ( kt <identifiersep> expression expression , @ not <identifiersep> null binding <identifiersep> trace trace , @ not <identifiersep> null kotlin <identifiersep> type expected <identifiersep> type <ect>
<comment> package org . jetbrains . eval4j . jdi . test ; public class debugee { public static void main ( string [ ] args ) { <comment> <LOG> runtime . get <identifiersep> runtime ( ) ; } } <ect>
s . print ( text ) ; } @ not <identifiersep> null @ override public synchronized throwable fill <identifiersep> in <identifiersep> stack <identifiersep> trace ( ) { return this ; } @ override <LOG> public stack <identifiersep> trace <identifiersep> element [ ] get <identifiersep> stack <identifiersep> trace ( ) { <comment> <ect>
return false } override fun get <identifiersep> summary <identifiersep> coverage <identifiersep> info ( coverage <identifiersep> annotator : java <identifiersep> coverage <identifiersep> annotator , element : psi <identifiersep> named <identifiersep> element ) : package <identifiersep> annotator . class <identifiersep> coverage <identifiersep> info ? { if ( element ! is kt <identifiersep> file ) { <LOG> return null } val qualified <identifiersep> names = collect <identifiersep> generated <identifiersep> class <identifiersep> qualified <identifiersep> names ( find <identifiersep> output <identifiersep> root ( element ) , element ) return if ( qualified <identifiersep> names == null ) null else total <identifiersep> coverage <identifiersep> for <identifiersep> qualified <identifiersep> names ( coverage <identifiersep> annotator , qualified <identifiersep> names ) } override fun keep <identifiersep> coverage <identifiersep> info <identifiersep> for <identifiersep> class <identifiersep> without <identifiersep> source ( bundle : coverage <identifiersep> suites <identifiersep> bundle , class <identifiersep> file : file ) : boolean { <comment> <ect>
result . covered <identifiersep> class <identifiersep> count += class <identifiersep> info . covered <identifiersep> class <identifiersep> count result . total <identifiersep> method <identifiersep> count += class <identifiersep> info . total <identifiersep> method <identifiersep> count result . covered <identifiersep> method <identifiersep> count += class <identifiersep> info . covered <identifiersep> method <identifiersep> count result . total <identifiersep> line <identifiersep> count += class <identifiersep> info . total <identifiersep> line <identifiersep> count result . fully <identifiersep> covered <identifiersep> line <identifiersep> count += class <identifiersep> info . fully <identifiersep> covered <identifiersep> line <identifiersep> count result . partially <identifiersep> covered <identifiersep> line <identifiersep> count += class <identifiersep> info . partially <identifiersep> covered <identifiersep> line <identifiersep> count <LOG> } else { } } return result } private fun get <identifiersep> classes <identifiersep> generated <identifiersep> from <identifiersep> file ( output <identifiersep> root : virtual <identifiersep> file ? , file : kt <identifiersep> file ) : list < virtual <identifiersep> file > { val relative <identifiersep> path = file . package <identifiersep> fq <identifiersep> name . as <identifiersep> string ( ) . replace ( ' . ' , ' / ' ) val package <identifiersep> output <identifiersep> dir = output <identifiersep> root ? . find <identifiersep> file <identifiersep> by <identifiersep> relative <identifiersep> path ( relative <identifiersep> path ) if ( package <identifiersep> output <identifiersep> dir == null ) return list <identifiersep> of ( ) <ect>
if ( file <identifiersep> util . files <identifiersep> equal ( updated <identifiersep> file , jar <identifiersep> io <identifiersep> file <identifiersep> to <identifiersep> replace ) ) { return null } file <identifiersep> util . copy ( updated <identifiersep> file , jar <identifiersep> io <identifiersep> file <identifiersep> to <identifiersep> replace ) if ( jar <identifiersep> io <identifiersep> file <identifiersep> to <identifiersep> replace . name != updated <identifiersep> file . name ) { val new <identifiersep> file = file ( jar <identifiersep> io <identifiersep> file <identifiersep> to <identifiersep> replace . parent , updated <identifiersep> file . name ) if ( ! new <identifiersep> file . exists ( ) ) { <LOG> if ( ! jar <identifiersep> io <identifiersep> file <identifiersep> to <identifiersep> replace . rename <identifiersep> to ( new <identifiersep> file ) ) { return null } val new <identifiersep> v <identifiersep> file = local <identifiersep> file <identifiersep> system . get <identifiersep> instance ( ) . refresh <identifiersep> and <identifiersep> find <identifiersep> file <identifiersep> by <identifiersep> io <identifiersep> file ( new <identifiersep> file ) if ( new <identifiersep> v <identifiersep> file == null ) { log . info ( <string_literal> ) return null <ect>
panel <identifiersep> class . get <identifiersep> declared <identifiersep> fields ( ) , new function1 < field , boolean > ( ) { @ override public boolean invoke ( field field ) { return radio <identifiersep> button <identifiersep> enum <identifiersep> model . class . is <identifiersep> assignable <identifiersep> from ( field . get <identifiersep> type ( ) ) ; } } ) ; <LOG> if ( model <identifiersep> field == null ) { return false ; } model <identifiersep> field . set <identifiersep> accessible ( true ) ; radio <identifiersep> button <identifiersep> enum <identifiersep> model enum <identifiersep> model = ( radio <identifiersep> button <identifiersep> enum <identifiersep> model ) model <identifiersep> field . get ( panel ) ; int ordinal = enum <identifiersep> model . get <identifiersep> selected ( ) . ordinal ( ) ; if ( ordinal == 0 ) { <ect>
log . error ( <string_literal> + arrays . to <identifiersep> string ( panel <identifiersep> class . get <identifiersep> declared <identifiersep> fields ( ) ) ) ; return false ; } lib <identifiersep> combobox <identifiersep> field . set <identifiersep> accessible ( true ) ; j <identifiersep> combo <identifiersep> box combobox = ( j <identifiersep> combo <identifiersep> box ) lib <identifiersep> combobox <identifiersep> field . get ( panel ) ; return combobox . get <identifiersep> selected <identifiersep> item ( ) != null ; } return ordinal != <number_literal> ; } <LOG> catch ( exception e ) { } return null ; } } <ect>
val field = ref <identifiersep> type . field <identifiersep> by <identifiersep> name ( get <identifiersep> field <identifiersep> name ( ) ) if ( field != null ) { val manager = debug <identifiersep> process . requests <identifiersep> manager if ( properties . watch <identifiersep> modification && vm . can <identifiersep> watch <identifiersep> field <identifiersep> modification ( ) ) { val request = manager . create <identifiersep> modification <identifiersep> watchpoint <identifiersep> request ( this , field ) <LOG> debug <identifiersep> process . requests <identifiersep> manager . enable <identifiersep> request ( request ) } } if ( properties . watch <identifiersep> access && vm . can <identifiersep> watch <identifiersep> field <identifiersep> access ( ) ) { val request = manager . create <identifiersep> access <identifiersep> watchpoint <identifiersep> request ( this , field ) debug <identifiersep> process . requests <identifiersep> manager . enable <identifiersep> request ( request ) log . debug ( <string_literal> ) <ect>
} ) if ( context <identifiersep> element != null && context <identifiersep> element ! is kt <identifiersep> element ) { code <identifiersep> fragment . put <identifiersep> copyable <identifiersep> user <identifiersep> data ( kt <identifiersep> code <identifiersep> fragment . fake <identifiersep> context <identifiersep> for <identifiersep> java <identifiersep> file , { val empty <identifiersep> file = create <identifiersep> fake <identifiersep> file <identifiersep> with <identifiersep> java <identifiersep> context <identifiersep> element ( <string_literal> , context <identifiersep> element ) val debugger <identifiersep> context = debugger <identifiersep> manager <identifiersep> ex . get <identifiersep> instance <identifiersep> ex ( project ) . context val debugger <identifiersep> session = debugger <identifiersep> context . debugger <identifiersep> session <LOG> if ( ( debugger <identifiersep> session == null || debugger <identifiersep> context . suspend <identifiersep> context == null ) && ! application <identifiersep> manager . get <identifiersep> application ( ) . is <identifiersep> unit <identifiersep> test <identifiersep> mode ) { return @ put <identifiersep> copyable <identifiersep> user <identifiersep> data empty <identifiersep> file } val frame <identifiersep> descriptor = get <identifiersep> frame <identifiersep> info ( context <identifiersep> element , debugger <identifiersep> context ) if ( frame <identifiersep> descriptor == null ) { log . warn ( <string_literal> ) return @ put <identifiersep> copyable <identifiersep> user <identifiersep> data empty <identifiersep> file <ect>
new <identifiersep> text , new <identifiersep> imports , kotlin <identifiersep> code <identifiersep> fragment . context ) after <identifiersep> conversion <identifiersep> pass ( project , j2k <identifiersep> post <identifiersep> processor ( format <identifiersep> code = false ) ) . run ( converted <identifiersep> fragment ! ! , range = null ) } } catch ( e : throwable ) { <LOG> <comment> <ect>
throw evaluate <identifiersep> exception <identifiersep> util . create <identifiersep> evaluate <identifiersep> exception ( <string_literal> + <string_literal> ) } } if ( code <identifiersep> fragment . context ! is kt <identifiersep> element ) { val attachments = array <identifiersep> of ( attachment <identifiersep> by <identifiersep> psi <identifiersep> file ( position . file ) , attachment <identifiersep> by <identifiersep> psi <identifiersep> file ( code <identifiersep> fragment ) , <LOG> attachment ( <string_literal> , <string_literal> ) ) throw evaluate <identifiersep> exception <identifiersep> util . create <identifiersep> evaluate <identifiersep> exception ( <string_literal> ) } return expression <identifiersep> evaluator <identifiersep> impl ( kotlin <identifiersep> evaluator ( code <identifiersep> fragment , position ) ) } } class kotlin <identifiersep> evaluator ( val code <identifiersep> fragment : kt <identifiersep> code <identifiersep> fragment , val source <identifiersep> position : source <identifiersep> position ) : evaluator { override fun evaluate ( context : evaluation <identifiersep> context <identifiersep> impl ) : any ? { if ( code <identifiersep> fragment . text . is <identifiersep> empty ( ) ) { <ect>
val extracted <identifiersep> function = extraction <identifiersep> result . declaration as kt <identifiersep> named <identifiersep> function log . debug ( <string_literal> + run <identifiersep> read <identifiersep> action { extracted <identifiersep> function . text } ) } val class <identifiersep> file <identifiersep> factory = create <identifiersep> class <identifiersep> file <identifiersep> factory ( code <identifiersep> fragment , extracted <identifiersep> function , context , parameters <identifiersep> descriptor ) val output <identifiersep> files = class <identifiersep> file <identifiersep> factory . as <identifiersep> list ( ) . filter <identifiersep> class <identifiersep> files ( ) <LOG> for ( file in output <identifiersep> files ) { } if ( debug <identifiersep> mode ) { println ( file . as <identifiersep> text ( ) ) } } val additional <identifiersep> files = output <identifiersep> files . map { class <identifiersep> to <identifiersep> load ( get <identifiersep> class <identifiersep> name ( it . relative <identifiersep> path ) , it . relative <identifiersep> path , it . as <identifiersep> byte <identifiersep> array ( ) ) } return compiled <identifiersep> data <identifiersep> descriptor ( additional <identifiersep> files , <ect>
val frame <identifiersep> visitor = frame <identifiersep> visitor ( this ) return parameters . zip ( parameter <identifiersep> types ) . map { val result = if ( it . first . value != null ) { it . first . value ! ! } else { <LOG> frame <identifiersep> visitor . find <identifiersep> value ( it . first . call <identifiersep> text , it . second , check <identifiersep> type = false , fail <identifiersep> if <identifiersep> not <identifiersep> found = true ) ! ! } } result } } private fun create <identifiersep> class <identifiersep> file <identifiersep> factory ( code <identifiersep> fragment : kt <identifiersep> code <identifiersep> fragment , extracted <identifiersep> function : kt <identifiersep> named <identifiersep> function , context : evaluation <identifiersep> context <identifiersep> impl , <ect>
if ( param <identifiersep> anonymous <identifiersep> type != null ) { val declaration <identifiersep> descriptor = param <identifiersep> anonymous <identifiersep> type . constructor . declaration <identifiersep> descriptor if ( declaration <identifiersep> descriptor is class <identifiersep> descriptor ) { val local <identifiersep> variable = visitor . find <identifiersep> value ( local <identifiersep> variable <identifiersep> name , asm <identifiersep> type = null , check <identifiersep> type = false , fail <identifiersep> if <identifiersep> not <identifiersep> found = false ) ? : exception ( <string_literal> ) <LOG> record ( codegen <identifiersep> binding . asm <identifiersep> type , declaration <identifiersep> descriptor , local <identifiersep> variable . asm <identifiersep> type ) } } } } private fun exception ( msg : string ) : nothing = throw evaluate <identifiersep> exception <identifiersep> util . create <identifiersep> evaluate <identifiersep> exception ( msg ) private fun exception ( e : throwable ) : nothing = throw evaluate <identifiersep> exception <identifiersep> util . create <identifiersep> evaluate <identifiersep> exception ( e ) private val ignored <identifiersep> diagnostics : set < diagnostic <identifiersep> factory < * > > = errors . invisible <identifiersep> reference <identifiersep> diagnostics <comment> <ect>
catch ( e : file <identifiersep> not <identifiersep> found <identifiersep> exception ) { null } } override fun has <identifiersep> metadata <identifiersep> package ( fq <identifiersep> name : fq <identifiersep> name ) : boolean = kotlin <identifiersep> metadata <identifiersep> file <identifiersep> package <identifiersep> index . has <identifiersep> something <identifiersep> in <identifiersep> package ( fq <identifiersep> name , scope ) <comment> <LOG> if ( scope != global <identifiersep> search <identifiersep> scope . empty <identifiersep> scope && scope . project == null ) { } } override fun find <identifiersep> virtual <identifiersep> file <identifiersep> with <identifiersep> header ( class <identifiersep> id : class <identifiersep> id ) : virtual <identifiersep> file ? = find <identifiersep> virtual <identifiersep> file <identifiersep> with <identifiersep> header ( class <identifiersep> id , kotlin <identifiersep> class <identifiersep> file <identifiersep> index . key ) private fun find <identifiersep> virtual <identifiersep> file <identifiersep> with <identifiersep> header ( class <identifiersep> id : class <identifiersep> id , key : id < fq <identifiersep> name , void > ) : virtual <identifiersep> file ? { val files = file <identifiersep> based <identifiersep> index . get <identifiersep> instance ( ) . get <identifiersep> containing <identifiersep> files < fq <identifiersep> name , void > ( key , class <identifiersep> id . as <identifiersep> single <identifiersep> fq <identifiersep> name ( ) , scope ) if ( files . size > 1 ) { <ect>
try { val fq <identifiersep> name = f ( it ) if ( fq <identifiersep> name != null ) { collections . singleton <identifiersep> map < fq <identifiersep> name , void > ( fq <identifiersep> name , null ) } else { empty <identifiersep> map ( ) } } <LOG> catch ( e : throwable ) { empty <identifiersep> map ( ) } } } fun < t > kotlin <identifiersep> file <identifiersep> index <identifiersep> base < t > . has <identifiersep> something <identifiersep> in <identifiersep> package ( fq <identifiersep> name : fq <identifiersep> name , scope : global <identifiersep> search <identifiersep> scope ) : boolean = ! file <identifiersep> based <identifiersep> index . get <identifiersep> instance ( ) . process <identifiersep> values ( name , fq <identifiersep> name , null , {  <identifiersep>  ,  <identifiersep>  - > false } , scope ) object kotlin <identifiersep> class <identifiersep> file <identifiersep> index : kotlin <identifiersep> file <identifiersep> index <identifiersep> base < kotlin <identifiersep> class <identifiersep> file <identifiersep> index > ( kotlin <identifiersep> class <identifiersep> file <identifiersep> index : : class . java ) { override fun get <identifiersep> indexer ( ) = indexer <ect>
return ( ( variable <identifiersep> descriptor ) descriptor ) . is <identifiersep> var ( ) ? kotlin <identifiersep> icons . var : kotlin <identifiersep> icons . val ; } if ( descriptor instanceof property <identifiersep> descriptor ) { return ( ( variable <identifiersep> descriptor ) descriptor ) . is <identifiersep> var ( ) ? kotlin <identifiersep> icons . field <identifiersep> var : kotlin <identifiersep> icons . field <identifiersep> val ; } if ( descriptor instanceof type <identifiersep> parameter <identifiersep> descriptor ) { return platform <identifiersep> icons . class <identifiersep> icon ; } if ( descriptor instanceof type <identifiersep> alias <identifiersep> descriptor ) { <LOG> return kotlin <identifiersep> icons . type <identifiersep> alias ; } return null ; } } <ect>
else - > null } ? : continue import <identifiersep> insert <identifiersep> helper . import <identifiersep> descriptor ( file , descriptor <identifiersep> to <identifiersep> import ) } } } } private val log = logger . get <identifiersep> instance ( project : : class . java . canonical <identifiersep> name ) fun prepare <identifiersep> delayed <identifiersep> requests ( project : project ) { val requests = project . delayed <identifiersep> refactoring <identifiersep> requests <LOG> if ( project . ensure <identifiersep> no <identifiersep> refactoring <identifiersep> requests <identifiersep> before <identifiersep> refactoring && requests != null && ! requests . is <identifiersep> empty ( ) ) { project . delayed <identifiersep> refactoring <identifiersep> requests = null } } var kt <identifiersep> element . is <identifiersep> to <identifiersep> be <identifiersep> shortened : boolean ? by copyable <identifiersep> psi <identifiersep> user <identifiersep> data <identifiersep> property ( key . create ( <string_literal> ) ) fun kt <identifiersep> element . add <identifiersep> to <identifiersep> be <identifiersep> shortened <identifiersep> descendants <identifiersep> to <identifiersep> waiting <identifiersep> set ( ) { for <identifiersep> each <identifiersep> descendant <identifiersep> of <identifiersep> type < kt <identifiersep> element > { if ( it . is <identifiersep> to <identifiersep> be <identifiersep> shortened ? : false ) { <ect>
private val is <identifiersep> final : boolean , private val has <identifiersep> implementation : boolean , private val substitute <identifiersep> object <identifiersep> with : psi <identifiersep> type ? , private val provided <identifiersep> signature : method <identifiersep> signature ? ) : psi <identifiersep> method , kt <identifiersep> light <identifiersep> element <identifiersep> base ( containing <identifiersep> class ) { init { <LOG> if ( ! has <identifiersep> implementation && is <identifiersep> final ) { } } private fun substitute <identifiersep> type ( psi <identifiersep> type : psi <identifiersep> type ) : psi <identifiersep> type { val substituted = containing <identifiersep> class . substitutor . substitute ( psi <identifiersep> type ) return if ( type <identifiersep> utils . is <identifiersep> java <identifiersep> lang <identifiersep> object ( substituted ) && substitute <identifiersep> object <identifiersep> with != null ) { substitute <identifiersep> object <identifiersep> with } else { <ect>
private fun create <identifiersep> stub ( file : virtual <identifiersep> file ) : psi <identifiersep> java <identifiersep> file <identifiersep> stub ? { if ( file . file <identifiersep> type != = java <identifiersep> class <identifiersep> file <identifiersep> type . instance ) return null try { return cls <identifiersep> file <identifiersep> impl . build <identifiersep> file <identifiersep> stub ( file , file . contents <identifiersep> to <identifiersep> byte <identifiersep> array ( false ) ) } catch ( e : cls <identifiersep> format <identifiersep> exception ) { log . error ( <string_literal> + file . canonical <identifiersep> path ! ! , e ) <LOG> } catch ( e : io <identifiersep> exception ) { } return null } companion object { private val log = logger . get <identifiersep> instance ( cls <identifiersep> java <identifiersep> stub <identifiersep> by <identifiersep> virtual <identifiersep> file <identifiersep> cache : : class . java ) fun get <identifiersep> instance ( project : project ) : cls <identifiersep> java <identifiersep> stub <identifiersep> by <identifiersep> virtual <identifiersep> file <identifiersep> cache { return service <identifiersep> manager . get <identifiersep> service ( project , cls <identifiersep> java <identifiersep> stub <identifiersep> by <identifiersep> virtual <identifiersep> file <identifiersep> cache : : class . java ) <ect>
force <identifiersep> resolve <identifiersep> package <identifiersep> declarations ( files , resolve <identifiersep> session ) return ide <identifiersep> light <identifiersep> class <identifiersep> construction <identifiersep> context ( resolve <identifiersep> session . binding <identifiersep> context , resolve <identifiersep> session . module <identifiersep> descriptor , exact ) } fun context <identifiersep> for <identifiersep> script ( script : kt <identifiersep> script ) : light <identifiersep> class <identifiersep> construction <identifiersep> context { val resolution <identifiersep> facade = script . get <identifiersep> resolution <identifiersep> facade ( ) val binding <identifiersep> context = resolution <identifiersep> facade . analyze ( script ) val descriptor = binding <identifiersep> context [ binding <identifiersep> context . script , script ] <LOG> if ( descriptor == null ) { return ide <identifiersep> light <identifiersep> class <identifiersep> construction <identifiersep> context ( binding <identifiersep> context , resolution <identifiersep> facade . module <identifiersep> descriptor , exact ) } force <identifiersep> resolve <identifiersep> util . force <identifiersep> resolve <identifiersep> all <identifiersep> contents ( descriptor ) return ide <identifiersep> light <identifiersep> class <identifiersep> construction <identifiersep> context ( binding <identifiersep> context , resolution <identifiersep> facade . module <identifiersep> descriptor , exact ) } fun light <identifiersep> context <identifiersep> for <identifiersep> class <identifiersep> or <identifiersep> object ( class <identifiersep> or <identifiersep> object : kt <identifiersep> class <identifiersep> or <identifiersep> object ) : light <identifiersep> class <identifiersep> construction <identifiersep> context ? { if ( ! is <identifiersep> dummy <identifiersep> resolve <identifiersep> applicable ( class <identifiersep> or <identifiersep> object ) ) return null <ect>
val name = declaration . name <identifiersep> as <identifiersep> safe <identifiersep> name val properties = package <identifiersep> descriptor . member <identifiersep> scope . get <identifiersep> contributed <identifiersep> variables ( name , no <identifiersep> lookup <identifiersep> location . from <identifiersep> ide ) for ( descriptor in properties ) { force <identifiersep> resolve <identifiersep> util . force <identifiersep> resolve <identifiersep> all <identifiersep> contents ( descriptor ) } } is kt <identifiersep> class <identifiersep> or <identifiersep> object , is kt <identifiersep> type <identifiersep> alias , is kt <identifiersep> destructuring <identifiersep> declaration - > { <comment> <LOG> <comment> <ect>
val on <identifiersep> result : ( idea <identifiersep> module <identifiersep> info ? ) - > t , val on <identifiersep> failure : ( string ) - > t , val virtual <identifiersep> file <identifiersep> processor : virtual <identifiersep> file <identifiersep> processor < t > ) { object not <identifiersep> null <identifiersep> take <identifiersep> first : module <identifiersep> info <identifiersep> collector < idea <identifiersep> module <identifiersep> info > ( on <identifiersep> result = { it ? : not <identifiersep> under <identifiersep> content <identifiersep> root <identifiersep> module <identifiersep> info } , <LOG> on <identifiersep> failure = { reason - > not <identifiersep> under <identifiersep> content <identifiersep> root <identifiersep> module <identifiersep> info } , virtual <identifiersep> file <identifiersep> processor = processor @ { project , virtual <identifiersep> file , is <identifiersep> library <identifiersep> source - > collect <identifiersep> infos <identifiersep> by <identifiersep> virtual <identifiersep> file ( project , <ect>
virtual <identifiersep> file , is <identifiersep> library <identifiersep> source , { return @ processor it } ) } ) object to <identifiersep> sequence : module <identifiersep> info <identifiersep> collector < sequence < idea <identifiersep> module <identifiersep> info > > ( on <identifiersep> result = { result - > result ? . let { sequence <identifiersep> of ( it ) } ? : empty <identifiersep> sequence ( ) } , <LOG> on <identifiersep> failure = { reason - > empty <identifiersep> sequence ( ) } , virtual <identifiersep> file <identifiersep> processor = { project , virtual <identifiersep> file , is <identifiersep> library <identifiersep> source - > build <identifiersep> sequence { collect <identifiersep> infos <identifiersep> by <identifiersep> virtual <identifiersep> file ( <ect>
psi <identifiersep> file context <identifiersep> file = context . get <identifiersep> containing <identifiersep> file ( ) ; return context <identifiersep> file instanceof kt <identifiersep> file ? get <identifiersep> platform ( ( kt <identifiersep> file ) context <identifiersep> file ) : jvm <identifiersep> platform . instance ; } virtual <identifiersep> file virtual <identifiersep> file = file . get <identifiersep> original <identifiersep> file ( ) . get <identifiersep> virtual <identifiersep> file ( ) ; if ( virtual <identifiersep> file != null ) { module module <identifiersep> for <identifiersep> file = project <identifiersep> file <identifiersep> index . service . get <identifiersep> instance ( file . get <identifiersep> project ( ) ) . get <identifiersep> module <identifiersep> for <identifiersep> file ( virtual <identifiersep> file ) ; if ( module <identifiersep> for <identifiersep> file != null ) { <LOG> return get <identifiersep> platform ( module <identifiersep> for <identifiersep> file ) ; } } return jvm <identifiersep> platform . instance ; } @ not <identifiersep> null public static target <identifiersep> platform get <identifiersep> platform ( @ not <identifiersep> null module module ) { return project <identifiersep> structure <identifiersep> util . get <identifiersep> cached <identifiersep> platform <identifiersep> for <identifiersep> module ( module ) ; } } <ect>
<comment> <LOG> if ( virtual <identifiersep> file . file <identifiersep> type != file <identifiersep> type ) { } val file = read <identifiersep> file ( virtual <identifiersep> file ) return when ( file ) { null - > { create <identifiersep> incompatible <identifiersep> abi <identifiersep> version <identifiersep> decompiled <identifiersep> text ( expected <identifiersep> binary <identifiersep> version , invalid <identifiersep> binary <identifiersep> version ) } is file <identifiersep> with <identifiersep> metadata . incompatible - > { <ect>
my <identifiersep> fixture . copy <identifiersep> file <identifiersep> to <identifiersep> project ( custom <identifiersep> manifest <identifiersep> path , sdk <identifiersep> constants . fn <identifiersep> android <identifiersep> manifest <identifiersep> xml ) } val source <identifiersep> file = my <identifiersep> fixture . copy <identifiersep> file <identifiersep> to <identifiersep> project ( path , <string_literal> ) my <identifiersep> fixture . configure <identifiersep> from <identifiersep> existing <identifiersep> virtual <identifiersep> file ( source <identifiersep> file ) val intention = class . for <identifiersep> name ( intention <identifiersep> class <identifiersep> name ) . new <identifiersep> instance ( ) as ? intention <identifiersep> action ? : error ( <string_literal> ) if ( ! intention . is <identifiersep> available ( my <identifiersep> fixture . project , my <identifiersep> fixture . editor , my <identifiersep> fixture . file ) ) { if ( not <identifiersep> available ) { <LOG> return } } if ( not <identifiersep> available ) { error ( <string_literal> ) } my <identifiersep> fixture . launch <identifiersep> action ( intention ) if ( check <identifiersep> manifest ) { my <identifiersep> fixture . check <identifiersep> result <identifiersep> by <identifiersep> file ( <string_literal> , <string_literal> , true ) <ect>
visibilities . public - > kt <identifiersep> tokens . public <identifiersep> keyword visibilities . protected - > kt <identifiersep> tokens . protected <identifiersep> keyword visibilities . internal - > kt <identifiersep> tokens . internal <identifiersep> keyword else - > { if ( visibilities . is <identifiersep> private ( normalized ) ) { kt <identifiersep> tokens . private <identifiersep> keyword } <LOG> else { } } } } fun < d : callable <identifiersep> member <identifiersep> descriptor > d . get <identifiersep> directly <identifiersep> overridden <identifiersep> declarations ( ) : collection < d > { val result = linked <identifiersep> hash <identifiersep> set < d > ( ) for ( overridden <identifiersep> descriptor in overridden <identifiersep> descriptors ) { @ suppress ( <string_literal> ) when ( overridden <identifiersep> descriptor . kind ) { <ect>
if ( tail <identifiersep> ok ) { if ( found <identifiersep> element != null ) { val dump = expected <identifiersep> completion <identifiersep> utils . list <identifiersep> to <identifiersep> string ( expected <identifiersep> completion <identifiersep> utils . get <identifiersep> items <identifiersep> information ( array <identifiersep> of ( found <identifiersep> element , lookup <identifiersep> element ) ) ) fail ( <string_literal> ) } found <identifiersep> element = lookup <identifiersep> element } } } } if ( found <identifiersep> element == null ) { <LOG> val dump = expected <identifiersep> completion <identifiersep> utils . list <identifiersep> to <identifiersep> string ( expected <identifiersep> completion <identifiersep> utils . get <identifiersep> items <identifiersep> information ( items . to <identifiersep> typed <identifiersep> array ( ) ) ) } return found <identifiersep> element } protected fun select <identifiersep> item ( item : lookup <identifiersep> element ? , completion <identifiersep> char : char ) { val lookup = ( fixture . lookup as lookup <identifiersep> impl ) if ( lookup . current <identifiersep> item != item ) { <comment> <ect>
val block = in <identifiersep> statement ? . parent as kt <identifiersep> block <identifiersep> expression ? val prev <identifiersep> statement = in <identifiersep> statement ? . siblings ( forward = false , with <identifiersep> itself = false ) ? . first <identifiersep> is <identifiersep> instance <identifiersep> or <identifiersep> null < kt <identifiersep> expression > ( ) val modification <identifiersep> scope = in <identifiersep> statement ? . let { kotlin <identifiersep> code <identifiersep> block <identifiersep> modification <identifiersep> listener . get <identifiersep> inside <identifiersep> code <identifiersep> block <identifiersep> modification <identifiersep> scope ( it ) } val psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after = modification <identifiersep> scope ? . let { collect <identifiersep> psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after ( modification <identifiersep> scope , in <identifiersep> statement ) } val prev <identifiersep> completion <identifiersep> data = prev <identifiersep> completion <identifiersep> data <identifiersep> cache . value . data when { <LOG> prev <identifiersep> completion <identifiersep> data == null - > block != prev <identifiersep> completion <identifiersep> data . block - > log ( <string_literal> ) prev <identifiersep> statement != prev <identifiersep> completion <identifiersep> data . prev <identifiersep> statement - > log ( <string_literal> ) psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > <ect>
val prev <identifiersep> completion <identifiersep> data = prev <identifiersep> completion <identifiersep> data <identifiersep> cache . value . data when { prev <identifiersep> completion <identifiersep> data == null - > log ( <string_literal> ) block != prev <identifiersep> completion <identifiersep> data . block - > log ( <string_literal> ) <LOG> prev <identifiersep> statement != prev <identifiersep> completion <identifiersep> data . prev <identifiersep> statement - > psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > log ( <string_literal> ) prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > log ( <string_literal> ) in <identifiersep> statement . is <identifiersep> too <identifiersep> complex ( ) - > <ect>
block != prev <identifiersep> completion <identifiersep> data . block - > log ( <string_literal> ) prev <identifiersep> statement != prev <identifiersep> completion <identifiersep> data . prev <identifiersep> statement - > log ( <string_literal> ) psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > log ( <string_literal> ) <LOG> prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > in <identifiersep> statement . is <identifiersep> too <identifiersep> complex ( ) - > log ( <string_literal> ) else - > { log ( <string_literal> <string_literal> ) log . debug ( <string_literal> ) <ect>
psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after != prev <identifiersep> completion <identifiersep> data . psi <identifiersep> elements <identifiersep> before <identifiersep> and <identifiersep> after - > log ( <string_literal> ) prev <identifiersep> completion <identifiersep> data . module <identifiersep> descriptor != resolution <identifiersep> facade . module <identifiersep> descriptor - > log ( <string_literal> ) in <identifiersep> statement . is <identifiersep> too <identifiersep> complex ( ) - > log ( <string_literal> ) <LOG> else - > { log . debug ( <string_literal> ) <comment> <ect>
var filter : ( declaration <identifiersep> descriptor ) - > boolean = { true } if ( descriptor <identifiersep> name . starts <identifiersep> with ( <string_literal> ) ) { filter = { it is class <identifiersep> descriptor } descriptor <identifiersep> name = descriptor <identifiersep> name . substring ( <string_literal> . length ) . trim ( ) } val descriptors = file . resolve <identifiersep> import <identifiersep> reference ( fq <identifiersep> name ( descriptor <identifiersep> name ) ) . filter ( filter ) when { <LOG> descriptors . is <identifiersep> empty ( ) - > descriptors . size > 1 - > error ( <string_literal> + descriptors . map { descriptor <identifiersep> renderer . fq <identifiersep> names <identifiersep> in <identifiersep> types . render ( it ) } . join <identifiersep> to <identifiersep> string ( <string_literal> ) ) else - > { val success = import <identifiersep> insert <identifiersep> helper . get <identifiersep> instance ( project ) . import <identifiersep> descriptor ( file , descriptors . single ( ) ) != import <identifiersep> descriptor <identifiersep> result . fail if ( ! success ) { <ect>
val include <identifiersep> non <identifiersep> project <identifiersep> symbols = non <identifiersep> project <identifiersep> symbols || in <identifiersep> text <identifiersep> directives <identifiersep> utils . is <identifiersep> directive <identifiersep> defined ( document <identifiersep> text , <string_literal> ) val search <identifiersep> text = search <identifiersep> text <identifiersep> list . first ( ) val found <identifiersep> symbols = model . get <identifiersep> names ( include <identifiersep> non <identifiersep> project <identifiersep> symbols ) . filter { it ? . starts <identifiersep> with ( search <identifiersep> text ) ? : false } . flat <identifiersep> map { model . get <identifiersep> elements <identifiersep> by <identifiersep> name ( it , include <identifiersep> non <identifiersep> project <identifiersep> symbols , it + <string_literal> ) . to <identifiersep> list ( ) } val inexact <identifiersep> matching = in <identifiersep> text <identifiersep> directives <identifiersep> utils . is <identifiersep> directive <identifiersep> defined ( document <identifiersep> text , <string_literal> ) val rendered <identifiersep> symbols = found <identifiersep> symbols . map { ( it as psi <identifiersep> element ) . render <identifiersep> as <identifiersep> goto <identifiersep> implementation ( ) } <LOG> if ( check <identifiersep> navigation && ( expected <identifiersep> references . size != 1 || inexact <identifiersep> matching ) ) { } if ( inexact <identifiersep> matching ) { useful <identifiersep> test <identifiersep> case . assert <identifiersep> contains <identifiersep> elements ( rendered <identifiersep> symbols , expected <identifiersep> references ) } else { useful <identifiersep> test <identifiersep> case . assert <identifiersep> ordered <identifiersep> equals ( rendered <identifiersep> symbols . sorted ( ) , expected <identifiersep> references ) } if ( ! check <identifiersep> navigation ) return <ect>
if ( ! file ! ! . is <identifiersep> directory ) { val psi <identifiersep> file = psi <identifiersep> manager . find <identifiersep> file ( file ) if ( psi <identifiersep> file is kt <identifiersep> file ) { has <identifiersep> at <identifiersep> least <identifiersep> one <identifiersep> file = true val binding <identifiersep> context = psi <identifiersep> file . analyze <identifiersep> with <identifiersep> content ( ) val errors = binding <identifiersep> context . diagnostics . all ( ) . filter { it . severity == severity . error } <LOG> if ( errors . is <identifiersep> not <identifiersep> empty ( ) ) { analyzer <identifiersep> with <identifiersep> compiler <identifiersep> report . report <identifiersep> diagnostics ( binding <identifiersep> context . diagnostics , printing <identifiersep> message <identifiersep> collector ( system . err , message <identifiersep> renderer . plain <identifiersep> full <identifiersep> paths , false ) ) total <identifiersep> errors += errors . size } } } true <ect>
no <identifiersep> consistency } class tracker ( private val fq <identifiersep> name : string ) : stub <identifiersep> computation <identifiersep> tracker { private var level = none set ( new <identifiersep> level ) { if ( new <identifiersep> level . ordinal < = field . ordinal ) { error ( <string_literal> ) } <LOG> if ( new <identifiersep> level . ordinal > allowed <identifiersep> level . ordinal ) { } field = new <identifiersep> level } private var allowed <identifiersep> level = none enum class level { none , light , <ect>
@ suppress <identifiersep> warnings ( <string_literal> ) @ override protected void set <identifiersep> up ( ) throws exception { if ( local <identifiersep> cache <identifiersep> reuse ) { boolean local <identifiersep> cache <identifiersep> rebuild = false ; if ( local <identifiersep> cache <identifiersep> dir . exists ( ) ) { <LOG> if ( is <identifiersep> local <identifiersep> cache <identifiersep> outdated ( ) ) { delete <identifiersep> local <identifiersep> cache <identifiersep> directory ( true ) ; local <identifiersep> cache <identifiersep> rebuild = true ; } } else { local <identifiersep> cache <identifiersep> rebuild = true ; } override <identifiersep> temp <identifiersep> output <identifiersep> directory ( ) ; <ect>
@ override public void init <identifiersep> component ( ) { register <identifiersep> path <identifiersep> variable ( ) ; try { <comment> <LOG> catch ( throwable throwable ) { update <identifiersep> checker . get <identifiersep> disabled <identifiersep> to <identifiersep> update <identifiersep> plugins ( ) . add ( <string_literal> ) ; } editor <identifiersep> factory . get <identifiersep> instance ( ) . get <identifiersep> event <identifiersep> multicaster ( ) . add <identifiersep> document <identifiersep> listener ( new document <identifiersep> adapter ( ) { @ override public void document <identifiersep> changed ( document <identifiersep> event e ) { virtual <identifiersep> file virtual <identifiersep> file = file <identifiersep> document <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> file ( e . get <identifiersep> document ( ) ) ; <ect>
run <identifiersep> silent <identifiersep> refactoring ( adjusted <identifiersep> descriptor ) } else { run <identifiersep> interactive <identifiersep> refactoring ( adjusted <identifiersep> descriptor ) } } fun adjust <identifiersep> descriptor ( descriptors <identifiersep> for <identifiersep> signature <identifiersep> change : collection < callable <identifiersep> descriptor > ) : kotlin <identifiersep> method <identifiersep> descriptor ? { val base <identifiersep> descriptor = prefer <identifiersep> contained <identifiersep> in <identifiersep> class ( descriptors <identifiersep> for <identifiersep> signature <identifiersep> change ) val function <identifiersep> declaration = descriptor <identifiersep> to <identifiersep> source <identifiersep> utils <identifiersep> ide . get <identifiersep> any <identifiersep> declaration ( project , base <identifiersep> descriptor ) <LOG> if ( function <identifiersep> declaration == null ) { return null } if ( ! check <identifiersep> modifiable ( function <identifiersep> declaration ) ) { return null } val original <identifiersep> descriptor = kotlin <identifiersep> change <identifiersep> signature <identifiersep> data ( base <identifiersep> descriptor , function <identifiersep> declaration , descriptors <identifiersep> for <identifiersep> signature <identifiersep> change ) return configuration . configure ( original <identifiersep> descriptor ) <ect>
return button <identifiersep> pressed ( code , dialog <identifiersep> buttons , messages . no <identifiersep> button ) } fun build <identifiersep> dialog <identifiersep> options ( is <identifiersep> single <identifiersep> function <identifiersep> selected : boolean ) : list < string > { return if ( is <identifiersep> single <identifiersep> function <identifiersep> selected ) { array <identifiersep> list <identifiersep> of ( messages . yes <identifiersep> button , messages . no <identifiersep> button , messages . cancel <identifiersep> button ) } else { array <identifiersep> list <identifiersep> of ( messages . ok <identifiersep> button , messages . cancel <identifiersep> button ) } } <LOG> if ( kind == synthesized ) { return false } val closest <identifiersep> modifiable <identifiersep> descriptors = get <identifiersep> closest <identifiersep> modifiable <identifiersep> descriptors ( ) if ( force <identifiersep> perform <identifiersep> for <identifiersep> selected <identifiersep> function <identifiersep> only ( ) ) { perform <identifiersep> refactoring ( closest <identifiersep> modifiable <identifiersep> descriptors ) return true <ect>
if ( application <identifiersep> manager . get <identifiersep> application ( ) . is <identifiersep> unit <identifiersep> test <identifiersep> mode || application <identifiersep> manager . get <identifiersep> application ( ) . is <identifiersep> headless <identifiersep> environment ) return if ( ! update <identifiersep> settings . get <identifiersep> instance ( ) . is <identifiersep> check <identifiersep> needed ) return val last <identifiersep> update <identifiersep> time = java . lang . long . parse <identifiersep> long ( properties <identifiersep> component . get <identifiersep> value ( property <identifiersep> name , <string_literal> ) ) if ( last <identifiersep> update <identifiersep> time == 0l || system . current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> update <identifiersep> time > cached <identifiersep> request <identifiersep> delay ) { queue <identifiersep> update <identifiersep> check { update <identifiersep> status - > when ( update <identifiersep> status ) { <LOG> is plugin <identifiersep> update <identifiersep> status . update - > notify <identifiersep> plugin <identifiersep> update <identifiersep> available ( update <identifiersep> status ) } true } } } private fun queue <identifiersep> update <identifiersep> check ( callback : ( plugin <identifiersep> update <identifiersep> status ) - > boolean ) { application <identifiersep> manager . get <identifiersep> application ( ) . assert <identifiersep> is <identifiersep> dispatch <identifiersep> thread ( ) if ( ! check <identifiersep> queued ) { check <identifiersep> queued = true <ect>
val diagnostic <identifiersep> with <identifiersep> parameters = errors . constant <identifiersep> expected <identifiersep> type <identifiersep> mismatch . cast ( diagnostic ) expected <identifiersep> type = diagnostic <identifiersep> with <identifiersep> parameters . b expression <identifiersep> type = context . get <identifiersep> type ( diagnostic <identifiersep> element ) if ( expression <identifiersep> type == null ) { log . error ( <string_literal> + diagnostic <identifiersep> element . text ) return empty <identifiersep> list ( ) } } <LOG> else - > { return empty <identifiersep> list ( ) } } if ( expression <identifiersep> type . is <identifiersep> primitive <identifiersep> number <identifiersep> type ( ) && expected <identifiersep> type . is <identifiersep> primitive <identifiersep> number <identifiersep> type ( ) ) { var wrong <identifiersep> primitive <identifiersep> literal <identifiersep> fix : wrong <identifiersep> primitive <identifiersep> literal <identifiersep> fix ? = null if ( diagnostic <identifiersep> element is kt <identifiersep> constant <identifiersep> expression && ! kotlin <identifiersep> built <identifiersep> ins . is <identifiersep> char ( expected <identifiersep> type ) ) { wrong <identifiersep> primitive <identifiersep> literal <identifiersep> fix = wrong <identifiersep> primitive <identifiersep> literal <identifiersep> fix ( diagnostic <identifiersep> element , expected <identifiersep> type ) <ect>
import java . util . array <identifiersep> list abstract class item ( val room : < warning > object < / warning > ) { abstract val name : string } val items : array <identifiersep> list < item > = array <identifiersep> list < item > ( ) fun test ( room : < warning > object < / warning > ) { for ( item : item in items ) { <LOG> if ( item . room == = room ) { } } } <ect>
val rnd = random ( ) ; val prompt = string <identifiersep> builder ( ) for ( i in 0 . . <number_literal> ) { val n = rnd . next <identifiersep> int ( <number_literal> ) + 1 numbers . add ( n ) if ( i > 0 ) prompt . append ( <string_literal> ) ; <LOG> prompt . append ( n ) } system . out . println ( <string_literal> ) val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) <ect>
system . out . println ( <string_literal> + prompt ) system . out . println ( <string_literal> ) val reader = buffered <identifiersep> reader ( input <identifiersep> stream <identifiersep> reader ( system . `in` ) ) val expr = string <identifiersep> builder ( reader . read <identifiersep> line ( ) ! ! ) try { val result = evaluate ( expr , numbers ) <LOG> if ( result != <number_literal> ) else system . out . println ( <string_literal> ) ; } catch ( e : throwable ) { system . out . println ( e . message ) } } <ect>
import kotlin . script . experimental . dependencies . * import kotlin . script . templates . script <identifiersep> template <identifiersep> definition class test <identifiersep> dependencies <identifiersep> resolver : dependencies <identifiersep> resolver { override fun resolve ( script <identifiersep> contents : script <identifiersep> contents , environment : environment <LOG> ) : dependencies <identifiersep> resolver . resolve <identifiersep> result { } } @ script <identifiersep> template <identifiersep> definition ( test <identifiersep> dependencies <identifiersep> resolver : : class , script <identifiersep> file <identifiersep> pattern = <string_literal> ) <ect>
fun foo ( x : any ? ) { if ( x == null ) { <LOG> val error = f ( ) } < caret > x . hash <identifiersep> code ( ) } fun f ( ) : ( string ) - > unit = { } <ect>
package hello <identifiersep> world ; <comment> <LOG> public static void main ( string [ ] args ) { } } <ect>
package target import source . klogging class foo { companion object : klogging ( ) fun baz ( ) { <LOG> logger . debug { <string_literal> } } <ect>
package target import source . klogging class foo { companion object : klogging ( ) fun baz ( ) { <LOG> logger . debug { <string_literal> } } <ect>
package target import source . i <identifiersep> logging import source . klogging class foo { companion object : i <identifiersep> logging by klogging ( ) fun baz ( ) { <LOG> logger . debug { <string_literal> } } <ect>
package test ; class b { <LOG> void bar ( ) { } <ect>
when { it . return <identifiersep> type . is <identifiersep> subtype <identifiersep> of ( type <identifiersep> member <identifiersep> template ) - > yield ( it . call ( this ) as member <identifiersep> template ) it . return <identifiersep> type . is <identifiersep> subtype <identifiersep> of ( type <identifiersep> iterable <identifiersep> of <identifiersep> member <identifiersep> templates ) - > @ suppress ( <string_literal> ) yield <identifiersep> all ( it . call ( this ) as iterable < member <identifiersep> template > ) <LOG> else - > } } } } . run { if ( default <identifiersep> actions . is <identifiersep> empty ( ) ) this else on <identifiersep> each { t - > default <identifiersep> actions . for <identifiersep> each ( t : : builder ) } } private val default <identifiersep> actions = mutable <identifiersep> list <identifiersep> of < member <identifiersep> build <identifiersep> action > ( ) fun default <identifiersep> builder ( builder <identifiersep> action : member <identifiersep> build <identifiersep> action ) { default <identifiersep> actions += builder <identifiersep> action <ect>
public class use <identifiersep> kotlin <identifiersep> const <identifiersep> in <identifiersep> switch { public static void main ( int i ) { switch ( i ) { <LOG> case a . use <identifiersep> kotlin <identifiersep> const <identifiersep> in <identifiersep> switch <identifiersep> kt . i : break ; default : system . out . println ( <string_literal> ) ; break ; } } } <ect>
package client ; import server . o ; class client { <LOG> void foo <identifiersep> bar ( ) { } <ect>
class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + a . get <identifiersep> foo ( ) ) ; b b = new b ( ) ; <LOG> b . set <identifiersep> foo ( <string_literal> ) ; } <ect>
class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + a . get <identifiersep> foo ( ) ) ; b b = new b ( ) ; <LOG> b . set <identifiersep> foo ( <string_literal> ) ; } <ect>
class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + a . get <identifiersep> foo ( ) ) ; b b = new b ( ) ; <LOG> b . set <identifiersep> foo ( <string_literal> ) ; } <ect>
class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + a . get <identifiersep> foo ( ) ) ; b b = new b ( ) ; <LOG> b . set <identifiersep> foo ( <string_literal> ) ; } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a . companion . set <identifiersep> foo ( <string_literal> ) ; a . foo = <string_literal> ; <LOG> system . out . println ( <string_literal> + a . companion . get <identifiersep> foo ( ) ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; system . out . println ( a . get <identifiersep> a ( ) + <string_literal> + a . get <identifiersep> b ( ) ) ; a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { <LOG> x . foo ( <string_literal> ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; system . out . println ( a . get <identifiersep> a ( ) + <string_literal> + a . get <identifiersep> b ( ) ) ; a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { <LOG> x . foo ( <string_literal> ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; system . out . println ( a . get <identifiersep> a ( ) + <string_literal> + a . get <identifiersep> b ( ) ) ; a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { <LOG> x . foo ( <string_literal> ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
class usages { void foo ( a a ) { a . foo ( <string_literal> ) ; system . out . println ( a . get <identifiersep> a ( ) + <string_literal> + a . get <identifiersep> b ( ) ) ; a . set <identifiersep> b ( <number_literal> ) ; } void foo ( x x ) { <LOG> x . foo ( <string_literal> ) ; x . set <identifiersep> b ( <number_literal> ) ; } <ect>
fun test <identifiersep> throw ( ) { if ( sdk <identifiersep> int < <number_literal> ) { throw illegal <identifiersep> state <identifiersep> exception ( ) } <comment> <LOG> if ( sdk <identifiersep> int < <number_literal> ) { } <comment> <ect>
fun is <identifiersep> plugin <identifiersep> execution <identifiersep> missing ( plugin : maven <identifiersep> plugin ? , excluded <identifiersep> execution <identifiersep> id : string , goal : string ) = plugin == null || plugin . executions . none { it . execution <identifiersep> id != excluded <identifiersep> execution <identifiersep> id && goal in it . goals } fun add <identifiersep> javac <identifiersep> executions ( module : module , kotlin <identifiersep> plugin : maven <identifiersep> dom <identifiersep> plugin ) { val javac <identifiersep> plugin = ensure <identifiersep> plugin <identifiersep> after ( add <identifiersep> plugin ( maven <identifiersep> id ( <string_literal> , <string_literal> , null ) ) , kotlin <identifiersep> plugin ) val project : maven <identifiersep> project = maven <identifiersep> projects <identifiersep> manager . get <identifiersep> instance ( module . project ) . find <identifiersep> project ( module ) ? : run { <LOG> if ( application <identifiersep> manager . get <identifiersep> application ( ) . is <identifiersep> unit <identifiersep> test <identifiersep> mode ) { return } error ( <string_literal> ) } val plugin = project . find <identifiersep> plugin ( <string_literal> , <string_literal> ) if ( is <identifiersep> execution <identifiersep> enabled ( plugin , <string_literal> ) ) { add <identifiersep> execution ( javac <identifiersep> plugin , <string_literal> , <string_literal> , empty <identifiersep> list ( ) ) <ect>
maven <identifiersep> indices <identifiersep> manager . get <identifiersep> instance ( ) . clear ( ) ; } finally { super . tear <identifiersep> down ( ) ; file <identifiersep> util . delete ( my <identifiersep> dir ) ; <comment> <LOG> if ( my <identifiersep> dir . exists ( ) ) { <comment> <ect>
} . execute ( ) . throw <identifiersep> exception ( ) ; } private static string create <identifiersep> settings <identifiersep> xml <identifiersep> content ( string content ) { if ( ! mirror <identifiersep> discoverable ) { system . err . println ( <string_literal> + maven <identifiersep> mirror <identifiersep> url + <string_literal> ) ; return <string_literal> + content + <LOG> <string_literal> ; } return <string_literal> + content + <string_literal> + <string_literal> + <string_literal> + <ect>
<number_literal> - > int <identifiersep> range ( numbers [ 0 ] , numbers [ 1 ] ) else - > error ( <string_literal> ) } } val sorted <identifiersep> fix <identifiersep> ranges = ranges <identifiersep> to <identifiersep> fix <identifiersep> files . values . sorted <identifiersep> by { it . start } sorted <identifiersep> fix <identifiersep> ranges . for <identifiersep> each <identifiersep> indexed { i , range - > if ( i > 0 ) { val previous = sorted <identifiersep> fix <identifiersep> ranges [ i - 1 ] <LOG> if ( previous . end <identifiersep> inclusive + 1 != range . start ) { } } } val number <identifiersep> of <identifiersep> fix <identifiersep> data <identifiersep> files = sorted <identifiersep> fix <identifiersep> ranges . last <identifiersep> or <identifiersep> null ( ) ? . end <identifiersep> inclusive ? : 0 if ( number <identifiersep> of <identifiersep> fix <identifiersep> data <identifiersep> files > suggested <identifiersep> fixes . size ) { fail ( <string_literal> ) } if ( number <identifiersep> of <identifiersep> fix <identifiersep> data <identifiersep> files < suggested <identifiersep> fixes . size ) { fail ( <string_literal> ) <ect>
. callback ( new external <identifiersep> project <identifiersep> refresh <identifiersep> callback ( ) { @ override public void on <identifiersep> success ( @ nullable data <identifiersep> node < project <identifiersep> data > external <identifiersep> project ) { if ( external <identifiersep> project == null ) { system . err . println ( <string_literal> ) ; return ; } <LOG> service <identifiersep> manager . get <identifiersep> service ( project <identifiersep> data <identifiersep> manager . class ) . import <identifiersep> data ( external <identifiersep> project , my <identifiersep> project , true ) ; } @ override public void on <identifiersep> failure ( @ not <identifiersep> null string error <identifiersep> message , @ nullable string error <identifiersep> details ) { error . set ( couple . of ( error <identifiersep> message , error <identifiersep> details ) ) ; } } ) . force <identifiersep> when <identifiersep> uptodate ( ) <ect>
val cls = library <identifiersep> impl : : class . java <comment> <LOG> return } } } catch ( e : exception ) { log . info ( <string_literal> , e ) } } companion object { val log = logger . get <identifiersep> instance ( kotlin <identifiersep> gradle <identifiersep> library <identifiersep> data <identifiersep> service : : class . java ) val non <identifiersep> jvm <identifiersep> suffixes = list <identifiersep> of ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) <ect>
public static void write <identifiersep> file <identifiersep> if <identifiersep> content <identifiersep> changed ( file file , string new <identifiersep> text ) throws io <identifiersep> exception { write <identifiersep> file <identifiersep> if <identifiersep> content <identifiersep> changed ( file , new <identifiersep> text , true ) ; } @ suppress <identifiersep> warnings ( <string_literal> ) public static void write <identifiersep> file <identifiersep> if <identifiersep> content <identifiersep> changed ( file file , string new <identifiersep> text , boolean log <identifiersep> not <identifiersep> changed ) throws io <identifiersep> exception { file parent <identifiersep> file = file . get <identifiersep> parent <identifiersep> file ( ) ; if ( ! parent <identifiersep> file . exists ( ) ) { <LOG> if ( parent <identifiersep> file . mkdirs ( ) ) { } else { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + parent <identifiersep> file ) ; } } if ( check <identifiersep> file <identifiersep> ignoring <identifiersep> line <identifiersep> separators ( file , new <identifiersep> text ) ) { if ( log <identifiersep> not <identifiersep> changed ) { system . out . println ( <string_literal> + file . get <identifiersep> absolute <identifiersep> path ( ) ) ; <ect>
if ( check <identifiersep> file <identifiersep> ignoring <identifiersep> line <identifiersep> separators ( file , new <identifiersep> text ) ) { if ( log <identifiersep> not <identifiersep> changed ) { system . out . println ( <string_literal> + file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } return ; } boolean use <identifiersep> temp <identifiersep> file = ! system <identifiersep> info . is <identifiersep> windows ; file temp <identifiersep> file = use <identifiersep> temp <identifiersep> file ? new file ( kotlin <identifiersep> test <identifiersep> utils . tmp <identifiersep> dir ( file . get <identifiersep> name ( ) ) , file . get <identifiersep> name ( ) + <string_literal> ) : file ; <LOG> files <identifiersep> kt . write <identifiersep> text ( temp <identifiersep> file , new <identifiersep> text , charsets . utf <identifiersep> <number_literal> ) ; if ( use <identifiersep> temp <identifiersep> file ) { files . move ( temp <identifiersep> file . to <identifiersep> path ( ) , file . to <identifiersep> path ( ) , replace <identifiersep> existing ) ; system . out . println ( <string_literal> + temp <identifiersep> file + <string_literal> + file ) ; } system . out . println ( ) ; } private static boolean check <identifiersep> file <identifiersep> ignoring <identifiersep> line <identifiersep> separators ( file file , string content ) { <ect>
val package <identifiersep> name : string = find <identifiersep> first ( pattern . compile ( <string_literal> ) ) val class <identifiersep> name : string = find <identifiersep> first ( pattern . compile ( <string_literal> ) ) val debug <identifiersep> class <identifiersep> name : string = <string_literal> private fun find <identifiersep> first ( pattern : pattern ) : string { for ( line in file ( file ) . read <identifiersep> lines ( ) ) { val m = pattern . matcher ( line ) <LOG> if ( m . find ( ) ) return m . group ( 1 ) } } } val proto <identifiersep> paths : list < proto <identifiersep> path > = list <identifiersep> of ( proto <identifiersep> path ( <string_literal> ) , proto <identifiersep> path ( <string_literal> ) , proto <identifiersep> path ( <string_literal> ) , proto <identifiersep> path ( <string_literal> ) , <ect>
boolean found <identifiersep> open <identifiersep> jdk <identifiersep> license = false ; while ( true ) { string line = reader . read <identifiersep> line ( ) ; if ( line == null ) break ; if ( line . contains ( <string_literal> ) ) { found <identifiersep> open <identifiersep> jdk <identifiersep> license = true ; } } <LOG> if ( ! found <identifiersep> open <identifiersep> jdk <identifiersep> license ) { system . exit ( 1 ) ; } } } generate <identifiersep> filtered <identifiersep> jar ( openjdk7path , <string_literal> , new file ( <string_literal> ) , <ect>
class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; system . out . println ( <string_literal> ) ; } } @ override protected void rebuild <identifiersep> all <identifiersep> modules ( ) { system . out . println ( <string_literal> ) ; <LOG> super . rebuild <identifiersep> all <identifiersep> modules ( ) ; } @ not <identifiersep> null @ override protected build <identifiersep> result build <identifiersep> all <identifiersep> modules ( ) { system . out . println ( <string_literal> ) ; build <identifiersep> result result = super . build <identifiersep> all <identifiersep> modules ( ) ; <ect>
super . rebuild <identifiersep> all <identifiersep> modules ( ) ; system . out . println ( <string_literal> ) ; } @ not <identifiersep> null @ override protected build <identifiersep> result build <identifiersep> all <identifiersep> modules ( ) { system . out . println ( <string_literal> ) ; <LOG> build <identifiersep> result result = super . build <identifiersep> all <identifiersep> modules ( ) ; return result ; } private void init <identifiersep> project ( ) { add <identifiersep> jdk ( jdk <identifiersep> name ) ; load <identifiersep> project ( work <identifiersep> dir . get <identifiersep> absolute <identifiersep> path ( ) ) ; add <identifiersep> kotlin <identifiersep> stdlib <identifiersep> dependency ( ) ; <ect>
source <identifiersep> files : collection < file > , source <identifiersep> roots : collection < file > , libraries : list < string > , friend <identifiersep> modules : list < string > , output <identifiersep> file : file ) { <LOG> log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( common <identifiersep> arguments ) ) val arguments = merge <identifiersep> beans ( common <identifiersep> arguments , xml <identifiersep> serializer <identifiersep> util . create <identifiersep> copy ( k2js <identifiersep> arguments ) ) log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( arguments ) ) setup <identifiersep> k2js <identifiersep> arguments ( output <identifiersep> file , source <identifiersep> files , libraries , friend <identifiersep> modules , arguments ) if ( arguments . source <identifiersep> map ) { arguments . source <identifiersep> map <identifiersep> base <identifiersep> dirs = source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( file . path <identifiersep> separator ) { it . path } <ect>
log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( common <identifiersep> arguments ) ) log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( k2js <identifiersep> arguments ) ) val arguments = merge <identifiersep> beans ( common <identifiersep> arguments , xml <identifiersep> serializer <identifiersep> util . create <identifiersep> copy ( k2js <identifiersep> arguments ) ) log . debug ( <string_literal> + argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( arguments ) ) setup <identifiersep> k2js <identifiersep> arguments ( output <identifiersep> file , source <identifiersep> files , libraries , friend <identifiersep> modules , arguments ) if ( arguments . source <identifiersep> map ) { <LOG> arguments . source <identifiersep> map <identifiersep> base <identifiersep> dirs = source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( file . path <identifiersep> separator ) { it . path } } with <identifiersep> compiler <identifiersep> settings ( compiler <identifiersep> settings ) { run <identifiersep> compiler ( k2js <identifiersep> compiler , arguments , environment ) } } override fun compile <identifiersep> with <identifiersep> daemon <identifiersep> or <identifiersep> fallback ( compiler <identifiersep> class <identifiersep> name : string , compiler <identifiersep> args : common <identifiersep> compiler <identifiersep> arguments , <ect>
environment : jps <identifiersep> compiler <identifiersep> environment ) : exit <identifiersep> code ? { val target <identifiersep> platform = when ( compiler <identifiersep> class <identifiersep> name ) { k2jvm <identifiersep> compiler - > compile <identifiersep> service . target <identifiersep> platform . jvm k2js <identifiersep> compiler - > compile <identifiersep> service . target <identifiersep> platform . js k2metadata <identifiersep> compiler - > compile <identifiersep> service . target <identifiersep> platform . metadata <LOG> else - > throw illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) } val connection = get <identifiersep> daemon <identifiersep> connection ( environment ) if ( connection == null ) { log . info ( <string_literal> ) return null } val ( daemon , session <identifiersep> id ) = connection <ect>
report <identifiersep> severity . debug . code } private fun fallback <identifiersep> compile <identifiersep> strategy ( compiler <identifiersep> args : common <identifiersep> compiler <identifiersep> arguments , compiler <identifiersep> class <identifiersep> name : string , environment : jps <identifiersep> compiler <identifiersep> environment ) : exit <identifiersep> code { <LOG> if ( <string_literal> == system . get <identifiersep> property ( <string_literal> ) && <string_literal> == system . get <identifiersep> property ( fail <identifiersep> on <identifiersep> fallback <identifiersep> property ) ) { } <comment> <ect>
fun mark <identifiersep> in <identifiersep> chunk <identifiersep> or <identifiersep> dependents ( files : iterable < file > , exclude <identifiersep> files : set < file > ) { mark <identifiersep> files <identifiersep> impl ( files ) { it ! in exclude <identifiersep> files && it . exists ( ) && module <identifiersep> based <identifiersep> filter . accept ( it ) } } private inline fun mark <identifiersep> files <identifiersep> impl ( files : iterable < file > , should <identifiersep> mark : ( file ) - > boolean ) { val files <identifiersep> to <identifiersep> mark = files . filter <identifiersep> to ( hash <identifiersep> set ( ) , should <identifiersep> mark ) if ( files <identifiersep> to <identifiersep> mark . is <identifiersep> empty ( ) ) return for ( file <identifiersep> to <identifiersep> mark in files <identifiersep> to <identifiersep> mark ) { <LOG> fs <identifiersep> operations . mark <identifiersep> dirty ( compile <identifiersep> context , compilation <identifiersep> round . next , file <identifiersep> to <identifiersep> mark ) } build <identifiersep> logger ? . marked <identifiersep> as <identifiersep> dirty ( files <identifiersep> to <identifiersep> mark ) has <identifiersep> marked <identifiersep> dirty = true } <comment> <ect>
|| class <identifiersep> name == <string_literal> || class <identifiersep> name == <string_literal> } } private val statistics <identifiersep> logger = teamcity <identifiersep> statistics <identifiersep> logger ( ) override fun get <identifiersep> presentable <identifiersep> name ( ) = kotlin <identifiersep> builder <identifiersep> name override fun get <identifiersep> compilable <identifiersep> file <identifiersep> extensions ( ) = array <identifiersep> list <identifiersep> of ( <string_literal> ) override fun build <identifiersep> started ( context : compile <identifiersep> context ) { <LOG> log . debug ( <string_literal> ) log . info ( <string_literal> ) val history <identifiersep> label = context . get <identifiersep> builder <identifiersep> parameter ( <string_literal> ) if ( history <identifiersep> label != null ) { log . info ( <string_literal> ) } } override fun build <identifiersep> finished ( context : compile <identifiersep> context ? ) { <ect>
override fun get <identifiersep> compilable <identifiersep> file <identifiersep> extensions ( ) = array <identifiersep> list <identifiersep> of ( <string_literal> ) override fun build <identifiersep> started ( context : compile <identifiersep> context ) { log . debug ( <string_literal> ) log . info ( <string_literal> ) log . info ( <string_literal> ) val history <identifiersep> label = context . get <identifiersep> builder <identifiersep> parameter ( <string_literal> ) <LOG> if ( history <identifiersep> label != null ) { } } override fun build <identifiersep> finished ( context : compile <identifiersep> context ? ) { statistics <identifiersep> logger . report <identifiersep> total ( ) } override fun chunk <identifiersep> build <identifiersep> started ( context : compile <identifiersep> context , chunk : module <identifiersep> chunk ) { super . chunk <identifiersep> build <identifiersep> started ( context , chunk ) if ( chunk . is <identifiersep> dummy ( context ) ) return <ect>
current <identifiersep> api <identifiersep> version != last <identifiersep> build <identifiersep> api <identifiersep> version - > { <string_literal> } last <identifiersep> build <identifiersep> lang <identifiersep> version != language <identifiersep> version . kotlin <identifiersep> 1 <identifiersep> 0 && last <identifiersep> build <identifiersep> meta <identifiersep> info . is <identifiersep> eap && ! current <identifiersep> build <identifiersep> meta <identifiersep> info . is <identifiersep> eap - > { <comment> <LOG> if ( reason <identifiersep> to <identifiersep> rebuild != null ) { actions . add ( cache <identifiersep> version . action . rebuild <identifiersep> all <identifiersep> kotlin ) } } } return actions } override fun chunk <identifiersep> build <identifiersep> finished ( context : compile <identifiersep> context , chunk : module <identifiersep> chunk ) { super . chunk <identifiersep> build <identifiersep> finished ( context , chunk ) if ( chunk . is <identifiersep> dummy ( context ) ) return <ect>
) : module <identifiersep> level <identifiersep> builder . exit <identifiersep> code { if ( chunk . is <identifiersep> dummy ( context ) ) return nothing <identifiersep> done val message <identifiersep> collector = message <identifiersep> collector <identifiersep> adapter ( context ) val fs <identifiersep> operations = fs <identifiersep> operations <identifiersep> helper ( context , chunk , log ) try { val proposed <identifiersep> exit <identifiersep> code = do <identifiersep> build ( chunk , context , dirty <identifiersep> files <identifiersep> holder , message <identifiersep> collector , output <identifiersep> consumer , fs <identifiersep> operations ) <LOG> val actual <identifiersep> exit <identifiersep> code = if ( proposed <identifiersep> exit <identifiersep> code == ok && fs <identifiersep> operations . has <identifiersep> marked <identifiersep> dirty ) additional <identifiersep> pass <identifiersep> required else proposed <identifiersep> exit <identifiersep> code context . testing <identifiersep> context ? . build <identifiersep> logger ? . build <identifiersep> finished ( actual <identifiersep> exit <identifiersep> code ) return actual <identifiersep> exit <identifiersep> code } catch ( e : stop <identifiersep> build <identifiersep> exception ) { log . info ( <string_literal> + e ) throw e <ect>
log . debug ( <string_literal> + actual <identifiersep> exit <identifiersep> code ) context . testing <identifiersep> context ? . build <identifiersep> logger ? . build <identifiersep> finished ( actual <identifiersep> exit <identifiersep> code ) return actual <identifiersep> exit <identifiersep> code } catch ( e : stop <identifiersep> build <identifiersep> exception ) { log . info ( <string_literal> + e ) throw e } <LOG> catch ( e : throwable ) { message <identifiersep> collector <identifiersep> util . report <identifiersep> exception ( message <identifiersep> collector , e ) return abort } } private fun do <identifiersep> build ( chunk : module <identifiersep> chunk , context : compile <identifiersep> context , <ect>
val output <identifiersep> item <identifiersep> collector = do <identifiersep> compile <identifiersep> module <identifiersep> chunk ( all <identifiersep> compiled <identifiersep> files , chunk , common <identifiersep> arguments , context , dirty <identifiersep> files <identifiersep> holder , environment , files <identifiersep> to <identifiersep> compile , incremental <identifiersep> caches , project ) statistics <identifiersep> logger . register <identifiersep> statistic ( chunk , system . nano <identifiersep> time ( ) - start ) if ( output <identifiersep> item <identifiersep> collector == null ) { return nothing <identifiersep> done } val compilation <identifiersep> errors = utils . errors <identifiersep> detected <identifiersep> key [ context , false ] <LOG> if ( compilation <identifiersep> errors ) { return abort } else { log . info ( <string_literal> ) } val generated <identifiersep> files = get <identifiersep> generated <identifiersep> files ( chunk , environment . output <identifiersep> items <identifiersep> collector ) register <identifiersep> output <identifiersep> items ( output <identifiersep> consumer , generated <identifiersep> files ) <ect>
context . testing <identifiersep> context ? . build <identifiersep> logger ? . actions <identifiersep> on <identifiersep> cache <identifiersep> version <identifiersep> changed ( sorted <identifiersep> actions ) for ( status in sorted <identifiersep> actions ) { when ( status ) { cache <identifiersep> version . action . rebuild <identifiersep> all <identifiersep> kotlin - > { mark <identifiersep> all <identifiersep> kotlin <identifiersep> for <identifiersep> rebuild ( context , fs <identifiersep> operations , <string_literal> ) return } <LOG> cache <identifiersep> version . action . rebuild <identifiersep> chunk - > { val rebuild <identifiersep> after <identifiersep> cache <identifiersep> version <identifiersep> changed = rebuild <identifiersep> after <identifiersep> cache <identifiersep> version <identifiersep> change <identifiersep> marker ( data <identifiersep> manager ) for ( target in targets ) { data <identifiersep> manager . get <identifiersep> kotlin <identifiersep> cache ( target ) . clean ( ) has <identifiersep> kotlin . clean ( target ) rebuild <identifiersep> after <identifiersep> cache <identifiersep> version <identifiersep> changed [ target ] = true <ect>
fs <identifiersep> operations . mark <identifiersep> chunk ( recursively = false , kotlin <identifiersep> only = true ) return } cache <identifiersep> version . action . clean <identifiersep> normal <identifiersep> caches - > { log . info ( <string_literal> ) for ( target in context . all <identifiersep> targets ( ) ) { data <identifiersep> manager . get <identifiersep> kotlin <identifiersep> cache ( target ) . clean ( ) } } <LOG> cache <identifiersep> version . action . clean <identifiersep> data <identifiersep> container - > { data <identifiersep> manager . clean <identifiersep> lookup <identifiersep> storage ( log ) cache <identifiersep> versions <identifiersep> provider . data <identifiersep> container <identifiersep> version ( ) . clean ( ) } else - > { assert ( status == cache <identifiersep> version . action . do <identifiersep> nothing ) { <string_literal> } } } } } private fun compile <identifiersep> context . all <identifiersep> targets ( ) = <ect>
for ( argument <identifiersep> provider in service <identifiersep> loader . load ( kotlin <identifiersep> jps <identifiersep> compiler <identifiersep> arguments <identifiersep> provider : : class . java ) ) { <comment> <LOG> argument <identifiersep> provider . get <identifiersep> classpath ( representative <identifiersep> target , context ) ) } if ( jps <identifiersep> utils . is <identifiersep> js <identifiersep> kotlin <identifiersep> module ( chunk . representative <identifiersep> target ( ) ) ) { log . debug ( <string_literal> ) return compile <identifiersep> to <identifiersep> js ( chunk , common <identifiersep> arguments , environment , project ) } if ( incremental <identifiersep> compilation . is <identifiersep> enabled ( ) ) { for ( target in chunk . targets ) { <ect>
for ( target in chunk . targets ) { val removed <identifiersep> files <identifiersep> in <identifiersep> target = kotlin <identifiersep> source <identifiersep> file <identifiersep> collector . get <identifiersep> removed <identifiersep> kotlin <identifiersep> files ( dirty <identifiersep> files <identifiersep> holder , target ) if ( ! removed <identifiersep> files <identifiersep> in <identifiersep> target . is <identifiersep> empty ( ) ) { if ( processed <identifiersep> targets <identifiersep> with <identifiersep> removed . add ( target ) ) { total <identifiersep> removed <identifiersep> files += removed <identifiersep> files <identifiersep> in <identifiersep> target . size } } } val module <identifiersep> file = kotlin <identifiersep> builder <identifiersep> module <identifiersep> script <identifiersep> generator . generate <identifiersep> module <identifiersep> description ( context , chunk , files <identifiersep> to <identifiersep> compile , total <identifiersep> removed <identifiersep> files != 0 ) <LOG> if ( module <identifiersep> file == null ) { <comment> <ect>
string html = issue . get <identifiersep> explanation ( text <identifiersep> format . html ) ; <comment> <LOG> <comment> <ect>
return <string_literal> ; } return application <identifiersep> manager . get <identifiersep> application ( ) . run <identifiersep> read <identifiersep> action ( new computable < string > ( ) { @ nullable @ override public string compute ( ) { final psi <identifiersep> file psi <identifiersep> file = psi <identifiersep> manager . get <identifiersep> instance ( my <identifiersep> project ) . find <identifiersep> file ( v <identifiersep> file ) ; <LOG> if ( psi <identifiersep> file == null ) { return null ; } else { return psi <identifiersep> file . get <identifiersep> text ( ) ; } } } ) ; } @ override <ect>
try { return files . to <identifiersep> string ( file , charsets . utf <identifiersep> <number_literal> ) ; } catch ( io <identifiersep> exception ioe ) { log . debug ( <string_literal> + file . get <identifiersep> path ( ) + <string_literal> ) ; return <string_literal> ; } } final string content = get <identifiersep> file <identifiersep> content ( v <identifiersep> file ) ; <LOG> if ( content == null ) { return <string_literal> ; } return content ; } @ nullable private string get <identifiersep> file <identifiersep> content ( final virtual <identifiersep> file v <identifiersep> file ) { if ( comparing . equal ( my <identifiersep> state . get <identifiersep> main <identifiersep> file ( ) , v <identifiersep> file ) ) { <ect>
<string_literal> + <string_literal> , log <identifiersep> call <identifiersep> name , is <identifiersep> loggable <identifiersep> description , log <identifiersep> call <identifiersep> description ) ; context . report ( wrong <identifiersep> tag , is <identifiersep> loggable <identifiersep> call , location , message ) ; } } } <LOG> <comment> <ect>
<comment> <LOG> long end = system . current <identifiersep> time <identifiersep> millis ( ) ; + <string_literal> ) ; system . out . println ( <string_literal> + m <identifiersep> data . length + <string_literal> + integer . to <identifiersep> string ( m <identifiersep> data . length / <number_literal> ) + <string_literal> ) ; } } <comment> private static void write <identifiersep> database ( file file , list < string > lines ) throws io <identifiersep> exception { <ect>
next <identifiersep> entry = buffer . position ( ) ; } int size = buffer . position ( ) ; assert size < = buffer . limit ( ) ; buffer . mark ( ) ; if ( write <identifiersep> stats ) { system . out . println ( <string_literal> + words . size ( ) + <string_literal> ) ; <LOG> system . out . print ( <string_literal> + size + <string_literal> ) ; system . out . println ( <string_literal> + ( entry <identifiersep> count * bytes <identifiersep> per <identifiersep> entry ) + <string_literal> ) ; system . out . println ( <string_literal> + ( size / entry <identifiersep> count ) + <string_literal> ) ; } <comment> <ect>
assert size < = buffer . limit ( ) ; buffer . mark ( ) ; if ( write <identifiersep> stats ) { system . out . println ( <string_literal> + words . size ( ) + <string_literal> ) ; system . out . print ( <string_literal> + size + <string_literal> ) ; system . out . println ( string . format ( <string_literal> , size / ( <number_literal> * <number_literal> . f ) ) ) ; <LOG> system . out . println ( <string_literal> + ( entry <identifiersep> count * bytes <identifiersep> per <identifiersep> entry ) + <string_literal> ) ; } <comment> <ect>
string s = new string ( arrays . copy <identifiersep> of <identifiersep> range ( utf8text , begin , end ) , charsets . utf <identifiersep> <number_literal> ) ; system . out . println ( <string_literal> + s + <string_literal> + offset + <string_literal> + dump <identifiersep> entry ( offset ) ) ; system . out . println ( <string_literal> + middle + <string_literal> + low + <string_literal> + high ) ; } <comment> <LOG> if ( debug <identifiersep> search ) { } if ( compare == 0 ) { offset = m <identifiersep> indices [ middle ] ; <comment> <ect>
} catch ( throwable e ) { client . log ( null , <string_literal> , binary <identifiersep> file . get <identifiersep> path ( ) ) ; client . log ( null , <string_literal> , binary <identifiersep> file . get <identifiersep> path ( ) ) ; client . log ( e , null ) ; } if ( write <identifiersep> stats ) { <LOG> long end = system . current <identifiersep> time <identifiersep> millis ( ) ; + <string_literal> ) ; system . out . println ( <string_literal> + m <identifiersep> data . length + <string_literal> + integer . to <identifiersep> string ( m <identifiersep> data . length / <number_literal> ) + <string_literal> ) ; } } <comment> private static void write <identifiersep> database ( file file , api info ) throws io <identifiersep> exception { <ect>
put3byte <identifiersep> int ( buffer , first <identifiersep> class <identifiersep> index ) ; put2byte <identifiersep> int ( buffer , class <identifiersep> count ) ; } } int size = buffer . position ( ) ; assert size < = buffer . limit ( ) ; buffer . mark ( ) ; if ( write <identifiersep> stats ) { <LOG> system . out . print ( <string_literal> + size + <string_literal> ) ; } <comment> <ect>
int offset = m <identifiersep> indices [ middle ] ; if ( debug <identifiersep> search ) { system . out . println ( <string_literal> + owner . substring ( 0 , class <identifiersep> name <identifiersep> length ) + <string_literal> + offset + <string_literal> + dump <identifiersep> entry ( offset ) ) ; } int compare = compare ( m <identifiersep> data , offset , ( byte ) 0 , owner , 0 , class <identifiersep> name <identifiersep> length ) ; if ( compare == 0 ) { <LOG> if ( debug <identifiersep> search ) { } return middle ; } if ( compare < 0 ) { low = middle + 1 ; } else if ( compare > 0 ) { high = middle - 1 ; <ect>
offset ++ ; <comment> <LOG> if ( debug <identifiersep> search ) { } return middle ; } if ( compare < 0 ) { low = middle + 1 ; } else if ( compare > 0 ) { high = middle - 1 ; <ect>
offset += name <identifiersep> length ; int args <identifiersep> end = desc . index <identifiersep> of ( ' ) ' ) ; <comment> <LOG> if ( debug <identifiersep> search ) { } offset += args <identifiersep> end + 1 ; if ( m <identifiersep> data [ offset ++ ] == 0 ) { <comment> <ect>
assert clz != null : super <identifiersep> class . get <identifiersep> second ( ) ; if ( clz != null ) { integer super <identifiersep> since = clz . get <identifiersep> field ( field , info ) ; if ( super <identifiersep> since == integer . max <identifiersep> value ) { continue ; } if ( super <identifiersep> since != null && super <identifiersep> since > since ) { <LOG> string declared <identifiersep> in = clz . find <identifiersep> field <identifiersep> declaration ( info , field ) ; + since + <string_literal> + declared <identifiersep> in + <string_literal> + super <identifiersep> since ) ; continue field <identifiersep> loop ; } } } } } private string find <identifiersep> field <identifiersep> declaration ( api info , string name ) { if ( m <identifiersep> fields . contains <identifiersep> key ( name ) ) { <ect>
val is <identifiersep> verbose = configuration . get ( kapt3configuration <identifiersep> keys . verbose <identifiersep> mode ) == <string_literal> val message <identifiersep> collector = configuration . get ( cli <identifiersep> configuration <identifiersep> keys . message <identifiersep> collector <identifiersep> key ) ? : printing <identifiersep> message <identifiersep> collector ( system . err , message <identifiersep> renderer . plain <identifiersep> full <identifiersep> paths , is <identifiersep> verbose ) val logger = kapt <identifiersep> logger ( is <identifiersep> verbose , message <identifiersep> collector ) try { class . for <identifiersep> name ( javac <identifiersep> context <identifiersep> class ) <LOG> } catch ( e : class <identifiersep> not <identifiersep> found <identifiersep> exception ) { return } val sources <identifiersep> output <identifiersep> dir = configuration . get ( kapt3configuration <identifiersep> keys . source <identifiersep> output <identifiersep> dir ) ? . let ( : : file ) val class <identifiersep> files <identifiersep> output <identifiersep> dir = configuration . get ( kapt3configuration <identifiersep> keys . class <identifiersep> output <identifiersep> dir ) ? . let ( : : file ) val stubs <identifiersep> output <identifiersep> dir = configuration . get ( kapt3configuration <identifiersep> keys . stubs <identifiersep> output <identifiersep> dir ) ? . let ( : : file ) val incremental <identifiersep> data <identifiersep> output <identifiersep> dir = configuration . get ( kapt3configuration <identifiersep> keys . incremental <identifiersep> data <identifiersep> output <identifiersep> dir ) ? . let ( : : file ) <ect>
val content <identifiersep> roots = configuration [ jvm <identifiersep> configuration <identifiersep> keys . content <identifiersep> roots ] ? : empty <identifiersep> list ( ) val compile <identifiersep> classpath = content <identifiersep> roots . filter <identifiersep> is <identifiersep> instance < jvm <identifiersep> classpath <identifiersep> root > ( ) . map { it . file } val java <identifiersep> source <identifiersep> roots = content <identifiersep> roots . filter <identifiersep> is <identifiersep> instance < java <identifiersep> source <identifiersep> root > ( ) . map { it . file } val use <identifiersep> light <identifiersep> analysis = configuration . get ( kapt3configuration <identifiersep> keys . use <identifiersep> light <identifiersep> analysis ) == <string_literal> val correct <identifiersep> error <identifiersep> types = configuration . get ( kapt3configuration <identifiersep> keys . correct <identifiersep> error <identifiersep> types ) == <string_literal> val map <identifiersep> diagnostic <identifiersep> locations = configuration . get ( kapt3configuration <identifiersep> keys . map <identifiersep> diagnostic <identifiersep> locations ) == <string_literal> <LOG> if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <ect>
val java <identifiersep> source <identifiersep> roots = content <identifiersep> roots . filter <identifiersep> is <identifiersep> instance < java <identifiersep> source <identifiersep> root > ( ) . map { it . file } val use <identifiersep> light <identifiersep> analysis = configuration . get ( kapt3configuration <identifiersep> keys . use <identifiersep> light <identifiersep> analysis ) == <string_literal> val correct <identifiersep> error <identifiersep> types = configuration . get ( kapt3configuration <identifiersep> keys . correct <identifiersep> error <identifiersep> types ) == <string_literal> val map <identifiersep> diagnostic <identifiersep> locations = configuration . get ( kapt3configuration <identifiersep> keys . map <identifiersep> diagnostic <identifiersep> locations ) == <string_literal> if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) logger . info ( <string_literal> + java <identifiersep> source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> ) } val kapt3analysis <identifiersep> completed <identifiersep> handler <identifiersep> extension = classpath <identifiersep> based <identifiersep> kapt3extension ( compile <identifiersep> classpath , ap <identifiersep> classpath , java <identifiersep> source <identifiersep> roots , sources <identifiersep> output <identifiersep> dir , class <identifiersep> files <identifiersep> output <identifiersep> dir , <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) <LOG> logger . info ( <string_literal> + annotation <identifiersep> processors ) logger . info ( <string_literal> ) } val kapt3analysis <identifiersep> completed <identifiersep> handler <identifiersep> extension = classpath <identifiersep> based <identifiersep> kapt3extension ( compile <identifiersep> classpath , ap <identifiersep> classpath , java <identifiersep> source <identifiersep> roots , sources <identifiersep> output <identifiersep> dir , class <identifiersep> files <identifiersep> output <identifiersep> dir , stubs <identifiersep> output <identifiersep> dir , incremental <identifiersep> data <identifiersep> output <identifiersep> dir , ap <identifiersep> options , javac <identifiersep> cli <identifiersep> options , annotation <identifiersep> processors , apt <identifiersep> mode , use <identifiersep> light <identifiersep> analysis , correct <identifiersep> error <identifiersep> types , map <identifiersep> diagnostic <identifiersep> locations , system . current <identifiersep> time <identifiersep> millis ( ) , logger , configuration ) <ect>
override fun load <identifiersep> processors ( ) : list < processor > { class <identifiersep> util <identifiersep> core . clear <identifiersep> jar <identifiersep> url <identifiersep> cache ( ) val classpath = annotation <identifiersep> processing <identifiersep> classpath + compile <identifiersep> classpath val class <identifiersep> loader = url <identifiersep> class <identifiersep> loader ( classpath . map { it . to <identifiersep> uri ( ) . to <identifiersep> url ( ) } . to <identifiersep> typed <identifiersep> array ( ) ) this . annotation <identifiersep> processing <identifiersep> class <identifiersep> loader = class <identifiersep> loader val processors = service <identifiersep> loader . load ( processor : : class . java , class <identifiersep> loader ) . to <identifiersep> list ( ) <LOG> if ( processors . is <identifiersep> empty ( ) ) { } else { logger . info { <string_literal> + processors . join <identifiersep> to <identifiersep> string { it : : class . java . canonical <identifiersep> name } } } return processors } } abstract class abstract <identifiersep> kapt3extension ( compile <identifiersep> classpath : list < file > , <ect>
throw kapt <identifiersep> error ( kapt <identifiersep> error . kind . exception , e . cause ? : e ) } val log = compiler <identifiersep> after <identifiersep> ap . log val filer = processing <identifiersep> environment . filer as javac <identifiersep> filer val error <identifiersep> count = log . nerrors val warning <identifiersep> count = log . nwarnings if ( logger . is <identifiersep> verbose ) { <LOG> logger . info ( <string_literal> ) wrapped <identifiersep> processors . for <identifiersep> each { processor - > val rounds = processor . rounds val round <identifiersep> ms = rounds . join <identifiersep> to <identifiersep> string { <string_literal> } val total <identifiersep> ms = rounds . sum ( ) logger . info ( <string_literal> ) <ect>
java <identifiersep> location + it . get <identifiersep> message ( locale . us ) . lines ( ) . first ( ) } . map { <string_literal> + expected <identifiersep> error + it } . sorted ( ) log . flush ( ) val line <identifiersep> separator = system . get <identifiersep> property ( <string_literal> ) system . err . println ( actual <identifiersep> errors . join <identifiersep> to <identifiersep> string ( line <identifiersep> separator ) ) <LOG> if ( expected <identifiersep> errors . is <identifiersep> empty ( ) ) { } else { test <identifiersep> case . assert <identifiersep> equals ( <string_literal> , expected <identifiersep> errors . join <identifiersep> to <identifiersep> string ( line <identifiersep> separator ) , actual <identifiersep> errors . join <identifiersep> to <identifiersep> string ( line <identifiersep> separator ) ) } } kotlin <identifiersep> test <identifiersep> utils . assert <identifiersep> equals <identifiersep> to <identifiersep> file ( txt <identifiersep> file , actual ) <ect>
super . save <identifiersep> stubs ( kapt <identifiersep> context , stubs ) } override fun save <identifiersep> incremental <identifiersep> data ( kapt <identifiersep> context : kapt <identifiersep> context < generation <identifiersep> state > , message <identifiersep> collector : message <identifiersep> collector , converter : class <identifiersep> file <identifiersep> to <identifiersep> source <identifiersep> stub <identifiersep> converter ) { <LOG> if ( this . saved <identifiersep> bindings != null ) { } this . saved <identifiersep> bindings = converter . bindings super . save <identifiersep> incremental <identifiersep> data ( kapt <identifiersep> context , message <identifiersep> collector , converter ) } } } <ect>
public class exec { void exec ( sam sam ) { } } <comment> <LOG> e . exec { } e . exec { val a : string = < ! no <identifiersep> this ! > this < ! > system . out . println ( a ) } <ect>
} ) override fun get <identifiersep> text ( ) = <string_literal> @ suppress ( <string_literal> ) override fun invoke ( kt <identifiersep> psi <identifiersep> factory : kt <identifiersep> psi <identifiersep> factory , parcelable <identifiersep> class : kt <identifiersep> class ) { val parceler <identifiersep> object = parcelable <identifiersep> class . find <identifiersep> parceler <identifiersep> companion <identifiersep> object ( ) ? . first ? : parcelable <identifiersep> class . get <identifiersep> or <identifiersep> create <identifiersep> companion <identifiersep> object ( ) val binding <identifiersep> context = parceler <identifiersep> object . analyze ( body <identifiersep> resolve <identifiersep> mode . partial ) <LOG> val parceler <identifiersep> type <identifiersep> arg = parcelable <identifiersep> class . name ? : run { return } val parceler <identifiersep> object <identifiersep> descriptor = binding <identifiersep> context [ binding <identifiersep> context . class , parceler <identifiersep> object ] ? : run { log . error ( <string_literal> < unnamed parcelable class > <string_literal> ) return } if ( ! parceler <identifiersep> object <identifiersep> descriptor . get <identifiersep> all <identifiersep> super <identifiersep> classifiers ( ) . any { it . fq <identifiersep> name <identifiersep> safe == parceler <identifiersep> fqname } ) { <ect>
test . write <identifiersep> to <identifiersep> parcel ( parcel , 0 ) } catch ( e : runtime <identifiersep> exception ) { if ( e . message ! ! . contains ( <string_literal> ) ) { exception <identifiersep> caught = true } else { throw e } } <LOG> if ( ! exception <identifiersep> caught ) { } <ect>
resource ( faulty <identifiersep> close = true ) . use { error ( <string_literal> ) } } assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) assert <identifiersep> true ( e . suppressed . single ( ) is io <identifiersep> exception ) } @ test fun op <identifiersep> fails <identifiersep> close <identifiersep> fails <identifiersep> twice ( ) { val e = assert <identifiersep> fails { resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > <LOG> resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > } } } assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) val suppressed = e . suppressed assert <identifiersep> equals ( <number_literal> , suppressed . size ) assert <identifiersep> true ( suppressed . all { it is io <identifiersep> exception } ) } @ test fun non <identifiersep> local <identifiersep> return <identifiersep> in <identifiersep> block ( ) { <ect>
resource ( faulty <identifiersep> close = true ) . use { error ( <string_literal> ) } } assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) assert <identifiersep> true ( e . suppressed . single ( ) is io <identifiersep> exception ) } @ test fun op <identifiersep> fails <identifiersep> close <identifiersep> fails <identifiersep> twice ( ) { val e = assert <identifiersep> fails { resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > <LOG> resource ( faulty <identifiersep> close = true ) . use {  <identifiersep>  - > } } } assert <identifiersep> true ( e is illegal <identifiersep> state <identifiersep> exception ) val suppressed = e . suppressed assert <identifiersep> equals ( <number_literal> , suppressed . size ) assert <identifiersep> true ( suppressed . all { it is io <identifiersep> exception } ) } @ test fun non <identifiersep> local <identifiersep> return <identifiersep> in <identifiersep> block ( ) { <ect>
assert <identifiersep> true ( stack . is <identifiersep> empty ( ) ) assert <identifiersep> equals ( set <identifiersep> of ( <string_literal> ) , failed ) assert <identifiersep> equals ( list <identifiersep> of ( <string_literal> , <string_literal> , <string_literal> , <string_literal> ) . map { file ( it ) } . to <identifiersep> set ( ) , dirs ) assert <identifiersep> equals ( list <identifiersep> of ( <string_literal> , <string_literal> ) . map { file ( it ) } . to <identifiersep> set ( ) , files ) } finally { file ( basedir , <string_literal> ) . set <identifiersep> readable ( true ) } <LOG> } else { } } finally { basedir . delete <identifiersep> recursively ( ) } } @ test fun top <identifiersep> down ( ) { val basedir = create <identifiersep> test <identifiersep> files ( ) try { <ect>
<comment> public class arrays <identifiersep> test extends test <identifiersep> case { public void test <identifiersep> arrays ( ) throws exception { string [ ] array = { <string_literal> , <string_literal> , <string_literal> } ; <LOG> string text = join <identifiersep> to <identifiersep> string ( array , <string_literal> , <string_literal> , <string_literal> , - 1 , <string_literal> , null ) ; assert <identifiersep> equals ( <string_literal> , text ) ; collection < string > actual = filter ( array , new function1 < string , boolean > ( ) { @ override public boolean invoke ( string text ) { return text . length ( ) > 1 ; <ect>
<comment> public class collection <identifiersep> test extends test <identifiersep> case { public void test <identifiersep> collections ( ) throws exception { list < string > list = array <identifiersep> list <identifiersep> of ( <string_literal> , <string_literal> ) ; <LOG> string text = join <identifiersep> to <identifiersep> string ( list , <string_literal> , <string_literal> , <string_literal> , - 1 , <string_literal> , null ) ; assert <identifiersep> equals ( <string_literal> , text ) ; collection < string > actual = filter ( list , new function1 < string , boolean > ( ) { @ override public boolean invoke ( string text ) { return text . starts <identifiersep> with ( <string_literal> ) ; <ect>
actual fun < t : throwable > assert <identifiersep> fails <identifiersep> with ( exception <identifiersep> class : k <identifiersep> class < t > , message : string ? , block : ( ) - > unit ) : t = assert <identifiersep> fails <identifiersep> with <identifiersep> impl ( exception <identifiersep> class . java , message , block ) <comment> @ inline <identifiersep> only <LOG> actual inline fun todo ( @ suppress ( <string_literal> ) block : ( ) - > unit ) { } <comment> <ect>
import org . codehaus . plexus . logging . * import org . jetbrains . kotlin . maven . * @ component ( role = kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension : : class , hint = <string_literal> ) class maven <identifiersep> plugin <identifiersep> component : kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension { @ requirement lateinit var logger : logger <LOG> override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : boolean { return true } override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = test <identifiersep> command <identifiersep> line <identifiersep> processor . test <identifiersep> plugin <identifiersep> id override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { logger . info ( <string_literal> ) return list <identifiersep> of ( plugin <identifiersep> option ( <ect>
import org . junit . rules . test <identifiersep> rule ; import org . junit . rules . test <identifiersep> watcher ; import org . junit . runner . description ; public abstract class maven <identifiersep> it <identifiersep> base { @ rule public test <identifiersep> rule watcher = new test <identifiersep> watcher ( ) { <LOG> protected void starting ( description description ) { } } ; } <ect>
private val kotlin <identifiersep> compiler <identifiersep> execution <identifiersep> strategy : string get ( ) = system . get <identifiersep> property ( kotlin <identifiersep> compiler <identifiersep> execution <identifiersep> strategy <identifiersep> property ) ? : daemon <identifiersep> execution <identifiersep> strategy override fun compile <identifiersep> with <identifiersep> daemon ( compiler <identifiersep> class <identifiersep> name : string , compiler <identifiersep> args : common <identifiersep> compiler <identifiersep> arguments , environment : gradle <identifiersep> compiler <identifiersep> environment ) : exit <identifiersep> code ? { val connection = try { get <identifiersep> daemon <identifiersep> connection ( environment ) } <LOG> catch ( e : throwable ) { e . print <identifiersep> stack <identifiersep> trace ( ) null } if ( connection == null ) { if ( environment is gradle <identifiersep> incremental <identifiersep> compiler <identifiersep> environment ) { log . warn ( <string_literal> ) <ect>
val exit <identifiersep> code = try { val res = if ( environment is gradle <identifiersep> incremental <identifiersep> compiler <identifiersep> environment ) { incremental <identifiersep> compilation <identifiersep> with <identifiersep> daemon ( daemon , session <identifiersep> id , target <identifiersep> platform , environment ) } else { non <identifiersep> incremental <identifiersep> compilation <identifiersep> with <identifiersep> daemon ( daemon , session <identifiersep> id , target <identifiersep> platform , environment ) } exit <identifiersep> code <identifiersep> from <identifiersep> process <identifiersep> exit <identifiersep> code ( res . get ( ) ) } <LOG> catch ( e : throwable ) { e . print <identifiersep> stack <identifiersep> trace ( ) null } <comment> <ect>
compiler <identifiersep> mode = compiler <identifiersep> mode . incremental <identifiersep> compiler , target <identifiersep> platform = target <identifiersep> platform , result <identifiersep> difference <identifiersep> file = environment . build <identifiersep> history <identifiersep> file , friend <identifiersep> difference <identifiersep> file = environment . friend <identifiersep> build <identifiersep> history <identifiersep> file , use <identifiersep> precise <identifiersep> java <identifiersep> tracking = environment . use <identifiersep> precise <identifiersep> java <identifiersep> tracking , local <identifiersep> state <identifiersep> dirs = environment . local <identifiersep> state <identifiersep> dirs <LOG> ) val services <identifiersep> facade = gradle <identifiersep> incremental <identifiersep> compiler <identifiersep> services <identifiersep> facade <identifiersep> impl ( project , environment ) val args <identifiersep> array = argument <identifiersep> utils . convert <identifiersep> arguments <identifiersep> to <identifiersep> string <identifiersep> list ( environment . compiler <identifiersep> args ) . to <identifiersep> typed <identifiersep> array ( ) return daemon . compile ( session <identifiersep> id , args <identifiersep> array , compilation <identifiersep> options , services <identifiersep> facade , gradle <identifiersep> compilation <identifiersep> results ( project ) ) } private fun report <identifiersep> categories ( verbose : boolean ) : array < int > = if ( ! verbose ) { <ect>
return project . extensions . get <identifiersep> by <identifiersep> name ( <string_literal> ) as base <identifiersep> extension } catch ( e : unknown <identifiersep> domain <identifiersep> object <identifiersep> exception ) { return null } } private fun add <identifiersep> generated <identifiersep> sources <identifiersep> output <identifiersep> to <identifiersep> compiler <identifiersep> args ( java <identifiersep> task : java <identifiersep> compile , output <identifiersep> dir : file ) { output <identifiersep> dir . mkdirs ( ) java <identifiersep> task . add <identifiersep> compiler <identifiersep> argument ( <string_literal> ) { prev <identifiersep> value - > <LOG> if ( prev <identifiersep> value != null ) output <identifiersep> dir . absolute <identifiersep> path } } private fun set <identifiersep> processor <identifiersep> path <identifiersep> in <identifiersep> java <identifiersep> task ( ) { val path = kapt <identifiersep> processor <identifiersep> path <comment> <ect>
separator = file . path <identifiersep> separator ) } } } private fun try <identifiersep> append <identifiersep> processor <identifiersep> path <identifiersep> property ( path : iterable < file > ) : boolean = try { val options <identifiersep> class = java <identifiersep> task . options . java <identifiersep> class val get <identifiersep> path = options <identifiersep> class . get <identifiersep> method ( <string_literal> ) val set <identifiersep> path = options <identifiersep> class . get <identifiersep> method ( <string_literal> , file <identifiersep> collection : : class . java ) original <identifiersep> processor <identifiersep> path = get <identifiersep> path ( java <identifiersep> task . options ) as ? file <identifiersep> collection <LOG> if ( original <identifiersep> processor <identifiersep> path != null ) val new <identifiersep> path = java <identifiersep> task . project . files ( path + ( original <identifiersep> processor <identifiersep> path ? : empty <identifiersep> list ( ) ) ) set <identifiersep> path ( java <identifiersep> task . options , new <identifiersep> path ) true } catch (  <identifiersep>  : no <identifiersep> such <identifiersep> method <identifiersep> exception ) { false <ect>
for ( ( key , value ) in options . entries ) { oos . write <identifiersep> utf ( key ) oos . write <identifiersep> utf ( value ) } oos . flush ( ) return base64 . get <identifiersep> encoder ( ) . encode <identifiersep> to <identifiersep> string ( os . to <identifiersep> byte <identifiersep> array ( ) ) } private fun kapt3subplugin <identifiersep> context . add <identifiersep> misc <identifiersep> options ( plugin <identifiersep> options : mutable <identifiersep> list < subplugin <identifiersep> option > ) { <LOG> if ( kapt <identifiersep> extension . generate <identifiersep> stubs ) { } plugin <identifiersep> options += subplugin <identifiersep> option ( <string_literal> , <string_literal> ) plugin <identifiersep> options += subplugin <identifiersep> option ( <string_literal> , <string_literal> ) plugin <identifiersep> options += subplugin <identifiersep> option ( <string_literal> , <string_literal> ) plugin <identifiersep> options += files <identifiersep> subplugin <identifiersep> option ( <string_literal> , list <identifiersep> of ( get <identifiersep> kapt <identifiersep> stubs <identifiersep> dir ( ) ) ) if ( project . has <identifiersep> property ( verbose <identifiersep> option <identifiersep> name ) && project . property ( verbose <identifiersep> option <identifiersep> name ) == <string_literal> ) { <ect>
if ( line > 0 && column > 0 ) { append ( <string_literal> ) } } append ( message ) } when ( severity ) { compiler <identifiersep> message <identifiersep> severity . error , compiler <identifiersep> message <identifiersep> severity . exception - > { <LOG> has <identifiersep> errors = true } compiler <identifiersep> message <identifiersep> severity . warning , compiler <identifiersep> message <identifiersep> severity . strong <identifiersep> warning - > { logger . warn ( format <identifiersep> msg ( <string_literal> ) ) } compiler <identifiersep> message <identifiersep> severity . info - > { logger . info ( format <identifiersep> msg ( <string_literal> ) ) <ect>
compiler <identifiersep> message <identifiersep> severity . exception - > { has <identifiersep> errors = true logger . error ( format <identifiersep> msg ( <string_literal> ) ) } compiler <identifiersep> message <identifiersep> severity . warning , compiler <identifiersep> message <identifiersep> severity . strong <identifiersep> warning - > { logger . warn ( format <identifiersep> msg ( <string_literal> ) ) } <LOG> compiler <identifiersep> message <identifiersep> severity . info - > { } compiler <identifiersep> message <identifiersep> severity . logging , compiler <identifiersep> message <identifiersep> severity . output - > { logger . debug ( format <identifiersep> msg ( <string_literal> ) ) } } ! ! <comment> <ect>
root <identifiersep> kotlin <identifiersep> options : kotlin <identifiersep> jvm <identifiersep> options <identifiersep> impl , tasks <identifiersep> provider : kotlin <identifiersep> tasks <identifiersep> provider , subplugin <identifiersep> environment : subplugin <identifiersep> environment ) { check <identifiersep> variant <identifiersep> is <identifiersep> valid ( variant <identifiersep> data ) val variant <identifiersep> data <identifiersep> name = get <identifiersep> variant <identifiersep> name ( variant <identifiersep> data ) logger . kotlin <identifiersep> debug ( <string_literal> ) val java <identifiersep> task = get <identifiersep> java <identifiersep> task ( variant <identifiersep> data ) <LOG> if ( java <identifiersep> task == null ) { return } val kotlin <identifiersep> task <identifiersep> name = <string_literal> <comment> <ect>
project . configurations . get <identifiersep> by <identifiersep> name ( <string_literal> ) . dependencies . add ( dep ) } else { throw gradle <identifiersep> exception ( <string_literal> ) } } } val incremental <identifiersep> multiplatform = properties <identifiersep> provider ( project ) . incremental <identifiersep> multiplatform ? : true project . after <identifiersep> evaluate { project . tasks . with <identifiersep> type ( abstract <identifiersep> kotlin <identifiersep> compile : : class . java ) . all { <LOG> if ( it . incremental && ! incremental <identifiersep> multiplatform ) { } it . incremental = it . incremental && incremental <identifiersep> multiplatform } } } private var implement <identifiersep> configuration <identifiersep> is <identifiersep> used = false private fun add <identifiersep> common <identifiersep> project ( common <identifiersep> project : project , platform <identifiersep> project : project ) { common <identifiersep> projects . add ( common <identifiersep> project ) common <identifiersep> project . when <identifiersep> evaluated { <ect>
@ component ( role = kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension : : class , hint = <string_literal> ) class kotlin <identifiersep> no <identifiersep> arg <identifiersep> maven <identifiersep> plugin <identifiersep> extension : kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension { @ requirement lateinit var logger : logger override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = noarg <identifiersep> compiler <identifiersep> plugin <identifiersep> id override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) = true <LOG> override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { return empty <identifiersep> list ( ) } } @ component ( role = kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension : : class , hint = <string_literal> ) class kotlin <identifiersep> jpa <identifiersep> maven <identifiersep> plugin <identifiersep> extension : kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension { private companion object { val preset <identifiersep> arg <identifiersep> name = <string_literal> <ect>
val src <identifiersep> dir = file ( <string_literal> ) if ( ! src <identifiersep> dir . exists ( ) ) { system . err ? . println ( <string_literal> ) system . exit ( 1 ) return } val repository <identifiersep> pre = src <identifiersep> dir . walk <identifiersep> top <identifiersep> down ( ) . filter { it . is <identifiersep> directory || it . extension == <string_literal> } . as <identifiersep> sequence ( ) . filter { it . is <identifiersep> file } . to <identifiersep> list ( ) . sorted <identifiersep> by { it . absolute <identifiersep> path } . fold ( repository ( empty <identifiersep> map ( ) , empty <identifiersep> map ( ) , empty <identifiersep> map ( ) , empty <identifiersep> map ( ) ) ) { acc , e - > <LOG> system . err . flush ( ) val file <identifiersep> repository = parse <identifiersep> idl ( antlr <identifiersep> file <identifiersep> stream ( e . absolute <identifiersep> path , <string_literal> ) ) repository ( interfaces = acc . interfaces . merge <identifiersep> reduce ( file <identifiersep> repository . interfaces , : : merge ) , type <identifiersep> defs = acc . type <identifiersep> defs + file <identifiersep> repository . type <identifiersep> defs , externals = acc . externals . merge ( file <identifiersep> repository . externals ) , <ect>
iface . kind == generate <identifiersep> definition <identifiersep> kind . class && attribute . is <identifiersep> val - > member <identifiersep> modality . open iface . kind == generate <identifiersep> definition <identifiersep> kind . abstract <identifiersep> class - > member <identifiersep> modality . open else - > member <identifiersep> modality . final } if ( attribute . name in super <identifiersep> attributes <identifiersep> by <identifiersep> name && attribute . signature ! in super <identifiersep> signatures ) { system . err . println ( <string_literal> ) for ( ( super <identifiersep> type <identifiersep> name , attributes ) in all <identifiersep> super <identifiersep> types . map { it . name to it . member <identifiersep> attributes . filter { it . name == attribute . name } . distinct ( ) } ) { <LOG> for ( super <identifiersep> attribute in attributes ) { } } } else if ( modality == member <identifiersep> modality . override && attribute . kind <identifiersep> not <identifiersep> changed ( super <identifiersep> attributes <identifiersep> by <identifiersep> name ) && ( iface . kind == generate <identifiersep> definition <identifiersep> kind . interface || attribute . has <identifiersep> super <identifiersep> implementation ( all <identifiersep> super <identifiersep> types ) ) ) { <comment> <ect>
if ( is <identifiersep> log <identifiersep> enabled ( ) ) { log ( get <identifiersep> message . invoke ( ) ) ; } } @ override public void report <identifiersep> compile <identifiersep> iteration ( collection < ? extends file > source <identifiersep> files , exit <identifiersep> code exit <identifiersep> code ) { compiled <identifiersep> kotlin <identifiersep> files . add <identifiersep> all ( source <identifiersep> files ) ; if ( is <identifiersep> log <identifiersep> enabled ( ) ) { <LOG> log ( <string_literal> + paths <identifiersep> as <identifiersep> string ( source <identifiersep> files ) ) ; } } @ not <identifiersep> null @ override public string paths <identifiersep> as <identifiersep> string ( iterable < ? extends file > files ) { return ic <identifiersep> reporter . default <identifiersep> impls . paths <identifiersep> as <identifiersep> string ( this , files ) ; } @ not <identifiersep> null <ect>
file <identifiersep> snapshot prev <identifiersep> snapshot = previous <identifiersep> snapshots . remove ( relative <identifiersep> path ) ; if ( ! snapshot . equals ( prev <identifiersep> snapshot ) ) { path target = target <identifiersep> base . resolve ( relative <identifiersep> path ) ; if ( ! files . is <identifiersep> directory ( target ) ) { files . delete <identifiersep> if <identifiersep> exists ( target ) ; files . create <identifiersep> directories ( target . get <identifiersep> parent ( ) ) ; <LOG> files . copy ( path , target ) ; } } new <identifiersep> snapshots . put ( relative <identifiersep> path , snapshot ) ; } for ( string removed <identifiersep> path : previous <identifiersep> snapshots . key <identifiersep> set ( ) ) { path target = target <identifiersep> base . resolve ( removed <identifiersep> path ) ; log . debug ( <string_literal> + target + <string_literal> + source <identifiersep> base ) ; if ( files . is <identifiersep> regular <identifiersep> file ( target ) ) { <ect>
for ( map . entry < string , file <identifiersep> snapshot > entry : snapshots . entry <identifiersep> set ( ) ) { string path = entry . get <identifiersep> key ( ) ; output . write <identifiersep> utf ( path ) ; file <identifiersep> snapshot snapshot = entry . get <identifiersep> value ( ) ; output . write <identifiersep> long ( snapshot . last <identifiersep> modified ) ; output . write <identifiersep> long ( snapshot . size ) ; } <LOG> } catch ( exception e ) { } } @ not <identifiersep> null private map < string , file <identifiersep> snapshot > read <identifiersep> file <identifiersep> snapshots ( @ not <identifiersep> null file input <identifiersep> file ) { map < string , file <identifiersep> snapshot > snapshots = new hash <identifiersep> map < > ( ) ; if ( ! input <identifiersep> file . is <identifiersep> file ( ) ) return snapshots ; try ( object <identifiersep> input <identifiersep> stream input = new object <identifiersep> input <identifiersep> stream ( new buffered <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( input <identifiersep> file ) ) ) ) { <ect>
log . info ( text ) ; break ; } case logging : case output : { log . debug ( text ) ; break ; } <LOG> default : { } } } public void throw <identifiersep> kotlin <identifiersep> compiler <identifiersep> exception ( ) throws kotlin <identifiersep> compilation <identifiersep> failure <identifiersep> exception { throw new kotlin <identifiersep> compilation <identifiersep> failure <identifiersep> exception ( get <identifiersep> collected <identifiersep> errors ( ) . stream ( ) . map ( pair - > { compiler <identifiersep> message <identifiersep> location location = pair . get <identifiersep> first ( ) ; string message = pair . get <identifiersep> second ( ) ; if ( location == null ) { <ect>
<comment> <LOG> if ( version <identifiersep> match == null ) { } else { java <identifiersep> home . take <identifiersep> if { it . is <identifiersep> not <identifiersep> empty ( ) } ? . let { file ( it ) } ? . take <identifiersep> if { it . is <identifiersep> directory && file ( it , <string_literal> , <string_literal> ) . is <identifiersep> file } ? . let { <ect>
val out <identifiersep> bytes = transform ( entry . name , in <identifiersep> bytes ) if ( in <identifiersep> bytes . size < out <identifiersep> bytes . size ) { error ( <string_literal> ) } entry . compressed <identifiersep> size = - 1l out <identifiersep> jar . put <identifiersep> next <identifiersep> entry ( entry ) out <identifiersep> jar . write ( out <identifiersep> bytes ) <LOG> out <identifiersep> jar . close <identifiersep> entry ( ) } } } logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) } <ect>
error ( <string_literal> ) } entry . compressed <identifiersep> size = - 1l out <identifiersep> jar . put <identifiersep> next <identifiersep> entry ( entry ) out <identifiersep> jar . write ( out <identifiersep> bytes ) out <identifiersep> jar . close <identifiersep> entry ( ) } } } logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) } <ect>
out <identifiersep> jar . put <identifiersep> next <identifiersep> entry ( entry ) out <identifiersep> jar . write ( out <identifiersep> bytes ) out <identifiersep> jar . close <identifiersep> entry ( ) } } } logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) } <ect>
@ get : input <identifiersep> files val source <identifiersep> dirs : file <identifiersep> collection get ( ) = project . files ( source <identifiersep> set ! ! . all <identifiersep> source . src <identifiersep> dirs . filter { ! source <identifiersep> set ! ! . resources . contains ( it ) && it . exists ( ) } ) @ get : output <identifiersep> directory var output : file ? = null @ task <identifiersep> action <LOG> fun instrument <identifiersep> classes ( ) { output ? . delete <identifiersep> recursively ( ) copy <identifiersep> original <identifiersep> classes ( ) val classpath = instrumentation <identifiersep> classpath ! ! ant . with <identifiersep> groovy <identifiersep> builder { <string_literal> ( <string_literal> to <string_literal> , <ect>
private fun instrument <identifiersep> code ( src <identifiersep> dirs : file <identifiersep> collection , instrument <identifiersep> not <identifiersep> null : boolean ) { val headless <identifiersep> old <identifiersep> value = system . set <identifiersep> property ( <string_literal> , <string_literal> ) <comment> <LOG> dep <identifiersep> source <identifiersep> directory <identifiersep> sets . fold ( source <identifiersep> set ! ! . compile <identifiersep> classpath ) { acc , v - > acc + v } . as <identifiersep> path . also { } logger . info ( <string_literal> ) ant . with <identifiersep> groovy <identifiersep> builder { <string_literal> ( <string_literal> to src <identifiersep> dirs . as <identifiersep> path , <string_literal> to output , <string_literal> to instrumentation <identifiersep> classpath , <ect>
val embedded <identifiersep> components = source <identifiersep> path . project . configurations . find <identifiersep> by <identifiersep> name ( embedded <identifiersep> components . configuration <identifiersep> name ) ? . resolved <identifiersep> configuration if ( embedded <identifiersep> components != null ) { for ( (  <identifiersep>  ,  <identifiersep>  , dependency ) in list <identifiersep> of ( embedded <identifiersep> components to scope . compile ) . collect <identifiersep> dependencies ( ) ) { if ( dependency . configuration == <string_literal> ) { archive <identifiersep> for <identifiersep> jar . add ( module <identifiersep> output ( dependency . module <identifiersep> name + <string_literal> ) ) <LOG> } else if ( dependency . configuration == <string_literal> || dependency . configuration == <string_literal> ) { } else { for ( file in dependency . module <identifiersep> artifacts . map { it . file } ) { archive <identifiersep> for <identifiersep> jar . add ( extracted <identifiersep> directory ( file ) ) } } } } } is configuration - > { require ( source <identifiersep> path . name == <string_literal> ) { <string_literal> } <ect>
val annotations : list < file > = empty <identifiersep> list ( ) , val dependencies : list < p <identifiersep> library > = empty <identifiersep> list ( ) ) { fun attach <identifiersep> source ( file : file ) : p <identifiersep> library { return this . copy ( sources = this . sources + list <identifiersep> of ( file ) ) } } fun parse ( project : project , libraries : list < p <identifiersep> library > , context : parser <identifiersep> context ) : p <identifiersep> project = with ( context ) { <LOG> if ( project != project . root <identifiersep> project ) { } val modules = project . allprojects . filter { it . plugins . has <identifiersep> plugin ( jps <identifiersep> compatible <identifiersep> plugin : : class . java ) } . flat <identifiersep> map { parse <identifiersep> modules ( it ) } return p <identifiersep> project ( <string_literal> , project . project <identifiersep> dir , modules , libraries ) } <comment> <ect>
@ override public void configure ( job <identifiersep> conf job <identifiersep> conf ) { try { super . configure ( job <identifiersep> conf ) ; <LOG> hadoop <identifiersep> util . init <identifiersep> log4j ( job <identifiersep> conf ) ; log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; current <identifiersep> process = new hadoop <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , job <identifiersep> conf , false ) ; timed <identifiersep> iterators = timed <identifiersep> iterator . iterators ( new timed <identifiersep> iterator < tuple > ( current <identifiersep> process , slice <identifiersep> counters . read <identifiersep> duration , slice <identifiersep> counters . tuples <identifiersep> read ) ) ; string reduce <identifiersep> node <identifiersep> state = job <identifiersep> conf . get <identifiersep> raw ( <string_literal> ) ; if ( reduce <identifiersep> node <identifiersep> state == null ) <ect>
log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; current <identifiersep> process = new hadoop <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , job <identifiersep> conf , false ) ; timed <identifiersep> iterators = timed <identifiersep> iterator . iterators ( new timed <identifiersep> iterator < tuple > ( current <identifiersep> process , slice <identifiersep> counters . read <identifiersep> duration , slice <identifiersep> counters . tuples <identifiersep> read ) ) ; string reduce <identifiersep> node <identifiersep> state = job <identifiersep> conf . get <identifiersep> raw ( <string_literal> ) ; if ( reduce <identifiersep> node <identifiersep> state == null ) reduce <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; <LOG> flow <identifiersep> node = deserialize <identifiersep> base64 ( reduce <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; stream <identifiersep> graph = new hadoop <identifiersep> reduce <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , util . get <identifiersep> first ( flow <identifiersep> node . get <identifiersep> source <identifiersep> elements ( ) ) ) ; group = ( hadoop <identifiersep> group <identifiersep> gate ) stream <identifiersep> graph . get <identifiersep> heads ( ) . iterator ( ) . next ( ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) <ect>
flow <identifiersep> node = deserialize <identifiersep> base64 ( reduce <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , flow <identifiersep> node . get <identifiersep> ordinal ( ) ) ; stream <identifiersep> graph = new hadoop <identifiersep> reduce <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , util . get <identifiersep> first ( flow <identifiersep> node . get <identifiersep> source <identifiersep> elements ( ) ) ) ; group = ( hadoop <identifiersep> group <identifiersep> gate ) stream <identifiersep> graph . get <identifiersep> heads ( ) . iterator ( ) . next ( ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ; <LOG> for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) log . info ( <string_literal> + trap ) ; log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) { <ect>
public class hadoop <identifiersep> mr <identifiersep> util { private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( hadoop <identifiersep> mr <identifiersep> util . class ) ; public static string write <identifiersep> state <identifiersep> to <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf conf , string id , string kind , string step <identifiersep> state ) { if ( util . is <identifiersep> empty ( step <identifiersep> state ) ) <LOG> return null ; string state <identifiersep> path = hfs . get <identifiersep> temp <identifiersep> path ( conf ) + <string_literal> + kind + <string_literal> + id ; hfs temp = new hfs ( new text <identifiersep> line ( ) , state <identifiersep> path , sink <identifiersep> mode . replace ) ; try { tuple <identifiersep> entry <identifiersep> collector writer = temp . open <identifiersep> for <identifiersep> write ( new hadoop <identifiersep> flow <identifiersep> process ( conf ) ) ; <ect>
{ if ( ! file . to <identifiersep> string ( ) . contains ( kind + <string_literal> + id ) ) continue ; step <identifiersep> state <identifiersep> path = file ; break ; } if ( step <identifiersep> state <identifiersep> path == null ) <LOG> throw new flow <identifiersep> exception ( <string_literal> ) ; hfs temp = new lfs ( new text <identifiersep> line ( new fields ( <string_literal> ) ) , step <identifiersep> state <identifiersep> path . to <identifiersep> string ( ) ) ; tuple <identifiersep> entry <identifiersep> iterator reader = null ; try { reader = temp . open <identifiersep> for <identifiersep> read ( new hadoop <identifiersep> flow <identifiersep> process ( job <identifiersep> conf ) ) ; <ect>
iterator < map . entry < integer , fields > > iterator = resolved <identifiersep> key <identifiersep> fields . entry <identifiersep> set ( ) . iterator ( ) ; fields fields = iterator . next ( ) . get <identifiersep> value ( ) ; while ( iterator . has <identifiersep> next ( ) ) { fields next = iterator . next ( ) . get <identifiersep> value ( ) ; if ( ! arrays . equals ( fields . get <identifiersep> types <identifiersep> classes ( ) , next . get <identifiersep> types <identifiersep> classes ( ) ) ) <LOG> { return false ; } } return true ; } public boolean is <identifiersep> hadoop <identifiersep> local <identifiersep> mode ( job <identifiersep> conf conf ) { return hadoop <identifiersep> util . is <identifiersep> local ( conf ) ; <ect>
{ try { temp <identifiersep> sink . delete <identifiersep> resource ( config ) ; } catch ( exception exception ) { <LOG> <comment> <ect>
default <identifiersep> job <identifiersep> conf . set <identifiersep> jar <identifiersep> by <identifiersep> class ( type ) ; string path = app <identifiersep> props . get <identifiersep> application <identifiersep> jar <identifiersep> path ( properties ) ; if ( default <identifiersep> job <identifiersep> conf . get <identifiersep> jar ( ) == null && path != null ) default <identifiersep> job <identifiersep> conf . set <identifiersep> jar ( path ) ; if ( default <identifiersep> job <identifiersep> conf . get <identifiersep> jar ( ) == null ) default <identifiersep> job <identifiersep> conf . set <identifiersep> jar <identifiersep> by <identifiersep> class ( hadoop <identifiersep> util . find <identifiersep> main <identifiersep> class ( hadoop <identifiersep> planner . class ) ) ; <LOG> app <identifiersep> props . set <identifiersep> application <identifiersep> jar <identifiersep> path ( properties , default <identifiersep> job <identifiersep> conf . get <identifiersep> jar ( ) ) ; } @ override public void config <identifiersep> rule <identifiersep> registry <identifiersep> defaults ( rule <identifiersep> registry rule <identifiersep> registry ) { super . config <identifiersep> rule <identifiersep> registry <identifiersep> defaults ( rule <identifiersep> registry ) ; rule <identifiersep> registry . add <identifiersep> default <identifiersep> element <identifiersep> factory ( intermediate <identifiersep> tap <identifiersep> element <identifiersep> factory . temp <identifiersep> tap , new temp <identifiersep> tap <identifiersep> element <identifiersep> factory ( ) ) ; <ect>
{ } @ override public void configure ( job <identifiersep> conf job <identifiersep> conf ) { try { <LOG> hadoop <identifiersep> util . init <identifiersep> log4j ( job <identifiersep> conf ) ; log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; current <identifiersep> process = new hadoop <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , job <identifiersep> conf , true ) ; string map <identifiersep> node <identifiersep> state = job <identifiersep> conf . get <identifiersep> raw ( <string_literal> ) ; if ( map <identifiersep> node <identifiersep> state == null ) map <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; <ect>
return true ; { log <identifiersep> info ( <string_literal> ) ; for ( tap source : get <identifiersep> sources <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + source ) ; <LOG> for ( tap sink : get <identifiersep> sinks <identifiersep> collection ( ) ) } <comment> <ect>
add <identifiersep> task <identifiersep> stats ( task <identifiersep> reports , false ) ; return true ; } catch ( io <identifiersep> exception exception ) { log <identifiersep> warn ( <string_literal> , exception ) ; } catch ( interrupted <identifiersep> exception exception ) <LOG> { } return false ; } protected void add <identifiersep> task <identifiersep> stats ( task <identifiersep> report [ ] task <identifiersep> reports , boolean skip <identifiersep> last ) { log <identifiersep> info ( <string_literal> , task <identifiersep> reports . length ) ; long last <identifiersep> fetch = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
int added = 0 ; int updated = 0 ; for ( int i = 0 ; i < task <identifiersep> reports . length - ( skip <identifiersep> last ? 1 : 0 ) ; i ++ ) { task <identifiersep> report task <identifiersep> report = task <identifiersep> reports [ i ] ; if ( task <identifiersep> report == null ) <LOG> { continue ; } string id = get <identifiersep> slice <identifiersep> id <identifiersep> for ( task <identifiersep> report . get <identifiersep> task <identifiersep> id ( ) ) ; hadoop <identifiersep> slice <identifiersep> stats slice <identifiersep> stats = ( hadoop <identifiersep> slice <identifiersep> stats ) slice <identifiersep> stats <identifiersep> map . get ( id ) ; if ( slice <identifiersep> stats != null ) { <ect>
protected static job get <identifiersep> job ( running <identifiersep> job running <identifiersep> job ) { if ( running <identifiersep> job == null ) <comment> <LOG> { return null ; } return job ; } protected hadoop <identifiersep> step <identifiersep> stats ( flow <identifiersep> step < job <identifiersep> conf > flow <identifiersep> step , client <identifiersep> state client <identifiersep> state ) { super ( flow <identifiersep> step , client <identifiersep> state ) ; <ect>
log . warn ( <string_literal> , exception ) ; } } private void add <identifiersep> attempts <identifiersep> to <identifiersep> task <identifiersep> stats ( task <identifiersep> completion <identifiersep> event [ ] events ) { for ( task <identifiersep> completion <identifiersep> event event : events ) { if ( event == null ) <LOG> { continue ; } if ( event . is <identifiersep> map <identifiersep> task ( ) ) mapper <identifiersep> node <identifiersep> stats . add <identifiersep> attempt ( event ) ; else reducer <identifiersep> node <identifiersep> stats . add <identifiersep> attempt ( event ) ; <ect>
configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) + <string_literal> + <string_literal> ) ; string staging <identifiersep> dir = configuration . get ( <string_literal> ) ; if ( util . is <identifiersep> empty ( staging <identifiersep> dir ) ) configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) + <string_literal> ) ; file <identifiersep> sys = file <identifiersep> system . get ( configuration ) ; } else <LOG> { if ( util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; if ( util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; new file ( system . get <identifiersep> property ( <string_literal> ) ) . mkdirs ( ) ; <comment> <ect>
if ( get <identifiersep> application <identifiersep> jar ( ) != null ) { log . info ( <string_literal> , get <identifiersep> application <identifiersep> jar ( ) ) ; configuration = conf ; ( ( job <identifiersep> conf ) configuration ) . set <identifiersep> jar ( get <identifiersep> application <identifiersep> jar ( ) ) ; if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) <LOG> { configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; <ect>
configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) <LOG> { configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; <ect>
configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) { log . info ( <string_literal> , <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) <LOG> { configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; } configuration . set ( <string_literal> , <string_literal> ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , 0 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , 0 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , 0 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , 1 ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , <number_literal> ) ; perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , <number_literal> ) ; <LOG> perform <identifiersep> list <identifiersep> test ( <number_literal> , <number_literal> , null , <number_literal> ) ; } @ test public void test <identifiersep> spill <identifiersep> list <identifiersep> compressed ( ) { gzip <identifiersep> codec codec = reflection <identifiersep> utils . new <identifiersep> instance ( gzip <identifiersep> codec . class , new configuration ( ) ) ; long time = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
{ long time = system . current <identifiersep> time <identifiersep> millis ( ) ; configuration job <identifiersep> conf = new configuration ( ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; <LOG> perform <identifiersep> map <identifiersep> test ( <number_literal> , <number_literal> , <number_literal> , <number_literal> , job <identifiersep> conf ) ; } @ test public void test <identifiersep> spill <identifiersep> map <identifiersep> compressed ( ) { long time = system . current <identifiersep> time <identifiersep> millis ( ) ; configuration job <identifiersep> conf = new configuration ( ) ; <ect>
string url = string . format ( format , base <identifiersep> uri , tez <identifiersep> task <identifiersep> id , tez <identifiersep> vertex <identifiersep> id , vertex <identifiersep> id , filter <identifiersep> by <identifiersep> fields , limit ) ; if ( start <identifiersep> task <identifiersep> id != null ) url = string . format ( <string_literal> , url , start <identifiersep> task <identifiersep> id ) ; json <identifiersep> object json <identifiersep> root = get <identifiersep> json <identifiersep> root <identifiersep> entity ( url ) ; final json <identifiersep> array entities <identifiersep> node = json <identifiersep> root . opt <identifiersep> json <identifiersep> array ( ats <identifiersep> constants . entities ) ; if ( entities <identifiersep> node == null ) <LOG> throw new cascading <identifiersep> exception ( <string_literal> ) ; return new iterator < task <identifiersep> status > ( ) { int index = 0 ; @ override public boolean has <identifiersep> next ( ) <ect>
try { return util . invoke <identifiersep> constructor ( timeline <identifiersep> client <identifiersep> class , parameters , types ) ; } catch ( cascading <identifiersep> exception exception ) { throwable cause = exception . get <identifiersep> cause ( ) ; <LOG> if ( cause instanceof reflective <identifiersep> operation <identifiersep> exception && cause . get <identifiersep> cause ( ) instanceof tez <identifiersep> exception ) else if ( cause instanceof reflective <identifiersep> operation <identifiersep> exception && cause . get <identifiersep> cause ( ) instanceof no <identifiersep> such <identifiersep> method <identifiersep> error ) log . warn ( <string_literal> , get <identifiersep> platform <identifiersep> version ( ) , cause . get <identifiersep> cause ( ) ) ; else log . warn ( <string_literal> , exception ) ; } return null ; <ect>
{ throwable cause = exception . get <identifiersep> cause ( ) ; if ( cause instanceof reflective <identifiersep> operation <identifiersep> exception && cause . get <identifiersep> cause ( ) instanceof tez <identifiersep> exception ) log . warn ( <string_literal> , cause . get <identifiersep> cause ( ) ) ; else if ( cause instanceof reflective <identifiersep> operation <identifiersep> exception && cause . get <identifiersep> cause ( ) instanceof no <identifiersep> such <identifiersep> method <identifiersep> error ) log . warn ( <string_literal> , get <identifiersep> platform <identifiersep> version ( ) , cause . get <identifiersep> cause ( ) ) ; <LOG> else } return null ; } public static string get <identifiersep> tracking <identifiersep> url ( tez <identifiersep> client tez <identifiersep> client , dag <identifiersep> client dag <identifiersep> client ) { if ( tez <identifiersep> client == null || dag <identifiersep> client == null ) return null ; <ect>
log . info ( <string_literal> ) ; return null ; } application <identifiersep> report report = framework <identifiersep> client . get <identifiersep> application <identifiersep> report ( application <identifiersep> id ) ; if ( report != null ) return report . get <identifiersep> tracking <identifiersep> url ( ) ; } catch ( yarn <identifiersep> exception | io <identifiersep> exception exception ) <LOG> { log . debug ( <string_literal> , exception ) ; } return null ; } private static framework <identifiersep> client get <identifiersep> framework <identifiersep> client ( dag <identifiersep> client dag <identifiersep> client ) { if ( dag <identifiersep> client instanceof tez <identifiersep> timeline <identifiersep> client ) <ect>
private static void set <identifiersep> fetch <identifiersep> limit ( configuration configuration ) { if ( fetch <identifiersep> limit > - 1 ) return ; fetch <identifiersep> limit = property <identifiersep> util . get <identifiersep> int <identifiersep> property ( hadoop <identifiersep> util . create <identifiersep> properties ( configuration ) , timeline <identifiersep> fetch <identifiersep> limit , default <identifiersep> fetch <identifiersep> limit ) ; if ( fetch <identifiersep> limit < <number_literal> ) <LOG> { fetch <identifiersep> limit = <number_literal> ; } } protected tez <identifiersep> node <identifiersep> stats ( final base <identifiersep> cached <identifiersep> step <identifiersep> stats < configuration , dag <identifiersep> client , tez <identifiersep> counters > parent <identifiersep> step <identifiersep> stats , flow <identifiersep> node flow <identifiersep> node , client <identifiersep> state client <identifiersep> state , configuration configuration ) { super ( flow <identifiersep> node , client <identifiersep> state ) ; set <identifiersep> fetch <identifiersep> limit ( configuration ) ; <ect>
private iterator < task <identifiersep> status > get <identifiersep> task <identifiersep> status <identifiersep> iterator ( timeline <identifiersep> client timeline <identifiersep> client , string start <identifiersep> task <identifiersep> id ) { try { string vertex <identifiersep> id = retrieve <identifiersep> vertex <identifiersep> id ( ( dag <identifiersep> client ) timeline <identifiersep> client ) ; if ( vertex <identifiersep> id == null ) <LOG> { return null ; } return timeline <identifiersep> client . get <identifiersep> vertex <identifiersep> children ( vertex <identifiersep> id , fetch <identifiersep> limit , start <identifiersep> task <identifiersep> id ) ; } catch ( io <identifiersep> exception | cascading <identifiersep> exception | tez <identifiersep> exception exception ) { log <identifiersep> warn ( <string_literal> , exception ) ; <ect>
private boolean without <identifiersep> timeline <identifiersep> server ( dag <identifiersep> client dag <identifiersep> client ) { vertex <identifiersep> status vertex <identifiersep> status = update <identifiersep> progress ( dag <identifiersep> client , status <identifiersep> get <identifiersep> counters ) ; if ( vertex <identifiersep> status == null || get <identifiersep> total <identifiersep> task <identifiersep> count ( ) == 0 ) return false ; int total = slice <identifiersep> stats <identifiersep> map . size ( ) ; <LOG> if ( total == 0 ) <comment> <ect>
{ vertex <identifiersep> status vertex <identifiersep> status = null ; try { vertex <identifiersep> status = dag <identifiersep> client . get <identifiersep> vertex <identifiersep> status ( get <identifiersep> id ( ) , status <identifiersep> get <identifiersep> opts ) ; } catch ( io <identifiersep> exception | tez <identifiersep> exception exception ) <LOG> { } if ( vertex <identifiersep> status == null ) return null ; progress progress = vertex <identifiersep> status . get <identifiersep> progress ( ) ; total <identifiersep> task <identifiersep> count = progress . get <identifiersep> total <identifiersep> task <identifiersep> count ( ) ; running <identifiersep> task <identifiersep> count = progress . get <identifiersep> running <identifiersep> task <identifiersep> count ( ) ; <ect>
for ( int i = 0 ; i < tuple . size ( ) ; i = i + size ) { tuple result = new tuple ( group ) ; result . add <identifiersep> all ( tuple . get ( fields . offset <identifiersep> selector ( size , i ) . get <identifiersep> pos ( ) ) ) ; output <identifiersep> collector . add ( result ) ; } } private void use <identifiersep> result <identifiersep> selectors ( tuple <identifiersep> entry input , tuple <identifiersep> entry <identifiersep> collector output <identifiersep> collector ) <LOG> { for ( fields result <identifiersep> field <identifiersep> selector : result <identifiersep> field <identifiersep> selectors ) { tuple group = input . select <identifiersep> tuple <identifiersep> copy ( group <identifiersep> field <identifiersep> selector ) ; <comment> <ect>
protected boolean match <identifiersep> whole <identifiersep> tuple ( matcher matcher , tuple <identifiersep> entry input ) { iterable < string > iterable = input . as <identifiersep> iterable <identifiersep> of ( string . class ) ; string join = util . join ( iterable , delimiter , false ) ; matcher . reset ( join ) ; <LOG> boolean match <identifiersep> found = matcher . find ( ) ; return match <identifiersep> found == negate <identifiersep> match ; } protected boolean match <identifiersep> each <identifiersep> element ( matcher matcher , tuple <identifiersep> entry input ) { return match <identifiersep> each <identifiersep> element <identifiersep> pos ( matcher , input ) != - 1 ; } protected int match <identifiersep> each <identifiersep> element <identifiersep> pos ( matcher matcher , tuple <identifiersep> entry input ) <ect>
<comment> public static class get <identifiersep> application <identifiersep> jar <identifiersep> class ( map < object , object > properties ) { string class <identifiersep> name = property <identifiersep> util . get <identifiersep> property ( properties , dep <identifiersep> app <identifiersep> jar <identifiersep> class , ( string ) null ) ; if ( class <identifiersep> name != null ) <LOG> { return util . load <identifiersep> class <identifiersep> safe ( class <identifiersep> name ) ; } class <identifiersep> name = property <identifiersep> util . get <identifiersep> property ( properties , app <identifiersep> jar <identifiersep> class , ( string ) null ) ; if ( class <identifiersep> name == null ) return null ; return util . load <identifiersep> class <identifiersep> safe ( class <identifiersep> name ) ; <ect>
{ return get <identifiersep> app <identifiersep> id ( ) ; } private static string get <identifiersep> app <identifiersep> id ( ) { if ( app <identifiersep> id == null ) { <LOG> app <identifiersep> id = util . create <identifiersep> unique <identifiersep> id ( ) ; } return app <identifiersep> id ; } <comment> public static void reset <identifiersep> app <identifiersep> id ( ) { app <identifiersep> id = null ; <ect>
<comment> public t add <identifiersep> tag ( string tag ) { if ( tag == null || tag . is <identifiersep> empty ( ) ) return ( t ) this ; tag = tag . trim ( ) ; <LOG> if ( util . contains <identifiersep> whitespace ( tag ) ) tags . add ( tag ) ; return ( t ) this ; } <comment> <ect>
return false ; string latest <identifiersep> major = latest <identifiersep> properties . get <identifiersep> property ( version . cascading <identifiersep> release <identifiersep> major ) ; string latest <identifiersep> minor = latest <identifiersep> properties . get <identifiersep> property ( version . cascading <identifiersep> release <identifiersep> minor ) ; boolean is <identifiersep> same <identifiersep> major <identifiersep> release = equals ( version . get <identifiersep> release <identifiersep> major ( ) , latest <identifiersep> major ) ; boolean is <identifiersep> same <identifiersep> minor <identifiersep> release = equals ( version . get <identifiersep> release <identifiersep> minor ( ) , latest <identifiersep> minor ) ; if ( is <identifiersep> same <identifiersep> major <identifiersep> release && is <identifiersep> same <identifiersep> minor <identifiersep> release ) <LOG> { return true ; } string version = latest <identifiersep> properties . get <identifiersep> property ( <string_literal> ) ; if ( version == null ) log . debug ( <string_literal> ) ; else <ect>
{ log . debug ( <string_literal> ) ; return true ; } string version = latest <identifiersep> properties . get <identifiersep> property ( <string_literal> ) ; if ( version == null ) log . debug ( <string_literal> ) ; <LOG> else return true ; } private static properties get <identifiersep> update <identifiersep> properties ( url update <identifiersep> url ) { try { <ect>
string connector = url . index <identifiersep> of ( ' ? ' ) > 0 ? <string_literal> : <string_literal> ; string spec = url + connector + build <identifiersep> params <identifiersep> string ( ) ; try { return new url ( spec ) ; } catch ( malformed <identifiersep> url <identifiersep> exception exception ) <LOG> { return null ; } } private static string build <identifiersep> url ( ) { string base <identifiersep> url = system . get <identifiersep> property ( update <identifiersep> url , <string_literal> ) ; if ( base <identifiersep> url . is <identifiersep> empty ( ) ) <ect>
return old <identifiersep> level . to <identifiersep> string ( ) ; } public static void log <identifiersep> memory ( logger logger , string message ) { runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; <LOG> long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; } public static void log <identifiersep> counters ( logger logger , string message , flow <identifiersep> process flow <identifiersep> process ) { string counters = flow <identifiersep> process . get <identifiersep> string <identifiersep> property ( flow <identifiersep> runtime <identifiersep> props . log <identifiersep> counters ) ; if ( counters == null ) return ; <ect>
{ print <identifiersep> graph ( writer , graph ) ; } finally { writer . close ( ) ; } } catch ( io <identifiersep> exception exception ) <LOG> { } } @ suppress <identifiersep> warnings ( { <string_literal> } ) private static void print <identifiersep> graph ( writer writer , graph graph ) { dot <identifiersep> exporter dot = new dot <identifiersep> exporter ( new integer <identifiersep> name <identifiersep> provider ( ) , object - > { <ect>
log . debug ( <string_literal> , command <identifiersep> line ) ; process process = runtime . get <identifiersep> runtime ( ) . exec ( command <identifiersep> line , null , parent <identifiersep> file ) ; int result = process . wait <identifiersep> for ( ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( process . get <identifiersep> input <identifiersep> stream ( ) ) ) ; string line = reader . read <identifiersep> line ( ) ; while ( line != null ) <LOG> { line = reader . read <identifiersep> line ( ) ; } reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( process . get <identifiersep> error <identifiersep> stream ( ) ) ) ; line = reader . read <identifiersep> line ( ) ; while ( line != null ) { <ect>
while ( line != null ) { log . warn ( <string_literal> , command [ 0 ] , line ) ; line = reader . read <identifiersep> line ( ) ; } return result ; } catch ( io <identifiersep> exception exception ) <LOG> { } catch ( interrupted <identifiersep> exception exception ) { log . warn ( <string_literal> + command [ 0 ] , exception ) ; } return integer . min <identifiersep> value ; } public static string format <identifiersep> duration <identifiersep> from <identifiersep> millis ( long duration ) <ect>
try { class < ? extends exception > exception <identifiersep> class = context <identifiersep> class <identifiersep> loader . load <identifiersep> class ( class <identifiersep> name ) . as <identifiersep> subclass ( exception . class ) ; exception <identifiersep> classes . add ( exception <identifiersep> class ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { <LOG> if ( ! util . is <identifiersep> empty ( warning <identifiersep> message ) ) } } return exception <identifiersep> classes ; } public static boolean submit <identifiersep> with <identifiersep> timeout ( callable < boolean > task , int timeout , time <identifiersep> unit time <identifiersep> unit ) throws exception { executor <identifiersep> service executor = executors . new <identifiersep> fixed <identifiersep> thread <identifiersep> pool ( 1 ) ; future < boolean > future = executor . submit ( task ) ; <ect>
catch ( exception exception ) { if ( operator . rethrow ( exception ) ) { logger . warn ( message + <string_literal> , exception ) ; throw exception ; } <LOG> saved = exception ; try { thread . sleep ( seconds <identifiersep> delay * <number_literal> ) ; } catch ( interrupted <identifiersep> exception exception1 ) { <ect>
if ( version <identifiersep> properties == null ) { version <identifiersep> properties = load <identifiersep> version <identifiersep> properties ( ) ; if ( version <identifiersep> properties . is <identifiersep> empty ( ) ) log . warn ( <string_literal> ) ; } } catch ( io <identifiersep> exception exception ) <LOG> { version <identifiersep> properties = new properties ( ) ; } return version <identifiersep> properties ; } public static synchronized void print <identifiersep> banner ( ) { <comment> <ect>
hook = queue . poll ( ) ; <comment> <LOG> { log . debug ( <string_literal> , exception ) ; } } } finally { system . set <identifiersep> property ( shutdown <identifiersep> executing , <string_literal> ) ; } } } ; <ect>
callback . evict ( eldest ) ; if ( flushes % get <identifiersep> capacity ( ) == 0 ) <comment> <LOG> long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) log . info ( <string_literal> , ( int ) ( percent * <number_literal> . 0f ) ) ; } flushes ++ ; <ect>
long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> , flushes + 1 , capacity ) ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; <LOG> if ( percent < 0 . 80f ) } flushes ++ ; } return do <identifiersep> remove ; } } ; } @ override public int size ( ) <ect>
if ( put <identifiersep> calls % get <identifiersep> capacity ( ) == 0 ) { runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; <LOG> log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; ( ( double ) get <identifiersep> capacity ( ) / actual <identifiersep> size ) * <number_literal> ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) log . info ( <string_literal> , ( int ) ( percent * <number_literal> . 0f ) ) ; } return previous ; <ect>
callback . evict ( eldest ) ; if ( flushes % get <identifiersep> capacity ( ) == 0 ) <comment> <LOG> long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; if ( percent < 0 . 80f ) log . info ( <string_literal> , ( int ) ( percent * <number_literal> . 0f ) ) ; } flushes ++ ; <ect>
long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; log . info ( <string_literal> , flushes + 1 , capacity ) ; log . info ( <string_literal> + free <identifiersep> mem + <string_literal> + total <identifiersep> mem + <string_literal> + max <identifiersep> mem ) ; float percent = ( float ) total <identifiersep> mem / ( float ) max <identifiersep> mem ; <LOG> if ( percent < 0 . 80f ) } flushes ++ ; } return do <identifiersep> remove ; } } ; } @ override public int size ( ) <ect>
{ string property = default <identifiersep> properties . get <identifiersep> property ( cascading <identifiersep> services <identifiersep> jar ) ; if ( property == null ) return null ; string disable <identifiersep> jar = default <identifiersep> properties . get <identifiersep> property ( cascading <identifiersep> services <identifiersep> jar <identifiersep> disable , system . get <identifiersep> property ( cascading <identifiersep> services <identifiersep> jar <identifiersep> disable , <string_literal> ) ) ; if ( boolean . value <identifiersep> of ( disable <identifiersep> jar ) ) <LOG> { return null ; } try { uri uri = uri . create ( property ) ; if ( ! uri . is <identifiersep> absolute ( ) ) <ect>
input <identifiersep> stream input = class <identifiersep> loader . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( resource ) ; try { if ( input != null ) { url url = parse <identifiersep> library <identifiersep> url ( class <identifiersep> loader , resource ) ; <LOG> if ( url != null ) else log . info ( <string_literal> , resource ) ; properties . load ( input ) ; } } catch ( io <identifiersep> exception exception ) { <ect>
if ( url != null ) log . info ( <string_literal> , resource , url ) ; else log . info ( <string_literal> , resource ) ; properties . load ( input ) ; } } catch ( io <identifiersep> exception exception ) <LOG> { } return properties ; } private synchronized service <identifiersep> loader get <identifiersep> service <identifiersep> util ( ) { return service <identifiersep> loader . get <identifiersep> instance ( enable <identifiersep> container ? library <identifiersep> url : null , exclusions ) ; } public cascading <identifiersep> services ( map < object , object > properties ) <ect>
else { try { uri = uri . create ( encode ( value . to <identifiersep> string ( ) ) ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception exception ) <LOG> { log . debug ( <string_literal> , value , exception ) ; if ( boolean . parse <identifiersep> boolean ( system . get <identifiersep> property ( failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ) ) { log . warn ( <string_literal> , failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ; return value . to <identifiersep> string ( ) ; <ect>
uri = uri . create ( encode ( value . to <identifiersep> string ( ) ) ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception exception ) { log . warn ( <string_literal> , value , exception . get <identifiersep> message ( ) ) ; log . debug ( <string_literal> , value , exception ) ; if ( boolean . parse <identifiersep> boolean ( system . get <identifiersep> property ( failure <identifiersep> mode <identifiersep> pass <identifiersep> through ) ) ) <LOG> { return value . to <identifiersep> string ( ) ; } <comment> <ect>
{ try { service . start <identifiersep> service ( ) ; return true ; } catch ( throwable throwable ) <LOG> { log . debug ( <string_literal> , throwable ) ; return false ; } } public void stop <identifiersep> service ( ) { <comment> <ect>
source <identifiersep> modified = util . get <identifiersep> source <identifiersep> modified ( config , values , sink <identifiersep> modified ) ; if ( sink <identifiersep> modified < source <identifiersep> modified ) return true ; return false ; } finally <LOG> { } } @ override public long get <identifiersep> sink <identifiersep> modified ( ) throws io <identifiersep> exception { long sink <identifiersep> modified = util . get <identifiersep> sink <identifiersep> modified ( get <identifiersep> config ( ) , sinks . values ( ) ) ; <ect>
{ long sink <identifiersep> modified = util . get <identifiersep> sink <identifiersep> modified ( get <identifiersep> config ( ) , sinks . values ( ) ) ; { if ( sink <identifiersep> modified == - 1l ) log <identifiersep> info ( <string_literal> ) ; <LOG> if ( sink <identifiersep> modified == 0l ) else log <identifiersep> info ( <string_literal> + new date ( sink <identifiersep> modified ) ) ; } return sink <identifiersep> modified ; } @ override public flow <identifiersep> step <identifiersep> strategy get <identifiersep> flow <identifiersep> step <identifiersep> strategy ( ) <ect>
{ <comment> <LOG> if ( ! tap . commit <identifiersep> resource ( get <identifiersep> config ( ) ) ) } catch ( io <identifiersep> exception exception ) { log <identifiersep> error ( <string_literal> + tap . get <identifiersep> full <identifiersep> identifier ( get <identifiersep> config ( ) ) , exception ) ; } } } @ override @ process <identifiersep> cleanup <ect>
{ if ( stop ) return ; flow <identifiersep> stats . mark <identifiersep> started ( ) ; fire <identifiersep> on <identifiersep> starting ( ) ; <LOG> { for ( tap source : get <identifiersep> sources <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + source ) ; for ( tap sink : get <identifiersep> sinks <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + sink ) ; } spawn <identifiersep> steps ( ) ; <ect>
return - 1 ; } protected abstract int get <identifiersep> max <identifiersep> num <identifiersep> parallel <identifiersep> steps ( ) ; protected abstract void internal <identifiersep> shutdown ( ) ; private list < future < throwable > > spawn <identifiersep> jobs ( int num <identifiersep> threads ) throws interrupted <identifiersep> exception { if ( spawn <identifiersep> strategy == null ) <LOG> { return new array <identifiersep> list < > ( ) ; } if ( stop ) return new array <identifiersep> list < > ( ) ; list < callable < throwable > > list = get <identifiersep> job <identifiersep> map <identifiersep> callables ( ) ; return spawn <identifiersep> strategy . start ( this , num <identifiersep> threads , list ) ; <ect>
return ; list < flow <identifiersep> step <identifiersep> job < config > > jobs = new array <identifiersep> list < flow <identifiersep> step <identifiersep> job < config > > ( jobs <identifiersep> map . values ( ) ) ; collections . reverse ( jobs ) ; for ( flow <identifiersep> step <identifiersep> job < config > job : jobs ) job . stop ( ) ; } finally <LOG> { } } protected void handle <identifiersep> executor <identifiersep> shutdown ( ) { if ( spawn <identifiersep> strategy == null ) return ; if ( spawn <identifiersep> strategy . is <identifiersep> completed ( this ) ) <ect>
log <identifiersep> debug ( <string_literal> ) ; try { spawn <identifiersep> strategy . complete ( this , <number_literal> * <number_literal> , time <identifiersep> unit . seconds ) ; } catch ( interrupted <identifiersep> exception exception ) { <LOG> <comment> <ect>
this . throwable = throwable ; fire <identifiersep> on <identifiersep> throwable ( ) ; } protected void fire <identifiersep> on <identifiersep> throwable ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { boolean is <identifiersep> handled = false ; for ( flow <identifiersep> listener flow <identifiersep> listener : get <identifiersep> listeners ( ) ) is <identifiersep> handled = flow <identifiersep> listener . on <identifiersep> throwable ( this , throwable ) || is <identifiersep> handled ; if ( is <identifiersep> handled ) throwable = null ; <ect>
for ( flow <identifiersep> listener flow <identifiersep> listener : get <identifiersep> listeners ( ) ) flow <identifiersep> listener . on <identifiersep> stopping ( this ) ; } } protected void fire <identifiersep> on <identifiersep> starting ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { for ( flow <identifiersep> listener flow <identifiersep> listener : get <identifiersep> listeners ( ) ) flow <identifiersep> listener . on <identifiersep> starting ( this ) ; } } @ override public string to <identifiersep> string ( ) { <ect>
@ override public void log <identifiersep> info ( string message , object . . . arguments ) { log . info ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> debug ( string message , object . . . arguments ) <LOG> { } @ override public void log <identifiersep> warn ( string message ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message ) ; } @ override <ect>
@ override public void log <identifiersep> warn ( string message ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message ) ; } @ override public void log <identifiersep> warn ( string message , throwable throwable ) <LOG> { } @ override public void log <identifiersep> warn ( string message , object . . . arguments ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override <ect>
@ override public void log <identifiersep> warn ( string message , object . . . arguments ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> error ( string message , object . . . arguments ) <LOG> { } @ override public void log <identifiersep> error ( string message , throwable throwable ) { log . error ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , log <identifiersep> flow <identifiersep> name <identifiersep> max ) + <string_literal> + message , throwable ) ; } @ override <ect>
@ override public priority priority ( ) { return priority . work <identifiersep> child ; } @ override public void execute ( ) <LOG> { base <identifiersep> flow . this . stop ( ) ; } } ; shutdown <identifiersep> util . add <identifiersep> hook ( shutdown <identifiersep> hook ) ; } private void deregister <identifiersep> shutdown <identifiersep> hook ( ) { <ect>
try { duct <identifiersep> graph . add <identifiersep> vertex ( lhs ) ; duct <identifiersep> graph . add <identifiersep> vertex ( rhs ) ; duct <identifiersep> graph . add <identifiersep> edge ( lhs , rhs , duct <identifiersep> graph . make <identifiersep> ordinal ( ordinal ) ) ; } catch ( runtime <identifiersep> exception exception ) <LOG> { print <identifiersep> graph <identifiersep> error ( ) ; throw exception ; } } public void bind ( ) { iterator < duct > iterator = get <identifiersep> topological <identifiersep> order <identifiersep> iterator ( ) ; <ect>
public topological <identifiersep> order <identifiersep> iterator < duct , integer > get <identifiersep> reversed <identifiersep> topological <identifiersep> order <identifiersep> iterator ( ) { try { return new topological <identifiersep> order <identifiersep> iterator ( get <identifiersep> reversed <identifiersep> graph ( ) ) ; } catch ( runtime <identifiersep> exception exception ) <LOG> { print <identifiersep> graph <identifiersep> error ( ) ; throw exception ; } } public directed <identifiersep> graph get <identifiersep> reversed <identifiersep> graph ( ) { duct <identifiersep> graph reversed <identifiersep> graph = new duct <identifiersep> graph ( ) ; <ect>
if ( path == null ) return ; classifier = util . cleanse <identifiersep> path <identifiersep> name ( classifier ) ; path = string . format ( <string_literal> , path , id , classifier , discriminator ) ; print <identifiersep> bound <identifiersep> graph ( path ) ; } public void print <identifiersep> bound <identifiersep> graph ( string filename ) <LOG> { directed <identifiersep> multigraph < duct , integer > graph = new directed <identifiersep> multigraph < > ( new edge <identifiersep> factory < duct , integer > ( ) { int count = 0 ; @ override public integer create <identifiersep> edge ( duct source <identifiersep> vertex , duct target <identifiersep> vertex ) <ect>
try { if ( iterator != null ) iterator . close ( ) ; } catch ( throwable current <identifiersep> throwable ) { <LOG> if ( ! ( current <identifiersep> throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) local <identifiersep> throwable = current <identifiersep> throwable ; } } return local <identifiersep> throwable ; } @ override public void initialize ( ) { <ect>
if ( sort <identifiersep> fields != null ) { sort <identifiersep> fields [ ordinal ] = outgoing <identifiersep> scope . get <identifiersep> sorting <identifiersep> selectors ( ) . get ( incoming <identifiersep> scope . get <identifiersep> name ( ) ) ; sort <identifiersep> builder [ ordinal ] = create <identifiersep> narrow <identifiersep> builder ( incoming <identifiersep> scope . get <identifiersep> incoming <identifiersep> splice <identifiersep> fields ( ) , sort <identifiersep> fields [ ordinal ] ) ; } { <LOG> log . debug ( <string_literal> , incoming <identifiersep> scope . get <identifiersep> name ( ) , ordinal ) ; log . debug ( <string_literal> , print <identifiersep> safe ( values <identifiersep> fields [ ordinal ] ) ) ; if ( sort <identifiersep> fields != null ) log . debug ( <string_literal> , print <identifiersep> safe ( sort <identifiersep> fields [ ordinal ] ) ) ; } } if ( role == io <identifiersep> role . sink ) { <ect>
sort <identifiersep> builder [ ordinal ] = create <identifiersep> narrow <identifiersep> builder ( incoming <identifiersep> scope . get <identifiersep> incoming <identifiersep> splice <identifiersep> fields ( ) , sort <identifiersep> fields [ ordinal ] ) ; } { log . debug ( <string_literal> , incoming <identifiersep> scope . get <identifiersep> name ( ) , ordinal ) ; log . debug ( <string_literal> , print <identifiersep> safe ( key <identifiersep> fields [ ordinal ] ) ) ; log . debug ( <string_literal> , print <identifiersep> safe ( values <identifiersep> fields [ ordinal ] ) ) ; <LOG> if ( sort <identifiersep> fields != null ) } } if ( role == io <identifiersep> role . sink ) { if ( sort <identifiersep> fields == null ) group <identifiersep> tuple = new key <identifiersep> tuple ( ) ; else <ect>
public void prepare ( ) { super . prepare ( ) ; streamed <identifiersep> collection = new array <identifiersep> list < tuple > ( arrays . as <identifiersep> list ( new tuple ( ) ) ) ; <comment> <LOG> if ( nulls <identifiersep> are <identifiersep> not <identifiersep> equal ) } @ override public void receive ( duct previous , int ordinal , tuple <identifiersep> entry incoming <identifiersep> entry ) { tuple incoming <identifiersep> tuple = ordinal != 0 ? incoming <identifiersep> entry . get <identifiersep> tuple <identifiersep> copy ( ) : incoming <identifiersep> entry . get <identifiersep> tuple ( ) ; tuple key <identifiersep> tuple = key <identifiersep> builder [ ordinal ] . make <identifiersep> result ( incoming <identifiersep> tuple , null ) ; <comment> <ect>
{ trap <identifiersep> collector . add ( payload ) ; } catch ( throwable current ) { throw new trap <identifiersep> exception ( <string_literal> + trap . get <identifiersep> identifier ( ) , current ) ; } flow <identifiersep> process . increment ( step <identifiersep> counters . tuples <identifiersep> trapped , 1 ) ; <LOG> if ( log <identifiersep> throwable <identifiersep> stack <identifiersep> trace ) } private tuple <identifiersep> entry get <identifiersep> diagnostics ( throwable throwable ) { if ( ! record <identifiersep> any <identifiersep> diagnostics ) return tuple <identifiersep> entry . null ; tuple diagnostics = new tuple ( ) ; <ect>
graphs . add <identifiersep> all <identifiersep> edges ( copy , full , edges ) ; return copy ; } private static < v , e > boolean is <identifiersep> between ( floyd <identifiersep> warshall <identifiersep> shortest <identifiersep> paths < v , e > paths , v edge <identifiersep> source , v edge <identifiersep> target , v vertex ) { return paths . get <identifiersep> first <identifiersep> hop ( edge <identifiersep> source , vertex ) != null && paths . get <identifiersep> first <identifiersep> hop ( vertex , edge <identifiersep> target ) != null ; } public static void remove <identifiersep> and <identifiersep> contract ( element <identifiersep> graph element <identifiersep> graph , flow <identifiersep> element flow <identifiersep> element ) <LOG> { set < scope > incoming <identifiersep> scopes = element <identifiersep> graph . incoming <identifiersep> edges <identifiersep> of ( flow <identifiersep> element ) ; boolean contract <identifiersep> incoming = true ; if ( ! contract <identifiersep> incoming ) { if ( incoming <identifiersep> scopes . size ( ) != 1 ) <ect>
new process <identifiersep> graph <identifiersep> name <identifiersep> provider ( ) , new process <identifiersep> graph <identifiersep> label <identifiersep> provider ( ) ) ; graph <identifiersep> writer . write <identifiersep> graph ( writer , graph , process <identifiersep> graph ) ; writer . close ( ) ; return true ; } catch ( io <identifiersep> exception exception ) <LOG> { } return false ; } public static void insert <identifiersep> flow <identifiersep> element <identifiersep> after ( element <identifiersep> graph element <identifiersep> graph , flow <identifiersep> element previous <identifiersep> element , flow <identifiersep> element flow <identifiersep> element ) { set < scope > outgoing = new hash <identifiersep> set < > ( element <identifiersep> graph . outgoing <identifiersep> edges <identifiersep> of ( previous <identifiersep> element ) ) ; element <identifiersep> graph . add <identifiersep> vertex ( flow <identifiersep> element ) ; <ect>
object specifics = util . return <identifiersep> instance <identifiersep> field <identifiersep> if <identifiersep> exists <identifiersep> safe ( graph , <string_literal> ) ; if ( specifics == null ) { log . warn ( <string_literal> ) ; return ; } boolean success = util . set <identifiersep> instance <identifiersep> field <identifiersep> if <identifiersep> exists <identifiersep> safe ( specifics , <string_literal> , new identity <identifiersep> hash <identifiersep> map < > ( ) ) ; <LOG> if ( ! success ) } } <ect>
flow <identifiersep> step <identifiersep> stats . mark <identifiersep> running ( ) ; mark <identifiersep> flow <identifiersep> running ( ) ; } private synchronized void mark <identifiersep> flow <identifiersep> running ( ) { flow flow = flow <identifiersep> step . get <identifiersep> flow ( ) ; if ( flow == null ) <LOG> { return ; } flow <identifiersep> stats flow <identifiersep> stats = flow . get <identifiersep> flow <identifiersep> stats ( ) ; synchronized ( flow <identifiersep> stats ) { if ( flow <identifiersep> stats . is <identifiersep> started ( ) || flow <identifiersep> stats . is <identifiersep> submitted ( ) ) <ect>
if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; if ( flow <identifiersep> element <identifiersep> graph == null ) { process <identifiersep> logger . log <identifiersep> info ( <string_literal> ) ; return ; } <LOG> path file = get <identifiersep> full <identifiersep> transform <identifiersep> trace <identifiersep> path ( registry <identifiersep> name ) . resolve ( name ) . normalize ( ) ; flow <identifiersep> element <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , list < ? extends element <identifiersep> graph > flow <identifiersep> element <identifiersep> graphs , plan <identifiersep> phase phase , string sub <identifiersep> name ) { if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; <ect>
process <identifiersep> logger . log <identifiersep> info ( <string_literal> ) ; return ; } for ( int i = 0 ; i < flow <identifiersep> element <identifiersep> graphs . size ( ) ; i ++ ) { element <identifiersep> graph flow <identifiersep> element <identifiersep> graph = flow <identifiersep> element <identifiersep> graphs . get ( i ) ; string name = string . format ( <string_literal> , phase . ordinal ( ) , phase , sub <identifiersep> name , i ) ; <LOG> path file = get <identifiersep> full <identifiersep> transform <identifiersep> trace <identifiersep> path ( registry <identifiersep> name ) . resolve ( name ) . normalize ( ) ; flow <identifiersep> element <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } } public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , map < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > parent <identifiersep> graphs <identifiersep> map , map < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > sub <identifiersep> graphs <identifiersep> map , plan <identifiersep> phase phase , string sub <identifiersep> name ) { if ( is <identifiersep> transform <identifiersep> trace <identifiersep> disabled ( ) ) return ; <ect>
if ( pipeline <identifiersep> graphs == null ) continue ; for ( int i = 0 ; i < pipeline <identifiersep> graphs . size ( ) ; i ++ ) { element <identifiersep> graph flow <identifiersep> element <identifiersep> graph = pipeline <identifiersep> graphs . get ( i ) ; string name = string . format ( <string_literal> , phase . ordinal ( ) , phase , sub <identifiersep> name , step <identifiersep> count , node <identifiersep> count , i ) ; <LOG> path file = get <identifiersep> full <identifiersep> transform <identifiersep> trace <identifiersep> path ( registry <identifiersep> name ) . resolve ( name ) ; flow <identifiersep> element <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } node <identifiersep> count ++ ; } step <identifiersep> count ++ ; } } public void write <identifiersep> transform <identifiersep> plan ( string registry <identifiersep> name , map < element <identifiersep> graph , list < ? extends element <identifiersep> graph > > sub <identifiersep> graphs <identifiersep> map , plan <identifiersep> phase phase , string sub <identifiersep> name ) { <ect>
{ list < ? extends element <identifiersep> graph > flow <identifiersep> element <identifiersep> graphs = entry . get <identifiersep> value ( ) ; for ( int i = 0 ; i < flow <identifiersep> element <identifiersep> graphs . size ( ) ; i ++ ) { element <identifiersep> graph flow <identifiersep> element <identifiersep> graph = flow <identifiersep> element <identifiersep> graphs . get ( i ) ; string name = string . format ( <string_literal> , phase . ordinal ( ) , phase , sub <identifiersep> name , step <identifiersep> count , i ) ; <LOG> path file = get <identifiersep> full <identifiersep> transform <identifiersep> trace <identifiersep> path ( registry <identifiersep> name ) . resolve ( name ) ; flow <identifiersep> element <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } step <identifiersep> count ++ ; } } protected path get <identifiersep> plan <identifiersep> trace <identifiersep> path ( ) { return apply <identifiersep> scope ( get <identifiersep> string <identifiersep> property ( system . get <identifiersep> properties ( ) , properties , flow <identifiersep> planner . trace <identifiersep> plan <identifiersep> path ) ) ; <ect>
{ process <identifiersep> logger . log <identifiersep> info ( <string_literal> ) ; return ; } if ( registry <identifiersep> name != null ) path = path . resolve ( registry <identifiersep> name ) ; path file <identifiersep> path = path . resolve ( string . format ( <string_literal> , file <identifiersep> name , canonical <identifiersep> hash ( element <identifiersep> graph ) ) ) ; <LOG> file file = file <identifiersep> path . to <identifiersep> file ( ) ; string filename = file . to <identifiersep> string ( ) ; element <identifiersep> graph . write <identifiersep> dot ( filename ) ; } public void write <identifiersep> trace <identifiersep> plan ( string registry <identifiersep> name , string file <identifiersep> name , flow <identifiersep> step <identifiersep> graph step <identifiersep> graph ) { path path = get <identifiersep> plan <identifiersep> trace <identifiersep> path ( ) ; <ect>
{ process <identifiersep> logger . log <identifiersep> info ( <string_literal> ) ; return ; } if ( registry <identifiersep> name != null ) path = path . resolve ( registry <identifiersep> name ) ; path file <identifiersep> path = path . resolve ( string . format ( <string_literal> , file <identifiersep> name ) ) ; <LOG> file file = file <identifiersep> path . to <identifiersep> file ( ) ; step <identifiersep> graph . write <identifiersep> dot ( file . to <identifiersep> string ( ) ) ; } public void write <identifiersep> trace <identifiersep> plan <identifiersep> steps ( string directory <identifiersep> name , flow <identifiersep> step <identifiersep> graph step <identifiersep> graph ) { if ( step <identifiersep> graph == null ) { <ect>
public void write <identifiersep> final ( string file <identifiersep> name , rule <identifiersep> result rule <identifiersep> result ) { path path = get <identifiersep> plan <identifiersep> trace <identifiersep> path ( ) ; if ( path == null ) return ; path file <identifiersep> path = path . resolve ( string . format ( <string_literal> , file <identifiersep> name , rule <identifiersep> result . get <identifiersep> registry ( ) . get <identifiersep> name ( ) ) ) ; <LOG> file file = file <identifiersep> path . to <identifiersep> file ( ) ; try ( print <identifiersep> writer writer = new print <identifiersep> writer ( file ) ) { writer . println ( <string_literal> ) ; } catch ( io <identifiersep> exception exception ) { <ect>
process <identifiersep> logger . log <identifiersep> error ( <string_literal> , exception ) ; } } public void write <identifiersep> stats ( planner <identifiersep> context planner <identifiersep> context , rule <identifiersep> result rule <identifiersep> result ) { path path = get <identifiersep> plan <identifiersep> stats <identifiersep> path ( ) ; if ( path == null ) return ; <LOG> file file = path . resolve ( string . format ( <string_literal> , rule <identifiersep> result . get <identifiersep> registry ( ) . get <identifiersep> name ( ) , rule <identifiersep> result . get <identifiersep> result <identifiersep> status ( ) ) ) . to <identifiersep> file ( ) ; file . get <identifiersep> parent <identifiersep> file ( ) . mkdirs ( ) ; try ( print <identifiersep> writer writer = new print <identifiersep> writer ( file ) ) { flow flow = planner <identifiersep> context . get <identifiersep> flow ( ) ; map < object , object > config <identifiersep> as <identifiersep> properties = flow . get <identifiersep> config <identifiersep> as <identifiersep> properties ( ) ; <ect>
public rule <identifiersep> result exec ( planner <identifiersep> context planner <identifiersep> context , flow <identifiersep> element <identifiersep> graph flow <identifiersep> element <identifiersep> graph ) { rule <identifiersep> result rule <identifiersep> result = new rule <identifiersep> result ( registry , flow <identifiersep> element <identifiersep> graph ) ; process <identifiersep> logger logger = planner <identifiersep> context . get <identifiersep> logger ( ) ; int size = flow <identifiersep> element <identifiersep> graph . vertex <identifiersep> set ( ) . size ( ) ; boolean log <identifiersep> as <identifiersep> info = size >= element <identifiersep> threshold ; <LOG> if ( log <identifiersep> as <identifiersep> info ) long begin <identifiersep> exec = system . current <identifiersep> time <identifiersep> millis ( ) ; try { plan <identifiersep> phases ( planner <identifiersep> context , log <identifiersep> as <identifiersep> info , rule <identifiersep> result ) ; } catch ( exception exception ) <ect>
linked <identifiersep> list < rule > rules = registry . get <identifiersep> rules <identifiersep> for ( phase ) ; write <identifiersep> phase <identifiersep> init <identifiersep> plan ( phase , rule <identifiersep> result ) ; try { <comment> <LOG> { long begin = system . current <identifiersep> time <identifiersep> millis ( ) ; try { switch ( phase . get <identifiersep> mode ( ) ) { <ect>
break ; } } catch ( unsupported <identifiersep> plan <identifiersep> exception exception ) { logger . log <identifiersep> debug ( <string_literal> , rule , exception . get <identifiersep> message ( ) ) ; throw new unsupported <identifiersep> plan <identifiersep> exception ( rule , exception ) ; } catch ( planner <identifiersep> exception exception ) <LOG> { throw exception ; <comment> <ect>
{ logger . log <identifiersep> debug ( <string_literal> , rule , exception . get <identifiersep> message ( ) ) ; throw new planner <identifiersep> exception ( registry , phase , rule , exception ) ; } finally { long end = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> rule <identifiersep> result . set <identifiersep> rule <identifiersep> duration ( rule , begin , end ) ; } } return rule <identifiersep> result ; } finally { logger . log <identifiersep> debug ( <string_literal> , phase ) ; write <identifiersep> phase <identifiersep> result <identifiersep> plan ( phase , rule <identifiersep> result ) ; <ect>
if ( flow <identifiersep> elements . size ( ) == 0 ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + source . to <identifiersep> string ( ) ) ; if ( ! ( source instanceof scoped <identifiersep> element ) ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + source . to <identifiersep> string ( ) ) ; scope outgoing <identifiersep> scope = ( ( scoped <identifiersep> element ) source ) . outgoing <identifiersep> scope <identifiersep> for ( incoming <identifiersep> scopes ) ; <LOG> { if ( outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) != null ) <ect>
{ long sink <identifiersep> modified = util . get <identifiersep> sink <identifiersep> modified ( get <identifiersep> config ( ) , sinks . key <identifiersep> set ( ) ) ; { if ( sink <identifiersep> modified == - 1l ) log <identifiersep> info ( <string_literal> ) ; <LOG> if ( sink <identifiersep> modified == 0l ) else log <identifiersep> info ( <string_literal> + new date ( sink <identifiersep> modified ) ) ; } return sink <identifiersep> modified ; } protected throwable prepare <identifiersep> resources ( ) { <ect>
{ return get <identifiersep> listeners ( ) . remove ( new safe <identifiersep> flow <identifiersep> step <identifiersep> listener ( flow <identifiersep> step <identifiersep> listener ) ) ; } protected void fire <identifiersep> on <identifiersep> completed ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> completed ( this ) ; } } protected void fire <identifiersep> on <identifiersep> throwable ( throwable throwable ) { <ect>
for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> throwable ( this , throwable ) ; } } protected void fire <identifiersep> on <identifiersep> stopping ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> stopping ( this ) ; } } protected void fire <identifiersep> on <identifiersep> starting ( ) { <ect>
for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> starting ( this ) ; } } protected void fire <identifiersep> on <identifiersep> running ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { for ( object flow <identifiersep> step <identifiersep> listener : get <identifiersep> listeners ( ) ) ( ( flow <identifiersep> step <identifiersep> listener ) flow <identifiersep> step <identifiersep> listener ) . on <identifiersep> step <identifiersep> running ( this ) ; } } protected client <identifiersep> state create <identifiersep> client <identifiersep> state ( flow <identifiersep> process flow <identifiersep> process ) { cascading <identifiersep> services services = flow <identifiersep> process . get <identifiersep> current <identifiersep> session ( ) . get <identifiersep> cascading <identifiersep> services ( ) ; <ect>
{ for ( pipe head : pipe . get <identifiersep> heads ( ) ) { string head <identifiersep> name = head . get <identifiersep> name ( ) ; if ( ! tap <identifiersep> names . contains ( head <identifiersep> name ) ) throw new planner <identifiersep> exception ( head , <string_literal> + head <identifiersep> name + <string_literal> ) ; <LOG> if ( head <identifiersep> names . contains ( head <identifiersep> name ) && ! heads . contains ( head ) ) head <identifiersep> names . add ( head <identifiersep> name ) ; heads . add ( head ) ; } } set < string > all <identifiersep> head <identifiersep> names = new hash <identifiersep> set < string > ( head <identifiersep> names ) ; head <identifiersep> names . remove <identifiersep> all ( flow <identifiersep> def . get <identifiersep> sources ( ) . key <identifiersep> set ( ) ) ; set < string > remaining <identifiersep> sources = new hash <identifiersep> set < string > ( flow <identifiersep> def . get <identifiersep> sources ( ) . key <identifiersep> set ( ) ) ; <ect>
private tap decorate <identifiersep> tap ( pipe pipe , tap temp <identifiersep> tap , string decorator <identifiersep> class <identifiersep> prop , string default <identifiersep> decorator <identifiersep> class <identifiersep> name ) { string decorator <identifiersep> class <identifiersep> name = property <identifiersep> util . get <identifiersep> property ( default <identifiersep> properties , pipe , decorator <identifiersep> class <identifiersep> prop ) ; if ( util . is <identifiersep> empty ( decorator <identifiersep> class <identifiersep> name ) ) decorator <identifiersep> class <identifiersep> name = default <identifiersep> decorator <identifiersep> class <identifiersep> name ; if ( util . is <identifiersep> empty ( decorator <identifiersep> class <identifiersep> name ) ) <LOG> return temp <identifiersep> tap ; temp <identifiersep> tap = util . new <identifiersep> instance ( decorator <identifiersep> class <identifiersep> name , temp <identifiersep> tap ) ; return temp <identifiersep> tap ; } protected tap make <identifiersep> temp <identifiersep> tap ( string name ) { return make <identifiersep> temp <identifiersep> tap ( null , name ) ; <ect>
return graph <identifiersep> transformer != null || super . requires <identifiersep> recursive <identifiersep> search ( ) ; } @ override protected element <identifiersep> graph prepare <identifiersep> for <identifiersep> match ( process <identifiersep> logger process <identifiersep> logger , transformed < element <identifiersep> graph > transformed , element <identifiersep> graph graph ) { if ( graph <identifiersep> transformer == null ) <LOG> return graph ; transformed child = graph <identifiersep> transformer . transform ( transformed . get <identifiersep> planner <identifiersep> context ( ) , graph ) ; transformed . add <identifiersep> child <identifiersep> transform ( child ) ; return child . get <identifiersep> end <identifiersep> graph ( ) ; } } <ect>
protected e transform ( process <identifiersep> logger process <identifiersep> logger , transformed < e > transformed , e graph , int max <identifiersep> depth , int current <identifiersep> depth ) { if ( current <identifiersep> depth == max <identifiersep> depth ) { process <identifiersep> logger . log <identifiersep> info ( <string_literal> , current <identifiersep> depth ) ; <LOG> return graph ; } element <identifiersep> graph prepared = prepare <identifiersep> for <identifiersep> match ( process <identifiersep> logger , transformed , graph ) ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , prepared != null ) ; if ( prepared == null ) return graph ; <ect>
process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , prepared != null ) ; if ( prepared == null ) return graph ; set < flow <identifiersep> element > exclusions = add <identifiersep> exclusions ( graph ) ; <LOG> match match ; <comment> <ect>
if ( find <identifiersep> all <identifiersep> primaries ) match = finder . find <identifiersep> all <identifiersep> matches ( transformed . get <identifiersep> planner <identifiersep> context ( ) , prepared , exclusions ) ; else match = finder . find <identifiersep> first <identifiersep> match ( transformed . get <identifiersep> planner <identifiersep> context ( ) , prepared , exclusions ) ; <LOG> process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) ) ; boolean transform <identifiersep> result = transform <identifiersep> graph <identifiersep> in <identifiersep> place <identifiersep> using <identifiersep> safe ( transformed , graph , match ) ; process <identifiersep> logger . log <identifiersep> debug ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , transform <identifiersep> result ) ; if ( ! transform <identifiersep> result ) return graph ; <ect>
in2 = copy . in2 ; out1 = copy . out1 ; out2 = copy . out2 ; order = copy . order ; } public pair < integer , integer > next <identifiersep> pair ( int prev <identifiersep> n1 , int prev <identifiersep> n2 ) <LOG> { if ( prev <identifiersep> n1 == null <identifiersep> node ) prev <identifiersep> n1 = 0 ; if ( prev <identifiersep> n2 == null <identifiersep> node ) prev <identifiersep> n2 = 0 ; else <ect>
{ for ( scope result : results ) { flow <identifiersep> element lhs = element <identifiersep> graph . get <identifiersep> delegate ( ) . get <identifiersep> edge <identifiersep> source ( result ) ; int lhs <identifiersep> index = element <identifiersep> graph . get <identifiersep> index ( lhs ) ; flow <identifiersep> element rhs = element <identifiersep> graph . get <identifiersep> delegate ( ) . get <identifiersep> edge <identifiersep> target ( result ) ; <LOG> int rhs <identifiersep> index = element <identifiersep> graph . get <identifiersep> index ( rhs ) ; } for ( scope <identifiersep> expression matcher : matchers ) log . debug ( <string_literal> , v1 , v2 , matcher ) ; } public static collection < scope > are <identifiersep> compatible <identifiersep> edges ( planner <identifiersep> context planner <identifiersep> context , element <identifiersep> graph element <identifiersep> graph , list < scope <identifiersep> expression > matchers , list < scope > scopes ) { <comment> <ect>
! finder <identifiersep> context . get <identifiersep> required <identifiersep> elements ( ) . is <identifiersep> empty ( ) ) result = finder <identifiersep> context . is <identifiersep> required ( flow <identifiersep> element ) ; else if ( finder <identifiersep> context . is <identifiersep> excluded ( flow <identifiersep> element ) || finder <identifiersep> context . is <identifiersep> ignored ( flow <identifiersep> element ) ) result = false ; else <LOG> result = expression . applies ( planner <identifiersep> context , element <identifiersep> graph . get <identifiersep> element <identifiersep> graph ( ) , flow <identifiersep> element ) ; return result ; } public boolean is <identifiersep> feasible <identifiersep> pair ( int node1 , int node2 ) { assert node1 < n1 ; assert node2 < n2 ; <ect>
{ if ( core2 [ other2 ] != null <identifiersep> node ) { int other1 = core2 [ other2 ] ; if ( ! match <identifiersep> graph . contains <identifiersep> edge ( other1 , node1 ) ) <LOG> { return false ; } } else { if ( in2 [ other2 ] != 0 ) termin2 ++ ; <ect>
<comment> private boolean match ( state state , map < integer , integer > vertex <identifiersep> map ) <LOG> { if ( state . is <identifiersep> goal ( ) ) return true ; if ( state . is <identifiersep> dead ( ) ) return false ; int n1 = state . null <identifiersep> node ; <ect>
{ n1 = next . get <identifiersep> lhs ( ) ; n2 = next . get <identifiersep> rhs ( ) ; log . trace ( <string_literal> , n1 , n2 ) ; <LOG> boolean feasible <identifiersep> pair = state . is <identifiersep> feasible <identifiersep> pair ( n1 , n2 ) ; if ( feasible <identifiersep> pair ) { state copy = state . copy ( ) ; copy . add <identifiersep> pair ( n1 , n2 ) ; found = match ( copy , vertex <identifiersep> map ) ; <ect>
{ if ( vertex <identifiersep> map . contains <identifiersep> key ( entry . get <identifiersep> key ( ) ) && ! vertex <identifiersep> map . get ( entry . get <identifiersep> key ( ) ) . equals ( entry . get <identifiersep> value ( ) ) ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } log . trace ( <string_literal> , n1 , n2 ) ; <LOG> vertex <identifiersep> map . put <identifiersep> all ( copy . get <identifiersep> vertex <identifiersep> mapping ( ) ) ; } else { log . trace ( <string_literal> , n1 , n2 ) ; <ect>
log . info ( <string_literal> , collectors . size ( ) ) ; return collector ; } private void purge <identifiersep> collectors ( ) { <LOG> int num <identifiersep> to <identifiersep> close = math . max ( 1 , ( int ) ( open <identifiersep> writes <identifiersep> threshold * . <number_literal> ) ) ; set < string > remove <identifiersep> keys = new hash <identifiersep> set < string > ( ) ; set < string > keys = collectors . key <identifiersep> set ( ) ; for ( string key : keys ) { if ( num <identifiersep> to <identifiersep> close -- == 0 ) <ect>
{ return get <identifiersep> listeners ( ) . remove ( new safe <identifiersep> cascade <identifiersep> listener ( flow <identifiersep> listener ) ) ; } private void fire <identifiersep> on <identifiersep> completed ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { for ( cascade <identifiersep> listener cascade <identifiersep> listener : get <identifiersep> listeners ( ) ) cascade <identifiersep> listener . on <identifiersep> completed ( this ) ; } } private void fire <identifiersep> on <identifiersep> throwable ( ) { <ect>
if ( is <identifiersep> handled ) throwable = null ; } } protected void fire <identifiersep> on <identifiersep> stopping ( ) { if ( has <identifiersep> listeners ( ) ) <LOG> { for ( cascade <identifiersep> listener cascade <identifiersep> listener : get <identifiersep> listeners ( ) ) cascade <identifiersep> listener . on <identifiersep> stopping ( this ) ; } } protected void fire <identifiersep> on <identifiersep> starting ( ) { <ect>
public void cleanup ( ) { } <comment> private void run ( ) { <LOG> version . print <identifiersep> banner ( ) ; register <identifiersep> shutdown <identifiersep> hook ( ) ; try { if ( stop ) return ; <ect>
int num <identifiersep> local <identifiersep> flows = num <identifiersep> local <identifiersep> flows ( ) ; boolean run <identifiersep> flows <identifiersep> local = num <identifiersep> local <identifiersep> flows > 1 ; if ( run <identifiersep> flows <identifiersep> local ) num <identifiersep> threads = 1 ; { <LOG> log <identifiersep> info ( <string_literal> + ( num <identifiersep> threads != 1 ) ) ; log <identifiersep> info ( <string_literal> + num <identifiersep> threads ) ; } list < future < throwable > > futures = spawn <identifiersep> strategy . start ( this , num <identifiersep> threads , jobs <identifiersep> map . values ( ) ) ; for ( future < throwable > future : futures ) { throwable = future . get ( ) ; <ect>
@ override public priority priority ( ) { return priority . work <identifiersep> parent ; } @ override public void execute ( ) <LOG> { base <identifiersep> cascade . this . stop ( ) ; } } ; shutdown <identifiersep> util . add <identifiersep> hook ( shutdown <identifiersep> hook ) ; } private void deregister <identifiersep> shutdown <identifiersep> hook ( ) { <ect>
log <identifiersep> info ( <string_literal> ) ; try { spawn <identifiersep> strategy . complete ( this , <number_literal> * <number_literal> , time <identifiersep> unit . seconds ) ; } catch ( interrupted <identifiersep> exception exception ) { <LOG> <comment> <ect>
log <identifiersep> info ( <string_literal> ) ; synchronized ( jobs <identifiersep> map ) { list < callable < throwable > > jobs = new array <identifiersep> list < callable < throwable > > ( jobs <identifiersep> map . values ( ) ) ; collections . reverse ( jobs ) ; for ( callable < throwable > callable : jobs ) <LOG> ( ( cascade <identifiersep> job ) callable ) . stop ( ) ; } } @ override public void write <identifiersep> dot ( string filename ) { print <identifiersep> element <identifiersep> graph ( filename , identifier <identifiersep> graph ) ; } protected void print <identifiersep> element <identifiersep> graph ( string filename , simple <identifiersep> directed <identifiersep> graph < string , base <identifiersep> flow . flow <identifiersep> holder > graph ) <ect>
@ override { @ override public void log <identifiersep> info ( string message , object . . . arguments ) <LOG> { } @ override public void log <identifiersep> debug ( string message , object . . . arguments ) { log . debug ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override <ect>
@ override public void log <identifiersep> debug ( string message , object . . . arguments ) { log . debug ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> warn ( string message ) <LOG> { } @ override public void log <identifiersep> warn ( string message , throwable throwable ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , throwable ) ; } @ override <ect>
@ override public void log <identifiersep> warn ( string message , throwable throwable ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , throwable ) ; } @ override public void log <identifiersep> warn ( string message , object . . . arguments ) <LOG> { } @ override public void log <identifiersep> error ( string message , object . . . arguments ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override <ect>
@ override public void log <identifiersep> error ( string message , object . . . arguments ) { log . warn ( <string_literal> + util . truncate ( get <identifiersep> name ( ) , <number_literal> ) + <string_literal> + message , arguments ) ; } @ override public void log <identifiersep> error ( string message , throwable throwable ) <LOG> { } <comment> protected class cascade <identifiersep> job implements callable < throwable > { <comment> final flow flow ; <ect>
try { log <identifiersep> info ( <string_literal> + flow . get <identifiersep> name ( ) ) ; if ( flow <identifiersep> skip <identifiersep> strategy == null ? flow . is <identifiersep> skip <identifiersep> flow ( ) : flow <identifiersep> skip <identifiersep> strategy . skip <identifiersep> flow ( flow ) ) <LOG> { flow . get <identifiersep> flow <identifiersep> stats ( ) . mark <identifiersep> skipped ( ) ; flows . fire <identifiersep> on <identifiersep> completed ( flow ) ; return null ; } flow . prepare ( ) ; <comment> <ect>
flow . prepare ( ) ; <comment> <LOG> failed = true ; cascade <identifiersep> exception cascade <identifiersep> exception = new cascade <identifiersep> exception ( <string_literal> + flow . get <identifiersep> name ( ) , exception ) ; if ( ! cascade <identifiersep> stats . is <identifiersep> finished ( ) ) cascade <identifiersep> stats . mark <identifiersep> failed ( cascade <identifiersep> exception ) ; return cascade <identifiersep> exception ; } finally <ect>
{ try { latch . await ( ) ; return flow != null && ! failed && ! stop ; } catch ( interrupted <identifiersep> exception exception ) <LOG> { } return false ; } } @ override public unit <identifiersep> of <identifiersep> work <identifiersep> spawn <identifiersep> strategy get <identifiersep> spawn <identifiersep> strategy ( ) { return spawn <identifiersep> strategy ; <ect>
private void make <identifiersep> graph ( identifier <identifiersep> graph identifier <identifiersep> graph ) { set < string > identifiers = identifier <identifiersep> graph . vertex <identifiersep> set ( ) ; int count = 0 ; for ( string source : identifiers ) <LOG> { list < string > sinks = graphs . successor <identifiersep> list <identifiersep> of ( identifier <identifiersep> graph , source ) ; for ( string sink : sinks ) { log . debug ( <string_literal> , source , sink ) ; <ect>
{ for ( map . entry < string , flow <identifiersep> node <identifiersep> stats > entry : get <identifiersep> flow <identifiersep> node <identifiersep> stats <identifiersep> map ( ) . entry <identifiersep> set ( ) ) { entry . get <identifiersep> value ( ) . record <identifiersep> stats ( ) ; entry . get <identifiersep> value ( ) . record <identifiersep> child <identifiersep> stats ( ) ; } } catch ( exception exception ) <LOG> { } } } <ect>
log . error ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) ) ; else log . warn ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) . get <identifiersep> message ( ) ) ; if ( cached <identifiersep> counters != null ) { log . error ( <string_literal> ) ; <LOG> return cached <identifiersep> counters ; } if ( exception . get <identifiersep> cause ( ) instanceof flow <identifiersep> exception ) throw ( flow <identifiersep> exception ) exception . get <identifiersep> cause ( ) ; throw new flow <identifiersep> exception ( exception . get <identifiersep> cause ( ) ) ; } catch ( timeout <identifiersep> exception exception ) { <ect>
throw new flow <identifiersep> exception ( exception . get <identifiersep> cause ( ) ) ; } catch ( timeout <identifiersep> exception exception ) { fetch <identifiersep> attempts ++ ; if ( fetch <identifiersep> attempts >= max <identifiersep> fetch <identifiersep> attempts ) log . warn ( <string_literal> , timeout , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) ) ; <LOG> else } has <identifiersep> captured <identifiersep> final <identifiersep> counters = is <identifiersep> process <identifiersep> finished && success ; return cached <identifiersep> counters ; } private counters fetch <identifiersep> counters ( job <identifiersep> status running <identifiersep> job ) throws interrupted <identifiersep> exception , execution <identifiersep> exception , timeout <identifiersep> exception { <comment> <ect>
return ; boolean success = capture <identifiersep> child <identifiersep> detail <identifiersep> internal ( ) ; mark <identifiersep> detail <identifiersep> captured ( ) ; <comment> <LOG> if ( all <identifiersep> children <identifiersep> finished ) } } <comment> <ect>
protected void set <identifiersep> tails ( pipe . . . tails ) { if ( this . tails != null ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; this . tails = tails ; if ( previous == null ) <LOG> { return ; } set < pipe > stop <identifiersep> set = new hash <identifiersep> set < pipe > ( ) ; collections . add <identifiersep> all ( stop <identifiersep> set , previous ) ; set <identifiersep> parent ( stop <identifiersep> set , tails ) ; } private void set <identifiersep> parent ( set < pipe > stop <identifiersep> set , pipe [ ] tails ) <ect>
iterator [ ] iterators ; tuple [ ] last <identifiersep> values ; tuple <identifiersep> builder result <identifiersep> builder ; tuple result = new tuple ( ) ; <comment> <LOG> this . closure = closure ; init ( ) ; } protected void init ( ) { iterators = new iterator [ closure . size ( ) ] ; for ( int i = 0 ; i < closure . size ( ) ; i ++ ) <ect>
return parent <identifiersep> class <identifiersep> loader . load <identifiersep> class ( name ) ; } } } public child <identifiersep> first <identifiersep> url <identifiersep> class <identifiersep> loader ( string [ ] exclusions , url . . . urls ) { super ( thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) ) ; this . exclusions = util . remove <identifiersep> nulls ( exclusions ) ; <LOG> child <identifiersep> class <identifiersep> loader = new child <identifiersep> url <identifiersep> class <identifiersep> loader ( urls , this . get <identifiersep> parent ( ) ) ; } @ override protected synchronized class < ? > load <identifiersep> class ( string name , boolean resolve ) throws class <identifiersep> not <identifiersep> found <identifiersep> exception { for ( string exclusion : exclusions ) { <ect>
{ if ( name . starts <identifiersep> with ( exclusion ) ) { log . debug ( <string_literal> , exclusion , name ) ; return super . load <identifiersep> class ( name , resolve ) ; } } try <LOG> { return child <identifiersep> class <identifiersep> loader . load <identifiersep> class ( name ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { return super . load <identifiersep> class ( name , resolve ) ; } } } <ect>
return null ; } try { class < provider > type = ( class < provider > ) get <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( class <identifiersep> name ) ; return type . new <identifiersep> instance ( ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) <LOG> { } catch ( illegal <identifiersep> access <identifiersep> exception exception ) { log . error ( <string_literal> , class <identifiersep> name , exception ) ; } catch ( instantiation <identifiersep> exception exception ) { <ect>
{ log . error ( <string_literal> , class <identifiersep> name , exception ) ; } catch ( illegal <identifiersep> access <identifiersep> exception exception ) { log . error ( <string_literal> , class <identifiersep> name , exception ) ; } catch ( instantiation <identifiersep> exception exception ) <LOG> { } return null ; } private synchronized class <identifiersep> loader get <identifiersep> class <identifiersep> loader ( ) { if ( class <identifiersep> loader != null ) return class <identifiersep> loader ; <ect>
{ spill <identifiersep> listener null = new spill <identifiersep> listener ( ) { private final logger log = logger <identifiersep> factory . get <identifiersep> logger ( spill <identifiersep> listener . class ) ; @ override public void notify <identifiersep> write <identifiersep> spill <identifiersep> begin ( spillable spillable , int spill <identifiersep> size , string spill <identifiersep> reason ) <LOG> { } @ override public void notify <identifiersep> read <identifiersep> spill <identifiersep> begin ( spillable spillable ) { } @ override public void notify <identifiersep> write <identifiersep> spill <identifiersep> end ( spillable <identifiersep> tuple <identifiersep> list spillable <identifiersep> tuple <identifiersep> list , long duration ) <ect>
{ try { log . info ( <string_literal> , codec ) ; codec <identifiersep> class = thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( codec ) . as <identifiersep> subclass ( sub <identifiersep> class ) ; if ( codec <identifiersep> class != null ) <LOG> { break ; } } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { <comment> <ect>
{ if ( type >= 0 && type < = <number_literal> ) return null ; return element <identifiersep> reader . get <identifiersep> comparator <identifiersep> for ( type , this ) ; } @ override public void close ( ) throws io <identifiersep> exception <LOG> { try { super . close ( ) ; } finally { <ect>
continue ; for ( int i = 0 ; i < key <identifiersep> field . get <identifiersep> comparators ( ) . length ; i ++ ) { comparator comparator = key <identifiersep> field . get <identifiersep> comparators ( ) [ i ] ; if ( ! ( comparator instanceof hasher ) ) continue ; <LOG> if ( comparators [ i ] != null && ! comparators [ i ] . equals ( comparator ) ) comparators [ i ] = comparator ; } } return comparators ; } public static boolean is <identifiersep> null ( comparator [ ] comparators ) { int count = 0 ; <ect>
try { operation <identifiersep> call . set <identifiersep> arguments ( null ) ; assertion . do <identifiersep> assert ( flow <identifiersep> process . null , operation <identifiersep> call ) ; fail ( ) ; } catch ( assertion <identifiersep> exception exception ) <LOG> { <comment> <ect>
{ log . info ( <string_literal> , new object [ ] { spillable . get <identifiersep> grouping ( ) . print ( ) , num <identifiersep> files + 1 , spill <identifiersep> reason } ) ; runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; <LOG> long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; } log . info ( <string_literal> , spill <identifiersep> size , num <identifiersep> files + 1 ) ; flow <identifiersep> process . increment ( spill . num <identifiersep> spills <identifiersep> written , 1 ) ; flow <identifiersep> process . increment ( spill . num <identifiersep> tuples <identifiersep> spilled , spill <identifiersep> size ) ; } @ override public void notify <identifiersep> write <identifiersep> spill <identifiersep> end ( spillable <identifiersep> tuple <identifiersep> list spillable <identifiersep> tuple <identifiersep> list , long duration ) <ect>
{ log . info ( <string_literal> , new object [ ] { join <identifiersep> field . print <identifiersep> verbose ( ) , spillable . get <identifiersep> grouping ( ) . print ( ) , num <identifiersep> files + 1 , spill <identifiersep> reason } ) ; runtime runtime = runtime . get <identifiersep> runtime ( ) ; long free <identifiersep> mem = runtime . free <identifiersep> memory ( ) / <number_literal> / <number_literal> ; long max <identifiersep> mem = runtime . max <identifiersep> memory ( ) / <number_literal> / <number_literal> ; <LOG> long total <identifiersep> mem = runtime . total <identifiersep> memory ( ) / <number_literal> / <number_literal> ; } log . info ( <string_literal> , spill <identifiersep> size , num <identifiersep> files + 1 ) ; flow <identifiersep> process . increment ( spill . num <identifiersep> spills <identifiersep> written , 1 ) ; flow <identifiersep> process . increment ( spill . num <identifiersep> tuples <identifiersep> spilled , spill <identifiersep> size ) ; } @ override public void notify <identifiersep> write <identifiersep> spill <identifiersep> end ( spillable <identifiersep> tuple <identifiersep> list spillable <identifiersep> tuple <identifiersep> list , long duration ) <ect>
@ override public void set <identifiersep> conf ( configuration conf ) { super . set <identifiersep> conf ( conf ) ; if ( conf == null ) return ; <LOG> if ( perform <identifiersep> raw <identifiersep> comparison ( ) ) if ( perform <identifiersep> raw <identifiersep> comparison ( ) ) actual = get <identifiersep> byte <identifiersep> comparison ( ) ; else actual = get <identifiersep> stream <identifiersep> comparison ( ) ; } protected raw <identifiersep> comparison get <identifiersep> stream <identifiersep> comparison ( ) <ect>
if ( map == null || map . values ( ) . size ( ) == 0 ) continue ; flow <identifiersep> step <identifiersep> job flow <identifiersep> step <identifiersep> job = map . values ( ) . iterator ( ) . next ( ) ; if ( flow <identifiersep> step <identifiersep> job . get <identifiersep> step <identifiersep> stats ( ) . get <identifiersep> status ( ) == cascading <identifiersep> stats . status . failed ) fail ( <string_literal> ) ; if ( flow <identifiersep> step <identifiersep> job . is <identifiersep> started ( ) ) <LOG> break ; } flow . stop ( ) ; } assert <identifiersep> true ( <string_literal> , listener . completed . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , listener . stopped . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; try { <ect>
public void test <identifiersep> dfs ( ) throws uri <identifiersep> syntax <identifiersep> exception , io <identifiersep> exception { if ( ! get <identifiersep> platform ( ) . is <identifiersep> use <identifiersep> cluster ( ) ) return ; <comment> <LOG> { return ; } tap tap = new dfs ( new sequence <identifiersep> file ( new fields ( <string_literal> ) ) , <string_literal> ) ; string path = tap . get <identifiersep> full <identifiersep> identifier ( get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> process ( ) ) ; assert <identifiersep> false ( <string_literal> , new path ( path ) . to <identifiersep> uri ( ) . get <identifiersep> scheme ( ) . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) ; new dfs ( new sequence <identifiersep> file ( new fields ( <string_literal> ) ) , <string_literal> ) ; <ect>
assert <identifiersep> true ( <string_literal> , tuple . get <identifiersep> object ( <number_literal> ) instanceof bytes <identifiersep> writable ) ; byte [ ] bytes = ( ( bytes <identifiersep> writable ) tuple . get <identifiersep> object ( <number_literal> ) ) . get <identifiersep> bytes ( ) ; string string = new string ( bytes , 0 , bytes . length > 1 ? bytes . length - 1 : bytes . length , <string_literal> ) ; assert <identifiersep> equals ( <string_literal> , integer . parse <identifiersep> int ( string ) , i ) ; assert <identifiersep> true ( <string_literal> , tuple . get <identifiersep> object ( <number_literal> ) instanceof boolean <identifiersep> writable ) ; k = value ; } <LOG> input . close ( ) ; } <ect>
flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( properties ) . connect ( sources , sink , splice ) ; flow . complete ( ) ; validate <identifiersep> length ( flow , <number_literal> ) ; <comment> <LOG> string value = target == null ? null : target . value ; while ( iterator . has <identifiersep> next ( ) ) { test <identifiersep> text next <identifiersep> target = ( test <identifiersep> text ) iterator . next ( ) . get <identifiersep> object ( <string_literal> ) ; string next = next <identifiersep> target == null ? null : next <identifiersep> target . value ; if ( value != null && value . compare <identifiersep> to ( next ) >= 0 ) <ect>
public static void init <identifiersep> log4j ( configuration configuration ) { string values = configuration . get ( <string_literal> , null ) ; if ( values == null || values . length ( ) == 0 ) return ; if ( ! util . has <identifiersep> class ( <string_literal> ) ) <LOG> { return ; } string [ ] elements = values . split ( <string_literal> ) ; for ( string element : elements ) log <identifiersep> util . set <identifiersep> log4j <identifiersep> level ( element . split ( <string_literal> ) ) ; } <comment> <ect>
job <identifiersep> confs [ i ] = ( job <identifiersep> conf ) merge <identifiersep> conf ( job , configs . get ( i ) , false ) ; return job <identifiersep> confs ; } public static < j extends configuration > j merge <identifiersep> conf ( j job , map < string , string > config , boolean directly ) { configuration current <identifiersep> conf = directly ? job : ( job instanceof job <identifiersep> conf ? copy <identifiersep> job <identifiersep> conf ( ( job <identifiersep> conf ) job ) : new configuration ( job ) ) ; for ( string key : config . key <identifiersep> set ( ) ) <LOG> { current <identifiersep> conf . set ( key , config . get ( key ) ) ; } return ( j ) current <identifiersep> conf ; } public static configuration remove <identifiersep> properties <identifiersep> from ( configuration job <identifiersep> conf , string . . . keys ) { map < object , object > properties = create <identifiersep> properties ( job <identifiersep> conf ) ; <ect>
log . warn ( <string_literal> , manifest <identifiersep> path , exception . get <identifiersep> message ( ) ) ; return new platform <identifiersep> info ( platform <identifiersep> name , null , parsed <identifiersep> version ) ; } attributes attributes = manifest . get <identifiersep> attributes ( attribute <identifiersep> path ) ; if ( attributes == null ) attributes = manifest . get <identifiersep> main <identifiersep> attributes ( ) ; if ( attributes == null ) <LOG> { return new platform <identifiersep> info ( platform <identifiersep> name , null , parsed <identifiersep> version ) ; } string vendor = attributes . get <identifiersep> value ( <string_literal> ) ; string version = attributes . get <identifiersep> value ( <string_literal> ) ; if ( util . is <identifiersep> empty ( version ) ) version = parsed <identifiersep> version ; <ect>
{ <comment> <LOG> { if ( local <identifiersep> file <identifiersep> status != null ) timestamp <identifiersep> map . put ( remote <identifiersep> path . get <identifiersep> name ( ) , local <identifiersep> file <identifiersep> status . get <identifiersep> modification <identifiersep> time ( ) ) ; } } return timestamp <identifiersep> map ; } public static map < path , path > get <identifiersep> common <identifiersep> paths ( map < string , path > local <identifiersep> paths , map < string , path > remote <identifiersep> paths ) { <ect>
length = length < 0 ? 0 : length ; <comment> <LOG> { log . debug ( <string_literal> , connection . get <identifiersep> request <identifiersep> method ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> code ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> message ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> content <identifiersep> length ( ) ) ; } } private url make <identifiersep> url ( path path ) throws io <identifiersep> exception <ect>
return new file <identifiersep> status ( length , false , 1 , get <identifiersep> default <identifiersep> block <identifiersep> size ( ) , modified , path ) ; } private void debug <identifiersep> connection ( http <identifiersep> url <identifiersep> connection connection ) throws io <identifiersep> exception { { log . debug ( <string_literal> , connection . get <identifiersep> url ( ) ) ; <LOG> log . debug ( <string_literal> , connection . get <identifiersep> request <identifiersep> method ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> message ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> content <identifiersep> length ( ) ) ; } } private url make <identifiersep> url ( path path ) throws io <identifiersep> exception { if ( path . to <identifiersep> string ( ) . starts <identifiersep> with ( scheme ) ) <ect>
{ { log . debug ( <string_literal> , connection . get <identifiersep> url ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> request <identifiersep> method ( ) ) ; log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> code ( ) ) ; <LOG> log . debug ( <string_literal> , connection . get <identifiersep> response <identifiersep> message ( ) ) ; } } private url make <identifiersep> url ( path path ) throws io <identifiersep> exception { if ( path . to <identifiersep> string ( ) . starts <identifiersep> with ( scheme ) ) return uri . create ( path . to <identifiersep> string ( ) ) . to <identifiersep> url ( ) ; try <ect>
config = new hash <identifiersep> map < string , string > ( ) ; string [ ] keys = writable <identifiersep> utils . read <identifiersep> string <identifiersep> array ( in ) ; string [ ] values = writable <identifiersep> utils . read <identifiersep> string <identifiersep> array ( in ) ; for ( int i = 0 ; i < keys . length ; i ++ ) config . put ( keys [ i ] , values [ i ] ) ; <LOG> { for ( map . entry < string , string > entry : config . entry <identifiersep> set ( ) ) log . debug ( <string_literal> , entry . get <identifiersep> key ( ) , entry . get <identifiersep> value ( ) ) ; } job <identifiersep> conf current <identifiersep> conf = hadoop <identifiersep> util . merge <identifiersep> conf ( job <identifiersep> conf , config , false ) ; try { <ect>
input <identifiersep> split . read <identifiersep> fields ( in ) ; if ( input <identifiersep> split instanceof file <identifiersep> split ) { path path = ( ( file <identifiersep> split ) input <identifiersep> split ) . get <identifiersep> path ( ) ; if ( path != null ) { <LOG> job <identifiersep> conf . set ( file <identifiersep> type . cascading <identifiersep> source <identifiersep> path , path . to <identifiersep> string ( ) ) ; } } } } <ect>
flow <identifiersep> process . keep <identifiersep> alive ( ) ; writer . write ( writable <identifiersep> comparable , writable ) ; } public void close ( ) { try { <LOG> if ( is <identifiersep> file <identifiersep> output <identifiersep> format ) else log . info ( <string_literal> , tap ) ; try { writer . close ( get <identifiersep> reporter ( ) ) ; <ect>
clean <identifiersep> job = hadoop18tap <identifiersep> util . commit <identifiersep> task ( conf ) ; if ( clean <identifiersep> job ) <comment> <LOG> { throw new tap <identifiersep> exception ( <string_literal> + filename , exception ) ; } } } <ect>
string mapper = conf . get <identifiersep> boolean ( <string_literal> , conf . get <identifiersep> boolean ( <string_literal> , true ) ) ? <string_literal> : <string_literal> ; string value = string . format ( <string_literal> , ( int ) math . rint ( system . current <identifiersep> time <identifiersep> millis ( ) ) , mapper ) ; conf . set ( <string_literal> , value ) ; conf . set ( <string_literal> , value ) ; } make <identifiersep> temp <identifiersep> path ( conf ) ; if ( write <identifiersep> directly <identifiersep> to <identifiersep> working <identifiersep> path ( conf , output <identifiersep> path ) ) <LOG> { set <identifiersep> work <identifiersep> output <identifiersep> path ( conf , output <identifiersep> path ) ; return ; } <comment> <ect>
file <identifiersep> system fs = get <identifiersep> fs <identifiersep> safe ( conf , task <identifiersep> output <identifiersep> path ) ; if ( fs == null ) return false ; atomic <identifiersep> integer integer = path <identifiersep> counts . get ( task <identifiersep> output <identifiersep> path . to <identifiersep> string ( ) ) ; if ( integer . decrement <identifiersep> and <identifiersep> get ( ) != 0 ) return false ; <LOG> string task <identifiersep> id = conf . get ( <string_literal> , conf . get ( <string_literal> ) ) ; if ( task <identifiersep> output <identifiersep> path != null ) { if ( write <identifiersep> directly <identifiersep> to <identifiersep> working <identifiersep> path ( conf , task <identifiersep> output <identifiersep> path ) ) return true ; if ( fs . exists ( task <identifiersep> output <identifiersep> path ) ) <ect>
return combine <identifiersep> enabled ; <comment> <LOG> { system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; } return false ; } protected static boolean get <identifiersep> combined <identifiersep> input <identifiersep> safe <identifiersep> mode ( configuration conf ) { return conf . get <identifiersep> boolean ( <string_literal> , true ) ; <ect>
try { uri uri <identifiersep> scheme ; log . debug ( <string_literal> , string <identifiersep> path ) ; uri uri = new path ( string <identifiersep> path ) . to <identifiersep> uri ( ) ; <comment> <LOG> string authority = uri . get <identifiersep> authority ( ) ; if ( scheme <identifiersep> string != null && authority != null ) uri <identifiersep> scheme = new uri ( scheme <identifiersep> string + <string_literal> + uri . get <identifiersep> authority ( ) ) ; else if ( scheme <identifiersep> string != null ) uri <identifiersep> scheme = new uri ( scheme <identifiersep> string + <string_literal> ) ; else <ect>
<comment> <LOG> else } else { <comment> <ect>
public boolean delete <identifiersep> resource ( configuration conf ) throws io <identifiersep> exception { string full <identifiersep> identifier = get <identifiersep> full <identifiersep> identifier ( conf ) ; return delete <identifiersep> full <identifiersep> identifier ( conf , full <identifiersep> identifier ) ; } private boolean delete <identifiersep> full <identifiersep> identifier ( configuration conf , string full <identifiersep> identifier ) throws io <identifiersep> exception <LOG> { reset <identifiersep> file <identifiersep> statuses ( ) ; path full <identifiersep> path = new path ( full <identifiersep> identifier ) ; <comment> <ect>
throw new tap <identifiersep> exception ( exception ) ; } } @ override public tuple <identifiersep> entry <identifiersep> iterator open <identifiersep> for <identifiersep> read ( flow <identifiersep> process < ? extends configuration > flow <identifiersep> process , record <identifiersep> reader input ) throws io <identifiersep> exception { <comment> <LOG> { return super . open <identifiersep> for <identifiersep> read ( flow <identifiersep> process , input ) ; } path [ ] cached <identifiersep> files = get <identifiersep> local <identifiersep> cache <identifiersep> files ( flow <identifiersep> process ) ; if ( cached <identifiersep> files == null || cached <identifiersep> files . length == 0 ) return super . open <identifiersep> for <identifiersep> read ( flow <identifiersep> process , null ) ; list < path > paths = new array <identifiersep> list < > ( ) ; <ect>
{ if ( path . to <identifiersep> string ( ) . ends <identifiersep> with ( path <identifiersep> to <identifiersep> find . get <identifiersep> name ( ) ) ) { log . info ( <string_literal> , path ) ; taps . add ( new lfs ( get <identifiersep> scheme ( ) , path . to <identifiersep> string ( ) ) ) ; } } } if ( paths . is <identifiersep> empty ( ) ) <comment> <LOG> { return super . open <identifiersep> for <identifiersep> read ( flow <identifiersep> process , input ) ; } return new multi <identifiersep> source <identifiersep> tap ( taps . to <identifiersep> array ( new tap [ taps . size ( ) ] ) ) . open <identifiersep> for <identifiersep> read ( flow <identifiersep> process , input ) ; } private void register <identifiersep> hfs ( flow <identifiersep> process < ? extends configuration > process , configuration conf , hfs hfs ) throws io <identifiersep> exception { if ( is <identifiersep> simple <identifiersep> glob ( ) ) <ect>
{ string type <identifiersep> name = job <identifiersep> conf . get ( flow <identifiersep> props . default <identifiersep> element <identifiersep> comparator ) ; if ( util . is <identifiersep> empty ( type <identifiersep> name ) ) return null ; return create <identifiersep> comparator ( job <identifiersep> conf , type <identifiersep> name ) ; } private static comparator create <identifiersep> comparator ( configuration job <identifiersep> conf , string type <identifiersep> name ) <LOG> { try { class < comparator > type = ( class < comparator > ) tuple <identifiersep> serialization . class . get <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( type <identifiersep> name ) ; return reflection <identifiersep> utils . new <identifiersep> instance ( type , job <identifiersep> conf ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) <ect>
return types <identifiersep> ignored ; } public boolean are <identifiersep> types <identifiersep> required ( ) { if ( types <identifiersep> required == null ) { types <identifiersep> required = get <identifiersep> conf ( ) . get <identifiersep> boolean ( tuple <identifiersep> serialization <identifiersep> props . require <identifiersep> types , false ) ; <LOG> if ( types <identifiersep> required ) } return types <identifiersep> required ; } serialization <identifiersep> factory get <identifiersep> serialization <identifiersep> factory ( ) { if ( serialization <identifiersep> factory == null ) serialization <identifiersep> factory = new serialization <identifiersep> factory ( get <identifiersep> conf ( ) ) ; <ect>
if ( token <identifiersep> annotation . tokens ( ) . length != token <identifiersep> annotation . class <identifiersep> names ( ) . length ) throw new cascading <identifiersep> exception ( <string_literal> ) ; int [ ] tokens = token <identifiersep> annotation . tokens ( ) ; for ( int i = 0 ; i < tokens . length ; i ++ ) add <identifiersep> token ( type , tokens [ i ] , token <identifiersep> annotation . class <identifiersep> names ( ) [ i ] ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) <LOG> { } } tokens <identifiersep> size = token <identifiersep> classes <identifiersep> map . size ( ) ; } private void add <identifiersep> token ( class type , int token , string class <identifiersep> name ) { if ( type != null && ! type . get <identifiersep> name ( ) . starts <identifiersep> with ( <string_literal> ) && token < <number_literal> ) throw new cascading <identifiersep> exception ( <string_literal> + token ) ; <ect>
public static map < integer , fields > get <identifiersep> fields ( configuration conf , string property ) { try { return hadoop <identifiersep> util . get <identifiersep> fields ( conf , property ) ; } catch ( io <identifiersep> exception exception ) <LOG> { return collections . empty <identifiersep> map ( ) ; } } private static fields mask <identifiersep> void ( fields fields , fields mask ) { if ( fields == null ) return null ; <ect>
object found <identifiersep> object = null ; object object ; try { object = deserializer . deserialize ( found <identifiersep> object ) ; } catch ( io <identifiersep> exception exception ) <LOG> { throw exception ; } return object ; } @ override public comparator get <identifiersep> comparator <identifiersep> for ( int token , data <identifiersep> input <identifiersep> stream input <identifiersep> stream ) throws io <identifiersep> exception { <ect>
public void write ( data <identifiersep> output <identifiersep> stream output <identifiersep> stream , object object ) throws io <identifiersep> exception { class < ? > type = object . get <identifiersep> class ( ) ; string class <identifiersep> name = type . get <identifiersep> name ( ) ; integer token = tuple <identifiersep> serialization . get <identifiersep> token <identifiersep> for ( class <identifiersep> name ) ; if ( token == null ) <LOG> { writable <identifiersep> utils . write <identifiersep> v <identifiersep> int ( output <identifiersep> stream , hadoop <identifiersep> tuple <identifiersep> output <identifiersep> stream . writable <identifiersep> token ) ; <comment> <ect>
{ serializer serializer = get <identifiersep> serializer ( output <identifiersep> stream , type ) ; try { serializer . serialize ( object ) ; } catch ( io <identifiersep> exception exception ) <LOG> { throw exception ; } } public void close ( ) { if ( serializers . size ( ) == 0 ) return ; <ect>
<comment> <LOG> system . gc ( ) ; return codec <identifiersep> pool . get <identifiersep> decompressor ( codec ) ; } } } <ect>
public void start ( duct previous ) { log . debug ( <string_literal> , previous ) ; synchronized ( this ) { if ( started != null ) <LOG> { return ; } if ( completed != null ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; started = new weak <identifiersep> reference < > ( previous ) ; } try <ect>
stream <identifiersep> graph . prepare ( ) ; log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable current <identifiersep> throwable ) { try { <LOG> if ( ! ( current <identifiersep> throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) completed = true ; successful = false ; throwable = current <identifiersep> throwable ; return throwable ; } finally <ect>
{ attempted <identifiersep> cleanup = true ; <comment> <LOG> if ( ! ( current <identifiersep> throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) if ( throwable == null ) throwable = current <identifiersep> throwable ; } completed = true ; successful = throwable == null ; return throwable ; <ect>
flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( ) . connect ( source , sink , pipe ) ; try { flow . complete ( ) ; fail ( <string_literal> ) ; } catch ( throwable exception ) <LOG> { exception . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
return runners ; } private set < class < ? extends test <identifiersep> platform > > get <identifiersep> platform <identifiersep> classes <identifiersep> from <identifiersep> annotation ( class < ? > java <identifiersep> class ) throws throwable { platform <identifiersep> runner . platform annotation = java <identifiersep> class . get <identifiersep> annotation ( platform <identifiersep> runner . platform . class ) ; if ( annotation == null ) return collections . empty <identifiersep> set ; <LOG> hash <identifiersep> set < class < ? extends test <identifiersep> platform > > classes = new linked <identifiersep> hash <identifiersep> set < class < ? extends test <identifiersep> platform > > ( arrays . as <identifiersep> list ( annotation . value ( ) ) ) ; return classes ; } static map < class <identifiersep> loader , set < class < ? extends test <identifiersep> platform > > > cache = new weak <identifiersep> hash <identifiersep> map < > ( ) ; protected synchronized static set < class < ? extends test <identifiersep> platform > > get <identifiersep> platform <identifiersep> classes <identifiersep> from <identifiersep> classpath ( class <identifiersep> loader class <identifiersep> loader ) throws io <identifiersep> exception , class <identifiersep> not <identifiersep> found <identifiersep> exception { if ( cache . contains <identifiersep> key ( class <identifiersep> loader ) ) <ect>
enumeration < url > urls = class <identifiersep> loader . get <identifiersep> resources ( platform <identifiersep> resource ) ; while ( urls . has <identifiersep> more <identifiersep> elements ( ) ) { input <identifiersep> stream stream = urls . next <identifiersep> element ( ) . open <identifiersep> stream ( ) ; classes . add ( ( class < ? extends test <identifiersep> platform > ) get <identifiersep> platform <identifiersep> class ( class <identifiersep> loader , properties , stream ) ) ; } if ( classes . is <identifiersep> empty ( ) ) <LOG> { log . warn ( <string_literal> , platform <identifiersep> resource , test <identifiersep> platform . class . get <identifiersep> canonical <identifiersep> name ( ) ) ; log . warn ( <string_literal> ) ; } else { log . info ( <string_literal> , classes . size ( ) ) ; <ect>
{ input <identifiersep> stream stream = urls . next <identifiersep> element ( ) . open <identifiersep> stream ( ) ; classes . add ( ( class < ? extends test <identifiersep> platform > ) get <identifiersep> platform <identifiersep> class ( class <identifiersep> loader , properties , stream ) ) ; } if ( classes . is <identifiersep> empty ( ) ) { log . warn ( <string_literal> ) ; <LOG> log . warn ( <string_literal> , platform <identifiersep> resource , test <identifiersep> platform . class . get <identifiersep> canonical <identifiersep> name ( ) ) ; } else { log . info ( <string_literal> , classes . size ( ) ) ; } cache . put ( class <identifiersep> loader , classes ) ; return classes ; <ect>
if ( type == null ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + classname ) ; return type ; } private void add <identifiersep> platform ( final class < ? > java <identifiersep> class , class < ? extends test <identifiersep> platform > type , int ordinal , int size ) throws throwable { if ( java <identifiersep> class . get <identifiersep> annotation ( ignore . class ) != null ) <comment> <LOG> { return ; } final test <identifiersep> platform test <identifiersep> platform = make <identifiersep> instance ( type ) ; <comment> <ect>
if ( test <identifiersep> platform == null ) return ; final string platform <identifiersep> name = test <identifiersep> platform . get <identifiersep> name ( ) ; if ( ! includes . is <identifiersep> empty ( ) && ! includes . contains ( platform <identifiersep> name . to <identifiersep> lower <identifiersep> case ( ) ) ) { log . info ( <string_literal> , platform <identifiersep> name ) ; <LOG> return ; } platform <identifiersep> suite suite <identifiersep> annotation = java <identifiersep> class . get <identifiersep> annotation ( platform <identifiersep> suite . class ) ; if ( suite <identifiersep> annotation != null ) runners . add ( make <identifiersep> suite <identifiersep> runner ( java <identifiersep> class , suite <identifiersep> annotation . method ( ) , test <identifiersep> platform ) ) ; else runners . add ( make <identifiersep> class <identifiersep> runner ( java <identifiersep> class , test <identifiersep> platform , platform <identifiersep> name , size != 1 ) ) ; <ect>
private static final logger log = logger <identifiersep> factory . get <identifiersep> logger ( compare <identifiersep> platforms <identifiersep> test . class ) ; public static final string nondeterministic = <string_literal> ; public static test suite ( ) throws exception { string root = system . get <identifiersep> property ( <string_literal> ) ; if ( root == null ) <LOG> return new test <identifiersep> suite ( ) ; string [ ] roots = root . split ( <string_literal> ) ; file local <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2tez <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; log . info ( <string_literal> , local <identifiersep> root ) ; <ect>
return new test <identifiersep> suite ( ) ; log . info ( <string_literal> , root ) ; string [ ] roots = root . split ( <string_literal> ) ; file local <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; file hadoop2tez <identifiersep> root = new file ( find ( roots , <string_literal> ) , <string_literal> ) ; <LOG> log . info ( <string_literal> , local <identifiersep> root ) ; log . info ( <string_literal> , hadoop2tez <identifiersep> root ) ; test <identifiersep> suite suite = new test <identifiersep> suite ( ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2root , suite ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2tez <identifiersep> root , suite ) ; return suite ; <ect>
log . info ( <string_literal> , hadoop2tez <identifiersep> root ) ; test <identifiersep> suite suite = new test <identifiersep> suite ( ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2root , suite ) ; create <identifiersep> comparisons ( <string_literal> , local <identifiersep> root , hadoop2tez <identifiersep> root , suite ) ; return suite ; } private static void create <identifiersep> comparisons ( string comparison , file lhs <identifiersep> root , file rhs <identifiersep> root , test <identifiersep> suite suite ) <LOG> { linked <identifiersep> list < file > lhs <identifiersep> files = new linked <identifiersep> list < file > ( file <identifiersep> utils . list <identifiersep> files ( lhs <identifiersep> root , new regex <identifiersep> file <identifiersep> filter ( <string_literal> ) , true <identifiersep> file <identifiersep> filter . instance ) ) ; linked <identifiersep> list < file > rhs <identifiersep> files = new linked <identifiersep> list < file > ( ) ; log . info ( <string_literal> , lhs <identifiersep> files . size ( ) ) ; int root <identifiersep> length = lhs <identifiersep> root . to <identifiersep> string ( ) . length ( ) + 1 ; list <identifiersep> iterator < file > iterator = lhs <identifiersep> files . list <identifiersep> iterator ( ) ; <ect>
file file = new file ( rhs <identifiersep> root , local <identifiersep> file . to <identifiersep> string ( ) . substring ( root <identifiersep> length ) ) ; if ( local <identifiersep> file . to <identifiersep> string ( ) . ends <identifiersep> with ( nondeterministic ) ) iterator . remove ( ) ; else if ( file . exists ( ) ) rhs <identifiersep> files . add ( file ) ; else <LOG> iterator . remove ( ) ; } for ( int i = 0 ; i < lhs <identifiersep> files . size ( ) ; i ++ ) { file local <identifiersep> file = lhs <identifiersep> files . get ( i ) ; file hadoop <identifiersep> file = rhs <identifiersep> files . get ( i ) ; suite . add <identifiersep> test ( new compare <identifiersep> test <identifiersep> case ( comparison , local <identifiersep> file , hadoop <identifiersep> file ) ) ; <ect>
flow third = third <identifiersep> flow ( second . get <identifiersep> sink ( ) , path + <string_literal> + compare <identifiersep> platforms <identifiersep> test . nondeterministic ) ; flow fourth = fourth <identifiersep> flow ( third . get <identifiersep> sink ( ) , path + <string_literal> + compare <identifiersep> platforms <identifiersep> test . nondeterministic ) ; locking <identifiersep> cascade <identifiersep> listener cascade <identifiersep> listener = new locking <identifiersep> cascade <identifiersep> listener ( ) ; locking <identifiersep> flow <identifiersep> listener flow <identifiersep> listener = new locking <identifiersep> flow <identifiersep> listener ( ) ; first . add <identifiersep> listener ( flow <identifiersep> listener ) ; cascade cascade = new cascade <identifiersep> connector ( get <identifiersep> properties ( ) ) . connect ( first , second , third , fourth ) ; <LOG> cascade . add <identifiersep> listener ( cascade <identifiersep> listener ) ; cascade . start ( ) ; assert <identifiersep> true ( <string_literal> , flow <identifiersep> listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , cascade <identifiersep> listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; while ( true ) { <ect>
thread . sleep ( <number_literal> ) ; map < string , flow <identifiersep> step <identifiersep> job > map = flows . get <identifiersep> jobs <identifiersep> map ( first ) ; if ( map == null || map . values ( ) . size ( ) == 0 ) continue ; flow <identifiersep> step <identifiersep> job flow <identifiersep> step <identifiersep> job = map . values ( ) . iterator ( ) . next ( ) ; if ( flow <identifiersep> step <identifiersep> job . is <identifiersep> started ( ) ) <LOG> break ; } cascade . stop ( ) ; assert <identifiersep> true ( <string_literal> , flow <identifiersep> listener . stopped . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , flow <identifiersep> listener . completed . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , cascade <identifiersep> listener . stopped . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , cascade <identifiersep> listener . completed . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; <ect>
streamed <identifiersep> head = handle <identifiersep> head ( streamed <identifiersep> source , flow <identifiersep> process ) ; set < flow <identifiersep> element > accumulated = new hash <identifiersep> set < > ( node . get <identifiersep> source <identifiersep> elements ( ) ) ; accumulated . remove ( streamed <identifiersep> source ) ; hadoop2tez <identifiersep> flow <identifiersep> process tez <identifiersep> process = ( hadoop2tez <identifiersep> flow <identifiersep> process ) flow <identifiersep> process ; tez <identifiersep> configuration conf = tez <identifiersep> process . get <identifiersep> configuration ( ) ; for ( flow <identifiersep> element flow <identifiersep> element : accumulated ) <LOG> { if ( flow <identifiersep> element instanceof tap ) { tap source = ( tap ) flow <identifiersep> element ; <comment> <ect>
{ try { if ( logical <identifiersep> output . is <identifiersep> commit <identifiersep> required ( ) ) commit ( logical <identifiersep> output ) ; } catch ( exception exception ) <LOG> { } } } @ override protected object get <identifiersep> output ( ) { return collector ; } private void commit ( mr <identifiersep> output output ) throws io <identifiersep> exception <ect>
throw exception ; } } <comment> <LOG> { <comment> <ect>
{ try { if ( logical <identifiersep> inputs != null ) { for ( logical <identifiersep> input logical <identifiersep> input : logical <identifiersep> inputs . get <identifiersep> values ( ) ) <LOG> { logical <identifiersep> input . start ( ) ; } } if ( logical <identifiersep> outputs != null ) { for ( logical <identifiersep> output logical <identifiersep> output : logical <identifiersep> outputs ) { <ect>
tuple current <identifiersep> key = ( tuple ) reader . get <identifiersep> current <identifiersep> key ( ) ; value <identifiersep> entry . set <identifiersep> tuple ( current <identifiersep> key ) ; next . receive ( this , 0 , value <identifiersep> entry ) ; } complete ( this ) ; } catch ( throwable throwable ) { <LOG> if ( ! ( throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) return throwable ; } return local <identifiersep> throwable ; } protected output <identifiersep> collector create <identifiersep> output <identifiersep> collector ( ) { if ( logical <identifiersep> outputs . size ( ) == 1 ) <ect>
{ for ( logical <identifiersep> input logical <identifiersep> input : logical <identifiersep> inputs . get <identifiersep> values ( ) ) { log . info ( <string_literal> , logical <identifiersep> input . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , get <identifiersep> splice ( ) , pipe . id ( get <identifiersep> splice ( ) ) , logical <identifiersep> inputs . get <identifiersep> values ( ) . size ( ) ) ; logical <identifiersep> input . start ( ) ; } } if ( logical <identifiersep> output != null ) <LOG> { logical <identifiersep> output . start ( ) ; } } catch ( exception exception ) { throw new cascading <identifiersep> exception ( <string_literal> , exception ) ; } super . prepare ( ) ; <ect>
source <identifiersep> vertices <identifiersep> i <identifiersep> ds . add ( edge <identifiersep> source <identifiersep> flow <identifiersep> node . get <identifiersep> id ( ) ) ; source <identifiersep> vertices . add ( vertex <identifiersep> map . get ( edge <identifiersep> source <identifiersep> flow <identifiersep> node ) ) ; processed <identifiersep> edges . add ( node <identifiersep> graph . get <identifiersep> edge ( edge <identifiersep> source <identifiersep> flow <identifiersep> node , edge <identifiersep> target <identifiersep> flow <identifiersep> node ) ) ; } vertex <identifiersep> group vertex <identifiersep> group = dag . create <identifiersep> vertex <identifiersep> group ( edge <identifiersep> target <identifiersep> flow <identifiersep> node . get <identifiersep> id ( ) , source <identifiersep> vertices . to <identifiersep> array ( new vertex [ source <identifiersep> vertices . size ( ) ] ) ) ; string input <identifiersep> class <identifiersep> name = flow <identifiersep> element instanceof group ? ordered <identifiersep> grouped <identifiersep> merged <identifiersep> kv <identifiersep> input . class . get <identifiersep> name ( ) : concatenated <identifiersep> merged <identifiersep> key <identifiersep> value <identifiersep> input . class . get <identifiersep> name ( ) ; input <identifiersep> descriptor input <identifiersep> descriptor = input <identifiersep> descriptor . create ( input <identifiersep> class <identifiersep> name ) . set <identifiersep> user <identifiersep> payload ( edge <identifiersep> property . get <identifiersep> edge <identifiersep> destination ( ) . get <identifiersep> user <identifiersep> payload ( ) ) ; <LOG> string type = ( ( splice ) flow <identifiersep> element ) . is <identifiersep> merge ( ) ? <string_literal> : <string_literal> ; dag . add <identifiersep> edge ( group <identifiersep> input <identifiersep> edge . create ( vertex <identifiersep> group , target <identifiersep> vertex , edge <identifiersep> property , input <identifiersep> descriptor ) ) ; } else { throw new unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> + flow <identifiersep> element ) ; } } return dag ; <ect>
{ try { sink . delete <identifiersep> resource ( config ) ; } catch ( exception exception ) { <LOG> <comment> <ect>
private void add <identifiersep> remote <identifiersep> debug ( flow <identifiersep> node flow <identifiersep> node , vertex vertex ) { string value = system . get <identifiersep> property ( <string_literal> , null ) ; if ( util . is <identifiersep> empty ( value ) ) return ; if ( ! flow <identifiersep> node . get <identifiersep> source <identifiersep> element <identifiersep> names ( ) . contains ( value ) && as <identifiersep> int ( value ) != flow <identifiersep> node . get <identifiersep> ordinal ( ) ) <LOG> return ; string opts = vertex . get <identifiersep> task <identifiersep> launch <identifiersep> cmd <identifiersep> opts ( ) ; if ( opts == null ) opts = <string_literal> ; string address = system . get <identifiersep> property ( <string_literal> , <string_literal> ) . trim ( ) ; opts += <string_literal> + address + <string_literal> ; <ect>
log . warn ( <string_literal> , <string_literal> , value , flow <identifiersep> node . get <identifiersep> id ( ) ) ; string opts = vertex . get <identifiersep> task <identifiersep> launch <identifiersep> cmd <identifiersep> opts ( ) ; if ( opts == null ) opts = <string_literal> ; string path = system . get <identifiersep> property ( <string_literal> , <string_literal> ) ; if ( ! path . ends <identifiersep> with ( <string_literal> ) ) <LOG> path += <string_literal> ; opts += string . format ( <string_literal> , path , flow <identifiersep> node . get <identifiersep> id ( ) ) ; vertex . set <identifiersep> task <identifiersep> launch <identifiersep> cmd <identifiersep> opts ( opts ) ; } private int as <identifiersep> int ( string value ) { try <ect>
class type = app <identifiersep> props . get <identifiersep> application <identifiersep> jar <identifiersep> class ( properties ) ; if ( type == null ) type = hadoop <identifiersep> util . find <identifiersep> main <identifiersep> class ( hadoop2tez <identifiersep> planner . class ) ; if ( type != null ) application <identifiersep> jar <identifiersep> path = util . find <identifiersep> containing <identifiersep> jar ( type ) ; app <identifiersep> props . set <identifiersep> application <identifiersep> jar <identifiersep> path ( properties , application <identifiersep> jar <identifiersep> path ) ; } <LOG> if ( application <identifiersep> jar <identifiersep> path != null ) else log . info ( <string_literal> ) ; } @ override public void config <identifiersep> rule <identifiersep> registry <identifiersep> defaults ( rule <identifiersep> registry rule <identifiersep> registry ) { <ect>
public void initialize ( ) throws exception { configuration = new tez <identifiersep> configuration ( tez <identifiersep> utils . create <identifiersep> conf <identifiersep> from <identifiersep> user <identifiersep> payload ( get <identifiersep> context ( ) . get <identifiersep> user <identifiersep> payload ( ) ) ) ; tez <identifiersep> util . set <identifiersep> mr <identifiersep> properties ( get <identifiersep> context ( ) , configuration , true ) ; try { <LOG> hadoop <identifiersep> util . init <identifiersep> log4j ( configuration ) ; current <identifiersep> process = new hadoop2tez <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , get <identifiersep> context ( ) , configuration ) ; flow <identifiersep> node = deserialize <identifiersep> base64 ( configuration . get <identifiersep> raw ( flow <identifiersep> node . cascading <identifiersep> flow <identifiersep> node ) , configuration , base <identifiersep> flow <identifiersep> node . class ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , flow <identifiersep> node . get <identifiersep> ordinal ( ) ) ; log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) <ect>
input <identifiersep> source streamed <identifiersep> head ; try { stream <identifiersep> graph = new hadoop2tez <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , input <identifiersep> map , output <identifiersep> map ) ; all <identifiersep> heads = stream <identifiersep> graph . get <identifiersep> heads ( ) ; streamed <identifiersep> head = stream <identifiersep> graph . get <identifiersep> streamed <identifiersep> head ( ) ; <LOG> for ( duct head : all <identifiersep> heads ) for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) log . info ( <string_literal> , ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) , flow <identifiersep> elements . id ( ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) ) ) ; for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) log . info ( <string_literal> , trap , flow <identifiersep> elements . id ( trap ) ) ; } catch ( throwable throwable ) <ect>
all <identifiersep> heads = stream <identifiersep> graph . get <identifiersep> heads ( ) ; streamed <identifiersep> head = stream <identifiersep> graph . get <identifiersep> streamed <identifiersep> head ( ) ; for ( duct head : all <identifiersep> heads ) log . info ( <string_literal> , ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) , head == streamed <identifiersep> head , flow <identifiersep> elements . id ( ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ) ; for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) log . info ( <string_literal> , ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) , flow <identifiersep> elements . id ( ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) ) ) ; <LOG> for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) } catch ( throwable throwable ) { if ( throwable instanceof cascading <identifiersep> exception ) throw ( cascading <identifiersep> exception ) throwable ; throw new flow <identifiersep> exception ( <string_literal> , throwable ) ; <ect>
long begin <identifiersep> input <identifiersep> ready = system . current <identifiersep> time <identifiersep> millis ( ) ; hash <identifiersep> set < input > inputs = new hash <identifiersep> set < input > ( input <identifiersep> map . values ( ) ) ; get <identifiersep> context ( ) . wait <identifiersep> for <identifiersep> all <identifiersep> inputs <identifiersep> ready ( inputs ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , inputs . size ( ) , util . format <identifiersep> duration <identifiersep> hm <identifiersep> sms ( system . current <identifiersep> time <identifiersep> millis ( ) - begin <identifiersep> input <identifiersep> ready ) ) ; } @ override public void handle <identifiersep> events ( list < event > events ) <LOG> { } @ override public void close ( ) throws exception { string message = <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) ; log <identifiersep> memory ( log , message + <string_literal> ) ; <ect>
if ( ! util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) configuration . set ( <string_literal> , system . get <identifiersep> property ( <string_literal> ) ) ; else configuration . set ( <string_literal> , <string_literal> ) ; file <identifiersep> sys = file <identifiersep> system . get ( configuration ) ; } else <LOG> { if ( util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; if ( util . is <identifiersep> empty ( system . get <identifiersep> property ( <string_literal> ) ) ) system . set <identifiersep> property ( <string_literal> , <string_literal> ) ; new file ( system . get <identifiersep> property ( <string_literal> ) ) . mkdirs ( ) ; <comment> <ect>
return ( size + <number_literal> ) / <number_literal> ; } <comment> <LOG> public static void bytes <identifiersep> to <identifiersep> bits ( byte [ ] b , bit <identifiersep> set ba , int max <identifiersep> size ) { int x = 0 ; for ( byte bi : b ) { for ( int j = 0 ; j < <number_literal> ; j ++ ) { if ( x > max <identifiersep> size ) break ; int mask = 1 < < j ; <ect>
public void run ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { try { real <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void real <identifiersep> run ( ) { long now = system . current <identifiersep> time <identifiersep> millis ( ) ; list < job > jobs <identifiersep> to <identifiersep> run = null ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + r ) ; if ( r . job instanceof fast <identifiersep> runnable ) <comment> <LOG> } catch ( throwable t ) { } else try { executor . execute ( r . job , r . name , true ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <ect>
} catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> + r , t ) ; } else try { executor . execute ( r . job , r . name , true ) ; } catch ( throwable t ) { <LOG> logger . error ( this , <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; queue <identifiersep> timed <identifiersep> job ( r . job , r . name , <number_literal> , true , false ) ; } } if ( sleep <identifiersep> time > 0 ) { try { <ect>
ok = true ; for ( int i = 0 ; ok && i < keys . length ; ++ i ) { key <identifiersep> index = keys [ i ] %modulo ; <comment> <LOG> collision <identifiersep> table [ key <identifiersep> index ] = modulo ; } } } chars = new char [ modulo ] ; strings = new string [ modulo ] ; for ( map . entry < character , string > entry : map . entry <identifiersep> set ( ) ) { character character = entry . get <identifiersep> key ( ) ; key <identifiersep> index = character . char <identifiersep> value ( ) %modulo ; <ect>
buf [ j ] = ( byte ) x ; x > > >= <number_literal> ; } return buf ; } public static long parse <identifiersep> long ( string s , long default <identifiersep> value ) { try { return long . parse <identifiersep> long ( s ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return default <identifiersep> value ; } } public static int parse <identifiersep> int ( string s , int default <identifiersep> value ) { try { return integer . parse <identifiersep> int ( s ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <ect>
try { wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { } <comment> <LOG> } catch ( interrupted <identifiersep> exception e ) { } } } } @ override public executor get <identifiersep> executor ( ) { return executor ; } @ override public void queue <identifiersep> timed <identifiersep> job <identifiersep> absolute ( runnable runner , string name , long time , <ect>
<comment> public static void main ( string [ ] args ) { decaying <identifiersep> keyspace <identifiersep> average a = new decaying <identifiersep> keyspace <identifiersep> average ( 0 . <number_literal> , <number_literal> , null ) ; a . report ( 0 . <number_literal> ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { <LOG> a . report ( 0 . <number_literal> ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } system . out . println ( <string_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { <ect>
a . report ( 0 . <number_literal> ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; <LOG> system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; <ect>
a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } system . out . println ( <string_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { <LOG> a . report ( 0 . <number_literal> ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; <ect>
a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { <LOG> a . report ( 0 . <number_literal> ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } } system . out . println ( <string_literal> ) ; a = new decaying <identifiersep> keyspace <identifiersep> average ( 0 . <number_literal> , <number_literal> , null ) ; <ect>
system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; <LOG> system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } } a = new decaying <identifiersep> keyspace <identifiersep> average ( 0 . <number_literal> , <number_literal> , null ) ; a . report ( 0 . <number_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { <ect>
system . out . println ( <string_literal> ) ; a = new decaying <identifiersep> keyspace <identifiersep> average ( 0 . <number_literal> , <number_literal> , null ) ; a . report ( 0 . <number_literal> ) ; for ( int wrap = <number_literal> ; wrap != 0 ; wrap -- ) { system . out . println ( <string_literal> + wrap ) ; for ( int i = <number_literal> ; i != 0 ; i -- ) { <LOG> a . report ( 0 . <number_literal> ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; <ect>
a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 0 . <number_literal> ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { <LOG> a . report ( 0 . <number_literal> ) ; } for ( int i = <number_literal> ; i != 0 ; i -- ) { a . report ( 1 . 0 ) ; system . out . println ( <string_literal> + a . current <identifiersep> value ( ) ) ; } } } } <ect>
<comment> @ override public synchronized void report ( double d ) { if ( d < min ) { <LOG> if ( log <identifiersep> debug ) d = min ; } if ( d > max ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + d , new exception ( <string_literal> ) ) ; d = max ; <ect>
<comment> @ override public synchronized double value <identifiersep> if <identifiersep> reported ( double d ) { <LOG> if ( d < min ) { d = min ; } if ( d > max ) { logger . error ( this , <string_literal> + d , new exception ( <string_literal> ) ) ; d = max ; } double decay <identifiersep> factor = 1 . 0 / ( math . min ( reports + 1 , max <identifiersep> reports ) ) ; <ect>
<comment> @ override public void report ( double d ) { synchronized ( this ) { <comment> <LOG> if ( d < min <identifiersep> report ) { return ; } if ( d > max <identifiersep> report ) { logger . error ( this , <string_literal> + d + <string_literal> + this , new exception ( <string_literal> ) ) ; return ; } if ( double . is <identifiersep> infinite ( d ) || double . is <identifiersep> na <identifiersep> n ( d ) ) { <ect>
if ( d < min <identifiersep> report ) { logger . error ( this , <string_literal> + d + <string_literal> + this , new exception ( <string_literal> ) ) ; return ; } if ( d > max <identifiersep> report ) { logger . error ( this , <string_literal> + d + <string_literal> + this , new exception ( <string_literal> ) ) ; return ; } <LOG> if ( double . is <identifiersep> infinite ( d ) || double . is <identifiersep> na <identifiersep> n ( d ) ) { return ; } total <identifiersep> reports ++ ; if ( ! started ) { cur <identifiersep> value = d ; started = true ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + d + <string_literal> + this + <string_literal> ) ; } else if ( last <identifiersep> report <identifiersep> time != - 1 ) { <comment> <LOG> if ( this <identifiersep> interval < 0 ) { last <identifiersep> report <identifiersep> time = now ; if ( time <identifiersep> skew <identifiersep> callback != null ) time <identifiersep> skew <identifiersep> callback . set <identifiersep> time <identifiersep> skew <identifiersep> detected <identifiersep> user <identifiersep> alert ( ) ; return ; } double this <identifiersep> half <identifiersep> life = half <identifiersep> life ; <ect>
double change <identifiersep> factor = math . pow ( 0 . <number_literal> , ( this <identifiersep> interval ) / this <identifiersep> half <identifiersep> life ) ; double old <identifiersep> cur <identifiersep> value = cur <identifiersep> value ; cur <identifiersep> value = cur <identifiersep> value * change <identifiersep> factor <comment> + ( 1 . 0 - change <identifiersep> factor ) * d ; <comment> <LOG> if ( cur <identifiersep> value < min <identifiersep> report || cur <identifiersep> value > max <identifiersep> report ) { cur <identifiersep> value = old <identifiersep> cur <identifiersep> value ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + d + <string_literal> + this + <string_literal> + this <identifiersep> interval + <string_literal> + half <identifiersep> life + <string_literal> + uptime + <string_literal> + this <identifiersep> half <identifiersep> life + <string_literal> + change <identifiersep> factor + <string_literal> + old <identifiersep> cur <identifiersep> value + <ect>
system . err . println ( <string_literal> + wiped <identifiersep> files + <string_literal> + ( i - wipeable <identifiersep> files ) + <string_literal> ) ; file f = filenames [ i ] ; string name = f . get <identifiersep> name ( ) ; if ( ( ( ( file . separator <identifiersep> char == ' \\ \\ ' ) && name . to <identifiersep> lower <identifiersep> case ( ) . starts <identifiersep> with ( prefix . to <identifiersep> lower <identifiersep> case ( ) ) ) || name . starts <identifiersep> with ( prefix ) ) ) { wipeable <identifiersep> files ++ ; <LOG> if ( ( ! f . delete ( ) ) && f . exists ( ) ) else wiped <identifiersep> files ++ ; } } long end <identifiersep> wipe = system . current <identifiersep> time <identifiersep> millis ( ) ; system . err . println ( <string_literal> + wiped <identifiersep> files + <string_literal> + wipeable <identifiersep> files + <string_literal> + ( filenames . length - wipeable <identifiersep> files ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> wipe - start <identifiersep> wipe ) ) ; } } } public long make <identifiersep> random <identifiersep> filename ( ) throws io <identifiersep> exception { <ect>
public file maybe <identifiersep> move ( file file , long id ) { if ( matches ( file ) ) return file ; file new <identifiersep> file = get <identifiersep> filename ( id ) ; logger . normal ( this , <string_literal> + file + <string_literal> + new <identifiersep> file ) ; if ( file <identifiersep> util . move <identifiersep> to ( file , new <identifiersep> file , false ) ) return new <identifiersep> file ; <LOG> else { return file ; } } } <ect>
public static final int high <identifiersep> priority = priority <identifiersep> level . high <identifiersep> priority . value ; @ deprecated public static final int max <identifiersep> priority = priority <identifiersep> level . max <identifiersep> priority . value ; static { logger . minor ( native <identifiersep> thread . class , <string_literal> ) ; <comment> <LOG> boolean maybe <identifiersep> load <identifiersep> native = platform . is <identifiersep> linux ( ) ; if ( maybe <identifiersep> load <identifiersep> native ) { native <identifiersep> priority <identifiersep> base = linux <identifiersep> native <identifiersep> thread . getpriority ( 0 , 0 ) ; native <identifiersep> priority <identifiersep> range = <number_literal> - native <identifiersep> priority <identifiersep> base ; system . out . println ( <string_literal> + native <identifiersep> priority <identifiersep> base + ' ) ' ) ; <comment> <ect>
public void finish <identifiersep> delayed <identifiersep> free ( delayed <identifiersep> free [ ] buckets ) { if ( buckets != null ) { for ( delayed <identifiersep> free bucket : buckets ) { try { if ( bucket . to <identifiersep> free ( ) ) bucket . real <identifiersep> free ( ) ; <LOG> } catch ( throwable t ) { } } } } @ override public boolean check <identifiersep> disk <identifiersep> space ( file file , int to <identifiersep> write , int buffer <identifiersep> size ) { return checker . check <identifiersep> disk <identifiersep> space ( file , to <identifiersep> write , buffer <identifiersep> size ) ; } } <ect>
public void free ( ) { close ( ) ; if ( ! delete <identifiersep> on <identifiersep> free ) return ; if ( secure <identifiersep> delete ) { try { file <identifiersep> util . secure <identifiersep> delete ( file ) ; <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + file ) ; } } else { file . delete ( ) ; } } boolean is <identifiersep> open ( ) { synchronized ( fds ) { <ect>
protected void set <identifiersep> delete <identifiersep> on <identifiersep> exit ( file file ) { try { file . delete <identifiersep> on <identifiersep> exit ( ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) { if ( wrapper <identifiersep> manager . has <identifiersep> shutdown <identifiersep> hook <identifiersep> been <identifiersep> triggered ( ) ) { logger . normal ( this , <string_literal> + e , e ) ; <LOG> } else { } } } @ override public output <identifiersep> stream get <identifiersep> output <identifiersep> stream <identifiersep> unbuffered ( ) throws io <identifiersep> exception { synchronized ( this ) { file file = get <identifiersep> file ( ) ; if ( freed ) <ect>
logger . error ( this , <string_literal> + this + <string_literal> + streams , new exception ( <string_literal> ) ) ; boolean rename = ! temp <identifiersep> file <identifiersep> already <identifiersep> exists ( ) ; file tempfile = rename ? get <identifiersep> tempfile ( ) : file ; long stream <identifiersep> number = ++ file <identifiersep> restart <identifiersep> counter ; file <identifiersep> bucket <identifiersep> output <identifiersep> stream os = new file <identifiersep> bucket <identifiersep> output <identifiersep> stream ( tempfile , stream <identifiersep> number ) ; <LOG> if ( log <identifiersep> debug ) add <identifiersep> stream ( os ) ; return os ; } } @ override public output <identifiersep> stream get <identifiersep> output <identifiersep> stream ( ) throws io <identifiersep> exception { return new buffered <identifiersep> output <identifiersep> stream ( get <identifiersep> output <identifiersep> stream <identifiersep> unbuffered ( ) ) ; <ect>
logger . minor ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; synchronized ( this ) { if ( freed ) return ; freed = true ; to <identifiersep> close = streams == null ? null : streams . to <identifiersep> array ( new closeable [ streams . size ( ) ] ) ; streams = null ; } <LOG> if ( to <identifiersep> close != null ) { for ( closeable strm : to <identifiersep> close ) { try { strm . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
logger . error ( this , <string_literal> + this + <string_literal> + arrays . to <identifiersep> string ( to <identifiersep> close ) , new exception ( <string_literal> ) ) ; for ( closeable strm : to <identifiersep> close ) { try { strm . close ( ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <LOG> } catch ( throwable t ) { } } } file file = get <identifiersep> file ( ) ; if ( ( delete <identifiersep> on <identifiersep> free ( ) || force <identifiersep> free ) && file . exists ( ) ) { logger . debug ( this , <string_literal> + file , new exception ( <string_literal> ) ) ; delete <identifiersep> file ( ) ; <ect>
file = new file ( file . get <identifiersep> path ( ) ) ; this . read <identifiersep> only = read <identifiersep> only ; this . create <identifiersep> file <identifiersep> only = create <identifiersep> file <identifiersep> only ; this . file = file ; this . delete <identifiersep> on <identifiersep> free = delete <identifiersep> on <identifiersep> free ; this . delete <identifiersep> on <identifiersep> exit = delete <identifiersep> on <identifiersep> exit ; <LOG> <comment> <ect>
<comment> public static void close ( closeable closable ) { if ( closable != null ) { try { closable . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } } <comment> public static void close ( bucket bucket ) { <ect>
<comment> public static void close ( zip <identifiersep> file zip <identifiersep> file ) { if ( zip <identifiersep> file != null ) { try { zip <identifiersep> file . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } } } <ect>
@ override public void free ( ) { close ( ) ; if ( secure <identifiersep> delete ) { try { file <identifiersep> util . secure <identifiersep> delete ( file ) ; <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + file ) ; } } else { file . delete ( ) ; } } public void set <identifiersep> secure <identifiersep> delete ( boolean secure <identifiersep> delete ) { this . secure <identifiersep> delete = secure <identifiersep> delete ; <ect>
return operating <identifiersep> system . free <identifiersep> bsd ; if ( name . index <identifiersep> of ( <string_literal> ) >= 0 ) return operating <identifiersep> system . generic <identifiersep> unix ; else if ( file . separator <identifiersep> char == ' / ' ) return operating <identifiersep> system . generic <identifiersep> unix ; else if ( file . separator <identifiersep> char == ' \\ \\ ' ) <LOG> return operating <identifiersep> system . windows ; } catch ( throwable t ) { logger . error ( file <identifiersep> util . class , <string_literal> , t ) ; } return operating <identifiersep> system . unknown ; } private static cpu <identifiersep> architecture detect <identifiersep> cpu <identifiersep> architecture ( ) { <comment> <ect>
if ( name . equals ( <string_literal> ) || name . equals ( <string_literal> ) ) return cpu <identifiersep> architecture . ppc <identifiersep> <number_literal> ; if ( name . equals ( <string_literal> ) ) return cpu <identifiersep> architecture . ppc <identifiersep> <number_literal> ; if ( name . starts <identifiersep> with ( <string_literal> ) ) return cpu <identifiersep> architecture . ia64 ; <LOG> } catch ( throwable t ) { } return cpu <identifiersep> architecture . unknown ; } <comment> <ect>
if ( ! orig . exists ( ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( ! orig . rename <identifiersep> to ( dest ) ) { <comment> <LOG> logger . error ( <string_literal> , <string_literal> + dest + <string_literal> ) ; } } if ( ! orig . rename <identifiersep> to ( dest ) ) { string err = <string_literal> + orig + <string_literal> + dest + ( dest . exists ( ) ? <string_literal> : <string_literal> ) + ( orig . exists ( ) ? <string_literal> : <string_literal> ) + <string_literal> ; <ect>
case unknown : break ; case mac <identifiersep> os : break ; case linux : break ; case free <identifiersep> bsd : break ; case generic <identifiersep> unix : break ; case windows : break ; <LOG> default : target <identifiersep> os = operating <identifiersep> system . unknown ; break ; } char def = ' ' ; if ( extra <identifiersep> chars . index <identifiersep> of ( ' ' ) != - 1 ) { def = ' <identifiersep> ' ; <ect>
remaining -= read ; } } public static boolean secure <identifiersep> delete <identifiersep> all ( file wd ) throws io <identifiersep> exception { if ( ! wd . is <identifiersep> directory ( ) ) { system . err . println ( <string_literal> + wd ) ; try { secure <identifiersep> delete ( wd ) ; <LOG> } catch ( io <identifiersep> exception e ) { return false ; } } else { for ( file subfile : wd . list <identifiersep> files ( ) ) { if ( ! remove <identifiersep> all ( subfile ) ) return false ; } if ( ! wd . delete ( ) ) { <ect>
if ( ! wd . delete ( ) ) { logger . error ( file <identifiersep> util . class , <string_literal> + wd ) ; } } return true ; } <comment> public static boolean remove <identifiersep> all ( file wd ) { <LOG> if ( ! wd . is <identifiersep> directory ( ) ) { if ( ! wd . delete ( ) && wd . exists ( ) ) { logger . error ( file <identifiersep> util . class , <string_literal> + wd ) ; return false ; } } else { for ( file subfile : wd . list <identifiersep> files ( ) ) { <ect>
if ( ! wd . delete ( ) && wd . exists ( ) ) { logger . error ( file <identifiersep> util . class , <string_literal> + wd ) ; return false ; } } else { for ( file subfile : wd . list <identifiersep> files ( ) ) { if ( ! remove <identifiersep> all ( subfile ) ) return false ; } <LOG> if ( ! wd . delete ( ) ) { } } return true ; } public static void secure <identifiersep> delete ( file file ) throws io <identifiersep> exception { <comment> <ect>
protected void finalize ( ) throws throwable { <comment> <LOG> else free ( ) ; } super . finalize ( ) ; } @ override public long creation <identifiersep> time ( ) { return creation <identifiersep> time ; <ect>
<comment> <LOG> logger . error ( this , <string_literal> ) ; said <identifiersep> so = true ; } try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e1 ) { <comment> <ect>
synchronized ( temp <identifiersep> bucket <identifiersep> factory . this ) { if ( bytes <identifiersep> in <identifiersep> use < = max <identifiersep> ram <identifiersep> used * max <identifiersep> usage <identifiersep> low ) return ; } try { if ( ! clean <identifiersep> bucket <identifiersep> queue ( system . current <identifiersep> time <identifiersep> millis ( ) , true ) ) return ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { if ( ! said <identifiersep> so ) { <LOG> logger . error ( this , <string_literal> ) ; said <identifiersep> so = true ; } try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e1 ) { <comment> <ect>
@ override protected void finalize ( ) throws throwable { if ( original != null ) return ; <comment> <LOG> if ( trace <identifiersep> bucket <identifiersep> leaks ) else logger . error ( this , <string_literal> + size ( ) + <string_literal> + this ) ; free ( ) ; } super . finalize ( ) ; } } @ override <ect>
lockable <identifiersep> random <identifiersep> access <identifiersep> buffer ret = disk <identifiersep> raf <identifiersep> factory . make <identifiersep> raf ( padded <identifiersep> size ) ; if ( encrypt ) { if ( real <identifiersep> size != padded <identifiersep> size ) ret = new padded <identifiersep> random <identifiersep> access <identifiersep> buffer ( ret , real <identifiersep> size ) ; try { ret = new encrypted <identifiersep> random <identifiersep> access <identifiersep> buffer ( crypt <identifiersep> type , ret , secret , true ) ; <LOG> } catch ( general <identifiersep> security <identifiersep> exception e ) { } } return ret ; } } @ override public lockable <identifiersep> random <identifiersep> access <identifiersep> buffer make <identifiersep> raf ( byte [ ] initial <identifiersep> contents , int offset , int size , boolean read <identifiersep> only ) throws io <identifiersep> exception { if ( size < 0 ) throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; <ect>
throw new insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception ( ) ; } } finally { if ( ret == null ) file . delete ( ) ; lock . unlock ( ) ; } } @ override public boolean check <identifiersep> disk <identifiersep> space ( file file , int to <identifiersep> write , int buffer <identifiersep> size ) { <LOG> if ( ! file <identifiersep> util . is <identifiersep> parent ( dir , file ) ) { return true ; } lock . lock ( ) ; try { if ( dir . get <identifiersep> usable <identifiersep> space ( ) - ( to <identifiersep> write + buffer <identifiersep> size ) < min <identifiersep> disk <identifiersep> space ) return false ; <ect>
logger . error ( this , <string_literal> , e ) ; return null ; } <comment> <LOG> } catch ( unknown <identifiersep> host <identifiersep> exception ex ) { return null ; } return ds . get <identifiersep> local <identifiersep> address ( ) ; } finally { if ( ds != null ) { ds . close ( ) ; <ect>
thread . sleep ( interval ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> } catch ( throwable t ) { } } } <comment> public void clear <identifiersep> cached ( ) { last <identifiersep> address <identifiersep> list = null ; <ect>
<comment> <LOG> if ( ! hn . matches ( <string_literal> ) ) { return false ; } return true ; } } <ect>
logger . error ( this , <string_literal> + i + <string_literal> + blocks . length + <string_literal> + block . reqs . length + <string_literal> + block <identifiersep> size ) ; } for ( int j = 0 ; j < block . reqs . length ; j ++ ) { if ( x >= index ) break ; if ( block . reqs [ j ] == req ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + req + <string_literal> + this + <string_literal> + index ) ; return ; } <LOG> if ( block . reqs [ j ] == null ) { } x ++ ; } } if ( blocks . length < = target <identifiersep> block ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; block [ ] new <identifiersep> blocks = arrays . copy <identifiersep> of ( blocks , target <identifiersep> block + 1 ) ; <ect>
break ; } } } if ( index == 0 ) empty = true ; } } <comment> <LOG> else if ( old <identifiersep> array != null ) if ( ! matched ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + it + <string_literal> + this ) ; return ; } if ( empty && parent != null ) { parent . maybe <identifiersep> remove ( this , context ) ; <ect>
public int get <identifiersep> priority ( ) { return priority ; } @ override public void run ( ) { synchronized ( jobs ) { if ( current != null ) { <LOG> if ( current . is <identifiersep> alive ( ) ) { return ; } } current = thread . current <identifiersep> thread ( ) ; } try { boolean called <identifiersep> idle <identifiersep> callback = false ; while ( true ) { <ect>
job . run ( ) ; long end = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> + job + <string_literal> + ( end - start ) + <string_literal> ) ; } if ( statistics != null ) { statistics . report <identifiersep> database <identifiersep> job ( job . to <identifiersep> string ( ) , end - start ) ; } <LOG> } catch ( throwable t ) { logger . error ( this , <string_literal> + job + <string_literal> + this ) ; } } } finally { synchronized ( jobs ) { current = null ; running = false ; <ect>
empty = false ; break ; } } if ( ! empty ) really <identifiersep> start ( ) ; } } private void really <identifiersep> start ( ) { synchronized ( jobs ) { <LOG> if ( running ) { return ; } running = true ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + name + <string_literal> + runner , new exception ( <string_literal> ) ) ; real <identifiersep> executor . execute ( runner , name ) ; } } @ override <ect>
if ( ! background ) { if ( platform . is <identifiersep> windows ( ) ) { windows <identifiersep> holder lib = windows <identifiersep> holder . instance ; if ( lib . set <identifiersep> priority <identifiersep> class ( lib . get <identifiersep> current <identifiersep> process ( ) , windows <identifiersep> holder . process <identifiersep> mode <identifiersep> background <identifiersep> begin ) ) { system . out . println ( <string_literal> ) ; return background = true ; <LOG> } else if ( lib . get <identifiersep> last <identifiersep> error ( ) . equals ( windows <identifiersep> holder . error <identifiersep> process <identifiersep> mode <identifiersep> already <identifiersep> background ) ) { return false ; } } else if ( platform . is <identifiersep> linux ( ) ) { return handle <identifiersep> return ( linux <identifiersep> holder . setpriority ( linux <identifiersep> holder . prio <identifiersep> process , linux <identifiersep> holder . myself , linux <identifiersep> holder . lower <identifiersep> priority ) ) ; } else if ( platform . is <identifiersep> mac ( ) ) { return handle <identifiersep> return ( osx <identifiersep> holder . setpriority ( osx <identifiersep> holder . prio <identifiersep> darwin <identifiersep> thread , osx <identifiersep> holder . myself , osx <identifiersep> holder . prio <identifiersep> darwin <identifiersep> bg ) ) ; <ect>
return handle <identifiersep> return ( osx <identifiersep> holder . setpriority ( osx <identifiersep> holder . prio <identifiersep> darwin <identifiersep> thread , osx <identifiersep> holder . myself , osx <identifiersep> holder . prio <identifiersep> darwin <identifiersep> bg ) ) ; } } return background ; } private static boolean handle <identifiersep> return ( int ret ) { if ( ret == 0 ) { system . out . println ( <string_literal> ) ; return background = true ; <LOG> } else { return false ; } } } <ect>
closer . close ( br ) ; } if ( null != read <identifiersep> line ) { try { string [ ] proc <identifiersep> fields = read <identifiersep> line . trim ( ) . split ( <string_literal> ) ; if ( <number_literal> < = proc <identifiersep> fields . length ) { return proc <identifiersep> fields [ field <identifiersep> number ] ; } <LOG> } catch ( pattern <identifiersep> syntax <identifiersep> exception e ) { } } } else { closer . close ( is ) ; } } return null ; } <comment> <ect>
synchronized ( root ) { long wakeup <identifiersep> time = long . max <identifiersep> value ; <comment> <LOG> if ( rga == null ) { if ( grab <identifiersep> arrays [ 1 - x ] == null ) { logger . error ( this , <string_literal> + this ) ; grab <identifiersep> arrays = new <identifiersep> grabber <identifiersep> array ( 0 ) ; grab <identifiersep> clients = new <identifiersep> client <identifiersep> array ( 0 ) ; return null ; <ect>
logger . error ( this , <string_literal> + this ) ; if ( grab <identifiersep> arrays [ 1 - x ] == null ) { logger . error ( this , <string_literal> + this ) ; grab <identifiersep> arrays = new <identifiersep> grabber <identifiersep> array ( 0 ) ; grab <identifiersep> clients = new <identifiersep> client <identifiersep> array ( 0 ) ; return null ; <LOG> } else { grab <identifiersep> arrays = as <identifiersep> grabber <identifiersep> array ( grab <identifiersep> arrays [ 1 - x ] ) ; grab <identifiersep> clients = as <identifiersep> client <identifiersep> array ( grab <identifiersep> clients [ 1 - x ] ) ; return null ; } } random <identifiersep> grab <identifiersep> array <identifiersep> item item = null ; remove <identifiersep> random <identifiersep> return val = null ; <ect>
<comment> <LOG> if ( rga == null ) { <comment> <ect>
m <identifiersep> name = my <identifiersep> name ; m <identifiersep> ticker = new trivial <identifiersep> ticker ( m <identifiersep> node . executor ) ; } <comment> <LOG> public void start ( ) { m <identifiersep> ticker . queue <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , get <identifiersep> startup <identifiersep> delay ( ) , false , true ) ; } <comment> @ override public abstract int get <identifiersep> priority ( ) ; @ override <ect>
public void run ( ) { long sleep <identifiersep> time = seconds . to <identifiersep> millis ( 1 ) ; try { logger . debug ( this , <string_literal> ) ; iterate ( ) ; sleep <identifiersep> time = get <identifiersep> sleep <identifiersep> time ( ) ; } <LOG> catch ( exception e ) { } finally { logger . debug ( this , <string_literal> + minutes . convert ( sleep <identifiersep> time , milliseconds ) + <string_literal> ) ; m <identifiersep> ticker . queue <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , sleep <identifiersep> time , false , true ) ; } } <comment> <ect>
m <identifiersep> ticker . queue <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , sleep <identifiersep> time , false , true ) ; } } <comment> public void next <identifiersep> iteration ( ) { m <identifiersep> ticker . reschedule <identifiersep> timed <identifiersep> job ( this , m <identifiersep> name , 0 ) ; } <LOG> protected void abort <identifiersep> all <identifiersep> transfers ( ) { abort <identifiersep> fetches ( ) ; abort <identifiersep> inserts ( ) ; } protected void abort <identifiersep> fetches ( ) { logger . debug ( this , <string_literal> ) ; if ( m <identifiersep> fetches != null ) synchronized ( m <identifiersep> fetches ) { <ect>
if ( m <identifiersep> fetches != null ) synchronized ( m <identifiersep> fetches ) { client <identifiersep> getter [ ] fetches = m <identifiersep> fetches . to <identifiersep> array ( new client <identifiersep> getter [ m <identifiersep> fetches . size ( ) ] ) ; int fcounter = 0 ; for ( client <identifiersep> getter fetch : fetches ) { <comment> fetch . cancel ( m <identifiersep> node . client <identifiersep> core . client <identifiersep> context ) ; <LOG> ++ fcounter ; } } } protected void abort <identifiersep> inserts ( ) { logger . debug ( this , <string_literal> ) ; if ( m <identifiersep> inserts != null ) synchronized ( m <identifiersep> inserts ) { base <identifiersep> client <identifiersep> putter [ ] inserts = m <identifiersep> inserts . to <identifiersep> array ( new base <identifiersep> client <identifiersep> putter [ m <identifiersep> inserts . size ( ) ] ) ; int icounter = 0 ; <ect>
if ( m <identifiersep> inserts != null ) synchronized ( m <identifiersep> inserts ) { base <identifiersep> client <identifiersep> putter [ ] inserts = m <identifiersep> inserts . to <identifiersep> array ( new base <identifiersep> client <identifiersep> putter [ m <identifiersep> inserts . size ( ) ] ) ; int icounter = 0 ; for ( base <identifiersep> client <identifiersep> putter insert : inserts ) { <comment> insert . cancel ( m <identifiersep> node . client <identifiersep> core . client <identifiersep> context ) ; <LOG> ++ icounter ; } } } protected void add <identifiersep> fetch ( client <identifiersep> getter g ) { synchronized ( m <identifiersep> fetches ) { m <identifiersep> fetches . add ( g ) ; } } protected void remove <identifiersep> fetch ( client <identifiersep> getter g ) { synchronized ( m <identifiersep> fetches ) { <ect>
logger . debug ( this , <string_literal> + g . get <identifiersep> uri ( ) ) ; } protected void add <identifiersep> insert ( base <identifiersep> client <identifiersep> putter p ) { synchronized ( m <identifiersep> inserts ) { m <identifiersep> inserts . add ( p ) ; } } protected void remove <identifiersep> insert ( base <identifiersep> client <identifiersep> putter p ) { synchronized ( m <identifiersep> inserts ) { <LOG> m <identifiersep> inserts . remove ( p ) ; } } protected int fetch <identifiersep> count ( ) { synchronized ( m <identifiersep> fetches ) { return m <identifiersep> fetches . size ( ) ; } } protected int insert <identifiersep> count ( ) { synchronized ( m <identifiersep> inserts ) { <ect>
return m <identifiersep> inserts . size ( ) ; } } public void terminate ( ) { logger . debug ( this , <string_literal> ) ; m <identifiersep> ticker . shutdown ( ) ; try { abort <identifiersep> all <identifiersep> transfers ( ) ; } <LOG> catch ( runtime <identifiersep> exception e ) { } logger . debug ( this , <string_literal> ) ; } protected abstract collection < client <identifiersep> getter > create <identifiersep> fetch <identifiersep> storage ( ) ; protected abstract collection < base <identifiersep> client <identifiersep> putter > create <identifiersep> insert <identifiersep> storage ( ) ; protected abstract long get <identifiersep> startup <identifiersep> delay ( ) ; protected abstract long get <identifiersep> sleep <identifiersep> time ( ) ; <ect>
if ( job == null ) { synchronized ( sync <identifiersep> lock ) { thread <identifiersep> started = false ; } return ; } try { job . run ( ) ; <LOG> } catch ( throwable t ) { logger . error ( this , <string_literal> + job + <string_literal> + this ) ; } } } finally { synchronized ( sync <identifiersep> lock ) { running <identifiersep> thread = null ; } } } } ; <ect>
<comment> <LOG> <comment> <ect>
boolean first <identifiersep> line = true ; boolean header <identifiersep> section = true ; list < string > headers = new array <identifiersep> list < string > ( ) ; while ( true ) { string line = br . read <identifiersep> line ( max <identifiersep> length , buffer <identifiersep> size , utf <identifiersep> or <identifiersep> iso88591 ) ; if ( line == null ) { <LOG> if ( first <identifiersep> line ) throw new eof <identifiersep> exception ( ) ; break ; } if ( ( line . length ( ) == 0 ) ) continue ; <comment> <ect>
logger . error ( this , <string_literal> + e + <string_literal> , e ) ; } return sw . to <identifiersep> string ( ) ; } public string to <identifiersep> ordered <identifiersep> string ( ) { string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; try { write <identifiersep> to <identifiersep> ordered ( sw ) ; <LOG> } catch ( io <identifiersep> exception e ) { } return sw . to <identifiersep> string ( ) ; } public string to <identifiersep> ordered <identifiersep> string <identifiersep> with <identifiersep> base64 ( ) { string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; try { write <identifiersep> to <identifiersep> ordered ( sw , <string_literal> , false , true ) ; <ect>
input <identifiersep> stream <identifiersep> reader isr = null ; buffered <identifiersep> reader br = null ; try { bis = new buffered <identifiersep> input <identifiersep> stream ( is ) ; try { isr = new input <identifiersep> stream <identifiersep> reader ( bis , <string_literal> ) ; <LOG> } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { is . close ( ) ; throw new error ( <string_literal> + e , e ) ; } br = new buffered <identifiersep> reader ( isr ) ; simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( br , allow <identifiersep> multiple , short <identifiersep> lived , allow <identifiersep> base64 , always <identifiersep> base64 ) ; br . close ( ) ; <ect>
string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; int [ ] ret = new int [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { try { ret [ i ] = integer . parse <identifiersep> int ( strings [ i ] ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return null ; } } return ret ; } public short [ ] get <identifiersep> short <identifiersep> array ( string key ) { string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; <ect>
string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; long [ ] ret = new long [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { try { ret [ i ] = long . parse <identifiersep> long ( strings [ i ] ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return null ; } } return ret ; } public double [ ] get <identifiersep> double <identifiersep> array ( string key ) { string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; <ect>
log <identifiersep> stream . close ( ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; } if ( alt <identifiersep> log <identifiersep> stream != null ) { try { alt <identifiersep> log <identifiersep> stream . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } synchronized ( list ) { closed <identifiersep> finished = true ; list . notify <identifiersep> all ( ) ; } return ; } if ( o == null ) continue ; <ect>
public void trim <identifiersep> old <identifiersep> log <identifiersep> files ( ) { synchronized ( trim <identifiersep> old <identifiersep> log <identifiersep> files <identifiersep> lock ) { while ( old <identifiersep> log <identifiersep> files <identifiersep> disk <identifiersep> space <identifiersep> usage > max <identifiersep> old <identifiersep> logfiles <identifiersep> disk <identifiersep> usage ) { old <identifiersep> log <identifiersep> file olf ; <comment> <LOG> if ( log <identifiersep> files . is <identifiersep> empty ( ) ) { } olf = log <identifiersep> files . remove <identifiersep> first ( ) ; } olf . filename . delete ( ) ; old <identifiersep> log <identifiersep> files <identifiersep> disk <identifiersep> space <identifiersep> usage -= olf . size ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + olf . filename + <string_literal> + olf . size + <ect>
old <identifiersep> file = f ; } else { <comment> <LOG> if ( current <identifiersep> filename != null && current <identifiersep> filename . exists ( ) ) { for ( int a = 1 ; ; a ++ ) { numeric <identifiersep> same <identifiersep> date <identifiersep> filename = new file ( get <identifiersep> hour <identifiersep> log <identifiersep> name ( gc , a , true ) ) ; if ( numeric <identifiersep> same <identifiersep> date <identifiersep> filename == null || ! numeric <identifiersep> same <identifiersep> date <identifiersep> filename . exists ( ) ) { if ( numeric <identifiersep> same <identifiersep> date <identifiersep> filename != null ) { system . out . println ( <string_literal> + numeric <identifiersep> same <identifiersep> date <identifiersep> filename ) ; <ect>
while ( ! closed <identifiersep> finished ) { int wait = ( int ) ( deadline - system . current <identifiersep> time <identifiersep> millis ( ) ) ; if ( wait < = 0 ) return ; try { list . wait ( wait ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> <comment> <ect>
super ( message ) ; code = e <identifiersep> code ; } } protected final plugin <identifiersep> context plugin <identifiersep> context ; protected abstract <identifiersep> fcp <identifiersep> handler ( plugin <identifiersep> context plugin <identifiersep> context2 ) { this . plugin <identifiersep> context = plugin <identifiersep> context2 ; } public final void handle ( plugin <identifiersep> reply <identifiersep> sender replysender , simple <identifiersep> field <identifiersep> set params , bucket data , int accesstype ) throws plugin <identifiersep> not <identifiersep> found <identifiersep> exception { <LOG> if ( log <identifiersep> debug ) { } final string command = params . get ( <string_literal> ) ; final string identifier = params . get ( <string_literal> ) ; if ( <string_literal> . equals ( command ) ) { simple <identifiersep> field <identifiersep> set sfs = new simple <identifiersep> field <identifiersep> set ( true ) ; sfs . put ( <string_literal> , system . current <identifiersep> time <identifiersep> millis ( ) ) ; <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { try { j . try <identifiersep> compress ( context ) ; } catch ( insert <identifiersep> exception e ) { j . on <identifiersep> failure ( e , null , context ) ; <LOG> } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <LOG> } catch ( throwable t ) { } } @ override public int get <identifiersep> priority ( ) { return native <identifiersep> thread . min <identifiersep> priority ; } } , <string_literal> + j ) ; if ( log <identifiersep> minor ) <ect>
cis = new counted <identifiersep> input <identifiersep> stream ( is ) ; cos = new counted <identifiersep> output <identifiersep> stream ( os ) ; encoder encoder = new encoder ( ) ; encoder . set <identifiersep> end <identifiersep> marker <identifiersep> mode ( true ) ; int dictionary <identifiersep> size = 1 ; if ( max <identifiersep> read <identifiersep> length == long . max <identifiersep> value || max <identifiersep> read <identifiersep> length < 0 ) { <LOG> dictionary <identifiersep> size = max <identifiersep> dictionary <identifiersep> size ; } else { while ( dictionary <identifiersep> size < max <identifiersep> read <identifiersep> length && dictionary <identifiersep> size < max <identifiersep> dictionary <identifiersep> size ) dictionary <identifiersep> size < < = 1 ; } encoder . set <identifiersep> dictionary <identifiersep> size ( dictionary <identifiersep> size ) ; encoder . write <identifiersep> coder <identifiersep> properties ( os ) ; <ect>
return ; } scheduled = false ; dirty = false ; writing = true ; } try { write <identifiersep> buffer ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } finally { synchronized ( resizable <identifiersep> persistent <identifiersep> int <identifiersep> buffer . this ) { writing = false ; resizable <identifiersep> persistent <identifiersep> int <identifiersep> buffer . this . notify <identifiersep> all ( ) ; } lock . read <identifiersep> lock ( ) . unlock ( ) ; <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + filename , e ) ; } synchronized ( this ) { writing = false ; } try { raf . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } finally { lock . write <identifiersep> lock ( ) . unlock ( ) ; } } public void abort ( ) { lock . write <identifiersep> lock ( ) . lock ( ) ; try { <ect>
logger . normal ( this , <string_literal> + this . size + <string_literal> + size ) ; this . size = size ; buffer = arrays . copy <identifiersep> of ( buffer , size ) ; try { raf . set <identifiersep> length ( size * <number_literal> ) ; write <identifiersep> buffer ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } finally { lock . write <identifiersep> lock ( ) . unlock ( ) ; } } public void force <identifiersep> write ( ) { logger . normal ( this , <string_literal> + this ) ; lock . read <identifiersep> lock ( ) . lock ( ) ; <ect>
<comment> condition lock <identifiersep> entry ( long offset ) { <LOG> if ( log <identifiersep> debug ) condition condition ; try { entry <identifiersep> lock . lock ( ) ; try { do { <ect>
lock <identifiersep> map . put ( offset , condition ) ; } finally { entry <identifiersep> lock . unlock ( ) ; } } catch ( interrupted <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; return null ; } <LOG> if ( log <identifiersep> debug ) return condition ; } <comment> void unlock <identifiersep> entry ( long offset , condition condition ) { <ect>
system . arraycopy ( salt , 0 , iv2 , 0 , 0x10 ) ; system . arraycopy ( iv , 0 , iv2 , 0x10 , 0x10 ) ; try { block <identifiersep> cipher aes = new rijndael ( <number_literal> , <number_literal> ) ; aes . initialize ( key ) ; return pcfb <identifiersep> mode . create ( aes , iv2 ) ; <LOG> } catch ( unsupported <identifiersep> cipher <identifiersep> exception e ) { throw new error ( <string_literal> , e ) ; } } public void shutdown ( ) { master <identifiersep> keys . clear ( salt ) ; master <identifiersep> keys . clear ( disk <identifiersep> salt ) ; } } <ect>
store <identifiersep> size = max <identifiersep> keys ; write <identifiersep> config <identifiersep> file ( ) ; } new <identifiersep> store | = open <identifiersep> store <identifiersep> files ( base <identifiersep> dir , name ) ; bloom <identifiersep> file = new file ( this . base <identifiersep> dir , name + <string_literal> ) ; if ( bloom <identifiersep> file . exists ( ) ) { bloom <identifiersep> file . delete ( ) ; <LOG> system . err . println ( <string_literal> + name + <string_literal> ) ; } file slot <identifiersep> filter <identifiersep> file = new file ( this . base <identifiersep> dir , name + <string_literal> ) ; int size = ( int ) math . max ( store <identifiersep> size , prev <identifiersep> store <identifiersep> size ) ; slot <identifiersep> filter <identifiersep> disabled = ! enable <identifiersep> slot <identifiersep> filters ; if ( ! slot <identifiersep> filter <identifiersep> disabled ) { slot <identifiersep> filter = new resizable <identifiersep> persistent <identifiersep> int <identifiersep> buffer ( slot <identifiersep> filter <identifiersep> file , size ) ; <ect>
slot <identifiersep> filter = new resizable <identifiersep> persistent <identifiersep> int <identifiersep> buffer ( slot <identifiersep> filter <identifiersep> file , size ) ; system . err . println ( <string_literal> + slot <identifiersep> filter <identifiersep> file + <string_literal> + name + <string_literal> + slot <identifiersep> filter . is <identifiersep> new ( ) + <string_literal> ) ; if ( new <identifiersep> store && slot <identifiersep> filter . is <identifiersep> new ( ) ) slot <identifiersep> filter . fill ( slot <identifiersep> checked ) ; } else { if ( slot <identifiersep> filter <identifiersep> file . exists ( ) ) { <LOG> if ( slot <identifiersep> filter <identifiersep> file . delete ( ) ) { } else { system . err . println ( <string_literal> + slot <identifiersep> filter <identifiersep> file + <string_literal> ) ; } } slot <identifiersep> filter = null ; } if ( ( flags & flag <identifiersep> dirty ) != 0 ) system . err . println ( <string_literal> + name + <string_literal> ) ; <ect>
if ( slot <identifiersep> filter <identifiersep> file . exists ( ) ) { if ( slot <identifiersep> filter <identifiersep> file . delete ( ) ) { system . err . println ( <string_literal> ) ; } else { system . err . println ( <string_literal> + slot <identifiersep> filter <identifiersep> file + <string_literal> ) ; } } slot <identifiersep> filter = null ; } <LOG> if ( ( flags & flag <identifiersep> dirty ) != 0 ) flags | = flag <identifiersep> dirty ; <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; old <identifiersep> entry . store <identifiersep> size = store <identifiersep> size ; write <identifiersep> entry ( old <identifiersep> entry , digested <identifiersep> key , old <identifiersep> offset ) ; } return true ; } old <identifiersep> entry . set <identifiersep> hd ( read <identifiersep> hd ( old <identifiersep> offset ) ) ; <comment> <LOG> if ( block . equals ( old <identifiersep> block ) ) { if ( ( old <identifiersep> entry . flag & entry . entry <identifiersep> new <identifiersep> block ) == 0 && ! is <identifiersep> old <identifiersep> block ) { <comment> <ect>
<comment> <LOG> if ( log <identifiersep> debug ) old <identifiersep> entry = read <identifiersep> entry ( offset [ index <identifiersep> to <identifiersep> overwrite ] , null , null , false ) ; write <identifiersep> entry ( entry , digested <identifiersep> key , offset [ index <identifiersep> to <identifiersep> overwrite ] ) ; if ( old <identifiersep> entry . generation != generation ) key <identifiersep> count . increment <identifiersep> and <identifiersep> get ( ) ; on <identifiersep> write ( ) ; <ect>
mbf . flip ( ) ; entry entry = new entry ( mbf , null ) ; entry . cur <identifiersep> offset = offset ; byte [ ] slot <identifiersep> digested <identifiersep> routing <identifiersep> key = entry . digested <identifiersep> routing <identifiersep> key ; int true <identifiersep> cache = entry . get <identifiersep> slot <identifiersep> filter <identifiersep> entry ( ) ; if ( true <identifiersep> cache != cache && ! slot <identifiersep> filter <identifiersep> disabled ) { <LOG> if ( valid <identifiersep> cache ) slot <identifiersep> filter . put ( ( int ) offset , true <identifiersep> cache ) ; } if ( routing <identifiersep> key != null ) { if ( entry . is <identifiersep> free ( ) ) { if ( valid <identifiersep> cache && ! likely <identifiersep> match && ! slot <identifiersep> cache <identifiersep> is <identifiersep> free ( cache ) ) { logger . error ( this , <string_literal> + offset + <string_literal> + cache ) ; <ect>
if ( valid <identifiersep> cache && likely <identifiersep> match ) { logger . normal ( this , <string_literal> + offset + <string_literal> + cache ) ; bloom <identifiersep> false <identifiersep> pos . increment <identifiersep> and <identifiersep> get ( ) ; } else if ( log <identifiersep> minor && valid <identifiersep> cache && ! likely <identifiersep> match ) logger . minor ( this , <string_literal> ) ; return null ; } <LOG> if ( valid <identifiersep> cache && ! likely <identifiersep> match ) { bloom <identifiersep> false <identifiersep> pos . increment <identifiersep> and <identifiersep> get ( ) ; } if ( with <identifiersep> data ) { byte <identifiersep> buffer hd <identifiersep> buf = read <identifiersep> hd ( offset ) ; entry . set <identifiersep> hd ( hd <identifiersep> buf ) ; boolean decrypted = cipher <identifiersep> manager . decrypt ( entry , routing <identifiersep> key ) ; <ect>
meta <identifiersep> fc . close ( ) ; } catch ( exception e ) { logger . error ( this , <string_literal> , e ) ; } try { hd <identifiersep> fc . force ( true ) ; hd <identifiersep> fc . close ( ) ; <LOG> } catch ( exception e ) { } if ( ! slot <identifiersep> filter <identifiersep> disabled ) { if ( ! abort ) slot <identifiersep> filter . shutdown ( ) ; else slot <identifiersep> filter . abort ( ) ; <ect>
cipher = new rijndael ( <number_literal> , <number_literal> ) ; } catch ( unsupported <identifiersep> cipher <identifiersep> exception e ) { throw new error ( <string_literal> + e , e ) ; } cipher . initialize ( master <identifiersep> key ) ; disk <identifiersep> salt = new byte [ 0x10 ] ; cipher . encipher ( newsalt , disk <identifiersep> salt ) ; <LOG> if ( log <identifiersep> debug ) } cipher <identifiersep> manager = new cipher <identifiersep> manager ( newsalt , disk <identifiersep> salt ) ; write <identifiersep> config <identifiersep> file ( ) ; return true ; } else { try { <ect>
} catch ( eof <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
logger . error ( this , <string_literal> + name , e ) ; system . err . println ( <string_literal> + name ) ; if ( config <identifiersep> file . exists ( ) && config <identifiersep> file . delete ( ) ) { file meta <identifiersep> file = new file ( base <identifiersep> dir , name + <string_literal> ) ; meta <identifiersep> file . delete ( ) ; return load <identifiersep> config <identifiersep> file ( master <identifiersep> key ) ; } <LOG> <comment> <ect>
raf . write <identifiersep> long ( hits . get ( ) ) ; raf . write <identifiersep> long ( misses . get ( ) ) ; raf . write <identifiersep> long ( bloom <identifiersep> false <identifiersep> pos . get ( ) ) ; raf . get <identifiersep> fd ( ) . sync ( ) ; raf . close ( ) ; file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> config , config <identifiersep> file ) ; <LOG> } catch ( io <identifiersep> exception ioe ) { } finally { config <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; } } <comment> <ect>
cleaner <identifiersep> lock . unlock ( ) ; } } } private static final int resize <identifiersep> memory <identifiersep> entries = <number_literal> ; <comment> <LOG> logger . normal ( this , <string_literal> ) ; batch <identifiersep> processor < t > resize <identifiersep> processer = new batch <identifiersep> processor < t > ( ) { deque < entry > old <identifiersep> entry <identifiersep> list = new linked <identifiersep> list < entry > ( ) ; @ override public void init ( ) { if ( store <identifiersep> size >  <identifiersep> prev <identifiersep> store <identifiersep> size ) <ect>
@ override public entry process ( entry entry ) { if ( ! slot <identifiersep> filter <identifiersep> disabled ) { int cache = entry . get <identifiersep> slot <identifiersep> filter <identifiersep> entry ( ) ; try { slot <identifiersep> filter . put ( ( int ) entry . cur <identifiersep> offset , cache , true ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } if ( ! entry . is <identifiersep> free ( ) ) { key <identifiersep> count . increment <identifiersep> and <identifiersep> get ( ) ; if ( entry . generation != generation ) { entry . generation = generation ; return entry ; <ect>
processor . init ( ) ; try { for ( long cur <identifiersep> offset = start <identifiersep> offset ; cur <identifiersep> offset >= 0 && cur <identifiersep> offset < store <identifiersep> size ; cur <identifiersep> offset += step ) { if ( shutdown ) { processor . abort ( ) ; return ; } <LOG> if ( i ++ % <number_literal> == 0 ) + entries <identifiersep> total ) ; batch <identifiersep> process <identifiersep> entries ( cur <identifiersep> offset , resize <identifiersep> memory <identifiersep> entries , processor ) ; entries <identifiersep> left = reverse ? cur <identifiersep> offset : math . max ( store <identifiersep> size - cur <identifiersep> offset - resize <identifiersep> memory <identifiersep> entries , 0 ) ; if ( ! processor . batch ( entries <identifiersep> left ) ) { processor . abort ( ) ; <ect>
while ( buf . has <identifiersep> remaining ( ) ) { int status = meta <identifiersep> fc . read ( buf , start <identifiersep> file <identifiersep> offset + buf . position ( ) ) ; if ( status == - 1 ) break ; } } catch ( io <identifiersep> exception ioe ) { if ( shutdown ) <LOG> return false ; } buf . flip ( ) ; try { for ( int j = 0 ; ! shutdown && buf . limit ( ) > j * entry . metadata <identifiersep> length ; j ++ ) { buf . position ( j * entry . metadata <identifiersep> length ) ; if ( buf . remaining ( ) < entry . metadata <identifiersep> length ) <comment> <ect>
dirty = true ; if ( ! slot <identifiersep> filter <identifiersep> disabled ) { int new <identifiersep> val = new <identifiersep> entry . get <identifiersep> slot <identifiersep> filter <identifiersep> entry ( ) ; if ( slot <identifiersep> filter . get ( ( int ) ( offset + j ) ) != new <identifiersep> val ) { try { slot <identifiersep> filter . put ( ( int ) ( offset + j ) , new <identifiersep> val ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } } dirty = true ; } } } finally { <comment> <ect>
for ( long offset : offsets ) { try { if ( ! is <identifiersep> free ( offset ) && arrays . equals ( get <identifiersep> digested <identifiersep> key <identifiersep> from <identifiersep> offset ( offset ) , entry . get <identifiersep> digested <identifiersep> routing <identifiersep> key ( ) ) ) { <comment> <LOG> } catch ( io <identifiersep> exception e ) { } } <comment> <ect>
config <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; } if ( cleaner <identifiersep> lock . try <identifiersep> lock ( ) ) { cleaner <identifiersep> condition . signal ( ) ; cleaner <identifiersep> lock . unlock ( ) ; } if ( shrink <identifiersep> now ) { config <identifiersep> lock . write <identifiersep> lock ( ) . lock ( ) ; <LOG> try { while ( prev <identifiersep> store <identifiersep> size == old ) { resize <identifiersep> complete <identifiersep> condition . await <identifiersep> uninterruptibly ( ) ; } system . err . println ( <string_literal> + old + <string_literal> + new <identifiersep> store <identifiersep> size + <string_literal> + store <identifiersep> size + <string_literal> + prev <identifiersep> store <identifiersep> size + <string_literal> ) ; } finally { config <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; <ect>
try { flush <identifiersep> and <identifiersep> close ( abort ) ; flags & = ~flag <identifiersep> dirty ; <comment> <LOG> cipher <identifiersep> manager . shutdown ( ) ; } <comment> <ect>
while ( k < number <identifiersep> of <identifiersep> keys <identifiersep> to <identifiersep> write ) { long size <identifiersep> block = cfs . push <identifiersep> least <identifiersep> recently <identifiersep> block ( ) ; if ( size <identifiersep> block == - 1 ) break ; synchronized ( this ) { size -= size <identifiersep> block ; assert ( size >= 0 ) ; <comment> <LOG> if ( size < 0 ) { size = 0 ; } if ( size == 0 ) return ; } k ++ ; } } } } public long get <identifiersep> size <identifiersep> of <identifiersep> cache ( ) { long size <identifiersep> returned ; <ect>
public class add <identifiersep> ref { <comment> public static void main ( string [ ] args ) { <LOG> if ( args . length < 1 ) { system . exit ( - 1 ) ; } final file reference = new file ( args [ 0 ] ) ; if ( ( reference == null ) || ! ( reference . is <identifiersep> file ( ) ) || ! ( reference . can <identifiersep> read ( ) ) ) { system . err . println ( <string_literal> ) ; system . exit ( - 1 ) ; <ect>
fcpm = fcp <identifiersep> message . create ( <string_literal> , sfs ) ; fcpm . send ( os ) ; os . flush ( ) ; string message <identifiersep> name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; sfs = get <identifiersep> message ( lis ) ; fcpm = fcp <identifiersep> message . create ( message <identifiersep> name , sfs ) ; <LOG> if ( ( fcpm == null ) || ! ( fcpm instanceof node <identifiersep> hello <identifiersep> message ) ) { system . exit ( 1 ) ; } } catch ( message <identifiersep> invalid <identifiersep> exception me ) { me . print <identifiersep> stack <identifiersep> trace ( ) ; } try { sfs = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( reference , false , true ) ; <ect>
} catch ( message <identifiersep> invalid <identifiersep> exception me ) { system . err . println ( <string_literal> + me ) ; me . print <identifiersep> stack <identifiersep> trace ( ) ; } lis . close ( ) ; is . close ( ) ; os . close ( ) ; <LOG> fcp <identifiersep> socket . close ( ) ; } catch ( socket <identifiersep> exception se ) { system . err . println ( se ) ; se . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( 1 ) ; } catch ( io <identifiersep> exception ioe ) { <ect>
if ( line == null ) { system . err . println ( <string_literal> + f ) ; system . exit ( <number_literal> ) ; } int idx = line . index <identifiersep> of ( ' = ' ) ; if ( idx == - 1 ) { <comment> <LOG> if ( ! line . equals ( <string_literal> ) ) { system . exit ( 1 ) ; } sw . append ( line + <string_literal> ) ; line = br . read <identifiersep> line ( ) ; if ( line != null ) { system . err . println ( <string_literal> + line + <string_literal> ) ; <ect>
system . err . println ( <string_literal> + line + <string_literal> ) ; system . exit ( <number_literal> ) ; } break ; } string before = line . substring ( 0 , idx ) ; <comment> <LOG> if ( s == null ) { changed = true ; continue ; } sw . append ( line + <string_literal> ) ; } closer . close ( fis ) ; closer . close ( isr ) ; <ect>
public class merge <identifiersep> sfs { <comment> public static void main ( string [ ] args ) throws io <identifiersep> exception { <LOG> if ( args . length < <number_literal> || args . length > <number_literal> ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; return ; } file f1 = new file ( args [ 0 ] ) ; <ect>
<comment> public static void main ( string [ ] args ) throws io <identifiersep> exception { if ( args . length < <number_literal> || args . length > <number_literal> ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; return ; } file f1 = new file ( args [ 0 ] ) ; file f2 = new file ( args [ 1 ] ) ; simple <identifiersep> field <identifiersep> set fs1 = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( f1 , false , true ) ; <ect>
buffer data = ( buffer ) m1 . get <identifiersep> object ( dmt . data ) ; int missing = 0 ; try { synchronized ( block <identifiersep> receiver . this ) { if ( completed ) return ; } if ( check <identifiersep> dupes &&  <identifiersep> prb . is <identifiersep> received ( packet <identifiersep> no ) ) { <LOG> <comment> <ect>
synchronized ( avg <identifiersep> time <identifiersep> taken ) { avg <identifiersep> time <identifiersep> taken . report ( transfer <identifiersep> time ) ; logger . minor ( this , <string_literal> + transfer <identifiersep> time + <string_literal> + avg <identifiersep> time <identifiersep> taken ) ; } } complete (  <identifiersep> prb . get <identifiersep> block ( ) ) ; return ; } } catch ( aborted <identifiersep> exception e1 ) { <LOG> <comment> <ect>
return native <identifiersep> thread . norm <identifiersep> priority ; } } ,  <identifiersep> ctr ) ; } catch ( disconnected <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
try { wait ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> if ( end - last <identifiersep> sent <identifiersep> packet > timeout ) { cancel ( <string_literal> ) ; return false ; } continue ; } <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + block <identifiersep> num ) ; bulk <identifiersep> transmitter [ ] notify <identifiersep> b <identifiersep> ts ; long file <identifiersep> offset = ( long ) block <identifiersep> num * ( long ) block <identifiersep> size ; int bs = ( int ) math . min ( block <identifiersep> size , size - file <identifiersep> offset ) ; if ( length < bs ) { <LOG> string err = <string_literal> + bs + <string_literal> + length ; abort ( retrieval <identifiersep> exception . premature <identifiersep> eof , err ) ; return ; } synchronized ( this ) { if ( blocks <identifiersep> received . bit <identifiersep> at ( block <identifiersep> num ) ) return ; <comment> <ect>
public byte [ ] get <identifiersep> block <identifiersep> data ( int block <identifiersep> num ) { long file <identifiersep> offset = ( long ) block <identifiersep> num * ( long ) block <identifiersep> size ; int bs = ( int ) math . min ( block <identifiersep> size , size - file <identifiersep> offset ) ; byte [ ] data = new byte [ bs ] ; try { raf . pread ( file <identifiersep> offset , data , 0 , bs ) ; <LOG> } catch ( io <identifiersep> exception e ) { abort ( retrieval <identifiersep> exception . io <identifiersep> error , e . to <identifiersep> string ( ) ) ; return null ; } return data ; } public synchronized void remove ( bulk <identifiersep> transmitter remove ) { boolean found = false ; <ect>
 <identifiersep> prb = source ;  <identifiersep> ctr = ctr ; if (  <identifiersep> ctr == null ) throw new null <identifiersep> pointer <identifiersep> exception ( ) ; packet <identifiersep> size = dmt . packet <identifiersep> transmit <identifiersep> size (  <identifiersep> prb .  <identifiersep> packet <identifiersep> size ,  <identifiersep> prb .  <identifiersep> packets ) ; try {  <identifiersep> sent <identifiersep> packets = new bit <identifiersep> array (  <identifiersep> prb . get <identifiersep> num <identifiersep> packets ( ) ) ; <LOG> } catch ( aborted <identifiersep> exception e ) { <comment> <ect>
abort <identifiersep> reason = <string_literal> ; } else { <comment> <LOG> time <identifiersep> string = time <identifiersep> util . format <identifiersep> time ( ( system . current <identifiersep> time <identifiersep> millis ( ) - time <identifiersep> all <identifiersep> sent ) , <number_literal> , true ) ; abort <identifiersep> reason = <string_literal> + time <identifiersep> string ; } fail = maybe <identifiersep> fail ( retrieval <identifiersep> exception . receiver <identifiersep> died , abort <identifiersep> reason ) ; } fail . execute ( ) ; } @ override public int get <identifiersep> priority ( ) { <ect>
public void packet <identifiersep> received ( int packet <identifiersep> no ) { synchronized (  <identifiersep> sender <identifiersep> thread ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + packet <identifiersep> no + <string_literal> +  <identifiersep> uid + <string_literal> +  <identifiersep> destination ) ; if (  <identifiersep> unsent . contains ( packet <identifiersep> no ) ) { logger . error ( this , <string_literal> + packet <identifiersep> no + <string_literal> + this + <string_literal> +  <identifiersep> unsent , new exception ( <string_literal> ) ) ; return ; } <LOG> if (  <identifiersep> sent <identifiersep> packets . bit <identifiersep> at ( packet <identifiersep> no ) ) { return ; }  <identifiersep> unsent . add <identifiersep> last ( packet <identifiersep> no ) ; time <identifiersep> all <identifiersep> sent = - 1 ;  <identifiersep> sender <identifiersep> thread . schedule ( ) ; } } @ override <ect>
lock . lock ( ) ; try { if ( acceptors . size ( ) > 0 ) return ; while ( true ) { logger . error ( this , <string_literal> ) ; bound <identifiersep> condition . await <identifiersep> uninterruptibly ( ) ; <LOG> if ( acceptors . size ( ) > 0 ) { return ; } if ( shutdown ) return ; if ( wrapper <identifiersep> manager . has <identifiersep> shutdown <identifiersep> hook <identifiersep> been <identifiersep> triggered ( ) ) return ; <ect>
input <identifiersep> stream <identifiersep> reader ir = new input <identifiersep> stream <identifiersep> reader ( bis , <string_literal> ) ; buffered <identifiersep> reader br = new buffered <identifiersep> reader ( ir ) ; simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( br , false , true ) ; return new address <identifiersep> tracker ( fs , last <identifiersep> boot <identifiersep> id ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <comment> <ect>
inet <identifiersep> address ip = peer . get <identifiersep> address ( ) ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; synchronized ( this ) { peer <identifiersep> address <identifiersep> tracker <identifiersep> item peer <identifiersep> item = peer <identifiersep> trackers . get ( peer ) ; if ( peer <identifiersep> item == null ) { peer <identifiersep> item = new peer <identifiersep> address <identifiersep> tracker <identifiersep> item ( time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> received <identifiersep> peer , time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> sent <identifiersep> peer , peer ) ; <LOG> if ( peer <identifiersep> trackers . size ( ) > max <identifiersep> items ) { peer <identifiersep> trackers . clear ( ) ; ip <identifiersep> trackers . clear ( ) ; time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> received <identifiersep> peer = now ; time <identifiersep> definitely <identifiersep> no <identifiersep> packets <identifiersep> sent <identifiersep> peer = now ; } peer <identifiersep> trackers . put ( peer , peer <identifiersep> item ) ; <ect>
simple <identifiersep> field <identifiersep> set fs = get <identifiersep> fieldset ( boot <identifiersep> id ) ; fs . write <identifiersep> to ( bw ) ; bw . flush ( ) ; bw . close ( ) ; fos = null ; file <identifiersep> util . rename <identifiersep> to ( data <identifiersep> bak , data ) ; <LOG> } catch ( io <identifiersep> exception e ) { return ; } finally { if ( fos != null ) try { fos . close ( ) ; <ect>
inet <identifiersep> address addr = null ; if ( host != null ) { if ( host . starts <identifiersep> with ( <string_literal> ) ) host = host . substring ( 1 ) ; host = host . trim ( ) ; } <comment> <LOG> address <identifiersep> identifier . address <identifiersep> type address <identifiersep> type = address <identifiersep> identifier . get <identifiersep> address <identifiersep> type ( host ) ; if ( address <identifiersep> type != address <identifiersep> identifier . address <identifiersep> type . other ) { <comment> <ect>
<comment> <LOG> if ( addr == null ) { } this .  <identifiersep> address = addr ; this . hostname = host ; <comment> <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + host + <string_literal> + address <identifiersep> type + ' \\ '' ) ; if ( address <identifiersep> type != address <identifiersep> identifier . address <identifiersep> type . other ) { try { addr = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( host ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( ! allow <identifiersep> unknown ) throw e ; <LOG> addr = null ; } if ( addr != null && addr . get <identifiersep> host <identifiersep> address ( ) . equals ( host ) ) { if ( log <identifiersep> debug ) logger . debug ( this , ' \\ '' + host + <string_literal> ) ; host = null ; } else { addr = null ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + host + <string_literal> + ( addr != null ? addr . get <identifiersep> host <identifiersep> address ( ) + ' \\ '' : <string_literal> ) ) ; if ( addr != null && addr . get <identifiersep> host <identifiersep> address ( ) . equals ( host ) ) { if ( log <identifiersep> debug ) logger . debug ( this , ' \\ '' + host + <string_literal> ) ; host = null ; } else { addr = null ; } } <LOG> if ( addr == null ) { } this .  <identifiersep> address = addr ; this . hostname = host ; if ( check <identifiersep> hostname <identifiersep> or <identifiersep> ip <identifiersep> syntax && null != this . hostname ) { if ( ! hostname <identifiersep> util . is <identifiersep> valid <identifiersep> hostname ( this . hostname , true ) ) throw new hostname <identifiersep> syntax <identifiersep> exception ( ) ; } <comment> <ect>
return m ; } try { message sub <identifiersep> message = decode <identifiersep> message ( bb2 , peer , 0 , false , true , very <identifiersep> lax ) ; if ( sub <identifiersep> message == null ) return m ; if ( log <identifiersep> minor ) logger . minor ( message . class , <string_literal> + sub <identifiersep> message ) ; m . add <identifiersep> sub <identifiersep> message ( sub <identifiersep> message ) ; <LOG> } catch ( throwable t ) { } } } } catch ( eof <identifiersep> exception e ) { string msg = peer . get <identifiersep> peer ( ) + <string_literal> + mspec . get <identifiersep> name ( ) ; if ( in <identifiersep> sub <identifiersep> message ) { if ( log <identifiersep> minor ) logger . minor ( message . class , msg + <string_literal> , e ) ; } else logger . error ( message . class , msg , e ) ; <ect>
if ( value == null ) { throw new incorrect <identifiersep> type <identifiersep> exception ( <string_literal> + key ) ; } throw new incorrect <identifiersep> type <identifiersep> exception ( <string_literal> + value . get <identifiersep> class ( ) + <string_literal> +  <identifiersep> spec . type <identifiersep> of ( key ) ) ; }  <identifiersep> payload . put ( key , value ) ; } public byte [ ] encode <identifiersep> to <identifiersep> packet ( ) { return encode <identifiersep> to <identifiersep> packet ( true , false ) ; } <LOG> private byte [ ] encode <identifiersep> to <identifiersep> packet ( boolean include <identifiersep> sub <identifiersep> messages , boolean is <identifiersep> sub <identifiersep> message ) { byte <identifiersep> array <identifiersep> output <identifiersep> stream baos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( baos ) ; try { dos . write <identifiersep> int (  <identifiersep> spec . get <identifiersep> name ( ) . hash <identifiersep> code ( ) ) ; for ( string name :  <identifiersep> spec . get <identifiersep> ordered <identifiersep> fields ( ) ) { <ect>
<comment> public message decode <identifiersep> single <identifiersep> message ( byte [ ] data , int offset , int length , peer <identifiersep> context peer , int overhead ) { try { return message . decode <identifiersep> message <identifiersep> from <identifiersep> packet ( data , offset , length , peer , overhead ) ; <LOG> } catch ( throwable t ) { return null ; } } public void start ( final ticker ticker ) { synchronized ( this ) { started <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; } ticker . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { <ect>
if ( f . timed <identifiersep> out ( t <identifiersep> start ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + f ) ; i . remove ( ) ; if ( timed <identifiersep> out <identifiersep> filters == null ) timed <identifiersep> out <identifiersep> filters = new hash <identifiersep> set < message <identifiersep> filter > ( ) ; <LOG> if ( ! timed <identifiersep> out <identifiersep> filters . add ( f ) ) if ( log <identifiersep> minor ) { for ( list <identifiersep> iterator < message > it =  <identifiersep> unclaimed . list <identifiersep> iterator ( ) ; it . has <identifiersep> next ( ) ; ) { message m = it . next ( ) ; matched status = f . match ( m , true , t <identifiersep> start ) ; if ( status == matched . matched ) { <ect>
if ( timed <identifiersep> out <identifiersep> filters != null ) { for ( message <identifiersep> filter f : timed <identifiersep> out <identifiersep> filters ) { f . set <identifiersep> message ( null ) ; f . on <identifiersep> timed <identifiersep> out (  <identifiersep> executor ) ; } } long t <identifiersep> end = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( t <identifiersep> end - t <identifiersep> start > <number_literal> ) { <LOG> if ( t <identifiersep> end - t <identifiersep> start > <number_literal> ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( t <identifiersep> end - t <identifiersep> start ) + <string_literal> ) ; } return next <identifiersep> timeout ; } <comment> <ect>
match . on <identifiersep> matched (  <identifiersep> executor ) ; } <comment> <LOG> } catch ( throwable t ) { } } if ( timed <identifiersep> out != null ) timed <identifiersep> out . clear ( ) ; <comment> <ect>
i . remove ( ) ; } } } if ( dropped <identifiersep> filters != null ) { for ( message <identifiersep> filter mf : dropped <identifiersep> filters ) { mf . on <identifiersep> restarted <identifiersep> connection ( ctx ,  <identifiersep> executor ) ; } } } public void add <identifiersep> async <identifiersep> filter ( message <identifiersep> filter filter , async <identifiersep> message <identifiersep> filter <identifiersep> callback callback , byte <identifiersep> counter ctr ) throws disconnected <identifiersep> exception { filter . set <identifiersep> async <identifiersep> callback ( callback , ctr ) ; <LOG> if ( filter . matched ( ) ) { filter . clear <identifiersep> matched ( ) ; } filter . on <identifiersep> start <identifiersep> waiting ( false ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + filter + <string_literal> + callback ) ; message ret = null ; if ( filter . any <identifiersep> connections <identifiersep> dropped ( ) ) { <ect>
<comment> public message wait <identifiersep> for ( message <identifiersep> filter filter , byte <identifiersep> counter ctr ) throws disconnected <identifiersep> exception { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filter ) ; if ( filter . has <identifiersep> callback ( ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> if ( filter . matched ( ) ) { filter . clear <identifiersep> matched ( ) ; } filter . on <identifiersep> start <identifiersep> waiting ( true ) ; message ret = null ; if ( filter . any <identifiersep> connections <identifiersep> dropped ( ) ) { filter . on <identifiersep> dropped <identifiersep> connection ( filter . dropped <identifiersep> connection ( ) ,  <identifiersep> executor ) ; <ect>
<comment> <LOG> long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( ctr != null ) && ( ret != null ) ) ctr . received <identifiersep> bytes ( ret .  <identifiersep> received <identifiersep> byte <identifiersep> count ) ; return ret ; } <comment> <ect>
private void run <identifiersep> loop ( ) { byte [ ] buf = new byte [ max <identifiersep> receive <identifiersep> size ] ; datagram <identifiersep> packet packet = new datagram <identifiersep> packet ( buf , buf . length ) ; while (  <identifiersep> active ) { try { real <identifiersep> run ( packet ) ; <LOG> } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( system . err ) ; logger . error ( this , <string_literal> + t , t ) ; } } } private void real <identifiersep> run ( datagram <identifiersep> packet packet ) { <comment> <ect>
if ( got <identifiersep> packet ) { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; peer peer = new peer ( packet . get <identifiersep> address ( ) , packet . get <identifiersep> port ( ) ) ; tracker . received <identifiersep> packet <identifiersep> from ( peer ) ; long end <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { <LOG> if ( end <identifiersep> time - start <identifiersep> time > <number_literal> ) { } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( end <identifiersep> time - start <identifiersep> time ) + <string_literal> ) ; } } byte [ ] data = packet . get <identifiersep> data ( ) ; int offset = packet . get <identifiersep> offset ( ) ; int length = packet . get <identifiersep> length ( ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( end <identifiersep> time - start <identifiersep> time ) + <string_literal> ) ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + length ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> + low <identifiersep> level <identifiersep> filter , t ) ; } <LOG> } else { } } private static final int max <identifiersep> receive <identifiersep> size = <number_literal> ; private boolean get <identifiersep> packet ( datagram <identifiersep> packet packet ) { try {  <identifiersep> sock . receive ( packet ) ; inet <identifiersep> address address = packet . get <identifiersep> address ( ) ; <ect>
if ( !  <identifiersep> active ) { logger . error ( this , <string_literal> ) ; <comment> <LOG> if ( destination . get <identifiersep> address ( false , allow <identifiersep> local <identifiersep> addresses ) == null ) { if ( destination . get <identifiersep> address ( true , allow <identifiersep> local <identifiersep> addresses ) == null ) { logger . error ( this , <string_literal> + destination . get <identifiersep> port ( ) , new exception ( <string_literal> ) ) ; return ; } } if (  <identifiersep> drop <identifiersep> probability > 0 ) { if ( drop <identifiersep> random . next <identifiersep> int ( ) %  <identifiersep> drop <identifiersep> probability == 0 ) { <ect>
boolean is <identifiersep> local = ( ! ip <identifiersep> util . is <identifiersep> valid <identifiersep> address ( address , false ) ) && ( ip <identifiersep> util . is <identifiersep> valid <identifiersep> address ( address , true ) ) ; collector . add <identifiersep> info ( address , port , 0 , get <identifiersep> headers <identifiersep> length ( address ) + block <identifiersep> to <identifiersep> send . length , is <identifiersep> local ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + block <identifiersep> to <identifiersep> send . length + <string_literal> + address + ' : ' + port ) ; } catch ( io <identifiersep> exception e ) { if ( packet . get <identifiersep> address ( ) instanceof inet6address ) { logger . normal ( this , <string_literal> + destination + <string_literal> + e ) ; <LOG> } else { } } } <comment> <ect>
targets . put ( key , entry ) ; } entry . add <identifiersep> data ( ( inbytes > 0 ) ? inbytes : 0 , ( outbytes > 0 ) ? outbytes : 0 ) ; } if ( ! is <identifiersep> local ) { synchronized ( this ) { totalbytesout += ( outbytes > 0 ) ? outbytes : 0 ; totalbytesin += ( inbytes > 0 ) ? inbytes : 0 ; <LOG> if ( log <identifiersep> debug ) } } } public void dump <identifiersep> info ( ) { synchronized ( this ) {  <identifiersep> dump <identifiersep> info ( ) ; } } public long [ ] get <identifiersep> total <identifiersep> io ( ) { synchronized ( this ) { <ect>
file filename = f ; file temp <identifiersep> filename = new file ( f . get <identifiersep> path ( ) + <string_literal> ) ; return new file <identifiersep> persistent <identifiersep> config ( load ( filename , temp <identifiersep> filename ) , filename , temp <identifiersep> filename , header ) ; } static simple <identifiersep> field <identifiersep> set load ( file filename , file temp <identifiersep> filename ) throws io <identifiersep> exception { boolean filename <identifiersep> exists = filename . exists ( ) ; boolean temp <identifiersep> filename <identifiersep> exists = temp <identifiersep> filename . exists ( ) ; <LOG> if ( filename <identifiersep> exists && ! filename . can <identifiersep> write ( ) ) { system . err . println ( <string_literal> + filename ) ; } if ( temp <identifiersep> filename <identifiersep> exists && ! temp <identifiersep> filename . can <identifiersep> write ( ) ) { logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + temp <identifiersep> filename ) ; system . err . println ( <string_literal> + temp <identifiersep> filename ) ; } if ( filename <identifiersep> exists ) { <ect>
static simple <identifiersep> field <identifiersep> set load ( file filename , file temp <identifiersep> filename ) throws io <identifiersep> exception { boolean filename <identifiersep> exists = filename . exists ( ) ; boolean temp <identifiersep> filename <identifiersep> exists = temp <identifiersep> filename . exists ( ) ; if ( filename <identifiersep> exists && ! filename . can <identifiersep> write ( ) ) { logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + filename ) ; system . err . println ( <string_literal> + filename ) ; } <LOG> if ( temp <identifiersep> filename <identifiersep> exists && ! temp <identifiersep> filename . can <identifiersep> write ( ) ) { system . err . println ( <string_literal> + temp <identifiersep> filename ) ; } if ( filename <identifiersep> exists ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { try { return initial <identifiersep> load ( filename ) ; <ect>
logger . error ( file <identifiersep> persistent <identifiersep> config . class , <string_literal> + temp <identifiersep> filename ) ; system . err . println ( <string_literal> + temp <identifiersep> filename ) ; } if ( filename <identifiersep> exists ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { try { return initial <identifiersep> load ( filename ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { } catch ( eof <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> ) ; } <comment> <ect>
} catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> + e + <string_literal> + temp <identifiersep> filename ) ; } catch ( eof <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> ) ; } <comment> <LOG> <comment> <ect>
if ( temp <identifiersep> filename . can <identifiersep> read ( ) && temp <identifiersep> filename . length ( ) > 0 ) { try { return initial <identifiersep> load ( temp <identifiersep> filename ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { system . err . println ( <string_literal> + temp <identifiersep> filename + <string_literal> + e ) ; } <comment> <LOG> } else { throw new io <identifiersep> exception ( <string_literal> + temp <identifiersep> filename ) ; } } system . err . println ( <string_literal> + filename ) ; return null ; } protected file <identifiersep> persistent <identifiersep> config ( simple <identifiersep> field <identifiersep> set orig <identifiersep> fs , file fnam , file temp ) throws io <identifiersep> exception { this ( orig <identifiersep> fs , fnam , temp , null ) ; <ect>
@ override public synchronized void finished <identifiersep> init ( ) { finished <identifiersep> init = true ; if ( orig <identifiersep> config <identifiersep> file <identifiersep> contents == null ) return ; iterator < string > i = orig <identifiersep> config <identifiersep> file <identifiersep> contents . key <identifiersep> iterator ( ) ; while ( i . has <identifiersep> next ( ) ) { <LOG> string key = i . next ( ) ; } orig <identifiersep> config <identifiersep> file <identifiersep> contents = null ; super . finished <identifiersep> init ( ) ; } public simple <identifiersep> field <identifiersep> set export <identifiersep> field <identifiersep> set ( ) { return export <identifiersep> field <identifiersep> set ( false ) ; } public simple <identifiersep> field <identifiersep> set export <identifiersep> field <identifiersep> set ( boolean with <identifiersep> defaults ) { <ect>
public void finished <identifiersep> init ( ) { sub <identifiersep> config [ ] configs ; synchronized ( this ) { <comment> <LOG> if ( ! config . has <identifiersep> finished <identifiersep> initialization ( ) ) } } public void on <identifiersep> register ( sub <identifiersep> config config , option < ? > o ) { <comment> <ect>
} catch ( io <identifiersep> exception e ) { closer . close ( fis ) ; closer . close ( fos ) ; fis = null ; fos = null ; if ( old <identifiersep> config . exists ( ) ) new <identifiersep> config . delete ( ) ; <LOG> logger . error ( wrapper <identifiersep> config . class , <string_literal> + <string_literal> + e , e ) ; return false ; } finally { closer . close ( fis ) ; closer . close ( fos ) ; } if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { <ect>
is <identifiersep> writing <identifiersep> config = true ; ticker . queue <identifiersep> timed <identifiersep> job ( thread , 0 ) ; } } public void finished <identifiersep> init ( ticker ticker ) { this . ticker = ticker ; super . finished <identifiersep> init ( ) ; } public void set <identifiersep> has <identifiersep> node <identifiersep> started ( ) { <LOG> synchronized ( this ) { this . has <identifiersep> node <identifiersep> started = true ; notify <identifiersep> all ( ) ; } } } <ect>
return null ; } if ( key <identifiersep> buf [ 0 ] != 1 || ( key <identifiersep> buf [ 1 ] != key . algo <identifiersep> aes <identifiersep> pcfb <identifiersep> <number_literal> <identifiersep> sha256 && key <identifiersep> buf [ 1 ] != key . algo <identifiersep> aes <identifiersep> ctr <identifiersep> <number_literal> <identifiersep> sha256 ) ) { if ( key <identifiersep> buf [ key <identifiersep> buf . length - 1 ] == 0 && key <identifiersep> buf [ key <identifiersep> buf . length - <number_literal> ] == 0 ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> if ( dont <identifiersep> verify ) throw new ssk <identifiersep> verify <identifiersep> exception ( <string_literal> ) ; } } <comment> <ect>
public void decompose ( ) { string r = routing <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( routing <identifiersep> key ) ; string k = crypto <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( crypto <identifiersep> key ) ; string e = extra == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( extra ) ; system . out . println ( <string_literal> + this ) ; system . out . println ( <string_literal> + key <identifiersep> type ) ; <LOG> system . out . println ( <string_literal> + r ) ; system . out . println ( <string_literal> + e ) ; system . out . println ( <string_literal> + ( doc <identifiersep> name == null ? <string_literal> : doc <identifiersep> name ) ) ; system . out . print ( <string_literal> ) ; if ( meta <identifiersep> str == null ) <ect>
system . out . println ( <string_literal> + r ) ; system . out . println ( <string_literal> + k ) ; system . out . println ( <string_literal> + e ) ; system . out . println ( <string_literal> + ( doc <identifiersep> name == null ? <string_literal> : doc <identifiersep> name ) ) ; system . out . print ( <string_literal> ) ; <LOG> if ( meta <identifiersep> str == null ) else system . out . println ( arrays . as <identifiersep> list ( meta <identifiersep> str ) . to <identifiersep> string ( ) ) ; } public string get <identifiersep> guessable <identifiersep> key ( ) { return get <identifiersep> doc <identifiersep> name ( ) ; } <comment> <ect>
<comment> <LOG> long time <identifiersep> sun = benchmark ( sun <identifiersep> hmac ) ; system . out . println ( algo + <string_literal> + sun <identifiersep> hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; if ( log <identifiersep> minor ) { logger . minor ( clazz , algo + <string_literal> + hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + sun <identifiersep> hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; } if ( time <identifiersep> sun < time <identifiersep> def ) { <ect>
system . out . println ( algo + <string_literal> + sun <identifiersep> hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; if ( log <identifiersep> minor ) { logger . minor ( clazz , algo + <string_literal> + hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + sun <identifiersep> hmac . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; } if ( time <identifiersep> sun < time <identifiersep> def ) { hmac = sun <identifiersep> hmac ; } } <LOG> } catch ( general <identifiersep> security <identifiersep> exception e ) { <comment> <ect>
} catch ( general <identifiersep> security <identifiersep> exception e ) { logger . warning ( clazz , algo + <string_literal> + sun + <string_literal> , e ) ; <comment> <LOG> hmac <identifiersep> provider = hmac . get <identifiersep> provider ( ) ; logger . normal ( clazz , algo + <string_literal> + hmac <identifiersep> provider ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> } catch ( unsupported <identifiersep> cipher <identifiersep> exception e ) { throw new error ( e ) ; } cipher . initialize ( enc <identifiersep> key ) ; <comment> <ect>
return new node <identifiersep> ssk ( pubkey <identifiersep> hash , encrypted <identifiersep> hashed <identifiersep> docname , null , crypto <identifiersep> algorithm ) ; } public boolean grab <identifiersep> pubkey ( get <identifiersep> pubkey pubkey <identifiersep> cache , boolean can <identifiersep> read <identifiersep> client <identifiersep> cache , boolean for <identifiersep> ulpr , block <identifiersep> metadata meta ) { if ( pub <identifiersep> key != null ) return false ; pub <identifiersep> key = pubkey <identifiersep> cache . get <identifiersep> key ( pub <identifiersep> key <identifiersep> hash , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , meta ) ; return pub <identifiersep> key != null ; } public static byte [ ] routing <identifiersep> key <identifiersep> from <identifiersep> full <identifiersep> key ( byte [ ] key <identifiersep> buf ) { <LOG> if ( key <identifiersep> buf . length != full <identifiersep> key <identifiersep> length ) { } byte [ ] encrypted <identifiersep> hashed <identifiersep> docname = arrays . copy <identifiersep> of <identifiersep> range ( key <identifiersep> buf , <number_literal> , <number_literal> + e <identifiersep> h <identifiersep> docname <identifiersep> size ) ; byte [ ] pub <identifiersep> key <identifiersep> hash = arrays . copy <identifiersep> of <identifiersep> range ( key <identifiersep> buf , <number_literal> + e <identifiersep> h <identifiersep> docname <identifiersep> size , <number_literal> + e <identifiersep> h <identifiersep> docname <identifiersep> size + pubkey <identifiersep> hash <identifiersep> size ) ; return make <identifiersep> routing <identifiersep> key ( pub <identifiersep> key <identifiersep> hash , encrypted <identifiersep> hashed <identifiersep> docname ) ; } @ override public int compare <identifiersep> to ( key arg0 ) { <ect>
s = null ; } sr = s ; try { accumulator <identifiersep> init ( digest ) ; reseed <identifiersep> init ( digest ) ; generator <identifiersep> init ( cipher ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( <string_literal> + e , e ) ; } if ( update <identifiersep> seed && ! ( seed . to <identifiersep> string ( ) ) . equals ( <string_literal> ) ) <comment> <ect>
bos = new buffered <identifiersep> output <identifiersep> stream ( fos ) ; dos = new data <identifiersep> output <identifiersep> stream ( bos ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) dos . write <identifiersep> long ( next <identifiersep> long ( ) ) ; dos . flush ( ) ; dos . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } finally { closer . close ( dos ) ; closer . close ( bos ) ; closer . close ( fos ) ; } } <comment> <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { if ( ( ( v > > i ) & 1 ) == 1 ) system . out . print ( '1' ) ; else system . out . print ( '0' ) ; } } else if ( args [ 0 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) <LOG> if ( ( args . length == 1 ) || args [ 1 ] . equals ( <string_literal> ) ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> int ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> long ( ) ) ; <ect>
if ( ( args . length == 1 ) || args [ 1 ] . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> int ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) <LOG> system . out . println ( r . next <identifiersep> long ( ) ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> float ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> double ( ) ) ; <ect>
system . out . println ( r . next <identifiersep> long ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> float ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) <LOG> system . out . println ( r . next <identifiersep> double ( ) ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> full <identifiersep> float ( ) ) ; system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) system . out . println ( r . next <identifiersep> full <identifiersep> double ( ) ) ; <ect>
<comment> kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> ) ; kg . initialize ( this . spec ) ; key = selftest ( kg , kf , modulus <identifiersep> size ) ; } catch ( throwable e ) { <LOG> <comment> kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kg . initialize ( this . spec ) ; key = selftest ( kg , kf , modulus <identifiersep> size ) ; } try { <ect>
private synchronized key <identifiersep> pair <identifiersep> generator get <identifiersep> key <identifiersep> pair <identifiersep> generator ( ) { if ( keygen <identifiersep> cached != null ) return keygen <identifiersep> cached ; key <identifiersep> pair <identifiersep> generator kg = null ; try { kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , kg <identifiersep> provider ) ; kg . initialize ( spec ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> algorithm <identifiersep> parameter <identifiersep> exception e ) { logger . error ( ecdh . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } keygen <identifiersep> cached = kg ; <ect>
try { key <identifiersep> agreement ka = null ; ka = key <identifiersep> agreement . get <identifiersep> instance ( <string_literal> , curve . ka <identifiersep> provider ) ; ka . init ( key . get <identifiersep> private ( ) ) ; ka . do <identifiersep> phase ( pubkey , true ) ; return ka . generate <identifiersep> secret ( ) ; <LOG> } catch ( invalid <identifiersep> key <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } return null ; <ect>
public static ec <identifiersep> public <identifiersep> key get <identifiersep> public <identifiersep> key ( byte [ ] data , curves curve ) { ec <identifiersep> public <identifiersep> key remote <identifiersep> public <identifiersep> key = null ; try { x509encoded <identifiersep> key <identifiersep> spec ks = new x509encoded <identifiersep> key <identifiersep> spec ( data ) ; key <identifiersep> factory kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , curve . kf <identifiersep> provider ) ; remote <identifiersep> public <identifiersep> key = ( ec <identifiersep> public <identifiersep> key ) kf . generate <identifiersep> public ( ks ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> spec <identifiersep> exception e ) { logger . error ( ecdh . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } return remote <identifiersep> public <identifiersep> key ; <ect>
public byte [ ] get <identifiersep> public <identifiersep> key <identifiersep> network <identifiersep> format ( ) { byte [ ] ret = get <identifiersep> public <identifiersep> key ( ) . get <identifiersep> encoded ( ) ; if ( ret . length == curve . modulus <identifiersep> size ) { return ret ; } else if ( ret . length > curve . modulus <identifiersep> size ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + curve . modulus <identifiersep> size + <string_literal> + ret . length ) ; <LOG> } else { byte [ ] out = new byte [ curve . modulus <identifiersep> size ] ; system . arraycopy ( ret , 0 , out , 0 , ret . length ) ; return ret ; } } } <ect>
} catch ( general <identifiersep> security <identifiersep> exception e ) { <comment> <LOG> provider md <identifiersep> provider = md . get <identifiersep> provider ( ) ; logger . normal ( clazz , algo + <string_literal> + md <identifiersep> provider ) ; md <identifiersep> providers <identifiersep> internal . put ( algo , md <identifiersep> provider ) ; } md <identifiersep> providers = collections . unmodifiable <identifiersep> map ( md <identifiersep> providers <identifiersep> internal ) ; ctx = message <identifiersep> digest . get <identifiersep> instance ( <string_literal> , md <identifiersep> providers . get ( <string_literal> ) ) ; ctx <identifiersep> length = ctx . get <identifiersep> digest <identifiersep> length ( ) ; <ect>
if ( ( args . length == 0 ) || args [ 0 ] . equals ( <string_literal> ) ) { write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; write <identifiersep> mpi ( new big <identifiersep> integer ( <string_literal> ) , system . out ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( read <identifiersep> mpi ( system . in ) ) ; system . out . println ( read <identifiersep> mpi ( system . in ) ) ; system . out . println ( <string_literal> ) ; system . out . println ( read <identifiersep> mpi ( system . in ) ) ; } else if ( args [ 0 ] . equals ( <string_literal> ) ) { write <identifiersep> mpi ( new big <identifiersep> integer ( args [ 1 ] ) , system . out ) ; <ect>
super ( proxy ) ; array <identifiersep> list < digester > digesters = new array <identifiersep> list < digester > ( ) ; for ( hash <identifiersep> type type : hash <identifiersep> type . values ( ) ) { if ( ( generate <identifiersep> hashes & type . bitmask ) == type . bitmask ) { try { digesters . add ( new digester ( type ) ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { } } } this . digesters = digesters . to <identifiersep> array ( new digester [ digesters . size ( ) ] ) ; } @ override public void write ( int arg0 ) throws java . io . io <identifiersep> exception { out . write ( arg0 ) ; for ( digester d : digesters ) <ect>
if ( is <identifiersep> freed ) { throw new io <identifiersep> exception ( <string_literal> + <string_literal> ) ; } output <identifiersep> stream uos = underlying . get <identifiersep> output <identifiersep> stream <identifiersep> unbuffered ( ) ; try { return new my <identifiersep> output <identifiersep> stream ( uos , setup ( uos ) ) ; <LOG> } catch ( general <identifiersep> security <identifiersep> exception e ) { throw new io <identifiersep> exception ( e ) ; } } class my <identifiersep> input <identifiersep> stream extends filter <identifiersep> input <identifiersep> stream { private final skipping <identifiersep> stream <identifiersep> cipher cipher <identifiersep> read ; public my <identifiersep> input <identifiersep> stream ( input <identifiersep> stream in , skipping <identifiersep> stream <identifiersep> cipher cipher ) { super ( in ) ; <ect>
if ( underlying . size ( ) < type . header <identifiersep> len ) throw new io <identifiersep> exception ( <string_literal> ) ; underlying . set <identifiersep> read <identifiersep> only ( ) ; lockable <identifiersep> random <identifiersep> access <identifiersep> buffer r = underlying . to <identifiersep> random <identifiersep> access <identifiersep> buffer ( ) ; try { return new encrypted <identifiersep> random <identifiersep> access <identifiersep> buffer ( type , r , master <identifiersep> key , false ) ; <LOG> } catch ( general <identifiersep> security <identifiersep> exception e ) { throw new io <identifiersep> exception ( e ) ; } } @ override public output <identifiersep> stream get <identifiersep> output <identifiersep> stream ( ) throws io <identifiersep> exception { return new buffered <identifiersep> output <identifiersep> stream ( get <identifiersep> output <identifiersep> stream <identifiersep> unbuffered ( ) ) ; } @ override <ect>
if ( results . length != hashes . length ) { logger . error ( hash <identifiersep> result . class , <string_literal> + results . length + <string_literal> + hashes . length + <string_literal> ) ; return false ; } for ( int i = 0 ; i < results . length ; i ++ ) { if ( results [ i ] . type != hashes [ i ] . type ) { <comment> <LOG> if ( hash <identifiersep> type . value <identifiersep> of ( results [ i ] . type . name ( ) ) != hash <identifiersep> type . value <identifiersep> of ( hashes [ i ] . type . name ( ) ) ) { return false ; } } if ( ! arrays . equals ( results [ i ] . result , hashes [ i ] . result ) ) { logger . error ( hash <identifiersep> result . class , <string_literal> + results [ i ] . type . name ( ) + <string_literal> ) ; return false ; } } return true ; <ect>
key <identifiersep> store <identifiersep> pass = ssl <identifiersep> config . get <identifiersep> string ( <string_literal> ) ; key <identifiersep> pass = ssl <identifiersep> config . get <identifiersep> string ( <string_literal> ) ; try { keystore = key <identifiersep> store . get <identifiersep> instance ( <string_literal> ) ; load <identifiersep> key <identifiersep> store ( ) ; create <identifiersep> ssl <identifiersep> context ( ) ; <LOG> } catch ( exception e ) { } ssl <identifiersep> config . finished <identifiersep> initialization ( ) ; } <comment> <ect>
class < ? > c = class . for <identifiersep> name ( <string_literal> ) ; p = ( provider ) c . new <identifiersep> instance ( ) ; security . add <identifiersep> provider ( p ) ; } catch ( throwable e ) { throw e ; } logger . debug ( bouncy <identifiersep> castle <identifiersep> loader . class , <string_literal> + p ) ; <LOG> } else { } try { <comment> <ect>
nss <identifiersep> provider = ( provider ) constructor . new <identifiersep> instance ( nss <identifiersep> file . get <identifiersep> path ( ) ) ; if ( atfirst ) security . insert <identifiersep> provider <identifiersep> at ( nss <identifiersep> provider , 1 ) ; else security . add <identifiersep> provider ( nss <identifiersep> provider ) ; logger . debug ( nss <identifiersep> loader . class , <string_literal> + nss <identifiersep> provider ) ; <LOG> } else { } return nss <identifiersep> provider ; } } static public void main ( string [ ] args ) { dump <identifiersep> loaded ( ) ; } static public void dump <identifiersep> loaded ( ) { system . out . println ( <string_literal> + bouncy <identifiersep> castle ) ; <ect>
} else { logger . debug ( nss <identifiersep> loader . class , <string_literal> + nss <identifiersep> provider ) ; } return nss <identifiersep> provider ; } } static public void main ( string [ ] args ) { dump <identifiersep> loaded ( ) ; } static public void dump <identifiersep> loaded ( ) { <LOG> system . out . println ( <string_literal> + bouncy <identifiersep> castle ) ; system . out . println ( <string_literal> + sun ) ; system . out . println ( <string_literal> + sun <identifiersep> jce ) ; } } <ect>
return nss <identifiersep> provider ; } } static public void main ( string [ ] args ) { dump <identifiersep> loaded ( ) ; } static public void dump <identifiersep> loaded ( ) { system . out . println ( <string_literal> + bouncy <identifiersep> castle ) ; system . out . println ( <string_literal> + nss ) ; <LOG> system . out . println ( <string_literal> + sun ) ; } } <ect>
message <identifiersep> digest md = item . get ( ) ; if ( md != null ) { return md ; } } return message <identifiersep> digest . get <identifiersep> instance ( <string_literal> , md <identifiersep> provider ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e2 ) { <comment> <LOG> logger . error ( node . class , <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } wrapper <identifiersep> manager . stop ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> crappy <identifiersep> jvm ) ; throw new runtime <identifiersep> exception ( ) ; } <comment> <ect>
. append ( fphex . substring ( <number_literal> , <number_literal> ) ) . append ( ' ' ) . append ( fphex . substring ( <number_literal> , <number_literal> ) ) ; return b . to <identifiersep> string ( ) ; } public static void main ( string [ ] args ) throws exception { for ( ; ; ) { <LOG> crypto <identifiersep> key kp = crypto <identifiersep> key . read ( system . in ) ; } } } <ect>
<comment> private static final int debuglevel = rdebug ? <number_literal> : 0 ; <comment> private static final boolean trace = false ; private static void debug ( string s ) { if ( log <identifiersep> debug ) logger . debug ( rijndael <identifiersep> algorithm . class , <string_literal> + name + <string_literal> + s ) ; } <LOG> private static void trace ( boolean in , string s ) { } <comment> <ect>
} ; <comment> <LOG> system . out . println ( <string_literal> + full <identifiersep> name ) ; system . out . println ( ) ; } int root = 0x11b ; int i , j = 0 ; <comment> <ect>
rcon [ 0 ] = 1 ; int r = 1 ; for ( int t = 1 ; t < <number_literal> ; ) rcon [ t ++ ] = ( byte ) ( r = mul ( <number_literal> , r ) ) ; time = system . current <identifiersep> time <identifiersep> millis ( ) - time ; if ( rdebug && ( log <identifiersep> debug ) ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( s [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( si [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
if ( rdebug && ( log <identifiersep> debug ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( s [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( i <identifiersep> g [ i ] [ j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t5 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t6 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t8 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t6 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t7 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t8 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t8 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( rcon [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> + time + <string_literal> ) ; system . out . println ( ) ; } } private static void generate <identifiersep> log <identifiersep> and <identifiersep> alog <identifiersep> tables ( int root ) { alog [ 0 ] = 1 ; <ect>
t2 [ ( t0 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ t3 [ ( t1 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ t4 [ t2 & 0x <identifiersep> ff ] ) ^ ker [ <number_literal> ] ; t0 = a0 ; t1 = a1 ; t2 = a2 ; <LOG> t3 = a3 ; } <comment> <ect>
t1 = a1 ; t2 = a2 ; t3 = a3 ; t4 = a4 ; t5 = a5 ; t6 = a6 ; <LOG> t7 = a7 ; } <comment> <ect>
t6 [ ( t2 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ t7 [ ( t1 > > > <number_literal> ) & 0x <identifiersep> ff ] ^ t8 [ t0 & 0x <identifiersep> ff ] ) ^ kdr [ <number_literal> ] ; t0 = a0 ; t1 = a1 ; t2 = a2 ; <LOG> t3 = a3 ; } <comment> <ect>
t1 = a1 ; t2 = a2 ; t3 = a3 ; t4 = a4 ; t5 = a5 ; t6 = a6 ; <LOG> t7 = a7 ; } <comment> <ect>
for ( int r = 1 ; r < rounds ; r ++ ) { <comment> <LOG> system . arraycopy ( a , 0 , t , 0 , bc ) ; } for ( i = 0 ; i < bc ; i ++ ) { <comment> <ect>
for ( int r = 1 ; r < rounds ; r ++ ) { <comment> <LOG> system . arraycopy ( a , 0 , t , 0 , bc ) ; } for ( i = 0 ; i < bc ; i ++ ) { <comment> <ect>
byte [ ] pt = new byte [ block <identifiersep> size ] ; int i ; for ( i = 0 ; i < keysize ; i ++ ) kb [ i ] = ( byte ) i ; for ( i = 0 ; i < block <identifiersep> size ; i ++ ) pt [ i ] = ( byte ) i ; <LOG> if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( ) ; system . out . println ( <string_literal> + ( <number_literal> * keysize ) ) ; system . out . println ( <string_literal> + to <identifiersep> string ( kb ) ) ; system . out . println ( ) ; } object key = make <identifiersep> key ( kb , block <identifiersep> size ) ; <ect>
kb [ i ] = ( byte ) i ; for ( i = 0 ; i < block <identifiersep> size ; i ++ ) pt [ i ] = ( byte ) i ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; <LOG> system . out . println ( <string_literal> + ( <number_literal> * keysize ) ) ; system . out . println ( ) ; } object key = make <identifiersep> key ( kb , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; <ect>
system . out . println ( <string_literal> + ( <number_literal> * keysize ) ) ; system . out . println ( <string_literal> + to <identifiersep> string ( kb ) ) ; system . out . println ( ) ; } object key = make <identifiersep> key ( kb , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( ) ; } byte [ ] ct = new byte [ block <identifiersep> size ] ; block <identifiersep> encrypt ( pt , ct , 0 , key , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> + to <identifiersep> string ( pt ) ) ; } byte [ ] ct = new byte [ block <identifiersep> size ] ; block <identifiersep> encrypt ( pt , ct , 0 , key , block <identifiersep> size ) ; if ( rdebug && ( log <identifiersep> minor ) ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( ) ; } byte [ ] cpt = new byte [ block <identifiersep> size ] ; block <identifiersep> decrypt ( ct , cpt , 0 , key , block <identifiersep> size ) ; ok = are <identifiersep> equal ( pt , cpt ) ; if ( ! ok ) throw new runtime <identifiersep> exception ( <string_literal> ) ; <ect>
try { cipher bcastle <identifiersep> cipher = cipher . get <identifiersep> instance ( algo , bcastle ) ; bcastle <identifiersep> cipher . init ( cipher . encrypt <identifiersep> mode , k , iv ) ; provider bcastle <identifiersep> provider = bcastle <identifiersep> cipher . get <identifiersep> provider ( ) ; if ( provider != bcastle <identifiersep> provider ) { long time <identifiersep> def = benchmark ( c , k , iv ) ; <LOG> long time <identifiersep> bcastle = benchmark ( bcastle <identifiersep> cipher , k , iv ) ; system . out . println ( algo + <string_literal> + bcastle <identifiersep> provider + <string_literal> + time <identifiersep> bcastle + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + provider + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + bcastle <identifiersep> provider + <string_literal> + time <identifiersep> bcastle + <string_literal> ) ; if ( time <identifiersep> bcastle < time <identifiersep> def ) { provider = bcastle <identifiersep> provider ; <ect>
logger . minor ( clazz , algo + <string_literal> + provider + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + bcastle <identifiersep> provider + <string_literal> + time <identifiersep> bcastle + <string_literal> ) ; if ( time <identifiersep> bcastle < time <identifiersep> def ) { provider = bcastle <identifiersep> provider ; c = bcastle <identifiersep> cipher ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> <comment> <ect>
} catch ( throwable e ) { <comment> <LOG> logger . normal ( rijndael . class , <string_literal> + provider ) ; return provider ; } catch ( general <identifiersep> security <identifiersep> exception e ) { logger . warning ( rijndael . class , <string_literal> , e ) ; return null ; } } <comment> <ect>
kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kg . initialize ( this . spec ) ; key = kg . generate <identifiersep> key <identifiersep> pair ( ) ; sig = signature . get <identifiersep> instance ( default <identifiersep> hash <identifiersep> algorithm , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; selftest <identifiersep> sign ( key , sig ) ; } <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> algorithm <identifiersep> parameter <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { <ect>
sig . update ( d ) ; result = sig . sign ( ) ; <comment> <LOG> else } } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; <ect>
break ; else logger . error ( this , <string_literal> + result . length + <string_literal> + curve . max <identifiersep> sig <identifiersep> size + <string_literal> ) ; } } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( invalid <identifiersep> key <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( signature <identifiersep> exception e ) { logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; <ect>
sig . init <identifiersep> verify ( key ) ; for ( byte [ ] d : data ) sig . update ( d ) ; <comment> <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( signature <identifiersep> exception e ) { <ect>
} catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( signature <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; } public ec <identifiersep> public <identifiersep> key get <identifiersep> public <identifiersep> key ( ) { return ( ec <identifiersep> public <identifiersep> key ) key . get <identifiersep> public ( ) ; } <comment> <ect>
x509encoded <identifiersep> key <identifiersep> spec ks = new x509encoded <identifiersep> key <identifiersep> spec ( data ) ; key <identifiersep> factory kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , curve . kf <identifiersep> provider ) ; remote <identifiersep> public <identifiersep> key = ( ec <identifiersep> public <identifiersep> key ) kf . generate <identifiersep> public ( ks ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( ecdsa . class , <string_literal> + e . get <identifiersep> message ( ) , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( invalid <identifiersep> key <identifiersep> spec <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } return remote <identifiersep> public <identifiersep> key ; } <comment> <ect>
msg = null ; break ; } if ( msg . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> opennet <identifiersep> disabled ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; msg = null ; break ; } <LOG> if ( msg . get <identifiersep> spec ( ) != dmt . fnp <identifiersep> accepted ) { continue ; } break ; } if ( ( msg == null ) || ( msg . get <identifiersep> spec ( ) != dmt . fnp <identifiersep> accepted ) ) { <comment> <ect>
if ( msg . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> opennet <identifiersep> announce <identifiersep> node <identifiersep> not <identifiersep> wanted ) { if ( cb != null ) cb . node <identifiersep> not <identifiersep> wanted ( ) ; if ( source != null ) { try { send <identifiersep> not <identifiersep> wanted ( ) ; <LOG> } catch ( not <identifiersep> connected <identifiersep> exception e ) { return ; } } continue ; <comment> <ect>
send <identifiersep> our <identifiersep> ref ( source , om . crypto . my <identifiersep> compressed <identifiersep> full <identifiersep> ref ( ) ) ; } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; send <identifiersep> not <identifiersep> wanted ( ) ; <comment> <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; return false ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . warning ( this , <string_literal> + e , e ) ; opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; <ect>
opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; return false ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . warning ( this , <string_literal> + e , e ) ; opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; return false ; <LOG> } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { opennet <identifiersep> manager . reject <identifiersep> ref ( uid , source , dmt . noderef <identifiersep> rejected <identifiersep> invalid , this ) ; return false ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . normal ( this , <string_literal> ) ; return false ; <ect>
msg = <string_literal> + get <identifiersep> opennet <identifiersep> peers ( ) . length + <string_literal> + peers <identifiersep> file ; else msg = <string_literal> + get <identifiersep> darknet <identifiersep> peers ( ) . length + <string_literal> + peers <identifiersep> file ; logger . normal ( this , msg ) ; system . out . println ( msg ) ; return ; } } <LOG> if ( ! is <identifiersep> opennet ) <comment> <ect>
logger . error ( this , <string_literal> + pn ) ; else opennet . add <identifiersep> old <identifiersep> opennet <identifiersep> node ( ( opennet <identifiersep> peer <identifiersep> node ) pn ) ; } else add <identifiersep> peer ( pn , true , false ) ; got <identifiersep> some = true ; <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <ect>
got <identifiersep> some = true ; } catch ( fs <identifiersep> parse <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <ect>
continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; <LOG> } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; } catch ( runtime <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; <ect>
continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 + ' \\ n' + fs . to <identifiersep> string ( ) , e2 ) ; system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; <LOG> } catch ( runtime <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; <comment> <ect>
system . err . println ( <string_literal> + e2 ) ; some <identifiersep> broken = true ; continue ; <comment> <LOG> <comment> <ect>
} catch ( eof <identifiersep> exception e ) { <comment> <LOG> } catch ( io <identifiersep> exception e3 ) { } if ( some <identifiersep> broken ) { try { broken <identifiersep> peers <identifiersep> file . delete ( ) ; file <identifiersep> output <identifiersep> stream fos = new file <identifiersep> output <identifiersep> stream ( broken <identifiersep> peers <identifiersep> file ) ; fis = new file <identifiersep> input <identifiersep> stream ( peers <identifiersep> file ) ; <ect>
} catch ( io <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + e2 , e2 ) ; closer . close ( fos ) ; return ; } try { fos = new file <identifiersep> output <identifiersep> stream ( f ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e2 ) { closer . close ( fos ) ; f . delete ( ) ; return ; } output <identifiersep> stream <identifiersep> writer w = null ; try { <ect>
} else { file <identifiersep> util . rename <identifiersep> to ( f , get <identifiersep> backup <identifiersep> filename ( filename , 0 ) ) ; } } catch ( io <identifiersep> exception e ) { try { fos . close ( ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> logger . error ( this , <string_literal> + e , e ) ; } f . delete ( ) ; return ; <comment> <ect>
return oldest <identifiersep> never <identifiersep> connected <identifiersep> darknet <identifiersep> peer <identifiersep> age ; } <comment> public void maybe <identifiersep> log <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> summary ( long now ) { if ( now > next <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> log <identifiersep> time ) { <LOG> if ( ( now - next <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> log <identifiersep> time ) > seconds . to <identifiersep> millis ( <number_literal> ) && next <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> log <identifiersep> time > 0 ) int number <identifiersep> of <identifiersep> connected = 0 ; int number <identifiersep> of <identifiersep> routing <identifiersep> backed <identifiersep> off = 0 ; int number <identifiersep> of <identifiersep> too <identifiersep> new = 0 ; int number <identifiersep> of <identifiersep> too <identifiersep> old = 0 ; int number <identifiersep> of <identifiersep> disconnected = 0 ; <ect>
case peer <identifiersep> node <identifiersep> status <identifiersep> routing <identifiersep> disabled : number <identifiersep> of <identifiersep> routing <identifiersep> disabled ++ ; break ; case peer <identifiersep> node <identifiersep> status <identifiersep> no <identifiersep> load <identifiersep> stats : number <identifiersep> of <identifiersep> no <identifiersep> load <identifiersep> stats ++ ; break ; <LOG> default : break ; } } logger . normal ( this , <string_literal> + number <identifiersep> of <identifiersep> connected + <string_literal> + number <identifiersep> of <identifiersep> routing <identifiersep> backed <identifiersep> off + <string_literal> + number <identifiersep> of <identifiersep> too <identifiersep> new + <string_literal> + number <identifiersep> of <identifiersep> too <identifiersep> old + <string_literal> + number <identifiersep> of <identifiersep> disconnected + <string_literal> + number <identifiersep> of <identifiersep> never <identifiersep> connected + <string_literal> + number <identifiersep> of <identifiersep> disabled + <string_literal> + number <identifiersep> of <identifiersep> bursting + <string_literal> + number <identifiersep> of <identifiersep> listening + <string_literal> + number <identifiersep> of <identifiersep> listen <identifiersep> only + <string_literal> + number <identifiersep> of <identifiersep> clock <identifiersep> problem + <string_literal> + number <identifiersep> of <identifiersep> conn <identifiersep> error + <string_literal> + number <identifiersep> of <identifiersep> disconnecting + <string_literal> + number <identifiersep> of <identifiersep> no <identifiersep> load <identifiersep> stats ) ; next <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> log <identifiersep> time = now + peer <identifiersep> node <identifiersep> status <identifiersep> log <identifiersep> interval ; } } public void change <identifiersep> peer <identifiersep> node <identifiersep> status ( peer <identifiersep> node peer <identifiersep> node , int old <identifiersep> peer <identifiersep> node <identifiersep> status , int peer <identifiersep> node <identifiersep> status , boolean no <identifiersep> log ) { <ect>
if ( ( udp != null ) && ( udp . length > 0 ) ) { for ( string u : udp ) { <comment> <LOG> } catch ( hostname <identifiersep> syntax <identifiersep> exception e ) { system . err . println ( <string_literal> + u ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { throw ( io <identifiersep> exception ) new io <identifiersep> exception ( ) . init <identifiersep> cause ( e ) ; } if ( p . get <identifiersep> port ( ) == crypto . port <identifiersep> number ) { <ect>
if ( never <identifiersep> connected1 && ( ! never <identifiersep> connected2 ) ) return - 1 ; if ( ( ! never <identifiersep> connected1 ) && never <identifiersep> connected2 ) return 1 ; <comment> <LOG> else if ( pn1 . hash <identifiersep> code < pn2 . hash <identifiersep> code ) return - 1 ; return fields . compare <identifiersep> object <identifiersep> id ( pn1 , pn2 ) ; } } ) ; for ( opennet <identifiersep> peer <identifiersep> node opn : nodes ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
if ( crypto . allow <identifiersep> connection ( node <identifiersep> to <identifiersep> add <identifiersep> now , addr ) ) okay = true ; else { <comment> <LOG> } else { } if ( any && ! okay ) { logger . normal ( this , <string_literal> ) ; return false ; } } int max <identifiersep> peers = get <identifiersep> number <identifiersep> of <identifiersep> connected <identifiersep> peers <identifiersep> to <identifiersep> aim ( distance ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + max <identifiersep> peers ) ; <ect>
if ( length > max <identifiersep> opennet <identifiersep> noderef <identifiersep> length ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + length + <string_literal> + max <identifiersep> opennet <identifiersep> noderef <identifiersep> length ) ; return ( ( length > > > <number_literal> ) + ( ( length & <number_literal> ) == 0 ? 0 : 1 ) ) < < <number_literal> ; } public void send <identifiersep> announcement <identifiersep> reply ( long uid , peer <identifiersep> node peer , byte [ ] noderef , byte <identifiersep> counter ctr ) throws not <identifiersep> connected <identifiersep> exception { byte [ ] padded = new byte [ padded <identifiersep> noderef <identifiersep> size ] ; <LOG> if ( noderef . length > padded . length ) { return ; } system . arraycopy ( noderef , 0 , padded , 0 , noderef . length ) ; long xfer <identifiersep> uid = node . random . next <identifiersep> long ( ) ; message msg = dmt . create <identifiersep> fnp <identifiersep> opennet <identifiersep> announce <identifiersep> reply ( uid , xfer <identifiersep> uid , noderef . length , padded . length ) ; <ect>
ref = peer <identifiersep> node . compressed <identifiersep> noderef <identifiersep> to <identifiersep> field <identifiersep> set ( noderef , 0 , noderef . length ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( opennet <identifiersep> manager . class , <string_literal> + e , e ) ; return null ; } if ( force <identifiersep> opennet <identifiersep> enabled ) ref . put ( <string_literal> , true ) ; <LOG> if ( ! opennet <identifiersep> peer <identifiersep> node . validate <identifiersep> ref ( ref ) ) { return null ; } if ( ref != null ) { string identity = ref . get ( <string_literal> ) ; if ( identity != null ) <comment> <ect>
logger . error ( this , msg ) ; system . err . println ( msg + <string_literal> ) ; override <identifiersep> ip <identifiersep> address = null ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <comment> <LOG> logger . error ( this , msg ) ; override <identifiersep> ip <identifiersep> address = null ; } } <comment> <ect>
if ( pn . cached <identifiersep> removed ( ) ) { if ( log <identifiersep> minor && pn . node . peers . have <identifiersep> peer ( pn ) ) { logger . error ( this , <string_literal> + pn ) ; } else { return ; } } if ( ! pn . node . peers . have <identifiersep> peer ( pn ) ) { <LOG> if ( ! pn . cached <identifiersep> removed ( ) ) return ; } pn . set <identifiersep> peer <identifiersep> node <identifiersep> status ( system . current <identifiersep> time <identifiersep> millis ( ) , true ) ; } } <ect>
this . essential = essential ; this . for <identifiersep> build = for <identifiersep> build ; } @ override public void on <identifiersep> success ( ) { if ( ! essential ) { system . out . println ( <string_literal> + dep . new <identifiersep> filename + <string_literal> ) ; <LOG> return ; } boolean to <identifiersep> deploy = false ; boolean for <identifiersep> current <identifiersep> version = false ; synchronized ( main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . this ) { downloaders . remove ( this ) ; if ( for <identifiersep> build == build ) { <comment> <ect>
if ( to <identifiersep> deploy ) deploy ( ) ; else if ( for <identifiersep> current <identifiersep> version ) deployer . reannounce ( ) ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { if ( ! essential ) { logger . error ( this , <string_literal> + dep . new <identifiersep> filename + <string_literal> + e , e ) ; <LOG> } else { synchronized ( main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . this ) { downloaders . remove ( this ) ; if ( for <identifiersep> build != build ) return ; broken = true ; } } } public void cancel ( ) { <ect>
return inner <identifiersep> handle ( props , build ) ; } catch ( runtime <identifiersep> exception e ) { broken = true ; logger . error ( this , <string_literal> + e , e ) ; throw e ; } catch ( error e ) { <LOG> broken = true ; throw e ; } } enum dependency <identifiersep> type { <comment> classpath , <ect>
continue ; } } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { if ( s . starts <identifiersep> with ( <string_literal> ) ) { <comment> <LOG> <comment> <ect>
broken = true ; continue ; } file filename = null ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; <comment> <LOG> if ( filename == null ) { broken = true ; continue ; } if ( filename . get <identifiersep> parent <identifiersep> file ( ) != null ) filename . get <identifiersep> parent <identifiersep> file ( ) . mkdirs ( ) ; freenet <identifiersep> uri max <identifiersep> chk = null ; <ect>
<comment> <LOG> if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { dependencies . add ( new dependency ( current <identifiersep> file , filename , p , order ) ) ; continue ; } else { system . out . println ( <string_literal> + filename + <string_literal> ) ; filename . delete ( ) ; <ect>
dependencies . add ( new dependency ( current <identifiersep> file , filename , p , order ) ) ; continue ; } else { system . out . println ( <string_literal> + filename + <string_literal> ) ; filename . delete ( ) ; } } if ( valid <identifiersep> file ( filename , expected <identifiersep> hash , size , executable ) ) { <LOG> <comment> <ect>
if ( p == null ) { <comment> <LOG> broken = true ; system . err . println ( <string_literal> + fe ) ; } } else { <comment> <ect>
fetch <identifiersep> dependency ( max <identifiersep> chk , new dependency ( current <identifiersep> file , filename , p , order ) , expected <identifiersep> hash , size , true , executable ) ; } catch ( fetch <identifiersep> exception fe ) { broken = true ; logger . error ( this , <string_literal> + fe , fe ) ; system . err . println ( <string_literal> + fe ) ; } } else { <LOG> <comment> <ect>
if ( ! p . matcher ( name . to <identifiersep> lower <identifiersep> case ( ) ) . matches ( ) ) continue ; if ( valid <identifiersep> file ( f , expected <identifiersep> hash , size , executable ) ) { <comment> <LOG> if ( max <identifiersep> chk == null ) { broken = true ; continue ; } <comment> <ect>
continue ; } <comment> <LOG> logger . error ( this , <string_literal> + e , e ) ; } } if ( ready ( ) ) return new main <identifiersep> jar <identifiersep> dependencies ( new tree <identifiersep> set < dependency > ( dependencies ) , build ) ; else return null ; } private static boolean matches <identifiersep> current <identifiersep> os ( string s ) { <ect>
f . delete ( ) ; } for ( string prop <identifiersep> name : props . string <identifiersep> property <identifiersep> names ( ) ) { if ( ! prop <identifiersep> name . contains ( <string_literal> ) ) continue ; string base <identifiersep> name = prop <identifiersep> name . split ( <string_literal> ) [ 0 ] ; if ( ! processed . add ( base <identifiersep> name ) ) continue ; string s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; <LOG> if ( s == null ) { continue ; } final dependency <identifiersep> type type ; try { type = dependency <identifiersep> type . value <identifiersep> of ( s ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { <ect>
logger . normal ( this , <string_literal> + base <identifiersep> name + <string_literal> ) ; continue ; } } <comment> <LOG> logger . normal ( this , <string_literal> + base <identifiersep> name + <string_literal> + must <identifiersep> be <identifiersep> on <identifiersep> path <identifiersep> not <identifiersep> a <identifiersep> script + <string_literal> ) ; continue ; } if ( type == dependency <identifiersep> type . optional <identifiersep> atomic <identifiersep> multi <identifiersep> files <identifiersep> with <identifiersep> restart ) { parse <identifiersep> atomic <identifiersep> multi <identifiersep> files <identifiersep> with <identifiersep> restart ( props , base <identifiersep> name ) ; continue ; } <comment> <ect>
logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> ) ; return false ; } file filename = null ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; <comment> <LOG> if ( filename == null ) { return false ; } final freenet <identifiersep> uri key ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( s == null ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + base <identifiersep> name + <string_literal> ) ; <ect>
s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( s == null ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + base <identifiersep> name + <string_literal> ) ; return false ; } try { key = new freenet <identifiersep> uri ( s ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { return false ; } pattern p = null ; <comment> <ect>
string regex = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( regex == null ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + base <identifiersep> name + <string_literal> ) ; return false ; } try { p = pattern . compile ( regex ) ; <LOG> } catch ( pattern <identifiersep> syntax <identifiersep> exception e ) { return false ; } } final byte [ ] expected <identifiersep> hash = parse <identifiersep> expected <identifiersep> hash ( props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) , base <identifiersep> name ) ; if ( expected <identifiersep> hash == null ) { system . err . println ( <string_literal> + build + <string_literal> + base <identifiersep> name ) ; return false ; <ect>
long size = - 1 ; if ( s != null ) { try { size = long . parse <identifiersep> long ( s ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { size = - 1 ; } } <LOG> if ( size < 0 ) { return false ; } s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( s != null ) { try { <comment> <ect>
if ( type == dependency <identifiersep> type . classpath ) current <identifiersep> file = get <identifiersep> dependency <identifiersep> in <identifiersep> use ( p ) ; if ( type == dependency <identifiersep> type . optional <identifiersep> classpath <identifiersep> no <identifiersep> update && filename . exists ( ) ) { if ( filename . can <identifiersep> read ( ) && filename . length ( ) > 0 ) { logger . normal ( main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . class , <string_literal> + filename ) ; continue ; <LOG> } else { filename . delete ( ) ; } } if ( ! ( type == dependency <identifiersep> type . classpath || type == dependency <identifiersep> type . optional <identifiersep> preload || type == dependency <identifiersep> type . optional <identifiersep> classpath <identifiersep> no <identifiersep> update ) ) { <comment> <ect>
valid <identifiersep> file ( current <identifiersep> file , expected <identifiersep> hash , size , executable ) ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> public void on <identifiersep> success ( ) { if ( ! type . optional ) { system . out . println ( <string_literal> + file + <string_literal> ) ; deployer . add <identifiersep> dependency ( expected <identifiersep> hash , file ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { <ect>
public void on <identifiersep> success ( ) { system . out . println ( <string_literal> + file + <string_literal> ) ; if ( ! type . optional ) { system . out . println ( <string_literal> + file + <string_literal> ) ; deployer . add <identifiersep> dependency ( expected <identifiersep> hash , file ) ; } } @ override <LOG> public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { } } , type . optional ? 0 : build , false , executable ) ; } catch ( fetch <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + file + <string_literal> + key + <string_literal> + e , e ) ; } } if ( current <identifiersep> file == null ) continue ; <comment> <ect>
<comment> <LOG> f . delete ( ) ; continue ; } if ( fields . compare <identifiersep> version ( file <identifiersep> version , version ) < = 0 ) { f . delete ( ) ; system . out . println ( <string_literal> + f ) ; } <comment> <ect>
s = props . get <identifiersep> property ( file <identifiersep> base + <string_literal> ) ; if ( s == null ) { must <identifiersep> exist = must <identifiersep> exist . false ; } else { try { must <identifiersep> exist = must <identifiersep> exist . value <identifiersep> of ( s . to <identifiersep> upper <identifiersep> case ( ) ) ; <LOG> } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { atomic <identifiersep> deployer . cleanup ( ) ; return false ; } } boolean must <identifiersep> be <identifiersep> on <identifiersep> class <identifiersep> path = false ; s = props . get <identifiersep> property ( file <identifiersep> base + <string_literal> ) ; if ( s != null ) { <ect>
<comment> <LOG> if ( must <identifiersep> exist != must <identifiersep> exist . false ) { atomic <identifiersep> deployer . cleanup ( ) ; return false ; } nothing <identifiersep> to <identifiersep> do = false ; system . out . println ( <string_literal> + filename + <string_literal> + name ) ; } else if ( ! valid <identifiersep> file ( filename , expected <identifiersep> hash , size , executable ) ) { <ect>
system . out . println ( <string_literal> + name + <string_literal> + filename ) ; atomic <identifiersep> deployer . cleanup ( ) ; return false ; } nothing <identifiersep> to <identifiersep> do = false ; system . out . println ( <string_literal> + filename + <string_literal> + name ) ; } else if ( ! valid <identifiersep> file ( filename , expected <identifiersep> hash , size , executable ) ) { <LOG> if ( must <identifiersep> exist == must <identifiersep> exist . exact ) { atomic <identifiersep> deployer . cleanup ( ) ; return false ; } system . out . println ( <string_literal> + filename + <string_literal> + name ) ; nothing <identifiersep> to <identifiersep> do = false ; } else if ( must <identifiersep> exist == must <identifiersep> exist . exact ) <ect>
system . out . println ( <string_literal> + filename + <string_literal> + name ) ; nothing <identifiersep> to <identifiersep> do = false ; } else if ( must <identifiersep> exist == must <identifiersep> exist . exact ) continue ; if ( must <identifiersep> be <identifiersep> on <identifiersep> class <identifiersep> path ) { file f = get <identifiersep> dependency <identifiersep> in <identifiersep> use ( pattern . compile ( pattern . quote ( filename . get <identifiersep> name ( ) ) ) ) ; <LOG> if ( f == null ) { atomic <identifiersep> deployer . cleanup ( ) ; return false ; } } atomic <identifiersep> dependency dependency ; try { dependency = new atomic <identifiersep> dependency ( filename , key , size , expected <identifiersep> hash , executable ) ; <ect>
dependency = new atomic <identifiersep> dependency ( filename , key , size , expected <identifiersep> hash , executable ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + name + <string_literal> + e ) ; atomic <identifiersep> deployer . cleanup ( ) ; return false ; } atomic <identifiersep> deployer . add ( dependency ) ; } <LOG> if ( nothing <identifiersep> to <identifiersep> do ) { atomic <identifiersep> deployer . cleanup ( ) ; return false ; <comment> <ect>
system . out . println ( <string_literal> + filename + <string_literal> + key ) ; try { jar <identifiersep> fetcher fetcher = deployer . fetch ( key , temp <identifiersep> filename , size , expected <identifiersep> hash , this , build , false , executable <comment> ) ; synchronized ( this ) { this . fetcher = fetcher ; } return true ; <LOG> } catch ( fetch <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> ) ; return false ; } } @ override public void on <identifiersep> success ( ) { atomic <identifiersep> deployer d ; <ect>
return false ; } } @ override public void on <identifiersep> success ( ) { atomic <identifiersep> deployer d ; synchronized ( this ) { succeeded <identifiersep> fetch = true ; <LOG> d = my <identifiersep> deployer ; } d . on <identifiersep> success ( this ) ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e ) { system . out . println ( <string_literal> + filename + <string_literal> + key ) ; get <identifiersep> deployer ( ) . on <identifiersep> failure ( this , e ) ; <ect>
jar <identifiersep> fetcher f ; synchronized ( this ) { f = fetcher ; fetcher = null ; } if ( f == null ) return ; f . cancel ( ) ; } <LOG> boolean backup <identifiersep> original ( ) { if ( ! filename . exists ( ) ) { synchronized ( this ) { nothing <identifiersep> to <identifiersep> backup = true ; backed <identifiersep> up = true ; } return true ; <ect>
} else return false ; } } boolean revert <identifiersep> from <identifiersep> backup ( ) { synchronized ( this ) { assert ( succeeded <identifiersep> fetch ) ; assert ( backed <identifiersep> up ) ; <LOG> if ( ! tried <identifiersep> deploy ) return true ; <comment> <ect>
void cleanup ( ) { temp <identifiersep> filename . delete ( ) ; backup <identifiersep> filename . delete ( ) ; } } private atomic <identifiersep> deployer create <identifiersep> restarting <identifiersep> atomic <identifiersep> deployer ( string name ) { if ( file <identifiersep> util . detected <identifiersep> os . is <identifiersep> unix || file <identifiersep> util . detected <identifiersep> os . is <identifiersep> mac ) { return new unix <identifiersep> restarting <identifiersep> atomic <identifiersep> deployer ( name ) ; <LOG> } else if ( file <identifiersep> util . detected <identifiersep> os . is <identifiersep> windows ) { <comment> <ect>
for ( atomic <identifiersep> dependency dep : dependencies ( ) ) { dep . cancel ( ) ; dep . cleanup ( ) ; } } public void on <identifiersep> failure ( atomic <identifiersep> dependency dep , fetch <identifiersep> exception e ) { synchronized ( this ) { failed = true ; <LOG> dependencies <identifiersep> waiting . remove ( dep ) ; } cleanup ( ) ; } public void on <identifiersep> success ( atomic <identifiersep> dependency dep ) { synchronized ( this ) { assert ( dependencies . contains ( dep ) ) ; dependencies <identifiersep> waiting . remove ( dep ) ; <ect>
failed = true ; return ; } dependencies . add ( dependency ) ; dependencies <identifiersep> waiting . add ( dependency ) ; } public void start ( ) { for ( atomic <identifiersep> dependency dep : dependencies ( ) ) { <LOG> if ( ! dep . start ( this ) ) { atomic <identifiersep> dependency [ ] deps ; synchronized ( this ) { failed = true ; deps = dependencies ( ) ; } for ( atomic <identifiersep> dependency kill : deps ) { <ect>
system . err . println ( <string_literal> + name ) ; return false ; } else return true ; } <comment> boolean inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) { synchronized ( this ) { <LOG> if ( failed || ! started ) { return false ; } } atomic <identifiersep> dependency [ ] deps = dependencies ( ) ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . backup <identifiersep> original ( ) ) { system . err . println ( <string_literal> + dep . filename + <string_literal> + name ) ; <ect>
if ( ! dep . backup <identifiersep> original ( ) ) { system . err . println ( <string_literal> + dep . filename + <string_literal> + name ) ; return false ; } } boolean failed <identifiersep> deploy = false ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . deploy ( ) ) { <LOG> failed <identifiersep> deploy = true ; break ; } } if ( failed <identifiersep> deploy ) { system . err . println ( <string_literal> + name ) ; system . err . println ( <string_literal> ) ; for ( atomic <identifiersep> dependency dep : deps ) { <ect>
for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . deploy ( ) ) { failed <identifiersep> deploy = true ; system . err . println ( <string_literal> + dep . filename + <string_literal> + dep . temp <identifiersep> filename + <string_literal> + name ) ; break ; } } if ( failed <identifiersep> deploy ) { <LOG> system . err . println ( <string_literal> + name ) ; for ( atomic <identifiersep> dependency dep : deps ) { if ( ! dep . revert <identifiersep> from <identifiersep> backup ( ) ) { system . err . println ( <string_literal> + dep . backup <identifiersep> filename + <string_literal> + dep . filename ) ; <comment> <ect>
@ override protected boolean deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) { if ( ! wrapper <identifiersep> manager . is <identifiersep> controlled <identifiersep> by <identifiersep> native <identifiersep> wrapper ( ) ) return false ; file restart <identifiersep> script ; try { restart <identifiersep> script = create <identifiersep> restart <identifiersep> script ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + name + <string_literal> + e , e ) ; return false ; } if ( restart <identifiersep> script == null ) return false ; file shell = find <identifiersep> shell ( ) ; if ( shell == null ) return false ; <ect>
return false ; } if ( restart <identifiersep> script == null ) return false ; file shell = find <identifiersep> shell ( ) ; if ( shell == null ) return false ; if ( inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) ) { try { <comment> <LOG> if ( runtime . get <identifiersep> runtime ( ) . exec ( new string [ ] { shell . to <identifiersep> string ( ) , restart <identifiersep> script . to <identifiersep> string ( ) } ) == null ) { return false ; } } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name + <string_literal> + e ) ; logger . error ( this , <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name + <string_literal> + e , e ) ; return false ; <ect>
for ( string s : split ) { file f = new file ( s ) ; if ( name . equals <identifiersep> ignore <identifiersep> case ( f . get <identifiersep> name ( ) ) ) return true ; } return false ; } private static byte [ ] parse <identifiersep> expected <identifiersep> hash ( string sha256 , string base <identifiersep> name ) { <LOG> if ( sha256 == null ) { return null ; } try { return hex <identifiersep> util . hex <identifiersep> to <identifiersep> bytes ( sha256 ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + sha256 + <string_literal> + e , e ) ; <ect>
return null ; } try { return hex <identifiersep> util . hex <identifiersep> to <identifiersep> bytes ( sha256 ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + sha256 + <string_literal> + e , e ) ; return null ; <LOG> } catch ( index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception e ) { return null ; } } public static boolean valid <identifiersep> file ( file filename , byte [ ] expected <identifiersep> hash , long size , boolean executable ) { if ( filename == null ) return false ; if ( ! filename . exists ( ) ) return false ; if ( filename . length ( ) != size ) { <ect>
if ( arrays . equals ( hash , expected <identifiersep> hash ) ) { if ( executable && ! filename . can <identifiersep> execute ( ) ) { filename . set <identifiersep> executable ( true ) ; } return true ; } else { return false ; } <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { return false ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + filename + <string_literal> ) ; return false ; } finally { <ect>
synchronized ( this ) { if ( ! ready <identifiersep> to <identifiersep> deploy ) return false ; if ( deploy <identifiersep> on <identifiersep> no <identifiersep> revocation ) { <comment> <LOG> deploy <identifiersep> on <identifiersep> next <identifiersep> no <identifiersep> revocation = false ; return true ; } else return false ; } <comment> <ect>
} else return false ; } <comment> <LOG> return false ; } <comment> <ect>
return false ; } system . out . println ( <string_literal> + plugin <identifiersep> name + <string_literal> ) ; <comment> <LOG> logger . error ( this , <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; <comment> <ect>
logger . normal ( this , <string_literal> + plugin <identifiersep> name + <string_literal> + required <identifiersep> node <identifiersep> version ) ; } } @ override protected void parse <identifiersep> manifest <identifiersep> line ( string line ) { if ( line . starts <identifiersep> with ( required <identifiersep> node <identifiersep> version <identifiersep> prefix ) ) { required <identifiersep> node <identifiersep> version = integer . parse <identifiersep> int ( line . substring ( required <identifiersep> node <identifiersep> version <identifiersep> prefix . length ( ) ) ) ; } } @ override <LOG> protected void on <identifiersep> start <identifiersep> fetching ( ) { } @ override protected void process <identifiersep> success ( int build , fetch <identifiersep> result result , file blob ) { bucket old <identifiersep> result = null ; synchronized ( this ) { if ( required <identifiersep> node <identifiersep> version > version . build <identifiersep> number ( ) ) { <ect>
if ( this . result != null ) old <identifiersep> result = this . result . as <identifiersep> bucket ( ) ; this . result = result ; } if ( old <identifiersep> result != null ) old <identifiersep> result . free ( ) ; plugin <identifiersep> info <identifiersep> wrapper loaded = plugin <identifiersep> manager . get <identifiersep> plugin <identifiersep> info ( plugin <identifiersep> name ) ; if ( loaded == null ) { <LOG> if ( ! node . plugin <identifiersep> manager . is <identifiersep> plugin <identifiersep> loaded <identifiersep> or <identifiersep> loading <identifiersep> or <identifiersep> want <identifiersep> load ( plugin <identifiersep> name ) ) { logger . error ( this , <string_literal> + plugin <identifiersep> name ) ; temp <identifiersep> blob <identifiersep> file . delete ( ) ; return ; } } if ( loaded . get <identifiersep> plugin <identifiersep> long <identifiersep> version ( ) >= fetched <identifiersep> version ) { temp <identifiersep> blob <identifiersep> file . delete ( ) ; <ect>
return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + key , names , values ) ; } public void write <identifiersep> jar <identifiersep> to ( fetch <identifiersep> result result , file f <identifiersep> new ) throws io <identifiersep> exception { int fetched ; synchronized ( this ) { fetched = fetched <identifiersep> version ; } synchronized ( write <identifiersep> jar <identifiersep> sync ) { <LOG> if ( ! f <identifiersep> new . delete ( ) && f <identifiersep> new . exists ( ) ) { } file <identifiersep> output <identifiersep> stream fos ; fos = new file <identifiersep> output <identifiersep> stream ( f <identifiersep> new ) ; bucket <identifiersep> tools . copy <identifiersep> to ( result . as <identifiersep> bucket ( ) , fos , - 1 ) ; fos . flush ( ) ; fos . close ( ) ; <ect>
a = alert ; alert = null ; } if ( a != null ) node . client <identifiersep> core . alerts . unregister ( a ) ; } public synchronized void arm ( boolean was <identifiersep> running ) { if ( was <identifiersep> running ) { <LOG> deploy <identifiersep> on <identifiersep> next <identifiersep> no <identifiersep> revocation = true ; } else { deploy <identifiersep> on <identifiersep> no <identifiersep> revocation = true ; system . out . println ( <string_literal> + plugin <identifiersep> name + <string_literal> ) ; } } @ override public request <identifiersep> client get <identifiersep> request <identifiersep> client ( ) { <ect>
if ( blob <identifiersep> file . exists ( ) ) { array <identifiersep> bucket bucket = new array <identifiersep> bucket ( ) ; try { bucket <identifiersep> tools . copy ( new file <identifiersep> bucket ( blob <identifiersep> file , true , false , false , true ) , bucket ) ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } <comment> <ect>
<comment> public boolean start ( boolean aggressive , boolean reset ) { <LOG> if ( manager . is <identifiersep> blown ( ) ) { return false ; } boolean was <identifiersep> running = false ; log <identifiersep> minor = logger . should <identifiersep> log ( log <identifiersep> level . minor , this ) ; client <identifiersep> getter cg = null ; try { <ect>
core . client <identifiersep> context . start ( cg ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } return was <identifiersep> running ; } catch ( fetch <identifiersep> exception e ) { if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . recently <identifiersep> failed ) { logger . error ( this , <string_literal> ) ; <LOG> } else { manager . blow ( <string_literal> + e , true ) ; } synchronized ( this ) { if ( revocation <identifiersep> getter == cg ) { revocation <identifiersep> getter = null ; } } return false ; <ect>
blob <identifiersep> bucket = ( array <identifiersep> bucket ) tmp <identifiersep> blob ; } } else { try { array <identifiersep> bucket buf = new array <identifiersep> bucket ( bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( tmp <identifiersep> blob ) ) ; synchronized ( this ) { blob <identifiersep> bucket = buf ; } <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; <comment> <ect>
return ; } if ( tmp <identifiersep> blob instanceof file <identifiersep> bucket ) { file f = ( ( file <identifiersep> bucket ) tmp <identifiersep> blob ) . get <identifiersep> file ( ) ; synchronized ( this ) { if ( f == blob <identifiersep> file ) return ; if ( f . equals ( blob <identifiersep> file ) ) return ; <LOG> if ( file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( f ) . equals ( file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( blob <identifiersep> file ) ) ) return ; } } } file <identifiersep> bucket fb = new file <identifiersep> bucket ( blob <identifiersep> file , false , false , false , false ) ; try { bucket <identifiersep> tools . copy ( tmp <identifiersep> blob , fb ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; <ect>
if ( file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( f ) . equals ( file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( blob <identifiersep> file ) ) ) return ; } } system . out . println ( <string_literal> + tmp <identifiersep> blob ) ; } file <identifiersep> bucket fb = new file <identifiersep> bucket ( blob <identifiersep> file , false , false , false , false ) ; try { bucket <identifiersep> tools . copy ( tmp <identifiersep> blob , fb ) ; } catch ( io <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { on <identifiersep> failure ( e , state , state . get <identifiersep> blob <identifiersep> bucket ( ) ) ; } void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state , bucket blob ) { <ect>
logger . error ( this , <string_literal> + e , e ) ; return null ; } } } file f = get <identifiersep> blob <identifiersep> file ( ) ; if ( f == null ) return null ; try { return new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( f , true ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { return null ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return null ; } } <comment> <ect>
return ; <comment> <LOG> updater . start ( ) ; } public void stop <identifiersep> plugin <identifiersep> updater ( string plug <identifiersep> name ) { official <identifiersep> plugin <identifiersep> description plugin = node . get <identifiersep> plugin <identifiersep> manager ( ) . get <identifiersep> official <identifiersep> plugin ( plug <identifiersep> name ) ; if ( plugin == null ) return ; <comment> <ect>
deps = latest <identifiersep> main <identifiersep> jar <identifiersep> dependencies ; } synchronized ( deploy <identifiersep> lock ( ) ) { success = inner <identifiersep> deploy <identifiersep> update ( deps ) ; if ( success ) wait <identifiersep> forever ( ) ; } <comment> <LOG> logger . error ( this , <string_literal> + t , t ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; fail <identifiersep> update ( t . get <identifiersep> message ( ) ) ; string error = l10n ( <string_literal> , <string_literal> , t . get <identifiersep> message ( ) ) ; <ect>
success = inner <identifiersep> deploy <identifiersep> update ( deps ) ; if ( success ) wait <identifiersep> forever ( ) ; } <comment> <LOG> system . err . println ( <string_literal> ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; fail <identifiersep> update ( t . get <identifiersep> message ( ) ) ; string error = l10n ( <string_literal> , <string_literal> , t . get <identifiersep> message ( ) ) ; node . client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( false , error , error , error , user <identifiersep> alert . critical <identifiersep> error ) ) ; <ect>
thread . sleep ( <number_literal> * <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> private boolean inner <identifiersep> deploy <identifiersep> update ( main <identifiersep> jar <identifiersep> dependencies deps ) { <comment> <ect>
} catch ( io <identifiersep> exception e ) { throw new update <identifiersep> failed <identifiersep> exception ( <string_literal> + ( try <identifiersep> easy <identifiersep> way ? <string_literal> : <string_literal> ) + new <identifiersep> main <identifiersep> jar ) ; } if ( try <identifiersep> easy <identifiersep> way ) { <comment> <LOG> if ( file <identifiersep> util . copy <identifiersep> file ( main <identifiersep> jar , backup <identifiersep> main <identifiersep> jar ) ) if ( ! new <identifiersep> main <identifiersep> jar . rename <identifiersep> to ( main <identifiersep> jar ) ) { logger . error ( node <identifiersep> update <identifiersep> manager . class , <string_literal> + new <identifiersep> main <identifiersep> jar + <string_literal> + main <identifiersep> jar ) ; if ( written <identifiersep> to <identifiersep> temp <identifiersep> file ) { <ect>
new <identifiersep> main <identifiersep> jar . delete ( ) ; throw new update <identifiersep> failed <identifiersep> exception ( <string_literal> ) ; } <comment> <LOG> return false ; } } return true ; } public void write <identifiersep> jar <identifiersep> to ( file f <identifiersep> new ) throws io <identifiersep> exception { if ( ! f <identifiersep> new . delete ( ) && f <identifiersep> new . exists ( ) ) { system . err . println ( <string_literal> + f <identifiersep> new + <string_literal> ) ; } file <identifiersep> output <identifiersep> stream fos = null ; <ect>
} catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> private void fail <identifiersep> update ( string reason ) { system . err . println ( <string_literal> + reason ) ; this . kill <identifiersep> update <identifiersep> alerts ( ) ; node . client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( true , l10n ( <string_literal> ) , l10n ( <string_literal> , <string_literal> , reason ) , l10n ( <string_literal> , <string_literal> , reason ) , <ect>
delete1 = fetched <identifiersep> main <identifiersep> jar <identifiersep> data ; fetched <identifiersep> main <identifiersep> jar <identifiersep> version = fetched ; fetched <identifiersep> main <identifiersep> jar <identifiersep> data = result ; if ( fetched == version . build <identifiersep> number ( ) ) { if ( saved <identifiersep> blob != null ) current <identifiersep> version <identifiersep> blob <identifiersep> file = saved <identifiersep> blob ; <LOG> else } } else { delete2 = maybe <identifiersep> next <identifiersep> main <identifiersep> jar <identifiersep> data ; maybe <identifiersep> next <identifiersep> main <identifiersep> jar <identifiersep> version = fetched ; maybe <identifiersep> next <identifiersep> main <identifiersep> jar <identifiersep> data = result ; system . out <ect>
<comment> <LOG> alert <identifiersep> user ( ) ; <string_literal> + source . get <identifiersep> simple <identifiersep> version ( ) + <string_literal> ) ; system . err . println ( <string_literal> ) ; try <identifiersep> fetch <identifiersep> revocation ( source ) ; } else { <comment> <ect>
system . err . println ( <string_literal> ) ; try <identifiersep> fetch <identifiersep> revocation ( source ) ; } else { <comment> <LOG> <comment> <ect>
<comment> <LOG> } catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; <comment> <ect>
source . send <identifiersep> async ( msg , new async <identifiersep> message <identifiersep> callback ( ) { @ override public void acknowledged ( ) { <comment> <LOG> <comment> <ect>
@ override public void run ( ) { if ( update <identifiersep> manager . is <identifiersep> blown ( ) ) return ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { if ( nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> failed <identifiersep> transfer . contains ( source ) ) return ; if ( nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . contains ( source ) ) return ; <LOG> nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; } maybe <identifiersep> not <identifiersep> revoked ( ) ; } } , seconds . to <identifiersep> millis ( <number_literal> ) ) ; <comment> <ect>
if ( ( is <identifiersep> outdated ) || when <identifiersep> to <identifiersep> take <identifiersep> over <identifiersep> the <identifiersep> normal <identifiersep> updater < now ) { <comment> <LOG> logger . error ( this , <string_literal> + how <identifiersep> long + <string_literal> ) ; } else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <comment> <ect>
send <identifiersep> uom <identifiersep> request ( source , true ) ; else <comment> <LOG> <comment> <ect>
if ( update <identifiersep> manager . is <identifiersep> blown ( ) ) return ; if ( ! update <identifiersep> manager . is <identifiersep> enabled ( ) ) return ; if ( update <identifiersep> manager . has <identifiersep> new <identifiersep> main <identifiersep> jar ( ) ) return ; <LOG> if ( ! update <identifiersep> manager . node . is <identifiersep> oudated ( ) ) { system . out . println ( <string_literal> ) ; } maybe <identifiersep> request <identifiersep> main <identifiersep> jar ( ) ; } } , when <identifiersep> to <identifiersep> take <identifiersep> over <identifiersep> the <identifiersep> normal <identifiersep> updater - now ) ; } } else { <comment> <ect>
final hash <identifiersep> set < peer <identifiersep> node > asked <identifiersep> send <identifiersep> jar = nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar ; boolean was <identifiersep> fetching <identifiersep> uom = false ; synchronized ( this ) { long offered <identifiersep> version = source . get <identifiersep> main <identifiersep> jar <identifiersep> offered <identifiersep> version ( ) ; long update <identifiersep> version = update <identifiersep> manager . new <identifiersep> main <identifiersep> jar <identifiersep> version ( ) ; if ( offered <identifiersep> version < update <identifiersep> version ) { <LOG> if ( offered <identifiersep> version < = 0 ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + lname + <string_literal> + source + <string_literal> + offered <identifiersep> version ) ; return ; } int cur <identifiersep> version = update <identifiersep> manager . get <identifiersep> main <identifiersep> version ( ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } @ override public string to <identifiersep> string ( ) { return super . to <identifiersep> string ( ) + <string_literal> + uid + <string_literal> + source . get <identifiersep> peer ( ) + <string_literal> ; } } , update <identifiersep> manager . ctr ) ; <LOG> } catch ( not <identifiersep> connected <identifiersep> exception e ) { return true ; } return true ; } public boolean handle <identifiersep> sending <identifiersep> revocation ( message m , final peer <identifiersep> node source ) { final long uid = m . get <identifiersep> long ( dmt . uid ) ; final long length = m . get <identifiersep> long ( dmt . file <identifiersep> length ) ; <ect>
final long length = m . get <identifiersep> long ( dmt . file <identifiersep> length ) ; string key = m . get <identifiersep> string ( dmt . revocation <identifiersep> key ) ; freenet <identifiersep> uri revocation <identifiersep> uri ; try { revocation <identifiersep> uri = new freenet <identifiersep> uri ( key ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> + e + <string_literal> + key , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; synchronized ( this ) { <comment> <ect>
if ( update <identifiersep> manager . is <identifiersep> blown ( ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + source + <string_literal> + uid + <string_literal> ) ; cancel <identifiersep> send ( source , uid ) ; return true ; } if ( length > node <identifiersep> update <identifiersep> manager . max <identifiersep> revocation <identifiersep> key <identifiersep> blob <identifiersep> length ) { <LOG> system . err . println ( <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + size <identifiersep> util . format <identifiersep> size ( length ) + <string_literal> ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . remove ( source ) ; } cancel <identifiersep> send ( source , uid ) ; maybe <identifiersep> not <identifiersep> revoked ( ) ; <ect>
synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . remove ( source ) ; <comment> <LOG> return true ; } <comment> <ect>
update <identifiersep> manager . blow ( <string_literal> + e , true ) ; cancel <identifiersep> send ( source , uid ) ; return true ; } file <identifiersep> random <identifiersep> access <identifiersep> buffer raf ; try { raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( temp , length , false ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + e , true ) ; return true ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + e , e ) ; update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + e , true ) ; <ect>
@ override public void run ( ) { try { if ( br . receive ( ) ) <comment> <LOG> else { system . err . println ( <string_literal> + source ) ; source . failed <identifiersep> revocation <identifiersep> transfer ( ) ; int count = source . count <identifiersep> failed <identifiersep> revocation <identifiersep> transfers ( ) ; boolean retry = count < <number_literal> ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { <ect>
if ( nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . contains ( source ) ) retry = false ; else nodes <identifiersep> say <identifiersep> key <identifiersep> revoked . add ( source ) ; } } maybe <identifiersep> not <identifiersep> revoked ( ) ; if ( retry ) try <identifiersep> fetch <identifiersep> revocation ( source ) ; } <LOG> } catch ( throwable t ) { system . err . println ( <string_literal> + source + <string_literal> ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; update <identifiersep> manager . blow ( <string_literal> + source + <string_literal> + t , true ) ; synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { nodes <identifiersep> say <identifiersep> key <identifiersep> revoked <identifiersep> transferring . remove ( source ) ; <ect>
void process <identifiersep> revocation <identifiersep> blob ( final bucket temp , final string source , final boolean from <identifiersep> disk ) { simple <identifiersep> block <identifiersep> set blocks = new simple <identifiersep> block <identifiersep> set ( ) ; data <identifiersep> input <identifiersep> stream dis = null ; try { dis = new data <identifiersep> input <identifiersep> stream ( temp . get <identifiersep> input <identifiersep> stream ( ) ) ; binary <identifiersep> blob . read <identifiersep> binary <identifiersep> blob ( dis , blocks , true ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { system . err . println ( <string_literal> + temp + <string_literal> + source + <string_literal> ) ; if ( ! from <identifiersep> disk ) update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + source + <string_literal> , true ) ; return ; } catch ( eof <identifiersep> exception e ) { <ect>
} catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + temp + <string_literal> + source + <string_literal> ) ; system . err . println ( <string_literal> + temp + <string_literal> + source + <string_literal> ) ; if ( ! from <identifiersep> disk ) update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + source + <string_literal> , true ) ; return ; <LOG> } catch ( eof <identifiersep> exception e ) { system . err . println ( <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> ) ; <comment> <ect>
logger . error ( this , <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> , e ) ; system . err . println ( <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> ) ; <comment> <LOG> } catch ( binary <identifiersep> blob <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> ) ; <comment> <ect>
logger . error ( this , <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> , e ) ; system . err . println ( <string_literal> + source + <string_literal> + e + <string_literal> + temp + <string_literal> ) ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + temp + <string_literal> + source + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; if ( ! from <identifiersep> disk ) update <identifiersep> manager . blow ( <string_literal> + temp + <string_literal> + source + <string_literal> + e , true ) ; <comment> <ect>
temp <identifiersep> context . local <identifiersep> request <identifiersep> only = true ; final array <identifiersep> bucket cleaned <identifiersep> blob = new array <identifiersep> bucket ( ) ; client <identifiersep> get <identifiersep> callback my <identifiersep> callback = new client <identifiersep> get <identifiersep> callback ( ) { @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . cancelled ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
return update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ; } } ; client <identifiersep> getter cg = new client <identifiersep> getter ( my <identifiersep> callback , update <identifiersep> manager . get <identifiersep> revocation <identifiersep> uri ( ) , temp <identifiersep> context , ( short ) 0 , null , new binary <identifiersep> blob <identifiersep> writer ( cleaned <identifiersep> blob ) , null ) ; try { update <identifiersep> manager . node . client <identifiersep> core . client <identifiersep> context . start ( cg ) ; <LOG> } catch ( fetch <identifiersep> exception e1 ) { e1 . print <identifiersep> stack <identifiersep> trace ( ) ; my <identifiersep> callback . on <identifiersep> failure ( e1 , cg ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
@ override public void on <identifiersep> success ( base <identifiersep> client <identifiersep> putter state ) { <comment> <LOG> base <identifiersep> client <identifiersep> putter state ) { metadata . free ( ) ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <comment> <ect>
uri = update <identifiersep> manager . get <identifiersep> uri ( ) ; } if ( data == null ) { logger . normal ( this , <string_literal> + source + <string_literal> + name + <string_literal> ) ; <comment> <LOG> if ( ! source . sending <identifiersep> uom <identifiersep> jar ( false ) ) { return ; } try { try { raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( data , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <ect>
try { try { raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( data , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + source + <string_literal> + name + <string_literal> + e , e ) ; return ; <LOG> } catch ( io <identifiersep> exception e ) { return ; } final partially <identifiersep> received <identifiersep> bulk prb ; long length ; length = raf . size ( ) ; prb = new partially <identifiersep> received <identifiersep> bulk ( update <identifiersep> manager . node . get <identifiersep> usm ( ) , length , <ect>
system . err . println ( <string_literal> + version + <string_literal> + e + <string_literal> + key ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { this . nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar . remove ( source ) ; } return true ; } <LOG> if ( ! jar <identifiersep> uri . equals ( update <identifiersep> manager . get <identifiersep> uri ( ) . set <identifiersep> suggested <identifiersep> edition ( version ) ) ) { <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + <string_literal> + update <identifiersep> manager . get <identifiersep> uri ( ) + <string_literal> + <string_literal> + jar <identifiersep> uri ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { <ect>
logger . minor ( this , <string_literal> + source + <string_literal> + uid + <string_literal> ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { this . nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar . remove ( source ) ; } return true ; } if ( length > node <identifiersep> update <identifiersep> manager . max <identifiersep> main <identifiersep> jar <identifiersep> length ) { <LOG> system . err . println ( <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + version + <string_literal> + size <identifiersep> util . format <identifiersep> size ( length ) + <string_literal> ) ; <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { this . nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar . remove ( source ) ; } return true ; <ect>
nodes <identifiersep> sending <identifiersep> main <identifiersep> jar . add ( source ) ; } success = br . receive ( ) ; if ( success ) <comment> <LOG> logger . error ( this , <string_literal> + version + <string_literal> + source ) ; temp . delete ( ) ; } } finally { synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . class ) { nodes <identifiersep> sending <identifiersep> main <identifiersep> jar . remove ( source ) ; if ( success ) <ect>
final string to <identifiersep> string = source == null ? <string_literal> : source . user <identifiersep> to <identifiersep> string ( ) ; data <identifiersep> input <identifiersep> stream dis = null ; try { dis = new data <identifiersep> input <identifiersep> stream ( new buffered <identifiersep> input <identifiersep> stream ( new file <identifiersep> input <identifiersep> stream ( temp ) ) ) ; binary <identifiersep> blob . read <identifiersep> binary <identifiersep> blob ( dis , blocks , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> + temp + <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> ) ; return ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; system . err . println ( <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; <comment> <ect>
binary <identifiersep> blob . read <identifiersep> binary <identifiersep> blob ( dis , blocks , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> + temp + <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> ) ; system . err . println ( <string_literal> + temp + <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> ) ; return ; } catch ( io <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; <comment> <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; system . err . println ( <string_literal> + version + <string_literal> + temp + <string_literal> + to <identifiersep> string + <string_literal> ) ; <comment> <LOG> logger . error ( this , <string_literal> + to <identifiersep> string + <string_literal> + version + <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
file <identifiersep> bucket b = null ; try { f = file . create <identifiersep> temp <identifiersep> file ( <string_literal> , <string_literal> , update <identifiersep> manager . node . client <identifiersep> core . get <identifiersep> persistent <identifiersep> temp <identifiersep> dir ( ) ) ; f . delete <identifiersep> on <identifiersep> exit ( ) ; b = new file <identifiersep> bucket ( f , false , false , true , true ) ; } catch ( io <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> + to <identifiersep> string + <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; b = null ; f = null ; } final file <identifiersep> bucket cleaned <identifiersep> blob = b ; final file cleaned <identifiersep> blob <identifiersep> file = f ; <ect>
final file cleaned <identifiersep> blob <identifiersep> file = f ; client <identifiersep> get <identifiersep> callback my <identifiersep> callback = new client <identifiersep> get <identifiersep> callback ( ) { @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { if ( e . mode == fetch <identifiersep> exception <identifiersep> mode . cancelled ) { <comment> <LOG> logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; <comment> <ect>
<comment> <LOG> logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } else if ( e . is <identifiersep> fatal ( ) ) { <comment> <ect>
temp . delete ( ) ; logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; system . out . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } else if ( e . is <identifiersep> fatal ( ) ) { <comment> <LOG> logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string + <string_literal> + e , e ) ; } else { logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { <ect>
} else if ( e . is <identifiersep> fatal ( ) ) { <comment> <LOG> logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; if ( result . size ( ) == 0 ) { system . err . println ( <string_literal> ) ; <ect>
} else { logger . error ( this , <string_literal> + version + <string_literal> + to <identifiersep> string ) ; system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; } } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { system . err . println ( <string_literal> + version + <string_literal> + to <identifiersep> string ) ; <LOG> if ( result . size ( ) == 0 ) { return ; } node <identifiersep> updater main <identifiersep> updater = update <identifiersep> manager . get <identifiersep> main <identifiersep> updater ( ) ; if ( main <identifiersep> updater == null ) { system . err . println ( <string_literal> ) ; return ; <ect>
return ; } insert <identifiersep> blob ( main <identifiersep> updater . get <identifiersep> blob <identifiersep> bucket ( version ) , <string_literal> , priority ) ; } protected boolean remove <identifiersep> old <identifiersep> temp <identifiersep> files ( ) { file old <identifiersep> temp <identifiersep> files <identifiersep> peer <identifiersep> dir = update <identifiersep> manager . node . client <identifiersep> core . get <identifiersep> persistent <identifiersep> temp <identifiersep> dir ( ) ; if ( ! old <identifiersep> temp <identifiersep> files <identifiersep> peer <identifiersep> dir . exists ( ) ) return false ; <LOG> if ( ! old <identifiersep> temp <identifiersep> files <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { return false ; } boolean got <identifiersep> error = false ; file [ ] old <identifiersep> temp <identifiersep> files = old <identifiersep> temp <identifiersep> files <identifiersep> peer <identifiersep> dir . list <identifiersep> files ( new file <identifiersep> filter ( ) { private final int last <identifiersep> good <identifiersep> main <identifiersep> build <identifiersep> number = version . last <identifiersep> good <identifiersep> build ( ) ; @ override <ect>
return true ; } return false ; } } ) ; for ( file file <identifiersep> to <identifiersep> delete : old <identifiersep> temp <identifiersep> files ) { string file <identifiersep> to <identifiersep> delete <identifiersep> name = file <identifiersep> to <identifiersep> delete . get <identifiersep> name ( ) ; if ( ! file <identifiersep> to <identifiersep> delete . delete ( ) ) { <LOG> if ( file <identifiersep> to <identifiersep> delete . exists ( ) ) else logger . normal ( this , <string_literal> + file <identifiersep> to <identifiersep> delete <identifiersep> name ) ; got <identifiersep> error = true ; } } return ! got <identifiersep> error ; } @ override <ect>
if ( data != null ) raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( data , true ) ; else { logger . error ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( buf . get <identifiersep> data ( ) ) + <string_literal> ) ; fail = true ; raf = null ; } <LOG> } catch ( io <identifiersep> exception e ) { ( e instanceof file <identifiersep> not <identifiersep> found <identifiersep> exception ? <string_literal> : <string_literal> ) + <string_literal> + e , e ) ; raf = null ; fail = true ; } partially <identifiersep> received <identifiersep> bulk prb ; <ect>
decrement <identifiersep> dependencies ( source ) ; r . close ( ) ; } } } ) ; } } private void decrement <identifiersep> dependencies ( peer <identifiersep> node source ) { synchronized ( peers <identifiersep> fetching <identifiersep> dependencies ) { integer x = peers <identifiersep> fetching <identifiersep> dependencies . get ( source ) ; <LOG> if ( x == null ) { } else if ( x == 1 ) { peers <identifiersep> fetching <identifiersep> dependencies . remove ( source ) ; } else if ( x < = 0 ) { logger . error ( this , <string_literal> + x + <string_literal> + source ) ; peers <identifiersep> fetching <identifiersep> dependencies . remove ( source ) ; <ect>
failed = true ; } } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
system . out . println ( <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> } catch ( runtime <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( error e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; <ect>
system . out . println ( <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e ) ; logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; } catch ( runtime <identifiersep> exception e ) { logger . error ( this , <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( error e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { boolean connected = fetch <identifiersep> from . is <identifiersep> connected ( ) ; boolean add <identifiersep> failed = failed && connected ; <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { cg = null ; fetched = false ; temp <identifiersep> file = null ; return ; } temp <identifiersep> file = tmp ; <ect>
public long get <identifiersep> blob <identifiersep> size ( ) { if ( failed || ! fetched ) { logger . error ( this , <string_literal> + failed + <string_literal> + fetched ) ; return - 1 ; } return blob <identifiersep> bucket . size ( ) ; } public file get <identifiersep> blob <identifiersep> file ( ) { <LOG> if ( failed || ! fetched ) { return null ; } return save <identifiersep> to ; } <comment> public synchronized boolean fetched ( ) { <ect>
else main <identifiersep> rhs = rhs ; } else { <comment> <LOG> if ( dep . old <identifiersep> filename ( ) != null ) else system . out . println ( <string_literal> + dep . new <identifiersep> filename ( ) ) ; } else { <comment> <ect>
dependency dep = find <identifiersep> dependency <identifiersep> by <identifiersep> rhs <identifiersep> filename ( new file ( rhs ) ) ; if ( dep != null ) { if ( dep . old <identifiersep> filename ( ) != null ) system . out . println ( <string_literal> + dep . old <identifiersep> filename ( ) ) ; else system . out . println ( <string_literal> + dep . new <identifiersep> filename ( ) ) ; <LOG> } else { <comment> <ect>
bw . close ( ) ; if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { if ( ! old <identifiersep> config . delete ( ) ) { throw new updater <identifiersep> parser <identifiersep> exception ( l10n ( <string_literal> , <string_literal> , old <identifiersep> config . to <identifiersep> string ( ) ) ) ; } if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { throw new update <identifiersep> catastrophe <identifiersep> exception ( old <identifiersep> config , new <identifiersep> config ) ; } } <LOG> <comment> <ect>
continue ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <comment> <LOG> new <identifiersep> config . delete ( ) ; return changed . fail ; } finally { closer . close ( br ) ; closer . close ( isr ) ; closer . close ( bis ) ; <ect>
closer . close ( fos ) ; } if ( success ) { if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { if ( ! old <identifiersep> config . delete ( ) ) { system . err . println ( <string_literal> + new <identifiersep> config + <string_literal> + old <identifiersep> config + <string_literal> ) ; return changed . fail ; } <LOG> if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { system . err . println ( <string_literal> + new <identifiersep> config + <string_literal> + old <identifiersep> config ) ; system . exit ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> broke <identifiersep> wrapper <identifiersep> conf ) ; } } system . err . println ( <string_literal> ) ; return changed . success ; } else { <ect>
if ( ! old <identifiersep> config . delete ( ) ) { system . err . println ( <string_literal> + new <identifiersep> config + <string_literal> + old <identifiersep> config + <string_literal> ) ; return changed . fail ; } if ( ! new <identifiersep> config . rename <identifiersep> to ( old <identifiersep> config ) ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + new <identifiersep> config + <string_literal> + old <identifiersep> config ) ; <LOG> system . exit ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> broke <identifiersep> wrapper <identifiersep> conf ) ; } } return changed . success ; } else { new <identifiersep> config . delete ( ) ; return changed . fail ; } } public file get <identifiersep> backup <identifiersep> jar ( ) { <ect>
protected void maybe <identifiersep> process <identifiersep> old <identifiersep> blob ( ) { file old <identifiersep> blob = get <identifiersep> blob <identifiersep> file ( current <identifiersep> version ) ; if ( old <identifiersep> blob . exists ( ) ) { file temp ; try { temp = file . create <identifiersep> temp <identifiersep> file ( blob <identifiersep> filename <identifiersep> prefix + available <identifiersep> version + <string_literal> , <string_literal> , manager . node . client <identifiersep> core . get <identifiersep> persistent <identifiersep> temp <identifiersep> dir ( ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { return ; } if ( old <identifiersep> blob . rename <identifiersep> to ( temp ) ) { freenet <identifiersep> uri uri = uri . set <identifiersep> suggested <identifiersep> edition ( current <identifiersep> version ) ; uri = uri . ssk <identifiersep> for <identifiersep> usk ( ) ; try { <ect>
try { manager . uom . process <identifiersep> main <identifiersep> jar <identifiersep> blob ( temp , null , current <identifiersep> version , uri ) ; } catch ( throwable t ) { <comment> <LOG> } else { } } } public request <identifiersep> client get <identifiersep> request <identifiersep> client ( ) { return this ; } @ override public void on <identifiersep> found <identifiersep> edition ( long l , usk key , client <identifiersep> context context , boolean was <identifiersep> metadata , short codec , byte [ ] data , boolean new <identifiersep> known <identifiersep> good , boolean new <identifiersep> slot <identifiersep> too ) { if ( new <identifiersep> known <identifiersep> good && ! new <identifiersep> slot <identifiersep> too ) return ; <ect>
found = ( int ) key . suggested <identifiersep> edition ; real <identifiersep> available <identifiersep> version = found ; if ( found > max <identifiersep> deploy <identifiersep> version ) { system . err . println ( <string_literal> + jar <identifiersep> name ( ) + <string_literal> + l + <string_literal> + min <identifiersep> deploy <identifiersep> version + <string_literal> + max <identifiersep> deploy <identifiersep> version + <string_literal> ) ; found = max <identifiersep> deploy <identifiersep> version ; } if ( found < = available <identifiersep> version ) <LOG> return ; logger . minor ( this , <string_literal> + available <identifiersep> version + <string_literal> + found + <string_literal> ) ; this . available <identifiersep> version = found ; } finish <identifiersep> on <identifiersep> found <identifiersep> edition ( found ) ; } private void finish <identifiersep> on <identifiersep> found <identifiersep> edition ( int found ) { ticker . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { <ect>
if ( fetching <identifiersep> version < min <identifiersep> deploy <identifiersep> version || fetching <identifiersep> version == current <identifiersep> version ) { logger . normal ( this , <string_literal> ) ; cancelled = cg ; cg = null ; } fetching <identifiersep> version = available <identifiersep> version ; if ( available <identifiersep> version > current <identifiersep> version ) { <LOG> logger . normal ( this , <string_literal> + available <identifiersep> version + ' ) ' ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + available <identifiersep> version + ' ) ' ) ; <comment> <ect>
freenet <identifiersep> uri uri = uri . set <identifiersep> suggested <identifiersep> edition ( available <identifiersep> version ) ; uri = uri . ssk <identifiersep> for <identifiersep> usk ( ) ; cg = new client <identifiersep> getter ( this , uri , ctx , request <identifiersep> starter . immediate <identifiersep> splitfile <identifiersep> priority <identifiersep> class , null , new binary <identifiersep> blob <identifiersep> writer ( new file <identifiersep> bucket ( temp <identifiersep> blob <identifiersep> file , false , false , false , false ) ) , null ) ; to <identifiersep> start = cg ; <LOG> } else { } is <identifiersep> fetching = true ; } catch ( exception e ) { logger . error ( this , <string_literal> + e , e ) ; is <identifiersep> fetching = false ; } } if ( to <identifiersep> start != null ) <ect>
} catch ( exception e ) { logger . error ( this , <string_literal> + e , e ) ; is <identifiersep> fetching = false ; } } if ( to <identifiersep> start != null ) try { node . client <identifiersep> core . client <identifiersep> context . start ( to <identifiersep> start ) ; <LOG> } catch ( fetch <identifiersep> exception e ) { synchronized ( this ) { is <identifiersep> fetching = false ; } } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
if ( ze . is <identifiersep> directory ( ) ) continue ; string name = ze . get <identifiersep> name ( ) ; if ( name . equals ( filename ) ) { if ( log <identifiersep> minor ) logger . minor ( node <identifiersep> updater . class , <string_literal> ) ; long size = ze . get <identifiersep> size ( ) ; if ( log <identifiersep> minor ) logger . minor ( node <identifiersep> updater . class , <string_literal> + size ) ; <LOG> if ( size > max <identifiersep> manifest <identifiersep> size ) { break ; } byte [ ] buf = new byte [ ( int ) size ] ; data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( zis ) ; dis . read <identifiersep> fully ( buf ) ; byte <identifiersep> array <identifiersep> input <identifiersep> stream bais = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( buf ) ; <ect>
input <identifiersep> stream is = null ; try { is = result . as <identifiersep> bucket ( ) . get <identifiersep> input <identifiersep> stream ( ) ; parse <identifiersep> dependencies ( parse <identifiersep> properties ( is , dependencies <identifiersep> file ) , build ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; <LOG> } catch ( throwable t ) { } finally { closer . close ( is ) ; } } <comment> protected void parse <identifiersep> dependencies ( properties props , int build ) { <comment> <ect>
ticker . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { maybe <identifiersep> update ( ) ; } } , 0 ) ; } else { <LOG> logger . error ( this , <string_literal> + e . get <identifiersep> message ( ) ) ; if ( e . is <identifiersep> fatal ( ) ) { <comment> <ect>
<comment> <LOG> call <identifiersep> finished <identifiersep> found = available <identifiersep> version = required <identifiersep> ext ; } } } if ( call <identifiersep> finished <identifiersep> found > - 1 ) finish <identifiersep> on <identifiersep> found <identifiersep> edition ( call <identifiersep> finished <identifiersep> found ) ; } @ override public boolean real <identifiersep> time <identifiersep> flag ( ) { return false ; <ect>
synchronized ( this ) { if ( fetched ) { temp <identifiersep> file . delete ( ) ; return ; } fetched = true ; } if ( ! main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . valid <identifiersep> file ( temp <identifiersep> file , expected <identifiersep> hash , expected <identifiersep> length , executable ) ) { <LOG> logger . error ( this , <string_literal> + filename + <string_literal> ) ; if ( cb != null ) cb . on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + temp <identifiersep> file + <string_literal> + temp <identifiersep> file . length ( ) + <string_literal> ) ) ; temp <identifiersep> file . delete ( ) ; return ; } if ( ! file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> file , filename ) ) { <ect>
system . err . println ( <string_literal> + filename + <string_literal> ) ; if ( cb != null ) cb . on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + temp <identifiersep> file + <string_literal> + temp <identifiersep> file . length ( ) + <string_literal> ) ) ; temp <identifiersep> file . delete ( ) ; return ; } if ( ! file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> file , filename ) ) { <LOG> logger . error ( this , <string_literal> + temp <identifiersep> file + <string_literal> + filename ) ; if ( cb != null ) cb . on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + temp <identifiersep> file + <string_literal> + filename ) ) ; temp <identifiersep> file . delete ( ) ; return ; } if ( cb != null ) cb . on <identifiersep> success ( ) ; <ect>
@ override public request <identifiersep> client get <identifiersep> request <identifiersep> client ( ) { return this ; } } @ override public jar <identifiersep> fetcher fetch ( freenet <identifiersep> uri uri , file download <identifiersep> to , long expected <identifiersep> length , byte [ ] expected <identifiersep> hash , jar <identifiersep> fetcher <identifiersep> callback cb , int build , boolean essential , boolean executable ) throws fetch <identifiersep> exception { <LOG> if ( essential ) else if ( build != 0 ) <comment> <ect>
private string l10n ( string key ) { return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + key ) ; } public boolean broken <identifiersep> dependencies ( ) { return dependencies . is <identifiersep> broken ( ) ; } public void cleanup <identifiersep> dependencies ( ) { input <identifiersep> stream is = get <identifiersep> class ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> + dependencies <identifiersep> file ) ; <LOG> if ( is == null ) { return ; } properties props = new properties ( ) ; try { props . load ( is ) ; } catch ( io <identifiersep> exception e ) { <ect>
this . manager . broadcast <identifiersep> uom <identifiersep> announces <identifiersep> old ( ) ; } @ override public void multi <identifiersep> file <identifiersep> replace <identifiersep> ready <identifiersep> to <identifiersep> deploy ( final main <identifiersep> jar <identifiersep> dependencies <identifiersep> checker . atomic <identifiersep> deployer atomic <identifiersep> deployer ) { if ( this . manager . is <identifiersep> auto <identifiersep> update <identifiersep> allowed ( ) ) { atomic <identifiersep> deployer . deploy <identifiersep> multi <identifiersep> file <identifiersep> update <identifiersep> off <identifiersep> thread ( ) ; } else { <LOG> final long now = system . current <identifiersep> time <identifiersep> millis ( ) ; node . client <identifiersep> core . alerts . register ( new user <identifiersep> alert ( ) { private string l10n ( string key ) { return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + key ) ; } @ override public boolean user <identifiersep> can <identifiersep> dismiss ( ) { <ect>
else if ( level < = user <identifiersep> alert . error ) return <string_literal> ; else if ( level < = user <identifiersep> alert . warning ) return <string_literal> ; else if ( level < = user <identifiersep> alert . minor ) return <string_literal> ; <LOG> else { return <string_literal> ; } } public html <identifiersep> node create <identifiersep> summary ( ) { <comment> <ect>
static final int version = 1 ; <comment> static final long max <identifiersep> iterations = 1l < < <number_literal> ; <comment> static int iterate <identifiersep> time = <number_literal> ; <LOG> public static master <identifiersep> keys read ( file master <identifiersep> keys <identifiersep> file , random hard <identifiersep> random , string password ) throws master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception , master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception , io <identifiersep> exception { if ( master <identifiersep> keys <identifiersep> file != null && master <identifiersep> keys <identifiersep> file . exists ( ) ) { <comment> <ect>
if ( iterations < 0 || iterations > max <identifiersep> iterations ) throw new io <identifiersep> exception ( <string_literal> + iterations + <string_literal> ) ; byte [ ] salt = new byte [ <number_literal> ] ; dis . read <identifiersep> fully ( salt ) ; byte [ ] iv = new byte [ <number_literal> ] ; dis . read <identifiersep> fully ( iv ) ; byte [ ] data <identifiersep> and <identifiersep> hash = new byte [ length - salt . length - iv . length - <number_literal> - <number_literal> ] ; <LOG> dis . read <identifiersep> fully ( data <identifiersep> and <identifiersep> hash ) ; byte [ ] pwd = password . get <identifiersep> bytes ( <string_literal> ) ; message <identifiersep> digest md = sha256 . get <identifiersep> message <identifiersep> digest ( ) ; md . update ( pwd ) ; md . update ( salt ) ; byte [ ] outer <identifiersep> key = md . digest ( ) ; <ect>
outer <identifiersep> key = md . digest ( ) ; } } block <identifiersep> cipher cipher ; try { cipher = new rijndael ( <number_literal> , <number_literal> ) ; } catch ( unsupported <identifiersep> cipher <identifiersep> exception e ) { <comment> <LOG> throw new error ( e ) ; } cipher . initialize ( outer <identifiersep> key ) ; pcfb <identifiersep> mode pcfb = pcfb <identifiersep> mode . create ( cipher , iv ) ; pcfb . block <identifiersep> decipher ( data <identifiersep> and <identifiersep> hash , 0 , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <ect>
<comment> <LOG> byte [ ] hash = arrays . copy <identifiersep> of <identifiersep> range ( data <identifiersep> and <identifiersep> hash , data . length , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <ect>
<comment> <LOG> byte [ ] check <identifiersep> hash = md . digest ( data ) ; if ( ! fields . byte <identifiersep> array <identifiersep> equal ( check <identifiersep> hash , hash , 0 , 0 , hash <identifiersep> length ) ) { clear ( data ) ; clear ( hash ) ; throw new master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception ( ) ; } <comment> <ect>
system . err . println ( <string_literal> ) ; hard <identifiersep> random . next <identifiersep> bytes ( tempfiles <identifiersep> master <identifiersep> secret ) ; must <identifiersep> write = true ; } master <identifiersep> keys ret = new master <identifiersep> keys ( client <identifiersep> cache <identifiersep> key , database <identifiersep> key , tempfiles <identifiersep> master <identifiersep> secret , flags ) ; clear ( data ) ; clear ( hash ) ; <LOG> sha256 . return <identifiersep> message <identifiersep> digest ( md ) ; if ( must <identifiersep> write ) { ret . change <identifiersep> password ( master <identifiersep> keys <identifiersep> file , password , hard <identifiersep> random ) ; } return ret ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> closer . close ( fis ) ; } } master <identifiersep> keys ret = create <identifiersep> random ( hard <identifiersep> random ) ; ret . write ( master <identifiersep> keys <identifiersep> file , password , hard <identifiersep> random ) ; return ret ; } private static master <identifiersep> keys read <identifiersep> old <identifiersep> format ( data <identifiersep> input <identifiersep> stream dis , int length , random hard <identifiersep> random , string password ) throws io <identifiersep> exception , master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception { <ect>
clear ( hash ) ; sha256 . return <identifiersep> message <identifiersep> digest ( md ) ; return ret ; } public static void clear ( byte [ ] buf ) { if ( buf == null ) return ; <comment> <LOG> public void change <identifiersep> password ( file master <identifiersep> keys <identifiersep> file , string new <identifiersep> password , random hard <identifiersep> random ) throws io <identifiersep> exception { write ( master <identifiersep> keys <identifiersep> file , new <identifiersep> password , hard <identifiersep> random ) ; } private void write ( file master <identifiersep> keys <identifiersep> file , string new <identifiersep> password , random hard <identifiersep> random ) throws io <identifiersep> exception { <comment> <ect>
node . peers . increment <identifiersep> selection <identifiersep> samples ( system . current <identifiersep> time <identifiersep> millis ( ) , next ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . minor ( this , <string_literal> ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; <comment> <ect>
next . send <identifiersep> sync ( req , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . minor ( this , <string_literal> ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; <comment> <ect>
protected short hops <identifiersep> for <identifiersep> fatal <identifiersep> timeout <identifiersep> waiting <identifiersep> for <identifiersep> peer ( ) { return hops <identifiersep> for <identifiersep> time ( get <identifiersep> long <identifiersep> slot <identifiersep> waiter <identifiersep> timeout ( ) ) ; } private void log <identifiersep> delta ( long delta , int try <identifiersep> count , boolean waited <identifiersep> for <identifiersep> load <identifiersep> management , boolean retried <identifiersep> for <identifiersep> load <identifiersep> management ) { long long <identifiersep> timeout = get <identifiersep> long <identifiersep> slot <identifiersep> waiter <identifiersep> timeout ( ) ; if ( ( delta > long <identifiersep> timeout ) || try <identifiersep> count > <number_literal> ) logger . error ( this , <string_literal> + try <identifiersep> count + <string_literal> + time <identifiersep> util . format <identifiersep> time ( delta , <number_literal> , true ) + <string_literal> + waited <identifiersep> for <identifiersep> load <identifiersep> management + <string_literal> + retried <identifiersep> for <identifiersep> load <identifiersep> management + ( real <identifiersep> time <identifiersep> flag ? <string_literal> : <string_literal> ) + ( ( source == null ) ? <string_literal> : <string_literal> ) ) ; <LOG> else if ( ( delta > long <identifiersep> timeout / <number_literal> ) || try <identifiersep> count > 1 ) else if ( log <identifiersep> minor && ( waited <identifiersep> for <identifiersep> load <identifiersep> management || retried <identifiersep> for <identifiersep> load <identifiersep> management ) ) logger . minor ( this , <string_literal> + try <identifiersep> count + <string_literal> + time <identifiersep> util . format <identifiersep> time ( delta , <number_literal> , true ) + <string_literal> + waited <identifiersep> for <identifiersep> load <identifiersep> management + <string_literal> + retried <identifiersep> for <identifiersep> load <identifiersep> management + ( real <identifiersep> time <identifiersep> flag ? <string_literal> : <string_literal> ) + ( ( source == null ) ? <string_literal> : <string_literal> ) ) ; node . node <identifiersep> stats . report <identifiersep> nlm <identifiersep> delay ( delta , real <identifiersep> time <identifiersep> flag , source == null ) ; } private int rejected <identifiersep> loops ; <comment> <ect>
next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return do . next <identifiersep> peer ; } else { forward <identifiersep> rejected <identifiersep> overload ( ) ; } <comment> <LOG> if ( ! is <identifiersep> accepted ( msg ) ) { return do . next <identifiersep> peer ; } next . reset <identifiersep> mandatory <identifiersep> backoff ( real <identifiersep> time <identifiersep> flag ) ; next . output <identifiersep> load <identifiersep> tracker ( real <identifiersep> time <identifiersep> flag ) . clear <identifiersep> dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ( ) ; return do . finished ; } } protected abstract void handle <identifiersep> accepted <identifiersep> rejected <identifiersep> timeout ( final peer <identifiersep> node next , <ect>
synchronized ( enable <identifiersep> logger <identifiersep> lock ) { if ( file <identifiersep> logger <identifiersep> hook != null ) return ; logger . setup <identifiersep> chain ( ) ; try { config . force <identifiersep> update ( <string_literal> ) ; config . force <identifiersep> update ( <string_literal> ) ; <LOG> } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e2 ) { <comment> <ect>
new file <identifiersep> logger <identifiersep> hook ( true , new file ( log <identifiersep> dir , log <identifiersep> prefix ) . get <identifiersep> absolute <identifiersep> path ( ) , <string_literal> , <string_literal> , log <identifiersep> rotate <identifiersep> interval , log <identifiersep> level . debug <comment> , false , true , max <identifiersep> zipped <identifiersep> logs <identifiersep> size <comment> , max <identifiersep> cached <identifiersep> log <identifiersep> lines ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; return ; <LOG> } catch ( interval <identifiersep> parse <identifiersep> exception e ) { log <identifiersep> rotate <identifiersep> interval = <string_literal> ; try { hook = new file <identifiersep> logger <identifiersep> hook ( true , new file ( log <identifiersep> dir , log <identifiersep> prefix ) . get <identifiersep> absolute <identifiersep> path ( ) , <string_literal> , <string_literal> , log <identifiersep> rotate <identifiersep> interval , log <identifiersep> level . debug <comment> , false , true , <ect>
new file <identifiersep> logger <identifiersep> hook ( true , new file ( log <identifiersep> dir , log <identifiersep> prefix ) . get <identifiersep> absolute <identifiersep> path ( ) , <string_literal> , <string_literal> , log <identifiersep> rotate <identifiersep> interval , log <identifiersep> level . debug <comment> , false , true , max <identifiersep> zipped <identifiersep> logs <identifiersep> size <comment> , max <identifiersep> cached <identifiersep> log <identifiersep> lines ) ; } catch ( interval <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 . get <identifiersep> message ( ) ) ; return ; <LOG> } catch ( io <identifiersep> exception e1 ) { return ; } } hook . set <identifiersep> max <identifiersep> list <identifiersep> bytes ( max <identifiersep> cached <identifiersep> log <identifiersep> bytes ) ; hook . set <identifiersep> max <identifiersep> backlog <identifiersep> not <identifiersep> busy ( max <identifiersep> backlog <identifiersep> not <identifiersep> busy ) ; file <identifiersep> logger <identifiersep> hook = hook ; logger . global <identifiersep> add <identifiersep> hook ( hook ) ; <ect>
peer [ ] peers = new peer [ all . length ] ; for ( int i = 0 ; i < all . length ; i ++ ) peers [ i ] = new peer ( all [ i ] , false ) ; last <identifiersep> inserted <identifiersep> peers = peers ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + darknet <identifiersep> opennet <identifiersep> string + <string_literal> + e1 + <string_literal> + fs . get ( <string_literal> ) , e1 ) ; <LOG> } catch ( unknown <identifiersep> host <identifiersep> exception e1 ) { } } } } catch ( insert <identifiersep> exception e ) { on <identifiersep> failure ( e , inserter ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
public boolean persistent ( ) { return false ; } @ override public boolean real <identifiersep> time <identifiersep> flag ( ) { return false ; } @ override <LOG> public void on <identifiersep> generated <identifiersep> metadata ( bucket metadata , base <identifiersep> client <identifiersep> putter state ) { metadata . free ( ) ; } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <comment> <ect>
while ( true ) { int offset = dis . read <identifiersep> int ( ) ; if ( offset < base ) continue ; int slot <identifiersep> no = offset - base ; if ( slot <identifiersep> no == was <identifiersep> online <identifiersep> week . length ) break ; <comment> <LOG> if ( slot <identifiersep> no > was <identifiersep> online <identifiersep> week . length || slot <identifiersep> no < 0 ) { break ; } was <identifiersep> online [ slot <identifiersep> no % was <identifiersep> online . length ] = was <identifiersep> online <identifiersep> week [ slot <identifiersep> no ] = true ; } } catch ( eof <identifiersep> exception e ) { <comment> <ect>
data <identifiersep> output <identifiersep> stream dos = null ; int five <identifiersep> minutes <identifiersep> since <identifiersep> epoch = ( int ) ( now / period ) ; try { fos = new file <identifiersep> output <identifiersep> stream ( log <identifiersep> file , true ) ; dos = new data <identifiersep> output <identifiersep> stream ( fos ) ; dos . write <identifiersep> int ( five <identifiersep> minutes <identifiersep> since <identifiersep> epoch ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + log <identifiersep> file ) ; } finally { closer . close ( dos ) ; closer . close ( fos ) ; <ect>
<comment> <LOG> } catch ( throwable t ) { } } } , seconds . to <identifiersep> millis ( <number_literal> ) ) ; } } public inet <identifiersep> address [ ] get <identifiersep> inet <identifiersep> addresses ( ) { array <identifiersep> list < inet <identifiersep> address > v = new array <identifiersep> list < inet <identifiersep> address > ( ) ; for ( peer peer : get <identifiersep> handshake <identifiersep> i <identifiersep> ps ( ) ) { freenet <identifiersep> inet <identifiersep> address fa = peer . get <identifiersep> freenet <identifiersep> address ( ) . drop <identifiersep> hostname ( ) ; <ect>
<comment> <LOG> public int lost ( int start , int end ) { int size = end - start + 1 ; synchronized ( sent ) { synchronized ( acks ) { resends ++ ; sent . remove ( start , end ) ; <ect>
- ( is <identifiersep> short <identifiersep> message ? 1 : <number_literal> ) ; <comment> <LOG> sent . add ( start , start + data <identifiersep> length - 1 ) ; } boolean is <identifiersep> fragmented = ! ( ( start == 0 ) && ( data <identifiersep> length == item . buf . length ) ) ; return new message <identifiersep> fragment ( is <identifiersep> short <identifiersep> message , is <identifiersep> fragmented , start == 0 , message <identifiersep> id , data <identifiersep> length , item . buf . length , start , fragment <identifiersep> data , this ) ; } public void on <identifiersep> disconnect ( ) { item . on <identifiersep> disconnect ( ) ; <ect>
case low <identifiersep> level <identifiersep> get <identifiersep> exception . transfer <identifiersep> failed : return new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . transfer <identifiersep> failed ) ; case low <identifiersep> level <identifiersep> get <identifiersep> exception . verify <identifiersep> failed : return new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . block <identifiersep> decode <identifiersep> error ) ; case low <identifiersep> level <identifiersep> get <identifiersep> exception . cancelled : return new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . cancelled ) ; <LOG> default : return new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e . code ) ; } } @ override public boolean reduce <identifiersep> wakeup <identifiersep> time ( final long wakeup <identifiersep> time , client <identifiersep> context context ) { boolean ret = super . reduce <identifiersep> wakeup <identifiersep> time ( wakeup <identifiersep> time , context ) ; if ( this . parent instanceof wants <identifiersep> cooldown <identifiersep> callback ) { <ect>
if ( forked <identifiersep> request <identifiersep> tag == null ) this <identifiersep> tag = orig <identifiersep> tag ; inner <identifiersep> route <identifiersep> requests ( next , this <identifiersep> tag ) ; return ; } } private void handle <identifiersep> no <identifiersep> pubkey <identifiersep> accepted ( peer <identifiersep> node next , insert <identifiersep> tag this <identifiersep> tag ) { <comment> <LOG> <comment> <ect>
data <identifiersep> message = node . usm . wait <identifiersep> for ( mf <identifiersep> data , this ) ; } catch ( disconnected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + next + <string_literal> + this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; return do . next <identifiersep> peer ; } <LOG> if ( data <identifiersep> message == null ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; return do . next <identifiersep> peer ; } <comment> <ect>
sent <identifiersep> payload ( data . length ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + next ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; } <comment> <ect>
} catch ( disconnected <identifiersep> exception e ) { logger . normal ( this , <string_literal> + next + <string_literal> + this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; break ; } if ( msg == null ) { <LOG> <comment> <ect>
try { real <identifiersep> run ( ) ; <comment> <LOG> } catch ( throwable t ) { tag . handler <identifiersep> threw ( t ) ; } } private void apply <identifiersep> byte <identifiersep> counts ( ) { synchronized ( this ) { if ( disconnected ) { logger . normal ( this , <string_literal> ) ; <ect>
* methods would need to be reconsidered . * * security : also , always keeping transferring the data would open * up do <identifiersep> s opportunities , unless we disallow receiver cancels of * transfers , which would require getting rid of turtles . see the * discussion in block <identifiersep> receiver's top comments . <LOG> <comment> node . tracker . reassign <identifiersep> tag <identifiersep> to <identifiersep> self ( tag ) ; return false ; <comment> <ect>
status = rs . get <identifiersep> status ( ) ; <comment> <LOG> if ( bt == null ) { return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; tag . on <identifiersep> abort <identifiersep> downstream <identifiersep> transfers ( reason , desc ) ; try { <ect>
node . failure <identifiersep> table . on <identifiersep> final <identifiersep> failure ( key , null , htl , htl , - 1 , - 1 , source ) ; peer <identifiersep> node routed <identifiersep> last = rs == null ? null : rs . routed <identifiersep> last ( ) ; <comment> <LOG> if ( status == request <identifiersep> sender . not <identifiersep> finished ) try { switch ( status ) { case request <identifiersep> sender . not <identifiersep> finished : case request <identifiersep> sender . data <identifiersep> not <identifiersep> found : message dnf = dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> not <identifiersep> found ( uid ) ; <ect>
boolean xfer <identifiersep> finished = false ; boolean xfer <identifiersep> success = false ; synchronized ( this ) { if ( disconnected ) disconn = true ; else if ( bt == null ) { <LOG> <comment> <ect>
return ; try { if ( node . add <identifiersep> new <identifiersep> opennet <identifiersep> node ( ref , connection <identifiersep> type . path <identifiersep> folding ) == null ) logger . normal ( this , <string_literal> + this + <string_literal> + ref ) ; else logger . normal ( this , <string_literal> + this ) ; <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + source , e ) ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + source + <string_literal> + e , e ) ; } } <comment> <ect>
else logger . normal ( this , <string_literal> + this ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + source , e ) ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + source , e ) ; <LOG> } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { } } <comment> <ect>
} catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; finish ( internal <identifiersep> error , null , false ) ; } finally { <comment> <LOG> if ( status == not <identifiersep> finished && ! receiving <identifiersep> async ) { finish ( internal <identifiersep> error , null , false ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; } } static final int max <identifiersep> high <identifiersep> htl <identifiersep> failures = <number_literal> ; private void real <identifiersep> run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; <ect>
public boolean should <identifiersep> timeout ( ) { if ( no <identifiersep> reroute ) return false ; return false ; } @ override public void on <identifiersep> timeout ( ) { <comment> <LOG> <comment> <ect>
handle <identifiersep> chk <identifiersep> offer <identifiersep> reply ( m , pn , offer , offers ) ; try <identifiersep> offers ( offers , pn , status ) ; } @ override public boolean should <identifiersep> timeout ( ) { return false ; } @ override <LOG> public void on <identifiersep> timeout ( ) { <comment> <ect>
try { data <identifiersep> message = node . usm . wait <identifiersep> for ( mf <identifiersep> data , this ) ; } catch ( disconnected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn + <string_literal> + key ) ; return offer <identifiersep> status . try <identifiersep> another ; } <LOG> if ( data <identifiersep> message == null ) { return offer <identifiersep> status . try <identifiersep> another ; } byte [ ] ssk <identifiersep> data = ( ( short <identifiersep> buffer ) data <identifiersep> message . get <identifiersep> object ( dmt . data ) ) . get <identifiersep> data ( ) ; if ( pub <identifiersep> key == null ) { message <identifiersep> filter mf <identifiersep> pk = message <identifiersep> filter . create ( ) . set <identifiersep> source ( pn ) . set <identifiersep> field ( dmt . uid , uid ) . set <identifiersep> timeout ( get <identifiersep> offered <identifiersep> timeout ) . set <identifiersep> type ( dmt . fnpssk <identifiersep> pub <identifiersep> key ) ; message pk ; <ect>
return offer <identifiersep> status . try <identifiersep> another ; } if ( pk == null ) { logger . error ( this , <string_literal> + pn + <string_literal> + key + <string_literal> + this ) ; return offer <identifiersep> status . try <identifiersep> another ; } try { pub <identifiersep> key = dsa <identifiersep> public <identifiersep> key . create ( ( ( short <identifiersep> buffer ) pk . get <identifiersep> object ( dmt . pubkey <identifiersep> as <identifiersep> bytes ) ) . get <identifiersep> data ( ) ) ; <LOG> } catch ( crypt <identifiersep> format <identifiersep> exception e ) { return offer <identifiersep> status . try <identifiersep> another ; } try { ( ( node <identifiersep> ssk ) key ) . set <identifiersep> pub <identifiersep> key ( pub <identifiersep> key ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { logger . error ( this , <string_literal> + pn + <string_literal> + key + <string_literal> + e , e ) ; <ect>
if ( finish <identifiersep> ssk <identifiersep> from <identifiersep> get <identifiersep> offer ( pn , headers , ssk <identifiersep> data ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn + <string_literal> + key ) ; return offer <identifiersep> status . fetching ; } else { return offer <identifiersep> status . try <identifiersep> another ; } } else { <LOG> <comment> <ect>
<comment> <LOG> } catch ( throwable t ) { if ( offers != null ) { finish ( internal <identifiersep> error , pn , true ) ; } } finally { <comment> <ect>
if ( node . random . next <identifiersep> int ( random <identifiersep> reinsert <identifiersep> interval ) == 0 ) node . queue <identifiersep> random <identifiersep> reinsert ( block ) ; synchronized ( this ) { final <identifiersep> headers = headers ; final <identifiersep> ssk <identifiersep> data = ssk <identifiersep> data ; } finish ( success , next , false ) ; <LOG> } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { if ( ! was <identifiersep> fork ) finish ( verify <identifiersep> failure , next , false ) ; else next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return ; <ect>
if ( prb != null ) current | = wait <identifiersep> transferring <identifiersep> data ; if ( status != not <identifiersep> finished || sent <identifiersep> abort <identifiersep> downstream <identifiersep> transfers ) current | = wait <identifiersep> finished ; if ( current != mask ) return current ; try { <LOG> if ( now >= deadline ) { break ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + current + <string_literal> + status ) ; wait ( deadline - now ) ; now = system . current <identifiersep> time <identifiersep> millis ( ) ; <comment> <ect>
} else { <comment> <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { ack <identifiersep> opennet ( next ) ; return false ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + next , e ) ; ack <identifiersep> opennet ( next ) ; <ect>
ack <identifiersep> opennet ( next ) ; return false ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + next , e ) ; ack <identifiersep> opennet ( next ) ; return false ; <LOG> } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { ack <identifiersep> opennet ( next ) ; return false ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + next ) ; orig <identifiersep> tag . finished <identifiersep> waiting <identifiersep> for <identifiersep> opennet ( next ) ; } catch ( waited <identifiersep> too <identifiersep> long <identifiersep> for <identifiersep> opennet <identifiersep> noderef <identifiersep> exception e ) { logger . error ( this , <string_literal> + next + <string_literal> + this ) ; <comment> <LOG> orig <identifiersep> tag . timed <identifiersep> out <identifiersep> to <identifiersep> handler <identifiersep> but <identifiersep> continued ( ) ; <comment> <ect>
<comment> <LOG> else } } private boolean sent <identifiersep> received <identifiersep> reject <identifiersep> overload ; private void fire <identifiersep> received <identifiersep> reject <identifiersep> overload ( ) { synchronized ( listeners ) { if ( sent <identifiersep> received <identifiersep> reject <identifiersep> overload ) return ; sent <identifiersep> received <identifiersep> reject <identifiersep> overload = true ; <ect>
synchronized ( listeners ) { if ( sent <identifiersep> chk <identifiersep> transfer <identifiersep> begins ) return ; sent <identifiersep> chk <identifiersep> transfer <identifiersep> begins = true ; for ( request <identifiersep> sender <identifiersep> listener l : listeners ) { try { l . on <identifiersep> chk <identifiersep> transfer <identifiersep> begins ( ) ; <LOG> } catch ( throwable t ) { } } } } private boolean sent <identifiersep> request <identifiersep> sender <identifiersep> finished ; private boolean completed <identifiersep> from <identifiersep> offered <identifiersep> key ; private void fire <identifiersep> request <identifiersep> sender <identifiersep> finished ( int status , boolean from <identifiersep> offered <identifiersep> key ) { orig <identifiersep> tag . set <identifiersep> request <identifiersep> sender <identifiersep> finished ( status ) ; synchronized ( listeners ) { <ect>
sent <identifiersep> request <identifiersep> sender <identifiersep> finished = true ; completed <identifiersep> from <identifiersep> offered <identifiersep> key = from <identifiersep> offered <identifiersep> key ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + listeners . size ( ) + <string_literal> + status ) ; for ( request <identifiersep> sender <identifiersep> listener l : listeners ) { try { l . on <identifiersep> request <identifiersep> sender <identifiersep> finished ( status , from <identifiersep> offered <identifiersep> key , this ) ; <LOG> } catch ( throwable t ) { } } } } private boolean sent <identifiersep> abort <identifiersep> downstream <identifiersep> transfers ; private int abort <identifiersep> downstream <identifiersep> transfers <identifiersep> reason ; private string abort <identifiersep> downstream <identifiersep> transfers <identifiersep> desc ; private boolean receiving <identifiersep> async ; private void reassign <identifiersep> to <identifiersep> self <identifiersep> on <identifiersep> timeout ( boolean from <identifiersep> offered <identifiersep> key ) { <ect>
public void on <identifiersep> first <identifiersep> timeout ( ) { orig <identifiersep> tag . timed <identifiersep> out <identifiersep> to <identifiersep> handler <identifiersep> but <identifiersep> continued ( ) ; } <comment> @ override <LOG> public void on <identifiersep> fatal <identifiersep> timeout ( peer <identifiersep> context receiving <identifiersep> from ) { ( ( peer <identifiersep> node ) receiving <identifiersep> from ) . fatal <identifiersep> timeout ( ) ; } } ; <comment> <ect>
} else if ( i == 1 ) { s = pn . get <identifiersep> previous <identifiersep> key <identifiersep> tracker ( ) ; } else { s = pn . get <identifiersep> unverified <identifiersep> key <identifiersep> tracker ( ) ; } if ( s == null ) continue ; packet = try <identifiersep> decipher <identifiersep> packet ( buf , offset , length , s ) ; <LOG> if ( packet != null ) { break ; } } if ( packet == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return false ; } pn . received <identifiersep> packet ( false , true ) ; <ect>
if ( message <identifiersep> window <identifiersep> ptr <identifiersep> received < old <identifiersep> window ) { received <identifiersep> messages . remove ( old <identifiersep> window , num <identifiersep> message <identifiersep> ids - 1 ) ; received <identifiersep> messages . remove ( 0 , message <identifiersep> window <identifiersep> ptr <identifiersep> received ) ; } else { received <identifiersep> messages . remove ( old <identifiersep> window , message <identifiersep> window <identifiersep> ptr <identifiersep> received ) ; } } synchronized ( send <identifiersep> buffer <identifiersep> lock ) { <LOG> receive <identifiersep> buffer <identifiersep> used -= recv <identifiersep> buffer . message <identifiersep> length ; } fully <identifiersep> received . add ( recv <identifiersep> buffer . buffer ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + fragment . message <identifiersep> id + <string_literal> ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + fragment . message <identifiersep> id + <string_literal> + recv <identifiersep> map ) ; } } if ( ! dont <identifiersep> ack ) { <ect>
if ( seq <identifiersep> num <identifiersep> greater <identifiersep> than ( highest <identifiersep> received <identifiersep> seq <identifiersep> num , old <identifiersep> highest <identifiersep> received , <number_literal> ) ) { int move <identifiersep> by ; if ( highest <identifiersep> received <identifiersep> seq <identifiersep> num > old <identifiersep> highest <identifiersep> received ) { move <identifiersep> by = highest <identifiersep> received <identifiersep> seq <identifiersep> num - old <identifiersep> highest <identifiersep> received ; } else { move <identifiersep> by = ( ( int ) ( num <identifiersep> seqnums - old <identifiersep> highest <identifiersep> received ) ) + highest <identifiersep> received <identifiersep> seq <identifiersep> num ; } <LOG> if ( move <identifiersep> by > key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ) { } else if ( move <identifiersep> by < 0 ) { logger . warning ( this , <string_literal> + move <identifiersep> by ) ; move <identifiersep> by = 0 ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + move <identifiersep> by ) ; <ect>
move <identifiersep> by = ( ( int ) ( num <identifiersep> seqnums - old <identifiersep> highest <identifiersep> received ) ) + highest <identifiersep> received <identifiersep> seq <identifiersep> num ; } if ( move <identifiersep> by > key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ) { logger . warning ( this , <string_literal> + move <identifiersep> by ) ; } else if ( move <identifiersep> by < 0 ) { logger . warning ( this , <string_literal> + move <identifiersep> by ) ; move <identifiersep> by = 0 ; <LOG> } else { } int seq <identifiersep> num = ( int ) ( ( 0l + key <identifiersep> context . watch <identifiersep> list <identifiersep> offset + key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ) % num <identifiersep> seqnums ) ; for ( int i = key <identifiersep> context . watch <identifiersep> list <identifiersep> pointer ; i < ( key <identifiersep> context . watch <identifiersep> list <identifiersep> pointer + move <identifiersep> by ) ; i ++ ) { key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list [ i % key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ] = encrypt <identifiersep> sequence <identifiersep> number ( seq <identifiersep> num ++ , session <identifiersep> key ) ; if ( seq <identifiersep> num < 0 ) seq <identifiersep> num = 0 ; } key <identifiersep> context . watch <identifiersep> list <identifiersep> pointer = ( key <identifiersep> context . watch <identifiersep> list <identifiersep> pointer + move <identifiersep> by ) % key <identifiersep> context . seq <identifiersep> num <identifiersep> watch <identifiersep> list . length ; <ect>
if ( maybe <identifiersep> send <identifiersep> packet ( true , session <identifiersep> key ) ) return true ; } session <identifiersep> key = pn . get <identifiersep> unverified <identifiersep> key <identifiersep> tracker ( ) ; if ( session <identifiersep> key != null ) { <comment> <LOG> if ( session <identifiersep> key == null ) { return false ; } return maybe <identifiersep> send <identifiersep> packet ( ack <identifiersep> only , session <identifiersep> key ) ; } boolean maybe <identifiersep> send <identifiersep> packet ( boolean ack <identifiersep> only , session <identifiersep> key session <identifiersep> key ) throws blocked <identifiersep> too <identifiersep> long <identifiersep> exception { int max <identifiersep> packet <identifiersep> size = pn . get <identifiersep> max <identifiersep> packet <identifiersep> size ( ) ; <ect>
else fragments = fragments + <string_literal> + frag . message <identifiersep> id ; fragments += <string_literal> + frag . fragment <identifiersep> offset + <string_literal> + ( frag . fragment <identifiersep> offset + frag . fragment <identifiersep> length - 1 ) + <string_literal> ; } logger . minor ( this , <string_literal> + packet . get <identifiersep> sequence <identifiersep> number ( ) + <string_literal> + data . length + <string_literal> + fragments + <string_literal> + packet . get <identifiersep> acks ( ) . size ( ) + <string_literal> + this ) ; } pn . send <identifiersep> encrypted <identifiersep> packet ( data ) ; <LOG> } catch ( local <identifiersep> address <identifiersep> exception e ) { return false ; } packet . on <identifiersep> sent ( data . length , pn ) ; if ( packet . get <identifiersep> fragments ( ) . size ( ) > 0 ) { key <identifiersep> context . sent ( packet . get <identifiersep> sequence <identifiersep> number ( ) , packet . get <identifiersep> length ( ) ) ; } long now = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
if ( moved != null && moved . any <identifiersep> urgent <identifiersep> acks ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; must <identifiersep> send = true ; } int num <identifiersep> acks = packet . count <identifiersep> acks ( ) ; if ( num <identifiersep> acks > max <identifiersep> acks ) { must <identifiersep> send = true ; } <LOG> if ( num <identifiersep> acks > 0 ) { } byte [ ] have <identifiersep> added <identifiersep> stats <identifiersep> bulk = null ; byte [ ] have <identifiersep> added <identifiersep> stats <identifiersep> rt = null ; if ( ! ack <identifiersep> only ) { boolean added <identifiersep> fragments = false ; while ( true ) { <ect>
byte [ ] buf = item . get <identifiersep> data ( ) ; have <identifiersep> added <identifiersep> stats <identifiersep> rt = buf ; <comment> <LOG> if ( ( ! must <identifiersep> send ) && packet . get <identifiersep> length ( ) >= ( max <identifiersep> packet <identifiersep> size * <number_literal> / <number_literal> ) ) { <comment> <ect>
for ( message <identifiersep> wrapper wrapper : queue . values ( ) ) { items . add ( wrapper . get <identifiersep> item ( ) ) ; message <identifiersep> size += wrapper . get <identifiersep> length ( ) ; } queue . clear ( ) ; } send <identifiersep> buffer <identifiersep> used -= message <identifiersep> size ; <comment> <LOG> if ( send <identifiersep> buffer <identifiersep> used != 0 ) { send <identifiersep> buffer <identifiersep> used = 0 ; } } return items ; } <comment> <ect>
if ( can <identifiersep> allocate <identifiersep> id ) { <comment> <LOG> pn . start <identifiersep> rekeying ( ) ; return false ; } } if ( can <identifiersep> allocate <identifiersep> id ) { int buffer <identifiersep> usage ; synchronized ( send <identifiersep> buffer <identifiersep> lock ) { buffer <identifiersep> usage = send <identifiersep> buffer <identifiersep> used ; <ect>
<comment> <LOG> <comment> <ect>
public long acked ( session <identifiersep> key key ) { iterator < message <identifiersep> wrapper > msg <identifiersep> it = messages . iterator ( ) ; iterator < int [ ] > range <identifiersep> it = ranges . iterator ( ) ; while ( msg <identifiersep> it . has <identifiersep> next ( ) ) { message <identifiersep> wrapper wrapper = msg <identifiersep> it . next ( ) ; int [ ] range = range <identifiersep> it . next ( ) ; <LOG> if ( log <identifiersep> debug ) if ( wrapper . ack ( range [ 0 ] , range [ 1 ] , npf . pn ) ) { map < integer , message <identifiersep> wrapper > started = npf . started <identifiersep> by <identifiersep> prio . get ( wrapper . get <identifiersep> priority ( ) ) ; message <identifiersep> wrapper removed = null ; synchronized ( npf . send <identifiersep> buffer <identifiersep> lock ) { removed = started . remove ( wrapper . get <identifiersep> message <identifiersep> id ( ) ) ; <ect>
int size = wrapper . get <identifiersep> length ( ) ; npf . send <identifiersep> buffer <identifiersep> used -= size ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + size + <string_literal> + npf . send <identifiersep> buffer <identifiersep> used ) ; } } if ( removed == null && log <identifiersep> minor ) { <comment> <LOG> if ( removed != null ) { boolean could <identifiersep> send = npf . can <identifiersep> send ( key ) ; int id = wrapper . get <identifiersep> message <identifiersep> id ( ) ; synchronized ( npf ) { npf . acked <identifiersep> messages . add ( id , id ) ; int old <identifiersep> window = npf . message <identifiersep> window <identifiersep> ptr <identifiersep> acked ; <ect>
system . arraycopy ( data , 0 , buffer , data <identifiersep> offset , data . length ) ; return true ; } private boolean set <identifiersep> message <identifiersep> length ( int message <identifiersep> length ) { if ( this . message <identifiersep> length != - 1 && this . message <identifiersep> length != message <identifiersep> length ) { logger . warning ( this , <string_literal> ) ; } this . message <identifiersep> length = message <identifiersep> length ; <LOG> if ( buffer . length > message <identifiersep> length ) { } return resize ( message <identifiersep> length ) ; } private boolean resize ( int length ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . length + <string_literal> + length ) ; synchronized ( npf . receive <identifiersep> buffer <identifiersep> size <identifiersep> lock ) { if ( ( npf . receive <identifiersep> buffer <identifiersep> used + ( length - buffer . length ) ) > max <identifiersep> receive <identifiersep> buffer <identifiersep> size ) { <ect>
private boolean resize ( int length ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . length + <string_literal> + length ) ; synchronized ( npf . receive <identifiersep> buffer <identifiersep> size <identifiersep> lock ) { if ( ( npf . receive <identifiersep> buffer <identifiersep> used + ( length - buffer . length ) ) > max <identifiersep> receive <identifiersep> buffer <identifiersep> size ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return false ; } <LOG> npf . receive <identifiersep> buffer <identifiersep> used += ( length - buffer . length ) ; } buffer = arrays . copy <identifiersep> of ( buffer , length ) ; return true ; } } @ override public string to <identifiersep> string ( ) { if ( pn != null ) return super . to <identifiersep> string ( ) + <string_literal> + pn . short <identifiersep> to <identifiersep> string ( ) ; <ect>
public boolean is <identifiersep> insert ( ) { return false ; } @ override public boolean is <identifiersep> offer <identifiersep> reply ( ) { return false ; } public synchronized void waiting <identifiersep> for <identifiersep> opennet ( peer <identifiersep> node next ) { <LOG> if ( waiting <identifiersep> for <identifiersep> opennet != null ) this . waiting <identifiersep> for <identifiersep> opennet = next . my <identifiersep> ref ; } public void finished <identifiersep> waiting <identifiersep> for <identifiersep> opennet ( peer <identifiersep> node next ) { boolean no <identifiersep> record <identifiersep> unlock ; synchronized ( this ) { if ( waiting <identifiersep> for <identifiersep> opennet == null ) { <ect>
<comment> try { if ( probe <identifiersep> identifier == - 1 ) { node <identifiersep> config . get <identifiersep> option ( <string_literal> ) . set <identifiersep> value ( <string_literal> ) ; <comment> <LOG> } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e ) { } catch ( node <identifiersep> need <identifiersep> restart <identifiersep> exception e ) { logger . error ( probe . class , <string_literal> , e ) ; } } <comment> <ect>
<comment> private void request ( final message message , final peer <identifiersep> node source , final listener listener ) { final long uid = message . get <identifiersep> long ( dmt . uid ) ; final byte type <identifiersep> code = message . get <identifiersep> byte ( dmt . type ) ; final type type ; if ( type . is <identifiersep> valid ( type <identifiersep> code ) ) { <LOG> type = type . value <identifiersep> of ( type <identifiersep> code ) ; } else { if ( log <identifiersep> minor ) logger . minor ( probe . class , <string_literal> + type <identifiersep> code + <string_literal> ) ; listener . on <identifiersep> error ( error . unrecognized <identifiersep> type , type <identifiersep> code , true ) ; return ; } byte htl = message . get <identifiersep> byte ( dmt . htl ) ; <ect>
float accept <identifiersep> probability ; int candidate <identifiersep> degree = candidate . get <identifiersep> degree ( ) ; <comment> if ( candidate <identifiersep> degree == 0 ) accept <identifiersep> probability = 1 . 0f ; <LOG> else accept <identifiersep> probability = ( float ) degree / candidate <identifiersep> degree ; if ( node . random . next <identifiersep> float ( ) < accept <identifiersep> probability ) { if ( log <identifiersep> debug ) logger . debug ( probe . class , <string_literal> ) ; <comment> <ect>
if ( node . random . next <identifiersep> float ( ) < accept <identifiersep> probability ) { if ( log <identifiersep> debug ) logger . debug ( probe . class , <string_literal> ) ; <comment> <LOG> node . get <identifiersep> usm ( ) . add <identifiersep> async <identifiersep> filter ( filter , new result <identifiersep> listener ( listener ) , this ) ; candidate . send <identifiersep> async ( message , null , this ) ; return true ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( probe . class , <string_literal> , e ) ; <comment> <ect>
<comment> public result <identifiersep> listener ( listener listener ) { this . listener = listener ; } @ override <LOG> public void on <identifiersep> disconnect ( peer <identifiersep> context context ) { listener . on <identifiersep> error ( error . disconnected , null , true ) ; } <comment> <ect>
listener . on <identifiersep> refused ( ) ; } else { throw new unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> + message . get <identifiersep> spec ( ) . get <identifiersep> name ( ) ) ; } } @ override public void on <identifiersep> restarted ( peer <identifiersep> context context ) { } @ override <LOG> public void on <identifiersep> timeout ( ) { listener . on <identifiersep> error ( error . timeout , null , true ) ; } @ override public boolean should <identifiersep> timeout ( ) { return false ; } } <comment> <ect>
send ( dmt . create <identifiersep> probe <identifiersep> store <identifiersep> size ( uid , store <identifiersep> size ) ) ; } @ override public void on <identifiersep> uptime ( float uptime <identifiersep> percentage ) { send ( dmt . create <identifiersep> probe <identifiersep> uptime ( uid , uptime <identifiersep> percentage ) ) ; } @ override public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { <LOG> if ( stats . length < <number_literal> ) { on <identifiersep> error ( error . unknown , error . unknown . code , true ) ; } else { if ( stats . length > <number_literal> ) stats = arrays . copy <identifiersep> of ( stats , <number_literal> ) ; send ( dmt . create <identifiersep> probe <identifiersep> reject <identifiersep> stats ( uid , stats ) ) ; <ect>
@ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { try { real <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { } } } private void real <identifiersep> run ( ) { peer <identifiersep> node [ ] nodes = node . peers . my <identifiersep> peers ( ) ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( now - last <identifiersep> log <identifiersep> time ) > <number_literal> ) { if ( log <identifiersep> minor ) <ect>
public void on <identifiersep> succeeded ( ) { req . on <identifiersep> fetch <identifiersep> success ( context ) ; } @ override public void on <identifiersep> failed ( low <identifiersep> level <identifiersep> get <identifiersep> exception e ) { req . on <identifiersep> failure ( e , context ) ; } } , ! req . ignore <identifiersep> store , req . can <identifiersep> write <identifiersep> client <identifiersep> cache , req . real <identifiersep> time <identifiersep> flag , req . local <identifiersep> request <identifiersep> only , req . ignore <identifiersep> store ) ; <LOG> } catch ( throwable t ) { req . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) , context ) ; return true ; } } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; req . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) , context ) ; <ect>
node . plugin <identifiersep> manager . kill <identifiersep> plugin ( ( fred <identifiersep> plugin ) plugin , 0 ) ; } @ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { real <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { } } public void real <identifiersep> run ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; try { list < detected <identifiersep> ip > v = new array <identifiersep> list < detected <identifiersep> ip > ( ) ; detected <identifiersep> ip [ ] detected = null ; <ect>
int count <identifiersep> full <identifiersep> cone = 0 ; int count <identifiersep> restricted = 0 ; int count <identifiersep> port <identifiersep> restricted = 0 ; int count <identifiersep> symmetric = 0 ; int count <identifiersep> closed = 0 ; for ( detected <identifiersep> ip d : list ) { <LOG> logger . normal ( this , <string_literal> + d . public <identifiersep> address + <string_literal> + d . nat <identifiersep> type ) ; switch ( d . nat <identifiersep> type ) { case detected <identifiersep> ip . full <identifiersep> cone <identifiersep> nat : count <identifiersep> full <identifiersep> cone ++ ; break ; case detected <identifiersep> ip . full <identifiersep> internet : <ect>
if ( status . status == forward <identifiersep> port <identifiersep> status . definite <identifiersep> success ) { logger . normal ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; } else if ( status . status == forward <identifiersep> port <identifiersep> status . probable <identifiersep> success ) { logger . normal ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; } else if ( status . status == forward <identifiersep> port <identifiersep> status . maybe <identifiersep> success ) { logger . normal ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; <LOG> } else if ( status . status == forward <identifiersep> port <identifiersep> status . definite <identifiersep> failure ) { } else if ( status . status == forward <identifiersep> port <identifiersep> status . probable <identifiersep> failure ) { logger . error ( this , <string_literal> + p . name + <string_literal> + p . port <identifiersep> number + <string_literal> + p . protocol + <string_literal> + status . reason <identifiersep> string ) ; } <comment> <ect>
} , <string_literal> ) ; } public synchronized boolean has <identifiersep> detectors ( ) { return plugins . length > 0 ; } public void add <identifiersep> connection <identifiersep> type <identifiersep> box ( html <identifiersep> node content <identifiersep> node ) { if ( node . client <identifiersep> core == null ) return ; if ( node . client <identifiersep> core . alerts == null ) return ; <LOG> if ( proxy <identifiersep> alert == null ) { return ; } if ( proxy <identifiersep> alert . is <identifiersep> valid ( ) ) content <identifiersep> node . add <identifiersep> child ( node . client <identifiersep> core . alerts . render <identifiersep> alert ( proxy <identifiersep> alert ) ) ; } public boolean has <identifiersep> jstun ( ) { return node . plugin <identifiersep> manager . is <identifiersep> plugin <identifiersep> loaded <identifiersep> or <identifiersep> loading <identifiersep> or <identifiersep> want <identifiersep> load ( <string_literal> ) ; <ect>
try { w . write ( <string_literal> ) ; w . flush ( ) ; if ( process <identifiersep> line ( reader ) ) { reader . close ( ) ; return ; } <LOG> } catch ( socket <identifiersep> exception e ) { return ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; system . out . println ( <string_literal> + t ) ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; <ect>
reader . close ( ) ; return ; } } catch ( socket <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } catch ( throwable t ) { <LOG> logger . error ( this , <string_literal> + t , t ) ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; t . print <identifiersep> stack <identifiersep> trace ( new print <identifiersep> writer ( sw ) ) ; try { w . write ( sw . to <identifiersep> string ( ) ) ; } catch ( io <identifiersep> exception e ) { <ect>
private boolean process <identifiersep> line ( buffered <identifiersep> reader reader ) throws io <identifiersep> exception { string line ; string <identifiersep> builder outsb = new string <identifiersep> builder ( ) ; try { line = reader . read <identifiersep> line ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> outsb . append ( <string_literal> ) . append ( e ) . append ( ' ) ' ) ; return true ; } boolean get <identifiersep> chk <identifiersep> only = false ; if ( line == null ) return true ; string uline = line . to <identifiersep> upper <identifiersep> case ( ) ; if ( log <identifiersep> minor ) <ect>
boolean evil = false ; for ( byte b : data <identifiersep> bytes ) { <comment> <LOG> if ( evil ) { outsb . append ( <string_literal> ) ; outsb . append ( <string_literal> ) ; w . write ( outsb . to <identifiersep> string ( ) ) ; w . flush ( ) ; return false ; <ect>
boolean evil = false ; for ( byte b : data <identifiersep> bytes ) { <comment> <LOG> if ( evil ) { outsb . append ( <string_literal> ) ; outsb . append ( <string_literal> ) ; w . write ( outsb . to <identifiersep> string ( ) ) ; w . flush ( ) ; return false ; <ect>
while ( bis . available ( ) > 0 ) { outsb . append ( ( char ) bis . read ( ) ) ; } } catch ( io <identifiersep> exception e ) { outsb . append ( <string_literal> + e . get <identifiersep> message ( ) ) ; logger . error ( this , <string_literal> + e , e ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <LOG> outsb . append ( <string_literal> + e . get <identifiersep> message ( ) ) ; } finally { closer . close ( input <identifiersep> stream ) ; closer . close ( output <identifiersep> stream ) ; closer . close ( bis ) ; input . free ( ) ; <ect>
if ( e . uri != null ) { uri = e . uri ; uri = uri . add <identifiersep> meta <identifiersep> strings ( new string [ ] { <string_literal> } ) ; outsb . append ( <string_literal> ) . append ( uri ) ; } if ( e . error <identifiersep> codes != null ) { outsb . append ( <string_literal> ) ; <LOG> outsb . append ( e . error <identifiersep> codes . to <identifiersep> verbose <identifiersep> string ( ) ) ; } } } else if ( uline . starts <identifiersep> with ( <string_literal> ) || ( get <identifiersep> chk <identifiersep> only = uline . starts <identifiersep> with ( <string_literal> ) ) ) { <comment> <ect>
<comment> private hash <identifiersep> map < string , object > make <identifiersep> buckets <identifiersep> by <identifiersep> name ( string directory ) { if ( ! directory . ends <identifiersep> with ( <string_literal> ) ) directory = directory + ' / ' ; <LOG> file thisdir = new file ( directory ) ; hash <identifiersep> map < string , object > ret = new hash <identifiersep> map < string , object > ( ) ; file filelist [ ] = thisdir . list <identifiersep> files ( ) ; if ( filelist == null ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; for ( int i = 0 ; i < filelist . length ; i ++ ) { <ect>
if ( line . ends <identifiersep> with ( <string_literal> ) && character . is <identifiersep> whitespace ( line . char <identifiersep> at ( line . length ( ) - ( <string_literal> . length ( ) + 1 ) ) ) ) { line = <string_literal> ; breakflag = true ; } else { int idx = line . index <identifiersep> of ( ' = ' ) ; <LOG> if ( idx < 0 ) { return <string_literal> ; } else { if ( idx > 0 ) { string after ; if ( idx == line . length ( ) - 1 ) <ect>
if ( breakflag ) break ; } return sb . to <identifiersep> string ( ) ; } <comment> private void add <identifiersep> peer ( string content ) { <LOG> simple <identifiersep> field <identifiersep> set fs ; try { fs = new simple <identifiersep> field <identifiersep> set ( content , false , true , false ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } peer <identifiersep> node pn ; try { pn = n . create <identifiersep> new <identifiersep> darknet <identifiersep> node ( fs , friend <identifiersep> trust . normal , friend <identifiersep> visibility . no ) ; <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; <ect>
try { pn = n . create <identifiersep> new <identifiersep> darknet <identifiersep> node ( fs , friend <identifiersep> trust . normal , friend <identifiersep> visibility . no ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; <ect>
logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; <LOG> } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; <ect>
overall <identifiersep> map . put ( uid , tag ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + overall <identifiersep> map . size ( ) ) ; if ( local ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + local <identifiersep> map . size ( ) , new exception ( <string_literal> ) ) ; old <identifiersep> tag = local <identifiersep> map . get ( uid ) ; if ( old <identifiersep> tag != null ) { <LOG> if ( old <identifiersep> tag == tag ) { } else { <comment> <ect>
private < t extends uid <identifiersep> tag > void inner <identifiersep> unlock ( hash <identifiersep> map < long , t > overall <identifiersep> map , hash <identifiersep> map < long , t > local <identifiersep> map , t tag , long uid , boolean ssk , boolean insert , boolean offer <identifiersep> reply , boolean local , boolean can <identifiersep> fail ) { synchronized ( overall <identifiersep> map ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + overall <identifiersep> map . size ( ) , new exception ( <string_literal> ) ) ; if ( overall <identifiersep> map . get ( uid ) != tag ) { if ( can <identifiersep> fail ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + tag + <string_literal> + overall <identifiersep> map . get ( uid ) + <string_literal> + uid ) ; <LOG> } else { } } else overall <identifiersep> map . remove ( uid ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + overall <identifiersep> map . size ( ) ) ; if ( local ) { if ( local <identifiersep> map . get ( uid ) != tag ) { <ect>
count ++ ; transfers <identifiersep> out += out ; transfers <identifiersep> in += in ; if ( counter <identifiersep> source <identifiersep> restarted != null && tag . count <identifiersep> as <identifiersep> source <identifiersep> restarted ( ) ) { count <identifiersep> sr ++ ; transfers <identifiersep> out <identifiersep> sr += out ; <LOG> transfers <identifiersep> in <identifiersep> sr += in ; } } counter . total += count ; counter . expected <identifiersep> transfers <identifiersep> in += transfers <identifiersep> in ; counter . expected <identifiersep> transfers <identifiersep> out += transfers <identifiersep> out ; if ( counter <identifiersep> source <identifiersep> restarted != null ) { counter <identifiersep> source <identifiersep> restarted . total += count <identifiersep> sr ; <ect>
transfers <identifiersep> in += tag . expected <identifiersep> transfers <identifiersep> in ( ignore <identifiersep> local <identifiersep> vs <identifiersep> remote , transfers <identifiersep> per <identifiersep> insert , false ) ; count ++ ; } else if ( tag . currently <identifiersep> routing <identifiersep> to ( source ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + tag + <string_literal> + entry . get <identifiersep> key ( ) ) ; transfers <identifiersep> out += tag . expected <identifiersep> transfers <identifiersep> out ( ignore <identifiersep> local <identifiersep> vs <identifiersep> remote , transfers <identifiersep> per <identifiersep> insert , false ) ; transfers <identifiersep> in += tag . expected <identifiersep> transfers <identifiersep> in ( ignore <identifiersep> local <identifiersep> vs <identifiersep> remote , transfers <identifiersep> per <identifiersep> insert , false ) ; <LOG> count ++ ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( local ? <string_literal> : <string_literal> ) + <string_literal> + ( ssk ? <string_literal> : <string_literal> ) + <string_literal> + ( insert ? <string_literal> : <string_literal> ) + <string_literal> + ( offer ? <string_literal> : <string_literal> ) + <string_literal> + count + <string_literal> + map . size ( ) + <string_literal> + source ) ; counter . total += count ; counter . expected <identifiersep> transfers <identifiersep> in += transfers <identifiersep> in ; counter . expected <identifiersep> transfers <identifiersep> out += transfers <identifiersep> out ; } } } <comment> <ect>
notify <identifiersep> all ( ) ; } } @ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { persist <identifiersep> throttle ( ) ; <LOG> } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; } ps . queue <identifiersep> timed <identifiersep> job ( this , period ) ; } private void persist <identifiersep> throttle ( ) { <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { persist <identifiersep> throttle ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; system . err . println ( <string_literal> + t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; } ps . queue <identifiersep> timed <identifiersep> job ( this , period ) ; } private void persist <identifiersep> throttle ( ) { if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> ) ; } simple <identifiersep> field <identifiersep> set fs = persistable . persist <identifiersep> throttles <identifiersep> to <identifiersep> field <identifiersep> set ( ) ; <ect>
} catch ( io <identifiersep> exception e ) { try { throttle <identifiersep> fs = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( persist <identifiersep> temp , false , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e1 ) { <comment> <LOG> if ( persist <identifiersep> target . length ( ) > 0 || persist <identifiersep> temp . length ( ) > 0 ) } } return throttle <identifiersep> fs ; } public void start ( ) { synchronized ( this ) { if ( started ) { logger . error ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; <ect>
synchronized ( this ) { if ( started ) { logger . error ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; return ; } started = true ; } semi <identifiersep> ordered <identifiersep> shutdown <identifiersep> hook . get ( ) . add <identifiersep> early <identifiersep> job ( new thread ( ) { <LOG> public void run ( ) { persist <identifiersep> throttle ( ) ; } } ) ; run ( ) ; } } <ect>
addresses . add ( best ) ; } if ( ( second <identifiersep> best != null ) && ( second <identifiersep> best <identifiersep> popularity > 1 ) ) { if ( ! addresses . contains ( second <identifiersep> best ) ) { logger . normal ( this , <string_literal> + second <identifiersep> best + <string_literal> + second <identifiersep> best + ' ) ' ) ; addresses . add ( second <identifiersep> best ) ; } if ( best . get <identifiersep> address ( ) . equals ( second <identifiersep> best . get <identifiersep> address ( ) ) && best <identifiersep> popularity == 1 ) { <LOG> logger . error ( this , <string_literal> ) ; ip <identifiersep> detector . set <identifiersep> maybe <identifiersep> symmetric ( ) ; peer p = new peer ( best . get <identifiersep> freenet <identifiersep> address ( ) , crypto . port <identifiersep> number ) ; if ( ! addresses . contains ( p ) ) addresses . add ( p ) ; } } } } } } last <identifiersep> peers = addresses . to <identifiersep> array ( new peer [ addresses . size ( ) ] ) ; <ect>
public synchronized double get <identifiersep> location ( ) { return loc ; } <comment> public synchronized void set <identifiersep> location ( double l ) { <LOG> if ( ! location . is <identifiersep> valid ( l ) ) { return ; } this . loc = l ; time <identifiersep> loc <identifiersep> set = system . current <identifiersep> time <identifiersep> millis ( ) ; } public synchronized void update <identifiersep> location <identifiersep> change <identifiersep> session ( double new <identifiersep> loc ) { double old <identifiersep> loc = loc ; <ect>
unlock ( false ) ; } } else unlock ( false ) ; } else { continue ; } <comment> <LOG> } catch ( throwable t ) { } } } } <comment> private void start <identifiersep> swap <identifiersep> request ( ) { <ect>
try { commit = node . usm . wait <identifiersep> for ( filter , location <identifiersep> manager . this ) ; } catch ( disconnected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn + <string_literal> ) ; return ; } if ( commit == null ) { <LOG> <comment> <ect>
byte [ ] his <identifiersep> buf = ( ( short <identifiersep> buffer ) commit . get <identifiersep> object ( dmt . data ) ) . get <identifiersep> data ( ) ; if ( ( his <identifiersep> buf . length % <number_literal> != 0 ) || ( his <identifiersep> buf . length < <number_literal> ) ) { logger . error ( this , <string_literal> + uid ) ; return ; } <comment> <LOG> if ( ! java . util . arrays . equals ( rehash , his <identifiersep> hash ) ) { return ; } <comment> <ect>
long [ ] his <identifiersep> buf <identifiersep> long = fields . bytes <identifiersep> to <identifiersep> longs ( his <identifiersep> buf ) ; if ( his <identifiersep> buf <identifiersep> long . length < <number_literal> ) { logger . error ( this , <string_literal> + uid ) ; return ; } long his <identifiersep> random = his <identifiersep> buf <identifiersep> long [ 0 ] ; double his <identifiersep> loc = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ 1 ] ) ; <LOG> if ( ! location . is <identifiersep> valid ( his <identifiersep> loc ) ) { return ; } register <identifiersep> known <identifiersep> location ( his <identifiersep> loc ) ; double [ ] his <identifiersep> friend <identifiersep> locs = new double [ his <identifiersep> buf <identifiersep> long . length - <number_literal> ] ; for ( int i = 0 ; i < his <identifiersep> friend <identifiersep> locs . length ; i ++ ) { his <identifiersep> friend <identifiersep> locs [ i ] = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ i + <number_literal> ] ) ; <ect>
<comment> <LOG> } catch ( throwable t ) { } finally { unlock ( reached <identifiersep> end ) ; <comment> <ect>
reply = node . usm . wait <identifiersep> for ( filter , location <identifiersep> manager . this ) ; } catch ( disconnected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; } if ( reply == null ) { if ( pn . is <identifiersep> routable ( ) && ( system . current <identifiersep> time <identifiersep> millis ( ) - pn . time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) > timeout * <number_literal> ) ) { <LOG> <comment> <ect>
logger . error ( this , <string_literal> + uid ) ; } return ; } if ( reply . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> swap <identifiersep> rejected ) { logger . error ( this , <string_literal> ) ; return ; } byte [ ] his <identifiersep> buf = ( ( short <identifiersep> buffer ) reply . get <identifiersep> object ( dmt . data ) ) . get <identifiersep> data ( ) ; <LOG> if ( ( his <identifiersep> buf . length % <number_literal> != 0 ) || ( his <identifiersep> buf . length < <number_literal> ) ) { return ; } <comment> <ect>
<comment> public boolean handle <identifiersep> swap <identifiersep> reply ( message m , peer <identifiersep> node source ) { final long uid = m . get <identifiersep> long ( dmt . uid ) ; recently <identifiersep> forwarded <identifiersep> item item = recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds . get ( uid ) ; <LOG> if ( item == null ) { return false ; } if ( item . request <identifiersep> sender == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + source + <string_literal> + uid ) ; return false ; } if ( item . routed <identifiersep> to == null ) { <ect>
final long uid = m . get <identifiersep> long ( dmt . uid ) ; recently <identifiersep> forwarded <identifiersep> item item = recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds . get ( uid ) ; if ( item == null ) return false ; if ( item . request <identifiersep> sender == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return false ; } <LOG> if ( item . routed <identifiersep> to == null ) { return false ; } if ( source != item . routed <identifiersep> to ) { logger . error ( this , <string_literal> + uid + <string_literal> + source + <string_literal> + item . routed <identifiersep> to + <string_literal> + item . request <identifiersep> sender ) ; return true ; <ect>
private void spy <identifiersep> on <identifiersep> locations ( message m , boolean ignore <identifiersep> if <identifiersep> old , boolean swapping <identifiersep> with <identifiersep> me , double my <identifiersep> loc ) { long [ ] uids = null ; message uids <identifiersep> message = m . get <identifiersep> sub <identifiersep> message ( dmt . fnp <identifiersep> swap <identifiersep> node <identifiersep> ui <identifiersep> ds ) ; if ( uids <identifiersep> message != null ) { uids = fields . bytes <identifiersep> to <identifiersep> longs ( ( ( short <identifiersep> buffer ) uids <identifiersep> message . get <identifiersep> object ( dmt . node <identifiersep> uids ) ) . get <identifiersep> data ( ) ) ; } byte [ ] data = ( ( short <identifiersep> buffer ) m . get <identifiersep> object ( dmt . data ) ) . get <identifiersep> data ( ) ; <LOG> if ( data . length < <number_literal> || data . length % <number_literal> != 0 ) { return ; } double [ ] locations = fields . bytes <identifiersep> to <identifiersep> doubles ( data , <number_literal> , data . length - <number_literal> ) ; double his <identifiersep> loc = locations [ 0 ] ; if ( ! location . is <identifiersep> valid ( his <identifiersep> loc ) ) { logger . error ( this , <string_literal> + his <identifiersep> loc , new exception ( <string_literal> ) ) ; <ect>
list < recently <identifiersep> forwarded <identifiersep> item > v = new array <identifiersep> list < recently <identifiersep> forwarded <identifiersep> item > ( ) ; synchronized ( recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds ) { set < map . entry < long , recently <identifiersep> forwarded <identifiersep> item > > entry <identifiersep> set = recently <identifiersep> forwarded <identifiersep> i <identifiersep> ds . entry <identifiersep> set ( ) ; for ( map . entry < long , recently <identifiersep> forwarded <identifiersep> item > entry : entry <identifiersep> set ) { long l = entry . get <identifiersep> key ( ) ; recently <identifiersep> forwarded <identifiersep> item item = entry . get <identifiersep> value ( ) ; <LOG> if ( item == null ) { continue ; } if ( item . routed <identifiersep> to != pn ) continue ; if ( item . successfully <identifiersep> forwarded ) { v . add ( item ) ; } } <comment> <ect>
public void received <identifiersep> bytes ( int x ) { node . node <identifiersep> stats . swapping <identifiersep> received <identifiersep> bytes ( x ) ; } @ override public void sent <identifiersep> bytes ( int x ) { node . node <identifiersep> stats . swapping <identifiersep> sent <identifiersep> bytes ( x ) ; } @ override <LOG> public void sent <identifiersep> payload ( int x ) { } } <ect>
private boolean received <identifiersep> notice ( boolean success , boolean timeout , boolean kill ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + success + ( timeout ? <string_literal> : <string_literal> ) + <string_literal> + this ) ; boolean no <identifiersep> unlock <identifiersep> peer = false ; boolean got <identifiersep> fatal <identifiersep> timeout = false ; synchronized ( background <identifiersep> transfers ) { if ( finished <identifiersep> waiting ) { <LOG> if ( ! ( killed || kill ) ) return false ; } if ( killed ) { <comment> <ect>
<comment> <LOG> } else { } } @ override public boolean should <identifiersep> timeout ( ) { <comment> <ect>
if ( recv <identifiersep> failed ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } else { try { if ( prb . all <identifiersep> received ( ) ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + chk <identifiersep> insert <identifiersep> sender . this ) ; } @ override public void acknowledged ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + chk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override <LOG> public void disconnected ( ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void fatal <identifiersep> error ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + chk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; <ect>
} catch ( not <identifiersep> connected <identifiersep> exception e ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } } @ override public boolean should <identifiersep> timeout ( ) { return false ; } @ override <LOG> public void on <identifiersep> timeout ( ) { next . fatal <identifiersep> timeout ( tag , false ) ; } @ override public void on <identifiersep> disconnect ( peer <identifiersep> context ctx ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override <ect>
next . send <identifiersep> sync ( data <identifiersep> insert , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + next + <string_literal> + uid ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( this <identifiersep> tag , false ) ; route <identifiersep> requests ( ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <comment> <ect>
return ; } if ( fail <identifiersep> if <identifiersep> receive <identifiersep> failed ( tag , waiting <identifiersep> for ) ) { transfer . on <identifiersep> completed ( ) ; return ; } if ( msg == null ) { <comment> <LOG> <comment> <ect>
break ; } <comment> <LOG> if ( msg . get <identifiersep> spec ( ) != dmt . fnp <identifiersep> insert <identifiersep> reply ) { transfer . on <identifiersep> completed ( ) ; finish ( internal <identifiersep> error , next ) ; return ; } else { transfer . on <identifiersep> completed ( ) ; <ect>
<comment> public void on <identifiersep> sent ( int length ) { <comment> <LOG> } catch ( throwable t ) { } } } public short get <identifiersep> priority ( ) { return priority ; } @ override public string to <identifiersep> string ( ) { return super . to <identifiersep> string ( ) + <string_literal> + formatted + <string_literal> + msg ; <ect>
logger . error ( this , <string_literal> + t + <string_literal> + cbi + <string_literal> + this , t ) ; } } } } public void on <identifiersep> failed ( ) { if ( cb != null ) { for ( async <identifiersep> message <identifiersep> callback cbi : cb ) { try { cbi . fatal <identifiersep> error ( ) ; <LOG> } catch ( throwable t ) { } } } } public synchronized long get <identifiersep> id ( ) { if ( has <identifiersep> cached <identifiersep> id ) return cached <identifiersep> id ; cached <identifiersep> id = generate <identifiersep> id ( ) ; has <identifiersep> cached <identifiersep> id = true ; return cached <identifiersep> id ; <ect>
<comment> public void on <identifiersep> failed ( key key , peer <identifiersep> node routed <identifiersep> to , short htl , long rf <identifiersep> timeout , long ft <identifiersep> timeout ) { <LOG> if ( ft <identifiersep> timeout < 0 || ft <identifiersep> timeout > reject <identifiersep> time ) { ft <identifiersep> timeout = math . max ( math . min ( reject <identifiersep> time , ft <identifiersep> timeout ) , 0 ) ; } if ( rf <identifiersep> timeout < 0 || rf <identifiersep> timeout > recently <identifiersep> failed <identifiersep> time ) { if ( rf <identifiersep> timeout > 0 ) logger . error ( this , <string_literal> + rf <identifiersep> timeout , new exception ( <string_literal> ) ) ; rf <identifiersep> timeout = math . max ( math . min ( recently <identifiersep> failed <identifiersep> time , rf <identifiersep> timeout ) , 0 ) ; <ect>
@ override public long exclude ( random <identifiersep> grab <identifiersep> array <identifiersep> item item , client <identifiersep> context context , long now ) { if ( sched . is <identifiersep> running <identifiersep> or <identifiersep> queued <identifiersep> persistent <identifiersep> request ( ( sendable <identifiersep> request ) item ) ) { logger . normal ( this , <string_literal> + item , new exception ( <string_literal> ) ) ; return long . max <identifiersep> value ; } if ( is <identifiersep> insert ) return - 1 ; <LOG> if ( ! ( item instanceof base <identifiersep> sendable <identifiersep> get ) ) { return - 1 ; } base <identifiersep> sendable <identifiersep> get get = ( base <identifiersep> sendable <identifiersep> get ) item ; return get . get <identifiersep> wakeup <identifiersep> time ( context , now ) ; } } <ect>
continue ; } } if ( u == null ) throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> no <identifiersep> available <identifiersep> udp <identifiersep> ports , <string_literal> ) ; } else { try { u = new udp <identifiersep> socket <identifiersep> handler ( port , bindto . get <identifiersep> address ( ) , node , startup <identifiersep> time , get <identifiersep> title ( port ) , node . collector ) ; <LOG> } catch ( exception e ) { system . err . println ( e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> impossible <identifiersep> usm <identifiersep> port , <string_literal> + port + <string_literal> ) ; } } socket = u ; logger . normal ( this , <string_literal> + bindto + ' : ' + port ) ; <ect>
anon <identifiersep> setup <identifiersep> cipher . initialize ( identity <identifiersep> hash ) ; identity <identifiersep> hash <identifiersep> hash = sha256 . digest ( identity <identifiersep> hash ) ; try { simple <identifiersep> field <identifiersep> set ecdsa <identifiersep> sfs = fs . subset ( <string_literal> ) ; if ( ecdsa <identifiersep> sfs != null ) ecdsa <identifiersep> p256 = new ecdsa ( ecdsa <identifiersep> sfs . subset ( ecdsa . curves . p256 . name ( ) ) , curves . p256 ) ; <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { throw new io <identifiersep> exception ( e . to <identifiersep> string ( ) ) ; } if ( ecdsa <identifiersep> p256 == null ) { <comment> <ect>
byte [ ] sig = ecdsa <identifiersep> p256 . sign ( ref ) ; if ( log <identifiersep> minor && ! ecdsa . verify ( curves . p256 , get <identifiersep> ecdsap256pubkey ( ) , sig , ref ) ) throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> exception <identifiersep> to <identifiersep> debug , my <identifiersep> signed <identifiersep> reference ) ; return base64 . encode ( sig ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { <comment> <LOG> logger . error ( this , <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> crappy <identifiersep> jvm , <string_literal> ) ; } } private byte [ ] my <identifiersep> compressed <identifiersep> ref ( boolean setup , boolean heavy <identifiersep> setup , boolean for <identifiersep> ark ) { simple <identifiersep> field <identifiersep> set fs = export <identifiersep> public <identifiersep> field <identifiersep> set ( setup , heavy <identifiersep> setup , for <identifiersep> ark ) ; byte <identifiersep> array <identifiersep> output <identifiersep> stream baos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; <ect>
if ( pn instanceof darknet <identifiersep> peer <identifiersep> node ) { if ( ! ( peer <identifiersep> node instanceof darknet <identifiersep> peer <identifiersep> node ) ) { <comment> <LOG> continue ; } system . out . println ( <string_literal> + ( ( darknet <identifiersep> peer <identifiersep> node ) pn ) . get <identifiersep> name ( ) + <string_literal> + ( ( darknet <identifiersep> peer <identifiersep> node ) peer <identifiersep> node ) . get <identifiersep> name ( ) + <string_literal> + address + <string_literal> ) ; } node . peers . disconnect <identifiersep> and <identifiersep> remove ( pn , true , true , pn . is <identifiersep> opennet ( ) ) ; } } } <comment> <ect>
return super . to <identifiersep> string ( ) + <string_literal> + uid ; } @ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { real <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { tag . handler <identifiersep> threw ( t ) ; } finally { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; tag . unlock <identifiersep> handler ( ) ; } } private void real <identifiersep> run ( ) { <ect>
msg = dmt . create <identifiersep> fnp <identifiersep> rejected <identifiersep> overload ( uid , true , true , real <identifiersep> time <identifiersep> flag ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { return ; } <comment> <ect>
msg = dmt . create <identifiersep> fnp <identifiersep> insert <identifiersep> reply ( uid ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . minor ( this , <string_literal> ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { return ; } can <identifiersep> commit = true ; finish ( status ) ; return ; } <comment> <ect>
<comment> <LOG> if ( source . is <identifiersep> connected ( ) && ( start <identifiersep> time > ( source . time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) + node . handshake <identifiersep> timeout * <number_literal> ) ) ) message too <identifiersep> slow = dmt . create <identifiersep> fnp <identifiersep> rejected <identifiersep> timeout ( uid ) ; source . send <identifiersep> async ( too <identifiersep> slow , null , this ) ; message m = dmt . create <identifiersep> fnp <identifiersep> insert <identifiersep> transfers <identifiersep> completed ( uid , true ) ; source . send <identifiersep> async ( m , null , this ) ; prb = new partially <identifiersep> received <identifiersep> block ( node . packets <identifiersep> in <identifiersep> block , node . packet <identifiersep> size ) ; <ect>
if ( routing <identifiersep> took <identifiersep> too <identifiersep> long ) { tag . timed <identifiersep> out <identifiersep> to <identifiersep> handler <identifiersep> but <identifiersep> continued ( ) ; sent <identifiersep> completion <identifiersep> was <identifiersep> set = true ; try { source . send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> insert <identifiersep> transfers <identifiersep> completed ( uid , true ) , null , this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <LOG> <comment> <ect>
synchronized ( this ) { if ( ( prb == null ) || prb . is <identifiersep> aborted ( ) ) return null ; try { if ( ! can <identifiersep> commit ) return null ; if ( ! prb . all <identifiersep> received ( ) ) return null ; block = new chk <identifiersep> block ( prb . get <identifiersep> block ( ) , headers , key ) ; <LOG> } catch ( chk <identifiersep> verify <identifiersep> exception e ) { to <identifiersep> send = dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> verify <identifiersep> failed ) ; } catch ( aborted <identifiersep> exception e ) { logger . error ( this , <string_literal> + e ) ; <comment> <ect>
message msg = dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> receive <identifiersep> failed ) ; try { source . send <identifiersep> sync ( msg , chk <identifiersep> insert <identifiersep> handler . this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception ex ) { <comment> <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception ex ) { } if ( e . get <identifiersep> reason ( ) == retrieval <identifiersep> exception . sender <identifiersep> disconnected ) logger . normal ( this , <string_literal> + e + <string_literal> + chk <identifiersep> insert <identifiersep> handler . this , e ) ; else <comment> <ect>
for ( int i = 0 ; i < requestor <identifiersep> nodes . length ; i ++ ) { weak <identifiersep> reference < ? extends peer <identifiersep> node <identifiersep> unlocked > ref = requestor <identifiersep> nodes [ i ] ; if ( ref == null ) continue ; peer <identifiersep> node <identifiersep> unlocked pn = ref . get ( ) ; if ( pn == null ) continue ; if ( pn . get <identifiersep> boot <identifiersep> id ( ) != requestor <identifiersep> boot <identifiersep> i <identifiersep> ds [ i ] ) continue ; <LOG> if ( ! set . add ( pn ) ) { } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + requested <identifiersep> nodes . length + <string_literal> + key ) ; for ( int i = 0 ; i < requested <identifiersep> nodes . length ; i ++ ) { weak <identifiersep> reference < ? extends peer <identifiersep> node <identifiersep> unlocked > ref = requested <identifiersep> nodes [ i ] ; if ( ref == null ) continue ; peer <identifiersep> node <identifiersep> unlocked pn = ref . get ( ) ; <ect>
old <identifiersep> ssk = null ; migrate <identifiersep> old <identifiersep> store ( old <identifiersep> chk <identifiersep> cache , chk <identifiersep> datacache , false ) ; old <identifiersep> chk <identifiersep> cache = null ; migrate <identifiersep> old <identifiersep> store ( old <identifiersep> pk <identifiersep> cache , pub <identifiersep> key <identifiersep> datacache , false ) ; old <identifiersep> pk <identifiersep> cache = null ; migrate <identifiersep> old <identifiersep> store ( old <identifiersep> ssk <identifiersep> cache , ssk <identifiersep> datacache , false ) ; <LOG> old <identifiersep> ssk <identifiersep> cache = null ; } } } volatile chk <identifiersep> store old <identifiersep> chk ; volatile pubkey <identifiersep> store old <identifiersep> pk ; volatile ssk <identifiersep> store old <identifiersep> ssk ; volatile chk <identifiersep> store old <identifiersep> chk <identifiersep> cache ; volatile pubkey <identifiersep> store old <identifiersep> pk <identifiersep> cache ; <ect>
ram <identifiersep> freenet <identifiersep> store < t > ramstore = ( ram <identifiersep> freenet <identifiersep> store < t > ) store ; try { ramstore . migrate <identifiersep> to ( new <identifiersep> store , can <identifiersep> read <identifiersep> client <identifiersep> cache ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } ramstore . clear ( ) ; <LOG> } else if ( store instanceof salted <identifiersep> hash <identifiersep> freenet <identifiersep> store ) { } } public < t extends storable <identifiersep> block > void close <identifiersep> old <identifiersep> store ( store <identifiersep> callback < t > old ) { freenet <identifiersep> store < t > store = old . get <identifiersep> store ( ) ; if ( store instanceof salted <identifiersep> hash <identifiersep> freenet <identifiersep> store ) { salted <identifiersep> hash <identifiersep> freenet <identifiersep> store < t > saltstore = ( salted <identifiersep> hash <identifiersep> freenet <identifiersep> store < t > ) store ; saltstore . close ( ) ; <ect>
} catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e1 ) { set <identifiersep> client <identifiersep> cache <identifiersep> awaiting <identifiersep> password ( ) ; throw new invalid <identifiersep> config <identifiersep> value <identifiersep> exception ( <string_literal> ) ; } try { init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( suffix , true , key ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
for ( string udp <identifiersep> addr : udp ) { <comment> <LOG> logger . error ( this , <string_literal> + udp <identifiersep> addr ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { throw ( io <identifiersep> exception ) new io <identifiersep> exception ( ) . init <identifiersep> cause ( e ) ; } if ( p . get <identifiersep> port ( ) == get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) { <comment> <ect>
toadlets . start ( ) ; } catch ( io <identifiersep> exception e4 ) { logger . error ( this , <string_literal> + e4 , e4 ) ; system . err . println ( <string_literal> + e4 ) ; e4 . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> could <identifiersep> not <identifiersep> start <identifiersep> fproxy , <string_literal> + e4 ) ; <LOG> } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e4 ) { e4 . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> could <identifiersep> not <identifiersep> start <identifiersep> fproxy , <string_literal> + e4 ) ; } final native <identifiersep> thread entropy <identifiersep> gathering <identifiersep> thread = new native <identifiersep> thread ( new runnable ( ) { long t <identifiersep> last <identifiersep> added = - 1 ; private void recurse ( file f ) { <ect>
try { <comment> <LOG> system . out . println ( <string_literal> ) ; if ( file . separator <identifiersep> char == ' / ' ) { if ( new file ( <string_literal> ) . exists ( ) ) system . out . println ( <string_literal> ) ; else system . out . println ( <string_literal> ) ; <ect>
return ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; if ( file . separator <identifiersep> char == ' / ' ) { if ( new file ( <string_literal> ) . exists ( ) ) system . out . println ( <string_literal> ) ; <LOG> else } extend <identifiersep> timeouts ( ) ; for ( file root : file . list <identifiersep> roots ( ) ) { if ( is <identifiersep> prng <identifiersep> ready ) return ; recurse ( root ) ; <ect>
if ( security <identifiersep> levels . get <identifiersep> physical <identifiersep> threat <identifiersep> level ( ) == physical <identifiersep> threat <identifiersep> level . high ) { system . err . println ( <string_literal> ) ; security <identifiersep> levels . reset <identifiersep> physical <identifiersep> threat <identifiersep> level ( physical <identifiersep> threat <identifiersep> level . normal ) ; } break ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { break ; <LOG> } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e ) { master <identifiersep> keys <identifiersep> file . delete ( ) ; } catch ( io <identifiersep> exception e ) { break ; } } <comment> <ect>
node <identifiersep> config . register ( <string_literal> , traffic <identifiersep> class . get <identifiersep> default ( ) . name ( ) , sort <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , new traffic <identifiersep> class <identifiersep> callback ( ) ) ; string traffic <identifiersep> class <identifiersep> value = node <identifiersep> config . get <identifiersep> string ( <string_literal> ) ; try { traffic <identifiersep> class = traffic <identifiersep> class . from <identifiersep> name <identifiersep> or <identifiersep> value ( traffic <identifiersep> class <identifiersep> value ) ; <LOG> } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { traffic <identifiersep> class = traffic <identifiersep> class . get <identifiersep> default ( ) ; } <comment> <ect>
read <identifiersep> node <identifiersep> file ( node <identifiersep> file . get <identifiersep> path ( ) ) ; } catch ( io <identifiersep> exception e ) { try { system . err . println ( <string_literal> ) ; read <identifiersep> node <identifiersep> file ( node <identifiersep> file <identifiersep> backup . get <identifiersep> path ( ) ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> if ( node <identifiersep> file . exists ( ) || node <identifiersep> file <identifiersep> backup . exists ( ) ) { system . err . println ( e1 . to <identifiersep> string ( ) ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; system . err . println ( e . to <identifiersep> string ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( e1 . to <identifiersep> string ( ) ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; system . err . println ( e . to <identifiersep> string ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } else { } init <identifiersep> node <identifiersep> file <identifiersep> settings ( ) ; } } <comment> <ect>
public void set ( integer input <identifiersep> max <identifiersep> opennet <identifiersep> peers ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception { if ( input <identifiersep> max <identifiersep> opennet <identifiersep> peers < 0 ) throw new invalid <identifiersep> config <identifiersep> value <identifiersep> exception ( l10n ( <string_literal> ) ) ; if ( input <identifiersep> max <identifiersep> opennet <identifiersep> peers > opennet <identifiersep> manager . max <identifiersep> peers <identifiersep> for <identifiersep> scaling ) throw new invalid <identifiersep> config <identifiersep> value <identifiersep> exception ( l10n ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( opennet <identifiersep> manager . max <identifiersep> peers <identifiersep> for <identifiersep> scaling ) ) ) ; max <identifiersep> opennet <identifiersep> peers = input <identifiersep> max <identifiersep> opennet <identifiersep> peers ; } } , false ) ; max <identifiersep> opennet <identifiersep> peers = opennet <identifiersep> config . get <identifiersep> int ( <string_literal> ) ; <LOG> if ( max <identifiersep> opennet <identifiersep> peers > opennet <identifiersep> manager . max <identifiersep> peers <identifiersep> for <identifiersep> scaling ) { max <identifiersep> opennet <identifiersep> peers = opennet <identifiersep> manager . max <identifiersep> peers <identifiersep> for <identifiersep> scaling ; } opennet <identifiersep> crypto <identifiersep> config = new node <identifiersep> crypto <identifiersep> config ( opennet <identifiersep> config , <number_literal> <comment> , true , security <identifiersep> levels ) ; if ( opennet <identifiersep> enabled ) { opennet = new opennet <identifiersep> manager ( this , opennet <identifiersep> crypto <identifiersep> config , system . current <identifiersep> time <identifiersep> millis ( ) , is <identifiersep> allowed <identifiersep> to <identifiersep> connect <identifiersep> to <identifiersep> seednodes ) ; <comment> <ect>
chk <identifiersep> datacache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; pub <identifiersep> key <identifiersep> datastore . set <identifiersep> max <identifiersep> keys ( max <identifiersep> store <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; pub <identifiersep> key <identifiersep> datacache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> datastore . set <identifiersep> max <identifiersep> keys ( max <identifiersep> store <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> datacache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; } catch ( io <identifiersep> exception e ) { <LOG> <comment> <ect>
try { kill <identifiersep> master <identifiersep> keys <identifiersep> file ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . disable <identifiersep> write ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . wait <identifiersep> for <identifiersep> not <identifiersep> writing ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . delete <identifiersep> all <identifiersep> files ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> master <identifiersep> keys <identifiersep> file . delete ( ) ; system . err . println ( node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> , <string_literal> , master <identifiersep> keys <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) ) ) ; client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( true , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , user <identifiersep> alert . critical <identifiersep> error ) ) ; } } if ( old <identifiersep> level == physical <identifiersep> threat <identifiersep> level . maximum && new <identifiersep> level != physical <identifiersep> threat <identifiersep> level . high ) { <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + master <identifiersep> keys <identifiersep> file + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } } ) ; if ( security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level == physical <identifiersep> threat <identifiersep> level . maximum ) { try { <ect>
throw new node <identifiersep> need <identifiersep> restart <identifiersep> exception ( <string_literal> ) ; } } , true ) ; caching <identifiersep> freenet <identifiersep> store <identifiersep> period = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size > 0 && caching <identifiersep> freenet <identifiersep> store <identifiersep> period > 0 ) { caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker = new caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size , caching <identifiersep> freenet <identifiersep> store <identifiersep> period , ticker ) ; } boolean should <identifiersep> write <identifiersep> config = false ; <LOG> if ( store <identifiersep> type . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; store <identifiersep> type = <string_literal> ; should <identifiersep> write <identifiersep> config = true ; delete <identifiersep> old <identifiersep> bdb <identifiersep> index <identifiersep> store <identifiersep> files ( ) ; <ect>
caching <identifiersep> freenet <identifiersep> store <identifiersep> period = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size > 0 && caching <identifiersep> freenet <identifiersep> store <identifiersep> period > 0 ) { caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker = new caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size , caching <identifiersep> freenet <identifiersep> store <identifiersep> period , ticker ) ; } boolean should <identifiersep> write <identifiersep> config = false ; if ( store <identifiersep> type . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; store <identifiersep> type = <string_literal> ; should <identifiersep> write <identifiersep> config = true ; delete <identifiersep> old <identifiersep> bdb <identifiersep> index <identifiersep> store <identifiersep> files ( ) ; } if ( store <identifiersep> type . equals ( <string_literal> ) ) { init <identifiersep> ramfs ( ) ; <ect>
try { chk <identifiersep> clientcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> client <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; pub <identifiersep> key <identifiersep> clientcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> client <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> clientcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> client <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> logger . error ( this , <string_literal> + e + <string_literal> , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } , true ) ; max <identifiersep> total <identifiersep> client <identifiersep> cache <identifiersep> size = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( max <identifiersep> total <identifiersep> client <identifiersep> cache <identifiersep> size < min <identifiersep> client <identifiersep> cache <identifiersep> size ) { throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> invalid <identifiersep> store <identifiersep> size , <string_literal> ) ; <ect>
started <identifiersep> client <identifiersep> cache = true ; } if ( ! started <identifiersep> client <identifiersep> cache ) init <identifiersep> ram <identifiersep> client <identifiersep> cache <identifiersep> fs ( ) ; if ( ! client <identifiersep> core . loaded <identifiersep> database ( ) && database <identifiersep> key != null ) { try { late <identifiersep> setup <identifiersep> database ( database <identifiersep> key ) ; <LOG> } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e2 ) { e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( io <identifiersep> exception e2 ) { <ect>
} catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e2 ) { system . err . println ( <string_literal> + e2 ) ; e2 . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } catch ( io <identifiersep> exception e2 ) { e2 . print <identifiersep> stack <identifiersep> trace ( ) ; } } node <identifiersep> config . register ( <string_literal> , true , sort <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , new boolean <identifiersep> callback ( ) { @ override public boolean get ( ) { return use <identifiersep> slashdot <identifiersep> cache ; <ect>
try { chk <identifiersep> slashdotcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; pub <identifiersep> key <identifiersep> slashdotcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; ssk <identifiersep> slashdotcache . set <identifiersep> max <identifiersep> keys ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> keys , store <identifiersep> force <identifiersep> big <identifiersep> shrinks ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> logger . error ( this , <string_literal> + e + <string_literal> , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } , true ) ; max <identifiersep> slashdot <identifiersep> cache <identifiersep> size = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; if ( max <identifiersep> slashdot <identifiersep> cache <identifiersep> size < min <identifiersep> slashdot <identifiersep> cache <identifiersep> size ) { throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> invalid <identifiersep> store <identifiersep> size , <string_literal> ) ; <ect>
return dir ; } protected program <identifiersep> directory setup <identifiersep> program <identifiersep> dir ( sub <identifiersep> config install <identifiersep> config , string cfg <identifiersep> key , string default <identifiersep> value , string shortdesc , string longdesc , sub <identifiersep> config old <identifiersep> config ) throws node <identifiersep> init <identifiersep> exception { return setup <identifiersep> program <identifiersep> dir ( install <identifiersep> config , cfg <identifiersep> key , default <identifiersep> value , shortdesc , longdesc , null , old <identifiersep> config ) ; } public void late <identifiersep> setup <identifiersep> database ( database <identifiersep> key database <identifiersep> key ) throws master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception , master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception , io <identifiersep> exception { <LOG> if ( client <identifiersep> core . loaded <identifiersep> database ( ) ) return ; try { if ( ! client <identifiersep> core . late <identifiersep> init <identifiersep> database ( database <identifiersep> key ) ) fail <identifiersep> late <identifiersep> init <identifiersep> database ( ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { fail <identifiersep> late <identifiersep> init <identifiersep> database ( ) ; <ect>
chk <identifiersep> data <identifiersep> fs . start ( ticker , false ) | chk <identifiersep> cache <identifiersep> fs . start ( ticker , false ) | pubkey <identifiersep> data <identifiersep> fs . start ( ticker , false ) | pubkey <identifiersep> cache <identifiersep> fs . start ( ticker , false ) | ssk <identifiersep> data <identifiersep> fs . start ( ticker , false ) | ssk <identifiersep> cache <identifiersep> fs . start ( ticker , false ) ; <LOG> if ( delay ) { init <identifiersep> ramfs ( ) ; final runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( false ) ; this . get <identifiersep> ticker ( ) . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { <ect>
chk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; chk <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> cache <identifiersep> fs . start ( ticker , true ) ; <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } node . this . chk <identifiersep> datastore = chk <identifiersep> datastore ; node . this . chk <identifiersep> datacache = chk <identifiersep> datacache ; <ect>
node . this . chk <identifiersep> datacache = chk <identifiersep> datacache ; node . this . pub <identifiersep> key <identifiersep> datastore = pub <identifiersep> key <identifiersep> datastore ; node . this . pub <identifiersep> key <identifiersep> datacache = pub <identifiersep> key <identifiersep> datacache ; get <identifiersep> pub <identifiersep> key . set <identifiersep> data <identifiersep> store ( pub <identifiersep> key <identifiersep> datastore , pub <identifiersep> key <identifiersep> datacache ) ; node . this . ssk <identifiersep> datastore = ssk <identifiersep> datastore ; node . this . ssk <identifiersep> datacache = ssk <identifiersep> datacache ; <LOG> finish <identifiersep> init <identifiersep> salt <identifiersep> hash <identifiersep> fs ( suffix , client <identifiersep> core ) ; migrate . run ( ) ; } } , <string_literal> , 0 , true , false ) ; <comment> <ect>
final ssk <identifiersep> store ssk <identifiersep> clientcache = new ssk <identifiersep> store ( get <identifiersep> pub <identifiersep> key ) ; final freenet <identifiersep> store < ssk <identifiersep> block > ssk <identifiersep> data <identifiersep> fs = make <identifiersep> clientcache ( <string_literal> , true , ssk <identifiersep> clientcache , dont <identifiersep> resize <identifiersep> on <identifiersep> start , client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; boolean delay = chk <identifiersep> data <identifiersep> fs . start ( ticker , false ) | pubkey <identifiersep> data <identifiersep> fs . start ( ticker , false ) | ssk <identifiersep> data <identifiersep> fs . start ( ticker , false ) ; <LOG> if ( delay ) { init <identifiersep> ram <identifiersep> client <identifiersep> cache <identifiersep> fs ( ) ; final runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( true ) ; get <identifiersep> ticker ( ) . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { <ect>
public void run ( ) { system . err . println ( <string_literal> ) ; try { chk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; pubkey <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; ssk <identifiersep> data <identifiersep> fs . start ( ticker , true ) ; <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } node . this . chk <identifiersep> clientcache = chk <identifiersep> clientcache ; node . this . pub <identifiersep> key <identifiersep> clientcache = pub <identifiersep> key <identifiersep> clientcache ; <ect>
system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } node . this . chk <identifiersep> clientcache = chk <identifiersep> clientcache ; node . this . pub <identifiersep> key <identifiersep> clientcache = pub <identifiersep> key <identifiersep> clientcache ; get <identifiersep> pub <identifiersep> key . set <identifiersep> local <identifiersep> data <identifiersep> store ( pub <identifiersep> key <identifiersep> clientcache ) ; <LOG> node . this . ssk <identifiersep> clientcache = ssk <identifiersep> clientcache ; migrate . run ( ) ; } } , <string_literal> , 0 , true , false ) ; } else { node . this . chk <identifiersep> clientcache = chk <identifiersep> clientcache ; node . this . pub <identifiersep> key <identifiersep> clientcache = pub <identifiersep> key <identifiersep> clientcache ; <ect>
return store ; } private < t extends storable <identifiersep> block > freenet <identifiersep> store < t > make <identifiersep> store ( string type , boolean is <identifiersep> store , store <identifiersep> callback < t > cb , boolean dont <identifiersep> resize <identifiersep> on <identifiersep> start , byte [ ] client <identifiersep> cache <identifiersep> master <identifiersep> key ) throws io <identifiersep> exception { string store = is <identifiersep> store ? <string_literal> : <string_literal> ; long max <identifiersep> keys = is <identifiersep> store ? max <identifiersep> store <identifiersep> keys : max <identifiersep> cache <identifiersep> keys ; return make <identifiersep> store ( type , store , max <identifiersep> keys , cb , dont <identifiersep> resize <identifiersep> on <identifiersep> start , client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; } private < t extends storable <identifiersep> block > freenet <identifiersep> store < t > make <identifiersep> store ( string type , string store , long max <identifiersep> keys , store <identifiersep> callback < t > cb , boolean late <identifiersep> start , byte [ ] client <identifiersep> cache <identifiersep> master <identifiersep> key ) throws io <identifiersep> exception { <LOG> logger . normal ( this , <string_literal> + type + <string_literal> + store ) ; salted <identifiersep> hash <identifiersep> freenet <identifiersep> store < t > fs = salted <identifiersep> hash <identifiersep> freenet <identifiersep> store . < t > construct ( get <identifiersep> store <identifiersep> dir ( ) , type + <string_literal> + store , cb , random , max <identifiersep> keys , store <identifiersep> use <identifiersep> slot <identifiersep> filters , shutdown <identifiersep> hook , store <identifiersep> preallocate , store <identifiersep> salt <identifiersep> hash <identifiersep> resize <identifiersep> on <identifiersep> start && ! late <identifiersep> start , late <identifiersep> start ? ticker : null , client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; cb . set <identifiersep> store ( fs ) ; if ( caching <identifiersep> freenet <identifiersep> store <identifiersep> max <identifiersep> size > 0 ) return new caching <identifiersep> freenet <identifiersep> store < t > ( cb , fs , caching <identifiersep> freenet <identifiersep> store <identifiersep> tracker ) ; <ect>
ticker . start ( ) ; schedule <identifiersep> version <identifiersep> transition ( ) ; usm . start ( ticker ) ; if ( is <identifiersep> using <identifiersep> wrapper ( ) ) { logger . normal ( this , <string_literal> + node <identifiersep> starter ) ; system . out . println ( <string_literal> + node <identifiersep> starter ) ; <LOG> } else { system . out . println ( <string_literal> ) ; } logger . normal ( this , <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; logger . normal ( this , <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; system . out . println ( <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; <ect>
if ( is <identifiersep> using <identifiersep> wrapper ( ) ) { logger . normal ( this , <string_literal> + node <identifiersep> starter ) ; system . out . println ( <string_literal> + node <identifiersep> starter ) ; } else { logger . error ( this , <string_literal> ) ; system . out . println ( <string_literal> ) ; } <LOG> logger . normal ( this , <string_literal> + version . build <identifiersep> number ( ) + <string_literal> + version . cvs <identifiersep> revision ( ) ) ; logger . normal ( this , <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; system . out . println ( <string_literal> + darknet <identifiersep> crypto . get <identifiersep> bind <identifiersep> to ( ) + ' : ' + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; <comment> <ect>
<comment> <LOG> catch ( throwable t ) { } client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( true , l10n ( <string_literal> ) , l10n ( <string_literal> ) , l10n ( <string_literal> ) , user <identifiersep> alert . warning ) ) ; } } if ( ! is <identifiersep> using <identifiersep> wrapper ( ) && ! skip <identifiersep> wrapper <identifiersep> warning ) { client <identifiersep> core . alerts . register ( new simple <identifiersep> user <identifiersep> alert ( true , l10n ( <string_literal> ) , l10n ( <string_literal> ) , l10n ( <string_literal> ) , user <identifiersep> alert . warning ) ) ; } <comment> <ect>
if ( can <identifiersep> read <identifiersep> client <identifiersep> cache ) { try { ssk <identifiersep> block block = ssk <identifiersep> clientcache . fetch ( key , dont <identifiersep> promote || ! can <identifiersep> write <identifiersep> client <identifiersep> cache , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , false , meta ) ; if ( block != null ) { node <identifiersep> stats . avg <identifiersep> client <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> client <identifiersep> cache <identifiersep> ssk <identifiersep> success ) <LOG> node <identifiersep> stats . furthest <identifiersep> client <identifiersep> cache <identifiersep> ssk <identifiersep> success = dist ; return block ; } } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } } if ( for <identifiersep> ulpr || use <identifiersep> slashdot <identifiersep> cache || can <identifiersep> read <identifiersep> client <identifiersep> cache ) { try { <ect>
if ( for <identifiersep> ulpr || use <identifiersep> slashdot <identifiersep> cache || can <identifiersep> read <identifiersep> client <identifiersep> cache ) { try { ssk <identifiersep> block block = ssk <identifiersep> slashdotcache . fetch ( key , dont <identifiersep> promote , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , false , meta ) ; if ( block != null ) { node <identifiersep> stats . avg <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success ) <LOG> node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> ssk <identifiersep> success = dist ; return block ; } } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } } boolean ignore <identifiersep> old <identifiersep> blocks = ! write <identifiersep> local <identifiersep> to <identifiersep> datastore ; if ( can <identifiersep> read <identifiersep> client <identifiersep> cache ) ignore <identifiersep> old <identifiersep> blocks = false ; <ect>
ssk <identifiersep> store store = old <identifiersep> ssk ; if ( store != null ) block = store . fetch ( key , dont <identifiersep> promote || ! can <identifiersep> write <identifiersep> datastore , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , ignore <identifiersep> old <identifiersep> blocks , meta ) ; } if ( block != null ) { node <identifiersep> stats . avg <identifiersep> store <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> store <identifiersep> ssk <identifiersep> success ) <LOG> node <identifiersep> stats . furthest <identifiersep> store <identifiersep> ssk <identifiersep> success = dist ; return block ; } block = ssk <identifiersep> datacache . fetch ( key , dont <identifiersep> promote || ! can <identifiersep> write <identifiersep> datastore , can <identifiersep> read <identifiersep> client <identifiersep> cache , for <identifiersep> ulpr , ignore <identifiersep> old <identifiersep> blocks , meta ) ; if ( block == null ) { ssk <identifiersep> store store = old <identifiersep> ssk <identifiersep> cache ; if ( store != null ) <ect>
if ( block != null ) { node <identifiersep> stats . avg <identifiersep> cache <identifiersep> ssk <identifiersep> success . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> cache <identifiersep> ssk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> cache <identifiersep> ssk <identifiersep> success = dist ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key + <string_literal> ) ; } return block ; <LOG> } catch ( io <identifiersep> exception e ) { return null ; } } public chk <identifiersep> block fetch ( node <identifiersep> chk key , boolean dont <identifiersep> promote , boolean can <identifiersep> read <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore , boolean for <identifiersep> ulpr , block <identifiersep> metadata meta ) { double loc = key . to <identifiersep> normalized <identifiersep> double ( ) ; double dist = location . distance ( lm . get <identifiersep> location ( ) , loc ) ; if ( can <identifiersep> read <identifiersep> client <identifiersep> cache ) { <ect>
chk <identifiersep> block block = chk <identifiersep> slashdotcache . fetch ( key , dont <identifiersep> promote , false , meta ) ; if ( block != null ) { node <identifiersep> stats . avg <identifiersep> slashdot <identifiersep> cache <identifiersep> chk <identifiersep> sucess . report ( loc ) ; if ( dist > node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> chk <identifiersep> success ) node <identifiersep> stats . furthest <identifiersep> slashdot <identifiersep> cache <identifiersep> chk <identifiersep> success = dist ; return block ; } <LOG> } catch ( io <identifiersep> exception e ) { } } boolean ignore <identifiersep> old <identifiersep> blocks = ! write <identifiersep> local <identifiersep> to <identifiersep> datastore ; if ( can <identifiersep> read <identifiersep> client <identifiersep> cache ) ignore <identifiersep> old <identifiersep> blocks = false ; if ( log <identifiersep> minor ) dump <identifiersep> store <identifiersep> hits ( ) ; try { node <identifiersep> stats . avg <identifiersep> request <identifiersep> location . report ( loc ) ; <ect>
chk <identifiersep> datastore . put ( block , ! can <identifiersep> write <identifiersep> datastore ) ; node <identifiersep> stats . avg <identifiersep> store <identifiersep> chk <identifiersep> location . report ( loc ) ; } chk <identifiersep> datacache . put ( block , ! can <identifiersep> write <identifiersep> datastore ) ; node <identifiersep> stats . avg <identifiersep> cache <identifiersep> chk <identifiersep> location . report ( loc ) ; } if ( can <identifiersep> write <identifiersep> datastore || for <identifiersep> ulpr || use <identifiersep> slashdot <identifiersep> cache ) failure <identifiersep> table . on <identifiersep> found ( block ) ; <LOG> } catch ( io <identifiersep> exception e ) { } catch ( throwable t ) { system . err . println ( t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; logger . error ( this , <string_literal> + t + <string_literal> , t ) ; } if ( client <identifiersep> core != null && client <identifiersep> core . request <identifiersep> starters != null ) { <ect>
@ override public void handle <identifiersep> message ( byte [ ] data , boolean from <identifiersep> darknet , peer <identifiersep> node src , int type ) { logger . normal ( this , <string_literal> + src . get <identifiersep> peer ( ) ) ; simple <identifiersep> field <identifiersep> set fs = null ; try { fs = new simple <identifiersep> field <identifiersep> set ( new string ( data , <string_literal> ) , false , true , false ) ; <LOG> } catch ( io <identifiersep> exception e ) { return ; } if ( fs . get ( <string_literal> ) != null ) { fs . remove <identifiersep> value ( <string_literal> ) ; } try { src . process <identifiersep> diff <identifiersep> noderef ( fs ) ; <ect>
logger . error ( this , <string_literal> , e ) ; return ; } } } ; private node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener fproxy <identifiersep> n2nm <identifiersep> listener = new node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener ( ) { @ override public void handle <identifiersep> message ( byte [ ] data , boolean from <identifiersep> darknet , peer <identifiersep> node src , int type ) { <LOG> if ( ! from <identifiersep> darknet ) { return ; } darknet <identifiersep> peer <identifiersep> node dark <identifiersep> source = ( darknet <identifiersep> peer <identifiersep> node ) src ; logger . normal ( this , <string_literal> + dark <identifiersep> source . get <identifiersep> peer ( ) + <string_literal> ) ; simple <identifiersep> field <identifiersep> set fs = null ; try { <ect>
logger . error ( this , <string_literal> , e ) ; return ; } fs . put <identifiersep> overwrite ( <string_literal> , integer . to <identifiersep> string ( type ) ) ; fs . put <identifiersep> overwrite ( <string_literal> , long . to <identifiersep> string ( system . current <identifiersep> time <identifiersep> millis ( ) ) ) ; fs . put <identifiersep> overwrite ( <string_literal> , <string_literal> ) ; int file <identifiersep> number = dark <identifiersep> source . write <identifiersep> new <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( fs , extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> n2ntm ) ; <LOG> if ( file <identifiersep> number == - 1 ) { } <comment> <ect>
} else if ( type == node . n2n <identifiersep> text <identifiersep> message <identifiersep> type <identifiersep> file <identifiersep> offer <identifiersep> rejected ) { source . handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer <identifiersep> rejected ( fs , file <identifiersep> number ) ; } else if ( type == node . n2n <identifiersep> text <identifiersep> message <identifiersep> type <identifiersep> bookmark ) { source . handle <identifiersep> fproxy <identifiersep> bookmark <identifiersep> feed ( fs , file <identifiersep> number ) ; } else if ( type == node . n2n <identifiersep> text <identifiersep> message <identifiersep> type <identifiersep> download ) { source . handle <identifiersep> fproxy <identifiersep> download <identifiersep> feed ( fs , file <identifiersep> number ) ; <LOG> } else { } } public string get <identifiersep> my <identifiersep> name ( ) { return my <identifiersep> name ; } public message <identifiersep> core get <identifiersep> usm ( ) { return usm ; } public location <identifiersep> manager get <identifiersep> location <identifiersep> manager ( ) { <ect>
late <identifiersep> setup <identifiersep> database ( keys . create <identifiersep> database <identifiersep> key ( secure <identifiersep> random ) ) ; } private void activate <identifiersep> passworded <identifiersep> client <identifiersep> cache ( master <identifiersep> keys keys ) { synchronized ( this ) { if ( client <identifiersep> cache <identifiersep> type . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; return ; } <LOG> if ( ! client <identifiersep> cache <identifiersep> type . equals ( <string_literal> ) ) { return ; } } runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( true ) ; string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; try { init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( suffix , true , keys . client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; <ect>
return ; } } runnable migrate = new migrate <identifiersep> old <identifiersep> store <identifiersep> data ( true ) ; string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; try { init <identifiersep> salt <identifiersep> hash <identifiersep> client <identifiersep> cache <identifiersep> fs ( suffix , true , keys . client <identifiersep> cache <identifiersep> master <identifiersep> key ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } synchronized ( this ) { client <identifiersep> cache <identifiersep> awaiting <identifiersep> password = false ; } executor . execute ( migrate , <string_literal> ) ; <ect>
public void panic ( ) { has <identifiersep> panicked = true ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . panic ( ) ; client <identifiersep> core . client <identifiersep> layer <identifiersep> persister . kill <identifiersep> and <identifiersep> wait <identifiersep> for <identifiersep> not <identifiersep> running ( ) ; try { master <identifiersep> keys . kill <identifiersep> master <identifiersep> keys ( get <identifiersep> master <identifiersep> password <identifiersep> file ( ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + get <identifiersep> master <identifiersep> password <identifiersep> file ( ) + <string_literal> ) ; } <comment> <ect>
public mersenne <identifiersep> twister create <identifiersep> random ( ) { byte [ ] buf = new byte [ <number_literal> ] ; random . next <identifiersep> bytes ( buf ) ; return new mersenne <identifiersep> twister ( buf ) ; } public boolean enable <identifiersep> new <identifiersep> load <identifiersep> management ( boolean real <identifiersep> time <identifiersep> flag ) { node <identifiersep> stats stats = this . node <identifiersep> stats ; <LOG> if ( stats == null ) { return false ; } return stats . enable <identifiersep> new <identifiersep> load <identifiersep> management ( real <identifiersep> time <identifiersep> flag ) ; } <comment> public boolean enable <identifiersep> routed <identifiersep> ping ( ) { return enable <identifiersep> routed <identifiersep> ping ; <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { int cur <identifiersep> port = port ; string temp <identifiersep> bind <identifiersep> to = this . bind <identifiersep> to ; try { network <identifiersep> interface . set <identifiersep> so <identifiersep> timeout ( <number_literal> ) ; <LOG> } catch ( socket <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; e1 . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } while ( is <identifiersep> enabled ) { <comment> <ect>
continue ; <comment> <LOG> } catch ( socket <identifiersep> exception e ) { } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } } try { network <identifiersep> interface . close ( ) ; } catch ( io <identifiersep> exception e ) { <ect>
} catch ( socket <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } } try { network <identifiersep> interface . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } } public void set <identifiersep> port ( int val ) { port = val ; } } <ect>
list . add <identifiersep> last ( item ) ; it . remove ( ) ; moved ++ ; if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; } else if ( ! round <identifiersep> robin <identifiersep> between <identifiersep> ui <identifiersep> ds ) break ; } <LOG> if ( log <identifiersep> debug && moved > 0 ) if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; } private void move <identifiersep> from <identifiersep> empty <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> forward ( items list ) { <comment> <ect>
private void check <identifiersep> order ( ) { if ( non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id != null ) { long prev = - 1 ; items prev <identifiersep> items = null ; for ( items items : non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id ) { long this <identifiersep> time = items . time <identifiersep> last <identifiersep> sent ; <LOG> if ( this <identifiersep> time < prev ) prev = this <identifiersep> time ; prev <identifiersep> items = items ; } } if ( items <identifiersep> non <identifiersep> urgent != null ) { long prev = - 1 ; message <identifiersep> item prev <identifiersep> item = null ; <ect>
long id = item . get <identifiersep> id ( ) ; items tracker = items <identifiersep> by <identifiersep> id . get ( id ) ; if ( tracker != null ) { tracker . time <identifiersep> last <identifiersep> sent = now ; doubly <identifiersep> linked <identifiersep> list < ? super items > parent = tracker . get <identifiersep> parent ( ) ; <comment> <LOG> if ( tracker . items . is <identifiersep> empty ( ) ) { if ( empty <identifiersep> items <identifiersep> with <identifiersep> id == null ) empty <identifiersep> items <identifiersep> with <identifiersep> id = new doubly <identifiersep> linked <identifiersep> list <identifiersep> impl < items > ( ) ; if ( parent == null ) { logger . error ( this , <string_literal> ) ; } else if ( parent == empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <ect>
empty <identifiersep> items <identifiersep> with <identifiersep> id = new doubly <identifiersep> linked <identifiersep> list <identifiersep> impl < items > ( ) ; if ( parent == null ) { logger . error ( this , <string_literal> ) ; } else if ( parent == empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <comment> <LOG> } else if ( parent == non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id ) { non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( tracker ) ; } else assert ( false ) ; add <identifiersep> to <identifiersep> empty <identifiersep> backward ( tracker ) ; } else { <ect>
assert ( false ) ; add <identifiersep> to <identifiersep> empty <identifiersep> backward ( tracker ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + tracker + <string_literal> ) ; if ( non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id == null ) non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id = new doubly <identifiersep> linked <identifiersep> list <identifiersep> impl < items > ( ) ; <LOG> if ( parent == null ) { } else if ( parent == non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id ) { <comment> <ect>
return null ; } lists += non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . size ( ) ; items list = non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . head ( ) ; for ( int i = 0 ; i < lists && list != null ; i ++ ) { if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; if ( list . items . is <identifiersep> empty ( ) ) { <LOG> <comment> <ect>
if ( list . time <identifiersep> last <identifiersep> sent == - 1 || now - list . time <identifiersep> last <identifiersep> sent > forget <identifiersep> after ) { <comment> <LOG> else if ( old != list ) empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( list ) ; removed ++ ; } else { if ( log <identifiersep> debug && removed > 0 ) logger . debug ( this , <string_literal> + removed + <string_literal> ) ; <ect>
this . node = node ; my <identifiersep> thread = new native <identifiersep> thread ( this , <string_literal> + node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) , native <identifiersep> thread . max <identifiersep> priority , false ) ; my <identifiersep> thread . set <identifiersep> daemon ( true ) ; local <identifiersep> random = node . create <identifiersep> random ( ) ; } void start ( node <identifiersep> stats stats ) { this . stats = stats ; <LOG> logger . normal ( this , <string_literal> ) ; my <identifiersep> thread . start ( ) ; } private void schedule <identifiersep> periodic <identifiersep> job ( ) { node . ticker . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { <ect>
<comment> while ( true ) { last <identifiersep> received <identifiersep> packet <identifiersep> from <identifiersep> any <identifiersep> node = last <identifiersep> reported <identifiersep> no <identifiersep> packets ; try { real <identifiersep> run ( ) ; } catch ( throwable t ) { <LOG> logger . error ( this , <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } } } <comment> <ect>
to <identifiersep> send <identifiersep> ack <identifiersep> only = null ; } if ( to <identifiersep> send <identifiersep> packet != null ) { try { if ( to <identifiersep> send <identifiersep> packet . maybe <identifiersep> send <identifiersep> packet ( now , false ) ) { <comment> <LOG> } catch ( blocked <identifiersep> too <identifiersep> long <identifiersep> exception e ) { to <identifiersep> send <identifiersep> packet . force <identifiersep> disconnect ( ) ; } } else if ( to <identifiersep> send <identifiersep> ack <identifiersep> only != null ) { try { if ( to <identifiersep> send <identifiersep> ack <identifiersep> only . maybe <identifiersep> send <identifiersep> packet ( now , true ) ) { <comment> <ect>
<comment> if ( to <identifiersep> send <identifiersep> handshake != null ) { <comment> <LOG> if ( ( after <identifiersep> handshake <identifiersep> time - before <identifiersep> handshake <identifiersep> time ) > seconds . to <identifiersep> millis ( <number_literal> ) ) } <comment> <ect>
continue ; } if ( pn . should <identifiersep> send <identifiersep> handshake ( ) ) { <comment> <LOG> if ( ( after <identifiersep> handshake <identifiersep> time - before <identifiersep> handshake <identifiersep> time ) > seconds . to <identifiersep> millis ( <number_literal> ) ) } } } long old <identifiersep> now = now ; <comment> <ect>
if ( ( now - old <identifiersep> now ) > seconds . to <identifiersep> millis ( <number_literal> ) ) logger . error ( this , <string_literal> + ( now - old <identifiersep> now ) + <string_literal> ) ; long sleep <identifiersep> time = next <identifiersep> action <identifiersep> time - now ; <comment> <LOG> if ( now - last <identifiersep> received <identifiersep> packet <identifiersep> from <identifiersep> any <identifiersep> node > node . alarm <identifiersep> time ) { last <identifiersep> reported <identifiersep> no <identifiersep> packets = now ; } if ( sleep <identifiersep> time > 0 ) { <comment> <ect>
late <identifiersep> jobs = new array <identifiersep> list < thread > ( ) ; } public synchronized void add <identifiersep> early <identifiersep> job ( thread r ) { early <identifiersep> jobs . add ( r ) ; } public synchronized void add <identifiersep> late <identifiersep> job ( thread r ) { late <identifiersep> jobs . add ( r ) ; } @ override <LOG> public void run ( ) { <comment> <ect>
system . out . println ( <string_literal> ) ; return integer . value <identifiersep> of ( - 1 ) ; } string built <identifiersep> with <identifiersep> message = <string_literal> + ext <identifiersep> version . build <identifiersep> number + <string_literal> + ext <identifiersep> version . cvs <identifiersep> revision + <string_literal> + ext <identifiersep> build <identifiersep> number + <string_literal> + ext <identifiersep> revision <identifiersep> number ; logger . normal ( this , built <identifiersep> with <identifiersep> message ) ; system . out . println ( built <identifiersep> with <identifiersep> message ) ; file config <identifiersep> filename ; <LOG> if ( args . length == 0 ) { config <identifiersep> filename = new file ( <string_literal> ) ; } else config <identifiersep> filename = new file ( args [ 0 ] ) ; <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return integer . value <identifiersep> of ( - 1 ) ; } <comment> <ect>
<comment> <LOG> } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return integer . value <identifiersep> of ( - <number_literal> ) ; } system . out . println ( <string_literal> ) ; executor . start ( ) ; <comment> <ect>
while ( true ) { try { thread . sleep ( minutes . to <identifiersep> millis ( <number_literal> ) ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> try { } catch ( throwable t1 ) { <comment> <ect>
sub <identifiersep> config ssl <identifiersep> config = cfg . create <identifiersep> sub <identifiersep> config ( <string_literal> ) ; ssl . init ( ssl <identifiersep> config ) ; try { node = new node ( cfg , null , null , log <identifiersep> config <identifiersep> handler , this , executor ) ; node . start ( false ) ; system . out . println ( <string_literal> ) ; <LOG> } catch ( node <identifiersep> init <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( e . exit <identifiersep> code ) ; } return null ; } <comment> <ect>
throws invalid <identifiersep> threshold <identifiersep> exception { synchronized ( node <identifiersep> starter . class ) { if ( is <identifiersep> started ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; is <identifiersep> started = true ; is <identifiersep> testing <identifiersep> vm = true ; } if ( ( ! base <identifiersep> directory . mkdir ( ) ) && ( ( ! base <identifiersep> directory . exists ( ) ) <LOG> || ( ! base <identifiersep> directory . is <identifiersep> directory ( ) ) ) ) { system . exit ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> test <identifiersep> error ) ; } logger . setup <identifiersep> stdout <identifiersep> logging ( log <identifiersep> threshold , details ) ; <comment> <ect>
public static node create <identifiersep> test <identifiersep> node ( test <identifiersep> node <identifiersep> parameters params ) throws node <identifiersep> init <identifiersep> exception { synchronized ( node <identifiersep> starter . class ) { if ( ( ! is <identifiersep> started ) || ( ! is <identifiersep> testing <identifiersep> vm ) ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } file base <identifiersep> dir = params . base <identifiersep> directory ; file port <identifiersep> dir = new file ( base <identifiersep> dir , integer . to <identifiersep> string ( params . port ) ) ; <LOG> if ( ( ! port <identifiersep> dir . mkdir ( ) ) && ( ( ! port <identifiersep> dir . exists ( ) ) || ( ! port <identifiersep> dir . is <identifiersep> directory ( ) ) ) ) { system . exit ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> test <identifiersep> error ) ; } <comment> <ect>
+ e ; e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> bad <identifiersep> dir , msg ) ; } <comment> <LOG> if ( old <identifiersep> blob <identifiersep> file . exists ( ) ) { if ( persistent <identifiersep> temp <identifiersep> bucket <identifiersep> factory . is <identifiersep> encrypting ( ) ) { try { file <identifiersep> util . secure <identifiersep> delete ( old <identifiersep> blob <identifiersep> file ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> <ect>
shutdown <identifiersep> hook . add <identifiersep> late <identifiersep> job ( new native <identifiersep> thread ( <string_literal> , native <identifiersep> thread . high <identifiersep> priority , true ) { @ override public void real <identifiersep> run ( ) { if ( node <identifiersep> client <identifiersep> core . this . node . has <identifiersep> panicked ( ) ) <LOG> return ; client <identifiersep> layer <identifiersep> persister . wait <identifiersep> for <identifiersep> idle <identifiersep> and <identifiersep> checkpoint ( ) ; system . out . println ( <string_literal> ) ; } } ) ; archive <identifiersep> manager = <ect>
<comment> @ override public void on <identifiersep> request <identifiersep> sender <identifiersep> finished ( int status , boolean from <identifiersep> offered <identifiersep> key , request <identifiersep> sender rs ) { tag . unlock <identifiersep> handler ( ) ; if ( rs . aborted <identifiersep> downstream <identifiersep> transfers ( ) ) status = request <identifiersep> sender . transfer <identifiersep> failed ; <LOG> if ( status == request <identifiersep> sender . not <identifiersep> finished ) { listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ) ; return ; } boolean rejected <identifiersep> overload ; synchronized ( this ) { rejected <identifiersep> overload = this . rejected <identifiersep> overload ; <ect>
case request <identifiersep> sender . timed <identifiersep> out : listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . rejected <identifiersep> overload ) ) ; return ; case request <identifiersep> sender . internal <identifiersep> error : listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ) ; return ; <LOG> default : listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ) ; return ; } } } @ override public void on <identifiersep> abort <identifiersep> downstream <identifiersep> transfers ( int reason , string desc ) { <comment> <ect>
<comment> <LOG> } catch ( error e ) { listener . on <identifiersep> not <identifiersep> started ( true ) ; } } public client <identifiersep> key <identifiersep> block real <identifiersep> get <identifiersep> key ( client <identifiersep> key key , boolean local <identifiersep> only , boolean ignore <identifiersep> store , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> get <identifiersep> exception { if ( key instanceof client <identifiersep> chk ) return real <identifiersep> get <identifiersep> chk ( ( client <identifiersep> chk ) key , local <identifiersep> only , ignore <identifiersep> store , can <identifiersep> write <identifiersep> client <identifiersep> cache , real <identifiersep> time <identifiersep> flag ) ; else if ( key instanceof client <identifiersep> ssk ) <ect>
try { object o = node . make <identifiersep> request <identifiersep> sender ( key . get <identifiersep> node <identifiersep> chk ( ) , node . max <identifiersep> htl ( ) , uid , tag , null , local <identifiersep> only , ignore <identifiersep> store , false , true , can <identifiersep> write <identifiersep> client <identifiersep> cache , real <identifiersep> time <identifiersep> flag ) ; if ( o instanceof chk <identifiersep> block ) try { tag . set <identifiersep> served <identifiersep> from <identifiersep> datastore ( ) ; return new client <identifiersep> chk <identifiersep> block ( ( chk <identifiersep> block ) o , key ) ; <LOG> } catch ( chk <identifiersep> verify <identifiersep> exception e ) { throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . decode <identifiersep> failed ) ; } if ( o == null ) throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found <identifiersep> in <identifiersep> store ) ; rs = ( request <identifiersep> sender ) o ; boolean rejected <identifiersep> overload = false ; <ect>
if ( status == request <identifiersep> sender . success ) try { return new client <identifiersep> chk <identifiersep> block ( rs . get <identifiersep> prb ( ) . get <identifiersep> block ( ) , rs . get <identifiersep> headers ( ) , key , true ) ; } catch ( chk <identifiersep> verify <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . decode <identifiersep> failed ) ; <LOG> } catch ( aborted <identifiersep> exception e ) { throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } else { switch ( status ) { case request <identifiersep> sender . not <identifiersep> finished : logger . error ( this , <string_literal> + rs ) ; <ect>
throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . verify <identifiersep> failed ) ; case request <identifiersep> sender . generated <identifiersep> rejected <identifiersep> overload : case request <identifiersep> sender . timed <identifiersep> out : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . rejected <identifiersep> overload ) ; case request <identifiersep> sender . internal <identifiersep> error : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; <LOG> default : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } } } } finally { tag . unlock <identifiersep> handler ( ) ; } } client <identifiersep> ssk <identifiersep> block real <identifiersep> get <identifiersep> ssk ( client <identifiersep> ssk key , boolean local <identifiersep> only , boolean ignore <identifiersep> store , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> get <identifiersep> exception { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
if ( o instanceof ssk <identifiersep> block ) try { tag . set <identifiersep> served <identifiersep> from <identifiersep> datastore ( ) ; ssk <identifiersep> block block = ( ssk <identifiersep> block ) o ; key . set <identifiersep> public <identifiersep> key ( block . get <identifiersep> pub <identifiersep> key ( ) ) ; return client <identifiersep> ssk <identifiersep> block . construct ( block , key ) ; <LOG> } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . decode <identifiersep> failed ) ; } if ( o == null ) throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found <identifiersep> in <identifiersep> store ) ; rs = ( request <identifiersep> sender ) o ; boolean rejected <identifiersep> overload = false ; <ect>
return client <identifiersep> ssk <identifiersep> block . construct ( block , key ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . decode <identifiersep> failed ) ; } else switch ( rs . get <identifiersep> status ( ) ) { <LOG> case request <identifiersep> sender . not <identifiersep> finished : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; case request <identifiersep> sender . data <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . data <identifiersep> not <identifiersep> found ) ; case request <identifiersep> sender . recently <identifiersep> failed : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . recently <identifiersep> failed ) ; <ect>
case request <identifiersep> sender . get <identifiersep> offer <identifiersep> verify <identifiersep> failure : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . verify <identifiersep> failed ) ; case request <identifiersep> sender . generated <identifiersep> rejected <identifiersep> overload : case request <identifiersep> sender . timed <identifiersep> out : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . rejected <identifiersep> overload ) ; case request <identifiersep> sender . internal <identifiersep> error : <LOG> default : throw new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) ; } } } finally { tag . unlock <identifiersep> handler ( ) ; } } <comment> <ect>
msg += <string_literal> ; if ( is . get <identifiersep> status ( ) != chk <identifiersep> insert <identifiersep> sender . route <identifiersep> not <identifiersep> found ) logger . error ( this , msg ) ; else logger . normal ( this , msg ) ; switch ( is . get <identifiersep> status ( ) ) { <LOG> case chk <identifiersep> insert <identifiersep> sender . not <identifiersep> finished : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; case chk <identifiersep> insert <identifiersep> sender . generated <identifiersep> rejected <identifiersep> overload : case chk <identifiersep> insert <identifiersep> sender . timed <identifiersep> out : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . rejected <identifiersep> overload ) ; case chk <identifiersep> insert <identifiersep> sender . route <identifiersep> not <identifiersep> found : <ect>
} finally { tag . unlock <identifiersep> handler ( ) ; } } public void real <identifiersep> put <identifiersep> ssk ( ssk <identifiersep> block block , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean fork <identifiersep> on <identifiersep> cacheable , boolean prefer <identifiersep> insert , boolean ignore <identifiersep> low <identifiersep> backoff , boolean real <identifiersep> time <identifiersep> flag ) throws low <identifiersep> level <identifiersep> put <identifiersep> exception { ssk <identifiersep> insert <identifiersep> sender is ; long uid = make <identifiersep> uid ( ) ; insert <identifiersep> tag tag = new insert <identifiersep> tag ( true , insert <identifiersep> tag . start . local , null , real <identifiersep> time <identifiersep> flag , uid , node ) ; <LOG> if ( ! tracker . lock <identifiersep> uid ( uid , true , true , false , true , real <identifiersep> time <identifiersep> flag , tag ) ) { throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; } tag . set <identifiersep> accepted ( ) ; try { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <comment> <ect>
key <identifiersep> block collided = node . fetch ( key , true , can <identifiersep> write <identifiersep> client <identifiersep> cache , false , false , null ) ; if ( collided == null ) { logger . error ( this , <string_literal> ) ; <comment> <LOG> } catch ( key <identifiersep> collision <identifiersep> exception e2 ) { throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error , <string_literal> , e ) ; } } failed . set <identifiersep> collided <identifiersep> block ( collided ) ; throw failed ; } if ( status == ssk <identifiersep> insert <identifiersep> sender . success ) { logger . normal ( this , <string_literal> + block ) ; <ect>
case ssk <identifiersep> insert <identifiersep> sender . route <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> not <identifiersep> found ) ; case ssk <identifiersep> insert <identifiersep> sender . route <identifiersep> really <identifiersep> not <identifiersep> found : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> really <identifiersep> not <identifiersep> found ) ; case ssk <identifiersep> insert <identifiersep> sender . internal <identifiersep> error : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; <LOG> default : throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error ) ; } } } finally { tag . unlock <identifiersep> handler ( ) ; } } <comment> @ deprecated <ect>
if ( file <identifiersep> util . is <identifiersep> parent ( dir , filename ) ) return true ; } return false ; } } public synchronized boolean allow <identifiersep> upload <identifiersep> from ( file filename ) { if ( upload <identifiersep> allowed <identifiersep> everywhere ) return true ; for ( file dir : upload <identifiersep> allowed <identifiersep> dirs ) { if ( dir == null ) { <LOG> <comment> <ect>
connected <identifiersep> timeout <identifiersep> no <identifiersep> packets <identifiersep> received , <comment> <LOG> if ( last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time < = 0 && time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) > 0 ) else if ( time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) < = 0 ) system . err . println ( this . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> ) ; else system . err . println ( this . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> ) ; super . on <identifiersep> remove ( ) ; <ect>
public void on <identifiersep> remove ( ) { long last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time = last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time ( ) ; if ( last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time < = 0 && time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) > 0 ) system . err . println ( this . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> ) ; else if ( time <identifiersep> last <identifiersep> connection <identifiersep> completed ( ) < = 0 ) system . err . println ( this . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> ) ; <LOG> else super . on <identifiersep> remove ( ) ; } public fate get <identifiersep> fate ( ) { long last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time = last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time ( ) ; if ( is <identifiersep> connected ( ) ) { if ( last <identifiersep> received <identifiersep> data <identifiersep> packet <identifiersep> time < = 0 ) <ect>
return 0 ; } public synchronized void remove <identifiersep> status ( k peer <identifiersep> node <identifiersep> status , peer <identifiersep> node peer <identifiersep> node , boolean no <identifiersep> log ) { weak <identifiersep> hash <identifiersep> set < peer <identifiersep> node > status <identifiersep> set = statuses . get ( peer <identifiersep> node <identifiersep> status ) ; if ( status <identifiersep> set != null ) { if ( ! status <identifiersep> set . remove ( peer <identifiersep> node ) ) { <LOG> if ( ! no <identifiersep> log ) return ; } if ( status <identifiersep> set . is <identifiersep> empty ( ) ) statuses . remove ( peer <identifiersep> node <identifiersep> status ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + peer <identifiersep> node . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + peer <identifiersep> node <identifiersep> status + <string_literal> ) ; <ect>
<comment> if ( ( opennet <identifiersep> manager . max <identifiersep> peers <identifiersep> for <identifiersep> scaling < locs . length ) && ( source . is <identifiersep> opennet ( ) ) ) { if ( locs . length > opennet <identifiersep> manager . panic <identifiersep> max <identifiersep> peers ) { <LOG> <comment> <ect>
node . failure <identifiersep> table . on <identifiersep> offer ( key , source , authenticator ) ; return true ; } private boolean handle <identifiersep> get <identifiersep> offered <identifiersep> key ( message m , peer <identifiersep> node source ) { key key = ( key ) m . get <identifiersep> object ( dmt . key ) ; byte [ ] authenticator = ( ( short <identifiersep> buffer ) m . get <identifiersep> object ( dmt . offer <identifiersep> authenticator ) ) . get <identifiersep> data ( ) ; long uid = m . get <identifiersep> long ( dmt . uid ) ; <LOG> if ( ! hmac . verify <identifiersep> with <identifiersep> sha256 ( node . failure <identifiersep> table . offer <identifiersep> authenticator <identifiersep> key , key . get <identifiersep> full <identifiersep> key ( ) , authenticator ) ) { try { source . send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> get <identifiersep> offered <identifiersep> key <identifiersep> invalid ( uid , dmt . get <identifiersep> offered <identifiersep> key <identifiersep> rejected <identifiersep> bad <identifiersep> authenticator ) , null , node . failure <identifiersep> table . sender <identifiersep> counter ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
} catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> if ( htl < max <identifiersep> htl - 1 ) { htl = max <identifiersep> htl ; } } announcement <identifiersep> callback cb = null ; if ( log <identifiersep> minor ) { final string origin = source . to <identifiersep> string ( ) + <string_literal> + htl + <string_literal> ; <comment> <ect>
<comment> <LOG> <comment> <ect>
private boolean forward ( message m , long id , peer <identifiersep> node pn , short htl , double target , routed <identifiersep> context ctx , byte [ ] target <identifiersep> identity ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <comment> <LOG> if ( next != null && ! next . is <identifiersep> connected ( ) ) { next = null ; } if ( next == null ) next = node . peers . closer <identifiersep> peer ( pn , ctx . routed <identifiersep> to , target , true , node . is <identifiersep> advanced <identifiersep> mode <identifiersep> enabled ( ) , - 1 , null , null , htl , 0 , pn == null , false , false ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + next + <string_literal> + m ) ; <ect>
int dark <identifiersep> peers = node . peers . get <identifiersep> darknet <identifiersep> peers ( ) . length ; int open <identifiersep> peers = node . peers . get <identifiersep> opennet <identifiersep> peers ( ) . length ; int old <identifiersep> open <identifiersep> peers = om . count <identifiersep> old <identifiersep> opennet <identifiersep> peers ( ) ; if ( dark <identifiersep> peers + open <identifiersep> peers + old <identifiersep> open <identifiersep> peers == 0 ) { <comment> <LOG> <comment> <ect>
@ override public void run ( ) { synchronized ( announcer . this ) { started = true ; } try { maybe <identifiersep> send <identifiersep> announcement ( ) ; <LOG> } catch ( throwable t ) { } } } , min <identifiersep> added <identifiersep> seeds <identifiersep> interval ) ; } } private void register <identifiersep> event ( int event <identifiersep> status ) { node . client <identifiersep> core . alerts . register ( new announcement <identifiersep> user <identifiersep> event ( event <identifiersep> status ) ) ; } private void connect <identifiersep> some <identifiersep> seednodes ( ) { if ( ! node . is <identifiersep> opennet <identifiersep> enabled ( ) ) return ; <ect>
<comment> <LOG> } catch ( throwable t ) { } } } , announce <identifiersep> now ? 0 : min <identifiersep> added <identifiersep> seeds <identifiersep> interval ) ; } <comment> <ect>
} else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + seed ) ; } } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e ) { continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { <ect>
} catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + fs , e ) ; continue ; <LOG> } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { continue ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + count ) ; return count ; } public static list < simple <identifiersep> field <identifiersep> set > read <identifiersep> seednodes ( file file ) { list < simple <identifiersep> field <identifiersep> set > list = new array <identifiersep> list < simple <identifiersep> field <identifiersep> set > ( ) ; <ect>
return list ; } catch ( io <identifiersep> exception e ) { logger . error ( announcer . class , <string_literal> + file , e ) ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { return list ; } finally { closer . close ( fis ) ; } } protected void stop ( ) { <comment> <ect>
if ( killed <identifiersep> announcement <identifiersep> too <identifiersep> old ) return true ; } if ( node . peers . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> size ( peer <identifiersep> manager . peer <identifiersep> node <identifiersep> status <identifiersep> too <identifiersep> new , false ) > <number_literal> ) { synchronized ( this ) { if ( killed <identifiersep> announcement <identifiersep> too <identifiersep> old ) return true ; killed <identifiersep> announcement <identifiersep> too <identifiersep> old = true ; kill <identifiersep> announcement = true ; } <LOG> logger . error ( this , <string_literal> ) ; if ( node . client <identifiersep> core != null ) node . client <identifiersep> core . alerts . register ( announcement <identifiersep> disabled <identifiersep> alert ) ; } } if ( kill <identifiersep> announcement ) { node . executor . execute ( new runnable ( ) { @ override <ect>
return true ; } return ! has <identifiersep> non <identifiersep> local <identifiersep> addresses ; } protected boolean send <identifiersep> announcement ( final seed <identifiersep> server <identifiersep> peer <identifiersep> node seed ) { if ( ! node . is <identifiersep> opennet <identifiersep> enabled ( ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + seed + <string_literal> ) ; <LOG> return false ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + seed . user <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; announce <identifiersep> sender sender = new announce <identifiersep> sender ( node . get <identifiersep> location ( ) , om , node , new announcement <identifiersep> callback ( ) { private int total <identifiersep> added ; private int total <identifiersep> not <identifiersep> wanted ; <ect>
announce <identifiersep> now = true ; } } <comment> <LOG> if ( accepted <identifiersep> somewhere ) else system . out . println ( <string_literal> + seed . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + seed . get <identifiersep> version <identifiersep> number ( ) + <string_literal> ) ; if ( announce <identifiersep> now ) maybe <identifiersep> send <identifiersep> announcement ( ) ; } @ override <ect>
total <identifiersep> not <identifiersep> wanted ++ ; } logger . normal ( this , <string_literal> + seed . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + announcement <identifiersep> not <identifiersep> wanted <identifiersep> nodes + <string_literal> + total <identifiersep> not <identifiersep> wanted + <string_literal> ) ; } @ override public void node <identifiersep> not <identifiersep> added ( ) { logger . normal ( this , <string_literal> + seed . user <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; } @ override <LOG> public void relayed <identifiersep> noderef ( ) { } } , seed ) ; node . executor . execute ( sender , <string_literal> + seed ) ; return true ; } class announcement <identifiersep> user <identifiersep> event extends abstract <identifiersep> user <identifiersep> event { private final int status ; <ect>
if ( args . length > 0 ) ip <identifiersep> override = args [ 0 ] ; file dir = new file ( <string_literal> ) ; file <identifiersep> util . remove <identifiersep> all ( dir ) ; random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . error , <string_literal> , false ) ; file seednodes = new file ( <string_literal> ) ; <LOG> if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port ) ) ; inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; <ect>
+ <string_literal> + opennet <identifiersep> peers + <string_literal> + opennet <identifiersep> conns ) ; seconds ++ ; if ( opennet <identifiersep> conns >= target <identifiersep> peers ) { long time <identifiersep> taken = system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ; system . out . println ( <string_literal> + target <identifiersep> peers + <string_literal> + time <identifiersep> taken + <string_literal> + time <identifiersep> util . format <identifiersep> time ( time <identifiersep> taken ) + <string_literal> ) ; node . park ( ) ; <LOG> system . exit ( 0 ) ; } } node . park ( ) ; system . exit ( exit <identifiersep> failed <identifiersep> target ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
system . err . println ( <string_literal> + cycle <identifiersep> number + <string_literal> + i + <string_literal> + nodes [ i ] . get <identifiersep> location ( ) ) ; } int new <identifiersep> swaps = location <identifiersep> manager . swaps ; int total <identifiersep> started = location <identifiersep> manager . started <identifiersep> swaps ; int no <identifiersep> swaps = location <identifiersep> manager . no <identifiersep> swaps ; system . err . println ( <string_literal> + ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ; system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <LOG> <string_literal> + ( double ) no <identifiersep> swaps / ( double ) new <identifiersep> swaps + <string_literal> + ( ( total <identifiersep> started * <number_literal> ) - ( no <identifiersep> swaps + new <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; <ect>
int no <identifiersep> swaps = location <identifiersep> manager . no <identifiersep> swaps ; system . err . println ( <string_literal> + ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ; system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <string_literal> + ( double ) no <identifiersep> swaps / ( double ) new <identifiersep> swaps + <string_literal> + ( ( total <identifiersep> started * <number_literal> ) - ( no <identifiersep> swaps + new <identifiersep> swaps ) ) ) ; system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; <ect>
system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <string_literal> + ( double ) no <identifiersep> swaps / ( double ) new <identifiersep> swaps + <string_literal> + ( ( total <identifiersep> started * <number_literal> ) - ( no <identifiersep> swaps + new <identifiersep> swaps ) ) ) ; system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; double total <identifiersep> swap <identifiersep> time = 0 . 0 ; for ( int i = 0 ; i < nodes . length ; i ++ ) { <ect>
system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; double total <identifiersep> swap <identifiersep> time = 0 . 0 ; for ( int i = 0 ; i < nodes . length ; i ++ ) { total <identifiersep> swap <identifiersep> interval += nodes [ i ] . lm . get <identifiersep> send <identifiersep> swap <identifiersep> interval ( ) ; total <identifiersep> swap <identifiersep> time += nodes [ i ] . lm . get <identifiersep> average <identifiersep> swap <identifiersep> time ( ) ; <ect>
system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; double total <identifiersep> swap <identifiersep> interval = 0 . 0 ; double total <identifiersep> swap <identifiersep> time = 0 . 0 ; for ( int i = 0 ; i < nodes . length ; i ++ ) { total <identifiersep> swap <identifiersep> interval += nodes [ i ] . lm . get <identifiersep> send <identifiersep> swap <identifiersep> interval ( ) ; total <identifiersep> swap <identifiersep> time += nodes [ i ] . lm . get <identifiersep> average <identifiersep> swap <identifiersep> time ( ) ; } <LOG> system . err . println ( <string_literal> + ( total <identifiersep> swap <identifiersep> time / nodes . length ) ) ; wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; last <identifiersep> swaps = new <identifiersep> swaps ; <comment> <ect>
system . err . println ( <string_literal> + pings + <string_literal> + random <identifiersep> node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + random <identifiersep> node2 . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + ratio + <string_literal> + avg . current <identifiersep> value ( ) + <string_literal> + avg2 . current <identifiersep> value ( ) + ' ) ' ) ; } else { total <identifiersep> hops <identifiersep> taken += hops <identifiersep> taken ; successes ++ ; avg . report ( 1 . 0 ) ; avg2 . report ( 1 . 0 ) ; <LOG> double ratio = ( double ) successes / ( ( double ) ( failures + successes ) ) ; } } catch ( throwable t ) { logger . error ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + t , t ) ; } } system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; <ect>
successes ++ ; avg . report ( 1 . 0 ) ; avg2 . report ( 1 . 0 ) ; double ratio = ( double ) successes / ( ( double ) ( failures + successes ) ) ; system . err . println ( <string_literal> + pings + <string_literal> + hops <identifiersep> taken + ' ' + random <identifiersep> node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + random <identifiersep> node2 . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + ratio + <string_literal> + avg . current <identifiersep> value ( ) + <string_literal> + avg2 . current <identifiersep> value ( ) + ' ) ' ) ; } } catch ( throwable t ) { <LOG> logger . error ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + t , t ) ; } } if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; <ect>
} catch ( throwable t ) { logger . error ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + t , t ) ; } } system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; <LOG> system . err . println ( ) ; system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; <ect>
system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; if ( pings > <number_literal> && avg . current <identifiersep> value ( ) > accuracy && ( ( double ) successes / ( ( double ) ( failures + successes ) ) > accuracy ) ) { system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; <LOG> system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; <ect>
system . err . println ( ) ; system . err . println ( <string_literal> + ( accuracy * <number_literal> ) + <string_literal> ) ; system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; <ect>
system . err . println ( ) ; system . err . println ( <string_literal> + nodes . length ) ; system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . no <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; return ; } } system . exit ( exit <identifiersep> ping <identifiersep> target <identifiersep> not <identifiersep> reached ) ; <ect>
system . err . println ( <string_literal> + max <identifiersep> htl ) ; system . err . println ( <string_literal> + total <identifiersep> hops <identifiersep> taken / successes ) ; system . err . println ( <string_literal> + location <identifiersep> manager . started <identifiersep> swaps ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ) ; <LOG> system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> recognized <identifiersep> id ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps ) ; return ; } } system . exit ( exit <identifiersep> ping <identifiersep> target <identifiersep> not <identifiersep> reached ) ; } } <ect>
node2 . start ( true ) ; <comment> <LOG> while ( true ) { boolean success ; try { success = pn . ping ( ping <identifiersep> id ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> ) ; <ect>
boolean success ; try { success = pn . ping ( ping <identifiersep> id ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> ) ; continue ; } <LOG> if ( success ) else logger . error ( real <identifiersep> node <identifiersep> ping <identifiersep> test . class , <string_literal> + ping <identifiersep> id ) ; try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { <ect>
private static final int exit <identifiersep> different <identifiersep> uri = <number_literal> ; private static final int darknet <identifiersep> port1 = <number_literal> ; private static final int opennet <identifiersep> port1 = <number_literal> ; <comment> private static final int delta = <number_literal> ; public static void main ( string [ ] args ) { <LOG> if ( args . length < 1 || args . length > <number_literal> ) { system . exit ( 1 ) ; } string uid = args [ 0 ] ; boolean dump <identifiersep> only = args . length == <number_literal> && <string_literal> . equals <identifiersep> ignore <identifiersep> case ( args [ 1 ] ) ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <ect>
system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; boolean dump <identifiersep> only = args . length == <number_literal> && <string_literal> . equals <identifiersep> ignore <identifiersep> case ( args [ 1 ] ) ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <LOG> csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; file <identifiersep> input <identifiersep> stream fis = null ; <ect>
<comment> <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <ect>
csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + e + <string_literal> + i + <string_literal> ) ; } } if ( successes == <number_literal> ) system . err . println ( <string_literal> + successes ) ; else if ( successes != 0 ) system . err . println ( <string_literal> + successes ) ; <LOG> else uri = null ; <comment> <ect>
uri = null ; block = new insert <identifiersep> block ( mhks [ i ] , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri this <identifiersep> uri = client . insert ( block , false , null ) ; uri = this <identifiersep> uri ; <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; csv <identifiersep> line . add ( uri . to <identifiersep> ascii <identifiersep> string ( ) ) ; successes ++ ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
successes ++ ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + e + <string_literal> + i ) ; } } <LOG> if ( successes == <number_literal> ) else if ( successes != 0 ) system . err . println ( <string_literal> + successes ) ; else system . err . println ( <string_literal> + successes ) ; uri = null ; <ect>
csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + e + <string_literal> + i ) ; } } if ( successes == <number_literal> ) system . err . println ( <string_literal> + successes ) ; else if ( successes != 0 ) system . err . println ( <string_literal> + successes ) ; <LOG> else uri = null ; } <comment> <ect>
single <identifiersep> uri = null ; for ( int i = 0 ; i < mhk <identifiersep> ur <identifiersep> is . length ; i ++ ) mhk <identifiersep> ur <identifiersep> is [ i ] = null ; <comment> <LOG> calendar . set <identifiersep> time ( date ) ; gregorian <identifiersep> calendar target = ( gregorian <identifiersep> calendar ) today . clone ( ) ; target . set ( calendar . hour <identifiersep> of <identifiersep> day , 0 ) ; target . set ( calendar . minute , 0 ) ; target . set ( calendar . millisecond , 0 ) ; target . set ( calendar . second , 0 ) ; <ect>
system . out . println ( <string_literal> + seed <identifiersep> time ) ; int token = <number_literal> ; if ( split . length < <number_literal> ) { lines <identifiersep> too <identifiersep> short ++ ; continue ; } for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> int insert <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; token ++ ; freenet <identifiersep> uri this <identifiersep> uri = new freenet <identifiersep> uri ( split [ token ] ) ; if ( single <identifiersep> uri == null ) single <identifiersep> uri = this <identifiersep> uri ; else { <ect>
single <identifiersep> uri = this <identifiersep> uri ; else { if ( ! single <identifiersep> uri . equals ( this <identifiersep> uri ) ) { system . err . println ( <string_literal> + single <identifiersep> uri + <string_literal> + i + <string_literal> + this <identifiersep> uri ) ; lines <identifiersep> broken ++ ; continue ; } } <LOG> token ++ ; } for ( int i = 0 ; i < <number_literal> ; i ++ ) { int insert <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; token ++ ; mhk <identifiersep> ur <identifiersep> is [ i ] = new freenet <identifiersep> uri ( split [ token ] ) ; token ++ ; <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { int insert <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; token ++ ; mhk <identifiersep> ur <identifiersep> is [ i ] = new freenet <identifiersep> uri ( split [ token ] ) ; token ++ ; system . out . println ( <string_literal> + i + <string_literal> + mhk <identifiersep> ur <identifiersep> is [ i ] + <string_literal> + insert <identifiersep> time ) ; } <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { lines <identifiersep> no <identifiersep> number ++ ; continue ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; lines <identifiersep> no <identifiersep> url ++ ; <ect>
lines <identifiersep> no <identifiersep> number ++ ; continue ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; lines <identifiersep> no <identifiersep> url ++ ; continue ; } <LOG> if ( math . abs ( target . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) - calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ) < hours . to <identifiersep> millis ( <number_literal> ) ) { system . out . println ( <string_literal> + split [ 1 ] ) ; match = true ; break ; } else if ( split . length > <number_literal> + <number_literal> + <number_literal> ) { int token = <number_literal> + <number_literal> + <number_literal> ; <ect>
boolean single <identifiersep> key <identifiersep> success = false ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { <comment> <LOG> single <identifiersep> key <identifiersep> success = true ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . out . println ( <string_literal> + date + <string_literal> + i + <string_literal> + split [ token ] ) ; single <identifiersep> key <identifiersep> fetch <identifiersep> time = - 1 ; } } <comment> <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { total <identifiersep> single <identifiersep> key <identifiersep> fetches ++ ; int mhk <identifiersep> fetch <identifiersep> time = - 1 ; try { mhk <identifiersep> fetch <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; mhk <identifiersep> success = true ; <LOG> total <identifiersep> single <identifiersep> key <identifiersep> successes ++ ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . out . println ( <string_literal> + i + <string_literal> + date + <string_literal> + split [ token ] ) ; } token ++ ; } total ++ ; if ( single <identifiersep> key <identifiersep> success ) <ect>
token ++ ; } total ++ ; if ( single <identifiersep> key <identifiersep> success ) single <identifiersep> keys <identifiersep> succeeded ++ ; if ( mhk <identifiersep> success ) mhk <identifiersep> succeeded ++ ; <LOG> } else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; <ect>
if ( single <identifiersep> key <identifiersep> success ) single <identifiersep> keys <identifiersep> succeeded ++ ; if ( mhk <identifiersep> success ) mhk <identifiersep> succeeded ++ ; } else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + lines <identifiersep> too <identifiersep> short + <string_literal> + lines <identifiersep> broken + <string_literal> + lines <identifiersep> no <identifiersep> number + <string_literal> + lines <identifiersep> no <identifiersep> url + <string_literal> + lines <identifiersep> no <identifiersep> fetch ) ; <LOG> system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; <ect>
if ( mhk <identifiersep> success ) mhk <identifiersep> succeeded ++ ; } else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + lines <identifiersep> too <identifiersep> short + <string_literal> + lines <identifiersep> broken + <string_literal> + lines <identifiersep> no <identifiersep> number + <string_literal> + lines <identifiersep> no <identifiersep> url + <string_literal> + lines <identifiersep> no <identifiersep> fetch ) ; system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; <LOG> system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; system . out . println ( <string_literal> + ( ( double ) mhk <identifiersep> succeeded ) / ( ( double ) total ) ) ; fis . close ( ) ; <ect>
} else lines <identifiersep> no <identifiersep> fetch ++ ; } system . out . println ( <string_literal> + lines <identifiersep> too <identifiersep> short + <string_literal> + lines <identifiersep> broken + <string_literal> + lines <identifiersep> no <identifiersep> number + <string_literal> + lines <identifiersep> no <identifiersep> url + <string_literal> + lines <identifiersep> no <identifiersep> fetch ) ; system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; <LOG> system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; system . out . println ( <string_literal> + ( ( double ) mhk <identifiersep> succeeded ) / ( ( double ) total ) ) ; fis . close ( ) ; fis = null ; <comment> <ect>
system . out . println ( <string_literal> + total ) ; system . out . println ( <string_literal> + single <identifiersep> keys <identifiersep> succeeded ) ; system . out . println ( <string_literal> + mhk <identifiersep> succeeded ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ; system . out . println ( <string_literal> + total <identifiersep> single <identifiersep> key <identifiersep> successes ) ; system . out . println ( <string_literal> + ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> successes ) / ( ( double ) total <identifiersep> single <identifiersep> key <identifiersep> fetches ) ) ; <LOG> system . out . println ( <string_literal> + ( ( double ) single <identifiersep> keys <identifiersep> succeeded ) / ( ( double ) total ) ) ; fis . close ( ) ; fis = null ; <comment> <ect>
csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; fetched = true ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> csv <identifiersep> line . add ( fetch <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; } } for ( int i = 0 ; i < mhk <identifiersep> ur <identifiersep> is . length ; i ++ ) { try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( mhk <identifiersep> ur <identifiersep> is [ i ] ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
node node2 = null ; try { final file dir = new file ( <string_literal> + uid ) ; file <identifiersep> util . remove <identifiersep> all ( dir ) ; random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . error , <string_literal> , false ) ; file seednodes = new file ( <string_literal> ) ; <LOG> if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } final file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port1 ) ) ; inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; <ect>
system . out . println ( <string_literal> + ( t2 - t1 ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <LOG> freenet <identifiersep> uri uri = new freenet <identifiersep> uri ( <string_literal> + uid + <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) + <string_literal> + i ) ; client . add <identifiersep> event <identifiersep> hook ( new client <identifiersep> event <identifiersep> listener ( ) { @ override public void receive ( client <identifiersep> event ce , client <identifiersep> context context ) { system . out . println ( ce . get <identifiersep> description ( ) ) ; } } ) ; <ect>
true , true , true , true , <number_literal> * <number_literal> , false , true , false , false , null ) ; node2 . start ( true ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ! test <identifiersep> util . wait <identifiersep> for <identifiersep> nodes ( node2 ) ) { exit <identifiersep> code = exit <identifiersep> failed <identifiersep> target ; return ; } <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <ect>
target <identifiersep> date . add ( calendar . day <identifiersep> of <identifiersep> month , - ( ( 1 < < i ) - 1 ) ) ; freenet <identifiersep> uri uri = new freenet <identifiersep> uri ( <string_literal> + uid + <string_literal> + date <identifiersep> format . format ( target <identifiersep> date . get <identifiersep> time ( ) ) + <string_literal> + i ) ; system . out . println ( <string_literal> + uri ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
while ( ( line = br . read <identifiersep> line ( ) ) != null ) { dump <identifiersep> element element ; <comment> <LOG> calendar . set <identifiersep> time ( date ) ; if ( prev <identifiersep> date != null ) { long now = calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ; long prev = prev <identifiersep> date . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ; long dist = days . convert ( now - prev , milliseconds ) ; if ( dist != 1 ) system . out . println ( <string_literal> + dist + <string_literal> ) ; <ect>
calendar . set ( calendar . second , 0 ) ; calendar . set ( calendar . minute , 0 ) ; calendar . set ( calendar . hour <identifiersep> of <identifiersep> day , 0 ) ; map . put ( calendar , element ) ; } fis . close ( ) ; for ( int i = 0 ; i < = max <identifiersep> n ; i ++ ) { <LOG> int delta = ( ( 1 < < i ) - 1 ) ; int failures = 0 ; int successes = 0 ; long success <identifiersep> time = 0 ; int no <identifiersep> match = 0 ; int insert <identifiersep> failure = 0 ; <ect>
dump <identifiersep> element element = entry . get <identifiersep> value ( ) ; if ( element . pull <identifiersep> times != null ) { date = ( gregorian <identifiersep> calendar ) date . clone ( ) ; date . add ( calendar . day <identifiersep> of <identifiersep> month , - delta ) ; system . out . println ( <string_literal> + date . get <identifiersep> time ( ) + <string_literal> + element . date . get <identifiersep> time ( ) + <string_literal> + delta ) ; dump <identifiersep> element inserted = map . get ( date ) ; <LOG> if ( inserted == null ) { no <identifiersep> match ++ ; continue ; } if ( inserted . push <identifiersep> times == null || inserted . push <identifiersep> times [ i ] == 0 ) { system . out . println ( <string_literal> ) ; if ( element . pull <identifiersep> times [ i ] != 0 ) { <ect>
if ( inserted == null ) { system . out . println ( <string_literal> ) ; no <identifiersep> match ++ ; continue ; } if ( inserted . push <identifiersep> times == null || inserted . push <identifiersep> times [ i ] == 0 ) { system . out . println ( <string_literal> ) ; <LOG> if ( element . pull <identifiersep> times [ i ] != 0 ) { } insert <identifiersep> failure ++ ; } if ( element . pull <identifiersep> times [ i ] == 0 ) { string failure <identifiersep> mode = element . pull <identifiersep> failures [ i ] ; integer count = failure <identifiersep> modes . get ( failure <identifiersep> mode ) ; if ( count == null ) <ect>
else failure <identifiersep> modes . put ( failure <identifiersep> mode , count + 1 ) ; failures ++ ; } else { successes ++ ; success <identifiersep> time += element . pull <identifiersep> times [ i ] ; } } } <LOG> system . out . println ( <string_literal> + successes ) ; system . out . println ( <string_literal> + failures ) ; for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; system . out . println ( <string_literal> + no <identifiersep> match ) ; system . out . println ( <string_literal> + insert <identifiersep> failure ) ; <ect>
} else { successes ++ ; success <identifiersep> time += element . pull <identifiersep> times [ i ] ; } } } system . out . println ( <string_literal> + successes ) ; if ( successes != 0 ) system . out . println ( <string_literal> + ( success <identifiersep> time / successes ) ) ; system . out . println ( <string_literal> + failures ) ; <LOG> for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( <string_literal> + no <identifiersep> match ) ; system . out . println ( <string_literal> + insert <identifiersep> failure ) ; double psuccess = ( successes * 1 . 0 / ( 1 . 0 * ( successes + failures ) ) ) ; system . out . println ( <string_literal> + delta + <string_literal> + psuccess + <string_literal> + ( successes + failures ) + <string_literal> ) ; if ( delta != 0 ) { <ect>
success <identifiersep> time += element . pull <identifiersep> times [ i ] ; } } } system . out . println ( <string_literal> + successes ) ; if ( successes != 0 ) system . out . println ( <string_literal> + ( success <identifiersep> time / successes ) ) ; system . out . println ( <string_literal> + failures ) ; for ( map . entry < string , integer > entry : failure <identifiersep> modes . entry <identifiersep> set ( ) ) system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; <LOG> system . out . println ( <string_literal> + no <identifiersep> match ) ; double psuccess = ( successes * 1 . 0 / ( 1 . 0 * ( successes + failures ) ) ) ; system . out . println ( <string_literal> + delta + <string_literal> + psuccess + <string_literal> + ( successes + failures ) + <string_literal> ) ; if ( delta != 0 ) { double half <identifiersep> life <identifiersep> estimate = - 1 * math . log ( <number_literal> ) / ( math . log ( psuccess ) / delta ) ; system . out . println ( <string_literal> + half <identifiersep> life <identifiersep> estimate + <string_literal> ) ; <ect>
system . out . println ( entry . get <identifiersep> key ( ) + <string_literal> + entry . get <identifiersep> value ( ) ) ; system . out . println ( <string_literal> + no <identifiersep> match ) ; system . out . println ( <string_literal> + insert <identifiersep> failure ) ; double psuccess = ( successes * 1 . 0 / ( 1 . 0 * ( successes + failures ) ) ) ; system . out . println ( <string_literal> + delta + <string_literal> + psuccess + <string_literal> + ( successes + failures ) + <string_literal> ) ; if ( delta != 0 ) { <LOG> double half <identifiersep> life <identifiersep> estimate = - 1 * math . log ( <number_literal> ) / ( math . log ( psuccess ) / delta ) ; } system . out . println ( ) ; } } static class dump <identifiersep> element { public dump <identifiersep> element ( gregorian <identifiersep> calendar date , int version ) { this . date = date ; this . version = version ; <ect>
private static final int max <identifiersep> n = <number_literal> ; public static void main ( string [ ] args ) { if ( args . length != 1 ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; <LOG> list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; <ect>
node node2 = null ; try { final file dir = new file ( <string_literal> + uid ) ; file <identifiersep> util . remove <identifiersep> all ( dir ) ; random <identifiersep> source random = node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir . get <identifiersep> path ( ) , false , log <identifiersep> level . error , <string_literal> , false ) ; file seednodes = new file ( <string_literal> ) ; <LOG> if ( ! seednodes . exists ( ) || seednodes . length ( ) == 0 || ! seednodes . can <identifiersep> read ( ) ) { system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } final file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port1 ) ) ; inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; <ect>
long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + ( t2 - t1 ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <LOG> freenet <identifiersep> uri uri = new freenet <identifiersep> uri ( <string_literal> + uid + <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; try { insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , uri ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . insert ( block , false , null ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
true , true , true , true , <number_literal> * <number_literal> , false , true , false , false , null ) ; node2 . start ( true ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ! test <identifiersep> util . wait <identifiersep> for <identifiersep> nodes ( node2 ) ) { exit <identifiersep> code = exit <identifiersep> failed <identifiersep> target ; return ; } <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <ect>
target <identifiersep> date . add ( calendar . day <identifiersep> of <identifiersep> month , - ( ( 1 < < i ) - 1 ) ) ; uri = new freenet <identifiersep> uri ( <string_literal> + uid + <string_literal> + date <identifiersep> format . format ( target <identifiersep> date . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + uri ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
public static final int darknet <identifiersep> port <identifiersep> end = darknet <identifiersep> port <identifiersep> base + number <identifiersep> of <identifiersep> nodes ; public static void main ( string [ ] args ) throws fs <identifiersep> parse <identifiersep> exception , peer <identifiersep> parse <identifiersep> exception , chk <identifiersep> encode <identifiersep> exception , invalid <identifiersep> threshold <identifiersep> exception , node <identifiersep> init <identifiersep> exception , reference <identifiersep> signature <identifiersep> verification <identifiersep> exception , key <identifiersep> collision <identifiersep> exception , ssk <identifiersep> encode <identifiersep> exception , io <identifiersep> exception , interrupted <identifiersep> exception , ssk <identifiersep> verify <identifiersep> exception , invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception , peer <identifiersep> too <identifiersep> old <identifiersep> exception { system . err . println ( <string_literal> ) ; system . err . println ( ) ; string test <identifiersep> name = <string_literal> ; file wd = new file ( test <identifiersep> name ) ; <LOG> if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } wd . mkdir ( ) ; dummy <identifiersep> random <identifiersep> source random = new dummy <identifiersep> random <identifiersep> source ( ) ; <comment> <ect>
block = ( ( insertable <identifiersep> client <identifiersep> ssk ) insert <identifiersep> key ) . encode ( new array <identifiersep> bucket ( buf ) , false , false , ( short ) - 1 , buf . length , random , compressor <identifiersep> type . default <identifiersep> compressordescriptor , false ) ; } else { block = client <identifiersep> chk <identifiersep> block . encode ( buf , false , false , ( short ) - 1 , buf . length , compressor <identifiersep> type . default <identifiersep> compressordescriptor , false ) ; insert <identifiersep> key = fetch <identifiersep> key = block . get <identifiersep> client <identifiersep> key ( ) ; test <identifiersep> key = insert <identifiersep> key . get <identifiersep> uri ( ) ; } final key node <identifiersep> key = fetch <identifiersep> key . get <identifiersep> node <identifiersep> key ( false ) ; <LOG> system . err . println ( ) ; system . err . println ( ) ; logger . error ( real <identifiersep> node <identifiersep> ulpr <identifiersep> test . class , <string_literal> + successful <identifiersep> tests + <string_literal> + test <identifiersep> key + <string_literal> + fetch <identifiersep> key + <string_literal> + node <identifiersep> key ) ; wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; <comment> <ect>
key key = ( key ) m . get <identifiersep> object ( dmt . freenet <identifiersep> routing <identifiersep> key ) ; if ( key . equals ( node <identifiersep> key ) ) { visited [ n . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) - darknet <identifiersep> port <identifiersep> base ] = true ; } } } } ; for ( node node : nodes ) { node . set <identifiersep> dispatcher <identifiersep> hook ( cb ) ; } <LOG> for ( int i = 0 ; i < nodes . length ; i ++ ) { try { nodes [ i%nodes . length ] . client <identifiersep> core . real <identifiersep> get <identifiersep> key ( fetch <identifiersep> key , false , false , false , real <identifiersep> time <identifiersep> flag ) ; system . err . println ( <string_literal> ) ; <comment> <ect>
system . err . println ( <string_literal> ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> default : system . exit ( exit <identifiersep> unknown <identifiersep> error <identifiersep> checking <identifiersep> key <identifiersep> not <identifiersep> exist ) ; } } } <comment> <ect>
while ( true ) { x ++ ; thread . sleep ( <number_literal> ) ; int count = 0 ; for ( node node : nodes ) { if ( node . has <identifiersep> key ( fetch <identifiersep> key . get <identifiersep> node <identifiersep> key ( false ) , true , true ) ) <LOG> count ++ ; } logger . normal ( real <identifiersep> node <identifiersep> ulpr <identifiersep> test . class , <string_literal> + x + <string_literal> + count + ' / ' + nodes . length + <string_literal> + successful <identifiersep> tests + <string_literal> ) ; if ( x > <number_literal> ) { system . err . println ( ) ; system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> test <identifiersep> failed ) ; <ect>
system . err . println ( ) ; system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> test <identifiersep> failed ) ; } if ( count == nodes . length ) { successful <identifiersep> tests ++ ; long t <identifiersep> end = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> long propagation <identifiersep> time = t <identifiersep> end - t <identifiersep> start ; total <identifiersep> propagation <identifiersep> time += propagation <identifiersep> time ; system . err . println ( <string_literal> + ( total <identifiersep> propagation <identifiersep> time / successful <identifiersep> tests ) + <string_literal> ) ; system . err . println ( ) ; break ; } if ( x % nodes . length == 0 ) { <ect>
break ; } if ( x % nodes . length == 0 ) { system . err . print ( <string_literal> ) ; for ( int i = 0 ; i < nodes . length ; i ++ ) if ( nodes [ i ] . has <identifiersep> key ( fetch <identifiersep> key . get <identifiersep> node <identifiersep> key ( false ) , true , true ) ) { system . err . print ( i + <string_literal> ) ; } <LOG> system . err . println ( ) ; } } } system . exit ( 0 ) ; } } <ect>
system . err . println ( <string_literal> + seednode . to <identifiersep> string ( ) + <string_literal> + fse . get <identifiersep> message ( ) ) ; } } <comment> <LOG> if ( seed <identifiersep> nodes . size ( ) != number <identifiersep> of <identifiersep> nodes <identifiersep> in <identifiersep> the <identifiersep> file ) system . out . println ( <string_literal> + seed <identifiersep> nodes . size ( ) + <string_literal> ) ; thread . sleep ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; int ping <identifiersep> id = 0 ; long deadline = system . current <identifiersep> time <identifiersep> millis ( ) + minutes . to <identifiersep> millis ( <number_literal> ) ; while ( system . current <identifiersep> time <identifiersep> millis ( ) < deadline ) { <ect>
<string_literal> + uptime + <string_literal> + ping + <string_literal> + ping <identifiersep> time + <string_literal> + seednode . get <identifiersep> uptime ( ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( time <identifiersep> delta ) ) ; <comment> <LOG> if ( seednode . is <identifiersep> routable ( ) ) } catch ( not <identifiersep> connected <identifiersep> exception e ) { system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + seednode . get <identifiersep> handshake <identifiersep> count ( ) ) ; } } map < fate , integer > totals = new enum <identifiersep> map < fate , integer > ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node . fate . class ) ; for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { fate fate = seednode . get <identifiersep> fate ( ) ; <ect>
for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { fate fate = seednode . get <identifiersep> fate ( ) ; integer x = totals . get ( fate ) ; if ( x == null ) totals . put ( fate , 1 ) ; else <LOG> totals . put ( fate , x + 1 ) ; } system . out . println ( <string_literal> ) ; for ( entry < fate , integer > fate <identifiersep> entry : totals . entry <identifiersep> set ( ) ) { system . out . println ( fate <identifiersep> entry . get <identifiersep> key ( ) + <string_literal> + fate <identifiersep> entry . get <identifiersep> value ( ) ) ; } system . out . println ( <string_literal> + node . peers . count <identifiersep> connected <identifiersep> peers ( ) + <string_literal> + count <identifiersep> connected <identifiersep> seednodes + ' / ' + node . peers . count <identifiersep> seednodes ( ) ) ; thread . sleep ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; <ect>
if ( x == null ) totals . put ( fate , 1 ) ; else totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } system . out . println ( <string_literal> ) ; <LOG> for ( entry < fate , integer > fate <identifiersep> entry : totals . entry <identifiersep> set ( ) ) { } system . out . println ( <string_literal> + node . peers . count <identifiersep> connected <identifiersep> peers ( ) + <string_literal> + count <identifiersep> connected <identifiersep> seednodes + ' / ' + node . peers . count <identifiersep> seednodes ( ) ) ; thread . sleep ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; } map < fate , integer > totals = new enum <identifiersep> map < fate , integer > ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node . fate . class ) ; for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { fate fate = seednode . get <identifiersep> fate ( ) ; <ect>
for ( seed <identifiersep> server <identifiersep> test <identifiersep> peer <identifiersep> node seednode : seed <identifiersep> nodes ) { fate fate = seednode . get <identifiersep> fate ( ) ; integer x = totals . get ( fate ) ; if ( x == null ) totals . put ( fate , 1 ) ; else <LOG> totals . put ( fate , x + 1 ) ; } system . out . println ( <string_literal> ) ; for ( fate fate : totals . key <identifiersep> set ( ) ) { system . out . println ( <string_literal> + fate + <string_literal> + totals . get ( fate ) ) ; } system . out . println ( <string_literal> ) ; <comment> <ect>
if ( x == null ) totals . put ( fate , 1 ) ; else totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } system . out . println ( <string_literal> ) ; <LOG> for ( fate fate : totals . key <identifiersep> set ( ) ) { } system . out . println ( <string_literal> ) ; <comment> <ect>
totals . put ( fate , x + 1 ) ; system . out . println ( seednode . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + fate + <string_literal> + seednode . get <identifiersep> peer <identifiersep> node <identifiersep> status <identifiersep> string ( ) ) ; } system . out . println ( <string_literal> ) ; for ( fate fate : totals . key <identifiersep> set ( ) ) { system . out . println ( <string_literal> + fate + <string_literal> + totals . get ( fate ) ) ; } system . out . println ( <string_literal> ) ; <LOG> <comment> <ect>
last <identifiersep> success = time ; } else { if ( time >= count <identifiersep> since ) failures ++ ; } } while ( line != null ) ; br . close ( ) ; <LOG> if ( first <identifiersep> sample < count <identifiersep> since && successes == 0 ) system . out . println ( peer . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + ( last <identifiersep> success > 0 ? time <identifiersep> util . format <identifiersep> time ( write <identifiersep> time - last <identifiersep> success ) : <string_literal> ) + <string_literal> + failures + <string_literal> + successes ) ; } node . park ( ) ; system . exit ( 0 ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; <ect>
br . close ( ) ; if ( first <identifiersep> sample < count <identifiersep> since && successes == 0 ) system . err . println ( <string_literal> + peer . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + ( last <identifiersep> success > 0 ? time <identifiersep> util . format <identifiersep> time ( write <identifiersep> time - last <identifiersep> success ) : <string_literal> ) ) ; system . out . println ( peer . get <identifiersep> identity <identifiersep> string ( ) + <string_literal> + ( last <identifiersep> success > 0 ? time <identifiersep> util . format <identifiersep> time ( write <identifiersep> time - last <identifiersep> success ) : <string_literal> ) + <string_literal> + failures + <string_literal> + successes ) ; } node . park ( ) ; system . exit ( 0 ) ; <LOG> } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; try { if ( node != null ) node . park ( ) ; } catch ( throwable t1 ) { } <ect>
logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( block . get <identifiersep> headers ( ) ) ) ; <comment> <LOG> } catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { system . err . println ( <string_literal> + put <identifiersep> ex ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } } <comment> <ect>
} catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + put <identifiersep> ex ) ; system . err . println ( <string_literal> + put <identifiersep> ex ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } } <comment> <LOG> client <identifiersep> chk key = keys [ i ] ; for ( int j = 0 ; j < nodes . length ; j ++ ) { clients [ j ] . prefetch ( key . get <identifiersep> uri ( ) , days . to <identifiersep> millis ( 1 ) , <number_literal> , null ) ; } long total <identifiersep> running <identifiersep> requests = 0 ; for ( int j = 0 ; j < nodes . length ; j ++ ) { total <identifiersep> running <identifiersep> requests += nodes [ j ] . client <identifiersep> core . count <identifiersep> queued <identifiersep> requests ( ) ; <ect>
total <identifiersep> running <identifiersep> requests += nodes [ j ] . client <identifiersep> core . count <identifiersep> queued <identifiersep> requests ( ) ; } system . err . println ( <string_literal> + total <identifiersep> running <identifiersep> requests ) ; } <comment> <LOG> total <identifiersep> running <identifiersep> requests += nodes [ i ] . client <identifiersep> core . count <identifiersep> queued <identifiersep> requests ( ) ; } if ( total <identifiersep> running <identifiersep> requests == 0 ) break ; thread . sleep ( <number_literal> ) ; } system . exit ( 0 ) ; } } <ect>
system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } wd . mkdir ( ) ; <comment> <LOG> node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( name , false , log <identifiersep> level . error , <string_literal> , true ) ; system . out . println ( ) ; dummy <identifiersep> random <identifiersep> source random = new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) ; dummy <identifiersep> random <identifiersep> source topology <identifiersep> random = new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) ; <comment> <ect>
for ( int i = 0 ; i < number <identifiersep> of <identifiersep> nodes ; i ++ ) { nodes [ i ] . start ( false ) ; system . err . println ( <string_literal> + i + <string_literal> + nodes . length ) ; } wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; wait <identifiersep> for <identifiersep> ping <identifiersep> average ( 0 . <number_literal> , nodes , new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) , max <identifiersep> pings , <number_literal> ) ; random = new dummy <identifiersep> random <identifiersep> source ( <number_literal> ) ; <LOG> system . out . println ( ) ; system . out . println ( ) ; real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test tester = new real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test ( nodes , random , target <identifiersep> successes ) ; while ( true ) { try { wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; <ect>
try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception e1 ) { } string data <identifiersep> string = base <identifiersep> string + request <identifiersep> number ; <comment> <LOG> node random <identifiersep> node = nodes [ node1 ] ; <comment> <ect>
byte [ ] data = data <identifiersep> string . get <identifiersep> bytes ( <string_literal> ) ; logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( block . memory <identifiersep> decode ( ) , <string_literal> ) ) ; logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + insert <identifiersep> key . get <identifiersep> uri ( ) ) ; logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + fetch <identifiersep> key . get <identifiersep> uri ( ) ) ; try { insert <identifiersep> attempts ++ ; <LOG> random <identifiersep> node . client <identifiersep> core . real <identifiersep> put ( block . get <identifiersep> block ( ) , false , fork <identifiersep> on <identifiersep> cacheable , false , false , real <identifiersep> time <identifiersep> flag ) ; } catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + put <identifiersep> ex ) ; system . err . println ( <string_literal> + put <identifiersep> ex ) ; return exit <identifiersep> insert <identifiersep> failed ; } <comment> <ect>
logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + fetch <identifiersep> key . get <identifiersep> uri ( ) ) ; try { insert <identifiersep> attempts ++ ; random <identifiersep> node . client <identifiersep> core . real <identifiersep> put ( block . get <identifiersep> block ( ) , false , fork <identifiersep> on <identifiersep> cacheable , false , false , real <identifiersep> time <identifiersep> flag ) ; logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + node1 ) ; } catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { <LOG> logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + put <identifiersep> ex ) ; return exit <identifiersep> insert <identifiersep> failed ; } <comment> <ect>
try { block = fetch <identifiersep> node . client <identifiersep> core . real <identifiersep> get <identifiersep> key ( fetch <identifiersep> key , false , false , false , real <identifiersep> time <identifiersep> flag ) ; } catch ( low <identifiersep> level <identifiersep> get <identifiersep> exception e ) { block = null ; } if ( block == null ) { int percent <identifiersep> success = <number_literal> * fetch <identifiersep> successes / insert <identifiersep> attempts ; <LOG> logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + request <identifiersep> number + <string_literal> + percent <identifiersep> success + <string_literal> + node2 ) ; requests <identifiersep> avg . report ( 0 . 0 ) ; } else { byte [ ] results = block . memory <identifiersep> decode ( ) ; requests <identifiersep> avg . report ( 1 . 0 ) ; if ( arrays . equals ( results , data ) ) { <ect>
} else { byte [ ] results = block . memory <identifiersep> decode ( ) ; requests <identifiersep> avg . report ( 1 . 0 ) ; if ( arrays . equals ( results , data ) ) { fetch <identifiersep> successes ++ ; int percent <identifiersep> success = <number_literal> * fetch <identifiersep> successes / insert <identifiersep> attempts ; <LOG> logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + request <identifiersep> number + <string_literal> + node2 + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) ) ; if ( fetch <identifiersep> successes == target <identifiersep> successes ) { system . err . println ( <string_literal> + target <identifiersep> successes + <string_literal> ) ; return 0 ; } } else { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( results ) ) ; <ect>
int percent <identifiersep> success = <number_literal> * fetch <identifiersep> successes / insert <identifiersep> attempts ; logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + request <identifiersep> number + <string_literal> + node2 + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) ) ; system . err . println ( <string_literal> + request <identifiersep> number + <string_literal> + percent <identifiersep> success + <string_literal> + new string ( results ) + \' \\ " \' ) ; if ( fetch <identifiersep> successes == target <identifiersep> successes ) { system . err . println ( <string_literal> + target <identifiersep> successes + <string_literal> ) ; return 0 ; } <LOG> } else { system . err . println ( <string_literal> + new string ( results ) ) ; return exit <identifiersep> bad <identifiersep> data ; } } string <identifiersep> builder load = new string <identifiersep> builder ( <string_literal> ) ; int total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt = 0 ; list < long > running <identifiersep> ui <identifiersep> ds <identifiersep> list = new array <identifiersep> list < long > ( ) ; <ect>
int running <identifiersep> ui <identifiersep> ds <identifiersep> alt = nodes [ i ] . tracker . get <identifiersep> total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt ( ) ; total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt += running <identifiersep> ui <identifiersep> ds <identifiersep> alt ; load . append ( total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt ) ; if ( i != nodes . length - 1 ) load . append ( ' ' ) ; } system . err . println ( load . to <identifiersep> string ( ) ) ; <LOG> if ( total <identifiersep> running <identifiersep> ui <identifiersep> ds <identifiersep> alt != 0 ) if ( ! running <identifiersep> ui <identifiersep> ds <identifiersep> list . is <identifiersep> empty ( ) ) { system . err . println ( <string_literal> + arrays . to <identifiersep> string ( running <identifiersep> ui <identifiersep> ds <identifiersep> list . to <identifiersep> array ( ) ) ) ; } return - 1 ; } } <ect>
private static final int darknet <identifiersep> port1 = <number_literal> ; private static final int opennet <identifiersep> port1 = <number_literal> ; private static final int darknet <identifiersep> port2 = <number_literal> ; private static final int opennet <identifiersep> port2 = <number_literal> ; private static final int max <identifiersep> n = <number_literal> ; public static void main ( string [ ] args ) { <LOG> if ( args . length != 1 ) { system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <ect>
if ( args . length != 1 ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <LOG> csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; try { <ect>
<comment> <LOG> long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; freenet <identifiersep> uri todays <identifiersep> insert = null ; <comment> <ect>
system . out . println ( <string_literal> + i ) ; try { insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri uri = client . insert ( block , false , null ) ; if ( i == 0 ) todays <identifiersep> insert = uri ; <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; csv <identifiersep> line . add ( uri . to <identifiersep> ascii <identifiersep> string ( ) ) ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( <string_literal> ) ; <ect>
calendar target <identifiersep> date = ( calendar ) today . clone ( ) ; target <identifiersep> date . add ( calendar . day <identifiersep> of <identifiersep> month , - ( ( 1 < < i ) - 1 ) ) ; freenet <identifiersep> uri uri = null ; if ( i == 0 ) uri = todays <identifiersep> insert ; else { uri = get <identifiersep> historic <identifiersep> uri ( uid , i , target <identifiersep> date ) ; } <LOG> if ( uri == null ) { continue ; } system . out . println ( <string_literal> + uri ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; <ect>
nodes [ i ] = node <identifiersep> starter . create <identifiersep> test <identifiersep> node ( darknet <identifiersep> port <identifiersep> base + i , 0 , dir , true , max <identifiersep> htl , 0 <comment> , random , executor , <number_literal> * number <identifiersep> of <identifiersep> nodes , <number_literal> * <number_literal> , true , enable <identifiersep> swapping , false , false , false , enable <identifiersep> swap <identifiersep> queueing , true , output <identifiersep> bandwidth <identifiersep> limit , enable <identifiersep> foaf , false , true , false , null , i == 0 ) ; logger . normal ( real <identifiersep> node <identifiersep> probe <identifiersep> test . class , <string_literal> + i ) ; } logger . normal ( real <identifiersep> node <identifiersep> probe <identifiersep> test . class , <string_literal> + number <identifiersep> of <identifiersep> nodes + <string_literal> ) ; <comment> <LOG> for ( int i = 0 ; i < number <identifiersep> of <identifiersep> nodes ; i ++ ) { nodes [ i ] . start ( false ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( ) ; if ( do <identifiersep> insert <identifiersep> test ) { <ect>
real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test tester = new real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test ( nodes , random , <number_literal> ) ; wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; while ( true ) { try { wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; int status = tester . insert <identifiersep> request <identifiersep> test ( ) ; <LOG> if ( status == - 1 ) continue ; break ; } catch ( throwable t ) { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + t , t ) ; } } } final number <identifiersep> format nf = number <identifiersep> format . get <identifiersep> instance ( ) ; listener print = new listener ( ) { <ect>
logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + t , t ) ; } } } final number <identifiersep> format nf = number <identifiersep> format . get <identifiersep> instance ( ) ; listener print = new listener ( ) { @ override public void on <identifiersep> error ( error error , byte code , boolean local ) { system . out . print ( <string_literal> + error . name ( ) ) ; <LOG> if ( local ) system . out . print ( <string_literal> ) ; } @ override public void on <identifiersep> refused ( ) { system . out . println ( <string_literal> ) ; } @ override public void on <identifiersep> output <identifiersep> bandwidth ( float output <identifiersep> bandwidth ) { <ect>
if ( local ) system . out . print ( <string_literal> ) ; system . out . println ( code == null ? <string_literal> : <string_literal> + code + <string_literal> ) ; } @ override public void on <identifiersep> refused ( ) { system . out . println ( <string_literal> ) ; } @ override <LOG> public void on <identifiersep> output <identifiersep> bandwidth ( float output <identifiersep> bandwidth ) { <string_literal> ) ; } @ override public void on <identifiersep> build ( int build ) { system . out . println ( <string_literal> + build + <string_literal> ) ; } @ override <ect>
system . out . println ( <string_literal> + nf . format ( output <identifiersep> bandwidth ) + <string_literal> ) ; } @ override public void on <identifiersep> build ( int build ) { system . out . println ( <string_literal> + build + <string_literal> ) ; } @ override <LOG> public void on <identifiersep> identifier ( long identifier , byte uptime <identifiersep> percentage ) { } @ override public void on <identifiersep> link <identifiersep> lengths ( float [ ] link <identifiersep> lengths ) { system . out . print ( <string_literal> ) ; for ( float length : link <identifiersep> lengths ) system . out . print ( length + <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
@ override public void on <identifiersep> link <identifiersep> lengths ( float [ ] link <identifiersep> lengths ) { system . out . print ( <string_literal> ) ; for ( float length : link <identifiersep> lengths ) system . out . print ( length + <string_literal> ) ; system . out . println ( <string_literal> ) ; } @ override <LOG> public void on <identifiersep> location ( float location ) { } @ override public void on <identifiersep> store <identifiersep> size ( float store <identifiersep> size ) { system . out . println ( <string_literal> + nf . format ( store <identifiersep> size ) + <string_literal> ) ; } @ override public void on <identifiersep> uptime ( float uptime <identifiersep> percentage ) { <ect>
public void on <identifiersep> store <identifiersep> size ( float store <identifiersep> size ) { system . out . println ( <string_literal> + nf . format ( store <identifiersep> size ) + <string_literal> ) ; } @ override public void on <identifiersep> uptime ( float uptime <identifiersep> percentage ) { system . out . print ( <string_literal> + nf . format ( uptime <identifiersep> percentage ) + <string_literal> ) ; } @ override <LOG> public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { system . out . println ( <string_literal> + stats [ 0 ] ) ; system . out . println ( <string_literal> + stats [ 1 ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; } @ override <ect>
@ override public void on <identifiersep> uptime ( float uptime <identifiersep> percentage ) { system . out . print ( <string_literal> + nf . format ( uptime <identifiersep> percentage ) + <string_literal> ) ; } @ override public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> + stats [ 0 ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; } @ override public void on <identifiersep> overall <identifiersep> bulk <identifiersep> output <identifiersep> capacity ( byte bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage , float output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) { <ect>
system . out . print ( <string_literal> + nf . format ( uptime <identifiersep> percentage ) + <string_literal> ) ; } @ override public void on <identifiersep> reject <identifiersep> stats ( byte [ ] stats ) { system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> + stats [ 0 ] ) ; system . out . println ( <string_literal> + stats [ 1 ] ) ; <LOG> system . out . println ( <string_literal> + stats [ <number_literal> ] ) ; } @ override public void on <identifiersep> overall <identifiersep> bulk <identifiersep> output <identifiersep> capacity ( byte bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage , float output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) { system . out . println ( <string_literal> + nf . format ( output <identifiersep> bulk <identifiersep> capacity <identifiersep> used ) + <string_literal> + bandwidth <identifiersep> class <identifiersep> for <identifiersep> capacity <identifiersep> usage + <string_literal> ) ; <ect>
buffered <identifiersep> reader r ; console console = system . console ( ) ; if ( console != null ) r = new buffered <identifiersep> reader ( console . reader ( ) ) ; else r = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( system . in ) ) ; <comment> <LOG> while ( true ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
if ( console != null ) r = new buffered <identifiersep> reader ( console . reader ( ) ) ; else r = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( system . in ) ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
else r = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( system . in ) ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
while ( true ) { system . err . println ( <string_literal> + index + <string_literal> + htl + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; try { int selection = integer . parse <identifiersep> int ( r . read <identifiersep> line ( ) ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; try { int selection = integer . parse <identifiersep> int ( r . read <identifiersep> line ( ) ) ; if ( selection == types . length ) { system . err . print ( <string_literal> + ( number <identifiersep> of <identifiersep> nodes - 1 ) + <string_literal> ) ; <ect>
<comment> <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; high <identifiersep> level <identifiersep> simple <identifiersep> client client = node . client <identifiersep> core . make <identifiersep> client ( ( short ) 0 , false , false ) ; int successes = 0 ; long start <identifiersep> inserts <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; insert <identifiersep> batch batch = new insert <identifiersep> batch ( client ) ; <ect>
freenet <identifiersep> uri [ ] uris = batch . get <identifiersep> ur <identifiersep> is ( ) ; long [ ] times = batch . get <identifiersep> times ( ) ; insert <identifiersep> exception [ ] errors = batch . get <identifiersep> errors ( ) ; for ( int i = 0 ; i < inserted <identifiersep> blocks ; i ++ ) { if ( uris [ i ] != null ) { csv <identifiersep> line . add ( string . value <identifiersep> of ( times [ i ] ) ) ; <LOG> csv <identifiersep> line . add ( uris [ i ] . to <identifiersep> ascii <identifiersep> string ( ) ) ; successes ++ ; } else { csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( errors [ i ] . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + i + <string_literal> + errors [ i ] ) ; <ect>
system . out . println ( <string_literal> + i + <string_literal> + uris [ i ] + <string_literal> + times [ i ] ) ; successes ++ ; } else { csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( errors [ i ] . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + i + <string_literal> + errors [ i ] ) ; } } <LOG> long end <identifiersep> inserts <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; fetch <identifiersep> context fctx = client . get <identifiersep> fetch <identifiersep> context ( ) ; fctx . max <identifiersep> non <identifiersep> splitfile <identifiersep> retries = 0 ; fctx . max <identifiersep> splitfile <identifiersep> block <identifiersep> retries = 0 ; request <identifiersep> client request <identifiersep> context = new request <identifiersep> client <identifiersep> builder ( ) . build ( ) ; <comment> <ect>
while ( ( line = br . read <identifiersep> line ( ) ) != null ) { for ( int i = 0 ; i < mhk <identifiersep> ur <identifiersep> is . length ; i ++ ) mhk <identifiersep> ur <identifiersep> is [ i ] = null ; <comment> <LOG> calendar . set <identifiersep> time ( date ) ; calendar . set ( calendar . hour <identifiersep> of <identifiersep> day , 0 ) ; calendar . set ( calendar . minute , 0 ) ; calendar . set ( calendar . millisecond , 0 ) ; calendar . set ( calendar . second , 0 ) ; calendar . get <identifiersep> time ( ) ; <ect>
insert <identifiersep> times [ i ] = - 1 ; } token ++ ; try { inserted <identifiersep> ur <identifiersep> is [ i ] = new freenet <identifiersep> uri ( split [ token ] ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { inserted <identifiersep> ur <identifiersep> is [ i ] = null ; } <LOG> token ++ ; } for ( int i = 0 ; i < targets . length ; i ++ ) { if ( math . abs ( targets [ i ] . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) - calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ) < hours . to <identifiersep> millis ( <number_literal> ) ) { system . out . println ( <string_literal> + ( ( 1 < < i ) - 1 ) + <string_literal> ) ; system . out . println ( <string_literal> + split [ 1 ] ) ; csv <identifiersep> line . add ( integer . to <identifiersep> string ( i ) ) ; <ect>
} catch ( malformed <identifiersep> url <identifiersep> exception e ) { inserted <identifiersep> ur <identifiersep> is [ i ] = null ; } token ++ ; system . out . println ( <string_literal> + i + <string_literal> + inserted <identifiersep> ur <identifiersep> is [ i ] + <string_literal> + insert <identifiersep> times [ i ] ) ; } for ( int i = 0 ; i < targets . length ; i ++ ) { if ( math . abs ( targets [ i ] . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) - calendar . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ) < hours . to <identifiersep> millis ( <number_literal> ) ) { <LOG> system . out . println ( <string_literal> + ( ( 1 < < i ) - 1 ) + <string_literal> ) ; csv <identifiersep> line . add ( integer . to <identifiersep> string ( i ) ) ; int pulled = 0 ; int inserted = 0 ; for ( int j = 0 ; j < inserted <identifiersep> blocks ; j ++ ) { if ( inserted <identifiersep> ur <identifiersep> is [ j ] == null ) { <ect>
csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; pulled ++ ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> csv <identifiersep> line . add ( fetch <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; } } system . out . println ( <string_literal> + pulled + <string_literal> + inserted + <string_literal> + ( ( 1 < < i ) - 1 ) + <string_literal> ) ; } } while ( split . length > token + inserted <identifiersep> blocks ) { int delta ; try { delta = integer . parse <identifiersep> int ( split [ token ] ) ; <ect>
system . err . println ( <string_literal> + j + <string_literal> + e ) ; } } system . out . println ( <string_literal> + pulled + <string_literal> + inserted + <string_literal> + ( ( 1 < < i ) - 1 ) + <string_literal> ) ; } } while ( split . length > token + inserted <identifiersep> blocks ) { int delta ; try { delta = integer . parse <identifiersep> int ( split [ token ] ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + date <identifiersep> format . format ( calendar . get <identifiersep> time ( ) ) ) ; continue loop <identifiersep> over <identifiersep> lines ; } system . out . println ( <string_literal> + ( ( 1 < < delta ) - 1 ) + <string_literal> ) ; token ++ ; <ect>
while ( split . length > token + inserted <identifiersep> blocks ) { int delta ; try { delta = integer . parse <identifiersep> int ( split [ token ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . err . println ( <string_literal> + token + <string_literal> + token + <string_literal> ) ; <LOG> system . err . println ( <string_literal> ) ; continue loop <identifiersep> over <identifiersep> lines ; } system . out . println ( <string_literal> + ( ( 1 < < delta ) - 1 ) + <string_literal> ) ; token ++ ; int total <identifiersep> fetch <identifiersep> time = 0 ; int total <identifiersep> successes = 0 ; <ect>
for ( int i = 0 ; i < inserted <identifiersep> blocks ; i ++ ) { if ( split [ token ] . equals ( <string_literal> ) ) continue ; int mhk <identifiersep> fetch <identifiersep> time = - 1 ; total <identifiersep> fetches ++ ; try { <LOG> mhk <identifiersep> fetch <identifiersep> time = integer . parse <identifiersep> int ( split [ token ] ) ; total <identifiersep> successes ++ ; total <identifiersep> fetch <identifiersep> time += mhk <identifiersep> fetch <identifiersep> time ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . out . println ( <string_literal> + i + <string_literal> + date + <string_literal> + split [ token ] ) ; } token ++ ; <ect>
total <identifiersep> fetch <identifiersep> time += mhk <identifiersep> fetch <identifiersep> time ; } catch ( number <identifiersep> format <identifiersep> exception e ) { system . out . println ( <string_literal> + i + <string_literal> + date + <string_literal> + split [ token ] ) ; } token ++ ; } total <identifiersep> fetches <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> fetches ; total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> successes ; <LOG> total <identifiersep> fetch <identifiersep> time <identifiersep> by <identifiersep> delta [ delta ] += total <identifiersep> fetch <identifiersep> time ; } } system . out . println ( ) ; system . out . println ( ) ; for ( int i = 0 ; i < max <identifiersep> n + 1 ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> + total <identifiersep> fetches <identifiersep> by <identifiersep> delta [ i ] + <string_literal> + total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta [ i ] + <string_literal> + ( ( total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta [ i ] * <number_literal> . 0 ) / total <identifiersep> fetches <identifiersep> by <identifiersep> delta [ i ] ) + <string_literal> + ( total <identifiersep> fetch <identifiersep> time <identifiersep> by <identifiersep> delta [ i ] * 1 . 0 ) / total <identifiersep> successful <identifiersep> fetches <identifiersep> by <identifiersep> delta [ i ] + <string_literal> ) ; } fis . close ( ) ; <ect>
} catch ( throwable tt ) { } try { if ( node2 != null ) node2 . park ( ) ; } catch ( throwable tt ) { } closer . close ( fis ) ; <LOG> write <identifiersep> to <identifiersep> status <identifiersep> log ( file , csv <identifiersep> line ) ; system . exit ( exit <identifiersep> code ) ; } } private static random <identifiersep> access <identifiersep> bucket random <identifiersep> data ( node node ) throws io <identifiersep> exception { random <identifiersep> access <identifiersep> bucket data = node . client <identifiersep> core . temp <identifiersep> bucket <identifiersep> factory . make <identifiersep> bucket ( test <identifiersep> size ) ; output <identifiersep> stream os = data . get <identifiersep> output <identifiersep> stream ( ) ; try { <ect>
<comment> <LOG> system . exit ( exit <identifiersep> failed <identifiersep> target ) ; } random <identifiersep> access <identifiersep> bucket data = node . client <identifiersep> core . temp <identifiersep> bucket <identifiersep> factory . make <identifiersep> bucket ( test <identifiersep> size ) ; output <identifiersep> stream os = data . get <identifiersep> output <identifiersep> stream ( ) ; try { byte [ ] buf = new byte [ <number_literal> ] ; for ( long written = 0 ; written < test <identifiersep> size ; ) { <ect>
high <identifiersep> level <identifiersep> simple <identifiersep> client client = node . client <identifiersep> core . make <identifiersep> client ( ( short ) 0 , false , false ) ; insert <identifiersep> block block = new insert <identifiersep> block ( data , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; long start <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri uri ; try { uri = client . insert ( block , false , null ) ; <LOG> } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; return ; } long end <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; system . err . println ( <string_literal> + ( end <identifiersep> insert <identifiersep> time - start <identifiersep> insert <identifiersep> time ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> insert <identifiersep> time - start <identifiersep> insert <identifiersep> time ) + <string_literal> + uri + <string_literal> ) ; <ect>
system . exit ( exit <identifiersep> failed <identifiersep> target ) ; } <comment> <LOG> } catch ( fetch <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> fetch <identifiersep> failed ) ; return ; } long end <identifiersep> fetch <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; system . err . println ( <string_literal> + ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + uri + <string_literal> ) ; <ect>
system . exit ( exit <identifiersep> fetch <identifiersep> failed ) ; return ; } long end <identifiersep> fetch <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; system . err . println ( <string_literal> + ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + uri + <string_literal> ) ; second <identifiersep> node . park ( ) ; system . exit ( 0 ) ; <LOG> } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; try { if ( node != null ) node . park ( ) ; } catch ( throwable t1 ) { } <ect>
system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } file second <identifiersep> inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port ) ) ; second <identifiersep> inner <identifiersep> dir . mkdir ( ) ; file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( second <identifiersep> inner <identifiersep> dir , <string_literal> ) ) ; fis . close ( ) ; <LOG> <comment> <ect>
system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } system . out . println ( <string_literal> + sock ) ; osw . write ( <string_literal> + test <identifiersep> size + <string_literal> ) ; osw . flush ( ) ; input <identifiersep> stream is = new file <identifiersep> input <identifiersep> stream ( data <identifiersep> file ) ; <LOG> file <identifiersep> util . copy ( is , sock <identifiersep> os , test <identifiersep> size ) ; while ( true ) { name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; fs = new simple <identifiersep> field <identifiersep> set ( lis , <number_literal> , <number_literal> , true , false , true ) ; system . out . println ( <string_literal> + name ) ; system . out . print ( fs . to <identifiersep> ordered <identifiersep> string ( ) ) ; <ect>
system . out . println ( <string_literal> ) ; while ( true ) { name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; fs = new simple <identifiersep> field <identifiersep> set ( lis , <number_literal> , <number_literal> , true , false , true ) ; system . out . println ( <string_literal> + name ) ; system . out . print ( fs . to <identifiersep> ordered <identifiersep> string ( ) ) ; <LOG> if ( name . equals ( <string_literal> ) ) { system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } if ( name . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } if ( name . equals ( <string_literal> ) ) { <ect>
system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } if ( name . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } if ( name . equals ( <string_literal> ) ) { long end <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> freenet <identifiersep> uri uri = new freenet <identifiersep> uri ( fs . get ( <string_literal> ) ) ; sock <identifiersep> os . close ( ) ; sock <identifiersep> is . close ( ) ; sock . close ( ) ; return uri ; } } } } <ect>
return seq <identifiersep> num ; } } <comment> public void ack ( int ack , base <identifiersep> peer <identifiersep> node pn , session <identifiersep> key key ) { long rtt ; int max <identifiersep> size ; boolean valid <identifiersep> ack = false ; <LOG> long ack <identifiersep> received = system . current <identifiersep> time <identifiersep> millis ( ) ; sent <identifiersep> packet sent ; synchronized ( sent <identifiersep> packets ) { sent = sent <identifiersep> packets . remove ( ack ) ; max <identifiersep> size = ( max <identifiersep> seen <identifiersep> in <identifiersep> flight * <number_literal> ) + <number_literal> ; } if ( sent != null ) { <ect>
if ( sent != null ) { rtt = sent . acked ( key ) ; valid <identifiersep> ack = true ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ack ) ; long packet <identifiersep> sent = lost <identifiersep> sent <identifiersep> times . query <identifiersep> and <identifiersep> remove ( ack ) ; <LOG> if ( packet <identifiersep> sent < 0 ) { return ; } rtt = ack <identifiersep> received - packet <identifiersep> sent ; } if ( pn == null ) return ; int rt = ( int ) math . min ( rtt , integer . max <identifiersep> value ) ; <ect>
iterator < map . entry < integer , long > > it = acks . entry <identifiersep> set ( ) . iterator ( ) ; while ( it . has <identifiersep> next ( ) && packet . get <identifiersep> length ( ) < max <identifiersep> packet <identifiersep> size ) { map . entry < integer , long > entry = it . next ( ) ; int ack = entry . get <identifiersep> key ( ) ; <comment> <LOG> if ( ! packet . add <identifiersep> ack ( ack , max <identifiersep> packet <identifiersep> size ) ) { break ; } if ( entry . get <identifiersep> value ( ) + max <identifiersep> ack <identifiersep> delay < now ) must <identifiersep> send = true ; if ( moved == null ) { <comment> <ect>
peer <identifiersep> node [ ] peers = crypto . get <identifiersep> peer <identifiersep> nodes ( ) ; if ( node . is <identifiersep> stopping ( ) ) return decoded . shutting <identifiersep> down ; <comment> <LOG> if ( log <identifiersep> debug ) if ( try <identifiersep> process <identifiersep> auth ( buf , offset , length , pn , peer , false , now ) ) { return decoded . decoded ; } if ( pn . handshake <identifiersep> unknown <identifiersep> initiator ( ) ) { <comment> <ect>
<comment> private boolean try <identifiersep> process <identifiersep> auth ( byte [ ] buf , int offset , int length , peer <identifiersep> node pn , peer peer , boolean old <identifiersep> opennet <identifiersep> peer , long now ) { <LOG> block <identifiersep> cipher auth <identifiersep> key = pn . incoming <identifiersep> setup <identifiersep> cipher ; <comment> <ect>
<comment> <LOG> int data <identifiersep> length = ( byte1 < < <number_literal> ) + byte2 ; if ( data <identifiersep> length > length - ( iv <identifiersep> length + hash . length + <number_literal> ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + data <identifiersep> length + <string_literal> + ( length - ( iv <identifiersep> length + hash . length + <number_literal> ) ) + <string_literal> ) ; return false ; } <comment> <ect>
byte [ ] real <identifiersep> hash = sha256 . digest ( payload ) ; if ( message <identifiersep> digest . is <identifiersep> equal ( real <identifiersep> hash , hash ) ) { <comment> <LOG> } else { return false ; } } <comment> <ect>
pcfb . block <identifiersep> decipher ( hash , 0 , hash . length ) ; int data <identifiersep> start = iv <identifiersep> length + digest <identifiersep> length + offset + <number_literal> ; int byte1 = ( ( pcfb . decipher ( buf [ data <identifiersep> start - <number_literal> ] ) ) & 0xff ) ; int byte2 = ( ( pcfb . decipher ( buf [ data <identifiersep> start - 1 ] ) ) & 0xff ) ; int data <identifiersep> length = ( byte1 < < <number_literal> ) + byte2 ; if ( log <identifiersep> debug ) logger . minor ( this , <string_literal> + data <identifiersep> length + <string_literal> + byte1 + <string_literal> + byte2 + ' ) ' ) ; <LOG> if ( data <identifiersep> length > length - ( iv <identifiersep> length + hash . length + <number_literal> ) ) { return false ; } <comment> <ect>
<comment> final int setup <identifiersep> type = payload [ <number_literal> ] ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + packet <identifiersep> type + <string_literal> + version + <string_literal> + neg <identifiersep> type + <string_literal> + setup <identifiersep> type + <string_literal> + reply <identifiersep> to + <string_literal> ) ; <LOG> if ( version != 1 ) { return ; } if ( ! ( neg <identifiersep> type == <number_literal> ) ) { if ( neg <identifiersep> type > <number_literal> ) logger . error ( this , <string_literal> + neg <identifiersep> type ) ; else <ect>
if ( version != 1 ) { logger . error ( this , <string_literal> + version ) ; return ; } if ( ! ( neg <identifiersep> type == <number_literal> ) ) { if ( neg <identifiersep> type > <number_literal> ) logger . error ( this , <string_literal> + neg <identifiersep> type ) ; <LOG> else return ; } <comment> <ect>
<comment> <LOG> } else { } } private void process <identifiersep> decrypted <identifiersep> auth <identifiersep> anon <identifiersep> reply ( final byte [ ] payload , final peer reply <identifiersep> to , final peer <identifiersep> node pn ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + reply <identifiersep> to + <string_literal> + pn + <string_literal> + payload . length ) ; <comment> final int version = payload [ 0 ] ; <comment> <ect>
final int setup <identifiersep> type = payload [ <number_literal> ] ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + packet <identifiersep> type + <string_literal> + version + <string_literal> + neg <identifiersep> type + <string_literal> + setup <identifiersep> type + <string_literal> + reply <identifiersep> to + <string_literal> ) ; if ( version != 1 ) { logger . error ( this , <string_literal> + version ) ; return ; } if ( ! ( neg <identifiersep> type == <number_literal> ) ) { <LOG> if ( neg <identifiersep> type > <number_literal> ) else logger . warning ( this , <string_literal> + neg <identifiersep> type ) ; return ; } <comment> <ect>
if ( neg <identifiersep> type > <number_literal> ) logger . error ( this , <string_literal> + neg <identifiersep> type ) ; else logger . warning ( this , <string_literal> + neg <identifiersep> type ) ; return ; } <comment> <LOG> if ( setup <identifiersep> type != setup <identifiersep> opennet <identifiersep> seednode ) { return ; } <comment> <ect>
logger . minor ( this , <string_literal> + pn . get <identifiersep> peer ( ) + <string_literal> + packet <identifiersep> type + <string_literal> + version + <string_literal> + neg <identifiersep> type + <string_literal> + delta + <string_literal> + reply <identifiersep> to + <string_literal> ) ; } <comment> <LOG> if ( version != 1 ) { return ; } if ( neg <identifiersep> type >= 0 && neg <identifiersep> type < <number_literal> ) { <comment> <ect>
private static long log <identifiersep> no <identifiersep> contexts <identifiersep> interval = minutes . to <identifiersep> millis ( 1 ) ; private void handle <identifiersep> no <identifiersep> contexts <identifiersep> exception ( no <identifiersep> contexts <identifiersep> exception e , freenet . node . fnp <identifiersep> packet <identifiersep> mangler . no <identifiersep> contexts <identifiersep> exception . context context ) { if ( node . get <identifiersep> uptime ( ) < seconds . to <identifiersep> millis ( <number_literal> ) ) { logger . warning ( this , <string_literal> + context + <string_literal> + this ) ; return ; } <LOG> <comment> <ect>
last <identifiersep> logged <identifiersep> no <identifiersep> contexts = now ; } log <identifiersep> loud <identifiersep> error <identifiersep> no <identifiersep> contexts ( ) ; } private void log <identifiersep> loud <identifiersep> error <identifiersep> no <identifiersep> contexts ( ) { <comment> <LOG> system . err . println ( <string_literal> ) ; if ( file <identifiersep> util . detected <identifiersep> os . is <identifiersep> unix ) { file f = new file ( <string_literal> ) ; if ( f . exists ( ) ) system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
<comment> <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } private final lru <identifiersep> map < inet <identifiersep> address , long > throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip = lru <identifiersep> map . create <identifiersep> safe <identifiersep> map ( inet <identifiersep> address <identifiersep> comparator . comparator ) ; private static final int rekey <identifiersep> by <identifiersep> ip <identifiersep> table <identifiersep> size = <number_literal> ; private boolean throttle <identifiersep> rekey ( peer <identifiersep> node pn , peer reply <identifiersep> to ) { if ( pn != null ) { <ect>
long l = throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip . get ( addr ) ; if ( l == null || l != null && now > l ) throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip . push ( addr , now ) ; while ( throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip . size ( ) > rekey <identifiersep> by <identifiersep> ip <identifiersep> table <identifiersep> size || ( ( ! throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip . is <identifiersep> empty ( ) ) && throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip . peek <identifiersep> value ( ) < now - peer <identifiersep> node . throttle <identifiersep> rekey ) ) throttle <identifiersep> rekeys <identifiersep> by <identifiersep> ip . pop <identifiersep> key ( ) ; <LOG> if ( l != null && now - l < peer <identifiersep> node . throttle <identifiersep> rekey ) { return true ; } } return false ; } private static final int max <identifiersep> nonces <identifiersep> per <identifiersep> peer = <number_literal> ; <comment> <ect>
node . random . next <identifiersep> bytes ( my <identifiersep> nonce ) ; byte [ ] my <identifiersep> exponential = ctx . get <identifiersep> public <identifiersep> key <identifiersep> network <identifiersep> format ( ) ; <comment> <LOG> byte [ ] authenticator = hmac . mac <identifiersep> with <identifiersep> sha256 ( get <identifiersep> transient <identifiersep> key ( ) , assemble <identifiersep> jfk <identifiersep> authenticator ( my <identifiersep> exponential , his <identifiersep> exponential , my <identifiersep> nonce , nonce <identifiersep> initator , reply <identifiersep> to . get <identifiersep> address ( ) . get <identifiersep> address ( ) ) ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( nonce <identifiersep> initator ) ) ; byte [ ] message2 = new byte [ nonce <identifiersep> initator . length + nonce <identifiersep> size + modulus <identifiersep> length + sig . length + hash <identifiersep> length ] ; int offset = 0 ; <ect>
<comment> <LOG> if ( payload . length < expected <identifiersep> length + <number_literal> ) { return ; } byte [ ] nonce <identifiersep> initiator = new byte [ nonce <identifiersep> size <identifiersep> hashed ] ; system . arraycopy ( payload , input <identifiersep> offset , nonce <identifiersep> initiator , 0 , nonce <identifiersep> size <identifiersep> hashed ) ; input <identifiersep> offset += nonce <identifiersep> size <identifiersep> hashed ; byte [ ] nonce <identifiersep> responder = new byte [ nonce <identifiersep> size ] ; <ect>
<comment> <LOG> return ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( his <identifiersep> exponential ) + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash ) + <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( sig ) ) ; return ; } <comment> <ect>
<string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( sig ) ) ; return ; } <comment> <LOG> if ( ( t2 - t1 ) > <number_literal> ) { } } <comment> <ect>
if ( payload . length < expected <identifiersep> length + <number_literal> ) { logger . error ( this , <string_literal> + pn + <string_literal> + payload . length + <string_literal> + ( expected <identifiersep> length + <number_literal> ) ) ; return ; } <comment> <LOG> input <identifiersep> offset += nonce <identifiersep> size ; <comment> <ect>
byte [ ] authenticator = arrays . copy <identifiersep> of <identifiersep> range ( payload , input <identifiersep> offset , input <identifiersep> offset + hash <identifiersep> length ) ; input <identifiersep> offset += hash <identifiersep> length ; <comment> <LOG> if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( authenticator ) ) ; logger . normal ( this , <string_literal> + pn ) ; } return ; } <comment> <ect>
byte [ ] hmac = arrays . copy <identifiersep> of <identifiersep> range ( payload , input <identifiersep> offset , input <identifiersep> offset + hash <identifiersep> length ) ; input <identifiersep> offset += hash <identifiersep> length ; byte [ ] computed <identifiersep> exponential ; ec <identifiersep> public <identifiersep> key initiator <identifiersep> key = ecdh . get <identifiersep> public <identifiersep> key ( initiator <identifiersep> exponential , ecdh <identifiersep> curve <identifiersep> to <identifiersep> use ) ; ec <identifiersep> public <identifiersep> key responder <identifiersep> key = ecdh . get <identifiersep> public <identifiersep> key ( responder <identifiersep> exponential , ecdh <identifiersep> curve <identifiersep> to <identifiersep> use ) ; ecdh <identifiersep> light <identifiersep> context ctx = find <identifiersep> ecdh <identifiersep> context <identifiersep> by <identifiersep> pub <identifiersep> key ( responder <identifiersep> key ) ; <LOG> if ( ctx == null ) { <comment> <ect>
int iv <identifiersep> length = pcfb <identifiersep> mode . length <identifiersep> iv ( c ) ; int decyphered <identifiersep> payload <identifiersep> offset = 0 ; <comment> <LOG> if ( ! hmac . verify <identifiersep> with <identifiersep> sha256 ( ka , decyphered <identifiersep> payload , hmac ) ) { return ; } final pcfb <identifiersep> mode pk = pcfb <identifiersep> mode . create ( c , decyphered <identifiersep> payload , decyphered <identifiersep> payload <identifiersep> offset ) ; <comment> <ect>
logger . normal ( this , <string_literal> ) ; } else { logger . error ( this , <string_literal> ) ; } return ; } <comment> <LOG> if ( ! ecdsa . verify ( curves . p256 , pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key , sig , to <identifiersep> verify ) ) { return ; } <comment> <ect>
logger . normal ( this , <string_literal> + pn + <string_literal> ) ; dont <identifiersep> want = true ; opennet . purge <identifiersep> old <identifiersep> opennet <identifiersep> peer ( opn ) ; } <comment> <LOG> logger . error ( this , <string_literal> + pn + <string_literal> ) ; } logger . normal ( this , <string_literal> ) ; dont <identifiersep> want = true ; } long new <identifiersep> tracker <identifiersep> id = pn . completed <identifiersep> handshake ( boot <identifiersep> id , his <identifiersep> ref , 0 , his <identifiersep> ref . length , outgoing <identifiersep> cipher , outgoing <identifiersep> key , incomming <identifiersep> cipher , incomming <identifiersep> key , reply <identifiersep> to , true , neg <identifiersep> type , tracker <identifiersep> id , false , false , hmac <identifiersep> key , iv <identifiersep> cipher , <ect>
pn . maybe <identifiersep> send <identifiersep> initial <identifiersep> messages ( ) ; } } else { logger . error ( this , <string_literal> + pn . get <identifiersep> peer ( ) ) ; <comment> <LOG> if ( ( t2 - t1 ) > <number_literal> ) { } } private peer <identifiersep> node get <identifiersep> peer <identifiersep> node <identifiersep> from <identifiersep> unknown <identifiersep> initiator ( byte [ ] his <identifiersep> ref , int setup <identifiersep> type , peer <identifiersep> node pn , peer from ) { if ( setup <identifiersep> type == setup <identifiersep> opennet <identifiersep> seednode ) { opennet <identifiersep> manager om = node . get <identifiersep> opennet ( ) ; if ( om == null ) { logger . error ( this , <string_literal> ) ; <ect>
opennet <identifiersep> manager om = node . get <identifiersep> opennet ( ) ; if ( om == null ) { logger . error ( this , <string_literal> ) ; <comment> <LOG> if ( ref == null ) { <comment> <ect>
try { seed = new seed <identifiersep> client <identifiersep> peer <identifiersep> node ( ref , node , crypto ) ; <comment> <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e ) { return null ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { <ect>
( c . get <identifiersep> block <identifiersep> size ( ) > > <number_literal> ) + <comment> <LOG> offset += nonce <identifiersep> size ; <comment> <ect>
if ( unknown <identifiersep> initiator ) { send <identifiersep> anon <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , setup <identifiersep> type , message3 , pn , reply <identifiersep> to , pn . anonymous <identifiersep> initiator <identifiersep> setup <identifiersep> cipher ) ; } else { send <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , message3 , pn , reply <identifiersep> to ) ; } } } } , seconds . to <identifiersep> millis ( <number_literal> ) ) ; long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> if ( ( t2 - t1 ) > milliseconds . to <identifiersep> millis ( <number_literal> ) ) } private int get <identifiersep> initial <identifiersep> message <identifiersep> id ( byte [ ] identity ) { message <identifiersep> digest md = sha256 . get <identifiersep> message <identifiersep> digest ( ) ; md . update ( identity ) ; <comment> <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( authenticator ) ) ; } if ( unknown <identifiersep> initiator ) { send <identifiersep> anon <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , setup <identifiersep> type , message4 , pn , reply <identifiersep> to , crypto . anon <identifiersep> setup <identifiersep> cipher ) ; } else { send <identifiersep> auth <identifiersep> packet ( 1 , neg <identifiersep> type , <number_literal> , message4 , pn , reply <identifiersep> to ) ; } long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> if ( ( t2 - t1 ) > <number_literal> ) } <comment> private void send <identifiersep> auth <identifiersep> packet ( int version , int neg <identifiersep> type , int phase , byte [ ] data , peer <identifiersep> node pn , peer reply <identifiersep> to ) { if ( pn == null ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; <ect>
int max <identifiersep> packet <identifiersep> size = sock . get <identifiersep> max <identifiersep> packet <identifiersep> size ( ) ; int padding <identifiersep> length ; if ( pre <identifiersep> padding <identifiersep> length < max <identifiersep> packet <identifiersep> size ) { padding <identifiersep> length = node . fast <identifiersep> weak <identifiersep> random . next <identifiersep> int ( math . min ( <number_literal> , max <identifiersep> packet <identifiersep> size - pre <identifiersep> padding <identifiersep> length ) ) ; } else { padding <identifiersep> length = 0 ; <comment> <LOG> <comment> <ect>
peer peer = pn . get <identifiersep> handshake <identifiersep> ip ( ) ; if ( peer == null ) { pn . could <identifiersep> not <identifiersep> send <identifiersep> handshake ( not <identifiersep> registered ) ; return ; } peer old <identifiersep> peer = peer ; peer = peer . drop <identifiersep> host <identifiersep> name ( ) ; <LOG> if ( peer == null ) { pn . could <identifiersep> not <identifiersep> send <identifiersep> handshake ( not <identifiersep> registered ) ; return ; } try { send <identifiersep> jfk <identifiersep> message1 ( pn , peer , pn . handshake <identifiersep> unknown <identifiersep> initiator ( ) , pn . handshake <identifiersep> setup <identifiersep> type ( ) , neg <identifiersep> type ) ; } catch ( no <identifiersep> contexts <identifiersep> exception e ) { <ect>
previous <identifiersep> output <identifiersep> stat = 0 ; previous <identifiersep> io <identifiersep> stat <identifiersep> time = 1 ; last <identifiersep> input <identifiersep> stat = 0 ; last <identifiersep> output <identifiersep> stat = 0 ; last <identifiersep> io <identifiersep> stat <identifiersep> time = <number_literal> ; int default <identifiersep> thread <identifiersep> limit ; <LOG> long memory <identifiersep> limit = node <identifiersep> starter . get <identifiersep> memory <identifiersep> limit <identifiersep> mb ( ) ; if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; <ect>
long memory <identifiersep> limit = node <identifiersep> starter . get <identifiersep> memory <identifiersep> limit <identifiersep> mb ( ) ; system . out . println ( <string_literal> + memory <identifiersep> limit + <string_literal> ) ; if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { <LOG> default <identifiersep> thread <identifiersep> limit = <number_literal> ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; } else { system . out . println ( <string_literal> ) ; <ect>
} else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; } else if ( memory <identifiersep> limit > 0 && memory <identifiersep> limit < <number_literal> ) { default <identifiersep> thread <identifiersep> limit = <number_literal> ; system . out . println ( <string_literal> ) ; <LOG> } else { default <identifiersep> thread <identifiersep> limit = <number_literal> ; } stats <identifiersep> config . register ( <string_literal> , default <identifiersep> thread <identifiersep> limit , sort <identifiersep> order ++ , true , true , <string_literal> , <string_literal> , new int <identifiersep> callback ( ) { @ override public integer get ( ) { <ect>
if ( non <identifiersep> overhead <identifiersep> fraction < min <identifiersep> non <identifiersep> overhead ) { <comment> <LOG> <comment> <ect>
source . on <identifiersep> set <identifiersep> peer <identifiersep> allocation ( input , ( int ) this <identifiersep> allocation , transfers <identifiersep> per <identifiersep> insert , max <identifiersep> output <identifiersep> transfers , real <identifiersep> time <identifiersep> flag ) ; } <comment> <LOG> if ( bandwidth <identifiersep> liability <identifiersep> output > bandwidth <identifiersep> available <identifiersep> output <identifiersep> upper <identifiersep> limit ) { } if ( bandwidth <identifiersep> liability <identifiersep> output > bandwidth <identifiersep> available <identifiersep> output <identifiersep> lower <identifiersep> limit ) { <comment> <ect>
public synchronized void request <identifiersep> received <identifiersep> bytes ( boolean ssk , int x ) { if ( ssk ) ssk <identifiersep> request <identifiersep> rcvd <identifiersep> bytes += x ; else chk <identifiersep> request <identifiersep> rcvd <identifiersep> bytes += x ; } public synchronized void insert <identifiersep> sent <identifiersep> bytes ( boolean ssk , int x ) { <LOG> if ( log <identifiersep> debug ) if ( ssk ) ssk <identifiersep> insert <identifiersep> sent <identifiersep> bytes += x ; else chk <identifiersep> insert <identifiersep> sent <identifiersep> bytes += x ; } public synchronized void insert <identifiersep> received <identifiersep> bytes ( boolean ssk , int x ) { <ect>
public synchronized long get <identifiersep> announce <identifiersep> bytes <identifiersep> payload <identifiersep> sent ( ) { return announce <identifiersep> bytes <identifiersep> payload ; } private long routing <identifiersep> status <identifiersep> bytes <identifiersep> sent ; byte <identifiersep> counter set <identifiersep> routing <identifiersep> status <identifiersep> ctr = new byte <identifiersep> counter ( ) { @ override public void received <identifiersep> bytes ( int x ) { <LOG> <comment> <ect>
logger . error ( this , <string_literal> + this + <string_literal> + new <identifiersep> loc + ' ) ' , new exception ( <string_literal> ) ) ; <comment> <LOG> if ( ! location . is <identifiersep> valid ( loc ) ) { <comment> <ect>
return super . to <identifiersep> string ( ) + <string_literal> + uid ; } @ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try { real <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { } finally { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; tag . unlock <identifiersep> handler ( ) ; } } private void real <identifiersep> run ( ) { <comment> <ect>
} else if ( msg . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ) { try { source . send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , msg . get <identifiersep> short ( dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> reason ) ) , null , this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> } else { } } try { key . set <identifiersep> pub <identifiersep> key ( pub <identifiersep> key ) ; block = new ssk <identifiersep> block ( data , headers , key , false ) ; } catch ( ssk <identifiersep> verify <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + source , e1 ) ; <ect>
if ( ( stored <identifiersep> block != null ) && ! stored <identifiersep> block . equals ( block ) ) { try { request <identifiersep> handler . send <identifiersep> ssk ( stored <identifiersep> block . get <identifiersep> raw <identifiersep> headers ( ) , stored <identifiersep> block . get <identifiersep> raw <identifiersep> data ( ) , false , pub <identifiersep> key , source , uid , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; <LOG> } catch ( waited <identifiersep> too <identifiersep> long <identifiersep> exception e1 ) { return ; } catch ( peer <identifiersep> restarted <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <ect>
throw new error ( <string_literal> + e1 , e1 ) ; } try { request <identifiersep> handler . send <identifiersep> ssk ( headers , data , false , pub <identifiersep> key , source , uid , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e1 ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; <LOG> } catch ( waited <identifiersep> too <identifiersep> long <identifiersep> exception e1 ) { return ; } catch ( peer <identifiersep> restarted <identifiersep> exception e ) { logger . error ( this , <string_literal> + uid ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <ect>
public void remove <identifiersep> routing <identifiersep> to ( peer <identifiersep> node next ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + next + <string_literal> + this , new exception ( <string_literal> ) ) ; boolean no <identifiersep> record <identifiersep> unlock ; synchronized ( this ) { if ( currently <identifiersep> routing <identifiersep> to == null ) return ; <LOG> if ( ! currently <identifiersep> routing <identifiersep> to . remove ( next ) ) { } if ( handling <identifiersep> timeouts != null ) { handling <identifiersep> timeouts . remove ( next ) ; } if ( ! must <identifiersep> unlock ( ) ) return ; no <identifiersep> record <identifiersep> unlock = this . no <identifiersep> record <identifiersep> unlock ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; <ect>
if ( log <identifiersep> minor ) logger . debug ( this , <string_literal> + pn . short <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; break ; } expected = false ; } } if ( ! expected ) { if ( handling <identifiersep> timeouts != null ) logger . normal ( this , <string_literal> + currently <identifiersep> routing <identifiersep> to + <string_literal> ) ; <LOG> else } else reassign <identifiersep> to <identifiersep> self ( ) ; } return false ; } if ( fetching <identifiersep> offered <identifiersep> key <identifiersep> from != null && ! fetching <identifiersep> offered <identifiersep> key <identifiersep> from . is <identifiersep> empty ( ) ) { if ( ! ( reassigned || was <identifiersep> local ) ) { <ect>
for ( peer <identifiersep> node pn : fetching <identifiersep> offered <identifiersep> key <identifiersep> from ) { if ( handling <identifiersep> timeouts . contains ( pn ) ) { if ( log <identifiersep> minor ) logger . debug ( this , <string_literal> + pn . short <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; break ; } expected = false ; } } if ( ! expected ) <LOG> <comment> <ect>
} else { trust <identifiersep> level = node . security <identifiersep> levels . get <identifiersep> default <identifiersep> friend <identifiersep> trust ( ) ; system . err . println ( <string_literal> + name + <string_literal> + trust <identifiersep> level ) ; } s = metadata . get ( <string_literal> ) ; if ( s != null ) { our <identifiersep> visibility = friend <identifiersep> visibility . value <identifiersep> of ( s ) ; <LOG> } else { node . create <identifiersep> visibility <identifiersep> alert ( ) ; our <identifiersep> visibility = friend <identifiersep> visibility . no ; } s = metadata . get ( <string_literal> ) ; if ( s != null ) { their <identifiersep> visibility = friend <identifiersep> visibility . value <identifiersep> of ( s ) ; <ect>
return ! got <identifiersep> error ; } public boolean reread <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( int file <identifiersep> number ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + file <identifiersep> number + <string_literal> + short <identifiersep> to <identifiersep> string ( ) ) ; string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; <LOG> if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { return false ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) + file . separator + file <identifiersep> number ) ; <ect>
logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) + file . separator + file <identifiersep> number ) ; <LOG> if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { return false ; } return read <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( extra <identifiersep> peer <identifiersep> data <identifiersep> file , file <identifiersep> number ) ; } public boolean read <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( file extra <identifiersep> peer <identifiersep> data <identifiersep> file , int file <identifiersep> number ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file + <string_literal> + file <identifiersep> number + <string_literal> + short <identifiersep> to <identifiersep> string ( ) ) ; boolean got <identifiersep> error = false ; <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e5 ) { } } if ( fs == null ) { logger . normal ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file ) ; delete <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( file <identifiersep> number ) ; return true ; } boolean parse <identifiersep> result = false ; <ect>
return ! got <identifiersep> error ; } private boolean parse <identifiersep> extra <identifiersep> peer <identifiersep> data ( simple <identifiersep> field <identifiersep> set fs , file extra <identifiersep> peer <identifiersep> data <identifiersep> file , int file <identifiersep> number ) throws fs <identifiersep> parse <identifiersep> exception { string extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> string = fs . get ( <string_literal> ) ; int extra <identifiersep> peer <identifiersep> data <identifiersep> type = - 1 ; try { extra <identifiersep> peer <identifiersep> data <identifiersep> type = integer . parse <identifiersep> int ( extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> string ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return false ; } if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type == node . extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> n2ntm ) { node . handle <identifiersep> node <identifiersep> to <identifiersep> node <identifiersep> text <identifiersep> message <identifiersep> simple <identifiersep> field <identifiersep> set ( fs , this , file <identifiersep> number ) ; return true ; } else if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type == node . extra <identifiersep> peer <identifiersep> data <identifiersep> type <identifiersep> peer <identifiersep> note ) { <ect>
logger . error ( this , <string_literal> + peer <identifiersep> note <identifiersep> type <identifiersep> string + <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ) ; return false ; } if ( peer <identifiersep> note <identifiersep> type == node . peer <identifiersep> note <identifiersep> type <identifiersep> private <identifiersep> darknet <identifiersep> comment ) { synchronized ( this ) { try { private <identifiersep> darknet <identifiersep> comment = base64 . decode <identifiersep> utf8 ( fs . get ( <string_literal> ) ) ; <LOG> } catch ( illegal <identifiersep> base64exception e ) { return false ; } private <identifiersep> darknet <identifiersep> comment <identifiersep> file <identifiersep> number = file <identifiersep> number ; } return true ; } logger . error ( this , <string_literal> + peer <identifiersep> note <identifiersep> type + <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ) ; return false ; <ect>
fs . put <identifiersep> overwrite ( <string_literal> , string . value <identifiersep> of ( file <identifiersep> number ) ) ; if ( fs . get ( <string_literal> ) != null ) { fs . remove <identifiersep> value ( <string_literal> ) ; } fs . put <identifiersep> overwrite ( <string_literal> , long . to <identifiersep> string ( system . current <identifiersep> time <identifiersep> millis ( ) ) ) ; try { n2nm = dmt . create <identifiersep> node <identifiersep> to <identifiersep> node <identifiersep> message ( type , fs . to <identifiersep> string ( ) . get <identifiersep> bytes ( <string_literal> ) ) ; <LOG> } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { throw new error ( <string_literal> + e , e ) ; } try { synchronized ( queued <identifiersep> to <identifiersep> send <identifiersep> n2nm <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers ) { node . usm . send ( this , n2nm , null ) ; logger . normal ( this , <string_literal> + file <identifiersep> number + <string_literal> + get <identifiersep> name ( ) + <string_literal> + n2nm ) ; <ect>
public int write <identifiersep> new <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( simple <identifiersep> field <identifiersep> set fs , int extra <identifiersep> peer <identifiersep> data <identifiersep> type ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type > 0 ) fs . put <identifiersep> overwrite ( <string_literal> , integer . to <identifiersep> string ( extra <identifiersep> peer <identifiersep> data <identifiersep> type ) ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { <LOG> if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . mkdir ( ) ) { return - 1 ; } } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return - 1 ; } integer [ ] local <identifiersep> file <identifiersep> numbers ; <ect>
if ( local <identifiersep> file <identifiersep> number > next <identifiersep> file <identifiersep> number ) { break ; } next <identifiersep> file <identifiersep> number = local <identifiersep> file <identifiersep> number + 1 ; } extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers . add ( next <identifiersep> file <identifiersep> number ) ; } file <identifiersep> output <identifiersep> stream fos ; file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) + file . separator + next <identifiersep> file <identifiersep> number ) ; <LOG> if ( extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { return - 1 ; } string f = extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ; try { fos = new file <identifiersep> output <identifiersep> stream ( f ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e2 ) { <ect>
fs . write <identifiersep> to ( bw ) ; bw . close ( ) ; } catch ( io <identifiersep> exception e ) { try { fos . close ( ) ; } catch ( io <identifiersep> exception e1 ) { <LOG> logger . error ( this , <string_literal> + e , e ) ; } return - 1 ; } return next <identifiersep> file <identifiersep> number ; } public void delete <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( int file <identifiersep> number ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path , get <identifiersep> identity <identifiersep> string ( ) ) ; <ect>
public void delete <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> file ( int file <identifiersep> number ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path , get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return ; } <LOG> if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { return ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir , integer . to <identifiersep> string ( file <identifiersep> number ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ) ; return ; <ect>
if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ) ; return ; } synchronized ( extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers ) { extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers . remove ( file <identifiersep> number ) ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . delete ( ) ) { <LOG> if ( extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { } else { logger . normal ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file + <string_literal> + get <identifiersep> peer ( ) ) ; } } } public void remove <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; <ect>
public void remove <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) { string extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path = node . get <identifiersep> extra <identifiersep> peer <identifiersep> data <identifiersep> dir ( ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return ; } <LOG> if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { return ; } integer [ ] local <identifiersep> file <identifiersep> numbers ; synchronized ( extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers ) { local <identifiersep> file <identifiersep> numbers = extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers . to <identifiersep> array ( new integer [ extra <identifiersep> peer <identifiersep> data <identifiersep> file <identifiersep> numbers . size ( ) ] ) ; } for ( integer local <identifiersep> file <identifiersep> number : local <identifiersep> file <identifiersep> numbers ) { <ect>
if ( extra <identifiersep> peer <identifiersep> data <identifiersep> type > 0 ) fs . put <identifiersep> overwrite ( <string_literal> , integer . to <identifiersep> string ( extra <identifiersep> peer <identifiersep> data <identifiersep> type ) ) ; file extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } <LOG> if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { return false ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) + file . separator + file <identifiersep> number ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ) ; return false ; <ect>
string text = null ; long composed <identifiersep> time = fs . get <identifiersep> long ( <string_literal> , - 1 ) ; long sent <identifiersep> time = fs . get <identifiersep> long ( <string_literal> , - 1 ) ; long received <identifiersep> time = fs . get <identifiersep> long ( <string_literal> , - 1 ) ; try { text = base64 . decode <identifiersep> utf8 ( fs . get ( <string_literal> ) ) ; <LOG> } catch ( illegal <identifiersep> base64exception e ) { return ; } n2ntm <identifiersep> user <identifiersep> alert user <identifiersep> alert = new n2ntm <identifiersep> user <identifiersep> alert ( this , text , file <identifiersep> number , composed <identifiersep> time , sent <identifiersep> time , received <identifiersep> time ) ; node . client <identifiersep> core . alerts . register ( user <identifiersep> alert ) ; } public void handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { final file <identifiersep> offer offer ; <ect>
public void accept <identifiersep> transfer ( long id ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + id + <string_literal> + this ) ; file <identifiersep> offer fo ; synchronized ( this ) { fo = his <identifiersep> file <identifiersep> offers <identifiersep> by <identifiersep> uid . get ( id ) ; } <LOG> if ( fo == null ) { return ; } fo . accept ( ) ; } public void reject <identifiersep> transfer ( long id ) { file <identifiersep> offer fo ; synchronized ( this ) { <ect>
public void handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer <identifiersep> accepted ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { <comment> <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; file <identifiersep> offer fo ; synchronized ( this ) { <ect>
send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> bulk <identifiersep> send <identifiersep> aborted ( uid ) , null , node . node <identifiersep> stats . node <identifiersep> to <identifiersep> node <identifiersep> counter ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> } catch ( disconnected <identifiersep> exception e ) { } } public void handle <identifiersep> fproxy <identifiersep> file <identifiersep> offer <identifiersep> rejected ( simple <identifiersep> field <identifiersep> set fs , int file <identifiersep> number ) { <comment> <ect>
long received <identifiersep> time = fs . get <identifiersep> long ( <string_literal> , - 1 ) ; try { string s = fs . get ( <string_literal> ) ; if ( s != null ) description = base64 . decode <identifiersep> utf8 ( s ) ; uri = new freenet <identifiersep> uri ( fs . get ( <string_literal> ) ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { return ; } catch ( illegal <identifiersep> base64exception e ) { logger . error ( this , <string_literal> , e ) ; return ; } bookmark <identifiersep> feed <identifiersep> user <identifiersep> alert user <identifiersep> alert = new bookmark <identifiersep> feed <identifiersep> user <identifiersep> alert ( this , name , description , has <identifiersep> an <identifiersep> active <identifiersep> link , file <identifiersep> number , uri , composed <identifiersep> time , sent <identifiersep> time , received <identifiersep> time ) ; <ect>
long received <identifiersep> time = fs . get <identifiersep> long ( <string_literal> , - 1 ) ; try { string s = fs . get ( <string_literal> ) ; if ( s != null ) description = base64 . decode <identifiersep> utf8 ( s ) ; uri = new freenet <identifiersep> uri ( fs . get ( <string_literal> ) ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { return ; } catch ( illegal <identifiersep> base64exception e ) { logger . error ( this , <string_literal> , e ) ; return ; } download <identifiersep> feed <identifiersep> user <identifiersep> alert user <identifiersep> alert = new download <identifiersep> feed <identifiersep> user <identifiersep> alert ( this , description , file <identifiersep> number , uri , composed <identifiersep> time , sent <identifiersep> time , received <identifiersep> time ) ; <ect>
peer <identifiersep> added <identifiersep> time = 0 ; if ( ! never <identifiersep> connected ) peer <identifiersep> added <identifiersep> time = 0 ; } <comment> <LOG> if ( node . is <identifiersep> stopping ( ) ) return ; system . err . println ( <string_literal> + get <identifiersep> name ( ) + <string_literal> + get <identifiersep> peer ( ) + <string_literal> + get <identifiersep> version ( ) + <string_literal> ) ; <comment> <ect>
} catch ( not <identifiersep> connected <identifiersep> exception e ) { logger . normal ( this , <string_literal> ) ; } } private void send <identifiersep> visibility ( ) throws not <identifiersep> connected <identifiersep> exception { send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> visibility ( get <identifiersep> our <identifiersep> visibility ( ) . code ) , null , node . node <identifiersep> stats . initial <identifiersep> messages <identifiersep> ctr ) ; } public void handle <identifiersep> visibility ( message m ) { friend <identifiersep> visibility v = friend <identifiersep> visibility . get <identifiersep> by <identifiersep> code ( m . get <identifiersep> short ( dmt . friend <identifiersep> visibility ) ) ; <LOG> if ( v == null ) { v = friend <identifiersep> visibility . no ; } synchronized ( this ) { if ( their <identifiersep> visibility == v ) return ; their <identifiersep> visibility = v ; } node . peers . write <identifiersep> peers <identifiersep> darknet ( ) ; <ect>
inflater <identifiersep> input <identifiersep> stream dis = new inflater <identifiersep> input <identifiersep> stream ( bais ) ; simple <identifiersep> field <identifiersep> set fs ; try { fs = new simple <identifiersep> field <identifiersep> set ( new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( dis , <string_literal> ) ) , false , false ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { <LOG> receiving <identifiersep> full <identifiersep> noderef = false ; } e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } catch ( io <identifiersep> exception e ) { synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { receiving <identifiersep> full <identifiersep> noderef = false ; <ect>
synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { receiving <identifiersep> full <identifiersep> noderef = false ; } logger . error ( this , <string_literal> + e , e ) ; return ; } try { process <identifiersep> new <identifiersep> noderef ( fs , false , false , true ) ; <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { receiving <identifiersep> full <identifiersep> noderef = false ; } return ; } synchronized ( darknet <identifiersep> peer <identifiersep> node . this ) { full <identifiersep> field <identifiersep> set = fs ; <ect>
throw e ; } } @ override protected void send <identifiersep> initial <identifiersep> messages ( ) { super . send <identifiersep> initial <identifiersep> messages ( ) ; try { send <identifiersep> visibility ( ) ; <LOG> } catch ( not <identifiersep> connected <identifiersep> exception e ) { } if ( ! dont <identifiersep> keep <identifiersep> full <identifiersep> field <identifiersep> set ( ) ) { try { send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> get <identifiersep> your <identifiersep> full <identifiersep> noderef ( ) , null , node . node <identifiersep> stats . foaf <identifiersep> counter ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
incoming <identifiersep> setup <identifiersep> cipher = new rijndael ( <number_literal> , <number_literal> ) ; incoming <identifiersep> setup <identifiersep> cipher . initialize ( incoming <identifiersep> setup <identifiersep> key ) ; outgoing <identifiersep> setup <identifiersep> cipher = new rijndael ( <number_literal> , <number_literal> ) ; outgoing <identifiersep> setup <identifiersep> cipher . initialize ( outgoing <identifiersep> setup <identifiersep> key ) ; anonymous <identifiersep> initiator <identifiersep> setup <identifiersep> cipher = new rijndael ( <number_literal> , <number_literal> ) ; anonymous <identifiersep> initiator <identifiersep> setup <identifiersep> cipher . initialize ( identity <identifiersep> hash ) ; <LOG> } catch ( unsupported <identifiersep> cipher <identifiersep> exception e1 ) { throw new error ( e1 ) ; } nominal <identifiersep> peer = new array <identifiersep> list < peer > ( ) ; try { string physical [ ] = fs . get <identifiersep> all ( <string_literal> ) ; if ( physical == null ) { <ect>
for ( string phys : physical ) { peer p ; try { p = new peer ( phys , true , true ) ; } catch ( hostname <identifiersep> syntax <identifiersep> exception e ) { if ( from <identifiersep> local ) <LOG> logger . error ( this , <string_literal> + phys ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; <ect>
if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { if ( from <identifiersep> local ) <LOG> logger . error ( this , <string_literal> + phys ) ; continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; <ect>
if ( from <identifiersep> local ) logger . error ( this , <string_literal> + phys ) ; system . err . println ( <string_literal> + phys ) ; continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { if ( from <identifiersep> local ) <LOG> logger . error ( this , <string_literal> + phys ) ; continue ; } if ( ! nominal <identifiersep> peer . contains ( p ) ) nominal <identifiersep> peer . add ( p ) ; } } } catch ( exception e1 ) { throw new fs <identifiersep> parse <identifiersep> exception ( e1 ) ; <ect>
if ( detected <identifiersep> udp <identifiersep> string != null ) p = new peer ( detected <identifiersep> udp <identifiersep> string , false ) ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { p = null ; logger . error ( this , <string_literal> + metadata . get ( <string_literal> ) + <string_literal> + e , e ) ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { <LOG> p = null ; } if ( p != null ) detected <identifiersep> peer = p ; update <identifiersep> short <identifiersep> to <identifiersep> string ( ) ; time <identifiersep> last <identifiersep> received <identifiersep> packet = metadata . get <identifiersep> long ( <string_literal> , - 1 ) ; long time <identifiersep> last <identifiersep> connected = metadata . get <identifiersep> long ( <string_literal> , - 1 ) ; <ect>
ark = my <identifiersep> ark . copy ( ark <identifiersep> no ) ; } else if ( for <identifiersep> diff <identifiersep> node <identifiersep> ref && ark <identifiersep> pub <identifiersep> key != null && my <identifiersep> ark != null && ark <identifiersep> no < = - 1 ) { <comment> <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { } catch ( number <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + e , e ) ; } synchronized ( this ) { if ( ark != null ) { if ( ( my <identifiersep> ark == null ) || ( ( my <identifiersep> ark != ark ) && ! my <identifiersep> ark . equals ( ark ) ) ) { <ect>
output <identifiersep> load <identifiersep> tracker <identifiersep> real <identifiersep> time . fail <identifiersep> slot <identifiersep> waiters ( true ) ; output <identifiersep> load <identifiersep> tracker <identifiersep> bulk . fail <identifiersep> slot <identifiersep> waiters ( true ) ; load <identifiersep> sender <identifiersep> real <identifiersep> time . on <identifiersep> disconnect ( ) ; load <identifiersep> sender <identifiersep> bulk . on <identifiersep> disconnect ( ) ; return ret ; } @ override <LOG> public void force <identifiersep> disconnect ( ) { disconnected ( true , true ) ; <comment> <ect>
<comment> public void send <identifiersep> sync ( message req , byte <identifiersep> counter ctr , boolean real <identifiersep> time ) throws not <identifiersep> connected <identifiersep> exception , sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception { sync <identifiersep> message <identifiersep> callback cb = new sync <identifiersep> message <identifiersep> callback ( ) ; message <identifiersep> item item = send <identifiersep> async ( req , cb , ctr ) ; cb . wait <identifiersep> for <identifiersep> send ( minutes . to <identifiersep> millis ( 1 ) ) ; <LOG> if ( ! cb . done ) { this . local <identifiersep> rejected <identifiersep> overload ( <string_literal> , real <identifiersep> time ) ; <comment> <ect>
public void changed <identifiersep> ip ( peer new <identifiersep> peer ) { set <identifiersep> detected <identifiersep> peer ( new <identifiersep> peer ) ; } private void set <identifiersep> detected <identifiersep> peer ( peer new <identifiersep> peer ) { <comment> <LOG> if ( new <identifiersep> peer == null ) { return ; } synchronized ( this ) { peer old <identifiersep> peer = detected <identifiersep> peer ; if ( ( new <identifiersep> peer != null ) && ( ( old <identifiersep> peer == null ) || ! old <identifiersep> peer . equals ( new <identifiersep> peer ) ) ) { this . detected <identifiersep> peer = new <identifiersep> peer ; <ect>
<comment> <LOG> is <identifiersep> connected . set ( false , now ) ; } node . peers . disconnected ( this ) ; return - 1 ; } boolean routable = true ; boolean newer = false ; boolean older = false ; <ect>
if ( arrays . equals ( outgoing <identifiersep> key , current <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( incomming <identifiersep> key , current <identifiersep> tracker . incomming <identifiersep> key ) ) { logger . error ( this , <string_literal> ) ; return - 1 ; } } if ( previous <identifiersep> tracker != null ) { if ( arrays . equals ( outgoing <identifiersep> key , previous <identifiersep> tracker . outgoing <identifiersep> key ) <LOG> && arrays . equals ( incomming <identifiersep> key , previous <identifiersep> tracker . incomming <identifiersep> key ) ) { return - 1 ; } } if ( unverified <identifiersep> tracker != null ) { if ( arrays . equals ( outgoing <identifiersep> key , unverified <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( incomming <identifiersep> key , unverified <identifiersep> tracker . incomming <identifiersep> key ) ) { logger . error ( this , <string_literal> ) ; <ect>
is <identifiersep> rekeying = false ; time <identifiersep> last <identifiersep> rekeyed = now - ( unverified ? 0 : fnp <identifiersep> packet <identifiersep> mangler . max <identifiersep> session <identifiersep> key <identifiersep> rekeying <identifiersep> delay / <number_literal> ) ; total <identifiersep> bytes <identifiersep> exchanged <identifiersep> with <identifiersep> current <identifiersep> tracker = 0 ; <comment> <LOG> arrays . equals ( current <identifiersep> tracker . incomming <identifiersep> key , previous <identifiersep> tracker . incomming <identifiersep> key ) ) if ( previous <identifiersep> tracker != null && unverified <identifiersep> tracker != null && arrays . equals ( previous <identifiersep> tracker . outgoing <identifiersep> key , unverified <identifiersep> tracker . outgoing <identifiersep> key ) && arrays . equals ( previous <identifiersep> tracker . incomming <identifiersep> key , unverified <identifiersep> tracker . incomming <identifiersep> key ) ) logger . error ( this , <string_literal> + previous <identifiersep> tracker + <string_literal> + unverified <identifiersep> tracker ) ; time <identifiersep> last <identifiersep> sent <identifiersep> packet = now ; <ect>
if ( is <identifiersep> real <identifiersep> connection ( ) ) send <identifiersep> async ( loc <identifiersep> msg , null , node . node <identifiersep> stats . initial <identifiersep> messages <identifiersep> ctr ) ; send <identifiersep> async ( ip <identifiersep> msg , null , node . node <identifiersep> stats . initial <identifiersep> messages <identifiersep> ctr ) ; send <identifiersep> async ( time <identifiersep> msg , null , node . node <identifiersep> stats . initial <identifiersep> messages <identifiersep> ctr ) ; send <identifiersep> async ( d <identifiersep> routing <identifiersep> msg , null , node . node <identifiersep> stats . initial <identifiersep> messages <identifiersep> ctr ) ; send <identifiersep> async ( uptime <identifiersep> msg , null , node . node <identifiersep> stats . initial <identifiersep> messages <identifiersep> ctr ) ; <LOG> } catch ( not <identifiersep> connected <identifiersep> exception e ) { } send <identifiersep> connected <identifiersep> diff <identifiersep> noderef ( ) ; } private void send <identifiersep> ip <identifiersep> address <identifiersep> message ( ) { message ip <identifiersep> msg = dmt . create <identifiersep> fnp <identifiersep> detected <identifiersep> ip <identifiersep> address ( detected <identifiersep> peer ) ; try { send <identifiersep> async ( ip <identifiersep> msg , null , node . node <identifiersep> stats . changed <identifiersep> ip <identifiersep> ctr ) ; <ect>
nominal <identifiersep> peer = new array <identifiersep> list < peer > ( physical . length ) ; peer [ ] old <identifiersep> peers = old <identifiersep> nominal <identifiersep> peer . to <identifiersep> array ( new peer [ old <identifiersep> nominal <identifiersep> peer . size ( ) ] ) ; for ( string phys : physical ) { peer p ; try { p = new peer ( phys , true , true ) ; <LOG> } catch ( hostname <identifiersep> syntax <identifiersep> exception e ) { continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + phys ) ; continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <ect>
logger . error ( this , <string_literal> + phys ) ; continue ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + phys ) ; continue ; } catch ( unknown <identifiersep> host <identifiersep> exception e ) { <LOG> <comment> <ect>
} else if ( for <identifiersep> ark || for <identifiersep> full <identifiersep> node <identifiersep> ref ) { <comment> <LOG> } catch ( exception e1 ) { throw new fs <identifiersep> parse <identifiersep> exception ( e1 ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + changed <identifiersep> anything ) ; int [ ] new <identifiersep> neg <identifiersep> types = fs . get <identifiersep> int <identifiersep> array ( <string_literal> ) ; boolean ref <identifiersep> had <identifiersep> neg <identifiersep> types = false ; <ect>
throw new fs <identifiersep> parse <identifiersep> exception ( e ) ; } if ( pub . length > ecdsa . curves . p256 . modulus <identifiersep> size ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; ec <identifiersep> public <identifiersep> key key = ecdsa . get <identifiersep> public <identifiersep> key ( pub , ecdsa . curves . p256 ) ; if ( key == null ) throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; <LOG> if ( ! key . equals ( peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key ) ) { + <string_literal> ) ; throw new fs <identifiersep> parse <identifiersep> exception ( <string_literal> ) ; } } if ( parse <identifiersep> ark ( fs , false , for <identifiersep> diff <identifiersep> node <identifiersep> ref ) ) changed <identifiersep> anything = true ; if ( should <identifiersep> update <identifiersep> peer <identifiersep> counts ) { <ect>
synchronized ( this ) { handshake <identifiersep> count = 0 ; <comment> <LOG> } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <comment> <ect>
if ( is <identifiersep> connected ( ) || my <identifiersep> ark . suggested <identifiersep> edition > edition ) { result . as <identifiersep> bucket ( ) . free ( ) ; return ; } byte [ ] data ; try { data = result . as <identifiersep> byte <identifiersep> array ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { result . as <identifiersep> bucket ( ) . free ( ) ; return ; } string ref ; try { ref = new string ( data , <string_literal> ) ; <ect>
if ( ! should <identifiersep> send <identifiersep> handshake ( ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> peer ( ) + <string_literal> ) ; return null ; } long first <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; local <identifiersep> handshake <identifiersep> i <identifiersep> ps = get <identifiersep> handshake <identifiersep> i <identifiersep> ps ( ) ; long second <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> if ( ( second <identifiersep> time - first <identifiersep> time ) > <number_literal> ) if ( local <identifiersep> handshake <identifiersep> i <identifiersep> ps . length == 0 ) { long third <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; if ( ( third <identifiersep> time - second <identifiersep> time ) > <number_literal> ) logger . error ( this , <string_literal> + ( third <identifiersep> time - second <identifiersep> time ) + <string_literal> + user <identifiersep> to <identifiersep> string ( ) ) ; return null ; <ect>
<comment> static final int max <identifiersep> consecutive <identifiersep> rto <identifiersep> backoffs = <number_literal> ; @ override public synchronized void backoff <identifiersep> on <identifiersep> resend ( ) { <LOG> if ( rto >= max <identifiersep> rto ) { } rto = rto * <number_literal> ; if ( rto > max <identifiersep> rto ) rto = max <identifiersep> rto ; consecutive <identifiersep> rto <identifiersep> backoffs ++ ; if ( consecutive <identifiersep> rto <identifiersep> backoffs > max <identifiersep> consecutive <identifiersep> rto <identifiersep> backoffs ) { <ect>
<comment> <LOG> if ( wait <identifiersep> end - wait <identifiersep> start > ( real <identifiersep> time ? <number_literal> : <number_literal> ) ) { } else if ( wait <identifiersep> end - wait <identifiersep> start > ( real <identifiersep> time ? <number_literal> : <number_literal> ) ) { logger . normal ( this , <string_literal> + ( wait <identifiersep> end - wait <identifiersep> start ) + <string_literal> + this ) ; } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( wait <identifiersep> end - wait <identifiersep> start ) + <string_literal> + this ) ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + accepted <identifiersep> by + <string_literal> + waiting <identifiersep> for . size ( ) + <string_literal> + failed + <string_literal> + this ) ; <ect>
if ( our <identifiersep> usage + their <identifiersep> usage < stats . max <identifiersep> transfers <identifiersep> out <identifiersep> lower <identifiersep> limit ) return request <identifiersep> likely <identifiersep> accepted <identifiersep> state . likely ; else return request <identifiersep> likely <identifiersep> accepted <identifiersep> state . unlikely ; } public void set <identifiersep> dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ( ) { synchronized ( routed <identifiersep> to <identifiersep> lock ) { <LOG> if ( ! dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ) { dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed = true ; } } } public void clear <identifiersep> dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ( ) { synchronized ( routed <identifiersep> to <identifiersep> lock ) { if ( dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ) { logger . error ( this , <string_literal> + peer <identifiersep> node . this + <string_literal> + real <identifiersep> time ) ; <ect>
public static string localised <identifiersep> name ( network <identifiersep> threat <identifiersep> level new <identifiersep> threat <identifiersep> level ) { return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + new <identifiersep> threat <identifiersep> level . name ( ) ) ; } public static string localised <identifiersep> name ( physical <identifiersep> threat <identifiersep> level new <identifiersep> physical <identifiersep> level ) { return node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> + new <identifiersep> physical <identifiersep> level . name ( ) ) ; } public friend <identifiersep> trust get <identifiersep> default <identifiersep> friend <identifiersep> trust ( ) { synchronized ( this ) { <LOG> if ( friends <identifiersep> threat <identifiersep> level == null ) { return friend <identifiersep> trust . normal ; } if ( friends <identifiersep> threat <identifiersep> level == friends <identifiersep> threat <identifiersep> level . high ) return friend <identifiersep> trust . low ; if ( friends <identifiersep> threat <identifiersep> level == friends <identifiersep> threat <identifiersep> level . normal ) return friend <identifiersep> trust . normal ; <ect>
<comment> private peer <identifiersep> addition <identifiersep> return <identifiersep> codes add <identifiersep> new <identifiersep> node ( string node <identifiersep> reference , string private <identifiersep> comment , friend <identifiersep> trust trust , friend <identifiersep> visibility visibility ) { simple <identifiersep> field <identifiersep> set fs ; try { node <identifiersep> reference = fields . trim <identifiersep> lines ( node <identifiersep> reference ) ; fs = new simple <identifiersep> field <identifiersep> set ( node <identifiersep> reference , false , true , true ) ; <LOG> if ( ! fs . get <identifiersep> end <identifiersep> marker ( ) . ends <identifiersep> with ( <string_literal> ) ) { return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . wrong <identifiersep> encoding ; } fs . set <identifiersep> end <identifiersep> marker ( <string_literal> ) ; <comment> <ect>
logger . error ( this , <string_literal> + fs . get <identifiersep> end <identifiersep> marker ( ) + <string_literal> ) ; return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . wrong <identifiersep> encoding ; } fs . set <identifiersep> end <identifiersep> marker ( <string_literal> ) ; <comment> <LOG> } catch ( throwable t ) { return peer <identifiersep> addition <identifiersep> return <identifiersep> codes . internal <identifiersep> error ; } peer <identifiersep> node pn ; try { if ( is <identifiersep> opennet ( ) ) { pn = node . create <identifiersep> new <identifiersep> opennet <identifiersep> node ( fs ) ; <ect>
private uuid get <identifiersep> session <identifiersep> id ( toadlet <identifiersep> context context ) { if ( context == null ) return null ; try { received <identifiersep> cookie session <identifiersep> cookie = context . get <identifiersep> cookie ( null , m <identifiersep> cookie <identifiersep> path , m <identifiersep> cookie <identifiersep> name ) ; return session <identifiersep> cookie == null ? null : uuid . from <identifiersep> string ( session <identifiersep> cookie . get <identifiersep> value ( ) ) ; <LOG> } catch ( parse <identifiersep> exception e ) { return null ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; return null ; } } <comment> <ect>
<comment> private synchronized void verify <identifiersep> sessions <identifiersep> by <identifiersep> user <identifiersep> id <identifiersep> table ( ) { enumeration < session > sessions = m <identifiersep> sessions <identifiersep> by <identifiersep> user <identifiersep> id . elements ( ) ; while ( sessions . has <identifiersep> more <identifiersep> elements ( ) ) { session session = sessions . next <identifiersep> element ( ) ; <LOG> if ( m <identifiersep> sessions <identifiersep> by <identifiersep> id . contains <identifiersep> key ( session . get <identifiersep> id ( ) ) == false ) { m <identifiersep> sessions <identifiersep> by <identifiersep> user <identifiersep> id . remove ( session . get <identifiersep> user <identifiersep> id ( ) ) ; } } } } <ect>
if ( ! password . is <identifiersep> empty ( ) ) { <comment> <LOG> <comment> <ect>
pw . flush ( ) ; msg = msg + sw . to <identifiersep> string ( ) + <string_literal> ; write <identifiersep> html <identifiersep> reply ( ctx , <number_literal> , <string_literal> , msg ) ; if ( changed <identifiersep> anything ) core . store <identifiersep> config ( ) ; return ; } <LOG> } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { page <identifiersep> node page = ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> page <identifiersep> node ( l10n <identifiersep> sec ( <string_literal> ) , ctx ) ; page <identifiersep> node = page . outer ; html <identifiersep> node content <identifiersep> node = page . content ; content = ctx . get <identifiersep> page <identifiersep> maker ( ) . get <identifiersep> infobox ( <string_literal> , l10n <identifiersep> sec ( <string_literal> ) , content <identifiersep> node , <string_literal> , true ) . <ect>
if ( master <identifiersep> password . is <identifiersep> empty ( ) ) { send <identifiersep> password <identifiersep> page ( ctx , true , null ) ; return ; } system . err . println ( <string_literal> ) ; try { node . set <identifiersep> master <identifiersep> password ( master <identifiersep> password , false ) ; <LOG> } catch ( already <identifiersep> set <identifiersep> password <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; multi <identifiersep> value <identifiersep> table < string , string > headers = new multi <identifiersep> value <identifiersep> table < string , string > ( ) ; headers . put ( <string_literal> , <string_literal> ) ; ctx . send <identifiersep> reply <identifiersep> headers ( <number_literal> , <string_literal> , headers , null , 0 ) ; return ; <ect>
cancel <identifiersep> form . add <identifiersep> child ( <string_literal> , new string [ ] { <string_literal> , <string_literal> , <string_literal> } , new string [ ] { <string_literal> , <string_literal> , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) } ) ; cancel <identifiersep> form . add <identifiersep> child ( <string_literal> , new string [ ] { <string_literal> , <string_literal> , <string_literal> } , new string [ ] { <string_literal> , <string_literal> , <string_literal> } ) ; } page <identifiersep> maker . get <identifiersep> infobox ( <string_literal> , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , content , <string_literal> , false ) . add <identifiersep> child ( get <identifiersep> bookmarks <identifiersep> list ( bookmark <identifiersep> manager ) ) ; html <identifiersep> node add <identifiersep> default <identifiersep> bookmarks <identifiersep> form = ctx . add <identifiersep> form <identifiersep> child ( content , <string_literal> , <string_literal> ) ; add <identifiersep> default <identifiersep> bookmarks <identifiersep> form . add <identifiersep> child ( <string_literal> , new string [ ] { <string_literal> , <string_literal> , <string_literal> } , new string [ ] { <string_literal> , <string_literal> , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) } ) ; <LOG> if ( log <identifiersep> debug ) this . write <identifiersep> html <identifiersep> reply ( ctx , <number_literal> , <string_literal> , page <identifiersep> node . generate ( ) ) ; } public void handle <identifiersep> method <identifiersep> post ( uri uri , http <identifiersep> request req , toadlet <identifiersep> context ctx ) throws toadlet <identifiersep> context <identifiersep> closed <identifiersep> exception , io <identifiersep> exception { page <identifiersep> maker page <identifiersep> maker = ctx . get <identifiersep> page <identifiersep> maker ( ) ; bookmark <identifiersep> manager bookmark <identifiersep> manager = ctx . get <identifiersep> bookmark <identifiersep> manager ( ) ; <ect>
closer . close ( output <identifiersep> stream ) ; } } private filter <identifiersep> status apply <identifiersep> filter ( input <identifiersep> stream input , output <identifiersep> stream output , string mime <identifiersep> type , filter <identifiersep> operation operation , node <identifiersep> client <identifiersep> core core ) throws unsafe <identifiersep> content <identifiersep> type <identifiersep> exception , io <identifiersep> exception { uri fake <identifiersep> uri ; try { fake <identifiersep> uri = new uri ( <string_literal> ) ; <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { return null ; } <comment> <ect>
try { throw new redirect <identifiersep> exception ( new uri ( null , null , null , - 1 , welcome . get <identifiersep> path ( ) , uri . get <identifiersep> query ( ) , uri . get <identifiersep> fragment ( ) ) ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <comment> <LOG> <comment> write <identifiersep> temporary <identifiersep> redirect ( ctx , <string_literal> , welcome <identifiersep> toadlet . path ) ; return ; } } else if ( ks . equals ( <string_literal> ) ) { try { throw new redirect <identifiersep> exception ( static <identifiersep> toadlet . root <identifiersep> url + <string_literal> ) ; <ect>
referer = <string_literal> + furi . to <identifiersep> string ( ) ; if ( type != null && type . length ( ) > 0 ) referer += <string_literal> + type ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { referer = <string_literal> ; logger . normal ( this , <string_literal> + e . get <identifiersep> message ( ) ) ; <LOG> } catch ( throwable t ) { referer = null ; } } return referer ; } private static string get <identifiersep> force <identifiersep> value ( freenet <identifiersep> uri key , long time ) { byte <identifiersep> array <identifiersep> output <identifiersep> stream bos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; try { <ect>
push <identifiersep> data <identifiersep> manager = new push <identifiersep> data <identifiersep> manager ( get <identifiersep> ticker ( ) ) ; interval <identifiersep> push <identifiersep> manager = new interval <identifiersep> pusher <identifiersep> manager ( get <identifiersep> ticker ( ) , push <identifiersep> data <identifiersep> manager ) ; bookmark <identifiersep> manager = new bookmark <identifiersep> manager ( core , public <identifiersep> gateway <identifiersep> mode ( ) ) ; try { f <identifiersep> proxy <identifiersep> toadlet . maybe <identifiersep> create <identifiersep> f <identifiersep> proxy <identifiersep> etc ( core , node , node . config , this ) ; } catch ( io <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } public void set <identifiersep> core ( node <identifiersep> client <identifiersep> core core ) { this . core = core ; } <comment> <ect>
this . advanced <identifiersep> mode <identifiersep> enabled = fproxy <identifiersep> config . get <identifiersep> boolean ( <string_literal> ) ; toadlets = new linked <identifiersep> list < toadlet <identifiersep> element > ( ) ; if ( ssl . available ( ) ) { ssl = fproxy <identifiersep> config . get <identifiersep> boolean ( <string_literal> ) ; } this . allowed <identifiersep> hosts = fproxy <identifiersep> config . get <identifiersep> string ( <string_literal> ) ; if ( ! enabled ) { <LOG> logger . normal ( simple <identifiersep> toadlet <identifiersep> server . this , <string_literal> ) ; } else { maybe <identifiersep> get <identifiersep> network <identifiersep> interface ( ) ; my <identifiersep> thread = new thread ( this , <string_literal> ) ; my <identifiersep> thread . set <identifiersep> daemon ( true ) ; } <comment> <ect>
public void start ( ) { if ( my <identifiersep> thread != null ) try { maybe <identifiersep> get <identifiersep> network <identifiersep> interface ( ) ; my <identifiersep> thread . start ( ) ; logger . normal ( this , <string_literal> + bind <identifiersep> to + ' : ' + port ) ; system . out . println ( <string_literal> + bind <identifiersep> to + ' : ' + port ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } public void finish <identifiersep> start ( ) { core . node . security <identifiersep> levels . add <identifiersep> network <identifiersep> threat <identifiersep> level <identifiersep> listener ( new security <identifiersep> level <identifiersep> listener < network <identifiersep> threat <identifiersep> level > ( ) { @ override public void on <identifiersep> change ( network <identifiersep> threat <identifiersep> level old <identifiersep> level , network <identifiersep> threat <identifiersep> level new <identifiersep> level ) { <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; try { toadlet <identifiersep> context <identifiersep> impl . handle ( sock , simple <identifiersep> toadlet <identifiersep> server . this , page <identifiersep> maker , get <identifiersep> user <identifiersep> alert <identifiersep> manager ( ) , bookmark <identifiersep> manager ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { synchronized ( simple <identifiersep> toadlet <identifiersep> server . this ) { fproxy <identifiersep> connections -- ; simple <identifiersep> toadlet <identifiersep> server . this . notify <identifiersep> all ( ) ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <ect>
if ( ! bookmarks <identifiersep> file . exists ( ) || bookmarks <identifiersep> file . length ( ) == 0 ) throw new io <identifiersep> exception ( ) ; logger . normal ( this , <string_literal> + bookmarks <identifiersep> file . to <identifiersep> string ( ) ) ; simple <identifiersep> field <identifiersep> set sfs = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( bookmarks <identifiersep> file , false , true ) ; read <identifiersep> bookmarks ( main <identifiersep> category , sfs ) ; } catch ( malformed <identifiersep> url <identifiersep> exception mue ) { <LOG> } catch ( io <identifiersep> exception ioe ) { try { if ( backup <identifiersep> bookmarks <identifiersep> file . exists ( ) && backup <identifiersep> bookmarks <identifiersep> file . can <identifiersep> read ( ) && backup <identifiersep> bookmarks <identifiersep> file . length ( ) > 0 ) { logger . normal ( this , <string_literal> + backup <identifiersep> bookmarks <identifiersep> file . to <identifiersep> string ( ) ) ; simple <identifiersep> field <identifiersep> set sfs = simple <identifiersep> field <identifiersep> set . read <identifiersep> from ( backup <identifiersep> bookmarks <identifiersep> file , false , true ) ; read <identifiersep> bookmarks ( main <identifiersep> category , sfs ) ; <ect>
} catch ( identifier <identifiersep> collision <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return true ; <LOG> } catch ( identifier <identifiersep> collision <identifiersep> exception e ) { write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } catch ( not <identifiersep> allowed <identifiersep> exception e ) { write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> , <string_literal> , file . get <identifiersep> filename ( ) ) , ctx , false , true ) ; return false ; <ect>
try { client <identifiersep> put = new client <identifiersep> put ( fcp . get <identifiersep> global <identifiersep> forever <identifiersep> client ( ) , furi , identifier , integer . max <identifiersep> value , null , request <identifiersep> starter . bulk <identifiersep> splitfile <identifiersep> priority <identifiersep> class , persistence . forever , null , false , ! compress , - 1 , upload <identifiersep> from . disk , file , content <identifiersep> type , new file <identifiersep> bucket ( file , true , false , false , false ) , null , target , false , false , node . fork <identifiersep> on <identifiersep> cacheable <identifiersep> default , high <identifiersep> level <identifiersep> simple <identifiersep> client <identifiersep> impl . extra <identifiersep> inserts <identifiersep> single <identifiersep> block , high <identifiersep> level <identifiersep> simple <identifiersep> client <identifiersep> impl . extra <identifiersep> inserts <identifiersep> splitfile <identifiersep> header , false , cmode , override <identifiersep> splitfile <identifiersep> key , false , fcp . core ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + file + <string_literal> + identifier ) ; if ( client <identifiersep> put != null ) try { fcp . start <identifiersep> blocking ( client <identifiersep> put , context ) ; <LOG> } catch ( identifier <identifiersep> collision <identifiersep> exception e ) { write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
} catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> , <string_literal> , target ) , ctx ) ; return false ; } catch ( not <identifiersep> allowed <identifiersep> exception e ) { write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> , new string [ ] { <string_literal> } , new string [ ] { file . get <identifiersep> name ( ) } ) , ctx ) ; return false ; <LOG> } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; <comment> <ect>
return false ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { send <identifiersep> persistence <identifiersep> disabled <identifiersep> error ( ctx ) ; return false ; } write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return true ; <LOG> } catch ( identifier <identifiersep> collision <identifiersep> exception e ) { write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { write <identifiersep> error ( l10n ( <string_literal> ) , l10n ( <string_literal> ) , ctx ) ; return false ; <ect>
failed <identifiersep> unknown <identifiersep> mime <identifiersep> type . put ( mime <identifiersep> type , list ) ; } list . add ( download ) ; } else if ( failure <identifiersep> code == fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> validation <identifiersep> bad <identifiersep> mime ) { mime <identifiersep> type = content <identifiersep> filter . strip <identifiersep> mime <identifiersep> type ( mime <identifiersep> type ) ; filter <identifiersep> mime <identifiersep> type type = content <identifiersep> filter . get <identifiersep> mime <identifiersep> type ( mime <identifiersep> type ) ; linked <identifiersep> list < download <identifiersep> request <identifiersep> status > list ; <LOG> if ( type == null ) { list = failed <identifiersep> unknown <identifiersep> mime <identifiersep> type . get ( mime <identifiersep> type ) ; if ( list == null ) { list = new linked <identifiersep> list < download <identifiersep> request <identifiersep> status > ( ) ; failed <identifiersep> unknown <identifiersep> mime <identifiersep> type . put ( mime <identifiersep> type , list ) ; } } else { <ect>
bw = new buffered <identifiersep> writer ( osw ) ; string [ ] identifiers ; synchronized ( completed <identifiersep> request <identifiersep> identifiers ) { identifiers = completed <identifiersep> request <identifiersep> identifiers . to <identifiersep> array ( new string [ completed <identifiersep> request <identifiersep> identifiers . size ( ) ] ) ; } for ( string identifier : identifiers ) bw . write ( identifier + ' \\ n' ) ; <LOG> } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { return ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } finally { <ect>
} catch ( io <identifiersep> exception e1 ) { <comment> <LOG> if ( ! completed <identifiersep> identifiers <identifiersep> list <identifiersep> new . rename <identifiersep> to ( completed <identifiersep> identifiers <identifiersep> list ) ) { } } } private void register <identifiersep> alert ( client <identifiersep> request req ) { final string identifier = req . get <identifiersep> identifier ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + identifier ) ; if ( ! req . has <identifiersep> finished ( ) ) { <ect>
get <identifiersep> completed <identifiersep> event event = new get <identifiersep> completed <identifiersep> event ( identifier , uri , size ) ; synchronized ( completed <identifiersep> gets ) { completed <identifiersep> gets . put ( identifier , event ) ; } core . alerts . register ( event ) ; } else if ( req instanceof client <identifiersep> put ) { freenet <identifiersep> uri uri = ( ( client <identifiersep> put ) req ) . get <identifiersep> final <identifiersep> uri ( ) ; <LOG> if ( uri == null ) { return ; } long size = ( ( client <identifiersep> put ) req ) . get <identifiersep> data <identifiersep> size ( ) ; put <identifiersep> completed <identifiersep> event event = new put <identifiersep> completed <identifiersep> event ( identifier , uri , size ) ; synchronized ( completed <identifiersep> puts ) { completed <identifiersep> puts . put ( identifier , event ) ; <ect>
<comment> void send <identifiersep> unauthorized <identifiersep> page ( toadlet <identifiersep> context ctx ) throws toadlet <identifiersep> context <identifiersep> closed <identifiersep> exception , io <identifiersep> exception { send <identifiersep> error <identifiersep> page ( ctx , <number_literal> , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) , node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) ) ; } <LOG> protected void write <identifiersep> internal <identifiersep> error ( throwable t , toadlet <identifiersep> context ctx ) throws toadlet <identifiersep> context <identifiersep> closed <identifiersep> exception , io <identifiersep> exception { string msg = <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> ; string <identifiersep> writer sw = new string <identifiersep> writer ( ) ; print <identifiersep> writer pw = new print <identifiersep> writer ( sw ) ; while ( t != null ) { <ect>
public synchronized base <identifiersep> updateable <identifiersep> element get <identifiersep> rendered <identifiersep> element ( string request <identifiersep> id , string id ) { if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> + id + <string_literal> + request <identifiersep> id ) ; } if ( pages . get ( request <identifiersep> id ) != null ) for ( base <identifiersep> updateable <identifiersep> element element : pages . get ( request <identifiersep> id ) ) { if ( element . get <identifiersep> updater <identifiersep> id ( request <identifiersep> id ) . compare <identifiersep> to ( id ) == 0 ) { element . update <identifiersep> state ( false ) ; <LOG> return element ; } } return null ; } <comment> <ect>
<comment> <LOG> } catch ( config <identifiersep> exception e ) { } return first <identifiersep> time <identifiersep> wizard <identifiersep> toadlet . wizard <identifiersep> step . datastore <identifiersep> size . name ( ) ; } } <ect>
string down <identifiersep> string = limit <identifiersep> selected . substring ( 0 , x ) ; string up <identifiersep> string = limit <identifiersep> selected . substring ( x + 1 ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> long store <identifiersep> size = size - ( client <identifiersep> cache <identifiersep> size + slashdot <identifiersep> cache <identifiersep> size ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( store <identifiersep> size , true ) ) ; if ( config . get ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) . equals ( <string_literal> ) ) config . get ( <string_literal> ) . set ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> + fields . long <identifiersep> to <identifiersep> string ( client <identifiersep> cache <identifiersep> size , true ) ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( client <identifiersep> cache <identifiersep> size , true ) ) ; <ect>
config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( store <identifiersep> size , true ) ) ; if ( config . get ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) . equals ( <string_literal> ) ) config . get ( <string_literal> ) . set ( <string_literal> , <string_literal> ) ; system . out . println ( <string_literal> + fields . long <identifiersep> to <identifiersep> string ( client <identifiersep> cache <identifiersep> size , true ) ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( client <identifiersep> cache <identifiersep> size , true ) ) ; if ( config . get ( <string_literal> ) . get <identifiersep> string ( <string_literal> ) . equals ( <string_literal> ) ) <LOG> config . get ( <string_literal> ) . set ( <string_literal> , <string_literal> ) ; config . get ( <string_literal> ) . set ( <string_literal> , fields . long <identifiersep> to <identifiersep> string ( slashdot <identifiersep> cache <identifiersep> size , true ) ) ; logger . normal ( this , <string_literal> + selected <identifiersep> store <identifiersep> size ) ; } catch ( config <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } } private long max <identifiersep> datastore <identifiersep> size ( ) { <ect>
try { config . get ( <string_literal> ) . set ( limit <identifiersep> type , limit ) ; logger . normal ( this , <string_literal> + limit <identifiersep> type + <string_literal> + limit ) ; } catch ( config <identifiersep> exception e ) { if ( e instanceof invalid <identifiersep> config <identifiersep> value <identifiersep> exception ) { <comment> <LOG> throw ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception ) e ; } } } <comment> <ect>
} else { downstream <identifiersep> bytes = downstream <identifiersep> bits / <number_literal> ; } if ( upstream <identifiersep> bits < 0 ) { <comment> <LOG> <comment> <ect>
} else if ( core . node . get <identifiersep> master <identifiersep> password <identifiersep> file ( ) . exists ( ) ) { <comment> <LOG> <comment> <ect>
return new cache ( codes , ips ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> } catch ( ip <identifiersep> converter <identifiersep> parse <identifiersep> exception e ) { <comment> <ect>
try { is = part . get <identifiersep> input <identifiersep> stream ( ) ; dis = new data <identifiersep> input <identifiersep> stream ( is ) ; byte [ ] buf = new byte [ ( int ) math . min ( part . size ( ) , maxlength ) ] ; dis . read <identifiersep> fully ( buf ) ; return buf ; <LOG> } catch ( io <identifiersep> exception ioe ) { } finally { closer . close ( dis ) ; if ( dis == null ) closer . close ( is ) ; <comment> <ect>
http <identifiersep> request new <identifiersep> request = new http <identifiersep> request <identifiersep> impl ( new uri ( step <identifiersep> url ( redirect <identifiersep> target ) ) , <string_literal> ) ; <comment> <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { redirect <identifiersep> target = wizard <identifiersep> step . welcome . name ( ) ; } } } catch ( io <identifiersep> exception e ) { string title ; if ( e . get <identifiersep> message ( ) . equals ( <string_literal> ) ) { <comment> <ect>
return true ; } catch ( io <identifiersep> exception e ) { logger . normal ( this , <string_literal> ) ; <comment> <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { return false ; } finally { closer . close ( is ) ; closer . close ( os ) ; closer . close ( output ) ; <ect>
d = data ; cancelled = true ; } if ( d != null ) { try { d . free ( ) ; } catch ( throwable t ) { <LOG> <comment> <ect>
<comment> <LOG> catch ( runtime <identifiersep> exception e ) { } } return null ; } @ override public void set <identifiersep> cookie ( cookie new <identifiersep> cookie ) { if ( reply <identifiersep> cookies == null ) reply <identifiersep> cookies = new array <identifiersep> list < cookie > ( <number_literal> ) ; <ect>
try { send <identifiersep> error ( sock . get <identifiersep> output <identifiersep> stream ( ) , <number_literal> , <string_literal> , l10n ( <string_literal> ) , true , null ) ; } catch ( io <identifiersep> exception e1 ) { <comment> <LOG> } catch ( toadlet <identifiersep> context <identifiersep> closed <identifiersep> exception e ) { } catch ( throwable t ) { logger . error ( toadlet <identifiersep> context <identifiersep> impl . class , <string_literal> + t + <string_literal> , t ) ; try { string msg = <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> ; <ect>
public synchronized void add <identifiersep> navigation <identifiersep> category ( string link , string name , string title , fred <identifiersep> plugin <identifiersep> l10n plugin , int menu <identifiersep> offset ) { sub <identifiersep> menu menu = new sub <identifiersep> menu ( link , name , title , plugin ) ; sub <identifiersep> menus . put ( name , menu ) ; menu <identifiersep> list . add ( menu <identifiersep> offset , menu ) ; } public synchronized void remove <identifiersep> navigation <identifiersep> category ( string name ) { sub <identifiersep> menu menu = sub <identifiersep> menus . remove ( name ) ; <LOG> if ( menu == null ) { return ; } menu <identifiersep> list . remove ( menu ) ; } public synchronized void add <identifiersep> navigation <identifiersep> link ( string menutext , string path , string name , string title , boolean full <identifiersep> only , link <identifiersep> enabled <identifiersep> callback cb , fred <identifiersep> plugin <identifiersep> l10n l10n ) { sub <identifiersep> menu menu = sub <identifiersep> menus . get ( menutext ) ; if ( menu == null ) <ect>
if ( new <identifiersep> navigation <identifiersep> title == null ) { logger . error ( this , <string_literal> + l10n + <string_literal> ) ; } else { navigation <identifiersep> title = new <identifiersep> navigation <identifiersep> title ; } } if ( navigation <identifiersep> link != null ) { string new <identifiersep> navigation <identifiersep> link = l10n . get <identifiersep> string ( navigation <identifiersep> link ) ; <LOG> if ( new <identifiersep> navigation <identifiersep> link == null ) { } else { navigation <identifiersep> link = new <identifiersep> navigation <identifiersep> link ; } } } else { <comment> <ect>
string new <identifiersep> title = menu . plugin . get <identifiersep> string ( menu <identifiersep> item <identifiersep> title ) ; if ( new <identifiersep> title == null ) { logger . error ( this , <string_literal> + menu . plugin + <string_literal> ) ; } else { menu <identifiersep> item <identifiersep> title = new <identifiersep> title ; } string new <identifiersep> text = menu . plugin . get <identifiersep> string ( text ) ; <LOG> if ( new <identifiersep> text == null ) { } else { text = new <identifiersep> text ; } } list <identifiersep> item . add <identifiersep> child ( <string_literal> , new string [ ] { <string_literal> , <string_literal> } , new string [ ] { menu . default <identifiersep> navigation <identifiersep> link , menu <identifiersep> item <identifiersep> title } , text ) ; list <identifiersep> item . add <identifiersep> child ( subnavlist ) ; navbar <identifiersep> ul . add <identifiersep> child ( list <identifiersep> item ) ; <ect>
<comment> @ deprecated public void queue ( fcp <identifiersep> message msg ) { <LOG> if ( log <identifiersep> debug ) if ( msg == null ) throw new null <identifiersep> pointer <identifiersep> exception ( ) ; boolean never <identifiersep> drop <identifiersep> a <identifiersep> message = handler . server . never <identifiersep> drop <identifiersep> a <identifiersep> message ( ) ; int max <identifiersep> queue <identifiersep> length = handler . server . max <identifiersep> message <identifiersep> queue <identifiersep> length ( ) ; synchronized ( out <identifiersep> queue ) { if ( closed <identifiersep> output <identifiersep> queue ) { <ect>
synchronized ( out <identifiersep> queue ) { if ( closed <identifiersep> output <identifiersep> queue ) { logger . error ( this , <string_literal> + this + <string_literal> + msg ) ; <comment> <LOG> if ( never <identifiersep> drop <identifiersep> a <identifiersep> message ) { } else { logger . error ( this , <string_literal> + handler + <string_literal> + out <identifiersep> queue . size ( ) + <string_literal> , new exception ( <string_literal> ) ) ; return ; } } out <identifiersep> queue . add ( msg ) ; out <identifiersep> queue . notify <identifiersep> all ( ) ; <ect>
if ( len == 0 ) { bucket = new null <identifiersep> bucket ( ) ; return ; } random <identifiersep> access <identifiersep> bucket temp <identifiersep> bucket ; try { temp <identifiersep> bucket = create <identifiersep> bucket ( bf , len , server ) ; <LOG> } catch ( io <identifiersep> exception e ) { file <identifiersep> util . copy ( is , new null <identifiersep> output <identifiersep> stream ( ) , len ) ; throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . internal <identifiersep> error , e . to <identifiersep> string ( ) , get <identifiersep> identifier ( ) , is <identifiersep> global ( ) ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; file <identifiersep> util . copy ( is , new null <identifiersep> output <identifiersep> stream ( ) , len ) ; <ect>
buffered <identifiersep> output <identifiersep> stream bos = null ; try { fos = new file <identifiersep> output <identifiersep> stream ( result . read <identifiersep> filename ) ; bos = new buffered <identifiersep> output <identifiersep> stream ( fos ) ; bos . write ( result . read <identifiersep> content . get <identifiersep> bytes ( <string_literal> ) ) ; bos . flush ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } finally { closer . close ( bos ) ; closer . close ( fos ) ; } } return result ; } <comment> <ect>
if ( s != null ) { if ( ! ( o . get <identifiersep> value <identifiersep> string ( ) . equals ( s ) ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + prefix + ' . ' + config <identifiersep> name + <string_literal> + s ) ; try { o . set <identifiersep> value ( s ) ; } catch ( exception e ) { <LOG> <comment> <ect>
throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . ref <identifiersep> signature <identifiersep> invalid , <string_literal> + e . get <identifiersep> message ( ) , identifier , false ) ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . ref <identifiersep> parse <identifiersep> error , <string_literal> + e . get <identifiersep> message ( ) , identifier , false ) ; } if ( arrays . equals ( pn . peer <identifiersep> ecdsa <identifiersep> pub <identifiersep> key <identifiersep> hash , node . get <identifiersep> darknet <identifiersep> pub <identifiersep> key <identifiersep> hash ( ) ) ) throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . cannot <identifiersep> peer <identifiersep> with <identifiersep> self , <string_literal> , identifier , false ) ; if ( ! node . add <identifiersep> peer <identifiersep> connection ( pn ) ) { <LOG> throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . duplicate <identifiersep> peer <identifiersep> ref , <string_literal> , identifier , false ) ; } } handler . output <identifiersep> handler . queue ( new peer <identifiersep> message ( pn , true , true , identifier ) ) ; } } <ect>
break ; } } if ( req == null ) { for ( client <identifiersep> request r : running <identifiersep> persistent <identifiersep> requests ) { if ( r . get <identifiersep> identifier ( ) . equals ( identifier ) ) { req = r ; running <identifiersep> persistent <identifiersep> requests . remove ( r ) ; <LOG> removed <identifiersep> from <identifiersep> running = true ; break ; } } } if ( req == null ) return false ; } else if ( ! ( ( removed <identifiersep> from <identifiersep> running = running <identifiersep> persistent <identifiersep> requests . remove ( req ) ) || completed <identifiersep> unacked <identifiersep> requests . remove ( req ) ) ) { logger . error ( this , <string_literal> + identifier + <string_literal> ) ; return false ; <ect>
try { if ( ssl ) { temp <identifiersep> network <identifiersep> interface = ssl <identifiersep> network <identifiersep> interface . create ( port , bind <identifiersep> to , allowed <identifiersep> hosts , node . executor , true ) ; } else { temp <identifiersep> network <identifiersep> interface = network <identifiersep> interface . create ( port , bind <identifiersep> to , allowed <identifiersep> hosts , node . executor , true ) ; } } catch ( io <identifiersep> exception be ) { <LOG> logger . error ( this , <string_literal> + bind <identifiersep> to + ' : ' + port + <string_literal> , be ) ; } this . network <identifiersep> interface = temp <identifiersep> network <identifiersep> interface ; } public void maybe <identifiersep> start ( ) { if ( this . enabled ) { maybe <identifiersep> get <identifiersep> network <identifiersep> interface ( ) ; logger . normal ( this , <string_literal> + bind <identifiersep> to + ' : ' + port + ' . ' ) ; <ect>
system . out . println ( <string_literal> + bind <identifiersep> to + ' : ' + port + ' . ' ) ; if ( this . network <identifiersep> interface != null ) { thread t = new thread ( this , <string_literal> ) ; t . set <identifiersep> daemon ( true ) ; t . start ( ) ; } } else { <LOG> logger . normal ( this , <string_literal> ) ; this . network <identifiersep> interface = null ; } if ( node . plugin <identifiersep> manager . is <identifiersep> enabled ( ) ) { <comment> <ect>
return <string_literal> ; } @ override public boolean run ( client <identifiersep> context context ) { boolean succeeded = false ; try { succeeded = global <identifiersep> forever <identifiersep> client . remove <identifiersep> by <identifiersep> identifier ( identifier , true , fcp <identifiersep> server . this , core . client <identifiersep> context ) ; <LOG> } catch ( throwable t ) { } finally { success . set ( succeeded ) ; done . count <identifiersep> down ( ) ; } return true ; } } , native <identifiersep> thread . high <identifiersep> priority ) ; <ect>
public boolean run ( client <identifiersep> context context ) { boolean succeeded = false ; try { global <identifiersep> forever <identifiersep> client . remove <identifiersep> all ( core . client <identifiersep> context ) ; succeeded = true ; } catch ( throwable t ) { <LOG> logger . error ( this , <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; } finally { success . set ( succeeded ) ; done . count <identifiersep> down ( ) ; <ect>
ne = e ; return false ; } catch ( io <identifiersep> exception e ) { ioe = e ; return false ; } catch ( throwable t ) { <LOG> <comment> <ect>
<comment> <LOG> } catch ( throwable t ) { } } } <comment> private static transient volatile boolean log <identifiersep> minor = false ; static { logger . register <identifiersep> class ( fcp <identifiersep> plugin <identifiersep> connection <identifiersep> tracker . class ) ; } } <ect>
return putter ; } @ override protected fcp <identifiersep> message persistent <identifiersep> tag <identifiersep> message ( ) { <comment> <LOG> if ( putter == null ) <comment> <ect>
if ( encoded <identifiersep> note <identifiersep> text == null ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . missing <identifiersep> field , <string_literal> , identifier , false ) ; } string note <identifiersep> text ; <comment> <LOG> } catch ( illegal <identifiersep> base64exception e ) { return ; } if ( peer <identifiersep> note <identifiersep> type == node . peer <identifiersep> note <identifiersep> type <identifiersep> private <identifiersep> darknet <identifiersep> comment ) { dpn . set <identifiersep> private <identifiersep> darknet <identifiersep> comment <identifiersep> note ( note <identifiersep> text ) ; } else { fcp <identifiersep> message msg = new unknown <identifiersep> peer <identifiersep> note <identifiersep> type <identifiersep> message ( peer <identifiersep> note <identifiersep> type , identifier ) ; <ect>
logger . warning ( this , <string_literal> + this ) ; return ; } sfs . set <identifiersep> end <identifiersep> marker ( get <identifiersep> end <identifiersep> string ( ) ) ; string msg = sfs . to <identifiersep> string ( ) ; os . write ( ( get <identifiersep> name ( ) + ' \\ n' ) . get <identifiersep> bytes ( <string_literal> ) ) ; os . write ( msg . get <identifiersep> bytes ( <string_literal> ) ) ; <LOG> if ( log <identifiersep> debug ) { logger . debug ( this , <string_literal> + this ) ; } } string get <identifiersep> end <identifiersep> string ( ) { return <string_literal> ; } public abstract simple <identifiersep> field <identifiersep> set get <identifiersep> field <identifiersep> set ( ) ; public abstract string get <identifiersep> name ( ) ; <ect>
if ( check <identifiersep> job . write <identifiersep> filename != null ) { file maybe <identifiersep> written <identifiersep> file = check <identifiersep> job . write <identifiersep> filename ; if ( maybe <identifiersep> written <identifiersep> file . exists ( ) && maybe <identifiersep> written <identifiersep> file . is <identifiersep> file ( ) && maybe <identifiersep> written <identifiersep> file . can <identifiersep> read ( ) ) { try { string existing <identifiersep> content = file <identifiersep> util . read <identifiersep> utf ( maybe <identifiersep> written <identifiersep> file ) . to <identifiersep> string ( ) . trim ( ) ; is <identifiersep> write <identifiersep> allowed = check <identifiersep> job . write <identifiersep> content . equals ( existing <identifiersep> content ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } sfs . put <identifiersep> single ( write <identifiersep> allowed , string . value <identifiersep> of ( is <identifiersep> write <identifiersep> allowed ) ) ; } <comment> <ect>
target <identifiersep> file = null ; ret = null ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { <comment> <ect>
return new persistent <identifiersep> get ( identifier , uri , verbosity , priority <identifiersep> class , return <identifiersep> type , persistence , target <identifiersep> file , client <identifiersep> token , client . is <identifiersep> global <identifiersep> queue , started , fctx . max <identifiersep> non <identifiersep> splitfile <identifiersep> retries , binary <identifiersep> blob , fctx . max <identifiersep> output <identifiersep> length , is <identifiersep> real <identifiersep> time ( ) ) ; } <comment> <LOG> <comment> <ect>
} else if ( ce instanceof enter <identifiersep> finite <identifiersep> cooldown <identifiersep> event ) { verbosity <identifiersep> mask = verbosity <identifiersep> enter <identifiersep> finite <identifiersep> cooldown ; if ( ( verbosity & verbosity <identifiersep> mask ) == 0 ) return ; enter <identifiersep> finite <identifiersep> cooldown <identifiersep> event event = ( enter <identifiersep> finite <identifiersep> cooldown <identifiersep> event ) ce ; progress = new enter <identifiersep> finite <identifiersep> cooldown ( identifier , global , event . wakeup <identifiersep> time ) ; <LOG> } else { return ; <comment> <ect>
fetch <identifiersep> context fctx = null ; try { data <identifiersep> input <identifiersep> stream inner <identifiersep> dis = new data <identifiersep> input <identifiersep> stream ( checker . checksum <identifiersep> reader <identifiersep> with <identifiersep> length ( dis , context . temp <identifiersep> bucket <identifiersep> factory , <number_literal> ) ) ; try { fctx = new fetch <identifiersep> context ( inner <identifiersep> dis ) ; <LOG> } catch ( io <identifiersep> exception e ) { } finally { inner <identifiersep> dis . close ( ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; } if ( fctx == null ) { <ect>
if ( return <identifiersep> type == return <identifiersep> type . direct ) { try { data <identifiersep> input <identifiersep> stream inner <identifiersep> dis = new data <identifiersep> input <identifiersep> stream ( checker . checksum <identifiersep> reader <identifiersep> with <identifiersep> length ( dis , context . temp <identifiersep> bucket <identifiersep> factory , <number_literal> ) ) ; try { return <identifiersep> bucket <identifiersep> direct = bucket <identifiersep> tools . restore <identifiersep> from ( inner <identifiersep> dis , context . persistent <identifiersep> fg , context . persistent <identifiersep> file <identifiersep> tracker , context . get <identifiersep> persistent <identifiersep> master <identifiersep> secret ( ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { return <identifiersep> bucket <identifiersep> direct = null ; succeeded = false ; finished = false ; } finally { inner <identifiersep> dis . close ( ) ; <ect>
inner <identifiersep> dis . close ( ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; return <identifiersep> bucket <identifiersep> direct = null ; succeeded = false ; finished = false ; <LOG> } catch ( storage <identifiersep> format <identifiersep> exception e ) { return <identifiersep> bucket <identifiersep> direct = null ; succeeded = false ; finished = false ; } } } else { try { <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; finished = false ; get <identifiersep> failed <identifiersep> message = null ; } finally { inner <identifiersep> dis . close ( ) ; } <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { finished = false ; get <identifiersep> failed <identifiersep> message = null ; } } } else { getter = make <identifiersep> getter ( make <identifiersep> bucket ( false ) ) ; try { <ect>
real <identifiersep> run ( ) ; } catch ( too <identifiersep> long <identifiersep> exception e ) { logger . normal ( this , <string_literal> + e . get <identifiersep> message ( ) , e ) ; } catch ( io <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + e , e ) ; <LOG> } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; } handler . close ( ) ; handler . closed <identifiersep> input ( ) ; } public void real <identifiersep> run ( ) throws io <identifiersep> exception { input <identifiersep> stream is = new buffered <identifiersep> input <identifiersep> stream ( handler . sock . get <identifiersep> input <identifiersep> stream ( ) , <number_literal> ) ; <ect>
continue ; } } if ( ( ! first <identifiersep> message ) && ( msg instanceof client <identifiersep> hello <identifiersep> message ) ) { fcp <identifiersep> message err = new protocol <identifiersep> error <identifiersep> message ( protocol <identifiersep> error <identifiersep> message . no <identifiersep> late <identifiersep> client <identifiersep> hellos , false , null , null , false ) ; handler . output <identifiersep> handler . queue ( err ) ; continue ; } try { <LOG> if ( log <identifiersep> debug ) msg . run ( handler , handler . server . node ) ; } catch ( message <identifiersep> invalid <identifiersep> exception e ) { fcp <identifiersep> message err = new protocol <identifiersep> error <identifiersep> message ( e . protocol <identifiersep> code , false , e . get <identifiersep> message ( ) , e . ident , e . global ) ; handler . output <identifiersep> handler . queue ( err ) ; continue ; <ect>
<comment> <LOG> if ( hashes == null ) { return null ; } simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( false ) ; simple <identifiersep> field <identifiersep> set values = new simple <identifiersep> field <identifiersep> set ( false ) ; for ( hash <identifiersep> result hash : hashes ) { if ( hash == null ) { <ect>
public void run ( fcp <identifiersep> connection <identifiersep> handler handler , node node ) throws message <identifiersep> invalid <identifiersep> exception { if ( bucket == null ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . missing <identifiersep> field , <string_literal> , identifier , false ) ; } bucket result <identifiersep> bucket ; try { result <identifiersep> bucket = bf . make <identifiersep> bucket ( - 1 ) ; <LOG> } catch ( io <identifiersep> exception e ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . internal <identifiersep> error , e . to <identifiersep> string ( ) , identifier , false ) ; } string result <identifiersep> charset = null ; string result <identifiersep> mime <identifiersep> type = null ; boolean unsafe = false ; input <identifiersep> stream input = null ; <ect>
filter <identifiersep> result <identifiersep> message response = new filter <identifiersep> result <identifiersep> message ( identifier , result <identifiersep> charset , result <identifiersep> mime <identifiersep> type , unsafe , result <identifiersep> bucket ) ; handler . output <identifiersep> handler . queue ( response ) ; } private filter <identifiersep> status apply <identifiersep> filter ( input <identifiersep> stream input , output <identifiersep> stream output , client <identifiersep> context client <identifiersep> context ) throws message <identifiersep> invalid <identifiersep> exception , unsafe <identifiersep> content <identifiersep> type <identifiersep> exception , io <identifiersep> exception { uri fake <identifiersep> uri ; try { fake <identifiersep> uri = new uri ( <string_literal> ) ; <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { throw new message <identifiersep> invalid <identifiersep> exception ( protocol <identifiersep> error <identifiersep> message . internal <identifiersep> error , e . to <identifiersep> string ( ) , identifier , false ) ; } <comment> <ect>
bucket data <identifiersep> shadow ; public final boolean overridden <identifiersep> data <identifiersep> type ; private boolean detected <identifiersep> dont <identifiersep> compress ; synchronized void set <identifiersep> finished ( boolean success , long data <identifiersep> size , string mime <identifiersep> type , fetch <identifiersep> exception <identifiersep> mode failure <identifiersep> code , string failure <identifiersep> reason <identifiersep> long , string failure <identifiersep> reason <identifiersep> short , bucket data <identifiersep> shadow , boolean filtered ) { set <identifiersep> finished ( success ) ; <LOG> if ( mime <identifiersep> type == null && ( failure <identifiersep> code == fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> validation <identifiersep> unknown <identifiersep> mime || failure <identifiersep> code == fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> validation <identifiersep> bad <identifiersep> mime ) ) { } this . data <identifiersep> size = data <identifiersep> size ; this . mime <identifiersep> type = mime <identifiersep> type ; this . failure <identifiersep> code = failure <identifiersep> code ; this . failure <identifiersep> reason <identifiersep> long = failure <identifiersep> reason <identifiersep> long ; this . failure <identifiersep> reason <identifiersep> short = failure <identifiersep> reason <identifiersep> short ; <ect>
: get <identifiersep> current <identifiersep> client <identifiersep> permissions ( ) ; <comment> <LOG> if ( log <identifiersep> debug ) { } <comment> <ect>
if ( upload <identifiersep> from == upload <identifiersep> from . redirect ) { this . target <identifiersep> uri = message . redirect <identifiersep> target ; metadata m = new metadata ( document <identifiersep> type . simple <identifiersep> redirect , null , null , target <identifiersep> uri , cm ) ; try { temp <identifiersep> data = m . to <identifiersep> bucket ( server . core . client <identifiersep> context . get <identifiersep> bucket <identifiersep> factory ( is <identifiersep> persistent <identifiersep> forever ( ) ) ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { <LOG> <comment> <ect>
d . free ( ) ; } @ override protected freenet . client . async . client <identifiersep> requester get <identifiersep> client <identifiersep> request ( ) { return putter ; } @ override protected fcp <identifiersep> message persistent <identifiersep> tag <identifiersep> message ( ) { <LOG> if ( putter == null ) <comment> <ect>
if ( req == null ) { try { node . client <identifiersep> core . client <identifiersep> context . job <identifiersep> runner . queue ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { client <identifiersep> request req = handler . get <identifiersep> forever <identifiersep> request ( global , handler , identifier ) ; <LOG> if ( req == null ) { protocol <identifiersep> error <identifiersep> message msg = new protocol <identifiersep> error <identifiersep> message ( protocol <identifiersep> error <identifiersep> message . no <identifiersep> such <identifiersep> identifier , false , null , identifier , global ) ; handler . output <identifiersep> handler . queue ( msg ) ; return false ; } else { req . modify <identifiersep> request ( client <identifiersep> token , priority <identifiersep> class , handler . server ) ; <ect>
case wrong <identifiersep> return <identifiersep> type : return <string_literal> ; case io <identifiersep> error : return <string_literal> ; case persistence <identifiersep> disabled : return <string_literal> ; <LOG> default : return <string_literal> ; } } public protocol <identifiersep> error <identifiersep> message ( int code , boolean fatal , string extra , string ident , boolean global ) { this . code = code ; this . extra = extra ; this . fatal = fatal ; <ect>
<comment> public void put <identifiersep> store ( final plugin <identifiersep> store store ) throws persistence <identifiersep> disabled <identifiersep> exception { string name = this . plugin . get <identifiersep> class ( ) . get <identifiersep> canonical <identifiersep> name ( ) ; try { stores . write <identifiersep> plugin <identifiersep> store ( name , store ) ; <LOG> } catch ( io <identifiersep> exception e ) { return ; } } <comment> <ect>
this . node = node ; this . desperate = desperate ; } @ override public freenet <identifiersep> uri check <identifiersep> source ( string source ) throws plugin <identifiersep> not <identifiersep> found <identifiersep> exception { try { return new freenet <identifiersep> uri ( source ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + source , e ) ; } } @ override input <identifiersep> stream get <identifiersep> input <identifiersep> stream ( final plugin <identifiersep> progress progress ) throws io <identifiersep> exception , plugin <identifiersep> not <identifiersep> found <identifiersep> exception { freenet <identifiersep> uri uri = get <identifiersep> source ( ) ; system . out . println ( <string_literal> + uri ) ; <ect>
return res . as <identifiersep> bucket ( ) . get <identifiersep> input <identifiersep> stream ( ) ; } catch ( fetch <identifiersep> exception e ) { if ( ( e . get <identifiersep> mode ( ) == fetch <identifiersep> exception <identifiersep> mode . permanent <identifiersep> redirect ) || ( e . get <identifiersep> mode ( ) == fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> many <identifiersep> path <identifiersep> components ) ) { uri = e . new <identifiersep> uri ; continue ; } if ( e . is <identifiersep> fatal ( ) ) <LOG> fatal <identifiersep> failure = true ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + e . get <identifiersep> message ( ) + <string_literal> + get <identifiersep> source ( ) , e ) ; } } } @ override string get <identifiersep> plugin <identifiersep> name ( string source ) throws plugin <identifiersep> not <identifiersep> found <identifiersep> exception { return source . substring ( source . last <identifiersep> index <identifiersep> of ( ' / ' ) + 1 ) ; } @ override <ect>
public void start <identifiersep> shutdown <identifiersep> plugin ( plugin <identifiersep> manager manager , boolean reloading ) { unregister ( manager , reloading ) ; <comment> <LOG> } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } synchronized ( this ) { stopping = true ; } } public boolean finish <identifiersep> shutdown <identifiersep> plugin ( plugin <identifiersep> manager manager , long max <identifiersep> wait <identifiersep> time , boolean reloading ) { <ect>
private final program <identifiersep> directory plugin <identifiersep> stores <identifiersep> dir ; public plugin <identifiersep> stores ( node node , sub <identifiersep> config install <identifiersep> config ) throws node <identifiersep> init <identifiersep> exception { this . node = node ; plugin <identifiersep> stores <identifiersep> dir = node . setup <identifiersep> program <identifiersep> dir ( install <identifiersep> config , <string_literal> , <string_literal> , <string_literal> , <string_literal> , null , null ) ; file dir = plugin <identifiersep> stores <identifiersep> dir . dir ( ) ; <LOG> if ( ! ( dir . mkdirs ( ) || ( dir . exists ( ) && dir . is <identifiersep> directory ( ) && dir . can <identifiersep> read ( ) && dir . can <identifiersep> write ( ) ) ) ) { } } private void write <identifiersep> plugin <identifiersep> store <identifiersep> inner ( string store <identifiersep> identifier , plugin <identifiersep> store plugin <identifiersep> store , boolean is <identifiersep> encrypted , boolean backup ) throws io <identifiersep> exception { bucket bucket = make <identifiersep> plugin <identifiersep> store <identifiersep> bucket ( store <identifiersep> identifier , is <identifiersep> encrypted , backup ) ; output <identifiersep> stream os = bucket . get <identifiersep> output <identifiersep> stream ( ) ; try { if ( plugin <identifiersep> store != null ) { <ect>
<comment> <LOG> system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; <comment> <ect>
} , <string_literal> + plugin <identifiersep> name ) ; } public void send <identifiersep> sync <identifiersep> internal <identifiersep> only ( final simple <identifiersep> field <identifiersep> set plugparams , final bucket data2 ) { try { fred <identifiersep> plugin <identifiersep> fcp plug = plugin <identifiersep> ref . get ( ) ; if ( plug == null ) { <comment> <LOG> <comment> <ect>
certificate cert = it . next ( ) ; ks . set <identifiersep> certificate <identifiersep> entry ( cert . get <identifiersep> public <identifiersep> key ( ) . to <identifiersep> string ( ) , cert ) ; } file <identifiersep> output <identifiersep> stream tmp <identifiersep> fos = new file <identifiersep> output <identifiersep> stream ( tmp <identifiersep> keystore ) ; try { ks . store ( tmp <identifiersep> fos , new char [ 0 ] ) ; } finally { <LOG> closer . close ( tmp <identifiersep> fos ) ; } } catch ( exception e ) { system . err . println ( <string_literal> + e . get <identifiersep> message ( ) ) ; throw new io <identifiersep> exception ( <string_literal> + e ) ; } finally { closer . close ( fis ) ; <ect>
plugin <identifiersep> wrappers = new array <identifiersep> list < plugin <identifiersep> info <identifiersep> wrapper > ( ) ; plugins <identifiersep> failed <identifiersep> load = new hash <identifiersep> map < string , plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert > ( ) ; this . node = node ; this . core = node . client <identifiersep> core ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <LOG> if ( log <identifiersep> debug ) client = core . make <identifiersep> client ( prio , true , false ) ; <comment> <ect>
to <identifiersep> start = arrays . copy <identifiersep> of ( to <identifiersep> start , to <identifiersep> start . length + 1 ) ; to <identifiersep> start [ to <identifiersep> start . length - 1 ] = <string_literal> ; system . err . println ( <string_literal> ) ; } if ( contains ( to <identifiersep> start , <string_literal> ) ) { for ( int i = 0 ; i < to <identifiersep> start . length ; i ++ ) { if ( <string_literal> . equals ( to <identifiersep> start [ i ] ) ) <LOG> to <identifiersep> start [ i ] = <string_literal> ; } } <comment> <ect>
long now = system . current <identifiersep> time <identifiersep> millis ( ) ; long deadline = now + max <identifiersep> wait <identifiersep> time ; while ( true ) { int delta = ( int ) ( deadline - now ) ; if ( delta < = 0 ) { string list = plugin <identifiersep> list ( wrappers ) ; <LOG> logger . error ( this , <string_literal> + list ) ; } else { for ( iterator < plugin <identifiersep> info <identifiersep> wrapper > it = wrappers . list <identifiersep> iterator ( ) ; it . has <identifiersep> next ( ) ; ) { plugin <identifiersep> info <identifiersep> wrapper pi = it . next ( ) ; system . out . println ( <string_literal> + pi . get <identifiersep> filename ( ) ) ; if ( pi . finish <identifiersep> shutdown <identifiersep> plugin ( this , delta , false ) ) { <ect>
for ( iterator < plugin <identifiersep> info <identifiersep> wrapper > it = wrappers . list <identifiersep> iterator ( ) ; it . has <identifiersep> next ( ) ; ) { plugin <identifiersep> info <identifiersep> wrapper pi = it . next ( ) ; system . out . println ( <string_literal> + pi . get <identifiersep> filename ( ) ) ; if ( pi . finish <identifiersep> shutdown <identifiersep> plugin ( this , delta , false ) ) { it . remove ( ) ; } } if ( wrappers . is <identifiersep> empty ( ) ) { <LOG> logger . normal ( this , <string_literal> ) ; return ; } string list = plugin <identifiersep> list ( wrappers ) ; logger . error ( this , <string_literal> + list ) ; system . err . println ( <string_literal> + list ) ; } } } private static string plugin <identifiersep> list ( array <identifiersep> list < plugin <identifiersep> info <identifiersep> wrapper > wrappers ) { <ect>
it . remove ( ) ; } } if ( wrappers . is <identifiersep> empty ( ) ) { logger . normal ( this , <string_literal> ) ; system . out . println ( <string_literal> ) ; return ; } string list = plugin <identifiersep> list ( wrappers ) ; <LOG> logger . error ( this , <string_literal> + list ) ; } } } private static string plugin <identifiersep> list ( array <identifiersep> list < plugin <identifiersep> info <identifiersep> wrapper > wrappers ) { string <identifiersep> buffer sb = new string <identifiersep> buffer ( ) ; for ( plugin <identifiersep> info <identifiersep> wrapper pi : wrappers ) { sb . append ( pi . get <identifiersep> filename ( ) ) ; sb . append ( ' \\ n' ) ; <ect>
core . alerts . register ( new <identifiersep> alert ) ; core . alerts . unregister ( old <identifiersep> alert ) ; } catch ( unsupported <identifiersep> class <identifiersep> version <identifiersep> error e ) { logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; system . err . println ( <string_literal> + filename + <string_literal> + e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; logger . error ( this , <string_literal> + filename + <string_literal> ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , l10n ( <string_literal> , <string_literal> , filename ) ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; synchronized ( plugin <identifiersep> wrappers ) { <ect>
new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , l10n ( <string_literal> , <string_literal> , filename ) ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; synchronized ( plugin <identifiersep> wrappers ) { old <identifiersep> alert = plugins <identifiersep> failed <identifiersep> load . put ( filename , new <identifiersep> alert ) ; } core . alerts . register ( new <identifiersep> alert ) ; core . alerts . unregister ( old <identifiersep> alert ) ; <LOG> } catch ( throwable e ) { system . err . println ( <string_literal> + filename + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> + filename + <string_literal> ) ; logger . error ( this , <string_literal> + filename + <string_literal> ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = <ect>
old <identifiersep> alert = plugins <identifiersep> failed <identifiersep> load . put ( filename , new <identifiersep> alert ) ; } core . alerts . register ( new <identifiersep> alert ) ; core . alerts . unregister ( old <identifiersep> alert ) ; } catch ( throwable e ) { logger . error ( this , <string_literal> + filename + <string_literal> + e , e ) ; system . err . println ( <string_literal> + filename + <string_literal> + e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; logger . error ( this , <string_literal> + filename + <string_literal> ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert new <identifiersep> alert = new plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert ( filename , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet , false , e ) ; plugin <identifiersep> load <identifiersep> failed <identifiersep> user <identifiersep> alert old <identifiersep> alert = null ; synchronized ( plugin <identifiersep> wrappers ) { <ect>
<comment> <LOG> if ( plugin <identifiersep> is <identifiersep> trying <identifiersep> to <identifiersep> hijack <identifiersep> node <identifiersep> config ) { } else { toadlet toadlet = pi . get <identifiersep> config <identifiersep> toadlet ( ) ; core . get <identifiersep> toadlet <identifiersep> container ( ) . register ( toadlet , <string_literal> , toadlet . path ( ) , true , <string_literal> + pi . get <identifiersep> plugin <identifiersep> class <identifiersep> name ( ) + <string_literal> , <string_literal> + pi . get <identifiersep> plugin <identifiersep> class <identifiersep> name ( ) + <string_literal> , true , null , ( fred <identifiersep> plugin <identifiersep> l10n ) pi . get <identifiersep> plugin ( ) ) ; } } if ( pi . is <identifiersep> ip <identifiersep> detector <identifiersep> plugin ( ) ) node . ip <identifiersep> detector . register <identifiersep> ip <identifiersep> detector <identifiersep> plugin ( ( fred <identifiersep> plugin <identifiersep> ip <identifiersep> detector ) plug ) ; <ect>
public void unregister <identifiersep> plugin <identifiersep> toadlet ( plugin <identifiersep> info <identifiersep> wrapper pi ) { synchronized ( toadlet <identifiersep> list ) { try { toadlet <identifiersep> list . remove ( pi . get <identifiersep> plugin <identifiersep> class <identifiersep> name ( ) ) ; logger . normal ( this , <string_literal> + pi . get <identifiersep> plugin <identifiersep> class <identifiersep> name ( ) + ' / ' , new exception ( <string_literal> ) ) ; <LOG> } catch ( throwable ex ) { } } } public void add <identifiersep> toadlet <identifiersep> symlinks ( plugin <identifiersep> info <identifiersep> wrapper pi ) { synchronized ( toadlet <identifiersep> list ) { try { string targets [ ] = pi . get <identifiersep> plugin <identifiersep> toadlet <identifiersep> symlinks ( ) ; if ( targets == null ) <ect>
for ( string target : targets ) { rm = target ; toadlet <identifiersep> list . remove ( target ) ; pi . remove <identifiersep> plugin <identifiersep> toadlet <identifiersep> symlink ( target ) ; logger . normal ( this , <string_literal> + target + <string_literal> + pi . get <identifiersep> plugin <identifiersep> class <identifiersep> name ( ) + ' / ' ) ; } <LOG> } catch ( throwable ex ) { } } } public string dump <identifiersep> plugins ( ) { string <identifiersep> builder out = new string <identifiersep> builder ( ) ; synchronized ( plugin <identifiersep> wrappers ) { for ( int i = 0 ; i < plugin <identifiersep> wrappers . size ( ) ; i ++ ) { plugin <identifiersep> info <identifiersep> wrapper pi = plugin <identifiersep> wrappers . get ( i ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + plugin <identifiersep> file . get <identifiersep> absolute <identifiersep> path ( ) + <string_literal> + plugin <identifiersep> file . exists ( ) + <string_literal> + pdl + <string_literal> + name ) ; int retries = <number_literal> ; for ( int i = 0 ; i < retries ; i ++ ) { if ( ! plugin <identifiersep> file . exists ( ) || plugin <identifiersep> file . length ( ) == 0 ) try { <LOG> downloaded = true ; wrapper <identifiersep> manager . signal <identifiersep> starting ( ( int ) minutes . to <identifiersep> millis ( <number_literal> ) ) ; file temp <identifiersep> plugin <identifiersep> file = null ; output <identifiersep> stream plugin <identifiersep> output <identifiersep> stream = null ; input <identifiersep> stream plugin <identifiersep> input <identifiersep> stream = null ; try { <ect>
digest = pdl . get <identifiersep> sha1sum ( ) ; } else { testsum = get <identifiersep> file <identifiersep> digest ( plugin <identifiersep> file , <string_literal> ) ; } if ( digest != null && testsum == null ) { testsum = get <identifiersep> file <identifiersep> digest ( plugin <identifiersep> file , <string_literal> ) ; } if ( digest != null ) { <LOG> if ( ! ( digest . equals <identifiersep> ignore <identifiersep> case ( testsum ) ) ) { throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + digest + <string_literal> + testsum ) ; } } } catch ( io <identifiersep> exception ioe1 ) { logger . error ( this , <string_literal> , ioe1 ) ; if ( temp <identifiersep> plugin <identifiersep> file != null ) temp <identifiersep> plugin <identifiersep> file . delete ( ) ; <ect>
<comment> jar <identifiersep> file plugin <identifiersep> jar <identifiersep> file = null ; string plugin <identifiersep> main <identifiersep> class <identifiersep> name = null ; try { plugin <identifiersep> jar <identifiersep> file = new jar <identifiersep> file ( plugin <identifiersep> file ) ; manifest manifest = plugin <identifiersep> jar <identifiersep> file . get <identifiersep> manifest ( ) ; <LOG> if ( manifest == null ) { plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } attributes main <identifiersep> attributes = manifest . get <identifiersep> main <identifiersep> attributes ( ) ; if ( main <identifiersep> attributes == null ) { <ect>
if ( main <identifiersep> attributes == null ) { logger . error ( this , <string_literal> ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } plugin <identifiersep> main <identifiersep> class <identifiersep> name = main <identifiersep> attributes . get <identifiersep> value ( <string_literal> ) ; <LOG> if ( plugin <identifiersep> main <identifiersep> class <identifiersep> name == null ) { plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } if ( this . is <identifiersep> plugin <identifiersep> loaded ( plugin <identifiersep> main <identifiersep> class <identifiersep> name ) ) { logger . error ( this , <string_literal> + filename ) ; <ect>
long ver = - 1 ; if ( min <identifiersep> ver != - 1 ) { if ( object instanceof fred <identifiersep> plugin <identifiersep> real <identifiersep> versioned ) { ver = ( ( fred <identifiersep> plugin <identifiersep> real <identifiersep> versioned ) object ) . get <identifiersep> real <identifiersep> version ( ) ; } } <comment> <LOG> system . err . println ( <string_literal> + name + <string_literal> + min <identifiersep> ver + <string_literal> + ver ) ; <comment> <ect>
( ( fred <identifiersep> plugin <identifiersep> l10n ) object ) . set <identifiersep> language ( node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> selected <identifiersep> language ( ) ) ; } if ( object instanceof fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n ) { ( ( fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n ) object ) . set <identifiersep> language ( node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> selected <identifiersep> language ( ) ) ; } if ( object instanceof fred <identifiersep> plugin <identifiersep> themed ) { ( ( fred <identifiersep> plugin <identifiersep> themed ) object ) . set <identifiersep> theme ( fproxy <identifiersep> theme ) ; } return ( fred <identifiersep> plugin ) object ; <LOG> } catch ( io <identifiersep> exception ioe1 ) { plugin <identifiersep> file . delete ( ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ioe1 ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception cnfe1 ) { logger . error ( this , <string_literal> , cnfe1 ) ; plugin <identifiersep> file . delete ( ) ; <ect>
} catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception cnfe1 ) { logger . error ( this , <string_literal> , cnfe1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> + cnfe1 . get <identifiersep> message ( ) + <string_literal> , cnfe1 ) ; <LOG> } catch ( instantiation <identifiersep> exception ie1 ) { plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ie1 ) ; } catch ( illegal <identifiersep> access <identifiersep> exception iae1 ) { logger . error ( this , <string_literal> , iae1 ) ; <ect>
if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ie1 ) ; } catch ( illegal <identifiersep> access <identifiersep> exception iae1 ) { logger . error ( this , <string_literal> , iae1 ) ; plugin <identifiersep> file . delete ( ) ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , iae1 ) ; <LOG> } catch ( no <identifiersep> class <identifiersep> def <identifiersep> found <identifiersep> error ncdfe1 ) { plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ncdfe1 ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> , t ) ; <ect>
final fred <identifiersep> plugin <identifiersep> themed plug = ( fred <identifiersep> plugin <identifiersep> themed ) ( pi . plug ) ; executor . execute ( new runnable ( ) { @ override public void run ( ) { try { plug . set <identifiersep> theme ( css <identifiersep> name ) ; <LOG> } catch ( throwable t ) { } } } , <string_literal> ) ; } } } } public static void set <identifiersep> language ( language lang ) { if ( selfinstance == null ) return ; selfinstance . set <identifiersep> plugin <identifiersep> language ( lang ) ; } private void set <identifiersep> plugin <identifiersep> language ( final language lang ) { <ect>
final fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n plug = ( fred <identifiersep> plugin <identifiersep> base <identifiersep> l10n ) ( pi . plug ) ; executor . execute ( new runnable ( ) { @ override public void run ( ) { try { plug . set <identifiersep> language ( lang ) ; <LOG> } catch ( throwable t ) { } } } , <string_literal> ) ; } } } } public theme get <identifiersep> f <identifiersep> proxy <identifiersep> theme ( ) { return fproxy <identifiersep> theme ; } public boolean load <identifiersep> official <identifiersep> plugins <identifiersep> from <identifiersep> web ( ) { return always <identifiersep> load <identifiersep> official <identifiersep> plugins <identifiersep> from <identifiersep> central <identifiersep> server ; <ect>
throw new missing <identifiersep> resource <identifiersep> exception ( <string_literal> , this . get <identifiersep> class ( ) . get <identifiersep> name ( ) , <string_literal> ) ; } this . lang = selected <identifiersep> language ; logger . normal ( this . get <identifiersep> class ( ) , <string_literal> + this . lang ) ; try { this . load <identifiersep> override <identifiersep> file <identifiersep> or <identifiersep> backup ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> this . translation <identifiersep> override = null ; } this . current <identifiersep> translation = this . load <identifiersep> translation ( lang ) ; if ( this . current <identifiersep> translation == null ) { logger . error ( this , <string_literal> + lang + <string_literal> ) ; this . current <identifiersep> translation = null ; } } <comment> <ect>
input <identifiersep> stream in = null ; try { <comment> <LOG> } else { } } catch ( exception e ) { system . err . println ( <string_literal> + this . get <identifiersep> l10n <identifiersep> file <identifiersep> name ( lang ) + <string_literal> + e . get <identifiersep> message ( ) ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; result = null ; } finally { <ect>
fos = new file <identifiersep> output <identifiersep> stream ( temp <identifiersep> file ) ; this . translation <identifiersep> override . write <identifiersep> to <identifiersep> big <identifiersep> buffer ( fos ) ; fos . close ( ) ; fos = null ; file <identifiersep> util . rename <identifiersep> to ( temp <identifiersep> file , final <identifiersep> file ) ; logger . normal ( this . get <identifiersep> class ( ) , <string_literal> ) ; <LOG> } catch ( io <identifiersep> exception e ) { } finally { closer . close ( fos ) ; } } <comment> <ect>
<comment> private string get <identifiersep> fallback <identifiersep> string ( string key ) { this . load <identifiersep> fallback ( ) ; string result = this . fallback <identifiersep> translation . get ( key ) ; if ( result == null ) { <LOG> logger . error ( this . get <identifiersep> class ( ) , <string_literal> + key + <string_literal> ) ; new exception ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; } <comment> <ect>
context . main <identifiersep> executor . execute ( new runnable ( ) { @ override public void run ( ) { input <identifiersep> stream is = null ; try { compressor . compressor <identifiersep> type . lzma <identifiersep> new . decompress ( is = data . get <identifiersep> input <identifiersep> stream ( ) , os , data . size ( ) , expected <identifiersep> size ) ; <LOG> } catch ( compression <identifiersep> output <identifiersep> size <identifiersep> exception e ) { wrapper . set ( e ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; wrapper . set ( e ) ; } finally { <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; wrapper . set ( e ) ; } finally { try { os . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } closer . close ( is ) ; } } } ) ; is = pis ; } else if ( ctype == compressor <identifiersep> type . lzma ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <ect>
boolean got <identifiersep> metadata = false ; outer <identifiersep> zip : while ( true ) { entry = zis . get <identifiersep> next <identifiersep> entry ( ) ; if ( entry == null ) break ; if ( entry . is <identifiersep> directory ( ) ) continue ; string name = strip <identifiersep> leading <identifiersep> slashes ( entry . get <identifiersep> name ( ) ) ; <LOG> if ( names . contains ( name ) ) { continue ; } long size = entry . get <identifiersep> size ( ) ; if ( name . equals ( <string_literal> ) ) got <identifiersep> metadata = true ; if ( size > max <identifiersep> archived <identifiersep> file <identifiersep> size && ! name . equals ( element ) ) { <ect>
return add <identifiersep> store <identifiersep> element ( ctx , key , <string_literal> , bucket , got <identifiersep> element , element2 , callback , context ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { try { x = resolve ( e , x , temp <identifiersep> bucket <identifiersep> factory , ctx , key , got <identifiersep> element , element2 , callback , context ) ; } catch ( io <identifiersep> exception e1 ) { throw new archive <identifiersep> failure <identifiersep> exception ( <string_literal> + e1 , e1 ) ; } <LOG> } catch ( io <identifiersep> exception e1 ) { throw new archive <identifiersep> failure <identifiersep> exception ( <string_literal> + e1 , e1 ) ; } } } private int resolve ( metadata <identifiersep> unresolved <identifiersep> exception e , int x , bucket <identifiersep> factory bf , archive <identifiersep> store <identifiersep> context ctx , freenet <identifiersep> uri key , mutable <identifiersep> boolean got <identifiersep> element , string element2 , archive <identifiersep> extract <identifiersep> callback callback , client <identifiersep> context context ) throws io <identifiersep> exception , archive <identifiersep> failure <identifiersep> exception { for ( metadata m : e . must <identifiersep> resolve ) { try { add <identifiersep> store <identifiersep> element ( ctx , key , <string_literal> + ( x ++ ) , m . to <identifiersep> bucket ( bf ) , got <identifiersep> element , element2 , callback , context ) ; <ect>
super ( get <identifiersep> message ( m ) ) ; extra <identifiersep> message = null ; mode = m ; error <identifiersep> codes = null ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode m , long expected <identifiersep> size , boolean finalized <identifiersep> size , string expected <identifiersep> mime <identifiersep> type ) { super ( get <identifiersep> message ( m ) ) ; extra <identifiersep> message = null ; <ect>
this . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type = finalized <identifiersep> size ; mode = m ; error <identifiersep> codes = null ; new <identifiersep> uri = uri ; this . expected <identifiersep> size = expected <identifiersep> size ; this . expected <identifiersep> mime <identifiersep> type = expected <identifiersep> mime <identifiersep> type ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( metadata <identifiersep> parse <identifiersep> exception e ) { super ( get <identifiersep> message ( fetch <identifiersep> exception <identifiersep> mode . invalid <identifiersep> metadata ) + <string_literal> + e . get <identifiersep> message ( ) ) ; extra <identifiersep> message = e . get <identifiersep> message ( ) ; <ect>
extra <identifiersep> message = t . get <identifiersep> message ( ) ; this . mode = mode ; error <identifiersep> codes = null ; init <identifiersep> cause ( t ) ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , long expected <identifiersep> size , string reason , throwable t , string expected <identifiersep> mime <identifiersep> type ) { super ( reason + <string_literal> + get <identifiersep> message ( mode ) + <string_literal> + t . get <identifiersep> message ( ) ) ; extra <identifiersep> message = t . get <identifiersep> message ( ) ; <ect>
super ( get <identifiersep> message ( mode ) ) ; extra <identifiersep> message = null ; this . mode = mode ; error <identifiersep> codes = null ; this . new <identifiersep> uri = new <identifiersep> uri ; expected <identifiersep> size = - 1 ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , string msg , freenet <identifiersep> uri uri ) { super ( get <identifiersep> message ( mode ) + <string_literal> + msg ) ; extra <identifiersep> message = msg ; <ect>
this . new <identifiersep> uri = e . new <identifiersep> uri ; this . error <identifiersep> codes = e . error <identifiersep> codes ; this . expected <identifiersep> mime <identifiersep> type = e . expected <identifiersep> mime <identifiersep> type ; this . expected <identifiersep> size = e . expected <identifiersep> size ; this . extra <identifiersep> message = e . extra <identifiersep> message ; this . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type = e . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception e , freenet <identifiersep> uri uri ) { super ( e . get <identifiersep> message ( ) ) ; if ( e . get <identifiersep> cause ( ) != null ) <ect>
this . new <identifiersep> uri = e . new <identifiersep> uri ; this . error <identifiersep> codes = e . error <identifiersep> codes == null ? null : e . error <identifiersep> codes . clone ( ) ; this . expected <identifiersep> mime <identifiersep> type = e . expected <identifiersep> mime <identifiersep> type ; this . expected <identifiersep> size = e . expected <identifiersep> size ; this . extra <identifiersep> message = e . extra <identifiersep> message ; this . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type = e . finalized <identifiersep> size <identifiersep> and <identifiersep> mime <identifiersep> type ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } protected fetch <identifiersep> exception ( ) { <comment> <ect>
return false ; case archive <identifiersep> restart : case permanent <identifiersep> redirect : case wrong <identifiersep> mime <identifiersep> type : <comment> <LOG> default : return false ; <comment> <ect>
if ( splitfile <identifiersep> algorithm == splitfile <identifiersep> algorithm . nonredundant ) { <comment> <LOG> if ( splitfile <identifiersep> check <identifiersep> blocks > 0 ) { throw new metadata <identifiersep> parse <identifiersep> exception ( <string_literal> + splitfile <identifiersep> check <identifiersep> blocks + <string_literal> ) ; } } else if ( splitfile <identifiersep> algorithm == splitfile <identifiersep> algorithm . onion <identifiersep> standard ) { byte [ ] params = splitfile <identifiersep> params ( ) ; int check <identifiersep> blocks ; if ( get <identifiersep> parsed <identifiersep> version ( ) == 0 ) { <ect>
if ( data == null ) throw new null <identifiersep> pointer <identifiersep> exception ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key ) ; manifest <identifiersep> entries . put ( key , data ) ; } else if ( o instanceof hash <identifiersep> map ) { <LOG> if ( key . equals ( <string_literal> ) ) { } hash <identifiersep> map < string , object > hm = metadata . force <identifiersep> map ( o ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key ) ; metadata sub <identifiersep> map = mk <identifiersep> redirection <identifiersep> manifest <identifiersep> with <identifiersep> metadata ( hm ) ; manifest <identifiersep> entries . put ( key , sub <identifiersep> map ) ; <ect>
logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; } hash <identifiersep> map < string , object > hm = metadata . force <identifiersep> map ( o ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + key ) ; metadata sub <identifiersep> map = mk <identifiersep> redirection <identifiersep> manifest <identifiersep> with <identifiersep> metadata ( hm ) ; manifest <identifiersep> entries . put ( key , sub <identifiersep> map ) ; <LOG> if ( log <identifiersep> debug ) } } } <comment> <ect>
if ( doc <identifiersep> type == document <identifiersep> type . archive <identifiersep> metadata <identifiersep> redirect ) { document <identifiersep> type = doc <identifiersep> type ; target <identifiersep> name = name ; while ( true ) { if ( target <identifiersep> name . is <identifiersep> empty ( ) ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + name + <string_literal> ) ; if ( target <identifiersep> name . char <identifiersep> at ( 0 ) == ' / ' ) { <LOG> target <identifiersep> name = target <identifiersep> name . substring ( 1 ) ; continue ; } else break ; } } else throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; hashes = null ; <ect>
if ( insert ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; inc ( k . code , val ) ; } public void inc ( insert <identifiersep> exception <identifiersep> mode k , int val ) { if ( ! insert ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; inc ( k . code , val ) ; } public synchronized void inc ( integer k , int val ) { <LOG> if ( k == 0 ) { } if ( map == null ) map = new hash <identifiersep> map < integer , integer > ( ) ; integer key = k ; integer i = map . get ( key ) ; if ( i == null ) map . put ( key , 1 ) ; <ect>
random <identifiersep> access <identifiersep> bucket b ; try { b = m . to <identifiersep> bucket ( bucket <identifiersep> factory ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; <LOG> } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; } insert <identifiersep> block block = new insert <identifiersep> block ( b , null , insert <identifiersep> uri ) ; freenet <identifiersep> uri uri = insert ( block , false , null , true , priority <identifiersep> class ) ; block . free ( ) ; return uri ; <ect>
public null <identifiersep> client <identifiersep> callback ( request <identifiersep> client cb ) { this . cb = cb ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + e + <string_literal> + state , e ) ; } @ override <LOG> public void on <identifiersep> failure ( insert <identifiersep> exception e , base <identifiersep> client <identifiersep> putter state ) { } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; } @ override public void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { <ect>
public void on <identifiersep> failure ( insert <identifiersep> exception e , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + e + <string_literal> + state , e ) ; } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; } @ override <LOG> public void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + result + <string_literal> + state ) ; result . data . free ( ) ; } @ override <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + uri + <string_literal> + state ) ; } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + result + <string_literal> + state ) ; result . data . free ( ) ; } @ override <LOG> public void on <identifiersep> success ( base <identifiersep> client <identifiersep> putter state ) { } @ override public void on <identifiersep> generated <identifiersep> metadata ( bucket metadata , base <identifiersep> client <identifiersep> putter state ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + state ) ; metadata . free ( ) ; } @ override <ect>
client <identifiersep> event <identifiersep> listener [ ] list ; synchronized ( this ) { list = get <identifiersep> event <identifiersep> listeners ( ) ; } for ( client <identifiersep> event <identifiersep> listener cel : list ) { try { cel . receive ( ce , context ) ; <LOG> } catch ( exception ue ) { ue . print <identifiersep> stack <identifiersep> trace ( ) ; system . err . println ( <string_literal> ) ; } } } <comment> public synchronized client <identifiersep> event <identifiersep> listener [ ] get <identifiersep> event <identifiersep> listeners ( ) { client <identifiersep> event <identifiersep> listener [ ] ret = new client <identifiersep> event <identifiersep> listener [ listeners . size ( ) ] ; <ect>
extra = common <identifiersep> extra <identifiersep> bytes ; } } else { int offset = x * extra <identifiersep> bytes <identifiersep> length ; extra = arrays . copy <identifiersep> of <identifiersep> range ( extra <identifiersep> bytes <identifiersep> for <identifiersep> keys , offset , offset + extra <identifiersep> bytes <identifiersep> length ) ; } try { return new client <identifiersep> chk ( routing <identifiersep> key , decrypt <identifiersep> key , extra ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { throw new illegal <identifiersep> state <identifiersep> exception ( e ) ; } } private node <identifiersep> chk get <identifiersep> node <identifiersep> key ( int x , boolean copy ) { int xr = x * node <identifiersep> chk . key <identifiersep> length ; byte [ ] routing <identifiersep> key = arrays . copy <identifiersep> of <identifiersep> range ( routing <identifiersep> keys , xr , xr + node <identifiersep> chk . key <identifiersep> length ) ; byte [ ] extra ; <ect>
public void on <identifiersep> success ( ) { boolean fail = false ; synchronized ( this ) { if ( failed ) { fail = true ; } else { <LOG> if ( succeeded ) { return ; } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; } succeeded = true ; } } if ( fail ) { <ect>
return want <identifiersep> binary <identifiersep> blob ; } @ override public base <identifiersep> sendable <identifiersep> get get <identifiersep> sendable <identifiersep> get ( ) { return getter ; } @ override public void restarted <identifiersep> after <identifiersep> data <identifiersep> corruption ( ) { <LOG> if ( has <identifiersep> finished ( ) ) return ; <comment> <ect>
logger . error ( this , <string_literal> + this + <string_literal> + e , e ) ; parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <LOG> } catch ( throwable e ) { parent . fail ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ) ; } finally { chunk . release ( ) ; synchronized ( split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage . this ) { try <identifiersep> decode = false ; <ect>
if ( blocks <identifiersep> fetched [ i ] < 0 || blocks <identifiersep> fetched [ i ] > total <identifiersep> blocks ) { logger . warning ( this , <string_literal> + i + <string_literal> + blocks <identifiersep> fetched [ i ] ) ; if ( blocks <identifiersep> fetched [ i ] != - 1 ) blocks <identifiersep> fetched [ i ] = - 1 ; maybe <identifiersep> blocks . add ( new my <identifiersep> block ( all <identifiersep> blocks [ i ] , ( short ) - 1 , i ) ) ; continue ; <LOG> } else if ( used [ blocks <identifiersep> fetched [ i ] ] ) { blocks <identifiersep> fetched [ i ] = - 1 ; continue ; } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + blocks <identifiersep> fetched [ i ] + <string_literal> + i ) ; maybe <identifiersep> blocks . add ( new my <identifiersep> block ( all <identifiersep> blocks [ i ] , blocks <identifiersep> fetched [ i ] , i ) ) ; <ect>
client <identifiersep> chk <identifiersep> block block = client <identifiersep> chk <identifiersep> block . encode <identifiersep> splitfile <identifiersep> block ( buf , decode <identifiersep> key . get <identifiersep> crypto <identifiersep> key ( ) , decode <identifiersep> key . get <identifiersep> crypto <identifiersep> algorithm ( ) ) ; client <identifiersep> chk actual <identifiersep> key = block . get <identifiersep> client <identifiersep> key ( ) ; if ( decode <identifiersep> key == null || ! decode <identifiersep> key . equals ( actual <identifiersep> key ) ) { <comment> <LOG> if ( block <identifiersep> number == - 1 ) { failed = true ; synchronized ( this ) { block <identifiersep> chooser . on <identifiersep> un <identifiersep> success ( block <identifiersep> number ) ; if ( blocks <identifiersep> fetched [ test . slot ] == test . block <identifiersep> number ) { blocks <identifiersep> fetched [ test . slot ] = ( short ) - 1 ; <ect>
parent . fail ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . splitfile <identifiersep> decode <identifiersep> error , <string_literal> ) ) ; return ; } } if ( capturing <identifiersep> binary <identifiersep> blob ) parent . fetcher . maybe <identifiersep> add <identifiersep> to <identifiersep> binary <identifiersep> blob ( block ) ; } catch ( chk <identifiersep> encode <identifiersep> exception e ) { <comment> <LOG> parent . fail ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> ) ) ; return ; } } } private boolean check <identifiersep> encoded <identifiersep> data <identifiersep> blocks ( byte [ ] [ ] check <identifiersep> blocks , boolean [ ] check <identifiersep> blocks <identifiersep> present , split <identifiersep> file <identifiersep> segment <identifiersep> keys keys , boolean capturing <identifiersep> binary <identifiersep> blob ) { for ( int i = 0 ; i < check <identifiersep> blocks . length ; i ++ ) { if ( check <identifiersep> blocks <identifiersep> present [ i ] ) continue ; <ect>
logger . error ( this , <string_literal> + i + <string_literal> + this + <string_literal> + parent ) ; return false ; } if ( capturing <identifiersep> binary <identifiersep> blob ) parent . fetcher . maybe <identifiersep> add <identifiersep> to <identifiersep> binary <identifiersep> blob ( block ) ; } catch ( chk <identifiersep> encode <identifiersep> exception e ) { <comment> <LOG> parent . fail ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> ) ) ; return false ; } } return true ; } private void queue <identifiersep> heal ( byte [ ] [ ] data <identifiersep> blocks , byte [ ] [ ] check <identifiersep> blocks , boolean [ ] data <identifiersep> blocks <identifiersep> present , boolean [ ] check <identifiersep> blocks <identifiersep> present ) throws io <identifiersep> exception { for ( int i = 0 ; i < data <identifiersep> blocks . length ; i ++ ) { if ( data <identifiersep> blocks <identifiersep> present [ i ] ) continue ; <ect>
try { decoded <identifiersep> block = new client <identifiersep> chk <identifiersep> block ( block , decode <identifiersep> key ) ; decoded <identifiersep> data = decoded <identifiersep> block . memory <identifiersep> decode ( ) ; } catch ( chk <identifiersep> verify <identifiersep> exception e ) { logger . error ( this , <string_literal> + decode <identifiersep> key ) ; return false ; <LOG> } catch ( chk <identifiersep> decode <identifiersep> exception e ) { return false ; } return inner <identifiersep> on <identifiersep> got <identifiersep> key ( key , decoded <identifiersep> block , keys , block <identifiersep> number , decoded <identifiersep> data ) ; } <comment> <ect>
raf <identifiersep> lock lock = parent . lock <identifiersep> raf <identifiersep> open ( ) ; try { write <identifiersep> downloaded <identifiersep> block ( slot <identifiersep> number , decoded <identifiersep> data ) ; saved = true ; } catch ( io <identifiersep> exception e ) { blocks <identifiersep> fetched [ slot <identifiersep> number ] = - 1 ; <LOG> block <identifiersep> chooser . on <identifiersep> un <identifiersep> success ( block <identifiersep> number ) ; throw e ; } finally { lock . unlock ( ) ; } if ( cross <identifiersep> segments <identifiersep> by <identifiersep> block != null && block <identifiersep> number < cross <identifiersep> segments <identifiersep> by <identifiersep> block . length ) { callback = cross <identifiersep> segments <identifiersep> by <identifiersep> block [ block <identifiersep> number ] ; <ect>
for ( int i = 0 ; i < blocks <identifiersep> fetched . length ; i ++ ) { if ( blocks <identifiersep> fetched [ i ] == block <identifiersep> num ) { byte [ ] buf = read <identifiersep> block ( i ) ; try { client <identifiersep> chk <identifiersep> block block = client <identifiersep> chk <identifiersep> block . encode <identifiersep> splitfile <identifiersep> block ( buf , key . get <identifiersep> crypto <identifiersep> key ( ) , key . get <identifiersep> crypto <identifiersep> algorithm ( ) ) ; <LOG> if ( ! ( block . get <identifiersep> client <identifiersep> key ( ) . equals ( key ) ) ) { block <identifiersep> chooser . on <identifiersep> un <identifiersep> success ( block <identifiersep> num ) ; succeeded = false ; finished = false ; } else { return buf ; <ect>
finished = false ; } else { return buf ; } } catch ( chk <identifiersep> encode <identifiersep> exception e ) { <comment> <LOG> return null ; } } } return null ; } synchronized void resume <identifiersep> callback ( int block <identifiersep> no , split <identifiersep> file <identifiersep> fetcher <identifiersep> cross <identifiersep> segment <identifiersep> storage cross <identifiersep> segment ) { this . cross <identifiersep> segments <identifiersep> by <identifiersep> block [ block <identifiersep> no ] = cross <identifiersep> segment ; } public synchronized boolean has <identifiersep> block ( int block <identifiersep> no ) { return block <identifiersep> chooser . has <identifiersep> succeeded ( block <identifiersep> no ) ; <ect>
synchronized ( this ) { for ( key key : check <identifiersep> keys ) { final <identifiersep> keys <identifiersep> to <identifiersep> check . add ( key ) ; } queue <identifiersep> item queue <identifiersep> item = new queue <identifiersep> item ( final <identifiersep> keys <identifiersep> to <identifiersep> check . to <identifiersep> array ( new key [ final <identifiersep> keys <identifiersep> to <identifiersep> check . size ( ) ] ) , getter , blocks ) ; <LOG> if ( log <identifiersep> minor && queue [ prio ] . contains ( queue <identifiersep> item ) ) { return ; } queue [ prio ] . add ( queue <identifiersep> item ) ; wake <identifiersep> up ( ) ; } } @ override public void run ( ) { <ect>
try { context . job <identifiersep> runner . queue ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { try { scheduler . finish <identifiersep> register ( new sendable <identifiersep> get [ ] { get } , true , valid ) ; <LOG> } catch ( throwable t ) { try { get . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error , <string_literal> + t , t ) , null , context ) ; } catch ( throwable t1 ) { logger . error ( this , <string_literal> + t , t ) ; } } return false ; <ect>
boolean definitive ; public compatibility <identifiersep> analyser ( ) { this . min = compatibility <identifiersep> mode . compat <identifiersep> unknown ; this . max = compatibility <identifiersep> mode . compat <identifiersep> unknown ; this . dont <identifiersep> compress = true ; } public void merge ( compatibility <identifiersep> mode min , compatibility <identifiersep> mode max , byte [ ] crypto <identifiersep> key , boolean dont <identifiersep> compress , boolean definitive ) { <LOG> if ( this . definitive ) { return ; } assert ( min != compatibility <identifiersep> mode . compat <identifiersep> current ) ; assert ( max != compatibility <identifiersep> mode . compat <identifiersep> current ) ; if ( definitive ) this . definitive = true ; if ( ! dont <identifiersep> compress ) this . dont <identifiersep> compress = false ; <ect>
byte [ ] my <identifiersep> data = bucket <identifiersep> tools . to <identifiersep> byte <identifiersep> array ( data ) ; if ( arrays . equals ( my <identifiersep> data , his <identifiersep> data ) ) { <comment> <LOG> } catch ( io <identifiersep> exception e ) { } } if ( persistent ) { fetcher = null ; } } if ( already <identifiersep> inserted ) { <comment> <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; if ( ! added ) { cb . on <identifiersep> failure ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , pub <identifiersep> usk . get <identifiersep> ssk ( edition ) . get <identifiersep> uri ( ) ) , this , context ) ; return ; } <comment> <LOG> } catch ( insert <identifiersep> exception e ) { if ( ! added ) { cb . on <identifiersep> failure ( e , this , context ) ; return ; } <comment> <ect>
fetcher = null ; } if ( tag != null ) { tag . cancel ( context ) ; } if ( sbi != null ) { sbi . cancel ( context ) ; <comment> <LOG> if ( data == null ) { } else { data . free ( ) ; synchronized ( this ) { data = null ; } } } cb . on <identifiersep> failure ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . cancelled ) , this , context ) ; <ect>
cancel ( context ) ; } @ override public void on <identifiersep> encode ( base <identifiersep> client <identifiersep> key key , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { <comment> <LOG> <comment> <ect>
public short get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) { return parent . get <identifiersep> priority <identifiersep> class ( ) ; } @ override public short get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) { return parent . get <identifiersep> priority <identifiersep> class ( ) ; } @ override <LOG> public void on <identifiersep> metadata ( bucket meta , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { meta . free ( ) ; } private transient boolean resumed = false ; @ override public void on <identifiersep> resume ( client <identifiersep> context context ) throws insert <identifiersep> exception , resume <identifiersep> failed <identifiersep> exception { if ( resumed ) return ; <ect>
data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( bais ) ; long flags = dis . read <identifiersep> long ( ) ; if ( ( flags & has <identifiersep> checked <identifiersep> datastore <identifiersep> flag ) != 0 ) has <identifiersep> checked <identifiersep> datastore = true ; errors = new failure <identifiersep> code <identifiersep> tracker ( false , dis ) ; dis . close ( ) ; <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <comment> <ect>
for ( split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage segment : broken <identifiersep> segments ) { segment . try <identifiersep> start <identifiersep> decode ( ) ; } } } if ( key <identifiersep> listener . needs <identifiersep> keys ( ) ) { try { this . job <identifiersep> runner . queue ( new persistent <identifiersep> job ( ) { @ override <LOG> public boolean run ( client <identifiersep> context context ) { logger . error ( this , <string_literal> + split <identifiersep> file <identifiersep> fetcher <identifiersep> storage . this ) ; key <identifiersep> salter salt = fetcher . get <identifiersep> salter ( ) ; for ( int i = 0 ; i < segments . length ; i ++ ) { split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage segment = segments [ i ] ; try { <ect>
try { key <identifiersep> listener . initial <identifiersep> write <identifiersep> segment <identifiersep> bloom <identifiersep> filters ( offset <identifiersep> segment <identifiersep> bloom <identifiersep> filters ) ; key <identifiersep> listener . inner <identifiersep> write <identifiersep> main <identifiersep> bloom <identifiersep> filter ( offset <identifiersep> main <identifiersep> bloom <identifiersep> filter ) ; } catch ( io <identifiersep> exception e ) { if ( persistent ) fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } <LOG> fetcher . restarted <identifiersep> after <identifiersep> data <identifiersep> corruption ( ) ; system . out . println ( <string_literal> + split <identifiersep> file <identifiersep> fetcher <identifiersep> storage . this ) ; return false ; } } , native <identifiersep> thread . low <identifiersep> priority + 1 ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
throws io <identifiersep> exception { lockable <identifiersep> random <identifiersep> access <identifiersep> buffer . raf <identifiersep> lock lock = raf . lock <identifiersep> open ( ) ; try { for ( split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage segment : segments ) { segment . write <identifiersep> to <identifiersep> inner ( os ) ; } os . close ( ) ; <LOG> } catch ( throwable t ) { } finally { lock . unlock ( ) ; } } @ override public long size ( ) { return final <identifiersep> length ; <ect>
<comment> public void fail <identifiersep> on <identifiersep> segment ( split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage segment ) { fail ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . splitfile <identifiersep> error , errors ) ) ; } <LOG> public void fail <identifiersep> on <identifiersep> disk <identifiersep> error ( final io <identifiersep> exception e ) { job <identifiersep> runner . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { fetcher . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; return true ; <ect>
logger . minor ( this , <string_literal> + max <identifiersep> retries + <string_literal> + r + <string_literal> + this + <string_literal> + finished + <string_literal> + cancelled ) ; if ( ( r < = max <identifiersep> retries ) || ( max <identifiersep> retries == - 1 ) ) { check <identifiersep> cached <identifiersep> cooldown <identifiersep> data ( ) ; if ( cached <identifiersep> cooldown <identifiersep> tries == 0 || r % cached <identifiersep> cooldown <identifiersep> tries == 0 ) { <comment> <LOG> if ( cooldown <identifiersep> wakeup <identifiersep> time > now ) { } else { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; cooldown <identifiersep> wakeup <identifiersep> time = now + cached <identifiersep> cooldown <identifiersep> time ; reduce <identifiersep> wakeup <identifiersep> time ( cooldown <identifiersep> wakeup <identifiersep> time , context ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + time <identifiersep> util . format <identifiersep> time ( cooldown <identifiersep> wakeup <identifiersep> time - now ) ) ; <ect>
if ( finished ) return null ; if ( cancelled ) return null ; } if ( key == null ) { logger . error ( this , <string_literal> + this + <string_literal> , new exception ( <string_literal> ) ) ; return null ; } key new <identifiersep> key = key . get <identifiersep> node <identifiersep> key ( true ) ; <LOG> if ( parent == null ) { return null ; } short prio = parent . get <identifiersep> priority <identifiersep> class ( ) ; key <identifiersep> listener ret = new single <identifiersep> key <identifiersep> listener ( new <identifiersep> key , this , prio , persistent ) ; return ret ; } protected abstract void not <identifiersep> found <identifiersep> in <identifiersep> store ( client <identifiersep> context context ) ; <ect>
<comment> public void remove <identifiersep> pending <identifiersep> keys ( has <identifiersep> key <identifiersep> listener getter , boolean complain ) { boolean found = sched <identifiersep> transient . remove <identifiersep> pending <identifiersep> keys ( getter ) ; if ( sched <identifiersep> core != null ) found | = sched <identifiersep> core . remove <identifiersep> pending <identifiersep> keys ( getter ) ; <LOG> if ( complain && ! found ) } public void reregister <identifiersep> all ( final client <identifiersep> requester request , short old <identifiersep> prio ) { selector . reregister <identifiersep> all ( request , this , client <identifiersep> context , old <identifiersep> prio ) ; starter . wake <identifiersep> up ( ) ; } public string get <identifiersep> choosen <identifiersep> priority <identifiersep> scheduler ( ) { return choosen <identifiersep> priority <identifiersep> scheduler ; <ect>
insert . on <identifiersep> failure ( e , null , context ) ; return false ; } @ override public string to <identifiersep> string ( ) { return <string_literal> ; } } , prio ) ; <LOG> } catch ( persistence <identifiersep> disabled <identifiersep> exception e1 ) { } } } @ override public client <identifiersep> context get <identifiersep> context ( ) { return client <identifiersep> context ; } <comment> <ect>
raf . close ( ) ; raf . free ( ) ; original <identifiersep> data . close ( ) ; if ( free <identifiersep> data ) original <identifiersep> data . free ( ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; <LOG> } catch ( storage <identifiersep> format <identifiersep> exception e ) { raf . close ( ) ; raf . free ( ) ; original <identifiersep> data . close ( ) ; if ( free <identifiersep> data ) original <identifiersep> data . free ( ) ; <ect>
public void start <identifiersep> temporary <identifiersep> background <identifiersep> fetcher ( usk usk , client <identifiersep> context context , final fetch <identifiersep> context fctx , boolean prefetch <identifiersep> content , boolean real <identifiersep> time <identifiersep> flag ) { final usk clear = usk . clear <identifiersep> copy ( ) ; usk <identifiersep> fetcher sched = null ; array <identifiersep> list < usk <identifiersep> fetcher > to <identifiersep> cancel = null ; synchronized ( this ) { <comment> <LOG> <comment> <ect>
<comment> public void subscribe ( usk orig <identifiersep> usk , usk <identifiersep> callback cb , boolean run <identifiersep> background <identifiersep> fetch , boolean ignore <identifiersep> usk <identifiersep> datehints , request <identifiersep> client client ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + orig <identifiersep> usk + <string_literal> + cb ) ; if ( client . persistent ( ) ) throw new unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> ) ; usk <identifiersep> fetcher sched = null ; long ed = orig <identifiersep> usk . suggested <identifiersep> edition ; <LOG> if ( ed < 0 ) { ed = - ed ; } long cur <identifiersep> ed ; cur <identifiersep> ed = lookup <identifiersep> latest <identifiersep> slot ( orig <identifiersep> usk ) ; long good <identifiersep> ed ; good <identifiersep> ed = lookup <identifiersep> known <identifiersep> good ( orig <identifiersep> usk ) ; <ect>
if ( ! is <identifiersep> metadata ) context . usk <identifiersep> manager . update <identifiersep> known <identifiersep> good ( usk , uu . get <identifiersep> suggested <identifiersep> edition ( ) , context ) ; else <comment> <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { } catch ( throwable t ) { <comment> <ect>
request <identifiersep> starters . set <identifiersep> global <identifiersep> salt ( salt ) ; } } else if ( ! has <identifiersep> loaded ( ) ) { <comment> <LOG> request <identifiersep> starters , random ) ) { system . err . println ( <string_literal> ) ; inner <identifiersep> set <identifiersep> files <identifiersep> and <identifiersep> load ( true , dir , base <identifiersep> name , write <identifiersep> encrypted , encryption <identifiersep> key , context , request <identifiersep> starters , random ) ; } on <identifiersep> started ( no <identifiersep> write ) ; } else { <ect>
private void delete <identifiersep> file ( file dir , string base <identifiersep> name , boolean backup , boolean encrypted ) { file f = make <identifiersep> filename ( dir , base <identifiersep> name , backup , encrypted ) ; try { file <identifiersep> util . secure <identifiersep> delete ( f ) ; } catch ( io <identifiersep> exception e ) { f . delete ( ) ; <LOG> if ( f . exists ( ) ) { system . err . println ( <string_literal> ) ; <comment> <ect>
if ( write <identifiersep> encrypted && encryption <identifiersep> key == null ) throw new master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception ( ) ; file old <identifiersep> write <identifiersep> to <identifiersep> filename = write <identifiersep> to <identifiersep> filename ; write <identifiersep> to <identifiersep> bucket = make <identifiersep> bucket ( dir , base <identifiersep> name , false , write <identifiersep> encrypted ? encryption <identifiersep> key : null ) ; write <identifiersep> to <identifiersep> filename = make <identifiersep> filename ( dir , base <identifiersep> name , false , write <identifiersep> encrypted ) ; write <identifiersep> to <identifiersep> backup <identifiersep> filename = make <identifiersep> filename ( dir , base <identifiersep> name , true , write <identifiersep> encrypted ) ; <LOG> if ( write <identifiersep> to <identifiersep> filename . equals ( old <identifiersep> write <identifiersep> to <identifiersep> filename ) ) return ; delete <identifiersep> after <identifiersep> successful <identifiersep> write = make <identifiersep> filename ( dir , base <identifiersep> name , false , ! write <identifiersep> encrypted ) ; other <identifiersep> delete <identifiersep> after <identifiersep> successful <identifiersep> write = make <identifiersep> filename ( dir , base <identifiersep> name , true , ! write <identifiersep> encrypted ) ; queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { <ect>
if ( loaded . done <identifiersep> something ( ) ) { if ( ! no <identifiersep> serialize ) { on <identifiersep> loading ( ) ; if ( loaded . get <identifiersep> salt ( ) == null ) { salt = new byte [ <number_literal> ] ; random . next <identifiersep> bytes ( salt ) ; <LOG> logger . error ( this , <string_literal> ) ; new <identifiersep> salt = true ; } else { salt = loaded . salt ; } } int success = 0 ; int restored <identifiersep> restarted = 0 ; <ect>
if ( restored <identifiersep> restarted > 0 ) system . out . println ( <string_literal> + restored <identifiersep> restarted + <string_literal> ) ; if ( failed > 0 ) system . err . println ( <string_literal> + failed + <string_literal> ) ; return failed <identifiersep> serialize ; } else { <LOG> <comment> <ect>
try { fis = bucket . get <identifiersep> input <identifiersep> stream ( ) ; inner <identifiersep> load ( loaded , fis , length , ! no <identifiersep> serialize && ! loaded . done <identifiersep> something ( ) , context , request <identifiersep> starters , random , no <identifiersep> serialize ) ; } catch ( io <identifiersep> exception e ) { <comment> <LOG> logger . error ( this , <string_literal> + bucket + <string_literal> + e , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; loaded . set <identifiersep> something <identifiersep> failed ( ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + bucket + <string_literal> + t , t ) ; system . err . println ( <string_literal> + bucket + <string_literal> + t ) ; <ect>
<comment> <LOG> logger . error ( this , <string_literal> + bucket + <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; loaded . set <identifiersep> something <identifiersep> failed ( ) ; } finally { try { if ( fis != null ) fis . close ( ) ; <ect>
int version = ois . read <identifiersep> int ( ) ; if ( version != version ) throw new io <identifiersep> exception ( <string_literal> ) ; byte [ ] salt = new byte [ <number_literal> ] ; try { checker . read <identifiersep> and <identifiersep> checksum ( ois , salt , 0 , salt . length ) ; loaded . set <identifiersep> salt ( salt ) ; <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e1 ) { } request <identifiersep> starters . set <identifiersep> global <identifiersep> salt ( salt ) ; int request <identifiersep> count = ois . read <identifiersep> int ( ) ; for ( int i = 0 ; i < request <identifiersep> count ; i ++ ) { client <identifiersep> request request = null ; request <identifiersep> identifier req <identifiersep> id = read <identifiersep> request <identifiersep> identifier ( ois ) ; <ect>
continue ; } try { if ( ! no <identifiersep> serialize ) { request = ( client <identifiersep> request ) read <identifiersep> checksummed <identifiersep> object ( ois , length ) ; if ( request != null ) { if ( req <identifiersep> id != null ) { <LOG> if ( ! req <identifiersep> id . same <identifiersep> identifier ( request . get <identifiersep> request <identifiersep> identifier ( ) ) ) { request = null ; } else { loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , request , request <identifiersep> load <identifiersep> status . loaded ) ; } } } } else skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; <ect>
request = null ; } else { loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , request , request <identifiersep> load <identifiersep> status . loaded ) ; } } } } else skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> ) ; } catch ( throwable t ) { <comment> <ect>
skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; system . err . println ( <string_literal> ) ; } catch ( throwable t ) { <comment> <LOG> logger . error ( this , <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } if ( request == null || log <identifiersep> minor ) { try { client <identifiersep> request restored = read <identifiersep> request <identifiersep> from <identifiersep> recovery <identifiersep> data ( ois , length , req <identifiersep> id ) ; if ( request == null && restored != null ) { <ect>
request = restored ; boolean loaded <identifiersep> fully = restored . fully <identifiersep> resumed ( ) ; loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , request , loaded <identifiersep> fully ? request <identifiersep> load <identifiersep> status . restored <identifiersep> fully : request <identifiersep> load <identifiersep> status . restored <identifiersep> restarted ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { if ( request == null ) { <LOG> logger . error ( this , <string_literal> ) ; } else { logger . error ( this , <string_literal> + req <identifiersep> id ) ; } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { <ect>
system . err . println ( <string_literal> ) ; } else { logger . error ( this , <string_literal> + req <identifiersep> id ) ; } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { <LOG> if ( request == null ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } else { logger . error ( this , <string_literal> + req <identifiersep> id + <string_literal> + e , e ) ; } if ( request == null ) <ect>
loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { if ( request == null ) { logger . error ( this , <string_literal> + e , e ) ; system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } else { } if ( request == null ) loaded . add <identifiersep> partially <identifiersep> loaded <identifiersep> request ( req <identifiersep> id , null , request <identifiersep> load <identifiersep> status . failed ) ; } } else { skip <identifiersep> checksummed <identifiersep> object ( ois , length ) ; } } if ( latest ) { <ect>
this . bandwidth <identifiersep> stats <identifiersep> putter . add <identifiersep> from ( stored <identifiersep> stats <identifiersep> putter ) ; int count = ois . read <identifiersep> int ( ) ; delayed <identifiersep> free [ ] buckets = new delayed <identifiersep> free [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { try { buckets [ i ] = ( delayed <identifiersep> free ) read <identifiersep> checksummed <identifiersep> object ( ois , length ) ; <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { } } persistent <identifiersep> temp <identifiersep> factory . finish <identifiersep> delayed <identifiersep> free ( buckets ) ; } @ override protected void inner <identifiersep> checkpoint ( boolean shutdown ) { save ( shutdown ) ; } protected void save ( boolean shutdown ) { <ect>
write <identifiersep> checksummed <identifiersep> object ( oos , bucket , null ) ; } oos . close ( ) ; fos = null ; logger . normal ( this , <string_literal> + requests . length + <string_literal> + write <identifiersep> to <identifiersep> filename ) ; persistent <identifiersep> temp <identifiersep> factory . finish <identifiersep> delayed <identifiersep> free ( buckets ) ; return true ; <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; } finally { try { if ( fos != null ) fos . close ( ) ; <ect>
prepend <identifiersep> length <identifiersep> output <identifiersep> stream oos = checker . checksum <identifiersep> writer <identifiersep> with <identifiersep> length ( os , temp <identifiersep> bucket <identifiersep> factory ) ; data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( oos ) ; try { req . get <identifiersep> client <identifiersep> detail ( dos , checker ) ; dos . close ( ) ; oos = null ; <LOG> } catch ( throwable e ) { system . err . println ( <string_literal> + req + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; oos . abort ( ) ; } finally { if ( oos != null ) oos . close ( ) ; <ect>
data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( tmp ) ; client <identifiersep> request request = client <identifiersep> request . restart <identifiersep> from ( dis , req <identifiersep> id , get <identifiersep> client <identifiersep> context ( ) , checker ) ; dis . close ( ) ; dis = null ; tmp = null ; return request ; <LOG> } catch ( throwable t ) { return null ; } finally { if ( tmp != null ) tmp . close ( ) ; } } private void write <identifiersep> checksummed <identifiersep> object ( object <identifiersep> output <identifiersep> stream os , object req , string name ) throws io <identifiersep> exception { prepend <identifiersep> length <identifiersep> output <identifiersep> stream oos = checker . checksum <identifiersep> writer <identifiersep> with <identifiersep> length ( os , temp <identifiersep> bucket <identifiersep> factory ) ; <ect>
object <identifiersep> input <identifiersep> stream oo = new object <identifiersep> input <identifiersep> stream ( ois ) ; object ret = oo . read <identifiersep> object ( ) ; oo . close ( ) ; oo = null ; ois = null ; return ret ; <LOG> } catch ( throwable t ) { return null ; } finally { if ( ois != null ) ois . close ( ) ; } } private void skip <identifiersep> checksummed <identifiersep> object ( object <identifiersep> input <identifiersep> stream is , long total <identifiersep> length ) throws io <identifiersep> exception { long length = is . read <identifiersep> long ( ) ; <ect>
} catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; return null ; } data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( buf ) ) ; try { return new request <identifiersep> identifier ( dis ) ; <LOG> } catch ( io <identifiersep> exception e ) { return null ; } } private void write <identifiersep> request <identifiersep> identifier ( data <identifiersep> output os , request <identifiersep> identifier req ) throws io <identifiersep> exception { byte <identifiersep> array <identifiersep> output <identifiersep> stream baos = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; output <identifiersep> stream oos = checker . checksum <identifiersep> writer ( baos ) ; data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( oos ) ; <ect>
this . ctx = fctx ; this . cb = cb ; this . orig <identifiersep> usk = orig <identifiersep> usk ; this . proxy = this ; } @ override public void on <identifiersep> found <identifiersep> edition ( long l , usk key , client <identifiersep> context context , boolean metadata , short codec , byte [ ] data , boolean new <identifiersep> known <identifiersep> good , boolean new <identifiersep> slot <identifiersep> too ) { <LOG> if ( l < 0 ) { return ; } if ( l < orig <identifiersep> usk . suggested <identifiersep> edition ) { logger . warning ( this , <string_literal> + l + <string_literal> + orig <identifiersep> usk . suggested <identifiersep> edition ) ; return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + l + <string_literal> + this + <string_literal> ) ; <ect>
@ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> get <identifiersep> state state , client <identifiersep> context context ) { switch ( e . mode ) { case not <identifiersep> enough <identifiersep> path <identifiersep> components : case permanent <identifiersep> redirect : context . usk <identifiersep> manager . update <identifiersep> known <identifiersep> good ( orig <identifiersep> usk , state . get <identifiersep> token ( ) , context ) ; <LOG> return ; } } @ override public void on <identifiersep> block <identifiersep> set <identifiersep> finished ( client <identifiersep> get <identifiersep> state state , client <identifiersep> context context ) { <comment> <ect>
if ( blocks <identifiersep> found [ i ] ) { <comment> <LOG> if ( ! found ) { return ; } if ( total <identifiersep> found < data <identifiersep> block <identifiersep> count ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + total <identifiersep> found + <string_literal> + data <identifiersep> block <identifiersep> count + <string_literal> + segments . length + <string_literal> ) ; return ; } try <identifiersep> decode <identifiersep> or <identifiersep> encode ( priority <identifiersep> class ) ; <ect>
check <identifiersep> decoded <identifiersep> block ( i + data <identifiersep> block <identifiersep> count , check <identifiersep> blocks [ i ] ) ; } } } synchronized ( this ) { succeeded = true ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + decoded + <string_literal> + encoded ) ; } private void check <identifiersep> decoded <identifiersep> block ( int i , byte [ ] data ) { client <identifiersep> chk key = get <identifiersep> key ( i ) ; <LOG> if ( key == null ) { fail <identifiersep> off <identifiersep> thread ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> ) ) ; return ; } client <identifiersep> chk <identifiersep> block block = encode <identifiersep> block ( key , data ) ; string decoded = i >= data <identifiersep> block <identifiersep> count ? <string_literal> : <string_literal> ; if ( block == null || ! key . get <identifiersep> node <identifiersep> chk ( ) . equals ( block . get <identifiersep> key ( ) ) ) { <ect>
boolean success = segments [ block <identifiersep> no ] . inner <identifiersep> on <identifiersep> got <identifiersep> key ( key . get <identifiersep> node <identifiersep> chk ( ) , block , keys , block <identifiersep> numbers [ block <identifiersep> no ] , data ) ; if ( success ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } else { <LOG> <comment> <ect>
return ; } status = status . encoded <identifiersep> cross <identifiersep> segments ; } start <identifiersep> segment <identifiersep> encode ( ) ; } private void on <identifiersep> completed <identifiersep> segment <identifiersep> encode ( ) { synchronized ( this ) { if ( status == status . encoded ) return ; <comment> <LOG> if ( ! ( status == status . encoded <identifiersep> cross <identifiersep> segments || ( cross <identifiersep> segments == null && status == status . started ) ) ) { return ; } status = status . encoded ; } callback . on <identifiersep> finished <identifiersep> encode ( ) ; } public void on <identifiersep> has <identifiersep> keys ( split <identifiersep> file <identifiersep> inserter <identifiersep> segment <identifiersep> storage split <identifiersep> file <identifiersep> inserter <identifiersep> segment <identifiersep> storage ) { for ( split <identifiersep> file <identifiersep> inserter <identifiersep> segment <identifiersep> storage segment : segments ) { <ect>
assert ( block <identifiersep> no >= 0 && block <identifiersep> no < segments [ seg <identifiersep> no ] . total <identifiersep> block <identifiersep> count ) ; long file <identifiersep> offset = this . offset <identifiersep> segment <identifiersep> keys [ seg <identifiersep> no ] + key <identifiersep> length * block <identifiersep> no ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + block <identifiersep> no + <string_literal> + seg <identifiersep> no + <string_literal> + this + <string_literal> + file <identifiersep> offset ) ; raf . pwrite ( file <identifiersep> offset , buf , 0 , buf . length ) ; } byte [ ] inner <identifiersep> read <identifiersep> segment <identifiersep> key ( int seg <identifiersep> no , int block <identifiersep> no ) throws io <identifiersep> exception { byte [ ] buf = new byte [ key <identifiersep> length ] ; <LOG> long file <identifiersep> offset = this . offset <identifiersep> segment <identifiersep> keys [ seg <identifiersep> no ] + key <identifiersep> length * block <identifiersep> no ; raf . pread ( file <identifiersep> offset , buf , 0 , buf . length ) ; return buf ; } public int total <identifiersep> cross <identifiersep> check <identifiersep> blocks ( ) { return segments . length * cross <identifiersep> check <identifiersep> blocks ; } <comment> <ect>
<comment> <LOG> if ( e . mode == insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error || e . mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else logger . normal ( this , <string_literal> + e + <string_literal> + this , e ) ; job <identifiersep> runner . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( new persistent <identifiersep> job ( ) { @ override public boolean run ( client <identifiersep> context context ) { <ect>
@ override public void on <identifiersep> success ( client <identifiersep> key <identifiersep> block block , boolean from <identifiersep> store , object token , client <identifiersep> context context ) { if ( parent instanceof client <identifiersep> getter ) ( ( client <identifiersep> getter ) parent ) . add <identifiersep> key <identifiersep> to <identifiersep> binary <identifiersep> blob ( block , context ) ; parent . completed <identifiersep> block ( from <identifiersep> store , context ) ; <comment> <LOG> if ( block == null ) { return ; } bucket data = extract ( block , context ) ; if ( key instanceof client <identifiersep> ssk ) { context . usk <identifiersep> manager . check <identifiersep> usk ( uri , persistent , data != null && ! block . is <identifiersep> metadata ( ) ) ; } if ( data == null ) { <ect>
<comment> <LOG> } else { throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . unknown <identifiersep> metadata ) ; } } } private string remove <identifiersep> meta <identifiersep> string ( ) { string name = meta <identifiersep> strings . remove ( 0 ) ; if ( added <identifiersep> meta <identifiersep> strings > 0 ) added <identifiersep> meta <identifiersep> strings -- ; return name ; <ect>
decompressor <identifiersep> manager . wait <identifiersep> finished ( ) ; worker . wait <identifiersep> finished ( ) ; <comment> <LOG> } catch ( throwable t ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; return ; } finally { closer . close ( pipe <identifiersep> out ) ; closer . close ( pipe <identifiersep> in ) ; <ect>
pipe <identifiersep> in . close ( ) ; output = null ; pipe <identifiersep> out = null ; pipe <identifiersep> in = null ; <comment> <LOG> } catch ( throwable t ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; return ; } finally { boolean dbrs <identifiersep> finished ; synchronized ( usk <identifiersep> fetcher . this ) { <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } string line ; try { line = new string ( data , <string_literal> ) ; <LOG> } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { return ; } catch ( throwable t ) { <comment> <ect>
} catch ( throwable t ) { <comment> <LOG> if ( split . length < <number_literal> ) { return ; } if ( ! split [ 0 ] . starts <identifiersep> with ( <string_literal> ) ) { logger . error ( this , <string_literal> + line + <string_literal> ) ; return ; } string value = split [ 1 ] ; <ect>
logger . error ( this , <string_literal> + line + <string_literal> ) ; return ; } string value = split [ 1 ] ; long hint ; try { hint = long . parse <identifiersep> long ( value ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + hint + <string_literal> + this . fetcher . get <identifiersep> key ( null ) . get <identifiersep> uri ( ) + <string_literal> + usk <identifiersep> fetcher . this ) ; process <identifiersep> dbr <identifiersep> hint ( hint , context , this ) ; } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> get <identifiersep> state state , <ect>
for ( usk <identifiersep> fetcher <identifiersep> callback c : cb ) { try { if ( ed == - 1 ) c . on <identifiersep> failure ( context ) ; else c . on <identifiersep> found <identifiersep> edition ( ed , orig <identifiersep> usk . copy ( ed ) , context , last <identifiersep> was <identifiersep> metadata , last <identifiersep> compression <identifiersep> codec , data , false , false ) ; <LOG> } catch ( exception e ) { } } } } void on <identifiersep> success ( usk <identifiersep> attempt att , boolean dont <identifiersep> update , client <identifiersep> ssk <identifiersep> block block , final client <identifiersep> context context ) { on <identifiersep> success ( att , att . number , dont <identifiersep> update , block , context ) ; } void on <identifiersep> success ( usk <identifiersep> attempt att , long cur <identifiersep> latest , boolean dont <identifiersep> update , client <identifiersep> ssk <identifiersep> block block , final client <identifiersep> context context ) { final long last <identifiersep> ed = usk <identifiersep> manager . lookup <identifiersep> latest <identifiersep> slot ( orig <identifiersep> usk ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + cur <identifiersep> latest + <string_literal> + orig <identifiersep> usk + <string_literal> + last <identifiersep> ed + <string_literal> + this ) ; <ect>
if ( decode && block != null ) { try { data = block . decode ( context . get <identifiersep> bucket <identifiersep> factory ( parent . persistent ( ) ) , <number_literal> <comment> , true ) ; } catch ( key <identifiersep> decode <identifiersep> exception e ) { data = null ; } catch ( io <identifiersep> exception e ) { <LOG> data = null ; } } synchronized ( this ) { if ( decode ) { if ( block != null ) { last <identifiersep> compression <identifiersep> codec = block . get <identifiersep> compression <identifiersep> codec ( ) ; last <identifiersep> was <identifiersep> metadata = block . is <identifiersep> metadata ( ) ; <ect>
usk <identifiersep> attempt [ ] attempts ; usk <identifiersep> attempt [ ] polling ; dbr <identifiersep> attempt [ ] atts ; usk <identifiersep> manager . on <identifiersep> finished ( this ) ; sendable <identifiersep> get store <identifiersep> checker ; bucket data ; <LOG> synchronized ( this ) { if ( completed ) logger . error ( this , <string_literal> + this ) ; cancelled = true ; attempts = running <identifiersep> attempts . values ( ) . to <identifiersep> array ( new usk <identifiersep> attempt [ running <identifiersep> attempts . size ( ) ] ) ; polling = polling <identifiersep> attempts . values ( ) . to <identifiersep> array ( new usk <identifiersep> attempt [ polling <identifiersep> attempts . size ( ) ] ) ; atts = dbr <identifiersep> attempts . to <identifiersep> array ( new dbr <identifiersep> attempt [ dbr <identifiersep> attempts . size ( ) ] ) ; <ect>
if ( looked <identifiersep> up < 0 ) looked <identifiersep> up = 0 ; for ( int i = 1 ; i < = orig <identifiersep> min <identifiersep> failures ; i ++ ) { long ed = i + looked <identifiersep> up ; lookup l = new lookup ( ) ; l . val = ed ; boolean poll = background <identifiersep> poll ; <LOG> if ( ( ( ! poll ) && to <identifiersep> fetch . contains ( l ) ) || ( poll && to <identifiersep> poll . contains ( l ) ) ) { continue ; } if ( already <identifiersep> running . remove ( l ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + l ) ; continue ; } client <identifiersep> ssk key ; <ect>
key = orig <identifiersep> usk . get <identifiersep> ssk ( ed ) ; l . key = key ; l . ignore <identifiersep> store = true ; if ( poll ) { if ( ! to <identifiersep> poll . contains ( l ) ) { to <identifiersep> poll . add ( l ) ; <LOG> } else { } } else { if ( ! to <identifiersep> fetch . contains ( l ) ) { to <identifiersep> fetch . add ( l ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + l ) ; <ect>
return new sendable <identifiersep> get [ ] { fetcher } ; } @ override public boolean handle <identifiersep> block ( key key , byte [ ] salted <identifiersep> key , key <identifiersep> block found , client <identifiersep> context context ) { if ( ! key . equals ( this . key ) ) return false ; try { fetcher . on <identifiersep> got <identifiersep> key ( key , found , context ) ; <LOG> } catch ( throwable t ) { fetcher . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) , null , context ) ; } synchronized ( this ) { done = true ; } return true ; } @ override <ect>
array <identifiersep> list < key <identifiersep> listener > matches = new array <identifiersep> list < key <identifiersep> listener > ( ) ; synchronized ( this ) { for ( key <identifiersep> listener listener : key <identifiersep> listeners ) { has <identifiersep> key <identifiersep> listener hkl ; try { hkl = listener . get <identifiersep> has <identifiersep> key <identifiersep> listener ( ) ; <LOG> } catch ( throwable t ) { continue ; } if ( hkl == has <identifiersep> listener ) { matches . add ( listener ) ; } } } if ( matches . is <identifiersep> empty ( ) ) { return false ; <ect>
if ( matches . is <identifiersep> empty ( ) ) { return priority ; } for ( key <identifiersep> listener listener : matches ) { short prio ; try { prio = listener . definitely <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key , sched . client <identifiersep> context ) ; <LOG> } catch ( throwable t ) { continue ; } if ( prio == - 1 ) continue ; if ( prio < priority ) priority = prio ; } return priority ; } public synchronized long count <identifiersep> waiting <identifiersep> keys ( ) { <ect>
list < key <identifiersep> listener > matches = probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ; if ( ! matches . is <identifiersep> empty ( ) ) { for ( key <identifiersep> listener listener : matches ) { try { if ( listener . definitely <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key , sched . client <identifiersep> context ) >= 0 ) { return true ; } <LOG> } catch ( throwable t ) { } } } return false ; } public synchronized boolean any <identifiersep> probably <identifiersep> want <identifiersep> key ( key key , client <identifiersep> context context ) { assert ( key instanceof node <identifiersep> ssk == is <identifiersep> ssk <identifiersep> scheduler ) ; byte [ ] salted <identifiersep> key = salt <identifiersep> key ( key ) ; for ( key <identifiersep> listener listener : key <identifiersep> listeners ) { <ect>
if ( listener . probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ) { return true ; } } catch ( throwable t ) { logger . error ( this , format ( <string_literal> , listener ) , t ) ; } } return false ; } public boolean trip <identifiersep> pending <identifiersep> key ( key key , key <identifiersep> block block , client <identifiersep> context context ) { <LOG> if ( ( key instanceof node <identifiersep> ssk ) != is <identifiersep> ssk <identifiersep> scheduler ) { return false ; } assert ( key instanceof node <identifiersep> ssk == is <identifiersep> ssk <identifiersep> scheduler ) ; byte [ ] salted <identifiersep> key = salt <identifiersep> key ( key ) ; list < key <identifiersep> listener > matches = probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ; boolean ret = false ; <ect>
ret = true ; } } catch ( throwable t ) { logger . error ( this , format ( <string_literal> , listener ) , t ) ; } if ( listener . is <identifiersep> empty ( ) ) { try { remove <identifiersep> pending <identifiersep> keys ( listener ) ; <LOG> } catch ( throwable t ) { } } } return ret ; } public sendable <identifiersep> get [ ] requests <identifiersep> for <identifiersep> key ( key key , client <identifiersep> context context ) { array <identifiersep> list < sendable <identifiersep> get > list = new array <identifiersep> list < sendable <identifiersep> get > ( ) ; assert ( key instanceof node <identifiersep> ssk == is <identifiersep> ssk <identifiersep> scheduler ) ; byte [ ] salted <identifiersep> key = salt <identifiersep> key ( key ) ; <ect>
array <identifiersep> list < key <identifiersep> listener > matches = new array <identifiersep> list < key <identifiersep> listener > ( ) ; synchronized ( this ) { for ( key <identifiersep> listener listener : key <identifiersep> listeners ) { try { if ( ! listener . probably <identifiersep> want <identifiersep> key ( key , salted <identifiersep> key ) ) { continue ; } <LOG> } catch ( throwable t ) { continue ; } matches . add ( listener ) ; } } return matches ; } } <ect>
synchronized ( running <identifiersep> inserts ) { return running <identifiersep> inserts . contains ( token ) ; } } public boolean add <identifiersep> running <identifiersep> insert ( sendable <identifiersep> request <identifiersep> item <identifiersep> key token ) { synchronized ( running <identifiersep> inserts ) { boolean retval = running <identifiersep> inserts . add ( token ) ; if ( ! retval ) { <LOG> <comment> <ect>
random <identifiersep> grab <identifiersep> array <identifiersep> with <identifiersep> object < client <identifiersep> request <identifiersep> scheduler <identifiersep> group > rga = request <identifiersep> grabber . get <identifiersep> grabber ( group ) ; if ( rga == null ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + request , new exception ( <string_literal> ) ) ; return ; } request <identifiersep> grabber . maybe <identifiersep> remove ( rga , context ) ; request <identifiersep> grabber = make <identifiersep> srga <identifiersep> for <identifiersep> client ( new <identifiersep> prio , client , context ) ; <LOG> if ( request <identifiersep> grabber . get <identifiersep> grabber ( group ) != null ) { <string_literal> + rga , new exception ( <string_literal> ) ) ; request <identifiersep> grabber . maybe <identifiersep> remove ( rga , context ) ; } request <identifiersep> grabber . add <identifiersep> grabber ( group , rga , context ) ; } } public synchronized long count <identifiersep> queued <identifiersep> requests ( client <identifiersep> context context ) { long total = 0 ; <ect>
public synchronized long count <identifiersep> queued <identifiersep> requests ( client <identifiersep> context context ) { long total = 0 ; for ( int i = 0 ; i < priorities . length ; i ++ ) { request <identifiersep> client <identifiersep> rga <identifiersep> node prio = priorities [ i ] ; if ( prio == null || prio . is <identifiersep> empty ( ) ) system . out . println ( <string_literal> + i + <string_literal> ) ; <LOG> else { system . out . println ( <string_literal> + prio . size ( ) + <string_literal> + prio ) ; for ( int k = 0 ; k < prio . size ( ) ; k ++ ) { request <identifiersep> client client = prio . get <identifiersep> client ( k ) ; system . out . println ( <string_literal> + k + <string_literal> + client ) ; client <identifiersep> request <identifiersep> rga <identifiersep> node request <identifiersep> grabber = prio . get <identifiersep> grabber ( client ) ; <ect>
if ( prio == null || prio . is <identifiersep> empty ( ) ) system . out . println ( <string_literal> + i + <string_literal> ) ; else { system . out . println ( <string_literal> + i + <string_literal> + prio . size ( ) ) ; system . out . println ( <string_literal> + prio . size ( ) + <string_literal> + prio ) ; for ( int k = 0 ; k < prio . size ( ) ; k ++ ) { <LOG> request <identifiersep> client client = prio . get <identifiersep> client ( k ) ; client <identifiersep> request <identifiersep> rga <identifiersep> node request <identifiersep> grabber = prio . get <identifiersep> grabber ( client ) ; system . out . println ( <string_literal> + request <identifiersep> grabber ) ; for ( int l = 0 ; l < request <identifiersep> grabber . size ( ) ; l ++ ) { client <identifiersep> request <identifiersep> scheduler <identifiersep> group cr = request <identifiersep> grabber . get <identifiersep> client ( l ) ; system . out . println ( <string_literal> + l + <string_literal> + cr ) ; <ect>
for ( int k = 0 ; k < prio . size ( ) ; k ++ ) { request <identifiersep> client client = prio . get <identifiersep> client ( k ) ; system . out . println ( <string_literal> + k + <string_literal> + client ) ; client <identifiersep> request <identifiersep> rga <identifiersep> node request <identifiersep> grabber = prio . get <identifiersep> grabber ( client ) ; system . out . println ( <string_literal> + request <identifiersep> grabber ) ; for ( int l = 0 ; l < request <identifiersep> grabber . size ( ) ; l ++ ) { <LOG> client <identifiersep> request <identifiersep> scheduler <identifiersep> group cr = request <identifiersep> grabber . get <identifiersep> client ( l ) ; random <identifiersep> grab <identifiersep> array rga = request <identifiersep> grabber . get <identifiersep> grabber ( cr ) ; system . out . println ( <string_literal> + rga . size ( ) + <string_literal> + rga ) ; long sendable = 0 ; long all = 0 ; for ( int m = 0 ; m < rga . size ( ) ; m ++ ) { <ect>
long sendable = 0 ; long all = 0 ; for ( int m = 0 ; m < rga . size ( ) ; m ++ ) { sendable <identifiersep> request req = ( sendable <identifiersep> request ) rga . get ( m ) ; if ( req == null ) continue ; sendable += req . count <identifiersep> sendable <identifiersep> keys ( context ) ; <LOG> all += req . count <identifiersep> all <identifiersep> keys ( context ) ; } total += all ; } } } } return total ; } <comment> <ect>
<comment> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <comment> <LOG> } catch ( compression <identifiersep> output <identifiersep> size <identifiersep> exception e ) { ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> big , e ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . not <identifiersep> enough <identifiersep> disk <identifiersep> space ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <ect>
ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . too <identifiersep> big , e ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . not <identifiersep> enough <identifiersep> disk <identifiersep> space ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; <LOG> } catch ( fetch <identifiersep> exception e ) { ex = e ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) ; } finally { <ect>
logger . minor ( this , <string_literal> + block . get <identifiersep> client <identifiersep> key ( ) . get <identifiersep> uri ( ) + <string_literal> + this , new exception ( <string_literal> ) ) ; try { binary <identifiersep> blob <identifiersep> writer . add <identifiersep> key ( block , context ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + e ) , null , context ) ; <LOG> } catch ( binary <identifiersep> blob <identifiersep> already <identifiersep> closed <identifiersep> exception e ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + e ) , null , context ) ; } } <comment> protected boolean collecting <identifiersep> binary <identifiersep> blob ( ) { return binary <identifiersep> blob <identifiersep> writer != null ; } <comment> <ect>
public void inner <identifiersep> on <identifiersep> resume ( client <identifiersep> context context ) throws resume <identifiersep> failed <identifiersep> exception { super . inner <identifiersep> on <identifiersep> resume ( context ) ; if ( current <identifiersep> state != null ) try { current <identifiersep> state . on <identifiersep> resume ( context ) ; } catch ( fetch <identifiersep> exception e ) { <LOG> current <identifiersep> state = null ; throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } catch ( runtime <identifiersep> exception e ) { <comment> <ect>
public boolean resume <identifiersep> from <identifiersep> trivial <identifiersep> progress ( data <identifiersep> input <identifiersep> stream dis , client <identifiersep> context context ) throws io <identifiersep> exception { if ( dis . read <identifiersep> boolean ( ) ) { try { current <identifiersep> state = new split <identifiersep> file <identifiersep> fetcher ( this , dis , context ) ; resumed <identifiersep> fetcher = true ; return true ; <LOG> } catch ( storage <identifiersep> format <identifiersep> exception e ) { return false ; } catch ( resume <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return false ; } catch ( io <identifiersep> exception e ) { <ect>
} catch ( storage <identifiersep> format <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return false ; } catch ( resume <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return false ; <LOG> } catch ( io <identifiersep> exception e ) { return false ; } } else return false ; } public boolean resumed <identifiersep> fetcher ( ) { return resumed <identifiersep> fetcher ; } @ override <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } metadata <identifiersep> dirty = false ; } <comment> <LOG> } catch ( io <identifiersep> exception e ) { parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } } private void inner <identifiersep> store <identifiersep> status ( data <identifiersep> output <identifiersep> stream dos ) throws io <identifiersep> exception { dos . write <identifiersep> int ( seg <identifiersep> no ) ; <comment> <ect>
generate <identifiersep> keys ( check <identifiersep> blocks , data <identifiersep> block <identifiersep> count + cross <identifiersep> check <identifiersep> block <identifiersep> count ) ; synchronized ( this ) { encoded = true ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + parent ) ; } catch ( io <identifiersep> exception e ) { parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; <LOG> } catch ( throwable t ) { parent . fail ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t , null ) ) ; } finally { if ( lock != null ) lock . unlock ( ) ; } } <comment> <ect>
if ( parent . checker . check <identifiersep> checksum ( check <identifiersep> buf , 0 , check <identifiersep> buf . length , checksum ) ) throw new missing <identifiersep> key <identifiersep> exception ( ) ; data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( buf ) ) ; byte b = dis . read <identifiersep> byte ( ) ; if ( b != 1 ) throw new missing <identifiersep> key <identifiersep> exception ( ) ; client <identifiersep> chk key = inner <identifiersep> read <identifiersep> key ( dis ) ; <LOG> set <identifiersep> has <identifiersep> key ( block <identifiersep> number ) ; return key ; } public class missing <identifiersep> key <identifiersep> exception extends exception { private static final long serial <identifiersep> version <identifiersep> uid = - 6695311996193392803l ; } <comment> <ect>
ctr = counter ++ ; if ( running <identifiersep> inserters . size ( ) > max <identifiersep> running ) return false ; try { sbi = new single <identifiersep> block <identifiersep> inserter ( this , data , ( short ) - 1 , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri , ctx , real <identifiersep> time <identifiersep> flag , this , false , chk <identifiersep> block . data <identifiersep> length , ctr , false , false , data , context , false , true , 0 , crypto <identifiersep> algorithm , crypto <identifiersep> key ) ; <LOG> } catch ( throwable e ) { return false ; } running <identifiersep> inserters . put ( data , sbi ) ; } try { sbi . schedule ( context ) ; if ( log <identifiersep> minor ) <ect>
data . free ( ) ; } @ override public void on <identifiersep> encode ( base <identifiersep> client <identifiersep> key usk , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { <comment> <LOG> <comment> <ect>
super . cancel ( ) ; } @ override public int get <identifiersep> min <identifiersep> success <identifiersep> fetch <identifiersep> blocks ( ) { return 0 ; } @ override public void on <identifiersep> metadata ( bucket meta , client <identifiersep> put <identifiersep> state state , <LOG> client <identifiersep> context context ) { meta . free ( ) ; } @ override public void inner <identifiersep> on <identifiersep> resume ( client <identifiersep> context context ) { <comment> <ect>
inserter . on <identifiersep> start <identifiersep> compression ( comp , context ) ; return false ; } } , native <identifiersep> thread . norm <identifiersep> priority + 1 ) ; } else { try { inserter . on <identifiersep> start <identifiersep> compression ( comp , context ) ; <LOG> } catch ( throwable t ) { } } input <identifiersep> stream is = null ; output <identifiersep> stream os = null ; multi <identifiersep> hash <identifiersep> input <identifiersep> stream hasher = null ; try { is = orig <identifiersep> data . get <identifiersep> input <identifiersep> stream ( ) ; <ect>
best <identifiersep> compressed <identifiersep> data = result ; best <identifiersep> compressed <identifiersep> data <identifiersep> size = result <identifiersep> size ; best <identifiersep> number <identifiersep> of <identifiersep> blocks = result <identifiersep> number <identifiersep> of <identifiersep> blocks ; best <identifiersep> codec = comp ; should <identifiersep> free <identifiersep> on <identifiersep> finally = false ; } } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <LOG> if ( ! context . job <identifiersep> runner . shutting <identifiersep> down ( ) ) should <identifiersep> free <identifiersep> on <identifiersep> finally = true ; if ( best <identifiersep> compressed <identifiersep> data != null && best <identifiersep> compressed <identifiersep> data != orig <identifiersep> data && best <identifiersep> compressed <identifiersep> data != result ) best <identifiersep> compressed <identifiersep> data . free ( ) ; } finally { if ( should <identifiersep> free <identifiersep> on <identifiersep> finally && ( result != null ) && result != orig <identifiersep> data ) <ect>
public void run ( ) { try { inserter . on <identifiersep> compressed ( output , context ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> , t ) ; } } } , <string_literal> + this ) ; } <LOG> } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { if ( best <identifiersep> compressed <identifiersep> data != null && best <identifiersep> compressed <identifiersep> data != orig <identifiersep> data ) best <identifiersep> compressed <identifiersep> data . free ( ) ; } catch ( invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception e ) { fail ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) , context , best <identifiersep> compressed <identifiersep> data ) ; } catch ( final io <identifiersep> exception e ) { <ect>
} catch ( eof <identifiersep> exception e ) { <comment> <LOG> if ( ! hash <identifiersep> result . strict <identifiersep> equals ( results , hashes ) ) { throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> hash <identifiersep> failed ) ; } } on <identifiersep> finish ( ) ; } catch ( throwable t ) { if ( ! ( t instanceof fetch <identifiersep> exception || t instanceof unsafe <identifiersep> content <identifiersep> type <identifiersep> exception || t instanceof compression <identifiersep> output <identifiersep> size <identifiersep> exception ) ) logger . error ( this , <string_literal> + t , t ) ; <ect>
@ override public object get <identifiersep> token ( ) { return token ; } @ override public void schedule ( client <identifiersep> context context ) throws insert <identifiersep> exception { start ( context ) ; } <LOG> private void start ( client <identifiersep> context context ) { make <identifiersep> metadata ( context ) ; synchronized ( this ) { if ( finished ) return ; } insert <identifiersep> block block ; output <identifiersep> stream os = null ; <ect>
if ( o instanceof hash <identifiersep> map ) { @ suppress <identifiersep> warnings ( <string_literal> ) hash <identifiersep> map < string , object > hm = ( hash <identifiersep> map < string , object > ) o ; hash <identifiersep> map < string , object > sub <identifiersep> map = new hash <identifiersep> map < string , object > ( ) ; <comment> <LOG> if ( log <identifiersep> debug ) } else if ( o instanceof metadata ) { <comment> <ect>
client <identifiersep> metadata cm ; if ( mime <identifiersep> type == null || mime <identifiersep> type . equals ( default <identifiersep> mime <identifiersep> types . default <identifiersep> mime <identifiersep> type ) ) cm = null ; else cm = new client <identifiersep> metadata ( mime <identifiersep> type ) ; metadata m ; <LOG> if ( element . target <identifiersep> uri != null ) { m = new metadata ( document <identifiersep> type . simple <identifiersep> redirect , null , null , element . target <identifiersep> uri , cm ) ; } else { <comment> <ect>
} catch ( insert <identifiersep> exception e ) { throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error , e . to <identifiersep> string ( ) + <string_literal> + e . get <identifiersep> message ( ) , e ) ; } catch ( io <identifiersep> exception e ) { throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error , e . to <identifiersep> string ( ) + <string_literal> + e . get <identifiersep> message ( ) , e ) ; } catch ( invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception e ) { throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error , e . to <identifiersep> string ( ) + <string_literal> + e . get <identifiersep> message ( ) , e ) ; } <LOG> if ( b == null ) { return false ; } key = encoded <identifiersep> block . get <identifiersep> client <identifiersep> key ( ) ; k = key ; context . get <identifiersep> job <identifiersep> runner ( block . persistent ) . queue <identifiersep> normal <identifiersep> or <identifiersep> drop ( new persistent <identifiersep> job ( ) { @ override <ect>
key <identifiersep> block collided = core . node . fetch ( k . get <identifiersep> node <identifiersep> key ( ) , true , req . can <identifiersep> write <identifiersep> client <identifiersep> cache , false , false , null ) ; if ( collided == null ) { logger . error ( this , <string_literal> ) ; <comment> <LOG> } catch ( key <identifiersep> collision <identifiersep> exception e2 ) { throw new low <identifiersep> level <identifiersep> put <identifiersep> exception ( low <identifiersep> level <identifiersep> put <identifiersep> exception . internal <identifiersep> error , <string_literal> , e ) ; } } failed . set <identifiersep> collided <identifiersep> block ( collided ) ; throw failed ; } else core . real <identifiersep> put ( b , req . can <identifiersep> write <identifiersep> client <identifiersep> cache , req . fork <identifiersep> on <identifiersep> cacheable , node . prefer <identifiersep> insert <identifiersep> default , node . ignore <identifiersep> low <identifiersep> backoff <identifiersep> default , req . real <identifiersep> time <identifiersep> flag ) ; <ect>
} else { if ( single <identifiersep> block <identifiersep> inserter . log <identifiersep> minor ) logger . minor ( this , <string_literal> + collided . is <identifiersep> metadata ( ) + <string_literal> + block . is <identifiersep> metadata + <string_literal> + collided . get <identifiersep> compression <identifiersep> codec ( ) + <string_literal> + block . compression <identifiersep> codec + <string_literal> + data . length + <string_literal> + inserting . length + <string_literal> + fields . hash <identifiersep> code ( data ) + <string_literal> + fields . hash <identifiersep> code ( inserting ) ) ; } } catch ( key <identifiersep> verify <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 + <string_literal> , e1 ) ; <LOG> } catch ( key <identifiersep> decode <identifiersep> exception e1 ) { } catch ( io <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 + <string_literal> , e1 ) ; } } req . on <identifiersep> failure ( e , context ) ; if ( single <identifiersep> block <identifiersep> inserter . log <identifiersep> minor ) logger . minor ( this , <string_literal> + e ) ; return true ; <ect>
if ( resulting <identifiersep> key != null ) return ; if ( finished ) return ; } try { encode ( context , false ) ; } catch ( insert <identifiersep> exception e ) { fail ( e , context ) ; <LOG> } catch ( throwable t ) { <comment> <ect>
public void add <identifiersep> block ( ) { boolean was <identifiersep> finalized ; synchronized ( this ) { total <identifiersep> blocks ++ ; was <identifiersep> finalized = block <identifiersep> set <identifiersep> finalized ; } if ( was <identifiersep> finalized ) { <LOG> if ( log <identifiersep> level . minor . matches <identifiersep> threshold ( logger . global <identifiersep> get <identifiersep> threshold <identifiersep> new ( ) ) ) else logger . error ( this , <string_literal> + this ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + total <identifiersep> blocks + <string_literal> + successful <identifiersep> blocks + <string_literal> + failed <identifiersep> blocks + <string_literal> + min <identifiersep> success <identifiersep> blocks ) ; } <comment> public void add <identifiersep> blocks ( int num ) { <ect>
public void add <identifiersep> blocks ( int num ) { boolean was <identifiersep> finalized ; synchronized ( this ) { total <identifiersep> blocks += num ; was <identifiersep> finalized = block <identifiersep> set <identifiersep> finalized ; } if ( was <identifiersep> finalized ) { <LOG> if ( log <identifiersep> level . minor . matches <identifiersep> threshold ( logger . global <identifiersep> get <identifiersep> threshold <identifiersep> new ( ) ) ) else logger . error ( this , <string_literal> + this ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + num + <string_literal> + total <identifiersep> blocks + <string_literal> + successful <identifiersep> blocks + <string_literal> + failed <identifiersep> blocks + <string_literal> + min <identifiersep> success <identifiersep> blocks ) ; } <comment> public void completed <identifiersep> block ( boolean dont <identifiersep> notify , client <identifiersep> context context ) { <ect>
current <identifiersep> state . schedule ( context ) ; synchronized ( this ) { cancel = cancelled ; } if ( cancel ) { on <identifiersep> failure ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . cancelled ) , null , context ) ; return false ; } <LOG> } catch ( insert <identifiersep> exception e ) { synchronized ( this ) { finished = true ; current <identifiersep> state = null ; } <comment> <ect>
synchronized ( this ) { finished = true ; current <identifiersep> state = null ; } <comment> <LOG> } catch ( binary <identifiersep> blob <identifiersep> format <identifiersep> exception e ) { synchronized ( this ) { finished = true ; current <identifiersep> state = null ; } <comment> <ect>
u = key . get <identifiersep> uri ( ) ; if ( got <identifiersep> final <identifiersep> metadata ) { logger . error ( this , <string_literal> + this + <string_literal> + state ) ; } if ( target <identifiersep> filename != null ) u = u . push <identifiersep> meta <identifiersep> string ( target <identifiersep> filename ) ; if ( this . uri != null ) { <LOG> if ( ! this . uri . equals ( u ) ) { } return ; } this . uri = u ; } client . on <identifiersep> generated <identifiersep> uri ( u , this ) ; } <comment> <ect>
<comment> public void on <identifiersep> metadata ( bucket final <identifiersep> metadata , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { boolean free <identifiersep> it = false ; synchronized ( this ) { if ( uri != null ) { logger . error ( this , <string_literal> + this + <string_literal> + state ) ; } <LOG> if ( got <identifiersep> final <identifiersep> metadata ) { free <identifiersep> it = true ; } else { got <identifiersep> final <identifiersep> metadata = true ; } } if ( free <identifiersep> it ) { final <identifiersep> metadata . free ( ) ; <ect>
@ override public void on <identifiersep> transition ( client <identifiersep> get <identifiersep> state old <identifiersep> state , client <identifiersep> get <identifiersep> state new <identifiersep> state , client <identifiersep> context context ) { <comment> <LOG> public void dump ( ) { system . out . println ( <string_literal> + client ) ; system . out . println ( <string_literal> + finished ) ; system . out . println ( <string_literal> + data ) ; } public byte [ ] get <identifiersep> client <identifiersep> detail ( checksum <identifiersep> checker checker ) throws io <identifiersep> exception { if ( client instanceof persistent <identifiersep> client <identifiersep> callback ) { <ect>
<comment> <LOG> system . out . println ( <string_literal> + client ) ; system . out . println ( <string_literal> + data ) ; } public byte [ ] get <identifiersep> client <identifiersep> detail ( checksum <identifiersep> checker checker ) throws io <identifiersep> exception { if ( client instanceof persistent <identifiersep> client <identifiersep> callback ) { return get <identifiersep> client <identifiersep> detail ( ( persistent <identifiersep> client <identifiersep> callback ) client , checker ) ; } else <ect>
case low <identifiersep> level <identifiersep> get <identifiersep> exception . route <identifiersep> not <identifiersep> found : case low <identifiersep> level <identifiersep> get <identifiersep> exception . transfer <identifiersep> failed : case low <identifiersep> level <identifiersep> get <identifiersep> exception . verify <identifiersep> failed : <comment> <LOG> default : can <identifiersep> retry = true ; } if ( can <identifiersep> retry && retry ( context ) ) return ; <comment> <ect>
if ( collision <identifiersep> is <identifiersep> ok && e . get <identifiersep> mode ( ) == insert <identifiersep> exception <identifiersep> mode . collision ) { on <identifiersep> success ( state , context ) ; return ; } boolean complete = true ; boolean do <identifiersep> cancel = false ; synchronized ( this ) { <LOG> if ( finished ) { return ; } list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( waiting <identifiersep> for , state ) ; list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( waiting <identifiersep> for <identifiersep> block <identifiersep> set , state ) ; list <identifiersep> utils . remove <identifiersep> by <identifiersep> swap <identifiersep> last ( waiting <identifiersep> for <identifiersep> fetchable , state ) ; if ( ! ( waiting <identifiersep> for . is <identifiersep> empty ( ) && started ) ) { <ect>
if ( waiting <identifiersep> for <identifiersep> fetchable . get ( i ) == old <identifiersep> state ) { waiting <identifiersep> for <identifiersep> fetchable . set ( i , new <identifiersep> state ) ; } } } @ override public synchronized void on <identifiersep> metadata ( metadata m , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { if ( generator == state ) { cb . on <identifiersep> metadata ( m , this , context ) ; <LOG> } else { } } @ override public synchronized void on <identifiersep> metadata ( bucket metadata , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { if ( generator == state ) { cb . on <identifiersep> metadata ( metadata , this , context ) ; } else { <ect>
this . metadata <identifiersep> threshold = metadata <identifiersep> threshold ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + persistent + <string_literal> + free <identifiersep> data ) ; } public void start ( client <identifiersep> context context ) throws insert <identifiersep> exception { try <identifiersep> compress ( context ) ; } void on <identifiersep> compressed ( compression <identifiersep> output output , client <identifiersep> context context ) { synchronized ( this ) { <LOG> if ( started ) { return ; } if ( cancelled ) { logger . error ( this , <string_literal> ) ; return ; } } try { <ect>
logger . error ( this , <string_literal> ) ; return ; } } try { on <identifiersep> compressed <identifiersep> inner ( output , context ) ; } catch ( insert <identifiersep> exception e ) { cb . on <identifiersep> failure ( e , single <identifiersep> file <identifiersep> inserter . this , context ) ; <LOG> } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + e + <string_literal> + state + <string_literal> + this + <string_literal> + sfi + <string_literal> + metadata <identifiersep> putter ) ; if ( state == sfi ) { sfi = null ; } else if ( state == metadata <identifiersep> putter ) { metadata <identifiersep> putter = null ; <LOG> } else { } if ( finished ) { to <identifiersep> fail = false ; <comment> <ect>
if ( finished ) return ; if ( report <identifiersep> metadata <identifiersep> only ) { if ( state != sfi ) { logger . error ( this , <string_literal> + state + <string_literal> ) ; return ; } meta <identifiersep> insert <identifiersep> success = true ; <LOG> } else if ( state == metadata <identifiersep> putter ) { e = new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , null ) ; } else if ( state != sfi ) { logger . error ( this , <string_literal> + state + <string_literal> + sfi + <string_literal> + metadata <identifiersep> putter + <string_literal> + this + <string_literal> + persistent , new exception ( <string_literal> ) ) ; e = new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , null ) ; } else { <ect>
if ( e != null ) { on <identifiersep> failure ( e , state , context ) ; return ; } byte [ ] meta <identifiersep> bytes ; try { meta <identifiersep> bytes = meta . write <identifiersep> to <identifiersep> byte <identifiersep> array ( ) ; <LOG> } catch ( metadata <identifiersep> unresolved <identifiersep> exception e1 ) { fail ( ( insert <identifiersep> exception ) new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e1 , null ) . init <identifiersep> cause ( e1 ) , context ) ; return ; } string meta <identifiersep> putter <identifiersep> target <identifiersep> filename = target <identifiersep> filename ; if ( target <identifiersep> filename != null ) { if ( meta <identifiersep> bytes . length < = short . max <identifiersep> value ) { <ect>
<comment> <LOG> if ( ! start <identifiersep> metadata ( context ) ) { fail ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , null ) , context ) ; return ; } synchronized ( this ) { if ( split <identifiersep> insert <identifiersep> success && sfi != null ) { sfi = null ; <ect>
if ( ! meta <identifiersep> insert <identifiersep> started ) { logger . error ( this , <string_literal> + state + <string_literal> + this ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( meta <identifiersep> fetchable ? <string_literal> : <string_literal> ) ) ; if ( meta <identifiersep> fetchable ) return ; meta <identifiersep> fetchable = true ; } else { <LOG> if ( state != sfi ) { return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; if ( meta <identifiersep> insert <identifiersep> started ) return ; } } if ( meta ) { cb . on <identifiersep> fetchable ( this ) ; <ect>
boolean free <identifiersep> it = false ; synchronized ( this ) { if ( finished ) return ; if ( state == metadata <identifiersep> putter ) { <comment> <LOG> if ( metadata <identifiersep> putter != null ) { free <identifiersep> it = true ; } else { <comment> <ect>
meta <identifiersep> insert <identifiersep> success = true ; <comment> <LOG> } else { free <identifiersep> it = true ; } } if ( free <identifiersep> it ) { meta . free ( ) ; return ; } cb . on <identifiersep> metadata ( meta , this , context ) ; <ect>
inner <identifiersep> store <identifiersep> status ( dos ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; return ; } try { dos . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } } private void inner <identifiersep> store <identifiersep> status ( data <identifiersep> output <identifiersep> stream dos ) throws io <identifiersep> exception { dos . write <identifiersep> int ( seg <identifiersep> no ) ; <comment> <ect>
start += per <identifiersep> segment <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes ; end += per <identifiersep> segment <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes ; } byte [ ] filter <identifiersep> buffer = new byte [ main <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes ] ; if ( ! new <identifiersep> salt ) { try { storage . pread <identifiersep> checksummed ( storage . offset <identifiersep> main <identifiersep> bloom <identifiersep> filter , filter <identifiersep> buffer , 0 , main <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes ) ; <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { must <identifiersep> regenerate <identifiersep> main <identifiersep> filter = true ; } } else { must <identifiersep> regenerate <identifiersep> main <identifiersep> filter = true ; } filter = new counting <identifiersep> bloom <identifiersep> filter ( main <identifiersep> bloom <identifiersep> filter <identifiersep> size <identifiersep> bytes * <number_literal> / <number_literal> , main <identifiersep> bloom <identifiersep> k , filter <identifiersep> buffer ) ; filter . set <identifiersep> warn <identifiersep> on <identifiersep> remove <identifiersep> from <identifiersep> empty ( ) ; <ect>
} finally { <comment> <LOG> } catch ( throwable t ) { <comment> <ect>
<comment> <LOG> if ( metadata != null ) { return ; } metadata = m ; if ( freeform <identifiersep> mode ) { boolean all <identifiersep> metadatas = false ; synchronized ( base <identifiersep> manifest <identifiersep> putter . this ) { <ect>
synchronized ( running <identifiersep> map ) { if ( running <identifiersep> map . contains ( this ) ) { logger . error ( this , <string_literal> + running <identifiersep> map , new error ( <string_literal> ) ) ; } else { running <identifiersep> map . add ( this ) ; } } } synchronized ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets ) { <LOG> if ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . contains ( this ) ) { } else { put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . add ( this ) ; } } synchronized ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable ) { if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable . contains ( this ) ) { logger . error ( this , <string_literal> , new error ( <string_literal> ) ) ; <ect>
private string target <identifiersep> in <identifiersep> archive ; protected final string item <identifiersep> name ; protected final boolean persistent ; protected final put <identifiersep> handler parent <identifiersep> put <identifiersep> handler ; public void start ( client <identifiersep> context context ) throws insert <identifiersep> exception { <comment> <LOG> if ( log <identifiersep> debug ) if ( orig <identifiersep> sfi == null ) { fail ( new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) , context ) ; } if ( ( ! ( this instanceof meta <identifiersep> put <identifiersep> handler ) ) && ( metadata != null ) ) { fail ( new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + metadata + <string_literal> ) , context ) ; } boolean ok ; <ect>
@ override public void on <identifiersep> success ( client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { if ( log <identifiersep> debug ) { <comment> <LOG> if ( ! ( <string_literal> . equals ( te . get <identifiersep> file <identifiersep> name ( ) ) && <string_literal> . equals ( te . get <identifiersep> method <identifiersep> name ( ) ) ) ) { } <comment> <ect>
old <identifiersep> state = current <identifiersep> state ; current <identifiersep> state = null ; } synchronized ( base <identifiersep> manifest <identifiersep> putter . this ) { running <identifiersep> put <identifiersep> handlers . remove ( this ) ; if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> metadata . remove ( this ) ) { logger . error ( this , <string_literal> + this . item <identifiersep> name + <string_literal> + this + <string_literal> + base <identifiersep> manifest <identifiersep> putter . this , new error ( <string_literal> ) ) ; } <LOG> if ( put <identifiersep> handler <identifiersep> waiting <identifiersep> for <identifiersep> block <identifiersep> sets . remove ( this ) ) { } if ( put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> fetchable . remove ( this ) ) { logger . error ( this , <string_literal> + this + <string_literal> + base <identifiersep> manifest <identifiersep> putter . this , new error ( <string_literal> ) ) ; } if ( ! running <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> minor ) { logger . minor ( this , <string_literal> + running <identifiersep> put <identifiersep> handlers . size ( ) ) ; <ect>
<comment> <LOG> return ; } } } @ override public void on <identifiersep> metadata ( metadata m , client <identifiersep> put <identifiersep> state state , client <identifiersep> context context ) { throw new unsupported <identifiersep> operation <identifiersep> exception ( ) ; } @ override public void on <identifiersep> metadata ( bucket meta , client <identifiersep> put <identifiersep> state state , <ect>
<comment> private void resolve ( metadata <identifiersep> unresolved <identifiersep> exception e , client <identifiersep> context context ) throws insert <identifiersep> exception , io <identifiersep> exception { new error ( <string_literal> ) . print <identifiersep> stack <identifiersep> trace ( ) ; metadata [ ] metas = e . must <identifiersep> resolve ; for ( metadata m : metas ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + m ) ; <LOG> if ( m . is <identifiersep> resolved ( ) ) { continue ; } try { meta <identifiersep> put <identifiersep> handler ph = new meta <identifiersep> put <identifiersep> handler ( this , null , m , context . get <identifiersep> bucket <identifiersep> factory ( persistent ( ) ) ) ; ph . start ( context ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e1 ) { <ect>
@ override public void queue ( persistent <identifiersep> job job , int thread <identifiersep> priority ) throws persistence <identifiersep> disabled <identifiersep> exception { synchronized ( sync ) { if ( ! loading ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; if ( killed ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; if ( context == null ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; <LOG> if ( must <identifiersep> checkpoint && enable <identifiersep> checkpointing ) { queued <identifiersep> jobs . add ( new queued <identifiersep> job ( job , thread <identifiersep> priority ) ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + job ) ; executor . execute ( new job <identifiersep> runnable ( job , thread <identifiersep> priority , context ) ) ; running <identifiersep> jobs ++ ; <ect>
@ override public void queue <identifiersep> internal ( persistent <identifiersep> job job , int thread <identifiersep> priority ) throws persistence <identifiersep> disabled <identifiersep> exception { synchronized ( sync ) { if ( ! loading ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; if ( killed ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; if ( context == null ) throw new illegal <identifiersep> state <identifiersep> exception ( ) ; <LOG> if ( writing ) { queued <identifiersep> jobs . add ( new queued <identifiersep> job ( job , thread <identifiersep> priority ) ) ; } else { if ( must <identifiersep> checkpoint ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } running <identifiersep> jobs ++ ; <ect>
executor . execute ( new job <identifiersep> runnable ( job , thread <identifiersep> priority , context ) ) ; } } } @ override public void queue <identifiersep> internal ( persistent <identifiersep> job job ) { try { queue <identifiersep> internal ( job , native <identifiersep> thread . norm <identifiersep> priority ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <LOG> <comment> <ect>
@ override public void run ( ) { boolean ret = false ; try { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + job ) ; ret = job . run ( context ) ; <LOG> } catch ( throwable t ) { } finally { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + job + <string_literal> + must <identifiersep> checkpoint + <string_literal> + enable <identifiersep> checkpointing + <string_literal> + running <identifiersep> jobs ) ; handle <identifiersep> completion ( ret , thread <identifiersep> priority ) ; } } } public void handle <identifiersep> completion ( boolean ret , int thread <identifiersep> priority ) { synchronized ( sync ) { <ect>
if ( system . current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> checkpointed > checkpoint <identifiersep> interval ) { must <identifiersep> checkpoint = true ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } } if ( ! must <identifiersep> checkpoint ) { delayed <identifiersep> checkpoint ( ) ; return ; } <LOG> if ( running <identifiersep> jobs != 0 ) { return ; } if ( ! killed ) { writing = true ; if ( thread <identifiersep> priority < write <identifiersep> at <identifiersep> priority ) { checkpoint <identifiersep> off <identifiersep> thread ( ) ; <ect>
inner <identifiersep> checkpoint ( shutdown ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; } } synchronized ( sync ) { must <identifiersep> checkpoint = false ; writing = false ; <LOG> queued <identifiersep> job [ ] jobs = queued <identifiersep> jobs . to <identifiersep> array ( new queued <identifiersep> job [ queued <identifiersep> jobs . size ( ) ] ) ; for ( queued <identifiersep> job job : jobs ) { running <identifiersep> jobs ++ ; executor . execute ( new job <identifiersep> runnable ( job . job , job . thread <identifiersep> priority , context ) ) ; } update <identifiersep> last <identifiersep> checkpointed ( ) ; queued <identifiersep> jobs . clear ( ) ; <ect>
synchronized ( sync ) { if ( ! enable <identifiersep> checkpointing ) return ; <comment> <LOG> if ( killed ) throw new persistence <identifiersep> disabled <identifiersep> exception ( ) ; try { sync . wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
wait ( ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> if ( succeeded ) return uri ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> , uri ) ; } @ override public void on <identifiersep> fetchable ( base <identifiersep> client <identifiersep> putter state ) { <comment> <ect>
<comment> private boolean verify <identifiersep> token ( string [ ] media , string [ ] elements , css <identifiersep> property <identifiersep> verifier obj , parsed <identifiersep> word [ ] words ) { <LOG> if ( words == null ) return false ; if ( obj == null ) { return false ; } int important = check <identifiersep> important ( words ) ; if ( important > 0 ) { <ect>
while ( element <identifiersep> string . index <identifiersep> of ( ' [ ' ) != - 1 && element <identifiersep> string . index <identifiersep> of ( ' ] ' ) != - 1 && ( element <identifiersep> string . index <identifiersep> of ( ' [ ' ) < element <identifiersep> string . index <identifiersep> of ( ' ] ' ) ) ) { if ( is <identifiersep> id <identifiersep> selector ) return null ; string att <identifiersep> selection = element <identifiersep> string . substring ( element <identifiersep> string . index <identifiersep> of ( ' [ ' ) + 1 , element <identifiersep> string . index <identifiersep> of ( ' ] ' ) ) . trim ( ) ; string <identifiersep> builder buf = new string <identifiersep> builder ( element <identifiersep> string ) ; buf . delete ( element <identifiersep> string . index <identifiersep> of ( ' [ ' ) , element <identifiersep> string . index <identifiersep> of ( ' ] ' ) + 1 ) ; <LOG> element <identifiersep> string = buf . to <identifiersep> string ( ) ; if ( att <identifiersep> selections == null ) att <identifiersep> selections = new array <identifiersep> list < string > ( ) ; att <identifiersep> selections . add ( att <identifiersep> selection ) ; } if ( element <identifiersep> string . index <identifiersep> of ( ' : ' ) != - 1 ) { if ( is <identifiersep> id <identifiersep> selector ) return null ; <ect>
{ if ( is <identifiersep> id <identifiersep> selector ) return null ; int index = htm <identifiersep> lelement . index <identifiersep> of ( ' . ' ) ; if ( index != htm <identifiersep> lelement . length ( ) - 1 ) { class <identifiersep> name = htm <identifiersep> lelement . substring ( index + 1 , htm <identifiersep> lelement . length ( ) ) . trim ( ) ; <LOG> htm <identifiersep> lelement = htm <identifiersep> lelement . substring ( 0 , index ) . trim ( ) ; } } else if ( htm <identifiersep> lelement . index <identifiersep> of ( ' # ' ) != - 1 ) { <comment> <ect>
} else if ( att <identifiersep> selection . index <identifiersep> of ( ' = ' ) != - 1 ) { att <identifiersep> selection <identifiersep> parts = new string [ <number_literal> ] ; att <identifiersep> selection <identifiersep> parts [ 0 ] = att <identifiersep> selection . substring ( 0 , att <identifiersep> selection . index <identifiersep> of ( ' = ' ) ) ; att <identifiersep> selection <identifiersep> parts [ 1 ] = att <identifiersep> selection . substring ( att <identifiersep> selection . index <identifiersep> of ( ' = ' ) + 1 , att <identifiersep> selection . length ( ) ) ; } else { att <identifiersep> selection <identifiersep> parts = new string [ ] { att <identifiersep> selection } ; } <LOG> <comment> <ect>
<comment> public string recursive <identifiersep> selector <identifiersep> verifier ( string selector <identifiersep> string ) <LOG> { selector <identifiersep> string = selector <identifiersep> string . trim ( ) ; <comment> <ect>
} else if ( c == ' \\ r' && escaping && escaped <identifiersep> digits == 0 ) { escaping = false ; eat <identifiersep> lf = true ; } else if ( ( c == ' \\ n' || c == ' \\ f' ) && escaping ) { if ( escaped <identifiersep> digits == 0 ) escaping = false ; <LOG> else { return null ; <comment> <ect>
return null ; <comment> <LOG> eat <identifiersep> lf = false ; } if ( quoting != 0 ) return null ; <comment> <ect>
<comment> <LOG> <comment> <ect>
if ( prevc == ' / ' && c == ' * ' && current <identifiersep> state != state1inquote && current <identifiersep> state != state2inquote && current <identifiersep> state != state3inquote && current <identifiersep> state != statecomment ) { state <identifiersep> before <identifiersep> comment = current <identifiersep> state ; current <identifiersep> state = statecomment ; if ( buffer . char <identifiersep> at ( buffer . length ( ) - 1 ) == ' / ' ) { <LOG> buffer . delete <identifiersep> char <identifiersep> at ( buffer . length ( ) - 1 ) ; } prevc = 0 ; } if ( c == 0 ) continue ; <comment> <ect>
buffer . set <identifiersep> length ( 0 ) ; break ; case ' ; ' : if ( prevc == ' \\ \\ ' ) { <comment> <LOG> break ; } <comment> <ect>
continue ; break ; } w . write ( buffer . substring ( 0 , i ) ) ; buffer . delete ( 0 , i ) ; } <comment> <LOG> { string strbuffer = buffer . to <identifiersep> string ( ) . trim ( ) ; int import <identifiersep> index = strbuffer . to <identifiersep> lower <identifiersep> case ( ) . index <identifiersep> of ( <string_literal> ) ; if ( <string_literal> . equals ( strbuffer . substring ( 0 , import <identifiersep> index ) . trim ( ) ) ) { string str1 = strbuffer . substring ( import <identifiersep> index + <number_literal> , strbuffer . length ( ) ) ; <ect>
default : buffer . append ( c ) ; if ( ! is <identifiersep> state1present ) { string s = buffer . to <identifiersep> string ( ) . trim ( ) ; if ( ! ( s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) || s . equals ( <string_literal> ) ) ) <LOG> current <identifiersep> state = state2 ; } break ; } break ; case state1inquote : if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; switch ( c ) <ect>
break ; } int i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <LOG> break ; } string ws = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { ws += buffer . substring ( 0 , <number_literal> ) ; if ( <string_literal> . index <identifiersep> of ( buffer . char <identifiersep> at ( <number_literal> ) ) == - 1 ) { <ect>
{ ignore <identifiersep> elements <identifiersep> s2 = true ; <comment> <LOG> filtered <identifiersep> tokens . set <identifiersep> length ( 0 ) ; } } else { <comment> <ect>
buffer . append ( c ) ; break ; } for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <LOG> break ; } ws = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; if ( ! s2comma ) { if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { filtered <identifiersep> tokens . append ( buffer . substring ( 0 , <number_literal> ) ) ; <ect>
char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; break ; } filtered <identifiersep> tokens . append ( buffer . substring ( 0 , i ) ) ; buffer . delete ( 0 , i ) ; } } <LOG> string filtered = recursive <identifiersep> selector <identifiersep> verifier ( buffer . to <identifiersep> string ( ) . trim ( ) ) ; if ( filtered != null && ! <string_literal> . equals ( filtered ) ) { if ( s2comma ) filtered <identifiersep> tokens . append ( <string_literal> ) ; else <ect>
ignore <identifiersep> elements <identifiersep> s1 = false ; } filtered <identifiersep> tokens . set <identifiersep> length ( 0 ) ; buffer . set <identifiersep> length ( 0 ) ; current <identifiersep> media = new string [ ] { default <identifiersep> media } ; is <identifiersep> state1present = false ; current <identifiersep> state = state1 ; <LOG> if ( is <identifiersep> inline ) return ; break ; case ' <string_literal> <ect>
break ; default : buffer . append ( c ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; break ; } break ; <LOG> case state2inquote : charset <identifiersep> possible = false ; switch ( c ) { case ' <string_literal> ' && prevc != ' \\ \\ ' ) <ect>
break ; } int i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <LOG> break ; } whitespace <identifiersep> before <identifiersep> property = buffer . substring ( 0 , i ) ; property <identifiersep> name = buffer . delete ( 0 , i ) . to <identifiersep> string ( ) . trim ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name ) ; buffer . set <identifiersep> length ( 0 ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; <ect>
continue ; break ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . substring ( 0 , i ) ) ; whitespace <identifiersep> before <identifiersep> property = buffer . substring ( 0 , i ) ; property <identifiersep> name = buffer . delete ( 0 , i ) . to <identifiersep> string ( ) . trim ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name ) ; <LOG> buffer . set <identifiersep> length ( 0 ) ; break ; case ' ; ' : if ( prevc == ' \\ \\ ' ) { <comment> <ect>
break ; } i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <LOG> break ; } whitespace <identifiersep> after <identifiersep> colon = buffer . substring ( 0 , i ) ; property <identifiersep> value = buffer . delete ( 0 , i ) . to <identifiersep> string ( ) . trim ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> value ) ; buffer . set <identifiersep> length ( 0 ) ; css <identifiersep> property <identifiersep> verifier obj = get <identifiersep> verifier ( property <identifiersep> name ) ; <ect>
whitespace <identifiersep> after <identifiersep> colon = buffer . substring ( 0 , i ) ; property <identifiersep> value = buffer . delete ( 0 , i ) . to <identifiersep> string ( ) . trim ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> value ) ; buffer . set <identifiersep> length ( 0 ) ; css <identifiersep> property <identifiersep> verifier obj = get <identifiersep> verifier ( property <identifiersep> name ) ; if ( obj != null ) { <LOG> parsed <identifiersep> word [ ] words = split ( property <identifiersep> value , obj . allow <identifiersep> comma <identifiersep> delimiters ) ; if ( words != null && ! ignore <identifiersep> elements <identifiersep> s2 && ! ignore <identifiersep> elements <identifiersep> s3 && verify <identifiersep> token ( current <identifiersep> media , elements , obj , words ) ) { if ( changed <identifiersep> anything ( words ) ) property <identifiersep> value = reconstruct ( words ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> before <identifiersep> property ) ; whitespace <identifiersep> before <identifiersep> property = <string_literal> ; <ect>
whitespace <identifiersep> before <identifiersep> property = <string_literal> ; filtered <identifiersep> tokens . append ( property <identifiersep> name ) ; filtered <identifiersep> tokens . append ( ' : ' ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> after <identifiersep> colon ) ; filtered <identifiersep> tokens . append ( property <identifiersep> value ) ; filtered <identifiersep> tokens . append ( ' ; ' ) ; <LOG> if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> + property <identifiersep> value ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens . to <identifiersep> string ( ) + <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( words ) + <string_literal> + ignore <identifiersep> elements <identifiersep> s1 + <string_literal> + ignore <identifiersep> elements <identifiersep> s2 + <string_literal> + ignore <identifiersep> elements <identifiersep> s3 ) ; } } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> ) ; } ignore <identifiersep> elements <identifiersep> s3 = false ; <ect>
filtered <identifiersep> tokens . append ( property <identifiersep> value ) ; filtered <identifiersep> tokens . append ( ' ; ' ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> + property <identifiersep> value ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens . to <identifiersep> string ( ) + <string_literal> ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens . to <identifiersep> string ( ) + <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( words ) + <string_literal> + ignore <identifiersep> elements <identifiersep> s1 + <string_literal> + ignore <identifiersep> elements <identifiersep> s2 + <string_literal> + ignore <identifiersep> elements <identifiersep> s3 ) ; } <LOG> } else { } ignore <identifiersep> elements <identifiersep> s3 = false ; property <identifiersep> name = <string_literal> ; property <identifiersep> value = <string_literal> ; break ; case ' } ' : <ect>
{ i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <LOG> break ; } whitespace <identifiersep> after <identifiersep> colon = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; property <identifiersep> value = buffer . to <identifiersep> string ( ) . trim ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> value ) ; buffer . set <identifiersep> length ( 0 ) ; <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . substring ( 0 , i ) ) ; whitespace <identifiersep> after <identifiersep> colon = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; property <identifiersep> value = buffer . to <identifiersep> string ( ) . trim ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> value ) ; buffer . set <identifiersep> length ( 0 ) ; <LOG> obj = get <identifiersep> verifier ( property <identifiersep> name ) ; if ( obj != null ) { parsed <identifiersep> word [ ] words = split ( property <identifiersep> value , obj . allow <identifiersep> comma <identifiersep> delimiters ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( words ) ) ; if ( ! ignore <identifiersep> elements <identifiersep> s2 && ! ignore <identifiersep> elements <identifiersep> s3 && verify <identifiersep> token ( current <identifiersep> media , elements , obj , words ) ) { <ect>
break ; } buffer . append ( c ) ; current <identifiersep> state = state3inquote ; current <identifiersep> quote = c ; break ; default : <LOG> buffer . append ( c ) ; break ; } break ; case state3inquote : charset <identifiersep> possible = false ; if ( stop <identifiersep> at <identifiersep> detected <identifiersep> charset ) <ect>
switch ( c ) { case ' / ' : if ( prevc == ' * ' ) { current <identifiersep> state = state <identifiersep> before <identifiersep> comment ; <LOG> c = 0 ; } break ; } break ; } } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens + <string_literal> ) ; w . write ( filtered <identifiersep> tokens . to <identifiersep> string ( ) ) ; for ( int i = 0 ; i < open <identifiersep> braces ; i ++ ) <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + current <identifiersep> state ) ; } break ; } break ; } } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + filtered <identifiersep> tokens + <string_literal> ) ; w . write ( filtered <identifiersep> tokens . to <identifiersep> string ( ) ) ; for ( int i = 0 ; i < open <identifiersep> braces ; i ++ ) <LOG> w . write ( ' } ' ) ; int i = 0 ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
last <identifiersep> word = word ; if ( ! first ) sb . append ( <string_literal> ) ; if ( ! word . changed ) { sb . append ( word . original ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + word . original + <string_literal> ) ; } else { <LOG> sb . append ( word . encode ( false ) ) ; <comment> <ect>
return false ; } } <comment> <LOG> private static parsed <identifiersep> word [ ] split ( string input , boolean allow <identifiersep> comma <identifiersep> delimiters ) { array <identifiersep> list < parsed <identifiersep> word > words = new array <identifiersep> list < parsed <identifiersep> word > ( ) ; parsed <identifiersep> word last <identifiersep> word = null ; char c = 0 ; <comment> <ect>
if ( ( <string_literal> . index <identifiersep> of ( c ) != - 1 || ( allow <identifiersep> comma <identifiersep> delimiters && c == ' , ' ) ) && bracket <identifiersep> count == 0 ) { if ( c == ' , ' ) { if ( decoded <identifiersep> token . length ( ) == 0 ) { if ( last <identifiersep> word == null ) { if ( log <identifiersep> debug ) logger . debug ( css <identifiersep> tokenizer <identifiersep> filter . class , <string_literal> + input + <string_literal> + i ) ; return null ; <LOG> } else if ( last <identifiersep> word . post <identifiersep> comma ) { <comment> <ect>
if ( add <identifiersep> comma ) { if ( log <identifiersep> debug ) logger . debug ( css <identifiersep> tokenizer <identifiersep> filter . class , <string_literal> + input + <string_literal> + i ) ; return null ; } add <identifiersep> comma = true ; } } <comment> <LOG> parsed <identifiersep> word word = parse <identifiersep> token ( orig <identifiersep> token , decoded <identifiersep> token , dont <identifiersep> like <identifiersep> orig <identifiersep> token , could <identifiersep> be <identifiersep> identifier ) ; if ( word == null ) return null ; if ( add <identifiersep> comma ) { word . post <identifiersep> comma = true ; add <identifiersep> comma = false ; } words . add ( word ) ; <ect>
if ( could <identifiersep> be <identifiersep> identifier ) return new parsed <identifiersep> identifier ( s , decoded <identifiersep> token . to <identifiersep> string ( ) , dont <identifiersep> like <identifiersep> orig <identifiersep> token ) ; string sl = s . to <identifiersep> lower <identifiersep> case ( ) ; if ( sl . starts <identifiersep> with ( <string_literal> ) ) { if ( s . ends <identifiersep> with ( <string_literal> ) ) { decoded <identifiersep> token . delete ( 0 , <number_literal> ) ; <LOG> decoded <identifiersep> token . set <identifiersep> length ( decoded <identifiersep> token . length ( ) - 1 ) ; <comment> <ect>
char c = stripped <identifiersep> orig . char <identifiersep> at ( 0 ) ; if ( c == \' \\ \'\' || c == \' \\ " \' ) { char d = stripped <identifiersep> orig . char <identifiersep> at ( stripped <identifiersep> orig . length ( ) - 1 ) ; if ( c == d ) { <comment> <LOG> decoded <identifiersep> token . delete <identifiersep> char <identifiersep> at ( 0 ) ; return new parsed <identifiersep> url ( orig <identifiersep> token . to <identifiersep> string ( ) , decoded <identifiersep> token . to <identifiersep> string ( ) , dont <identifiersep> like <identifiersep> orig <identifiersep> token , c ) ; } else return null ; } } return new parsed <identifiersep> url ( orig <identifiersep> token . to <identifiersep> string ( ) , decoded <identifiersep> token . to <identifiersep> string ( ) , dont <identifiersep> like <identifiersep> orig <identifiersep> token , ( char ) 0 ) ; } else return null ; <ect>
catch ( exception e ) { return false ; } } public static boolean is <identifiersep> valid <identifiersep> uri ( parsed <identifiersep> url word , filter <identifiersep> callback cb ) { string w = css <identifiersep> tokenizer <identifiersep> filter . remove <identifiersep> outer <identifiersep> quotes ( word . get <identifiersep> decoded ( ) ) ; <comment> <LOG> { string s = cb . process <identifiersep> uri ( w , null ) ; if ( s == null || s . equals ( <string_literal> ) ) return false ; if ( s . equals ( w ) ) return true ; if ( log <identifiersep> debug ) logger . debug ( css <identifiersep> tokenizer <identifiersep> filter . class , <string_literal> + s + <string_literal> + w + <string_literal> ) ; word . set <identifiersep> new <identifiersep> url ( s ) ; <ect>
if ( s == null || s . equals ( <string_literal> ) ) return false ; if ( s . equals ( w ) ) return true ; if ( log <identifiersep> debug ) logger . debug ( css <identifiersep> tokenizer <identifiersep> filter . class , <string_literal> + s + <string_literal> + w + <string_literal> ) ; word . set <identifiersep> new <identifiersep> url ( s ) ; return true ; } catch ( comment <identifiersep> exception e ) <LOG> { return false ; } } public boolean check <identifiersep> validity ( parsed <identifiersep> word [ ] words , filter <identifiersep> callback cb ) { return this . check <identifiersep> validity ( null , null , words , cb ) ; } public boolean check <identifiersep> validity ( parsed <identifiersep> word word , filter <identifiersep> callback cb ) <ect>
if ( allowed <identifiersep> media != null ) { boolean allowed = false ; for ( string m : media ) if ( allowed <identifiersep> media . contains ( m ) ) { allowed = true ; break ; } <LOG> if ( ! allowed ) { return false ; } } <comment> <ect>
if ( ( second <identifiersep> part . equals ( <string_literal> ) ) ) { <comment> <LOG> { parsed <identifiersep> word [ ] part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db = arrays . copy <identifiersep> of ( words , j ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + first <identifiersep> part + <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db ) ) ; if ( recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( first <identifiersep> part , part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db , cb ) ) <comment> <ect>
{ if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + j + <string_literal> ) ; parsed <identifiersep> word [ ] part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db = arrays . copy <identifiersep> of ( words , j ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + first <identifiersep> part + <string_literal> + css <identifiersep> property <identifiersep> verifier . to <identifiersep> string ( part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db ) ) ; if ( recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( first <identifiersep> part , part <identifiersep> to <identifiersep> pass <identifiersep> to <identifiersep> db , cb ) ) <comment> <LOG> parsed <identifiersep> word [ ] part <identifiersep> to <identifiersep> pass = arrays . copy <identifiersep> of <identifiersep> range ( words , j , words . length ) ; if ( recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( second <identifiersep> part , part <identifiersep> to <identifiersep> pass , cb ) ) return true ; } if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + j + <string_literal> + ( no <identifiersep> ofa + 1 ) + <string_literal> + words . length ) ; } return false ; } else if ( expression . char <identifiersep> at ( i ) == 'b' ) { <ect>
if ( words != null && words . length > 0 ) { int index = integer . parse <identifiersep> int ( first <identifiersep> part ) ; boolean result = css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ index ] . check <identifiersep> validity ( words [ 0 ] , cb ) ; if ( result ) { <LOG> parsed <identifiersep> word [ ] part <identifiersep> to <identifiersep> pass = arrays . copy <identifiersep> of <identifiersep> range ( words , 1 , words . length ) ; if ( recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( second <identifiersep> part , part <identifiersep> to <identifiersep> pass , cb ) ) return true ; } } return false ; } else if ( expression . char <identifiersep> at ( i ) == ' ? ' ) { <ect>
{ int lower <identifiersep> limit = integer . parse <identifiersep> int ( str <identifiersep> limits [ 0 ] ) ; int upper <identifiersep> limit = integer . parse <identifiersep> int ( str <identifiersep> limits [ 1 ] ) ; if ( recursive <identifiersep> variable <identifiersep> occurance <identifiersep> verifier ( index , words , lower <identifiersep> limit , upper <identifiersep> limit , tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> lower <identifiersep> limit , tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> upper <identifiersep> limit , second <identifiersep> part , cb ) ) return true ; } } return false ; } } <LOG> <comment> <ect>
{ if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + verifier <identifiersep> index + <string_literal> + to <identifiersep> string ( value <identifiersep> parts ) + <string_literal> + lower <identifiersep> limit + <string_literal> + upper <identifiersep> limit + <string_literal> + tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> lower <identifiersep> limit + <string_literal> + tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> upper <identifiersep> limit + <string_literal> + second <identifiersep> part + <string_literal> ) ; if ( ( value <identifiersep> parts == null || value <identifiersep> parts . length == 0 ) && lower <identifiersep> limit == 0 ) return true ; if ( lower <identifiersep> limit < = 0 ) { <comment> <LOG> if ( recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( second <identifiersep> part , value <identifiersep> parts , cb ) ) { return true ; } } <comment> <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + first <identifiersep> part + <string_literal> + second <identifiersep> part + <string_literal> + expression + <string_literal> + i ) ; boolean result = false ; int index = integer . parse <identifiersep> int ( first <identifiersep> part ) ; for ( int j = 0 ; j < words . length ; j ++ ) { <comment> <LOG> result = css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ index ] . check <identifiersep> validity ( get <identifiersep> sub <identifiersep> array ( words , 0 , j + 1 ) , cb ) ; if ( result ) { <comment> <ect>
if ( value <identifiersep> to <identifiersep> pass . length == 0 ) { <comment> <LOG> string pattern = ignored <identifiersep> parts + ( ( ( <string_literal> . equals ( ignored <identifiersep> parts ) ) || ( <string_literal> . equals ( second <identifiersep> part ) ) ) ? <string_literal> : <string_literal> ) + second <identifiersep> part ; if ( pattern . equals ( <string_literal> ) ) return false ; result = recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( pattern , value <identifiersep> to <identifiersep> pass , cb ) ; if ( result ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + words [ j ] ) ; <ect>
if ( result ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + words [ j ] ) ; return true ; } } } } } if ( last <identifiersep> a != - 1 ) return false ; <comment> <LOG> int index = integer . parse <identifiersep> int ( expression ) ; return css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ index ] . check <identifiersep> validity ( words , cb ) ; } } <comment> <ect>
static class font <identifiersep> part <identifiersep> property <identifiersep> verifier extends css <identifiersep> property <identifiersep> verifier { font <identifiersep> part <identifiersep> property <identifiersep> verifier ( ) { super ( false ) ; } @ override public boolean check <identifiersep> validity ( string [ ] media , string [ ] elements , parsed <identifiersep> word [ ] value , filter <identifiersep> callback cb ) <LOG> { css <identifiersep> property <identifiersep> verifier font <identifiersep> size = new css <identifiersep> property <identifiersep> verifier ( arrays . as <identifiersep> list ( <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> , <string_literal> ) , arrays . as <identifiersep> list ( <string_literal> , <string_literal> ) , null , null , true ) ; if ( font <identifiersep> size . check <identifiersep> validity ( value , cb ) ) return true ; for ( parsed <identifiersep> word word : value ) { <comment> <ect>
<comment> <LOG> { if ( value . length == 1 ) { if ( value [ 0 ] instanceof parsed <identifiersep> identifier && <string_literal> . equals <identifiersep> ignore <identifiersep> case ( ( ( parsed <identifiersep> identifier ) value [ 0 ] ) . original ) ) { <comment> <ect>
if ( allowed <identifiersep> media != null && ! only <identifiersep> value <identifiersep> verifier ) { boolean allowed = false ; for ( string m : media ) if ( allowed <identifiersep> media . contains ( m ) ) { allowed = true ; break ; } <LOG> if ( ! allowed ) { return false ; } } array <identifiersep> list < string > font <identifiersep> words = new array <identifiersep> list < string > ( ) ; <comment> <ect>
} else if ( word instanceof parsed <identifiersep> identifier ) { s = ( ( ( parsed <identifiersep> identifier ) word ) . get <identifiersep> decoded ( ) ) ; if ( is <identifiersep> generic <identifiersep> family ( s ) ) { continue ; } if ( is <identifiersep> specific <identifiersep> family ( s ) ) { continue ; } <LOG> if ( word . post <identifiersep> comma ) { return false ; } } else return false ; <comment> <ect>
<comment> <LOG> if ( i == value . length - 1 ) { return valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ; } if ( ! possibly <identifiersep> valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ) return false ; boolean last = false ; for ( int j = i + 1 ; j < value . length ; j ++ ) { <ect>
string s1 ; if ( new <identifiersep> word instanceof parsed <identifiersep> identifier ) { s1 = ( ( parsed <identifiersep> identifier ) new <identifiersep> word ) . original ; font <identifiersep> words . add ( s1 ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + s1 + <string_literal> ) ; if ( last ) { <LOG> if ( new <identifiersep> word . post <identifiersep> comma ) { } if ( valid <identifiersep> font <identifiersep> words ( font <identifiersep> words ) ) { <comment> <ect>
if ( new <identifiersep> word . post <identifiersep> comma ) { <comment> <LOG> } else { return false ; } } } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + new <identifiersep> word ) ; return false ; } } <comment> <ect>
} else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + new <identifiersep> word ) ; return false ; } } <comment> <LOG> return false ; } return true ; } private boolean possibly <identifiersep> valid <identifiersep> font <identifiersep> words ( array <identifiersep> list < string > font <identifiersep> words ) { if ( element <identifiersep> info . disallow <identifiersep> unknown <identifiersep> specific <identifiersep> fonts ) { string <identifiersep> builder sb = new string <identifiersep> builder ( ) ; boolean first = true ; <ect>
if ( c == ' < ' && ! ( pc . in <identifiersep> style || pc . in <identifiersep> script ) ) { <comment> <LOG> <comment> <ect>
if ( pc . only <identifiersep> detecting <identifiersep> charset ) return ; if ( ( s . length ( ) > <number_literal> ) && ( s . char <identifiersep> at ( 0 ) == ' ! ' ) && ( s . char <identifiersep> at ( 1 ) == ' - ' ) && ( s . char <identifiersep> at ( <number_literal> ) == ' - ' ) ) { s . delete ( 0 , <number_literal> ) ; if ( s . char <identifiersep> at ( s . length ( ) - 1 ) == ' - ' ) s . set <identifiersep> length ( s . length ( ) - 1 ) ; if ( s . char <identifiersep> at ( s . length ( ) - 1 ) == ' - ' ) <LOG> s . set <identifiersep> length ( s . length ( ) - 1 ) ; } if ( pc . expecting <identifiersep> bad <identifiersep> comment ) return ; <comment> <ect>
unparsed <identifiersep> attrs [ x - 1 ] = v . get ( x ) ; } else unparsed <identifiersep> attrs = new string [ 0 ] ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + element ) ; } public parsed <identifiersep> tag sanitize ( html <identifiersep> parse <identifiersep> context pc ) throws data <identifiersep> filter <identifiersep> exception { tag <identifiersep> verifier tv = <LOG> allowed <identifiersep> tags <identifiersep> verifiers . get ( element . to <identifiersep> lower <identifiersep> case ( ) ) ; if ( tv == null ) { if ( delete <identifiersep> wierd <identifiersep> stuff ) { return null ; } else { string err = <string_literal> + html <identifiersep> encoder . encode ( l10n ( <string_literal> , <string_literal> , element ) ) + <string_literal> ; <ect>
uri = html <identifiersep> decoder . decode ( uri ) ; uri = html <identifiersep> sanitize <identifiersep> uri ( uri , null , null , null , pc . cb , pc , inline ) ; if ( uri == null ) { continue ; } uri = html <identifiersep> encoder . encode ( uri ) ; o = uri ; } <LOG> <comment> <ect>
map < string , object > hn = super . sanitize <identifiersep> hash ( h , p , pc ) ; if ( p . start <identifiersep> slash ) { return finish ( h , hn , pc ) ; } else { return start ( h , hn , pc ) ; } } map < string , object > finish ( map < string , object > h , map < string , object > hn , <LOG> html <identifiersep> parse <identifiersep> context pc ) throws data <identifiersep> filter <identifiersep> exception { <comment> <ect>
return pc . in <identifiersep> style ; } @ override void process <identifiersep> style ( html <identifiersep> parse <identifiersep> context pc ) { try { pc . current <identifiersep> style <identifiersep> script <identifiersep> chunk = sanitize <identifiersep> style ( pc . current <identifiersep> style <identifiersep> script <identifiersep> chunk , pc . cb , pc , false ) ; <LOG> } catch ( data <identifiersep> filter <identifiersep> exception e ) { pc . current <identifiersep> style <identifiersep> script <identifiersep> chunk = <string_literal> ; } } } static class script <identifiersep> tag <identifiersep> verifier extends script <identifiersep> style <identifiersep> tag <identifiersep> verifier { script <identifiersep> tag <identifiersep> verifier ( ) { super ( <string_literal> , <ect>
return finish <identifiersep> process ( req , override <identifiersep> type , ' / ' + furi . to <identifiersep> string ( false , false ) , uri , no <identifiersep> relative ) ; } @ override public string on <identifiersep> base <identifiersep> href ( string base <identifiersep> href ) { string ret ; try { ret = process <identifiersep> uri ( base <identifiersep> href , null , true , false ) ; <LOG> } catch ( comment <identifiersep> exception e1 ) { ret = null ; } if ( ret == null ) { logger . error ( this , <string_literal> + base <identifiersep> href ) ; return null ; } else { <ect>
if ( color <identifiersep> parts . length != <number_literal> ) { return false ; } if ( is <identifiersep> number ( color <identifiersep> parts [ 0 ] ) && is <identifiersep> percentage ( color <identifiersep> parts [ 1 ] ) && is <identifiersep> percentage ( color <identifiersep> parts [ <number_literal> ] ) && is <identifiersep> number ( color <identifiersep> parts [ <number_literal> ] ) ) return true ; } return false ; } public static boolean is <identifiersep> css <identifiersep> transform ( string value ) { <LOG> value = value . trim ( ) ; if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length != <number_literal> ) { return false ; <ect>
if ( is <identifiersep> valid ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; <LOG> if ( is <identifiersep> percentage ( part . trim ( ) ) || is <identifiersep> length ( part . trim ( ) , false ) ) { return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> percentage ( part . trim ( ) ) || is <identifiersep> length ( part . trim ( ) , false ) ) { <ect>
if ( is <identifiersep> percentage ( part . trim ( ) ) || is <identifiersep> length ( part . trim ( ) , false ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; <LOG> if ( parts . length == 1 && ( is <identifiersep> percentage ( parts [ 0 ] . trim ( ) ) || is <identifiersep> length ( parts [ 0 ] . trim ( ) , false ) ) ) { return true ; } else if ( parts . length == <number_literal> && ( is <identifiersep> percentage ( parts [ 0 ] . trim ( ) ) || is <identifiersep> length ( parts [ 0 ] . trim ( ) , false ) ) && ( is <identifiersep> percentage ( parts [ 1 ] . trim ( ) ) || is <identifiersep> length ( parts [ 1 ] . trim ( ) , false ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) <ect>
} else if ( parts . length == <number_literal> && ( is <identifiersep> percentage ( parts [ 0 ] . trim ( ) ) || is <identifiersep> length ( parts [ 0 ] . trim ( ) , false ) ) && ( is <identifiersep> percentage ( parts [ 1 ] . trim ( ) ) || is <identifiersep> length ( parts [ 1 ] . trim ( ) , false ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; <LOG> if ( parts . length == 1 && is <identifiersep> number ( parts [ 0 ] . trim ( ) ) ) { return true ; } else if ( parts . length == <number_literal> && is <identifiersep> number ( parts [ 0 ] . trim ( ) ) && is <identifiersep> number ( parts [ 1 ] . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) <ect>
} else if ( parts . length == <number_literal> && is <identifiersep> number ( parts [ 0 ] . trim ( ) ) && is <identifiersep> number ( parts [ 1 ] . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; <LOG> if ( is <identifiersep> number ( part . trim ( ) ) ) { return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> number ( part . trim ( ) ) ) { <ect>
if ( is <identifiersep> number ( part . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; <LOG> if ( is <identifiersep> angle ( part . trim ( ) ) ) { return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; if ( is <identifiersep> number ( part . trim ( ) ) || is <identifiersep> angle ( part . trim ( ) ) ) { <ect>
if ( is <identifiersep> number ( part . trim ( ) ) || is <identifiersep> angle ( part . trim ( ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string part = value . substring ( <number_literal> , value . length ( ) - 1 ) ; <LOG> if ( is <identifiersep> number ( part . trim ( ) ) || is <identifiersep> angle ( part . trim ( ) ) ) { return true ; } } if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && ( is <identifiersep> number ( parts [ 0 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) ) { <ect>
if ( value . index <identifiersep> of ( <string_literal> ) == 0 && value . index <identifiersep> of ( ' ) ' ) == value . length ( ) - 1 ) { string [ ] parts = value . substring ( <number_literal> , value . length ( ) - 1 ) . split ( <string_literal> ) ; if ( parts . length == 1 && ( is <identifiersep> number ( parts [ 0 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) ) { if ( log <identifiersep> debug ) logger . debug ( filter <identifiersep> utils . class , <string_literal> ) ; return true ; <LOG> } else if ( parts . length == <number_literal> && ( is <identifiersep> number ( parts [ 0 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) && ( is <identifiersep> number ( parts [ 1 ] . trim ( ) ) || is <identifiersep> angle ( parts [ 0 ] . trim ( ) ) ) ) { return true ; } } return false ; } public static boolean is <identifiersep> frequency ( string value ) { string first <identifiersep> part ; <ect>
public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode m , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( get <identifiersep> message ( m ) ) ; extra = null ; mode = m ; error <identifiersep> codes = null ; this . uri = expected <identifiersep> uri ; <LOG> if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode mode , throwable e , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( get <identifiersep> message ( mode ) + <string_literal> + e . get <identifiersep> message ( ) ) ; extra = e . get <identifiersep> message ( ) ; <ect>
super ( get <identifiersep> message ( mode ) + <string_literal> + message + <string_literal> + e . get <identifiersep> message ( ) ) ; extra = e . get <identifiersep> message ( ) ; this . mode = mode ; error <identifiersep> codes = null ; init <identifiersep> cause ( e ) ; this . uri = expected <identifiersep> uri ; <LOG> if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + <string_literal> + e , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode mode , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( get <identifiersep> message ( mode ) ) ; extra = null ; <ect>
public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode mode , string message , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes , freenet <identifiersep> uri expected <identifiersep> uri ) { super ( message == null ? get <identifiersep> message ( mode ) : ( get <identifiersep> message ( mode ) + <string_literal> + message ) ) ; extra = message ; this . mode = mode ; this . error <identifiersep> codes = error <identifiersep> codes ; this . uri = expected <identifiersep> uri ; <LOG> if ( mode == insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) , this ) ; } public insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode mode ) { super ( get <identifiersep> message ( mode ) ) ; extra = null ; <ect>
case low <identifiersep> level <identifiersep> put <identifiersep> exception . rejected <identifiersep> overload : return new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . rejected <identifiersep> overload ) ; case low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> not <identifiersep> found : return new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . route <identifiersep> not <identifiersep> found ) ; case low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> really <identifiersep> not <identifiersep> found : return new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . route <identifiersep> really <identifiersep> not <identifiersep> found ) ; <LOG> default : return new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e . code , null ) ; } } private static final hash <identifiersep> map < integer , insert <identifiersep> exception <identifiersep> mode > modes = new hash <identifiersep> map < integer , insert <identifiersep> exception <identifiersep> mode > ( ) ; public static enum insert <identifiersep> exception <identifiersep> mode { <comment> <ect>
@ override void inner <identifiersep> close ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + bucket ) ; if ( bucket == null ) { <comment> <LOG> <comment> <ect>
list < method > methods = get <identifiersep> all <identifiersep> test <identifiersep> methods ( ) ; collections . shuffle ( methods ) ; try { run <identifiersep> tests ( methods ) ; } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } <LOG> } else { try { run <identifiersep> tests ( get <identifiersep> all <identifiersep> integration <identifiersep> tests ( ) ) ; } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; <ect>
@ seconds <identifiersep> long ( <number_literal> ) @ test <identifiersep> type ( type . integration ) public void test <identifiersep> cleaner <identifiersep> notification <identifiersep> removal ( ) throws exception { web <identifiersep> client c1 = new web <identifiersep> client ( ) ; web <identifiersep> client c2 = new web <identifiersep> client ( ) ; string request <identifiersep> id1 = ( ( html <identifiersep> page ) c1 . get <identifiersep> page ( test <identifiersep> url ) ) . get <identifiersep> element <identifiersep> by <identifiersep> id ( <string_literal> ) . get <identifiersep> attribute ( <string_literal> ) ; <LOG> string request <identifiersep> id2 = ( ( html <identifiersep> page ) c2 . get <identifiersep> page ( test <identifiersep> url ) ) . get <identifiersep> element <identifiersep> by <identifiersep> id ( <string_literal> ) . get <identifiersep> attribute ( <string_literal> ) ; c1 . close <identifiersep> all <identifiersep> windows ( ) ; c2 . close <identifiersep> all <identifiersep> windows ( ) ; system . out . println ( <string_literal> ) ; if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { throw new exception ( <string_literal> ) ; <ect>
string request <identifiersep> id2 = ( ( html <identifiersep> page ) c2 . get <identifiersep> page ( test <identifiersep> url ) ) . get <identifiersep> element <identifiersep> by <identifiersep> id ( <string_literal> ) . get <identifiersep> attribute ( <string_literal> ) ; system . out . println ( <string_literal> ) ; c1 . close <identifiersep> all <identifiersep> windows ( ) ; c2 . close <identifiersep> all <identifiersep> windows ( ) ; system . out . println ( <string_literal> ) ; if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { <LOG> throw new exception ( <string_literal> ) ; } for ( int i = 0 ; i < <number_literal> ; i ++ ) { thread . sleep ( <number_literal> ) ; system . out . println ( <string_literal> + i ) ; if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { throw new exception ( <string_literal> ) ; <ect>
final int k = filter . get <identifiersep> k ( ) ; final double q = 1 - math . pow ( 1 - 1 . 0 / filter <identifiersep> size , k * pass ) ; final double p = math . pow ( q , k ) ; final double actual = ( double ) f <identifiersep> pos / pass <identifiersep> false ; final double limit = p * 1 . <number_literal> + 1 . 0 / pass <identifiersep> false ; <comment> <LOG> system . out . println ( <string_literal> + k ) ; system . out . println ( <string_literal> + p ) ; system . out . println ( <string_literal> + limit ) ; system . out . println ( <string_literal> + actual ) ; system . out . println ( <string_literal> + actual / p ) ; <comment> <ect>
final double p = math . pow ( q , k ) ; final double actual = ( double ) f <identifiersep> pos / pass <identifiersep> false ; final double limit = p * 1 . <number_literal> + 1 . 0 / pass <identifiersep> false ; <comment> <LOG> system . out . println ( <string_literal> + p ) ; system . out . println ( <string_literal> + actual ) ; system . out . println ( <string_literal> + actual / p ) ; <comment> assert <identifiersep> false ( <string_literal> + p + <string_literal> + actual , actual > limit ) ; } public void test <identifiersep> counting <identifiersep> filter <identifiersep> false <identifiersep> positive ( ) { <ect>
final double limit = p * 1 . <number_literal> + 1 . 0 / pass <identifiersep> false ; <comment> <LOG> system . out . println ( <string_literal> + actual ) ; <comment> assert <identifiersep> false ( <string_literal> + p + <string_literal> + actual , actual > limit ) ; } public void test <identifiersep> counting <identifiersep> filter <identifiersep> false <identifiersep> positive ( ) { int k = bloom <identifiersep> filter . optimial <identifiersep> k ( filter <identifiersep> size , pass ) ; bloom <identifiersep> filter filter = bloom <identifiersep> filter . create <identifiersep> filter ( filter <identifiersep> size , k , true ) ; <ect>
{ secure <identifiersep> random r1 ; secure <identifiersep> random r2 ; try { r1 = secure <identifiersep> random . get <identifiersep> instance ( <string_literal> ) ; r2 = secure <identifiersep> random . get <identifiersep> instance ( <string_literal> ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; return ; } <comment> <ect>
assert <identifiersep> equals ( bob <identifiersep> p . get <identifiersep> encoded ( ) . length , curve <identifiersep> to <identifiersep> test . modulus <identifiersep> size ) ; } public static void main ( string [ ] args ) throws invalid <identifiersep> key <identifiersep> exception , illegal <identifiersep> state <identifiersep> exception , no <identifiersep> such <identifiersep> algorithm <identifiersep> exception { security . add <identifiersep> provider ( new bouncy <identifiersep> castle <identifiersep> provider ( ) ) ; ecdh alice = new ecdh ( curves . p256 ) ; ecdh bob = new ecdh ( curves . p256 ) ; public <identifiersep> key bob <identifiersep> p = bob . get <identifiersep> public <identifiersep> key ( ) ; <LOG> public <identifiersep> key alice <identifiersep> p = alice . get <identifiersep> public <identifiersep> key ( ) ; system . out . println ( <string_literal> + bob . curve ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice . get <identifiersep> agreed <identifiersep> secret ( bob . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob . get <identifiersep> agreed <identifiersep> secret ( alice . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; <ect>
security . add <identifiersep> provider ( new bouncy <identifiersep> castle <identifiersep> provider ( ) ) ; ecdh alice = new ecdh ( curves . p256 ) ; ecdh bob = new ecdh ( curves . p256 ) ; public <identifiersep> key bob <identifiersep> p = bob . get <identifiersep> public <identifiersep> key ( ) ; public <identifiersep> key alice <identifiersep> p = alice . get <identifiersep> public <identifiersep> key ( ) ; system . out . println ( <string_literal> + alice . curve ) ; <LOG> system . out . println ( <string_literal> + bob . curve ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice . get <identifiersep> agreed <identifiersep> secret ( bob . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob . get <identifiersep> agreed <identifiersep> secret ( alice . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; } public static string to <identifiersep> hex ( byte [ ] arg ) { return string . format ( <string_literal> , new big <identifiersep> integer ( 1 , arg ) ) ; <ect>
ecdh bob = new ecdh ( curves . p256 ) ; public <identifiersep> key bob <identifiersep> p = bob . get <identifiersep> public <identifiersep> key ( ) ; public <identifiersep> key alice <identifiersep> p = alice . get <identifiersep> public <identifiersep> key ( ) ; system . out . println ( <string_literal> + alice . curve ) ; system . out . println ( <string_literal> + bob . curve ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( alice <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; <LOG> system . out . println ( <string_literal> + to <identifiersep> hex ( bob <identifiersep> p . get <identifiersep> encoded ( ) ) ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( bob . get <identifiersep> agreed <identifiersep> secret ( alice . get <identifiersep> public <identifiersep> key ( ) ) ) ) ; } public static string to <identifiersep> hex ( byte [ ] arg ) { return string . format ( <string_literal> , new big <identifiersep> integer ( 1 , arg ) ) ; } public static string to <identifiersep> hex ( string arg ) throws unsupported <identifiersep> encoding <identifiersep> exception { return to <identifiersep> hex ( arg . get <identifiersep> bytes ( <string_literal> ) ) ; <ect>
byte [ ] hmac = hmac . mac <identifiersep> with <identifiersep> sha256 ( known <identifiersep> key , plaintext ) ; assert <identifiersep> equals ( hex . to <identifiersep> hex <identifiersep> string ( hmac ) , hex . to <identifiersep> hex <identifiersep> string ( known <identifiersep> sha256 ) ) ; } <comment> <LOG> int count = 0 ; random r = new random ( 0x <identifiersep> bbbbbbbb ) ; for ( int len = <number_literal> ; len < = <number_literal> ; len *= <number_literal> ) { byte [ ] plaintext = new byte [ len ] ; r . next <identifiersep> bytes ( plaintext ) ; system . out . println ( <string_literal> + len ) ; <ect>
key <identifiersep> parameter kp = new key <identifiersep> parameter ( known <identifiersep> key ) ; hmac . init ( kp ) ; hmac . update ( plaintext , 0 , plaintext . length ) ; hmac . do <identifiersep> final ( r1 , 0 ) ; for ( int j = 0 ; j < r1 . length ; j ++ ) { count += r1 [ j ] ; } } <LOG> long bc <identifiersep> length = system . current <identifiersep> time <identifiersep> millis ( ) - t1 ; system . out . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( current <identifiersep> length , <number_literal> , true ) ) ; system . out . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( bc <identifiersep> length , <number_literal> , true ) ) ; } } } <ect>
hmac . update ( plaintext , 0 , plaintext . length ) ; hmac . do <identifiersep> final ( r1 , 0 ) ; for ( int j = 0 ; j < r1 . length ; j ++ ) { count += r1 [ j ] ; } } long bc <identifiersep> length = system . current <identifiersep> time <identifiersep> millis ( ) - t1 ; system . out . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( legacy <identifiersep> length , <number_literal> , true ) ) ; <LOG> system . out . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( current <identifiersep> length , <number_literal> , true ) ) ; } } } <ect>
public void test <identifiersep> non <identifiersep> standard <identifiersep> test <identifiersep> vk ( ) throws unsupported <identifiersep> cipher <identifiersep> exception { rijndael aes128 = new rijndael ( <number_literal> , <number_literal> ) ; for ( int i = 0 ; i < test <identifiersep> vk256x256 . length ; i ++ ) { aes128 . initialize ( test <identifiersep> vk256x256 [ i ] [ 0 ] ) ; byte [ ] cipher = new byte [ <number_literal> / <number_literal> ] ; aes128 . encipher ( test <identifiersep> vk <identifiersep> p <identifiersep> tx256 , cipher ) ; <LOG> <comment> <ect>
public static void main ( string [ ] args ) throws exception { curves curve = ecdsa . curves . p256 ; ecdsa ecdsa = new ecdsa ( curve ) ; string to <identifiersep> sign = <string_literal> ; byte [ ] signed <identifiersep> bytes = to <identifiersep> sign . get <identifiersep> bytes ( <string_literal> ) ; <comment> <LOG> byte [ ] sig = ecdsa . sign <identifiersep> to <identifiersep> network <identifiersep> format ( signed <identifiersep> bytes ) ; system . out . println ( ecdsa . get <identifiersep> public <identifiersep> key ( ) . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> + to <identifiersep> sign + <string_literal> + to <identifiersep> hex ( signed <identifiersep> bytes ) + <string_literal> ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( sig ) ) ; system . out . println ( <string_literal> + ecdsa . verify ( sig , signed <identifiersep> bytes ) ) ; simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; <ect>
string to <identifiersep> sign = <string_literal> ; byte [ ] signed <identifiersep> bytes = to <identifiersep> sign . get <identifiersep> bytes ( <string_literal> ) ; <comment> <LOG> system . out . println ( <string_literal> + to <identifiersep> sign + <string_literal> + to <identifiersep> hex ( signed <identifiersep> bytes ) + <string_literal> ) ; system . out . println ( <string_literal> + ecdsa . verify ( sig , signed <identifiersep> bytes ) ) ; simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; system . out . println ( <string_literal> ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
byte [ ] sig = ecdsa . sign <identifiersep> to <identifiersep> network <identifiersep> format ( signed <identifiersep> bytes ) ; system . out . println ( <string_literal> + curve . to <identifiersep> string ( ) ) ; system . out . println ( ecdsa . get <identifiersep> public <identifiersep> key ( ) . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> + to <identifiersep> sign + <string_literal> + to <identifiersep> hex ( signed <identifiersep> bytes ) + <string_literal> ) ; system . out . println ( <string_literal> + to <identifiersep> hex ( sig ) ) ; system . out . println ( <string_literal> + ecdsa . verify ( sig , signed <identifiersep> bytes ) ) ; <LOG> simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> ) ; ecdsa ecdsa2 = new ecdsa ( sfs . get <identifiersep> subset ( curve . name ( ) ) , curve ) ; system . out . println ( ecdsa2 . get <identifiersep> public <identifiersep> key ( ) ) ; system . out . println ( <string_literal> + ecdsa2 . verify ( sig , signed <identifiersep> bytes ) ) ; <ect>
system . out . println ( <string_literal> + ecdsa . verify ( sig , signed <identifiersep> bytes ) ) ; simple <identifiersep> field <identifiersep> set sfs = ecdsa . as <identifiersep> field <identifiersep> set ( true ) ; system . out . println ( <string_literal> ) ; system . out . println ( sfs . to <identifiersep> string ( ) ) ; system . out . println ( <string_literal> ) ; ecdsa ecdsa2 = new ecdsa ( sfs . get <identifiersep> subset ( curve . name ( ) ) , curve ) ; <LOG> system . out . println ( ecdsa2 . get <identifiersep> public <identifiersep> key ( ) ) ; system . out . println ( <string_literal> + ecdsa . curve . max <identifiersep> sig <identifiersep> size + <string_literal> ) ; int max = 0 ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { max = math . max ( max , ecdsa . sign ( signed <identifiersep> bytes ) . length ) ; } system . out . println ( max ) ; <ect>
import freenet . support . hex <identifiersep> util ; import freenet . support . math . mersenne <identifiersep> twister ; public class ctr <identifiersep> block <identifiersep> cipher <identifiersep> test extends test <identifiersep> case { <comment> public static final boolean test <identifiersep> jca = rijndael . aes <identifiersep> ctr <identifiersep> provider != null ; static { <LOG> if ( ! test <identifiersep> jca ) } private mersenne <identifiersep> twister mt = new mersenne <identifiersep> twister ( <number_literal> ) ; <comment> <ect>
system . err . println ( <string_literal> ) ; byte [ ] text ; text = <string_literal> . get <identifiersep> bytes ( <string_literal> ) ; for ( int i = 0 ; i < key . length ; i ++ ) key [ i ] = ( byte ) 0x0b ; byte [ ] mv = s . mac ( key , text , <number_literal> ) ; <LOG> system . out . println ( hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( mv , 0 , mv . length ) ) ; for ( int i = 0 ; i < key . length ; i ++ ) key [ i ] = ( byte ) 0xaa ; text = new byte [ <number_literal> ] ; for ( int i = 0 ; i < text . length ; i ++ ) text [ i ] = ( byte ) 0xdd ; <ect>
t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; pure <identifiersep> code . decode ( repair <identifiersep> bufs2 , index <identifiersep> backup ) ; t3 = system . current <identifiersep> time <identifiersep> millis ( ) ; float d <identifiersep> native <identifiersep> decode = t2 - t1 ; float d <identifiersep> pure <identifiersep> decode = t3 - t2 ; system . out . println ( maybe <identifiersep> native ) ; <LOG> system . out . println ( pure <identifiersep> code ) ; system . out . println ( <string_literal> + d <identifiersep> native <identifiersep> decode + <string_literal> + d <identifiersep> pure <identifiersep> decode + <string_literal> ) ; } public void test <identifiersep> simple <identifiersep> rev ( ) { int lim = fec <identifiersep> math . gf <identifiersep> size + 1 ; fec <identifiersep> code code = fec <identifiersep> code <identifiersep> factory . get <identifiersep> default ( ) . create <identifiersep> fec <identifiersep> code ( kk , lim ) ; fec <identifiersep> code code2 = new pure <identifiersep> code ( kk , lim ) ; <ect>
filter . read <identifiersep> filter ( new array <identifiersep> bucket ( total ) . get <identifiersep> input <identifiersep> stream ( ) , out . get <identifiersep> output <identifiersep> stream ( ) , <string_literal> , null , null ) ; fos = new file <identifiersep> output <identifiersep> stream ( <string_literal> ) ; fos . write ( out . to <identifiersep> byte <identifiersep> array ( ) ) ; fos . close ( ) ; failed = true ; assert <identifiersep> false ( <string_literal> , true ) ; <LOG> } catch ( data <identifiersep> filter <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; if ( e . get <identifiersep> cause ( ) != null ) { e . get <identifiersep> cause ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; } <comment> <ect>
collection < string > c = css2 <identifiersep> selector . key <identifiersep> set ( ) ; iterator < string > itr = c . iterator ( ) ; int i = 0 ; while ( itr . has <identifiersep> next ( ) ) { string key = itr . next ( ) ; <LOG> string value = css2 <identifiersep> selector . get ( key ) ; assert <identifiersep> true ( <string_literal> + key + <string_literal> + filter ( key ) + <string_literal> + value + <string_literal> , filter ( key ) . contains ( value ) ) ; } i = 0 ; for ( string key : css2 <identifiersep> bad <identifiersep> selector ) { system . err . println ( <string_literal> + ( i ++ ) ) ; assert <identifiersep> true ( <string_literal> . equals ( filter ( key ) ) ) ; <ect>
collection < string > c = css3 <identifiersep> selector . key <identifiersep> set ( ) ; iterator < string > itr = c . iterator ( ) ; int i = 0 ; while ( itr . has <identifiersep> next ( ) ) { string key = itr . next ( ) ; <LOG> string value = css3 <identifiersep> selector . get ( key ) ; assert <identifiersep> true ( <string_literal> + key + <string_literal> + filter ( key ) + <string_literal> + value + <string_literal> , filter ( key ) . contains ( value ) ) ; } i = 0 ; for ( string key : css3 <identifiersep> bad <identifiersep> selector ) { system . err . println ( <string_literal> + ( i ++ ) ) ; assert <identifiersep> true ( <string_literal> . equals ( filter ( key ) ) ) ; <ect>
for ( object [ ] test : test <identifiersep> images ) { string filename = ( string ) test [ 0 ] ; boolean valid = ( boolean ) test [ 1 ] ; bucket ib ; try { ib = resource <identifiersep> to <identifiersep> bucket ( filename ) ; <LOG> } catch ( io <identifiersep> exception e ) { continue ; } try { filter . read <identifiersep> filter ( ib . get <identifiersep> input <identifiersep> stream ( ) , new null <identifiersep> bucket ( ) . get <identifiersep> output <identifiersep> stream ( ) , <string_literal> , null , null ) ; assert <identifiersep> true ( filename + <string_literal> + ( valid ? <string_literal> : <string_literal> ) + <string_literal> , valid ) ; } catch ( data <identifiersep> filter <identifiersep> exception dfe ) { <ect>
int n <identifiersep> probes = <number_literal> ; if ( args . length > 0 ) { <comment> <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { } } if ( args . length > 1 ) { <comment> <ect>
system . err . println ( <string_literal> ) ; } } if ( args . length > 1 ) { <comment> <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { } } random rand = new mersenne <identifiersep> twister ( seed ) ; int sleep <identifiersep> interval = <number_literal> ; <comment> <ect>
thread . sleep ( sleep <identifiersep> interval + rand . next <identifiersep> int ( sleep <identifiersep> interval / <number_literal> ) ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
string s = string . value <identifiersep> of ( l ) ; while ( s . length ( ) < <number_literal> ) s = <string_literal> + s ; <comment> <LOG> int xx ; long ms ; r = new mersenne <identifiersep> twister ( seed ) ; ms = system . current <identifiersep> time <identifiersep> millis ( ) ; xx = 0 ; for ( j = 0 ; j < <number_literal> ; j ++ ) xx += r . next <identifiersep> int ( ) ; <ect>
system . out . println ( <string_literal> ) ; r = new mersenne <identifiersep> twister ( seed ) ; ms = system . current <identifiersep> time <identifiersep> millis ( ) ; xx = 0 ; for ( j = 0 ; j < <number_literal> ; j ++ ) xx += r . next <identifiersep> int ( ) ; <LOG> system . out . println ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - ms ) + <string_literal> + xx ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <comment> <ect>
ms = system . current <identifiersep> time <identifiersep> millis ( ) ; xx = 0 ; for ( j = 0 ; j < <number_literal> ; j ++ ) xx += r . next <identifiersep> int ( ) ; system . out . println ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - ms ) + <string_literal> + xx ) ; system . out . println ( <string_literal> ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <comment> <ect>
system . out . println ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - ms ) + <string_literal> + xx ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <comment> <LOG> <comment> <ect>
system . out . println ( <string_literal> ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> boolean ( ( double ) ( j / <number_literal> . 0 ) ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; } <LOG> if ( ! ( j%8 == <number_literal> ) ) system . out . println ( ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> boolean ( ( float ) ( j / <number_literal> . 0f ) ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; <ect>
r . next <identifiersep> bytes ( bytes ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( bytes [ j ] + <string_literal> ) ; if ( j%16 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%16 == <number_literal> ) ) system . out . println ( ) ; <LOG> byte b ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( ( b = r . next <identifiersep> byte ( ) ) + <string_literal> ) ; if ( b != bytes [ j ] ) system . out . print ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> short ( ) + <string_literal> ) ; if ( j%8 == <number_literal> ) system . out . println ( ) ; } <LOG> if ( ! ( j%8 == <number_literal> ) ) system . out . println ( ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> int ( ) + <string_literal> ) ; if ( j%4 == <number_literal> ) system . out . println ( ) ; <ect>
for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> int ( max ) + <string_literal> ) ; max *= <number_literal> ; if ( max < = 0 ) max = 1 ; if ( j%4 == <number_literal> ) system . out . println ( ) ; } <LOG> if ( ! ( j%4 == <number_literal> ) ) system . out . println ( ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> long ( ) + <string_literal> ) ; if ( j%3 == <number_literal> ) system . out . println ( ) ; <ect>
for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> long ( max2 ) + <string_literal> ) ; max2 *= <number_literal> ; if ( max2 < = 0 ) max2 = 1 ; if ( j%4 == <number_literal> ) system . out . println ( ) ; } <LOG> if ( ! ( j%4 == <number_literal> ) ) system . out . println ( ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> float ( ) + <string_literal> ) ; if ( j%4 == <number_literal> ) system . out . println ( ) ; <ect>
try { this . properties = new configurations ( ) . properties ( url ) ; } catch ( configuration <identifiersep> exception e ) { logger . error ( <string_literal> , this . id , url , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; this . properties = new base <identifiersep> configuration ( ) ; } <LOG> } else { this . properties = new base <identifiersep> configuration ( ) ; } } return this . properties ; } public string get <identifiersep> skin <identifiersep> folder ( ) { return <string_literal> + this . id + ' / ' ; <ect>
<comment> protected abstract string get <identifiersep> output <identifiersep> syntax <identifiersep> string ( ) ; private syntax parse <identifiersep> syntax ( skin skin , string syntax ) { try { return syntax . value <identifiersep> of ( syntax ) ; <LOG> } catch ( parse <identifiersep> exception e ) { } <comment> <ect>
<comment> public void set <identifiersep> wiki ( session session , string wiki <identifiersep> id ) throws x <identifiersep> wiki <identifiersep> exception { <LOG> try { <comment> <ect>
<comment> <LOG> if ( session != null ) { this . logger . debug ( <string_literal> , transaction ) ; return false ; } <comment> <ect>
<comment> <LOG> <comment> <ect>
this . logger . debug ( <string_literal> ) ; if ( sfactory == null ) { session = get <identifiersep> session <identifiersep> factory ( ) . open <identifiersep> session ( ) ; } else { session = sfactory . open <identifiersep> session ( ) ; } this . logger . debug ( <string_literal> , session ) ; <LOG> set <identifiersep> current <identifiersep> session ( session ) ; transaction = session . begin <identifiersep> transaction ( ) ; this . logger . debug ( <string_literal> , transaction ) ; set <identifiersep> current <identifiersep> transaction ( transaction ) ; <comment> <ect>
session session = null ; try { session = get <identifiersep> current <identifiersep> session ( ) ; transaction transaction = get <identifiersep> current <identifiersep> transaction ( ) ; set <identifiersep> current <identifiersep> session ( null ) ; set <identifiersep> current <identifiersep> transaction ( null ) ; <LOG> if ( transaction != null ) { if ( commit ) { transaction . commit ( ) ; } else { transaction . rollback ( ) ; } } } catch ( hibernate <identifiersep> exception e ) { <ect>
this . thread = new thread ( this ) ; this . thread . set <identifiersep> daemon ( true ) ; this . thread . set <identifiersep> name ( <string_literal> ) ; this . thread . start ( ) ; } } @ override protected void run <identifiersep> internal ( ) throws exception <LOG> { this . progress <identifiersep> manager . push <identifiersep> level <identifiersep> progress ( <number_literal> , this ) ; try { this . progress <identifiersep> manager . start <identifiersep> step ( this ) ; x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; x <identifiersep> wiki xwiki = new x <identifiersep> wiki ( xcontext , xcontext . get <identifiersep> engine <identifiersep> context ( ) , true ) ; <ect>
x <identifiersep> wiki <identifiersep> context xcontext = unserialize <identifiersep> x <identifiersep> wiki <identifiersep> context ( remote <identifiersep> event . get <identifiersep> data ( ) ) ; try { if ( xcontext != null ) { local <identifiersep> event . set <identifiersep> source ( unserialize <identifiersep> document ( remote <identifiersep> event . get <identifiersep> source ( ) ) ) ; local <identifiersep> event . set <identifiersep> data ( xcontext ) ; local <identifiersep> event . set <identifiersep> event ( ( event ) remote <identifiersep> event . get <identifiersep> event ( ) ) ; } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } return true ; } return false ; } } <ect>
@ suppress <identifiersep> warnings ( <string_literal> ) map < string , file > file <identifiersep> mapping = ( map < string , file > ) context . get ( <string_literal> ) ; for ( file file : file <identifiersep> mapping . values ( ) ) { try { <comment> <LOG> } catch ( exception e ) { } } } <comment> <ect>
document <identifiersep> reference doc <identifiersep> ref = this . document <identifiersep> reference <identifiersep> resolver . resolve ( ( string ) sheet <identifiersep> binding [ 0 ] , expected <identifiersep> sheet <identifiersep> ref ) ; document <identifiersep> reference sheet <identifiersep> ref = this . document <identifiersep> reference <identifiersep> resolver . resolve ( ( string ) sheet <identifiersep> binding [ 1 ] , doc <identifiersep> ref ) ; if ( sheet <identifiersep> ref . equals ( expected <identifiersep> sheet <identifiersep> ref ) ) { document <identifiersep> references . add ( doc <identifiersep> ref ) ; } } return document <identifiersep> references ; <LOG> } catch ( query <identifiersep> exception e ) { return collections . empty <identifiersep> list ( ) ; } } @ override public boolean bind ( document <identifiersep> model <identifiersep> bridge document , document <identifiersep> reference sheet <identifiersep> reference ) { return bind ( document , <ect>
transformer . transform ( source , result ) ; <comment> <LOG> for ( page <identifiersep> sequence <identifiersep> results page <identifiersep> sequence <identifiersep> results : page <identifiersep> sequences ) { + <string_literal> + page <identifiersep> sequence <identifiersep> results . get <identifiersep> page <identifiersep> count ( ) + <string_literal> ) ; } this . logger . debug ( <string_literal> + fo <identifiersep> results . get <identifiersep> page <identifiersep> count ( ) + <string_literal> ) ; } } private configuration load <identifiersep> configuration ( ) { configuration configuration = null ; <ect>
private configuration load <identifiersep> configuration ( ) { configuration configuration = null ; try ( input <identifiersep> stream fop <identifiersep> configuration <identifiersep> file = fopxslfo <identifiersep> renderer . class . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ) { if ( fop <identifiersep> configuration <identifiersep> file != null ) { configuration = new default <identifiersep> configuration <identifiersep> builder ( ) . build ( fop <identifiersep> configuration <identifiersep> file ) ; } <LOG> } catch ( exception e ) { } configuration = maybe <identifiersep> extend <identifiersep> configuration ( configuration ) ; return configuration ; } private configuration maybe <identifiersep> extend <identifiersep> configuration ( configuration configuration ) { configuration writable <identifiersep> configuration = configuration ; <ect>
return listener <identifiersep> events ; } } ) ; } void on <identifiersep> new <identifiersep> old <identifiersep> rendering ( component <identifiersep> descriptor < old <identifiersep> rendering > descriptor , component <identifiersep> manager component <identifiersep> manager ) { try { this . old <identifiersep> rendering = component <identifiersep> manager . get <identifiersep> instance ( old <identifiersep> rendering . class ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } @ override public old <identifiersep> rendering get ( ) { if ( this . old <identifiersep> rendering == null ) { try { <ect>
{ this . configuration <identifiersep> location = get <identifiersep> config <identifiersep> path ( ) ; input <identifiersep> stream xwikicfgis = load <identifiersep> configuration ( ) ; if ( xwikicfgis != null ) { try { this . properties . load ( xwikicfgis ) ; <LOG> } catch ( exception e ) { } } } private input <identifiersep> stream load <identifiersep> configuration ( ) { this . configuration <identifiersep> location = get <identifiersep> config <identifiersep> path ( ) ; <comment> <ect>
x <identifiersep> wiki <identifiersep> user xwiki <identifiersep> user = xcontext . get <identifiersep> wiki ( ) . check <identifiersep> auth ( xcontext ) ; if ( xwiki <identifiersep> user != null ) { space <identifiersep> reference default <identifiersep> user <identifiersep> space = new space <identifiersep> reference ( x <identifiersep> wiki . system <identifiersep> space , new wiki <identifiersep> reference ( xcontext . get <identifiersep> wiki <identifiersep> id ( ) ) ) ; document <identifiersep> reference user <identifiersep> reference = this . explicit <identifiersep> resolver . resolve ( xwiki <identifiersep> user . get <identifiersep> user ( ) , default <identifiersep> user <identifiersep> space ) ; xcontext <LOG> . set <identifiersep> user <identifiersep> reference ( x <identifiersep> wiki <identifiersep> right <identifiersep> service . guest <identifiersep> user . equals ( user <identifiersep> reference . get <identifiersep> name ( ) ) ? null : user <identifiersep> reference ) ; } } } <ect>
<comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } input <identifiersep> stream content ; long size ; if ( properties . is <identifiersep> with <identifiersep> wiki <identifiersep> attachments <identifiersep> content ( ) ) { try { content = attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( xcontext ) ; <ect>
<comment> public xdom get <identifiersep> xdom <identifiersep> no <identifiersep> exception ( string template <identifiersep> name ) { xdom xdom ; try { xdom = get <identifiersep> xdom ( template <identifiersep> name ) ; <LOG> } catch ( throwable e ) { xdom = generate <identifiersep> error ( e ) ; } return xdom ; } <comment> <ect>
render <identifiersep> no <identifiersep> exception ( template , writer ) ; return writer . to <identifiersep> string ( ) ; } public void render <identifiersep> no <identifiersep> exception ( string template <identifiersep> name , writer writer ) { try { render ( template <identifiersep> name , writer ) ; <LOG> } catch ( exception e ) { render <identifiersep> error ( e , writer ) ; } } <comment> public void render <identifiersep> no <identifiersep> exception ( template template , writer writer ) <ect>
block <identifiersep> renderer . render ( xdom , printer ) ; } public xdom execute <identifiersep> no <identifiersep> exception ( string template <identifiersep> name ) { xdom xdom ; try { xdom = execute ( template <identifiersep> name ) ; <LOG> } catch ( throwable e ) { xdom = generate <identifiersep> error ( e ) ; } return xdom ; } <comment> <ect>
if ( principal == null || context . get <identifiersep> wiki ( ) . param <identifiersep> as <identifiersep> long ( <string_literal> , 0 ) == 1 ) { string username = convert <identifiersep> username ( this . persistent <identifiersep> login <identifiersep> manager . get <identifiersep> remembered <identifiersep> username ( request , response ) , context ) ; string password = this . persistent <identifiersep> login <identifiersep> manager . get <identifiersep> remembered <identifiersep> password ( request , response ) ; principal = authenticate ( username , password , context ) ; <LOG> if ( principal != null ) { } <comment> <ect>
string continue <identifiersep> to <identifiersep> url = get <identifiersep> continue <identifiersep> to <identifiersep> url ( request ) ; <comment> <LOG> <comment> <ect>
param = <string_literal> ; } return param ; } public x <identifiersep> wiki <identifiersep> auth <identifiersep> service get <identifiersep> auth <identifiersep> service ( x <identifiersep> wiki <identifiersep> context context ) { string authservicepage = get <identifiersep> param ( <string_literal> , context ) ; if ( ( authservicepage == null ) || authservicepage . trim ( ) . equals ( <string_literal> ) ) { <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { } return null ; } try { x <identifiersep> wiki <identifiersep> document doc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( authservicepage , context ) ; if ( context . get <identifiersep> wiki ( ) . get <identifiersep> right <identifiersep> service ( ) . has <identifiersep> programming <identifiersep> rights ( doc , context ) ) { return ( x <identifiersep> wiki <identifiersep> auth <identifiersep> service ) context . get <identifiersep> wiki ( ) . parse <identifiersep> groovy <identifiersep> from <identifiersep> string ( doc . get <identifiersep> content ( ) , context ) ; <ect>
for ( base <identifiersep> object bobj : groups ) { if ( bobj != null ) { string member = bobj . get <identifiersep> string <identifiersep> value ( field <identifiersep> xwikigroups <identifiersep> member ) ; if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( member ) ) { list . add ( member ) ; } } } } return list ; } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } return null ; } @ override @ deprecated public list < string > list <identifiersep> all <identifiersep> groups ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <ect>
@ override public x <identifiersep> wiki <identifiersep> user check <identifiersep> auth ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { string user = context . get <identifiersep> request ( ) . get <identifiersep> remote <identifiersep> user ( ) ; if ( ( user == null ) || user . equals ( <string_literal> ) ) { return super . check <identifiersep> auth ( context ) ; <LOG> } else { create <identifiersep> user ( user , context ) ; logger . debug ( <string_literal> , user ) ; user = <string_literal> + user ; } context . set <identifiersep> user ( user ) ; return new x <identifiersep> wiki <identifiersep> user ( user ) ; <ect>
security <identifiersep> request <identifiersep> wrapper wrapped <identifiersep> request = new security <identifiersep> request <identifiersep> wrapper ( request , null , null , auth . get <identifiersep> auth <identifiersep> method ( ) ) ; try { if ( auth . process <identifiersep> login ( wrapped <identifiersep> request , response , context ) ) { return null ; } <comment> <LOG> if ( auth . process <identifiersep> logout ( wrapped <identifiersep> request , response , new url <identifiersep> pattern <identifiersep> matcher ( ) ) ) { } wrapped <identifiersep> request . set <identifiersep> user <identifiersep> principal ( null ) ; return null ; } final string user <identifiersep> name = get <identifiersep> context <identifiersep> user <identifiersep> name ( wrapped <identifiersep> request . get <identifiersep> user <identifiersep> principal ( ) , context ) ; if ( user <identifiersep> name != null ) { <ect>
if ( user <identifiersep> name != null ) { logger . info ( <string_literal> + user <identifiersep> name + <string_literal> ) ; } } if ( user <identifiersep> name == null ) { return null ; } return new x <identifiersep> wiki <identifiersep> user ( user <identifiersep> name ) ; <LOG> } catch ( exception e ) { return null ; } finally { logger . debug ( <string_literal> + ( system . current <identifiersep> time <identifiersep> millis ( ) - time ) + <string_literal> ) ; } } <comment> <ect>
security <identifiersep> request <identifiersep> wrapper wrapped <identifiersep> request = new security <identifiersep> request <identifiersep> wrapper ( request , null , null , auth . get <identifiersep> auth <identifiersep> method ( ) ) ; try { if ( ! auth . process <identifiersep> login ( username , password , rememberme , wrapped <identifiersep> request , response , context ) ) { return null ; } principal principal = wrapped <identifiersep> request . get <identifiersep> user <identifiersep> principal ( ) ; <LOG> if ( principal != null ) { } } if ( principal == null ) { return null ; } return new x <identifiersep> wiki <identifiersep> user ( get <identifiersep> context <identifiersep> user <identifiersep> name ( principal , context ) ) ; } catch ( exception e ) { logger . error ( <string_literal> , e ) ; <ect>
public void show <identifiersep> login ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { try { if ( context . get <identifiersep> mode ( ) == x <identifiersep> wiki <identifiersep> context . mode <identifiersep> servlet ) { get <identifiersep> authenticator ( context ) . show <identifiersep> login ( context . get <identifiersep> request ( ) . get <identifiersep> http <identifiersep> servlet <identifiersep> request ( ) , context . get <identifiersep> response ( ) , context ) ; } <LOG> } catch ( io <identifiersep> exception e ) { } } @ override public principal authenticate ( string username , string password , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <comment> <ect>
final base <identifiersep> object user <identifiersep> object = doc . get <identifiersep> x <identifiersep> object ( userclass <identifiersep> reference ) ; <comment> <LOG> if ( result ) { } else { logger . debug ( <string_literal> + username + <string_literal> ) ; } logger . debug ( ( system . current <identifiersep> time <identifiersep> millis ( ) - time ) + <string_literal> ) ; } return result ; } catch ( throwable e ) { <ect>
final string stored = user <identifiersep> object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; result = new password <identifiersep> class ( ) . get <identifiersep> equivalent <identifiersep> password ( stored , password ) . equals ( stored ) ; } if ( result ) { logger . debug ( <string_literal> + username + <string_literal> ) ; } else { <LOG> logger . debug ( <string_literal> + username + <string_literal> ) ; } } return result ; } catch ( throwable e ) { logger . error ( <string_literal> , e ) ; return false ; } } protected string get <identifiersep> param ( string name , x <identifiersep> wiki <identifiersep> context context ) <ect>
if ( param == null ) { param = <string_literal> ; } return param ; } protected string create <identifiersep> user ( string user , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <LOG> string createuser = get <identifiersep> param ( <string_literal> , context ) ; } if ( createuser != null ) { string wikiname = context . get <identifiersep> wiki ( ) . clear <identifiersep> name ( user , true , true , context ) ; x <identifiersep> wiki <identifiersep> document userdoc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( new document <identifiersep> reference ( context . get <identifiersep> wiki <identifiersep> id ( ) , <string_literal> , wikiname ) , context ) ; <ect>
x <identifiersep> wiki <identifiersep> document userdoc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( new document <identifiersep> reference ( context . get <identifiersep> wiki <identifiersep> id ( ) , <string_literal> , wikiname ) , context ) ; if ( userdoc . is <identifiersep> new ( ) ) { logger . debug ( <string_literal> + user ) ; } <LOG> if ( <string_literal> . equals ( createuser ) ) { } context . get <identifiersep> wiki ( ) . create <identifiersep> empty <identifiersep> user ( wikiname , <string_literal> , context ) ; } } else { logger . debug ( <string_literal> + user ) ; } } return wikiname ; <ect>
<comment> private entity <identifiersep> reference <identifiersep> serializer < string > entity <identifiersep> reference <identifiersep> serializer = utils . get <identifiersep> component ( entity <identifiersep> reference <identifiersep> serializer . type <identifiersep> string ) ; protected void log <identifiersep> allow ( string username , string page , string action , string info ) <LOG> { } protected void log <identifiersep> deny ( string username , string page , string action , string info ) { logger . info ( <string_literal> , username , page , action , info ) ; } protected void log <identifiersep> deny ( string name , string resource <identifiersep> key , string access <identifiersep> level , string info , exception e ) { <ect>
if ( bobj == null ) { logger . debug ( <string_literal> , i ) ; continue ; } string users = bobj . get <identifiersep> string <identifiersep> value ( field <identifiersep> name ) ; string levels = bobj . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; boolean allowdeny = ( bobj . get <identifiersep> int <identifiersep> value ( <string_literal> ) == 1 ) ; <LOG> if ( allowdeny == allow ) { string [ ] levelsarray = string <identifiersep> utils . split ( levels , <string_literal> ) ; if ( array <identifiersep> utils . contains ( levelsarray , access <identifiersep> level ) ) { logger . debug ( <string_literal> , allow ) ; found = true ; logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , users ) ; <ect>
boolean allowdeny = ( bobj . get <identifiersep> int <identifiersep> value ( <string_literal> ) == 1 ) ; if ( allowdeny == allow ) { logger . debug ( <string_literal> , access <identifiersep> level , levels ) ; string [ ] levelsarray = string <identifiersep> utils . split ( levels , <string_literal> ) ; if ( array <identifiersep> utils . contains ( levelsarray , access <identifiersep> level ) ) { logger . debug ( <string_literal> , allow ) ; <LOG> found = true ; string [ ] userarray = groups <identifiersep> class . get <identifiersep> list <identifiersep> from <identifiersep> string ( users ) . to <identifiersep> array ( new string [ 0 ] ) ; for ( int ii = 0 ; ii < userarray . length ; ii ++ ) { string value = userarray [ ii ] ; if ( value . index <identifiersep> of ( <string_literal> ) == - 1 ) { <ect>
if ( array <identifiersep> utils . contains ( userarray , shortname ) ) { logger . debug ( <string_literal> , users , shortname ) ; return true ; } <comment> <LOG> if ( array <identifiersep> utils . contains ( userarray , veryshortname ) ) { return true ; } } if ( ( context . get <identifiersep> wiki <identifiersep> id ( ) != null ) && ( array <identifiersep> utils . contains ( userarray , user <identifiersep> or <identifiersep> group <identifiersep> name ) ) ) { logger . debug ( <string_literal> , users , user <identifiersep> or <identifiersep> group <identifiersep> name ) ; return true ; } logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , users ) ; <ect>
string veryshortname = shortname . substring ( shortname . index <identifiersep> of ( <string_literal> ) + 1 ) ; if ( array <identifiersep> utils . contains ( userarray , veryshortname ) ) { logger . debug ( <string_literal> , users , shortname ) ; return true ; } } if ( ( context . get <identifiersep> wiki <identifiersep> id ( ) != null ) && ( array <identifiersep> utils . contains ( userarray , user <identifiersep> or <identifiersep> group <identifiersep> name ) ) ) { logger . debug ( <string_literal> , users , user <identifiersep> or <identifiersep> group <identifiersep> name ) ; <LOG> return true ; } } } else { logger . debug ( <string_literal> , i ) ; } } } logger . debug ( <string_literal> ) ; <comment> <ect>
return true ; } } if ( ( context . get <identifiersep> wiki <identifiersep> id ( ) != null ) && ( array <identifiersep> utils . contains ( userarray , user <identifiersep> or <identifiersep> group <identifiersep> name ) ) ) { logger . debug ( <string_literal> , users , user <identifiersep> or <identifiersep> group <identifiersep> name ) ; return true ; } logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , users ) ; } } else { <LOG> logger . debug ( <string_literal> , i ) ; } } } <comment> <ect>
boolean result = check <identifiersep> right ( group , doc , access <identifiersep> level , false , allow , global , context ) ; if ( result ) { return true ; } } catch ( x <identifiersep> wiki <identifiersep> right <identifiersep> not <identifiersep> found <identifiersep> exception e ) { } catch ( exception e ) { logger . error ( <string_literal> , access <identifiersep> level , group , <LOG> doc . get <identifiersep> prefixed <identifiersep> full <identifiersep> name ( ) , e ) ; } } if ( found ) { return false ; } else { throw new x <identifiersep> wiki <identifiersep> right <identifiersep> not <identifiersep> found <identifiersep> exception ( ) ; } } private void add <identifiersep> member <identifiersep> groups ( string wiki , string prefixed <identifiersep> full <identifiersep> name , document <identifiersep> reference user <identifiersep> or <identifiersep> group <identifiersep> document <identifiersep> reference , <ect>
} finally { context . set <identifiersep> wiki <identifiersep> id ( current <identifiersep> wiki ) ; } grouplistcache . put ( key , tmp <identifiersep> group <identifiersep> list ) ; } grouplist . add <identifiersep> all ( tmp <identifiersep> group <identifiersep> list ) ; } public boolean has <identifiersep> access <identifiersep> level ( string access <identifiersep> level , string user <identifiersep> or <identifiersep> group <identifiersep> name , string entity <identifiersep> reference , boolean user , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception <LOG> { document <identifiersep> reference user <identifiersep> or <identifiersep> group <identifiersep> name <identifiersep> reference = this . current <identifiersep> mixed <identifiersep> document <identifiersep> reference <identifiersep> resolver . resolve ( user <identifiersep> or <identifiersep> group <identifiersep> name ) ; if ( ! user <identifiersep> or <identifiersep> group <identifiersep> name <identifiersep> reference . get <identifiersep> name ( ) . equals ( x <identifiersep> wiki <identifiersep> right <identifiersep> service . guest <identifiersep> user ) && context . get <identifiersep> wiki <identifiersep> id ( ) != null ) { <comment> <ect>
{ boolean has <identifiersep> admin = has <identifiersep> wiki <identifiersep> admin <identifiersep> rights ( context ) ; if ( ! has <identifiersep> admin ) { try { has <identifiersep> admin = has <identifiersep> access <identifiersep> level ( <string_literal> , context . get <identifiersep> user ( ) , context . get <identifiersep> doc ( ) . get <identifiersep> space ( ) + <string_literal> , context ) ; <LOG> } catch ( exception e ) { } } return has <identifiersep> admin ; } @ override public boolean has <identifiersep> wiki <identifiersep> admin <identifiersep> rights ( x <identifiersep> wiki <identifiersep> context context ) { try { <ect>
{ string protected <identifiersep> username = username ; string protected <identifiersep> password = password ; if ( this . protection . equals ( protection <identifiersep> all ) || this . protection . equals ( protection <identifiersep> encryption ) ) { protected <identifiersep> username = encrypt <identifiersep> text ( protected <identifiersep> username ) ; protected <identifiersep> password = encrypt <identifiersep> text ( protected <identifiersep> password ) ; <LOG> if ( protected <identifiersep> username == null || protected <identifiersep> password == null ) { logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; return ; } } <comment> <ect>
string protected <identifiersep> password = password ; if ( this . protection . equals ( protection <identifiersep> all ) || this . protection . equals ( protection <identifiersep> encryption ) ) { protected <identifiersep> username = encrypt <identifiersep> text ( protected <identifiersep> username ) ; protected <identifiersep> password = encrypt <identifiersep> text ( protected <identifiersep> password ) ; if ( protected <identifiersep> username == null || protected <identifiersep> password == null ) { logger . error ( <string_literal> ) ; <LOG> logger . error ( <string_literal> ) ; return ; } } <comment> <ect>
if ( validation <identifiersep> hash != null ) { <comment> <LOG> logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; } } } return ; } <comment> <ect>
cookie validation <identifiersep> cookie = new cookie ( get <identifiersep> cookie <identifiersep> prefix ( ) + cookie <identifiersep> validation , validation <identifiersep> hash ) ; setup <identifiersep> cookie ( validation <identifiersep> cookie , session <identifiersep> cookie , secure <identifiersep> cookie , cookie <identifiersep> domain , response ) ; } else { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> ) ; logger . error ( <string_literal> ) ; <LOG> logger . error ( <string_literal> ) ; } } } return ; } <comment> <ect>
<comment> private void add <identifiersep> cookie ( http <identifiersep> servlet <identifiersep> response response , cookie cookie ) <LOG> { + cookie . get <identifiersep> value ( ) ) ; } <comment> <ect>
<comment> private string get <identifiersep> validation <identifiersep> hash ( string username , string password , string client <identifiersep> ip ) { if ( this . validation <identifiersep> key == null ) { <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> ) ; } return null ; } message <identifiersep> digest md5 = null ; string <identifiersep> buffer sb <identifiersep> value <identifiersep> before <identifiersep> md5 = new string <identifiersep> buffer ( ) ; try { <ect>
for ( byte element : array ) { int b = element & 0x <identifiersep> ff ; if ( b < 0x10 ) { sb . append ( '0' ) ; } sb . append ( integer . to <identifiersep> hex <identifiersep> string ( b ) ) ; } this . value <identifiersep> after <identifiersep> md5 = sb . to <identifiersep> string ( ) ; <LOG> } catch ( exception e ) { } return this . value <identifiersep> after <identifiersep> md5 ; } <comment> <ect>
<comment> <LOG> logger . error ( <string_literal> ) ; } } catch ( exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + clear <identifiersep> text , e ) ; } } return null ; } <comment> <ect>
string password = get <identifiersep> cookie <identifiersep> value ( request . get <identifiersep> cookies ( ) , get <identifiersep> cookie <identifiersep> prefix ( ) + cookie <identifiersep> password , default <identifiersep> value ) ; string cookie <identifiersep> hash = get <identifiersep> cookie <identifiersep> value ( request . get <identifiersep> cookies ( ) , get <identifiersep> cookie <identifiersep> prefix ( ) + cookie <identifiersep> validation , default <identifiersep> value ) ; string calculated <identifiersep> hash = get <identifiersep> validation <identifiersep> hash ( username , password , get <identifiersep> client <identifiersep> ip ( request ) ) ; if ( cookie <identifiersep> hash . equals ( calculated <identifiersep> hash ) ) { return true ; <LOG> } else { logger . info ( <string_literal> ) ; forget <identifiersep> login ( request , response ) ; } } return false ; } <comment> <ect>
<comment> public document get <identifiersep> document <identifiersep> revision ( string revision ) { try { x <identifiersep> wiki <identifiersep> document document <identifiersep> revision = get <identifiersep> document <identifiersep> revision <identifiersep> provider ( ) . get <identifiersep> revision ( this . doc , revision ) ; return document <identifiersep> revision != null ? new document ( document <identifiersep> revision , this . context ) : null ; <LOG> } catch ( exception e ) { e ) ; return null ; } } <comment> <ect>
if ( attachments == null || attachments . is <identifiersep> empty ( ) ) { attachments = collections . empty <identifiersep> list ( ) ; } list < deleted <identifiersep> attachment > result = new array <identifiersep> list < deleted <identifiersep> attachment > ( attachments . size ( ) ) ; for ( com . xpn . xwiki . doc . deleted <identifiersep> attachment attachment : attachments ) { result . add ( new deleted <identifiersep> attachment ( attachment , this . context ) ) ; } return result ; <LOG> } catch ( exception ex ) { } return collections . empty <identifiersep> list ( ) ; } <comment> <ect>
public deleted <identifiersep> attachment get <identifiersep> deleted <identifiersep> attachment ( string id ) { try { com . xpn . xwiki . doc . deleted <identifiersep> attachment attachment = this . xwiki . get <identifiersep> deleted <identifiersep> attachment ( id , this . context ) ; if ( attachment != null ) { return new deleted <identifiersep> attachment ( attachment , this . context ) ; } <LOG> } catch ( exception ex ) { } return null ; } <comment> <ect>
<comment> public list < string > get <identifiersep> wiki <identifiersep> names ( ) { list < string > result = new array <identifiersep> list < string > ( ) ; try { result = this . xwiki . get <identifiersep> virtual <identifiersep> wikis <identifiersep> database <identifiersep> names ( get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; <LOG> } catch ( exception e ) { } return result ; } <comment> <ect>
public string get <identifiersep> url <identifiersep> content ( string surl , string username , string password ) throws io <identifiersep> exception { if ( ! has <identifiersep> programming <identifiersep> rights ( ) ) { return <string_literal> ; } try { return this . xwiki . get <identifiersep> url <identifiersep> content ( surl , username , password , this . context ) ; <LOG> } catch ( exception e ) { return <string_literal> ; } } <comment> <ect>
<comment> <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } return syntax ; } <comment> <ect>
int seconds = ( int ) ( double . parse <identifiersep> double ( waitdays ) * <number_literal> * <number_literal> * <number_literal> + 0 . <number_literal> ) ; calendar cal = calendar . get <identifiersep> instance ( ) ; cal . set <identifiersep> time ( get <identifiersep> date ( ) ) ; cal . add ( calendar . second , seconds ) ; return cal . before ( calendar . get <identifiersep> instance ( ) ) ; } catch ( exception ex ) { <LOG> <comment> <ect>
<comment> public boolean is <identifiersep> user <identifiersep> in <identifiersep> group ( string group <identifiersep> name ) { boolean result = false ; try { <LOG> if ( this . user == null ) { } else { result = this . user . is <identifiersep> user <identifiersep> in <identifiersep> group ( group <identifiersep> name , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; } } catch ( exception ex ) { logger . warn ( new message <identifiersep> format ( <string_literal> + <string_literal> ) . format ( new java . lang . object [ ] { this . user , group <identifiersep> name } ) , ex ) ; <ect>
statement . execute ( <string_literal> + escaped <identifiersep> schema <identifiersep> name + <string_literal> ) ; } else if ( database <identifiersep> product . db2 == database <identifiersep> product ) { statement . execute ( <string_literal> + escaped <identifiersep> schema <identifiersep> name + <string_literal> ) ; } else if ( database <identifiersep> product . postgresql == database <identifiersep> product ) { if ( is <identifiersep> in <identifiersep> schema <identifiersep> mode ( ) ) { statement . execute ( <string_literal> + escaped <identifiersep> schema <identifiersep> name + <string_literal> ) ; <LOG> } else { } } } <comment> @ override public boolean exists ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context inputxcontext ) throws x <identifiersep> wiki <identifiersep> exception <ect>
try { if ( b <identifiersep> transaction ) { end <identifiersep> transaction ( context , false ) ; } } catch ( exception e ) { } <comment> <LOG> monitor . end <identifiersep> timer ( hint ) ; } } return doc ; } @ override public void delete <identifiersep> x <identifiersep> wiki <identifiersep> doc ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context inputxcontext ) throws x <identifiersep> wiki <identifiersep> exception { x <identifiersep> wiki <identifiersep> context context = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( inputxcontext ) ; <ect>
query query = session . create <identifiersep> query ( <string_literal> ) ; query . set <identifiersep> long ( <string_literal> , doc . get <identifiersep> id ( ) ) ; @ suppress <identifiersep> warnings ( <string_literal> ) list < x <identifiersep> wiki <identifiersep> attachment > list = query . list ( ) ; for ( x <identifiersep> wiki <identifiersep> attachment attachment : list ) { doc . set <identifiersep> attachment ( attachment ) ; } <LOG> } catch ( exception e ) { object [ ] args = { doc . get <identifiersep> document <identifiersep> reference ( ) } ; throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> store , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> store <identifiersep> hibernate <identifiersep> searching <identifiersep> attachment , <string_literal> , e , args ) ; } finally { <ect>
string propname = hibprop . get <identifiersep> name ( ) ; property <identifiersep> class propclass = ( property <identifiersep> class ) bclass . get <identifiersep> field ( propname ) ; if ( propclass == null ) { this . logger . warn ( <string_literal> , propname ) ; return false ; } boolean result = is <identifiersep> valid <identifiersep> column <identifiersep> type ( hibprop . get <identifiersep> value ( ) . get <identifiersep> type ( ) . get <identifiersep> name ( ) , propclass . get <identifiersep> class <identifiersep> name ( ) ) ; <LOG> if ( result == false ) { return false ; } } return true ; } @ override public list < string > get <identifiersep> custom <identifiersep> mapping <identifiersep> property <identifiersep> list ( base <identifiersep> class bclass ) { <ect>
this . logger . warn ( <string_literal> , attachment . get <identifiersep> filename ( ) , attachment . get <identifiersep> doc ( ) . get <identifiersep> document <identifiersep> reference ( ) ) ; } attachment <identifiersep> versioning <identifiersep> store store = resolve <identifiersep> attachment <identifiersep> versioning <identifiersep> store ( attachment , context ) ; store . delete <identifiersep> archive ( attachment , context , false ) ; try { session . delete ( attachment ) ; <LOG> } catch ( exception e ) { attachment . get <identifiersep> doc ( ) . get <identifiersep> document <identifiersep> reference ( ) ) ; } try { if ( parent <identifiersep> update ) { list < x <identifiersep> wiki <identifiersep> attachment > list = attachment . get <identifiersep> doc ( ) . get <identifiersep> attachment <identifiersep> list ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { <ect>
return get <identifiersep> x <identifiersep> wiki <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store ( store <identifiersep> type ) ; } private x <identifiersep> wiki <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store <identifiersep> interface get <identifiersep> x <identifiersep> wiki <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store ( string store <identifiersep> type ) { if ( store <identifiersep> type != null && ! store <identifiersep> type . equals ( hint ) ) { try { return this . component <identifiersep> manager . get <identifiersep> instance ( x <identifiersep> wiki <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store <identifiersep> interface . class , store <identifiersep> type ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } return null ; } private x <identifiersep> wiki <identifiersep> deleted <identifiersep> document resolve <identifiersep> deleted <identifiersep> document <identifiersep> content ( x <identifiersep> wiki <identifiersep> deleted <identifiersep> document deleted <identifiersep> document , boolean b <identifiersep> transaction ) throws x <identifiersep> wiki <identifiersep> exception { x <identifiersep> wiki <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store <identifiersep> interface content <identifiersep> store = <ect>
private static final string compatibility <identifiersep> maxwait = <string_literal> ; <comment> <LOG> try { <comment> <ect>
if ( this . ds != null ) { try { this . ds . close ( ) ; } catch ( exception e2 ) { <comment> <LOG> throw new hibernate <identifiersep> exception ( message , e ) ; } } @ override public connection get <identifiersep> connection ( ) throws sql <identifiersep> exception { <comment> <ect>
shutdown <identifiersep> logger . debug ( <string_literal> ) ; log <identifiersep> statistics ( ) ; try { if ( this . ds != null ) { this . ds . close ( ) ; this . ds = null ; <LOG> } else { } } catch ( exception e ) { throw new hibernate <identifiersep> exception ( <string_literal> , e ) ; } shutdown <identifiersep> logger . debug ( <string_literal> ) ; } <comment> <ect>
<comment> private void log <identifiersep> progress ( string message , object . . . params ) { <LOG> if ( params . length > 0 ) { } else { this . logger . info ( <string_literal> , get <identifiersep> name ( ) , message ) ; } } <comment> <ect>
} ) ; } catch ( exception e ) { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> store , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> store <identifiersep> migration , get <identifiersep> name ( ) + <string_literal> , e ) ; } <LOG> int timer = 0 ; for ( string [ ] table : table <identifiersep> to <identifiersep> process ) { this . logger . debug ( <string_literal> , table [ 0 ] , times [ timer ++ ] / <number_literal> ) ; } } } else { final list < string [ ] > docs <identifiersep> coll = new array <identifiersep> list < string [ ] > ( ) ; for ( class < ? > doc <identifiersep> class : doc <identifiersep> classes ) { <ect>
times [ this . timer ++ ] += execute <identifiersep> id <identifiersep> update ( x <identifiersep> wiki <identifiersep> link . class , docid ) ; times [ this . timer ++ ] += execute <identifiersep> id <identifiersep> update ( x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> info . class , id + ' . ' + docid ) ; times [ this . timer ++ ] += execute <identifiersep> id <identifiersep> update ( x <identifiersep> wiki <identifiersep> document . class , id ) ; } } ) ; int timer = 0 ; <LOG> for ( string [ ] coll : docs <identifiersep> coll ) { } for ( class < ? > doclink <identifiersep> class : doclink <identifiersep> classes ) { this . logger . debug ( <string_literal> , doclink <identifiersep> class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; } this . logger . debug ( <string_literal> , x <identifiersep> wiki <identifiersep> rcs <identifiersep> node <identifiersep> info . class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; <ect>
int timer = 0 ; for ( string [ ] coll : docs <identifiersep> coll ) { this . logger . debug ( <string_literal> , coll [ 0 ] , times [ timer ++ ] / <number_literal> ) ; } for ( class < ? > doclink <identifiersep> class : doclink <identifiersep> classes ) { this . logger . debug ( <string_literal> , doclink <identifiersep> class . get <identifiersep> name ( ) , <LOG> times [ timer ++ ] / <number_literal> ) ; } times [ timer ++ ] / <number_literal> ) ; this . logger . debug ( <string_literal> , x <identifiersep> wiki <identifiersep> document . class . get <identifiersep> name ( ) , times [ timer ++ ] / <number_literal> ) ; } } log <identifiersep> progress ( <string_literal> ) ; } else { <ect>
} ) ; } catch ( exception e ) { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> store , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> store <identifiersep> migration , get <identifiersep> name ( ) + <string_literal> , e ) ; } <LOG> int timer = 0 ; for ( string [ ] table : table <identifiersep> to <identifiersep> process ) { this . logger . debug ( <string_literal> , table [ 0 ] , times [ timer ++ ] / <number_literal> ) ; } } } else { <comment> <ect>
for ( string property <identifiersep> class : class <identifiersep> to <identifiersep> process ) { times [ this . timer ++ ] += execute <identifiersep> id <identifiersep> update ( property <identifiersep> class , idid ) ; } times [ this . timer ++ ] += execute <identifiersep> id <identifiersep> update ( base <identifiersep> object . class , id ) ; } } ) ; int timer = 0 ; <LOG> for ( string [ ] coll : objs <identifiersep> coll ) { } for ( string custom <identifiersep> mapped <identifiersep> class : custom <identifiersep> class <identifiersep> to <identifiersep> process ) { this . logger . debug ( <string_literal> , custom <identifiersep> mapped <identifiersep> class , times [ timer ++ ] / <number_literal> ) ; } for ( string property <identifiersep> class : class <identifiersep> to <identifiersep> process ) { this . logger . debug ( <string_literal> , property <identifiersep> class , <ect>
times [ this . timer ++ ] += execute <identifiersep> id <identifiersep> update ( stats <identifiersep> class , id ) ; } } ) ; int timer = 0 ; for ( string [ ] coll : stats <identifiersep> coll ) { this . logger . debug ( <string_literal> , coll [ 0 ] , <LOG> times [ timer ++ ] / <number_literal> ) ; } times [ timer ++ ] / <number_literal> ) ; } } log <identifiersep> progress ( <string_literal> , klass <identifiersep> name ) ; } else { log <identifiersep> progress ( <string_literal> , klass <identifiersep> name ) ; } } } <comment> <ect>
for ( table table : this . fk <identifiersep> tables ) { append <identifiersep> add <identifiersep> foreign <identifiersep> key <identifiersep> change <identifiersep> log ( sb , table ) ; } <comment> <LOG> log <identifiersep> progress ( <string_literal> , this . log <identifiersep> count ) ; } return sb . to <identifiersep> string ( ) ; } } <ect>
if ( liquibase <identifiersep> change <identifiersep> logs == null || liquibase <identifiersep> change <identifiersep> logs . length ( ) == 0 ) { return ; } final string database = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) . get <identifiersep> wiki <identifiersep> id ( ) ; if ( pre <identifiersep> hibernate ) { this . logger . info ( <string_literal> , database ) ; <LOG> } else { } } final string <identifiersep> builder change <identifiersep> logs = new string <identifiersep> builder ( <number_literal> ) ; change <identifiersep> logs . append ( get <identifiersep> liquibase <identifiersep> change <identifiersep> log <identifiersep> header ( ) ) ; change <identifiersep> logs . append ( liquibase <identifiersep> change <identifiersep> logs ) ; change <identifiersep> logs . append ( get <identifiersep> liquibase <identifiersep> change <identifiersep> log <identifiersep> footer ( ) ) ; final x <identifiersep> wiki <identifiersep> hibernate <identifiersep> base <identifiersep> store store = get <identifiersep> store ( ) ; <ect>
out . println ( <string_literal> + this . sql <identifiersep> list . get ( i ) ) ; } out . flush ( ) ; } public void log <identifiersep> sql <identifiersep> list ( ) { logger . debug ( <string_literal> + this . sql <identifiersep> list . size ( ) ) ; <LOG> for ( int i = 0 ; i < this . sql <identifiersep> list . size ( ) ; i ++ ) { } } } } <ect>
return get <identifiersep> attachment <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store ( store <identifiersep> type ) ; } protected attachment <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store get <identifiersep> attachment <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store ( string store <identifiersep> type ) { if ( store <identifiersep> type != null && ! store <identifiersep> type . equals ( hint ) ) { try { return this . component <identifiersep> manager . get <identifiersep> instance ( attachment <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store . class , store <identifiersep> type ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } return null ; } private deleted <identifiersep> attachment resolve <identifiersep> deleted <identifiersep> attachment <identifiersep> content ( deleted <identifiersep> attachment deleted <identifiersep> attachment , boolean b <identifiersep> transaction , boolean fail <identifiersep> if <identifiersep> no <identifiersep> content ) throws x <identifiersep> wiki <identifiersep> exception { attachment <identifiersep> recycle <identifiersep> bin <identifiersep> content <identifiersep> store content <identifiersep> store = <ect>
<comment> <LOG> } catch ( exception e ) { cachedoc = null ; } if ( cachedoc != null ) { cachedoc . set <identifiersep> from <identifiersep> cache ( true ) ; logger . debug ( <string_literal> , key ) ; } else { <ect>
cachedoc = null ; } if ( cachedoc != null ) { cachedoc . set <identifiersep> from <identifiersep> cache ( true ) ; logger . debug ( <string_literal> , key ) ; } else { boolean result = get <identifiersep> page <identifiersep> exist <identifiersep> cache ( ) . get ( key ) ; <LOG> if ( result == boolean . false ) { cachedoc = doc ; cachedoc . set <identifiersep> new ( true ) ; <comment> <ect>
cachedoc . set <identifiersep> new ( true ) ; <comment> <LOG> cachedoc = this . store . load <identifiersep> x <identifiersep> wiki <identifiersep> doc ( doc , context ) ; if ( cachedoc . is <identifiersep> new ( ) ) { get <identifiersep> page <identifiersep> exist <identifiersep> cache ( ) . set ( key , boolean . false ) ; } else { get <identifiersep> cache ( ) . set ( key , cachedoc ) ; <comment> <ect>
get <identifiersep> page <identifiersep> exist <identifiersep> cache ( ) . set ( key , boolean . false ) ; } else { get <identifiersep> cache ( ) . set ( key , cachedoc ) ; <comment> <LOG> cachedoc . set <identifiersep> store ( this . store ) ; } return cachedoc ; } @ override public void delete <identifiersep> x <identifiersep> wiki <identifiersep> doc ( x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <comment> <ect>
<comment> public synchronized void update <identifiersep> schema ( x <identifiersep> wiki <identifiersep> context inputxcontext , boolean force ) throws hibernate <identifiersep> exception { x <identifiersep> wiki <identifiersep> context context = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( inputxcontext ) ; <comment> <LOG> && ( <string_literal> . equals ( context . get <identifiersep> wiki ( ) . param ( <string_literal> ) ) ) ) { return ; } logger . info ( <string_literal> , context . get <identifiersep> wiki <identifiersep> id ( ) ) ; try { string [ ] sql = get <identifiersep> schema <identifiersep> update <identifiersep> script ( this . store . get <identifiersep> configuration ( ) , context ) ; update <identifiersep> schema ( sql , context ) ; <ect>
logger . debug ( <string_literal> , context . get <identifiersep> wiki <identifiersep> id ( ) ) ; return ; } logger . info ( <string_literal> , context . get <identifiersep> wiki <identifiersep> id ( ) ) ; try { string [ ] sql = get <identifiersep> schema <identifiersep> update <identifiersep> script ( this . store . get <identifiersep> configuration ( ) , context ) ; update <identifiersep> schema ( sql , context ) ; <LOG> } finally { } } <comment> <ect>
try { list < property <identifiersep> class <identifiersep> provider > providers = utils . get <identifiersep> context <identifiersep> component <identifiersep> manager ( ) . get <identifiersep> instance <identifiersep> list ( property <identifiersep> class <identifiersep> provider . class ) ; for ( property <identifiersep> class <identifiersep> provider provider : providers ) { property <identifiersep> interface property = provider . get <identifiersep> definition ( ) ; safeput ( property . get <identifiersep> name ( ) , property ) ; } <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } @ override public void safeput ( string name , property <identifiersep> interface property ) { add <identifiersep> field ( property <identifiersep> name <identifiersep> prefix + name , property ) ; if ( property instanceof property <identifiersep> class ) { <ect>
public string to <identifiersep> xml <identifiersep> string ( boolean format ) { xar <identifiersep> output <identifiersep> properties xar <identifiersep> properties = new xar <identifiersep> output <identifiersep> properties ( ) ; xar <identifiersep> properties . set <identifiersep> format ( false ) ; try { return utils . get <identifiersep> component ( x <identifiersep> wiki <identifiersep> document <identifiersep> filter <identifiersep> utils . class ) . export <identifiersep> entity ( this , xar <identifiersep> properties ) ; <LOG> } catch ( exception e ) { return <string_literal> ; } } @ override public string to <identifiersep> string ( ) { return to <identifiersep> xml <identifiersep> string ( true ) ; <ect>
<comment> public string get <identifiersep> password <identifiersep> hash ( string password , string algorithm <identifiersep> name , string salt ) { <comment> <LOG> try { string salted <identifiersep> password = salt + password ; message <identifiersep> digest hash <identifiersep> algorithm = message <identifiersep> digest . get <identifiersep> instance ( algorithm <identifiersep> name ) ; hash <identifiersep> algorithm . update ( salted <identifiersep> password . get <identifiersep> bytes ( ) ) ; byte [ ] digest = hash <identifiersep> algorithm . digest ( ) ; <comment> <ect>
{ <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { return collections . empty <identifiersep> list ( ) ; } } @ override public map < string , list <identifiersep> item > get <identifiersep> map ( x <identifiersep> wiki <identifiersep> context context ) { <comment> <ect>
x <identifiersep> wiki xwiki = context . get <identifiersep> wiki ( ) ; string res = <string_literal> ; try { list = xwiki . search ( newsql , context ) . to <identifiersep> array ( ) ; if ( list . length > 0 ) { res = list [ 0 ] . to <identifiersep> string ( ) ; } <LOG> } catch ( exception e ) { } return res ; } <comment> <ect>
@ override public list < string > get <identifiersep> list ( x <identifiersep> wiki <identifiersep> context context ) { try { return ( list < string > ) context . get <identifiersep> wiki ( ) . get <identifiersep> group <identifiersep> service ( context ) . get <identifiersep> all <identifiersep> matched <identifiersep> groups ( null , false , 0 , 0 , null , context ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { return collections . empty <identifiersep> list ( ) ; } } @ override public map < string , list <identifiersep> item > get <identifiersep> map ( x <identifiersep> wiki <identifiersep> context context ) { return new hash <identifiersep> map < string , list <identifiersep> item > ( ) ; <ect>
<comment> @ deprecated public void set <identifiersep> class <identifiersep> type ( string type ) <LOG> { } @ override public property <identifiersep> class clone ( ) { property <identifiersep> class pclass = ( property <identifiersep> class ) super . clone ( ) ; pclass . set <identifiersep> object ( get <identifiersep> object ( ) ) ; <ect>
{ logger . debug ( <string_literal> , property <identifiersep> class <identifiersep> name ) ; try { <comment> <LOG> if ( context . get <identifiersep> wiki ( ) . exists ( reference , context ) ) { return document <identifiersep> displayer <identifiersep> identifier <identifiersep> prefix + <string_literal> + page <identifiersep> name ; } <comment> <ect>
logger . debug ( <string_literal> , page <identifiersep> name ) ; return document <identifiersep> displayer <identifiersep> identifier <identifiersep> prefix + context . get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) + <string_literal> + page <identifiersep> name ; } } <comment> <LOG> if ( existing <identifiersep> template != null ) { return template <identifiersep> displayer <identifiersep> identifier <identifiersep> prefix + template <identifiersep> name ; } } catch ( throwable e ) { <comment> <ect>
x <identifiersep> wiki <identifiersep> document doc = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , xcontext ) ; base <identifiersep> object object = doc . get <identifiersep> x <identifiersep> object ( object <identifiersep> reference ) ; if ( object != null ) { base <identifiersep> property property = ( base <identifiersep> property ) object . get ( property <identifiersep> name ) ; if ( property != null ) { value = property . get <identifiersep> value ( ) ; } } } <LOG> } catch ( exception e ) { } return value ; } @ override public object get <identifiersep> property ( string document <identifiersep> reference , string class <identifiersep> name , int object <identifiersep> number , string property <identifiersep> name ) { object value = null ; <ect>
x <identifiersep> wiki <identifiersep> document doc = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , xcontext ) ; base <identifiersep> object object = doc . get <identifiersep> object ( class <identifiersep> name ) ; if ( object != null ) { base <identifiersep> property property = ( base <identifiersep> property ) object . get ( property <identifiersep> name ) ; if ( property != null ) { value = property . get <identifiersep> value ( ) ; } } } <LOG> } catch ( exception e ) { } return value ; } @ override public object get <identifiersep> property ( document <identifiersep> reference document <identifiersep> reference , document <identifiersep> reference class <identifiersep> reference , string property <identifiersep> name ) { <ect>
x <identifiersep> wiki <identifiersep> document doc = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , xcontext ) ; base <identifiersep> object object = doc . get <identifiersep> x <identifiersep> object ( class <identifiersep> reference , object <identifiersep> number ) ; if ( object != null ) { base <identifiersep> property property = ( base <identifiersep> property ) object . get ( property <identifiersep> name ) ; if ( property != null ) { value = property . get <identifiersep> value ( ) ; } } } <LOG> } catch ( exception e ) { } return value ; } @ override public object get <identifiersep> property ( string document <identifiersep> reference , string property <identifiersep> name ) { object value = null ; <ect>
if ( ! x <identifiersep> wiki <identifiersep> right <identifiersep> service . is <identifiersep> super <identifiersep> admin ( user <identifiersep> reference ) ) { x <identifiersep> wiki <identifiersep> context xcontext = get <identifiersep> context ( ) ; try { x <identifiersep> wiki <identifiersep> document user <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( user <identifiersep> reference , xcontext ) ; advanced = string <identifiersep> utils . equals ( user <identifiersep> document . get <identifiersep> string <identifiersep> value ( userclass <identifiersep> reference , <string_literal> ) , <string_literal> ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } return advanced ; } @ override public void set <identifiersep> current <identifiersep> user ( string user <identifiersep> name ) { get <identifiersep> context ( ) . set <identifiersep> user ( user <identifiersep> name ) ; <ect>
<comment> @ override public void fatal <identifiersep> error ( sax <identifiersep> parse <identifiersep> exception exception ) throws sax <identifiersep> exception <LOG> { exception . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
@ override public object clone ( ) { try { return super . clone ( ) ; } catch ( exception e ) { <LOG> <comment> <ect>
try { xdom title <identifiersep> xdom = get <identifiersep> document <identifiersep> displayer ( ) . display ( this , parameters ) ; return render <identifiersep> xdom ( title <identifiersep> xdom , output <identifiersep> syntax ) ; } catch ( exception e ) { <comment> <LOG> <comment> <ect>
{ if ( custom <identifiersep> class != null ) { try { class < ? > [ ] classes = new class [ ] { x <identifiersep> wiki <identifiersep> document . class , x <identifiersep> wiki <identifiersep> context . class } ; object [ ] args = new object [ ] { this , context } ; return ( com . xpn . xwiki . api . document ) custom <identifiersep> class . get <identifiersep> constructor ( classes ) . new <identifiersep> instance ( args ) ; <LOG> } catch ( exception e ) { } } return new com . xpn . xwiki . api . document ( this , context ) ; } public com . xpn . xwiki . api . document new <identifiersep> document ( x <identifiersep> wiki <identifiersep> context context ) { string custom <identifiersep> class = get <identifiersep> custom <identifiersep> class ( ) ; return new <identifiersep> document ( custom <identifiersep> class , context ) ; <ect>
public list < string > get <identifiersep> included <identifiersep> pages ( x <identifiersep> wiki <identifiersep> context context ) { try { return get <identifiersep> included <identifiersep> pages <identifiersep> internal ( context ) ; } catch ( exception e ) { <comment> <LOG> <comment> <ect>
x <identifiersep> wiki <identifiersep> document tdoc = this ; if ( locale != null && ! locale . equals ( locale . root ) && ! locale . equals ( get <identifiersep> default <identifiersep> locale ( ) ) ) { try { tdoc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( new document <identifiersep> reference ( get <identifiersep> document <identifiersep> reference ( ) , locale ) , context ) ; if ( ! tdoc . is <identifiersep> new ( ) ) { return tdoc ; } <LOG> } catch ( exception e ) { } tdoc = get <identifiersep> translated <identifiersep> document ( locale <identifiersep> utils . get <identifiersep> parent <identifiersep> locale ( locale ) , context ) ; } return tdoc ; } <comment> <ect>
difflist . add ( new attachment <identifiersep> diff ( file <identifiersep> name , org . xwiki . diff . delta . type . delete , orig <identifiersep> attach , new <identifiersep> attach ) ) ; } else { try { if ( ! orig <identifiersep> attach . equals <identifiersep> data ( new <identifiersep> attach , context ) ) { difflist . add ( new attachment <identifiersep> diff ( file <identifiersep> name , org . xwiki . diff . delta . type . change , orig <identifiersep> attach , new <identifiersep> attach ) ) ; } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { new <identifiersep> attach . get <identifiersep> reference ( ) , e ) ; } } } for ( x <identifiersep> wiki <identifiersep> attachment new <identifiersep> attach : to <identifiersep> doc . get <identifiersep> attachment <identifiersep> list ( ) ) { string file <identifiersep> name = new <identifiersep> attach . get <identifiersep> filename ( ) ; x <identifiersep> wiki <identifiersep> attachment orig <identifiersep> attach = from <identifiersep> doc . get <identifiersep> attachment ( file <identifiersep> name ) ; if ( orig <identifiersep> attach == null ) { <ect>
<comment> public string get <identifiersep> version <identifiersep> hash <identifiersep> code ( x <identifiersep> wiki <identifiersep> context context ) { message <identifiersep> digest md5 = null ; try { md5 = message <identifiersep> digest . get <identifiersep> instance ( <string_literal> ) ; <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { return hash <identifiersep> code ( ) + <string_literal> ; } try { string value <identifiersep> before <identifiersep> md5 = to <identifiersep> xml ( true , false , true , false , context ) ; md5 . update ( value <identifiersep> before <identifiersep> md5 . get <identifiersep> bytes ( ) ) ; byte [ ] array = md5 . digest ( ) ; <ect>
<comment> private syntax get <identifiersep> default <identifiersep> document <identifiersep> syntax ( ) { syntax syntax = utils . get <identifiersep> component ( core <identifiersep> configuration . class ) . get <identifiersep> default <identifiersep> document <identifiersep> syntax ( ) ; if ( syntax == null || ( ! utils . get <identifiersep> component <identifiersep> manager ( ) . has <identifiersep> component ( parser . class , syntax . to <identifiersep> id <identifiersep> string ( ) ) <LOG> && ! syntax . xwiki <identifiersep> <number_literal> <identifiersep> 1 . equals ( syntax ) ) ) { syntax = syntax . xwiki <identifiersep> <number_literal> <identifiersep> 1 ; } return syntax ; } <comment> <ect>
attachment . set <identifiersep> attachment <identifiersep> content ( ( x <identifiersep> wiki <identifiersep> attachment <identifiersep> content ) get <identifiersep> attachment <identifiersep> content ( ) . clone ( ) ) ; attachment . get <identifiersep> attachment <identifiersep> content ( ) . set <identifiersep> attachment ( attachment ) ; } if ( get <identifiersep> attachment <identifiersep> archive ( ) != null ) { attachment . set <identifiersep> attachment <identifiersep> archive ( ( x <identifiersep> wiki <identifiersep> attachment <identifiersep> archive ) get <identifiersep> attachment <identifiersep> archive ( ) . clone ( ) ) ; attachment . get <identifiersep> attachment <identifiersep> archive ( ) . set <identifiersep> attachment ( attachment ) ; } } catch ( clone <identifiersep> not <identifiersep> supported <identifiersep> exception e ) { <LOG> <comment> <ect>
<comment> <LOG> } catch ( exception e ) { } } return media <identifiersep> type ; } public boolean is <identifiersep> image ( x <identifiersep> wiki <identifiersep> context context ) { string contenttype = get <identifiersep> mime <identifiersep> type ( context ) ; if ( contenttype . starts <identifiersep> with ( <string_literal> ) ) { <ect>
<comment> public boolean is <identifiersep> diff ( ) { if ( this . content != null ) { <LOG> if ( this . is <identifiersep> diff != is <identifiersep> content <identifiersep> diff ( ) ) { return is <identifiersep> content <identifiersep> diff ( ) ; } } return this . is <identifiersep> diff ; } <comment> <ect>
<comment> <LOG> <comment> <ect>
{ try { return document <identifiersep> builder <identifiersep> factory . new <identifiersep> instance ( ) . new <identifiersep> document <identifiersep> builder ( ) . parse ( new input <identifiersep> source ( new string <identifiersep> reader ( str ) ) ) ; } catch ( sax <identifiersep> exception ex ) { logger . warn ( <string_literal> + str , ex ) ; <LOG> } catch ( io <identifiersep> exception ex ) { } catch ( parser <identifiersep> configuration <identifiersep> exception ex ) { logger . warn ( <string_literal> + str , ex ) ; } return null ; } <comment> <ect>
<comment> public org . w3c . dom . document get <identifiersep> dom <identifiersep> document ( ) { try { return document <identifiersep> builder <identifiersep> factory . new <identifiersep> instance ( ) . new <identifiersep> document <identifiersep> builder ( ) . new <identifiersep> document ( ) ; <LOG> } catch ( parser <identifiersep> configuration <identifiersep> exception ex ) { } return null ; } <comment> <ect>
logger . debug ( <string_literal> + resource + <string_literal> ) ; } try { container container = utils . get <identifiersep> component ( container . class ) ; input <identifiersep> stream res = container . get <identifiersep> application <identifiersep> context ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( resource ) ; if ( res != null ) { return res ; } <LOG> } catch ( exception e ) { } return thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( resource ) ; } <comment> <ect>
long hash = 0 ; try { message <identifiersep> digest md5 = message <identifiersep> digest . get <identifiersep> instance ( <string_literal> ) ; byte [ ] digest = md5 . digest ( uid . get <identifiersep> bytes ( <string_literal> ) ) ; for ( int l = digest . length , i = math . max ( 0 , digest . length - <number_literal> ) ; i < l ; i ++ ) { hash = hash < < <number_literal> | ( ( long ) digest [ i ] & 0x <identifiersep> ff ) ; } <LOG> } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { throw new runtime <identifiersep> exception ( <string_literal> ) ; } catch ( exception ex ) { logger . error ( <string_literal> , ex ) ; throw new runtime <identifiersep> exception ( <string_literal> ) ; } return hash ; <ect>
@ override public final void run ( ) { try { <comment> <LOG> } catch ( execution <identifiersep> context <identifiersep> exception e ) { return ; } try { <comment> <ect>
@ override public url create <identifiersep> attachment <identifiersep> url ( string filename , string spaces , string name , string action , string querystring , string wiki , x <identifiersep> wiki <identifiersep> context context ) { try { return get <identifiersep> url ( wiki , spaces , name , filename , null , context ) ; <LOG> } catch ( exception ex ) { return super . create <identifiersep> attachment <identifiersep> url ( filename , spaces , name , action , null , wiki , context ) ; } } @ override public url create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( string filename , string spaces , string name , string revision , string wiki , x <identifiersep> wiki <identifiersep> context context ) { <ect>
throws exception { map < string , file > used <identifiersep> files = get <identifiersep> file <identifiersep> mapping ( context ) ; list < string > space <identifiersep> names = this . legacy <identifiersep> space <identifiersep> resolver . resolve ( spaces ) ; string key = get <identifiersep> attachment <identifiersep> key ( space <identifiersep> names , name , filename , revision ) ; if ( ! used <identifiersep> files . contains <identifiersep> key ( key ) ) { <LOG> file file = get <identifiersep> temporary <identifiersep> file ( key , context ) ; x <identifiersep> wiki <identifiersep> document doc = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( new document <identifiersep> reference ( string <identifiersep> utils . default <identifiersep> string ( wiki , context . get <identifiersep> wiki <identifiersep> id ( ) ) , space <identifiersep> names , name ) , context ) ; x <identifiersep> wiki <identifiersep> attachment attachment = doc . get <identifiersep> attachment ( filename ) ; if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( revision ) ) { attachment = attachment . get <identifiersep> attachment <identifiersep> revision ( revision , context ) ; <ect>
<comment> private string convert <identifiersep> to <identifiersep> strict <identifiersep> x <identifiersep> html ( string input ) <LOG> { html <identifiersep> cleaner cleaner = utils . get <identifiersep> component ( html <identifiersep> cleaner . class ) ; html <identifiersep> cleaner <identifiersep> configuration config = cleaner . get <identifiersep> default <identifiersep> configuration ( ) ; list < html <identifiersep> filter > filters = new array <identifiersep> list < html <identifiersep> filter > ( config . get <identifiersep> filters ( ) ) ; filters . add ( utils . get <identifiersep> component ( html <identifiersep> filter . class , <string_literal> ) ) ; config . set <identifiersep> filters ( filters ) ; <ect>
final velocity <identifiersep> engine final <identifiersep> velocity <identifiersep> engine = velocity <identifiersep> engine ; this . author <identifiersep> executor . call ( ( ) - > { final <identifiersep> velocity <identifiersep> engine . evaluate ( new velocity <identifiersep> context ( ) , null <identifiersep> writer . null <identifiersep> writer , <string_literal> , template . get <identifiersep> content ( ) . get <identifiersep> content ( ) ) ; return null ; } , template . get <identifiersep> content ( ) . get <identifiersep> author <identifiersep> reference ( ) ) ; <LOG> } catch ( exception e ) { } } } } } return velocity <identifiersep> engine ; } @ override public boolean evaluate ( writer out , string template <identifiersep> name , reader source ) throws x <identifiersep> wiki <identifiersep> velocity <identifiersep> exception { <comment> <ect>
} catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . installable = install <identifiersep> impossible ; return this . installable ; } this . installable = install <identifiersep> ok ; return this . installable ; <LOG> } finally { + ( ( this . doc == null ) ? <string_literal> : get <identifiersep> language ( ) ) + <string_literal> + this . installable ) ; } } } public static string install <identifiersep> status <identifiersep> to <identifiersep> string ( int status ) { if ( status == install <identifiersep> impossible ) { return <string_literal> ; <ect>
continue ; } <comment> <LOG> } catch ( exclude <identifiersep> document <identifiersep> exception e ) { } } } <comment> <ect>
for ( document <identifiersep> info doc <identifiersep> info : this . files ) { if ( doc <identifiersep> info . get <identifiersep> full <identifiersep> name ( ) . equals ( doc <identifiersep> name ) && doc <identifiersep> info . get <identifiersep> language ( ) . equals ( language ) ) { doc <identifiersep> info . set <identifiersep> action ( default <identifiersep> action ) ; return ; } } } public int test <identifiersep> install ( boolean is <identifiersep> admin , x <identifiersep> wiki <identifiersep> context context ) <LOG> { } int result = document <identifiersep> info . install <identifiersep> impossible ; try { if ( this . files . size ( ) == 0 ) { return result ; } result = this . files . get ( 0 ) . test <identifiersep> install ( is <identifiersep> admin , context ) ; <ect>
local <identifiersep> extension local <identifiersep> extension = local <identifiersep> repository . get <identifiersep> local <identifiersep> extension ( extension <identifiersep> id ) ; if ( local <identifiersep> extension == null ) { extension extension ; try { <comment> <LOG> } catch ( resolve <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> int result = document <identifiersep> info . install <identifiersep> ok ; } if ( doc . get <identifiersep> action ( ) == document <identifiersep> info . action <identifiersep> skip ) { add <identifiersep> to <identifiersep> skipped ( doc . get <identifiersep> full <identifiersep> name ( ) + <string_literal> + doc . get <identifiersep> language ( ) , context ) ; return document <identifiersep> info . install <identifiersep> ok ; } int status = doc . test <identifiersep> install ( is <identifiersep> admin , context ) ; if ( status == document <identifiersep> info . install <identifiersep> impossible ) { <ect>
} catch ( exception e ) { <comment> <LOG> logger . error ( <string_literal> + previousdoc . get <identifiersep> document <identifiersep> reference ( ) ) ; } } } } else if ( previousdoc . has <identifiersep> element ( x <identifiersep> wiki <identifiersep> document . has <identifiersep> attachments ) ) { <comment> <ect>
string filename = get <identifiersep> file <identifiersep> name <identifiersep> from <identifiersep> document ( doc , context ) ; file file = new file ( spacedir , filename ) ; file <identifiersep> output <identifiersep> stream fos = new file <identifiersep> output <identifiersep> stream ( file ) ; doc . to <identifiersep> xml ( fos , true , false , true , with <identifiersep> versions , context ) ; fos . flush ( ) ; fos . close ( ) ; <LOG> } catch ( exclude <identifiersep> document <identifiersep> exception e ) { } catch ( exception e ) { object [ ] args = new object [ 1 ] ; args [ 0 ] = doc . get <identifiersep> document <identifiersep> reference ( ) ; throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> doc , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> doc <identifiersep> export , <string_literal> , e , args ) ; <ect>
++ count ; } else { throw new package <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <string_literal> + doc . get <identifiersep> document <identifiersep> reference ( ) + <string_literal> ) ; } } catch ( exclude <identifiersep> document <identifiersep> exception e ) { logger . info ( <string_literal> + doc . get <identifiersep> document <identifiersep> reference ( ) + <string_literal> ) ; } <LOG> } else if ( ! file . get <identifiersep> name ( ) . equals ( default <identifiersep> package <identifiersep> file <identifiersep> name ) ) { } } } return count ; } <comment> <ect>
{ add <identifiersep> plugins ( class <identifiersep> names , context ) ; } @ suppress <identifiersep> warnings ( <string_literal> ) public void add <identifiersep> plugin ( string name , string class <identifiersep> name , x <identifiersep> wiki <identifiersep> context context ) { <LOG> if ( this . plugin <identifiersep> class <identifiersep> names . contains ( class <identifiersep> name ) ) { } return ; } try { class < ? > [ ] classes = new class < ? > [ <number_literal> ] ; classes [ 0 ] = string . class ; classes [ 1 ] = string . class ; <ect>
} catch ( exception e ) { } } } public void flush <identifiersep> cache ( x <identifiersep> wiki <identifiersep> context context ) { for ( x <identifiersep> wiki <identifiersep> plugin <identifiersep> interface plugin : get <identifiersep> plugins ( <string_literal> ) ) { try { plugin . flush <identifiersep> cache ( context ) ; <LOG> } catch ( exception e ) { } } } public string common <identifiersep> tags <identifiersep> handler ( string text , x <identifiersep> wiki <identifiersep> context context ) { for ( x <identifiersep> wiki <identifiersep> plugin <identifiersep> interface plugin : get <identifiersep> plugins ( <string_literal> ) ) { try { text = plugin . common <identifiersep> tags <identifiersep> handler ( text , context ) ; <ect>
<comment> public void clean <identifiersep> file <identifiersep> list ( x <identifiersep> wiki <identifiersep> context context ) <LOG> { list < file <identifiersep> item > fileuploadlist = get <identifiersep> file <identifiersep> items ( context ) ; if ( fileuploadlist != null ) { for ( file <identifiersep> item item : fileuploadlist ) { try { item . delete ( ) ; <ect>
<comment> public void load <identifiersep> file <identifiersep> list ( long upload <identifiersep> max <identifiersep> size , int upload <identifiersep> size <identifiersep> threashold , string tempdir , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception <LOG> { <comment> <ect>
request <identifiersep> context req <identifiersep> context = new servlet <identifiersep> request <identifiersep> context ( context . get <identifiersep> request ( ) . get <identifiersep> http <identifiersep> servlet <identifiersep> request ( ) ) ; fileupload . set <identifiersep> size <identifiersep> max ( upload <identifiersep> max <identifiersep> size ) ; <comment> <LOG> if ( list . size ( ) > 0 ) { } <comment> <ect>
list < file <identifiersep> item > fileuploadlist = get <identifiersep> file <identifiersep> items ( context ) ; if ( fileuploadlist == null ) { return null ; } file <identifiersep> item fileitem = null ; for ( file <identifiersep> item item : fileuploadlist ) { if ( formfield <identifiersep> name . equals ( item . get <identifiersep> field <identifiersep> name ( ) ) ) { <LOG> fileitem = item ; break ; } } return fileitem ; } } <ect>
{ int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> wiki <identifiersep> users <identifiersep> or <identifiersep> groups ( false , wiki <identifiersep> name , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { } return count ; } <comment> <ect>
{ int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> local <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { } return count ; } <comment> <ect>
try { list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> local <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; group <identifiersep> list = convert ( xdoc <identifiersep> list ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } } <ect>
{ collection < string > member <identifiersep> list ; try { member <identifiersep> list = rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> members <identifiersep> names <identifiersep> for <identifiersep> group ( group , match <identifiersep> field , nb , start , order <identifiersep> asc , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { member <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return member <identifiersep> list ; } <comment> <ect>
<comment> public int count <identifiersep> all <identifiersep> members <identifiersep> names <identifiersep> for <identifiersep> group ( string group ) throws x <identifiersep> wiki <identifiersep> exception { int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> members <identifiersep> names <identifiersep> for <identifiersep> group ( group , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { } return count ; } } <ect>
{ int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> wiki <identifiersep> users <identifiersep> or <identifiersep> groups ( true , wiki <identifiersep> name , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { } return count ; } <comment> <ect>
{ int count = 0 ; try { count = rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> local <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { } return count ; } <comment> <ect>
list < string > user <identifiersep> list ; try { user <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
list < string > user <identifiersep> list ; try { user <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> local <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
try { list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; user <identifiersep> list = convert ( xdoc <identifiersep> list ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } <comment> <ect>
try { list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> local <identifiersep> users <identifiersep> or <identifiersep> groups ( true , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; user <identifiersep> list = convert ( xdoc <identifiersep> list ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { user <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return user <identifiersep> list ; } } <ect>
clean <identifiersep> deleted <identifiersep> user <identifiersep> or <identifiersep> group ( user <identifiersep> or <identifiersep> group <identifiersep> wiki , user <identifiersep> or <identifiersep> group <identifiersep> space , user <identifiersep> or <identifiersep> group <identifiersep> name , true , context ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } else if ( document . get <identifiersep> object ( <string_literal> ) != null ) { try { clean <identifiersep> deleted <identifiersep> user <identifiersep> or <identifiersep> group ( user <identifiersep> or <identifiersep> group <identifiersep> wiki , user <identifiersep> or <identifiersep> group <identifiersep> space , user <identifiersep> or <identifiersep> group <identifiersep> name , false , context ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } } <comment> <ect>
<comment> @ deprecated public string get <identifiersep> wiki <identifiersep> owner ( ) { try { return get <identifiersep> wiki ( ) . get <identifiersep> wiki <identifiersep> owner ( get <identifiersep> wiki <identifiersep> id ( ) , this ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } return null ; } public x <identifiersep> wiki <identifiersep> document get <identifiersep> wiki <identifiersep> server ( ) { string current <identifiersep> wiki = get <identifiersep> wiki <identifiersep> id ( ) ; try { <ect>
this . queue . clear ( ) ; try { this . queue . put ( new stop <identifiersep> stats <identifiersep> register <identifiersep> object ( ) ) ; this . thread . join ( ) ; this . thread = null ; <LOG> } catch ( interrupted <identifiersep> exception e ) { } } } @ override public void run <identifiersep> internal ( ) { try { while ( true ) { <ect>
while ( true ) { register ( ) ; } } catch ( interrupted <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } <LOG> } catch ( stop <identifiersep> stats <identifiersep> store <identifiersep> exception e ) { } } } <comment> <ect>
new referer <identifiersep> stats ( last <identifiersep> item . name , last <identifiersep> item . referer , last <identifiersep> item . period <identifiersep> date , last <identifiersep> item . period <identifiersep> type ) ; <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } <comment> <ect>
<comment> <LOG> } catch ( exception e ) { } } } <comment> <ect>
try { for ( document <identifiersep> reference user : stats <identifiersep> util . get <identifiersep> request <identifiersep> filtered <identifiersep> users ( context ) ) { if ( user <identifiersep> list <identifiersep> where . length ( ) > 0 ) { user <identifiersep> list <identifiersep> where . append ( <string_literal> ) ; } user <identifiersep> list <identifiersep> where . append ( ' ? ' ) ; param <identifiersep> list . add ( this . compactwiki <identifiersep> entity <identifiersep> reference <identifiersep> serializer . serialize ( user ) ) ; } <LOG> } catch ( exception e ) { } if ( user <identifiersep> list <identifiersep> where . length ( ) > 0 ) { query . append ( <string_literal> ) ; query . append ( user <identifiersep> list <identifiersep> where ) ; query . append ( <string_literal> ) ; } <comment> <ect>
new document <identifiersep> stats ( last <identifiersep> item . name , last <identifiersep> item . action , last <identifiersep> item . period <identifiersep> date , last <identifiersep> item . period <identifiersep> type ) ; <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } <comment> <ect>
try { solist = qm . create <identifiersep> query ( <string_literal> + <string_literal> + field <identifiersep> name + <string_literal> + <string_literal> , query . hql ) . bind <identifiersep> value ( sfield <identifiersep> value , field <identifiersep> value ) . bind <identifiersep> value ( sdate , current <identifiersep> date ) . execute ( ) ; <LOG> } catch ( exception e ) { } } else { throw new unsupported <identifiersep> operation <identifiersep> exception ( <string_literal> ) ; } if ( solist != null && solist . size ( ) > 0 ) { visit <identifiersep> stats = solist . get ( 0 ) ; } return visit <identifiersep> stats ; <ect>
public url get <identifiersep> url ( ) { url url = null ; try { url = new url ( get <identifiersep> referer ( ) ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { } } return url ; } } <ect>
logger . debug ( <string_literal> + cthread . get <identifiersep> name ( ) + <string_literal> + mdata . get <identifiersep> wiki <identifiersep> page ( ) + <string_literal> ) ; } mdata . end <identifiersep> request ( false ) ; } mdata = new monitor <identifiersep> data ( page , action , url , cthread . get <identifiersep> name ( ) ) ; this . active <identifiersep> timer <identifiersep> data <identifiersep> list . put ( cthread , mdata ) ; <LOG> } catch ( throwable e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void add <identifiersep> to <identifiersep> last <identifiersep> unfinished <identifiersep> timer <identifiersep> data <identifiersep> list ( monitor <identifiersep> data mdata ) { this . last <identifiersep> unfinished <identifiersep> timer <identifiersep> data <identifiersep> list . add ( mdata ) ; } public void end <identifiersep> request ( ) <ect>
mdata . end <identifiersep> request ( true ) ; add <identifiersep> duration ( mdata . get <identifiersep> duration ( ) ) ; add <identifiersep> timer <identifiersep> duration ( mdata ) ; remove <identifiersep> from <identifiersep> active <identifiersep> timer <identifiersep> data <identifiersep> list ( cthread ) ; add <identifiersep> to <identifiersep> timer <identifiersep> data <identifiersep> list ( mdata ) ; <LOG> } catch ( throwable e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void remove <identifiersep> from <identifiersep> active <identifiersep> timer <identifiersep> data <identifiersep> list ( thread cthread ) { if ( this . active <identifiersep> timer <identifiersep> data <identifiersep> list . contains <identifiersep> key ( cthread ) ) { this . active <identifiersep> timer <identifiersep> data <identifiersep> list . remove ( cthread ) ; <ect>
try { thread cthread = thread . current <identifiersep> thread ( ) ; monitor <identifiersep> data mdata = this . active <identifiersep> timer <identifiersep> data <identifiersep> list . get ( cthread ) ; if ( mdata != null ) { mdata . set <identifiersep> timer <identifiersep> details ( timername , desc ) ; } <LOG> } catch ( throwable e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } public void end <identifiersep> timer ( string timername ) { if ( is <identifiersep> active ( ) == false ) { return ; <ect>
{ if ( this . start <identifiersep> time == null ) { return ; } monitor <identifiersep> timer timer ; timer = this . timers . get ( timername ) ; <LOG> if ( timer != null ) { } } else { timer = new monitor <identifiersep> timer ( timername , details ) ; timer . set <identifiersep> start <identifiersep> date ( ) ; this . timers . put ( timername , timer ) ; } } public void start <identifiersep> timer ( string timername ) <ect>
{ if ( this . start <identifiersep> time == null ) { return ; } monitor <identifiersep> timer timer ; timer = this . timers . get ( timername ) ; <LOG> if ( timer == null ) { } } else { timer . set <identifiersep> end <identifiersep> date ( ) ; if ( timer . get <identifiersep> details ( ) != null ) { this . timer <identifiersep> list . add ( timer ) ; } this . timers . remove ( timername ) ; <ect>
return this . timer <identifiersep> list ; } public map < string , monitor <identifiersep> timer <identifiersep> summary > get <identifiersep> timer <identifiersep> summaries ( ) { return this . timer <identifiersep> summaries ; } public void log ( ) <LOG> { iterator < monitor <identifiersep> timer <identifiersep> summary > it = this . timer <identifiersep> summaries . values ( ) . iterator ( ) ; while ( it . has <identifiersep> next ( ) ) { monitor <identifiersep> timer <identifiersep> summary tsummary = it . next ( ) ; logger . debug ( <string_literal> + this . wiki <identifiersep> page + <string_literal> + this . action + <string_literal> + tsummary . get <identifiersep> name ( ) + <string_literal> + tsummary . get <identifiersep> duration ( ) + <string_literal> + tsummary . get <identifiersep> nb <identifiersep> calls ( ) ) ; <ect>
public static object call <identifiersep> private <identifiersep> method ( object obj , string method <identifiersep> name , class < ? > [ ] classes , object [ ] args ) { try { method method = obj . get <identifiersep> class ( ) . get <identifiersep> declared <identifiersep> method ( method <identifiersep> name , classes ) ; method . set <identifiersep> accessible ( true ) ; return method . invoke ( obj , args ) ; <LOG> } catch ( illegal <identifiersep> access <identifiersep> exception e ) { return null ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception e ) { return null ; } catch ( invocation <identifiersep> target <identifiersep> exception e ) { logger . error ( <string_literal> , method <identifiersep> name , e ) ; <ect>
try { field field = obj . get <identifiersep> class ( ) . get <identifiersep> declared <identifiersep> field ( field <identifiersep> name ) ; field . set <identifiersep> accessible ( true ) ; return field . get ( obj ) ; } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception e ) { return null ; <LOG> } catch ( illegal <identifiersep> access <identifiersep> exception e ) { return null ; } finally { } } public static string get <identifiersep> server <identifiersep> wiki <identifiersep> page ( string servername ) { return <string_literal> + string <identifiersep> utils . capitalize ( servername ) ; <ect>
public date get <identifiersep> resource <identifiersep> last <identifiersep> modification <identifiersep> date ( string name ) { try { if ( get <identifiersep> engine <identifiersep> context ( ) != null ) { return util . get <identifiersep> file <identifiersep> last <identifiersep> modification <identifiersep> date ( get <identifiersep> engine <identifiersep> context ( ) . get <identifiersep> real <identifiersep> path ( name ) ) ; } } catch ( exception ex ) { <LOG> <comment> <ect>
<comment> @ deprecated public string evaluate <identifiersep> template ( string template , x <identifiersep> wiki <identifiersep> context context ) throws io <identifiersep> exception { try { return get <identifiersep> template <identifiersep> manager ( ) . render ( template ) ; <LOG> } catch ( exception e ) { object [ ] args = { template } ; x <identifiersep> wiki <identifiersep> exception xe = new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> rendering <identifiersep> velocity <identifiersep> exception , <string_literal> , e , args ) ; return util . get <identifiersep> html <identifiersep> exception <identifiersep> message ( xe , context ) ; <ect>
<comment> public string render <identifiersep> template ( string template , string skin , x <identifiersep> wiki <identifiersep> context context ) { try { return get <identifiersep> old <identifiersep> rendering ( ) . render <identifiersep> template ( template , skin , context ) ; <LOG> } catch ( exception ex ) { return parse <identifiersep> template ( template , skin , context ) ; } } <comment> <ect>
public string invoke <identifiersep> servlet <identifiersep> and <identifiersep> return <identifiersep> as <identifiersep> string ( string url , x <identifiersep> wiki <identifiersep> context xwiki <identifiersep> context ) { http <identifiersep> servlet <identifiersep> request servlet <identifiersep> request = xwiki <identifiersep> context . get <identifiersep> request ( ) ; http <identifiersep> servlet <identifiersep> response servlet <identifiersep> response = xwiki <identifiersep> context . get <identifiersep> response ( ) ; try { return include <identifiersep> servlet <identifiersep> as <identifiersep> string . invoke <identifiersep> servlet <identifiersep> and <identifiersep> return <identifiersep> as <identifiersep> string ( url , servlet <identifiersep> request , servlet <identifiersep> response ) ; <LOG> } catch ( exception e ) { return <string_literal> + url + <string_literal> ; } } <comment> <ect>
<comment> <LOG> } catch ( exception e ) { } } return null ; } <comment> @ deprecated <ect>
public string get <identifiersep> base <identifiersep> skin ( x <identifiersep> wiki <identifiersep> context context , boolean from <identifiersep> render <identifiersep> skin ) { string baseskin = <string_literal> ; try { return get <identifiersep> internal <identifiersep> skin <identifiersep> manager ( ) . get <identifiersep> current <identifiersep> parent <identifiersep> skin <identifiersep> id ( false ) ; } catch ( exception e ) { <LOG> baseskin = get <identifiersep> default <identifiersep> base <identifiersep> skin ( context ) ; } return baseskin ; } <comment> <ect>
string [ ] languages = string <identifiersep> utils . split ( xcontext . get <identifiersep> wiki ( ) . get <identifiersep> x <identifiersep> wiki <identifiersep> preference ( <string_literal> , xcontext ) , <string_literal> ) ; list < locale > locales = new array <identifiersep> list < locale > ( languages . length ) ; for ( string language : languages ) { if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( language ) ) { try { locales . add ( locale <identifiersep> utils . to <identifiersep> locale ( language ) ) ; <LOG> } catch ( exception e ) { } } } <comment> <ect>
context . set <identifiersep> wiki <identifiersep> id ( context . get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) ) ; x <identifiersep> wiki <identifiersep> document doc = get <identifiersep> document ( get <identifiersep> server <identifiersep> wiki <identifiersep> page ( wiki <identifiersep> name ) , context ) ; base <identifiersep> object serverobject = doc . get <identifiersep> x <identifiersep> object ( virtual <identifiersep> wiki <identifiersep> definition <identifiersep> class <identifiersep> reference ) ; if ( serverobject != null ) { string server = serverobject . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; return <string_literal> + server + <string_literal> ; } <LOG> } catch ( exception e ) { } finally { context . set <identifiersep> wiki <identifiersep> id ( database ) ; } } string servlet <identifiersep> path = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> , <string_literal> ) ; if ( context . get <identifiersep> request ( ) != null ) { if ( string <identifiersep> utils . is <identifiersep> empty ( servlet <identifiersep> path ) ) { <ect>
synchronized ( this . group <identifiersep> service <identifiersep> lock ) { if ( this . group <identifiersep> service == null ) { string group <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> , <string_literal> ) ; try { this . group <identifiersep> service = ( x <identifiersep> wiki <identifiersep> group <identifiersep> service ) class . for <identifiersep> name ( group <identifiersep> class ) . new <identifiersep> instance ( ) ; <LOG> } catch ( exception e ) { this . group <identifiersep> service = new x <identifiersep> wiki <identifiersep> group <identifiersep> service <identifiersep> impl ( ) ; } this . group <identifiersep> service . init ( this , context ) ; } return this . group <identifiersep> service ; } } public void set <identifiersep> group <identifiersep> service ( x <identifiersep> wiki <identifiersep> group <identifiersep> service group <identifiersep> service ) { <ect>
{ synchronized ( this . auth <identifiersep> service <identifiersep> lock ) { if ( this . auth <identifiersep> service == null ) { logger . info ( <string_literal> ) ; string auth <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> ) ; <LOG> if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> empty ( auth <identifiersep> class ) ) { } } else { if ( is <identifiersep> ldap ( ) ) { auth <identifiersep> class = <string_literal> ; } else { <ect>
if ( cl <identifiersep> manager != null ) { classloader = cl <identifiersep> manager . get <identifiersep> url <identifiersep> class <identifiersep> loader ( <string_literal> , false ) ; } <comment> <LOG> this . auth <identifiersep> service = ( x <identifiersep> wiki <identifiersep> auth <identifiersep> service ) class . for <identifiersep> name ( auth <identifiersep> class ) . new <identifiersep> instance ( ) ; } } catch ( exception e ) { logger . warn ( <string_literal> + auth <identifiersep> class + <string_literal> , e ) ; this . auth <identifiersep> service = new x <identifiersep> wiki <identifiersep> auth <identifiersep> service <identifiersep> impl ( ) ; <ect>
{ synchronized ( this . right <identifiersep> service <identifiersep> lock ) { if ( this . right <identifiersep> service == null ) { logger . info ( <string_literal> ) ; string rights <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> ) ; <LOG> if ( rights <identifiersep> class != null && ! rights <identifiersep> class . equals ( default <identifiersep> right <identifiersep> service <identifiersep> class ) ) { } } else { rights <identifiersep> class = default <identifiersep> right <identifiersep> service <identifiersep> class ; logger . debug ( <string_literal> , rights <identifiersep> class ) ; } } try { <ect>
logger . warn ( <string_literal> , rights <identifiersep> class ) ; } } else { rights <identifiersep> class = default <identifiersep> right <identifiersep> service <identifiersep> class ; logger . debug ( <string_literal> , rights <identifiersep> class ) ; } } try { <LOG> this . right <identifiersep> service = ( x <identifiersep> wiki <identifiersep> right <identifiersep> service ) class . for <identifiersep> name ( rights <identifiersep> class ) . new <identifiersep> instance ( ) ; } catch ( exception e ) { exception last <identifiersep> exception = e ; if ( ! rights <identifiersep> class . equals ( default <identifiersep> right <identifiersep> service <identifiersep> class ) ) { logger . warn ( string . format ( <string_literal> <ect>
this . stats <identifiersep> service . init ( context ) ; } } return this . stats <identifiersep> service ; } } public x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service get <identifiersep> url <identifiersep> factory <identifiersep> service ( ) { if ( this . url <identifiersep> factory <identifiersep> service == null ) { synchronized ( this . urlfactory <identifiersep> service <identifiersep> lock ) { <LOG> if ( this . url <identifiersep> factory <identifiersep> service == null ) { x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service factory <identifiersep> service = null ; string url <identifiersep> factory <identifiersep> service <identifiersep> class = get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> ) ; if ( url <identifiersep> factory <identifiersep> service <identifiersep> class != null ) { try { <ect>
try { logger . debug ( <string_literal> + url <identifiersep> factory <identifiersep> service <identifiersep> class + <string_literal> ) ; } factory <identifiersep> service = ( x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service ) class . for <identifiersep> name ( url <identifiersep> factory <identifiersep> service <identifiersep> class ) . get <identifiersep> constructor ( new class < ? > [ ] { x <identifiersep> wiki . class } ) . new <identifiersep> instance ( new object [ ] { this } ) ; } catch ( exception e ) { <LOG> factory <identifiersep> service = null ; } } if ( factory <identifiersep> service == null ) { logger . debug ( <string_literal> + url <identifiersep> factory <identifiersep> service <identifiersep> class + <string_literal> ) ; } factory <identifiersep> service = new x <identifiersep> wiki <identifiersep> url <identifiersep> factory <identifiersep> service <identifiersep> impl ( this ) ; } <comment> <ect>
public string evaluate <identifiersep> velocity ( string content , string name ) { try { velocity <identifiersep> manager velocity <identifiersep> manager = utils . get <identifiersep> component ( velocity <identifiersep> manager . class ) ; velocity <identifiersep> context velocity <identifiersep> context = velocity <identifiersep> manager . get <identifiersep> velocity <identifiersep> context ( ) ; return evaluate <identifiersep> velocity ( content , name , velocity <identifiersep> context ) ; <LOG> } catch ( exception e ) { object [ ] args = { name } ; x <identifiersep> wiki <identifiersep> exception xe = new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> rendering <identifiersep> velocity <identifiersep> exception , <string_literal> , e , args ) ; return util . get <identifiersep> html <identifiersep> exception <identifiersep> message ( xe , null ) ; <ect>
list = context . get <identifiersep> util ( ) . get <identifiersep> unique <identifiersep> matches ( content , pattern , <number_literal> ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { string name = list . get ( i ) ; if ( name . index <identifiersep> of ( ' . ' ) == - 1 ) { list . set ( i , default <identifiersep> space + <string_literal> + name ) ; } } } catch ( exception e ) { <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
continue ; } if ( ! string <identifiersep> utils . equals ( old <identifiersep> attachment . get <identifiersep> version ( ) , equivalent <identifiersep> attachment . get <identifiersep> version ( ) ) ) { <comment> <LOG> if ( rolledback <identifiersep> doc . get <identifiersep> attachment ( attachment . get <identifiersep> filename ( ) ) == null ) { <comment> <ect>
<comment> <LOG> } catch ( exception e ) { } return super . create <identifiersep> skin <identifiersep> url ( filename , skin , context ) ; } @ override public url create <identifiersep> skin <identifiersep> url ( string filename , string spaces , string name , x <identifiersep> wiki <identifiersep> context context ) { return create <identifiersep> skin <identifiersep> url ( filename , spaces , name , null , context , false ) ; <ect>
string <identifiersep> builder new <identifiersep> path = new string <identifiersep> builder ( <string_literal> ) ; <comment> <LOG> } catch ( exception e ) { } return super . create <identifiersep> resource <identifiersep> url ( filename , force <identifiersep> skin <identifiersep> action , context ) ; } @ override public url create <identifiersep> url ( string spaces , string name , string action , string querystring , string anchor , string xwikidb , x <identifiersep> wiki <identifiersep> context context ) { <ect>
@ override public url create <identifiersep> attachment <identifiersep> url ( string filename , string spaces , string name , string action , string querystring , string xwikidb , x <identifiersep> wiki <identifiersep> context context ) { try { return create <identifiersep> attachment <identifiersep> url ( filename , spaces , name , xwikidb , context ) ; <LOG> } catch ( exception e ) { return super . create <identifiersep> attachment <identifiersep> url ( filename , spaces , name , action , null , xwikidb , context ) ; } } @ override public url create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( string filename , string spaces , string name , string revision , string xwikidb , x <identifiersep> wiki <identifiersep> context context ) { <ect>
enumeration < string > parameter <identifiersep> names = hrequest . get <identifiersep> parameter <identifiersep> names ( ) ; while ( parameter <identifiersep> names . has <identifiersep> more <identifiersep> elements ( ) ) { string parameter = parameter <identifiersep> names . next <identifiersep> element ( ) ; if ( parameter . starts <identifiersep> with ( action <identifiersep> prefix ) ) { string target <identifiersep> url = get <identifiersep> target <identifiersep> url ( hrequest , parameter ) ; request <identifiersep> dispatcher dispatcher = hrequest . get <identifiersep> request <identifiersep> dispatcher ( target <identifiersep> url ) ; <LOG> if ( dispatcher != null ) { request . set <identifiersep> attribute ( attribute <identifiersep> action <identifiersep> dispatched , <string_literal> ) ; dispatcher . forward ( hrequest , response ) ; <comment> <ect>
<comment> public boolean render <identifiersep> file <identifiersep> from <identifiersep> object <identifiersep> field ( string filename , x <identifiersep> wiki <identifiersep> document doc , final x <identifiersep> wiki <identifiersep> context context ) throws io <identifiersep> exception <LOG> { base <identifiersep> object object = doc . get <identifiersep> object ( <string_literal> ) ; string content = null ; if ( object != null ) { content = object . get <identifiersep> string <identifiersep> value ( filename ) ; } if ( ! string <identifiersep> utils . is <identifiersep> blank ( content ) ) { <ect>
<comment> public boolean render <identifiersep> file <identifiersep> from <identifiersep> attachment ( string filename , x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws io <identifiersep> exception , x <identifiersep> wiki <identifiersep> exception <LOG> { x <identifiersep> wiki <identifiersep> attachment attachment = doc . get <identifiersep> attachment ( filename ) ; if ( attachment != null ) { x <identifiersep> wiki xwiki = context . get <identifiersep> wiki ( ) ; x <identifiersep> wiki <identifiersep> response response = context . get <identifiersep> response ( ) ; <comment> <ect>
. or <identifiersep> else ( 0 ) ; } ) . reversed ( ) ) ; this . recommended <identifiersep> template <identifiersep> providers = recommended <identifiersep> templates . stream ( ) . map ( recommended <identifiersep> template - > new document ( recommended <identifiersep> template , context ) ) . collect ( collectors . to <identifiersep> list ( ) ) ; <comment> <LOG> } catch ( exception e ) { } return templates ; } private document <identifiersep> reference <identifiersep> resolver < string > get <identifiersep> current <identifiersep> mixed <identifiersep> resolver ( ) { <comment> <ect>
public properties get <identifiersep> document <identifiersep> bundle <identifiersep> properties ( x <identifiersep> wiki <identifiersep> document doc <identifiersep> bundle ) { properties props = new properties ( ) ; string content = doc <identifiersep> bundle . get <identifiersep> content ( ) ; try { props . load ( new string <identifiersep> reader ( content ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { } return props ; } <comment> <ect>
if ( image == null ) { return <string_literal> ; } response . set <identifiersep> content <identifiersep> length ( image . get <identifiersep> data ( ) . length ) ; response . set <identifiersep> content <identifiersep> type ( image . get <identifiersep> mime <identifiersep> type ( ) ) ; try { response . get <identifiersep> output <identifiersep> stream ( ) . write ( image . get <identifiersep> data ( ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { } return null ; } } <ect>
om . notify ( event , context . get <identifiersep> doc ( ) , context ) ; event <identifiersep> sent = true ; if ( event . is <identifiersep> canceled ( ) ) { <comment> <LOG> } catch ( throwable ex ) { + <string_literal> + context . get <identifiersep> action ( ) + <string_literal> , ex ) ; } if ( monitor != null ) { monitor . end <identifiersep> timer ( <string_literal> ) ; } <comment> <ect>
e = new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> app , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <string_literal> , e ) ; } try { x <identifiersep> wiki <identifiersep> exception xex = ( x <identifiersep> wiki <identifiersep> exception ) e ; if ( xex . get <identifiersep> code ( ) == x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> app <identifiersep> send <identifiersep> response <identifiersep> exception ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> if ( ex . get <identifiersep> code ( ) == x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> app <identifiersep> send <identifiersep> response <identifiersep> exception ) { } } catch ( exception e2 ) { <comment> <ect>
return null ; } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { if ( ex . get <identifiersep> code ( ) == x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> app <identifiersep> send <identifiersep> response <identifiersep> exception ) { logger . error ( <string_literal> ) ; } } catch ( exception e2 ) { <comment> <LOG> logger . error ( <string_literal> , e ) ; } return null ; } finally { <comment> <ect>
x <identifiersep> wiki <identifiersep> request request = context . get <identifiersep> request ( ) ; x <identifiersep> wiki xwiki = context . get <identifiersep> wiki ( ) ; string sindex = request . get <identifiersep> parameter ( id <identifiersep> parameter ) ; try { long index = long . parse <identifiersep> long ( sindex ) ; result = xwiki . get <identifiersep> deleted <identifiersep> document ( index , context ) ; <LOG> } catch ( exception e ) { } return result ; } private boolean restore <identifiersep> document ( x <identifiersep> wiki <identifiersep> deleted <identifiersep> document deleted <identifiersep> document , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { job restore <identifiersep> job = start <identifiersep> restore <identifiersep> job ( deleted <identifiersep> document , context ) ; <comment> <ect>
save <identifiersep> action sa = new save <identifiersep> action ( ) ; if ( sa . save ( context ) ) { if ( is <identifiersep> ajax <identifiersep> request ) { string error <identifiersep> message = localize <identifiersep> plain <identifiersep> or <identifiersep> key ( <string_literal> ) ; <comment> <LOG> <comment> <ect>
int captcha = config <identifiersep> doc . get <identifiersep> int <identifiersep> value ( class <identifiersep> reference , <string_literal> ) ; if ( captcha == 1 ) { try { if ( ! verifier . is <identifiersep> answer <identifiersep> correct ( verifier . get <identifiersep> user <identifiersep> id ( request ) , request . get ( <string_literal> ) ) ) { logger . warn ( <string_literal> ) ; return false ; } <LOG> } catch ( exception e ) { return false ; } } return true ; } } <ect>
try { logger . debug ( <string_literal> + url <identifiersep> factory <identifiersep> class <identifiersep> name + <string_literal> ) ; @ suppress <identifiersep> warnings ( <string_literal> ) class < ? extends x <identifiersep> wiki <identifiersep> url <identifiersep> factory > url <identifiersep> factory <identifiersep> class = ( class < ? extends x <identifiersep> wiki <identifiersep> url <identifiersep> factory > ) class . for <identifiersep> name ( url <identifiersep> factory <identifiersep> class <identifiersep> name ) ; this . factory <identifiersep> map . put ( mode , url <identifiersep> factory <identifiersep> class ) ; <LOG> } catch ( exception e ) { } } } @ override public x <identifiersep> wiki <identifiersep> url <identifiersep> factory create <identifiersep> url <identifiersep> factory ( int mode , x <identifiersep> wiki <identifiersep> context context ) { x <identifiersep> wiki <identifiersep> url <identifiersep> factory urlf = null ; try { <ect>
action = <string_literal> ; } else { long arb <identifiersep> id = find <identifiersep> deleted <identifiersep> attachment <identifiersep> for <identifiersep> doc <identifiersep> revision ( context . get <identifiersep> doc ( ) , doc <identifiersep> revision , filename , context ) ; return create <identifiersep> attachment <identifiersep> revision <identifiersep> url ( filename , spaces , name , attachment . get <identifiersep> version ( ) , arb <identifiersep> id , querystring , xwikidb , context ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { } } } string <identifiersep> builder path = new string <identifiersep> builder ( this . context <identifiersep> path ) ; add <identifiersep> servlet <identifiersep> path ( path , xwikidb , context ) ; <comment> <ect>
try { final url servurl = get <identifiersep> server <identifiersep> url ( context ) ; <comment> <LOG> <comment> <ect>
wrong <identifiersep> file <identifiersep> names . add ( fileupload . get <identifiersep> file <identifiersep> name ( field <identifiersep> name , context ) ) ; } } for ( entry < string , string > file : file <identifiersep> names . entry <identifiersep> set ( ) ) { try { upload <identifiersep> attachment ( file . get <identifiersep> value ( ) , file . get <identifiersep> key ( ) , fileupload , doc , context ) ; } catch ( exception ex ) { logger . warn ( <string_literal> , ex ) ; <LOG> failed <identifiersep> files . put ( file . get <identifiersep> key ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( ex ) ) ; } } logger . debug ( <string_literal> + failed <identifiersep> files ) ; logger . debug ( <string_literal> + wrong <identifiersep> file <identifiersep> names ) ; if ( ajax ) { try { response . get <identifiersep> output <identifiersep> stream ( ) . println ( <string_literal> ) ; <ect>
try { upload <identifiersep> attachment ( file . get <identifiersep> value ( ) , file . get <identifiersep> key ( ) , fileupload , doc , context ) ; } catch ( exception ex ) { logger . warn ( <string_literal> , ex ) ; failed <identifiersep> files . put ( file . get <identifiersep> key ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( ex ) ) ; } } logger . debug ( <string_literal> + file <identifiersep> names ) ; <LOG> logger . debug ( <string_literal> + failed <identifiersep> files ) ; if ( ajax ) { try { response . get <identifiersep> output <identifiersep> stream ( ) . println ( <string_literal> ) ; } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; <ect>
@ override public void send <identifiersep> redirect ( string redirect ) throws io <identifiersep> exception { if ( string <identifiersep> utils . is <identifiersep> blank ( redirect ) ) { <comment> <LOG> if ( string <identifiersep> utils . contains <identifiersep> any ( redirect , ' \\ r' , ' \\ n' ) ) { return ; } this . http <identifiersep> status = sc <identifiersep> found ; this . response . send <identifiersep> redirect ( redirect ) ; } @ override public void set <identifiersep> content <identifiersep> type ( string type ) <ect>
if ( xreturn != null && xreturn instanceof iterable ) { set < string > target = new hash <identifiersep> set < > ( ) ; for ( object o : ( iterable ) xreturn ) { if ( o instanceof string ) { target . add ( ( string ) o ) ; } } return target ; } <LOG> } catch ( exception e ) { } <comment> <ect>
map < string , object > json <identifiersep> map = new hash <identifiersep> map < > ( ) ; database <identifiersep> meta <identifiersep> data meta <identifiersep> data ; try { meta <identifiersep> data = get <identifiersep> database <identifiersep> meta <identifiersep> data ( ) ; } catch ( exception e ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
{ long size = 0 ; try { get <identifiersep> query ( ) ; for ( string wiki <identifiersep> name : get <identifiersep> wikis ( ) ) { size += ( long ) count <identifiersep> query . set <identifiersep> wiki ( wiki <identifiersep> name ) . execute ( ) . get ( 0 ) ; } <LOG> } catch ( query <identifiersep> exception e ) { } return size ; } <comment> <ect>
private list < string > get <identifiersep> wikis ( ) { if ( root <identifiersep> reference == null ) { list < string > wikis ; try { wikis = new array <identifiersep> list < string > ( wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> all <identifiersep> ids ( ) ) ; <LOG> } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { wikis = collections . empty <identifiersep> list ( ) ; } return wikis ; } else { return arrays . as <identifiersep> list ( root <identifiersep> reference . extract <identifiersep> reference ( entity <identifiersep> type . wiki ) . get <identifiersep> name ( ) ) ; } } } <ect>
<comment> @ inject protected logger logger ; @ override public void add ( solr <identifiersep> input <identifiersep> document solr <identifiersep> document ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception <LOG> { this . server . add ( solr <identifiersep> document ) ; } @ override public void add ( list < solr <identifiersep> input <identifiersep> document > solr <identifiersep> documents ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , solr <identifiersep> documents ) ; <ect>
public void add ( list < solr <identifiersep> input <identifiersep> document > solr <identifiersep> documents ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , solr <identifiersep> documents ) ; this . server . add ( solr <identifiersep> documents ) ; } @ override public void delete ( string id ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception <LOG> { this . server . delete <identifiersep> by <identifiersep> id ( id ) ; } @ override public void delete ( list < string > ids ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , ids ) ; <ect>
public void delete ( list < string > ids ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , ids ) ; this . server . delete <identifiersep> by <identifiersep> id ( ids ) ; } @ override public void delete <identifiersep> by <identifiersep> query ( string query ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception <LOG> { this . server . delete <identifiersep> by <identifiersep> query ( query ) ; } @ override public void commit ( ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> ) ; <ect>
public void commit ( ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> ) ; this . server . commit ( ) ; } @ override public void rollback ( ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception <LOG> { this . server . rollback ( ) ; } @ override public query <identifiersep> response query ( solr <identifiersep> params solr <identifiersep> params ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception { this . logger . debug ( <string_literal> , solr <identifiersep> params ) ; <ect>
{ this . logger . debug ( <string_literal> , solr <identifiersep> params ) ; return this . server . query ( solr <identifiersep> params ) ; } @ override public query <identifiersep> response query <identifiersep> and <identifiersep> stream <identifiersep> response ( solr <identifiersep> params params , streaming <identifiersep> response <identifiersep> callback callback ) throws solr <identifiersep> server <identifiersep> exception , io <identifiersep> exception <LOG> { return this . server . query <identifiersep> and <identifiersep> stream <identifiersep> response ( params , callback ) ; } <comment> <ect>
public void initialize ( ) throws initialization <identifiersep> exception { string solr <identifiersep> home = determine <identifiersep> home <identifiersep> directory ( ) ; try { <comment> <LOG> <comment> <ect>
this . logger . info ( <string_literal> ) ; this . logger . info ( <string_literal> , solr <identifiersep> home ) ; <comment> <LOG> this . server = new embedded <identifiersep> solr <identifiersep> server ( container , core <identifiersep> name ) ; } catch ( exception e ) { throw new initialization <identifiersep> exception ( string . format ( <string_literal> , solr <identifiersep> home ) , e ) ; } } private core <identifiersep> container create <identifiersep> core <identifiersep> container ( string solr <identifiersep> home ) throws solr <identifiersep> server <identifiersep> exception { <ect>
@ override public void stream <identifiersep> doc <identifiersep> list <identifiersep> info ( long num <identifiersep> found , long start , float max <identifiersep> score ) { <comment> <LOG> } catch ( exception e ) { } } <comment> private set < locale > get <identifiersep> parent <identifiersep> locales ( locale locale ) <ect>
{ logger . debug ( <string_literal> ) ; while ( ! thread . interrupted ( ) ) { resolve <identifiersep> queue <identifiersep> entry queue <identifiersep> entry ; try { queue <identifiersep> entry = resolve <identifiersep> queue . take ( ) ; <LOG> } catch ( interrupted <identifiersep> exception e ) { queue <identifiersep> entry = resolve <identifiersep> queue <identifiersep> entry <identifiersep> stop ; } if ( queue <identifiersep> entry == resolve <identifiersep> queue <identifiersep> entry <identifiersep> stop ) { <comment> <ect>
<comment> <LOG> { while ( ! thread . interrupted ( ) ) { <comment> <ect>
} catch ( interrupted <identifiersep> exception e ) { this . logger . warn ( <string_literal> , e ) ; queue <identifiersep> entry = index <identifiersep> queue <identifiersep> entry <identifiersep> stop ; } <comment> <LOG> break ; } } } <comment> <ect>
solr <identifiersep> document . set <identifiersep> field ( field <identifiersep> utils . attachment <identifiersep> author , author <identifiersep> string <identifiersep> reference ) ; try { <comment> <LOG> } catch ( exception e ) { } set <identifiersep> locale <identifiersep> and <identifiersep> content <identifiersep> fields ( attachment , solr <identifiersep> document ) ; return true ; } <comment> <ect>
if ( this . configuration . synchronize <identifiersep> at <identifiersep> startup ( ) ) { <comment> <LOG> } catch ( solr <identifiersep> indexer <identifiersep> exception e ) { } } } } <ect>
{ if ( current <identifiersep> iterator == null || ! current <identifiersep> iterator . has <identifiersep> next ( ) ) { if ( current <identifiersep> wiki . has <identifiersep> next ( ) ) { string wiki = current <identifiersep> wiki . next ( ) ; try { current <identifiersep> iterator = get <identifiersep> references ( new wiki <identifiersep> reference ( wiki ) ) . iterator ( ) ; <LOG> } catch ( solr <identifiersep> indexer <identifiersep> exception e ) { } if ( ! current <identifiersep> iterator . has <identifiersep> next ( ) ) { update ( ) ; } } else { current <identifiersep> iterator = null ; } } } } <comment> <ect>
{ list < x <identifiersep> wiki <identifiersep> attachment > attachments = document . get <identifiersep> attachment <identifiersep> list ( ) ; for ( x <identifiersep> wiki <identifiersep> attachment attachment : attachments ) { attachment <identifiersep> reference attachment <identifiersep> reference = attachment . get <identifiersep> reference ( ) ; try { iterables . add <identifiersep> all ( result , this . attachment <identifiersep> resolver <identifiersep> provider . get ( ) . get <identifiersep> references ( attachment <identifiersep> reference ) ) ; <LOG> } catch ( exception e ) { } } } <comment> private void add <identifiersep> objects <identifiersep> references ( x <identifiersep> wiki <identifiersep> document document , list < entity <identifiersep> reference > result ) <ect>
results . remove ( result ) ; <comment> <LOG> } catch ( exception e ) { } } <comment> <ect>
os . flush ( ) ; } private boolean rasterize <identifiersep> to <identifiersep> file ( string content , file out , int width , int height ) throws io <identifiersep> exception { if ( ! out . get <identifiersep> parent <identifiersep> file ( ) . exists ( ) && ! out . get <identifiersep> parent <identifiersep> file ( ) . mkdirs ( ) ) { this . logger . debug ( <string_literal> , out . get <identifiersep> parent <identifiersep> file ( ) . get <identifiersep> absolute <identifiersep> path ( ) ) ; return false ; <LOG> } else if ( out . exists ( ) && out . is <identifiersep> file ( ) ) { return true ; } else { try ( output <identifiersep> stream fout = new file <identifiersep> output <identifiersep> stream ( out ) ) { this . logger . debug ( <string_literal> , out . get <identifiersep> absolute <identifiersep> path ( ) ) ; transcoder <identifiersep> input input = new transcoder <identifiersep> input ( new string <identifiersep> reader ( content ) ) ; <ect>
<comment> <LOG> } catch ( transcoder <identifiersep> exception ex ) { } return false ; } private string get <identifiersep> temporary <identifiersep> file <identifiersep> name ( string content , int width , int height ) { return math . abs ( content . hash <identifiersep> code ( ) ) + raster <identifiersep> file <identifiersep> extension ; } private document <identifiersep> reference get <identifiersep> current <identifiersep> document ( ) <ect>
string title = raw <identifiersep> title ; <comment> <LOG> } catch ( exception e ) { } } <comment> <ect>
<comment> private void maybe <identifiersep> open <identifiersep> name <identifiersep> space ( string name <identifiersep> space , boolean transformation <identifiersep> context <identifiersep> isolated , object is <identifiersep> in <identifiersep> rendering <identifiersep> engine ) { if ( transformation <identifiersep> context <identifiersep> isolated && ( is <identifiersep> in <identifiersep> rendering <identifiersep> engine == null || is <identifiersep> in <identifiersep> rendering <identifiersep> engine == boolean . false ) ) { try { <comment> <LOG> velocity <identifiersep> manager . get <identifiersep> velocity <identifiersep> engine ( ) . started <identifiersep> using <identifiersep> macro <identifiersep> namespace ( name <identifiersep> space ) ; } catch ( exception e ) { <comment> <ect>
if ( parameters . is <identifiersep> title <identifiersep> displayed ( ) ) { displayer = this . title <identifiersep> displayer ; string title <identifiersep> hint = <string_literal> + syntax <identifiersep> id ; if ( this . component <identifiersep> manager . has <identifiersep> component ( document <identifiersep> displayer . class , title <identifiersep> hint ) ) { try { displayer = this . component <identifiersep> manager . get <identifiersep> instance ( document <identifiersep> displayer . class , title <identifiersep> hint ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } } else { displayer = this . content <identifiersep> displayer ; string content <identifiersep> hint = <string_literal> + syntax <identifiersep> id ; if ( this . component <identifiersep> manager . has <identifiersep> component ( document <identifiersep> displayer . class , content <identifiersep> hint ) ) { try { <ect>
<comment> private document <identifiersep> displayer get <identifiersep> document <identifiersep> displayer ( ) { string document <identifiersep> displayer <identifiersep> hint = display <identifiersep> configuration . get <identifiersep> document <identifiersep> displayer <identifiersep> hint ( ) ; try { return component <identifiersep> manager . get <identifiersep> instance ( document <identifiersep> displayer . class , document <identifiersep> displayer <identifiersep> hint ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { + <string_literal> , document <identifiersep> displayer <identifiersep> hint , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; try { return component <identifiersep> manager . get <identifiersep> instance ( document <identifiersep> displayer . class ) ; } catch ( component <identifiersep> lookup <identifiersep> exception ex ) { throw new runtime <identifiersep> exception ( <string_literal> , ex ) ; <ect>
<comment> <LOG> string sheet <identifiersep> string <identifiersep> reference = default <identifiersep> entity <identifiersep> reference <identifiersep> serializer . serialize ( sheet <identifiersep> reference ) ; } } } <comment> <ect>
<comment> component <identifiersep> manager component <identifiersep> manager = get <identifiersep> component <identifiersep> manager ( ) ; application <identifiersep> context . get <identifiersep> attributes ( ) . put ( constants . xwiki <identifiersep> component <identifiersep> manager , component <identifiersep> manager ) ; jax <identifiersep> rs <identifiersep> application application ; try { application = component <identifiersep> manager . get <identifiersep> instance ( jax <identifiersep> rs <identifiersep> application . class ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { return null ; } application . set <identifiersep> context ( application <identifiersep> context ) ; <comment> <ect>
field <identifiersep> utils . write <identifiersep> field ( this , <string_literal> , null , true ) ; field <identifiersep> utils . write <identifiersep> field ( this , <string_literal> , null , true ) ; field <identifiersep> utils . write <identifiersep> field ( this , <string_literal> , null , true ) ; get <identifiersep> servlet <identifiersep> context ( ) . remove <identifiersep> attribute ( <string_literal> ) ; get <identifiersep> servlet <identifiersep> context ( ) . remove <identifiersep> attribute ( <string_literal> ) ; get <identifiersep> servlet <identifiersep> context ( ) . remove <identifiersep> attribute ( <string_literal> ) ; <LOG> } catch ( illegal <identifiersep> access <identifiersep> exception e ) { } } @ override public void init ( ) throws servlet <identifiersep> exception { super . init ( ) ; try { <ect>
<comment> @ override public void initialize ( ) throws initialization <identifiersep> exception { logger = java . util . logging . logger . get <identifiersep> logger ( this . get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; <LOG> object <identifiersep> factory = new object <identifiersep> factory ( ) ; utils . get <identifiersep> x <identifiersep> wiki <identifiersep> user ( component <identifiersep> manager ) ) ; } <comment> <ect>
if ( less <identifiersep> context . is <identifiersep> html <identifiersep> export ( ) && use <identifiersep> velocity && this instanceof default <identifiersep> less <identifiersep> compiler ) { compiler . compute ( less <identifiersep> resource <identifiersep> reference , include <identifiersep> skin <identifiersep> style , true , false , skin ) ; } return clone <identifiersep> result ( result ) ; } } <comment> <LOG> } catch ( less <identifiersep> compiler <identifiersep> exception e ) { <comment> <ect>
try { x <identifiersep> wiki <identifiersep> document document = this . context . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> name , this . context ) ; if ( this . context . get <identifiersep> wiki ( ) . check <identifiersep> access ( tag <identifiersep> access <identifiersep> right , document , this . context ) ) { result = this . get <identifiersep> protected <identifiersep> plugin ( ) . add <identifiersep> tag <identifiersep> to <identifiersep> document ( tag , document , this . context ) ; } else { result = tag <identifiersep> operation <identifiersep> result . not <identifiersep> allowed ; } <LOG> } catch ( exception ex ) { result = tag <identifiersep> operation <identifiersep> result . failed ; } return result ; } <comment> <ect>
throw new remote <identifiersep> event <identifiersep> exception ( <string_literal> + channel <identifiersep> id + <string_literal> , e ) ; } <comment> <LOG> this . logger . warn ( <string_literal> + channel <identifiersep> id + <string_literal> , e ) ; } } @ override public void stop <identifiersep> channel ( string channel <identifiersep> id ) throws remote <identifiersep> event <identifiersep> exception { j <identifiersep> channel channel = this . channels . get ( channel <identifiersep> id ) ; if ( channel == null ) { <ect>
this . channels . remove ( channel <identifiersep> id ) ; <comment> <LOG> this . logger . warn ( <string_literal> + channel <identifiersep> id + <string_literal> , e ) ; } } <comment> <ect>
return xml <identifiersep> configurator . get <identifiersep> instance ( is ) ; } @ override public void stop <identifiersep> all <identifiersep> channels ( ) throws remote <identifiersep> event <identifiersep> exception { for ( map . entry < string , j <identifiersep> channel > channel <identifiersep> entry : this . channels . entry <identifiersep> set ( ) ) { channel <identifiersep> entry . get <identifiersep> value ( ) . close ( ) ; } <LOG> this . channels . clear ( ) ; } } <ect>
} catch ( component <identifiersep> lookup <identifiersep> exception e ) { this . logger . error ( <string_literal> , e ) ; } } return this . remote <identifiersep> observation <identifiersep> manager ; } @ override public void receive ( message msg ) { <LOG> remote <identifiersep> event <identifiersep> data remote <identifiersep> event = ( remote <identifiersep> event <identifiersep> data ) msg . get <identifiersep> object ( ) ; get <identifiersep> remote <identifiersep> observation <identifiersep> manager ( ) . notify ( remote <identifiersep> event ) ; } } <ect>
<comment> <LOG> } catch ( remote <identifiersep> event <identifiersep> exception e ) { } } } @ override public void notify ( remote <identifiersep> event <identifiersep> data remote <identifiersep> event ) { <comment> <ect>
properties . set <identifiersep> property ( <string_literal> , <string_literal> ) ; properties . set <identifiersep> property ( <string_literal> , channel <identifiersep> name ) ; executor . save <identifiersep> x <identifiersep> wiki <identifiersep> properties ( ) ; <comment> <LOG> { if ( executor . get <identifiersep> execution <identifiersep> directory ( ) != null ) { properties <identifiersep> configuration properties = executor . load <identifiersep> x <identifiersep> wiki <identifiersep> properties <identifiersep> configuration ( ) ; <comment> <ect>
this . execution . get <identifiersep> context ( ) . set <identifiersep> property ( abstract <identifiersep> event <identifiersep> stream <identifiersep> event . event <identifiersep> loop <identifiersep> context <identifiersep> lock <identifiersep> property , true ) ; <comment> <LOG> } catch ( exception e ) { } } <comment> private org . xwiki . eventstream . event convert <identifiersep> event ( event event , object source , object data ) throws exception { <ect>
public list < object [ ] > search <identifiersep> unique <identifiersep> pages ( string optional <identifiersep> where <identifiersep> clause , list < object > parameters <identifiersep> values , int max <identifiersep> items , int start <identifiersep> at ) { try { return get <identifiersep> activity <identifiersep> stream ( ) . search <identifiersep> unique <identifiersep> pages ( optional <identifiersep> where <identifiersep> clause , parameters <identifiersep> values , max <identifiersep> items , start <identifiersep> at , this . context ) ; <LOG> } catch ( activity <identifiersep> stream <identifiersep> exception ex ) { return collections . empty <identifiersep> list ( ) ; } } <comment> <ect>
public list < object [ ] > search <identifiersep> daily <identifiersep> pages ( string optional <identifiersep> where <identifiersep> clause , list < object > parameters <identifiersep> values , int max <identifiersep> items , int start <identifiersep> at ) { try { return get <identifiersep> activity <identifiersep> stream ( ) . search <identifiersep> daily <identifiersep> pages ( optional <identifiersep> where <identifiersep> clause , parameters <identifiersep> values , max <identifiersep> items , start <identifiersep> at , this . context ) ; <LOG> } catch ( activity <identifiersep> stream <identifiersep> exception ex ) { return collections . empty <identifiersep> list ( ) ; } } } <ect>
for ( mail <identifiersep> status status : statuses ) { try { results . add ( new immutable <identifiersep> pair < > ( status , resend <identifiersep> asynchronously ( status . get <identifiersep> batch <identifiersep> id ( ) , status . get <identifiersep> message <identifiersep> id ( ) ) ) ) ; } catch ( mail <identifiersep> store <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
return mail <identifiersep> status <identifiersep> result ; } private void save <identifiersep> status ( mail <identifiersep> status status , map < string , object > parameters ) { try { mail <identifiersep> status <identifiersep> store . save ( status , parameters ) ; } catch ( mail <identifiersep> store <identifiersep> exception e ) { <LOG> <comment> <ect>
private void delete <identifiersep> mail <identifiersep> content ( mail <identifiersep> status current <identifiersep> status ) { if ( current <identifiersep> status != null ) { try { mail <identifiersep> content <identifiersep> store . delete ( current <identifiersep> status . get <identifiersep> batch <identifiersep> id ( ) , current <identifiersep> status . get <identifiersep> message <identifiersep> id ( ) ) ; } catch ( mail <identifiersep> store <identifiersep> exception e ) { <LOG> <comment> <ect>
return collections . empty <identifiersep> iterator ( ) ; } try { map < string , object > filter <identifiersep> map = new hash <identifiersep> map < > ( ) ; filter <identifiersep> map . put ( batchid <identifiersep> key , this . batch <identifiersep> id ) ; filter <identifiersep> map . put ( <string_literal> , state ) ; return this . mail <identifiersep> status <identifiersep> store . load ( filter <identifiersep> map , 0 , 0 , date <identifiersep> field , true ) . iterator ( ) ; <LOG> } catch ( mail <identifiersep> store <identifiersep> exception e ) { return collections . empty <identifiersep> iterator ( ) ; } } } <ect>
query . set <identifiersep> properties ( filter <identifiersep> map ) ; list < mail <identifiersep> status > query <identifiersep> result = ( list < mail <identifiersep> status > ) query . list ( ) ; return query <identifiersep> result ; } } ) ; <comment> <LOG> for ( mail <identifiersep> status mail <identifiersep> status : mail <identifiersep> statuses ) { } } return mail <identifiersep> statuses ; } catch ( exception e ) { throw new mail <identifiersep> store <identifiersep> exception ( string . format ( <string_literal> , filter <identifiersep> map ) , e ) ; } finally { <ect>
return batch <identifiersep> id ; } @ override public void on <identifiersep> prepare <identifiersep> begin ( string batch <identifiersep> id , map < string , object > parameters ) { if ( this . batch <identifiersep> id != null ) { throw new runtime <identifiersep> exception ( <string_literal> <LOG> + this . batch <identifiersep> id + <string_literal> + batch <identifiersep> id + <string_literal> ) ; } this . batch <identifiersep> id = batch <identifiersep> id ; } @ override public void on <identifiersep> prepare <identifiersep> message <identifiersep> success ( extended <identifiersep> mime <identifiersep> message message , map < string , object > parameters ) { <ect>
@ override public void on <identifiersep> prepare <identifiersep> fatal <identifiersep> error ( exception exception , map < string , object > parameters ) { logger . debug ( <string_literal> + batch <identifiersep> id + <string_literal> ) ; } @ override public void on <identifiersep> prepare <identifiersep> end ( map < string , object > parameters ) <LOG> { } @ override public void on <identifiersep> send <identifiersep> message <identifiersep> success ( extended <identifiersep> mime <identifiersep> message message , map < string , object > parameters ) { logger . debug ( <string_literal> , <ect>
<comment> <LOG> <comment> <ect>
thread . sleep ( 50l ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
thread . sleep ( 100l ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> <comment> <ect>
transformation <identifiersep> context transformation <identifiersep> context = new transformation <identifiersep> context ( transformed <identifiersep> xdom , syntax ) ; transformation <identifiersep> context . set <identifiersep> id ( get <identifiersep> role <identifiersep> hint ( ) ) ; ( ( mutable <identifiersep> rendering <identifiersep> context ) rendering <identifiersep> context ) . transform <identifiersep> in <identifiersep> context ( macro <identifiersep> transformation , transformation <identifiersep> context , transformed <identifiersep> xdom ) ; return null ; } , get <identifiersep> author <identifiersep> reference ( ) ) ; <LOG> } catch ( exception e ) { } finally { this . progress . end <identifiersep> step ( get <identifiersep> document <identifiersep> reference ( ) ) ; } return new composite <identifiersep> block ( transformed <identifiersep> xdom . get <identifiersep> children ( ) ) ; } @ override public map < string , string > get <identifiersep> parameters ( ) <ect>
default <identifiersep> extension <identifiersep> plan <identifiersep> tree current <identifiersep> tree = new default <identifiersep> extension <identifiersep> plan <identifiersep> tree ( ) ; try { install <identifiersep> extension ( extension <identifiersep> id , namespace , current <identifiersep> tree ) ; <comment> <LOG> } catch ( install <identifiersep> exception e ) { } return null ; } <comment> <ect>
this . found <identifiersep> flavors . add ( flavor ) ; } } } private extension find <identifiersep> valid <identifiersep> version ( string flavor <identifiersep> id , string namespace ) { iterable <identifiersep> result < version > versions ; try { versions = this . repository <identifiersep> manager . resolve <identifiersep> versions ( flavor <identifiersep> id , 0 , - 1 ) ; <LOG> if ( versions . get <identifiersep> size ( ) == 0 ) { return null ; } list < version > version <identifiersep> list = new array <identifiersep> list < version > ( versions . get <identifiersep> size ( ) ) ; for ( version version : versions ) { version <identifiersep> list . add ( version ) ; } return find <identifiersep> valid <identifiersep> version ( flavor <identifiersep> id , namespace , version <identifiersep> list ) ; <ect>
public iterable <identifiersep> result < extension > search <identifiersep> flavors ( flavor <identifiersep> query query ) throws search <identifiersep> exception { iterable <identifiersep> result < extension > result = null ; <comment> <LOG> } catch ( search <identifiersep> exception e ) { } <comment> <ect>
<string_literal> + <string_literal> , query . xwql ) ; <comment> <LOG> x <identifiersep> wiki <identifiersep> document user <identifiersep> document = xwiki . get <identifiersep> document ( user <identifiersep> reference , context ) ; try { migrate <identifiersep> document ( user <identifiersep> document ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . warn ( <string_literal> , result , e ) ; } } <comment> <ect>
logger . warn ( <string_literal> , result , e ) ; } } <comment> <LOG> } catch ( query <identifiersep> exception e ) { } } <comment> <ect>
for ( base <identifiersep> object obj : objects ) { if ( obj == null ) { continue ; } get <identifiersep> values ( obj , field <identifiersep> wikis , notification <identifiersep> filter <identifiersep> property . wiki , results ) ; get <identifiersep> values ( obj , field <identifiersep> spaces , notification <identifiersep> filter <identifiersep> property . space , results ) ; get <identifiersep> values ( obj , field <identifiersep> documents , notification <identifiersep> filter <identifiersep> property . page , results ) ; } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } return results ; } private void get <identifiersep> values ( base <identifiersep> object obj , string field <identifiersep> name , notification <identifiersep> filter <identifiersep> property property , set < notification <identifiersep> filter <identifiersep> preference > results ) { list < string > values = obj . get <identifiersep> list <identifiersep> value ( field <identifiersep> name ) ; <ect>
return notification <identifiersep> filter <identifiersep> manager . get <identifiersep> filter <identifiersep> preferences ( user ) . stream ( ) . filter ( pref - > match <identifiersep> filter ( pref ) && match <identifiersep> format ( pref , format ) && match <identifiersep> filter <identifiersep> type ( pref ) && match <identifiersep> all <identifiersep> events ( pref ) ) ; <LOG> } catch ( exception e ) { return stream . empty ( ) ; } } private boolean match <identifiersep> format ( notification <identifiersep> filter <identifiersep> preference filter <identifiersep> preference , notification <identifiersep> format format ) { return format == null || filter <identifiersep> preference . get <identifiersep> filter <identifiersep> formats ( ) . contains ( format ) ; } private boolean match <identifiersep> filter ( notification <identifiersep> filter <identifiersep> preference pref ) <ect>
{ try { for ( notification <identifiersep> filter <identifiersep> preference <identifiersep> provider provider : component <identifiersep> manager . < notification <identifiersep> filter <identifiersep> preference <identifiersep> provider > get <identifiersep> instance <identifiersep> list ( notification <identifiersep> filter <identifiersep> preference <identifiersep> provider . class ) ) { provider . delete <identifiersep> filter <identifiersep> preference ( filter <identifiersep> preference <identifiersep> name ) ; } <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } @ override public void set <identifiersep> filter <identifiersep> preference <identifiersep> enabled ( string filter <identifiersep> preference <identifiersep> name , boolean enabled ) throws notification <identifiersep> exception { try { <ect>
x <identifiersep> wiki <identifiersep> document user <identifiersep> profile <identifiersep> document = xwiki . get <identifiersep> document ( user <identifiersep> reference , context ) ; document <identifiersep> reference users <identifiersep> class <identifiersep> reference = xwiki . get <identifiersep> user <identifiersep> class ( context ) . get <identifiersep> document <identifiersep> reference ( ) ; string avatar <identifiersep> file <identifiersep> name = user <identifiersep> profile <identifiersep> document . get <identifiersep> string <identifiersep> value ( users <identifiersep> class <identifiersep> reference , <string_literal> ) ; x <identifiersep> wiki <identifiersep> attachment attachment = user <identifiersep> profile <identifiersep> document . get <identifiersep> attachment ( avatar <identifiersep> file <identifiersep> name ) ; if ( attachment != null && attachment . is <identifiersep> image ( context ) ) { return attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( context ) ; } <LOG> } catch ( exception e ) { } } return get <identifiersep> default <identifiersep> avatar <identifiersep> stream ( ) ; } private input <identifiersep> stream get <identifiersep> default <identifiersep> avatar <identifiersep> stream ( ) { return environment . get <identifiersep> resource <identifiersep> as <identifiersep> stream ( <string_literal> ) ; } private void resize <identifiersep> image ( input <identifiersep> stream image <identifiersep> file <identifiersep> input <identifiersep> stream , int size , output <identifiersep> stream output <identifiersep> stream ) throws io <identifiersep> exception <ect>
velocity <identifiersep> variables . put ( sorted <identifiersep> events , events <identifiersep> sorter . sort ( ) ) ; handle <identifiersep> avatars ( ) ; } private void handle <identifiersep> wiki <identifiersep> logo ( ) { try { get <identifiersep> attachments ( ) . add ( logo <identifiersep> attachment <identifiersep> extractor . get <identifiersep> logo ( ) ) ; <LOG> } catch ( exception e ) { } } private collection < attachment > get <identifiersep> attachments ( ) { object attachments = factory <identifiersep> parameters . get ( attachments ) ; if ( attachments != null ) { return ( collection < attachment > ) attachments ; <ect>
<comment> <LOG> } catch ( event <identifiersep> stream <identifiersep> exception e ) { } } } <comment> private synchronized void start <identifiersep> notification <identifiersep> thread ( ) { <comment> <ect>
<comment> public void start ( ) throws exception { if ( ! should <identifiersep> start <identifiersep> xwiki ) { return ; } this . was <identifiersep> started = false ; <LOG> if ( verify <identifiersep> running <identifiersep> xwiki <identifiersep> at <identifiersep> start . equals ( <string_literal> ) ) { <comment> <ect>
if ( verify <identifiersep> running <identifiersep> xwiki <identifiersep> at <identifiersep> start . equals ( <string_literal> ) ) { logger . info ( <string_literal> , get <identifiersep> url ( ) ) ; <comment> <LOG> stop <identifiersep> internal ( ) ; get <identifiersep> stop <identifiersep> port ( ) , get <identifiersep> rmi <identifiersep> port ( ) ) ; start <identifiersep> x <identifiersep> wiki ( ) ; wait <identifiersep> for <identifiersep> x <identifiersep> wiki <identifiersep> to <identifiersep> load ( ) ; this . managed = true ; } else { <ect>
<comment> private void start <identifiersep> x <identifiersep> wiki ( ) throws exception { file dir = new file ( get <identifiersep> execution <identifiersep> directory ( ) ) ; if ( dir . exists ( ) ) { <LOG> string start <identifiersep> command = get <identifiersep> default <identifiersep> start <identifiersep> command ( get <identifiersep> port ( ) , get <identifiersep> stop <identifiersep> port ( ) , get <identifiersep> rmi <identifiersep> port ( ) ) ; this . started <identifiersep> process <identifiersep> handler = execute <identifiersep> command ( start <identifiersep> command ) ; } else { throw new exception ( string . format ( <string_literal> + <string_literal> + <string_literal> <ect>
private void wait <identifiersep> for <identifiersep> process <identifiersep> to <identifiersep> finish ( default <identifiersep> execute <identifiersep> result <identifiersep> handler handler , long timeout ) throws exception { <comment> <LOG> if ( handler . get <identifiersep> exit <identifiersep> value ( ) == <number_literal> ) { } else { string message = string . format ( <string_literal> , timeout , handler . has <identifiersep> result ( ) ) ; if ( handler . has <identifiersep> result ( ) ) { <ect>
} else { <comment> <LOG> } catch ( no <identifiersep> tests <identifiersep> remain <identifiersep> exception e ) { } } } return runners ; } <comment> protected void before <identifiersep> tests ( ) <ect>
current <identifiersep> doc <identifiersep> reference ) ; log <identifiersep> printed = true ; } <comment> <LOG> if ( ! log <identifiersep> printed ) { } context . drop <identifiersep> permissions ( ) ; } else { <comment> <ect>
<comment> public test <identifiersep> debugger ( web <identifiersep> driver driver ) { this . driver = driver ; } @ override protected void starting ( description description ) <LOG> { } @ override protected void succeeded ( description description ) { logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; } @ override <ect>
@ override protected void succeeded ( description description ) { logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; } @ override protected void failed ( throwable e , description description ) <LOG> { take <identifiersep> screenshot ( description ) ; logger . info ( <string_literal> , driver . get <identifiersep> current <identifiersep> url ( ) ) ; logger . info ( <string_literal> , driver . get <identifiersep> page <identifiersep> source ( ) ) ; } <comment> <ect>
logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; } @ override protected void failed ( throwable e , description description ) { logger . info ( <string_literal> , get <identifiersep> test <identifiersep> name ( description ) ) ; take <identifiersep> screenshot ( description ) ; <LOG> logger . info ( <string_literal> , driver . get <identifiersep> current <identifiersep> url ( ) ) ; } <comment> private string get <identifiersep> test <identifiersep> name ( description description ) <ect>
if ( screenshot <identifiersep> dir != null ) { file screenshot <identifiersep> dir = new file ( screenshot <identifiersep> dir ) ; screenshot <identifiersep> dir . mkdirs ( ) ; screenshot <identifiersep> file = new file ( screenshot <identifiersep> dir , test <identifiersep> name + <string_literal> ) ; } else { screenshot <identifiersep> file = new file ( new file ( system . get <identifiersep> property ( <string_literal> ) ) , test <identifiersep> name + <string_literal> ) ; } <LOG> file <identifiersep> utils . copy <identifiersep> file ( source <identifiersep> file , screenshot <identifiersep> file ) ; } catch ( exception e ) { logger . error ( <string_literal> , test <identifiersep> name , e ) ; } } } <ect>
private void recache <identifiersep> secret <identifiersep> token <identifiersep> when <identifiersep> on <identifiersep> register <identifiersep> page ( ) { try { web <identifiersep> element token <identifiersep> input = get <identifiersep> driver ( ) . find <identifiersep> element ( by . xpath ( <string_literal> ) ) ; this . secret <identifiersep> token = token <identifiersep> input . get <identifiersep> attribute ( <string_literal> ) ; } catch ( no <identifiersep> such <identifiersep> element <identifiersep> exception exception ) { <LOG> <comment> <ect>
document <identifiersep> reference user <identifiersep> reference = context <identifiersep> user <identifiersep> reference ; if ( user <identifiersep> reference == null && context . get <identifiersep> mode ( ) != x <identifiersep> wiki <identifiersep> context . mode <identifiersep> xmlrpc ) { try { x <identifiersep> wiki <identifiersep> user user = context . get <identifiersep> wiki ( ) . check <identifiersep> auth ( context ) ; if ( user != null ) { user <identifiersep> reference = resolve <identifiersep> user <identifiersep> name ( user . get <identifiersep> user ( ) , new wiki <identifiersep> reference ( context . get <identifiersep> wiki <identifiersep> id ( ) ) ) ; } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } if ( user <identifiersep> reference != null && x <identifiersep> wiki <identifiersep> constants . guest <identifiersep> user . equals ( user <identifiersep> reference . get <identifiersep> name ( ) ) ) { <comment> <ect>
return false ; } @ override public boolean has <identifiersep> access <identifiersep> level ( string right <identifiersep> name , string username , string docname , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { wiki <identifiersep> reference wiki <identifiersep> reference = new wiki <identifiersep> reference ( context . get <identifiersep> wiki <identifiersep> id ( ) ) ; <LOG> document <identifiersep> reference document = resolve <identifiersep> document <identifiersep> name ( docname , wiki <identifiersep> reference ) ; document <identifiersep> reference user = resolve <identifiersep> user <identifiersep> name ( username , wiki <identifiersep> reference ) ; if ( user != null && x <identifiersep> wiki <identifiersep> constants . guest <identifiersep> user . equals ( user . get <identifiersep> name ( ) ) ) { <comment> <ect>
for ( security <identifiersep> reference ref = entity ; ref != null ; ref = ref . get <identifiersep> parent <identifiersep> security <identifiersep> reference ( ) ) { if ( right . get <identifiersep> enabled <identifiersep> rights ( ref . get <identifiersep> security <identifiersep> type ( ) ) . is <identifiersep> empty ( ) ) { <comment> <LOG> security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; return access ; } if ( ! entry . is <identifiersep> empty ( ) ) { security <identifiersep> access <identifiersep> entry access <identifiersep> entry = security <identifiersep> cache . get ( user , ref ) ; if ( access <identifiersep> entry == null ) { security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; <ect>
security <identifiersep> access <identifiersep> entry access <identifiersep> entry = security <identifiersep> cache . get ( user , ref ) ; if ( access <identifiersep> entry == null ) { security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; logger . debug ( <string_literal> , user , entity , access ) ; return access ; } else { <LOG> security <identifiersep> access access = access <identifiersep> entry . get <identifiersep> access ( ) ; return access ; } } } security <identifiersep> access access = security <identifiersep> cache <identifiersep> loader . load ( user , entity ) . get <identifiersep> access ( ) ; logger . debug ( <string_literal> , user , entity , access ) ; return access ; } <comment> <ect>
<comment> private void log <identifiersep> new <identifiersep> entry ( ) { <LOG> if ( parents == null || parents . size ( ) == 0 ) { return ; } string <identifiersep> builder sb = new string <identifiersep> builder ( <string_literal> ) ; sb . append ( get <identifiersep> key ( ) ) . append ( <string_literal> ) ; boolean first = true ; for ( security <identifiersep> cache <identifiersep> entry parent : parents ) { <ect>
<comment> <LOG> } catch ( throwable e ) { } } } } } } <comment> private void add <identifiersep> child ( security <identifiersep> cache <identifiersep> entry entry ) <ect>
{ string key = get <identifiersep> entry <identifiersep> key ( entry ) ; write <identifiersep> lock . lock ( ) ; try { if ( is <identifiersep> already <identifiersep> inserted ( key , entry , groups ) ) { return ; } <LOG> add <identifiersep> entry ( key , new <identifiersep> security <identifiersep> cache <identifiersep> entry ( entry , groups ) ) ; } finally { write <identifiersep> lock . unlock ( ) ; } } <comment> <ect>
return ( entry != null ) ? entry . get <identifiersep> entry ( ) : null ; } @ override public security <identifiersep> access <identifiersep> entry get ( user <identifiersep> security <identifiersep> reference user , security <identifiersep> reference entity ) { security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( user , entity ) ; <LOG> if ( entry == null ) { } return null ; logger . debug ( <string_literal> , get <identifiersep> entry <identifiersep> key ( user , entity ) ) ; } return ( security <identifiersep> access <identifiersep> entry ) entry . get <identifiersep> entry ( ) ; } @ override <ect>
return ( security <identifiersep> access <identifiersep> entry ) entry . get <identifiersep> entry ( ) ; } @ override public security <identifiersep> rule <identifiersep> entry get ( security <identifiersep> reference entity ) { security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( entity ) ; <LOG> if ( entry == null ) { } return null ; logger . debug ( <string_literal> , get <identifiersep> entry <identifiersep> key ( entity ) ) ; } return ( security <identifiersep> rule <identifiersep> entry ) entry . get <identifiersep> entry ( ) ; } @ override <ect>
extension <identifiersep> object <identifiersep> to <identifiersep> save . set ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . prop <identifiersep> extension <identifiersep> lastversion , last <identifiersep> version , xcontext ) ; need <identifiersep> save = true ; } <comment> <LOG> } else { } int current <identifiersep> value = get <identifiersep> value ( extension <identifiersep> object , x <identifiersep> wiki <identifiersep> repository <identifiersep> model . prop <identifiersep> extension <identifiersep> validextension , 0 ) ; if ( ( current <identifiersep> value == 1 ) != valid ) { base <identifiersep> object extension <identifiersep> object <identifiersep> to <identifiersep> save = document . get <identifiersep> x <identifiersep> object ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extension <identifiersep> classreference ) ; extension <identifiersep> object <identifiersep> to <identifiersep> save . set ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . prop <identifiersep> extension <identifiersep> validextension , valid ? <string_literal> : <string_literal> , xcontext ) ; need <identifiersep> save = true ; <ect>
x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extensionversion <identifiersep> classreference , extension <identifiersep> version <identifiersep> object . get <identifiersep> number ( ) ) ; return false ; } boolean valid ; resource <identifiersep> reference resource <identifiersep> reference = null ; try { resource <identifiersep> reference = get <identifiersep> download <identifiersep> reference ( document , extension <identifiersep> version ) ; <LOG> } catch ( resolve <identifiersep> exception e ) { x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extensionversion <identifiersep> classreference , extension <identifiersep> version <identifiersep> object . get <identifiersep> number ( ) ) ; return false ; } if ( resource <identifiersep> reference != null ) { if ( resource <identifiersep> type . attachment . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) ) { attachment <identifiersep> reference attachment <identifiersep> reference = <ect>
attachment <identifiersep> document = context . get <identifiersep> wiki ( ) . get <identifiersep> document ( attachment <identifiersep> reference . get <identifiersep> document <identifiersep> reference ( ) , context ) ; valid = attachment <identifiersep> document . get <identifiersep> attachment ( attachment <identifiersep> reference . get <identifiersep> name ( ) ) != null ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . logger . error ( <string_literal> , attachment <identifiersep> reference . get <identifiersep> document <identifiersep> reference ( ) , e ) ; valid = false ; } <LOG> if ( ! valid ) { } } else if ( resource <identifiersep> type . url . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) || extension <identifiersep> resource <identifiersep> reference . type . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) ) { valid = true ; } else { valid = false ; <ect>
|| extension <identifiersep> resource <identifiersep> reference . type . equals ( resource <identifiersep> reference . get <identifiersep> type ( ) ) ) { valid = true ; } else { valid = false ; this . logger . debug ( <string_literal> , resource <identifiersep> reference . get <identifiersep> type ( ) ) ; } } else { <LOG> valid = false ; x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extensionversion <identifiersep> classreference , extension <identifiersep> version <identifiersep> object . get <identifiersep> number ( ) ) ; } return valid ; } public void validate <identifiersep> extensions ( ) throws query <identifiersep> exception , x <identifiersep> wiki <identifiersep> exception { query query = this . query <identifiersep> manager . create <identifiersep> query ( <string_literal> <ect>
protected static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( all <identifiersep> tests . class ) ; private static repository <identifiersep> utils repository <identifiersep> util ; @ x <identifiersep> wiki <identifiersep> executor <identifiersep> suite . pre <identifiersep> start public void pre <identifiersep> start ( list < x <identifiersep> wiki <identifiersep> executor > executors ) throws exception { x <identifiersep> wiki <identifiersep> executor executor = executors . get ( 0 ) ; <LOG> repository <identifiersep> util = new repository <identifiersep> utils ( ) ; properties <identifiersep> configuration properties = executor . load <identifiersep> x <identifiersep> wiki <identifiersep> properties <identifiersep> configuration ( ) ; <comment> <ect>
super . pop ( ) ; } private void open <identifiersep> namespace ( string namespace ) { if ( get <identifiersep> velocity <identifiersep> manager ( ) != null ) { try { <comment> <LOG> get <identifiersep> velocity <identifiersep> manager ( ) . get <identifiersep> velocity <identifiersep> engine ( ) . started <identifiersep> using <identifiersep> macro <identifiersep> namespace ( namespace ) ; } catch ( exception e ) { <comment> <ect>
<comment> <LOG> } catch ( wiki <identifiersep> macro <identifiersep> exception e ) { return ; } <comment> <ect>
public void on <identifiersep> event ( event event , object source , object data ) { wiki <identifiersep> macro <identifiersep> initializer initializer = this . macro <identifiersep> initializer . get ( ) ; if ( event instanceof application <identifiersep> ready <identifiersep> event ) { try { initializer . register <identifiersep> existing <identifiersep> wiki <identifiersep> macros ( wiki <identifiersep> manager . get <identifiersep> current <identifiersep> wiki <identifiersep> id ( ) ) ; <LOG> } catch ( exception e ) { } } else if ( event instanceof wiki <identifiersep> ready <identifiersep> event ) { try { initializer . register <identifiersep> existing <identifiersep> wiki <identifiersep> macros ( ( ( wiki <identifiersep> ready <identifiersep> event ) event ) . get <identifiersep> wiki <identifiersep> id ( ) ) ; } catch ( exception e ) { this . logger . error ( <string_literal> , e ) ; <ect>
public void initialize ( document <identifiersep> reference macro <identifiersep> document <identifiersep> reference , wiki <identifiersep> macro <identifiersep> parameters parameters , string macro <identifiersep> content , macro <identifiersep> transformation <identifiersep> context context , map < string , object > macro <identifiersep> binding ) { try { x <identifiersep> wiki <identifiersep> document document = get <identifiersep> context ( ) . get <identifiersep> wiki ( ) . get <identifiersep> document ( macro <identifiersep> document <identifiersep> reference , get <identifiersep> context ( ) ) ; macro <identifiersep> binding . put ( macro <identifiersep> doc <identifiersep> key , document . new <identifiersep> document ( get <identifiersep> context ( ) ) ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } <ect>
execution <identifiersep> context econtext = this . execution . get <identifiersep> context ( ) ; <comment> <LOG> } else { } } } <ect>
<comment> <LOG> } catch ( exception ex ) { } } <comment> <ect>
string style = image <identifiersep> parameters . get ( <string_literal> ) ; if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( style ) ) { try { css <identifiersep> style <identifiersep> declaration sd = this . css <identifiersep> parser . parse <identifiersep> style <identifiersep> declaration ( new input <identifiersep> source ( new string <identifiersep> reader ( style ) ) ) ; value = sd . get <identifiersep> property <identifiersep> value ( dimension ) ; } catch ( exception e ) { <LOG> <comment> <ect>
try { list < print <identifiersep> renderer <identifiersep> factory > factories = this . component <identifiersep> manager <identifiersep> provider . get ( ) . get <identifiersep> instance <identifiersep> list ( print <identifiersep> renderer <identifiersep> factory . class ) ; for ( print <identifiersep> renderer <identifiersep> factory factory : factories ) { syntaxes . add ( factory . get <identifiersep> syntax ( ) ) ; } } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> <comment> <ect>
continue ; } else if ( character . is <identifiersep> whitespace ( array [ i ] ) ) { if ( ! filter <identifiersep> context . remove <identifiersep> white <identifiersep> spaces && content <identifiersep> buffer . length ( ) > 0 ) { filter <identifiersep> context . found <identifiersep> white <identifiersep> space = true ; } ++ i ; continue ; } <LOG> } catch ( invalid <identifiersep> velocity <identifiersep> exception e ) { } flush <identifiersep> white <identifiersep> spaces ( content <identifiersep> buffer , filter <identifiersep> context , false ) ; content <identifiersep> buffer . append ( array [ i ] ) ; ++ i ; } flush <identifiersep> white <identifiersep> spaces ( content <identifiersep> buffer , filter <identifiersep> context , true ) ; return content <identifiersep> buffer . to <identifiersep> string ( ) ; <ect>
get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) . put ( wiki <identifiersep> ui <identifiersep> extension . context <identifiersep> uix <identifiersep> key , uix <identifiersep> context ) ; <comment> <LOG> } catch ( transformation <identifiersep> exception e ) { } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { logger . warn ( <string_literal> , document <identifiersep> reference ) ; } return new composite <identifiersep> block ( transformed <identifiersep> xdom . get <identifiersep> children ( ) ) ; } <comment> <ect>
list < ui <identifiersep> extension > extensions = new array <identifiersep> list < ui <identifiersep> extension > ( ) ; try { list < ui <identifiersep> extension > all <identifiersep> extensions = context <identifiersep> component <identifiersep> manager <identifiersep> provider . get ( ) . get <identifiersep> instance <identifiersep> list ( ui <identifiersep> extension . class ) ; for ( ui <identifiersep> extension extension : all <identifiersep> extensions ) { if ( extension . get <identifiersep> extension <identifiersep> point <identifiersep> id ( ) . equals ( extension <identifiersep> point <identifiersep> id ) ) { extensions . add ( extension ) ; } } <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } return extensions ; } } <ect>
ui <identifiersep> extension <identifiersep> manager manager = this . ui <identifiersep> extension <identifiersep> manager ; component <identifiersep> manager component <identifiersep> manager = context <identifiersep> component <identifiersep> manager <identifiersep> provider . get ( ) ; if ( component <identifiersep> manager . has <identifiersep> component ( ui <identifiersep> extension <identifiersep> manager . class , extension <identifiersep> point <identifiersep> id ) ) { try { <comment> <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } return manager . get ( extension <identifiersep> point <identifiersep> id ) ; } <comment> <ect>
{ document <identifiersep> reference install <identifiersep> document <identifiersep> reference = new document <identifiersep> reference ( wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> main <identifiersep> wiki <identifiersep> id ( ) , workspace <identifiersep> class <identifiersep> space , <string_literal> ) ; try { document <identifiersep> restorer <identifiersep> from <identifiersep> attached <identifiersep> xar . restore <identifiersep> document <identifiersep> from <identifiersep> attached <identifiersep> xar ( install <identifiersep> document <identifiersep> reference , <string_literal> , documents <identifiersep> to <identifiersep> restore ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } private void restore <identifiersep> document <identifiersep> from <identifiersep> main <identifiersep> wiki ( list < document <identifiersep> reference > documents <identifiersep> to <identifiersep> restore ) { x <identifiersep> wiki <identifiersep> context xcontext = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ; x <identifiersep> wiki xwiki = xcontext . get <identifiersep> wiki ( ) ; wiki <identifiersep> reference main <identifiersep> wiki <identifiersep> reference = new wiki <identifiersep> reference ( wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> main <identifiersep> wiki <identifiersep> id ( ) ) ; <ect>
throws x <identifiersep> wiki <identifiersep> exception , io <identifiersep> exception { x <identifiersep> wiki <identifiersep> context xcontext = xcontext <identifiersep> provider . get ( ) ; x <identifiersep> wiki xwiki = xcontext . get <identifiersep> wiki ( ) ; <comment> <LOG> if ( document . is <identifiersep> new ( ) ) { return null ; } <comment> <ect>
x <identifiersep> wiki <identifiersep> document doc <identifiersep> to <identifiersep> restore = xwiki . get <identifiersep> document ( doc <identifiersep> ref , xcontext ) ; doc <identifiersep> to <identifiersep> restore . from <identifiersep> xml ( zip <identifiersep> file . get <identifiersep> input <identifiersep> stream ( zip <identifiersep> entry ) ) ; xwiki . save <identifiersep> document ( doc <identifiersep> to <identifiersep> restore , xcontext ) ; <comment> <LOG> } catch ( io <identifiersep> exception e ) { } finally { <comment> <ect>
<comment> public collection < wiki <identifiersep> descriptor > get <identifiersep> templates ( ) { try { return wiki <identifiersep> template <identifiersep> manager . get <identifiersep> templates ( ) ; <LOG> } catch ( wiki <identifiersep> template <identifiersep> manager <identifiersep> exception e ) { return new array <identifiersep> list < wiki <identifiersep> descriptor > ( ) ; } } <comment> <ect>
return false ; } catch ( access <identifiersep> denied <identifiersep> exception e ) { error ( string . format ( <string_literal> + <string_literal> , context . get <identifiersep> user <identifiersep> reference ( ) , wiki <identifiersep> id ) , e ) ; return false ; <LOG> } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { return false ; } } <comment> <ect>
authorization <identifiersep> manager . check <identifiersep> access ( right . create <identifiersep> wiki , context . get <identifiersep> user <identifiersep> reference ( ) , new wiki <identifiersep> reference ( context . get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) ) ) ; <comment> <LOG> } catch ( wiki <identifiersep> template <identifiersep> manager <identifiersep> exception e ) { } catch ( access <identifiersep> denied <identifiersep> exception e ) { error ( <string_literal> , e ) ; } return false ; } <comment> <ect>
{ try { wiki <identifiersep> provisioning <identifiersep> job wiki <identifiersep> provisioning <identifiersep> job = wiki <identifiersep> template <identifiersep> manager . get <identifiersep> wiki <identifiersep> provisioning <identifiersep> job ( job <identifiersep> id ) ; if ( wiki <identifiersep> provisioning <identifiersep> job == null ) { return null ; } return wiki <identifiersep> provisioning <identifiersep> job . get <identifiersep> status ( ) ; <LOG> } catch ( wiki <identifiersep> template <identifiersep> manager <identifiersep> exception e ) { return null ; } } } <ect>
<comment> public boolean can <identifiersep> delete <identifiersep> wiki ( string user <identifiersep> id , string wiki <identifiersep> id ) { try { <comment> <LOG> if ( descriptor == null ) { return false ; } <comment> <ect>
file file = new file ( <string_literal> + xwiki <identifiersep> properties <identifiersep> file ) ; if ( file . exists ( ) ) { try { return new configurations ( ) . properties ( file ) ; } catch ( exception e ) { <comment> <LOG> <comment> <ect>
try { result = get <identifiersep> base <identifiersep> property ( key , value <identifiersep> class == string . class ) ; if ( value <identifiersep> class != null && result != null ) { result = this . converter . convert ( value <identifiersep> class , result ) ; } <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } <comment> <ect>
{ x <identifiersep> wiki <identifiersep> preferences <identifiersep> wiki <identifiersep> translation <identifiersep> bundle bundle = this . wiki <identifiersep> bundles <identifiersep> cache . get ( wiki ) ; if ( bundle == null ) { try { bundle = create <identifiersep> wiki <identifiersep> bundle ( wiki ) ; this . wiki <identifiersep> bundles <identifiersep> cache . put ( wiki , bundle ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } return bundle ; } <comment> <ect>
if ( ! locale . equals ( locale . root ) ) { resource <identifiersep> name += <string_literal> + locale ; } resource <identifiersep> name += <string_literal> ; enumeration < url > urls ; try { urls = get <identifiersep> class ( ) . get <identifiersep> class <identifiersep> loader ( ) . get <identifiersep> resources ( resource <identifiersep> name ) ; <LOG> } catch ( io <identifiersep> exception e ) { return null ; } if ( ! urls . has <identifiersep> more <identifiersep> elements ( ) ) { return null ; } list < url > url <identifiersep> list = enumeration <identifiersep> utils . to <identifiersep> list ( urls ) ; properties properties = new properties ( ) ; <ect>
private void extension <identifiersep> deleted ( installed <identifiersep> extension extension , string namespace ) { try { component <identifiersep> descriptor < translation <identifiersep> bundle > descriptor = create <identifiersep> component <identifiersep> descriptor ( extension ) ; component <identifiersep> manager component <identifiersep> manager = this . component <identifiersep> manager <identifiersep> manager . get <identifiersep> component <identifiersep> manager ( namespace , false ) ; component <identifiersep> manager . unregister <identifiersep> component ( descriptor ) ; <LOG> } catch ( exception e ) { } } <comment> private void extension <identifiersep> added ( installed <identifiersep> extension extension , string namespace ) <ect>
x <identifiersep> wiki <identifiersep> document document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( reference , xcontext ) ; try { register <identifiersep> translation <identifiersep> bundle ( document ) ; } catch ( exception e ) { this . logger . error ( <string_literal> , document . get <identifiersep> document <identifiersep> reference ( ) , e ) ; } } <LOG> } catch ( exception e ) { } } @ override public translation <identifiersep> bundle get <identifiersep> bundle ( string bundle <identifiersep> id ) throws translation <identifiersep> bundle <identifiersep> does <identifiersep> not <identifiersep> exists <identifiersep> exception { string role <identifiersep> hint = id <identifiersep> prefix + bundle <identifiersep> id ; if ( this . component <identifiersep> manager <identifiersep> provider . get ( ) . has <identifiersep> component ( translation <identifiersep> bundle . class , role <identifiersep> hint ) ) { <ect>
throws translation <identifiersep> bundle <identifiersep> does <identifiersep> not <identifiersep> exists <identifiersep> exception , translation <identifiersep> bundle <identifiersep> factory <identifiersep> does <identifiersep> not <identifiersep> exists <identifiersep> exception { if ( this . component <identifiersep> manager <identifiersep> provider . get ( ) . has <identifiersep> component ( translation <identifiersep> bundle . class , bundle <identifiersep> type + ' : ' + bundle <identifiersep> id ) ) { try { return this . component <identifiersep> manager <identifiersep> provider . get ( ) . < translation <identifiersep> bundle > get <identifiersep> instance ( translation <identifiersep> bundle . class , bundle <identifiersep> type + ' : ' + bundle <identifiersep> id ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } translation <identifiersep> bundle <identifiersep> factory bundle <identifiersep> factory ; try { bundle <identifiersep> factory = this . component <identifiersep> manager <identifiersep> provider . get ( ) . get <identifiersep> instance ( translation <identifiersep> bundle <identifiersep> factory . class , bundle <identifiersep> type ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { throw new translation <identifiersep> bundle <identifiersep> factory <identifiersep> does <identifiersep> not <identifiersep> exists <identifiersep> exception ( string . format ( <ect>
sorted <identifiersep> set < translation <identifiersep> bundle > current <identifiersep> bundles = new tree <identifiersep> set < > ( ) ; try { component <identifiersep> manager component <identifiersep> manager = this . component <identifiersep> manager <identifiersep> provider . get ( ) ; list < translation <identifiersep> bundle > available <identifiersep> bundles = component <identifiersep> manager . < translation <identifiersep> bundle > get <identifiersep> instance <identifiersep> list ( translation <identifiersep> bundle . class ) ; current <identifiersep> bundles . add <identifiersep> all ( available <identifiersep> bundles ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } return current <identifiersep> bundles ; } <comment> private map < string , sorted <identifiersep> set < translation <identifiersep> bundle > > get <identifiersep> bundles <identifiersep> internal ( ) <ect>
line <identifiersep> iterator iterator = io <identifiersep> utils . line <identifiersep> iterator ( resource , standard <identifiersep> charsets . us <identifiersep> ascii ) ; while ( iterator . has <identifiersep> next ( ) ) { string line = iterator . next <identifiersep> line ( ) ; if ( string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( line ) ) { locales . add ( new locale ( line ) ) ; } } iterator . close ( ) ; <LOG> } catch ( exception e ) { } return locales ; } } <ect>
<string_literal> + <string_literal> , query . xwql ) ; q . bind <identifiersep> value ( <string_literal> , this . serializer . serialize ( group ) ) ; q . set <identifiersep> limit ( limit > 0 ? limit : <number_literal> ) . set <identifiersep> offset ( offset >= 0 ? offset : 0 ) ; result = this . stream . search <identifiersep> events ( q ) ; <LOG> } catch ( query <identifiersep> exception ex ) { } return result ; } @ override public void delete <identifiersep> message ( string id ) { query q ; <ect>
} catch ( component <identifiersep> lookup <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( <string_literal> , e ) ; } <comment> <LOG> { <comment> <ect>
@ override public file get <identifiersep> permanent <identifiersep> directory ( ) { if ( this . permanent <identifiersep> directory == null ) { try { this . permanent <identifiersep> directory = get <identifiersep> configured <identifiersep> permanent <identifiersep> directory ( ) ; <LOG> } catch ( exception e ) { } if ( this . permanent <identifiersep> directory == null ) { <comment> <ect>
this . random = secure <identifiersep> random . get <identifiersep> instance ( <string_literal> ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <comment> <LOG> this . random . set <identifiersep> seed ( seed ) ; } <comment> <ect>
<comment> <LOG> this . execution . get <identifiersep> context ( ) . set <identifiersep> property ( office <identifiersep> view <identifiersep> exception , e ) ; return null ; } } @ override public boolean is <identifiersep> mime <identifiersep> type <identifiersep> supported ( string mime <identifiersep> type ) { return is <identifiersep> conversion <identifiersep> supported ( mime <identifiersep> type , <string_literal> ) ; <ect>
{ string file <identifiersep> name = null ; try { file <identifiersep> name = get <identifiersep> file <identifiersep> name ( source ) ; } catch ( exception e ) { this . logger . warn ( <string_literal> , <LOG> exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } if ( string <identifiersep> utils . is <identifiersep> empty ( file <identifiersep> name ) ) { return ; } <comment> <ect>
{ <comment> <LOG> set <identifiersep> state ( server <identifiersep> state . not <identifiersep> connected ) ; } catch ( exception e ) { if ( connected ) { set <identifiersep> state ( server <identifiersep> state . error ) ; throw new office <identifiersep> server <identifiersep> exception ( <string_literal> , e ) ; } } } @ override <ect>
<comment> conf <identifiersep> error ( <string_literal> ) , <comment> <LOG> <comment> <comment> private string description ; <comment> <ect>
{ <comment> <LOG> <comment> <ect>
hash <identifiersep> algorithm . update ( ( byte ) size . ordinal ( ) ) ; hash <identifiersep> algorithm . update ( ( byte ) type . ordinal ( ) ) ; hash <identifiersep> algorithm . update ( formula . get <identifiersep> bytes ( ) ) ; return string . value <identifiersep> of ( org . apache . commons . codec . binary . hex . encode <identifiersep> hex ( hash <identifiersep> algorithm . digest ( ) ) ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; <LOG> } catch ( null <identifiersep> pointer <identifiersep> exception ex ) { } <comment> <ect>
} catch ( exception ex ) { logger . warn ( <string_literal> , ex ) ; } this . dot <identifiersep> path = context . get <identifiersep> wiki ( ) . param ( <string_literal> , dot <identifiersep> engine ) ; if ( ! this . dot <identifiersep> path . equals ( dot <identifiersep> engine ) ) { try { file dfile = new file ( this . dot <identifiersep> path ) ; <LOG> if ( ! dfile . exists ( ) ) { } } catch ( exception e ) { <comment> <ect>
thread t = new thread ( new hangcheck ( this <identifiersep> thread ) , <string_literal> ) ; t . run ( ) ; try { exit <identifiersep> value = p . wait <identifiersep> for ( ) ; t . interrupt ( ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> p . destroy ( ) ; } if ( exit <identifiersep> value != 0 ) { logger . error ( <string_literal> + io <identifiersep> utils . to <identifiersep> string ( p . get <identifiersep> error <identifiersep> stream ( ) , x <identifiersep> wiki . default <identifiersep> encoding ) ) ; } } return file <identifiersep> utils . read <identifiersep> file <identifiersep> to <identifiersep> byte <identifiersep> array ( ofile ) ; } <comment> <ect>
string mail <identifiersep> template = this . watch <identifiersep> list <identifiersep> job <identifiersep> object . get <identifiersep> string <identifiersep> value ( watch <identifiersep> list <identifiersep> job <identifiersep> class <identifiersep> document <identifiersep> initializer . template <identifiersep> field ) ; notification <identifiersep> data . put ( watch <identifiersep> list <identifiersep> event <identifiersep> mime <identifiersep> message <identifiersep> factory . template <identifiersep> parameter , mail <identifiersep> template ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> } catch ( exception e ) { return null ; } finally { <comment> <ect>
query . set <identifiersep> wiki ( wiki ) ; list < string > up <identifiersep> docs <identifiersep> in <identifiersep> wiki = query . execute ( ) ; <comment> <LOG> } catch ( exception e ) { } } } catch ( exception e ) { logger . error ( <string_literal> , e ) ; } return results ; } <comment> <ect>
prop <identifiersep> diff <identifiersep> div . add <identifiersep> element ( prop <identifiersep> diff ) ; prop <identifiersep> div . add <identifiersep> element ( prop <identifiersep> diff <identifiersep> div ) ; <comment> <LOG> <comment> <ect>
logger . error ( <string_literal> , user , e ) ; } if ( mode == null ) { string value = context . get <identifiersep> wiki ( ) . param ( <string_literal> ) ; if ( value != null ) { try { mode = automatic <identifiersep> watch <identifiersep> mode . value <identifiersep> of ( value . to <identifiersep> upper <identifiersep> case ( ) ) ; <LOG> } catch ( exception e ) { } } } return mode != null ? mode : automatic <identifiersep> watch <identifiersep> mode . major ; } @ override public list < string > get <identifiersep> intervals ( ) { return notification <identifiersep> cache . get ( ) . get <identifiersep> intervals ( ) ; <ect>
<comment> <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <ect>
m . reset ( line ) ; } headers <identifiersep> found = true ; } <comment> <LOG> if ( headers <identifiersep> found ) { } } <comment> <ect>
int email <identifiersep> count = emails . size ( ) ; int count = 0 ; int send <identifiersep> failed <identifiersep> count = 0 ; try { for ( iterator < mail > email <identifiersep> it = emails . iterator ( ) ; email <identifiersep> it . has <identifiersep> next ( ) ; ) { count ++ ; <LOG> mail mail = email <identifiersep> it . next ( ) ; if ( ( transport == null ) || ( session == null ) ) { <comment> <ect>
transport . close ( ) ; } } catch ( messaging <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } transport = null ; session = null ; } } catch ( send <identifiersep> failed <identifiersep> exception ex ) { <LOG> send <identifiersep> failed <identifiersep> count ++ ; logger . error ( <string_literal> + mail . to <identifiersep> string ( ) ) ; if ( email <identifiersep> count == 1 ) { throw ex ; } if ( ( email <identifiersep> count != 1 ) && ( send <identifiersep> failed <identifiersep> count > <number_literal> ) ) { throw ex ; <ect>
logger . error ( <string_literal> , ex ) ; logger . error ( <string_literal> + mail . to <identifiersep> string ( ) ) ; if ( email <identifiersep> count == 1 ) { throw ex ; } if ( ( email <identifiersep> count != 1 ) && ( send <identifiersep> failed <identifiersep> count > <number_literal> ) ) { throw ex ; } <LOG> } catch ( messaging <identifiersep> exception mex ) { logger . error ( <string_literal> + mail . to <identifiersep> string ( ) ) ; if ( email <identifiersep> count == 1 ) { throw mex ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; <ect>
throw ex ; } } catch ( messaging <identifiersep> exception mex ) { logger . error ( <string_literal> , mex ) ; logger . error ( <string_literal> + mail . to <identifiersep> string ( ) ) ; if ( email <identifiersep> count == 1 ) { throw mex ; } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } finally { try { if ( transport != null ) { <ect>
} catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } finally { try { if ( transport != null ) { transport . close ( ) ; } <LOG> } catch ( messaging <identifiersep> exception ex ) { } logger . info ( <string_literal> + email <identifiersep> count + <string_literal> + count ) ; } return true ; } <comment> <ect>
x <identifiersep> wiki xwiki = context . get <identifiersep> wiki ( ) ; x <identifiersep> wiki <identifiersep> document doc = xwiki . get <identifiersep> document ( template <identifiersep> doc <identifiersep> full <identifiersep> name , context ) ; document doc <identifiersep> api = new document ( doc , context ) ; base <identifiersep> object obj = doc . get <identifiersep> object ( email <identifiersep> xwiki <identifiersep> class <identifiersep> name , <string_literal> , language ) ; if ( obj == null ) { obj = doc . get <identifiersep> object ( email <identifiersep> xwiki <identifiersep> class <identifiersep> name , <string_literal> , <string_literal> ) ; } <LOG> if ( obj == null ) { return error <identifiersep> template <identifiersep> email <identifiersep> object <identifiersep> not <identifiersep> found ; } string subject <identifiersep> content = obj . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; string txt <identifiersep> content = obj . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; string html <identifiersep> content = obj . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; string subject = evaluate ( subject <identifiersep> content , template <identifiersep> doc <identifiersep> full <identifiersep> name , updated <identifiersep> velocity <identifiersep> context , context ) ; <ect>
{ string <identifiersep> writer writer = new string <identifiersep> writer ( ) ; try { velocity <identifiersep> manager velocity <identifiersep> manager = utils . get <identifiersep> component ( velocity <identifiersep> manager . class ) ; velocity <identifiersep> manager . get <identifiersep> velocity <identifiersep> engine ( ) . evaluate ( vcontext , writer , name , content ) ; return writer . to <identifiersep> string ( ) ; <LOG> } catch ( exception e ) { object [ ] args = { name } ; x <identifiersep> wiki <identifiersep> exception xe = new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> rendering <identifiersep> velocity <identifiersep> exception , <string_literal> , e , args ) ; <ect>
try { return get <identifiersep> protected <identifiersep> plugin ( ) . send <identifiersep> mail <identifiersep> from <identifiersep> template ( document <identifiersep> full <identifiersep> name , from , to , cc , bcc , language , parameters , this . context ) ; } catch ( exception e ) { <comment> <LOG> this . context . put ( <string_literal> , e . get <identifiersep> message ( ) ) ; } return - 1 ; } } @ override public mail create <identifiersep> mail ( ) { return new mail ( ) ; <ect>
int result = 0 ; try { get <identifiersep> protected <identifiersep> plugin ( ) . send <identifiersep> mail ( mail , mail <identifiersep> configuration , this . context ) ; } catch ( exception e ) { <comment> <LOG> this . context . put ( <string_literal> , e . get <identifiersep> message ( ) ) ; } + mail <identifiersep> configuration . to <identifiersep> string ( ) + <string_literal> , e ) ; result = - 1 ; } return result ; } } <ect>
if ( obj . get <identifiersep> string <identifiersep> value ( use <identifiersep> fieldname ) . equals ( <string_literal> ) ) { return true ; } } } return false ; } @ override public void use ( string resource , x <identifiersep> wiki <identifiersep> context context ) { <LOG> string canonical <identifiersep> resource = get <identifiersep> canonical <identifiersep> document <identifiersep> name ( resource ) ; get <identifiersep> pulled <identifiersep> resources ( context ) . add ( canonical <identifiersep> resource ) ; <comment> <ect>
<comment> private string get <identifiersep> document <identifiersep> version ( document <identifiersep> reference document <identifiersep> reference , x <identifiersep> wiki <identifiersep> context context ) { try { return context . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , context ) . get <identifiersep> version ( ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } return <string_literal> ; } <comment> <ect>
try { error <identifiersep> reporter reporter = new custom <identifiersep> error <identifiersep> reporter ( ) ; java <identifiersep> script <identifiersep> compressor compressor = new java <identifiersep> script <identifiersep> compressor ( new string <identifiersep> reader ( source ) , reporter ) ; string <identifiersep> writer out = new string <identifiersep> writer ( ) ; compressor . compress ( out , - 1 , true , false , false , false ) ; return out . to <identifiersep> string ( ) ; <LOG> } catch ( io <identifiersep> exception ex ) { } catch ( evaluator <identifiersep> exception ex ) { logger . info ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } catch ( exception ex ) { logger . warn ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } return source ; <ect>
compressor . compress ( out , - 1 , true , false , false , false ) ; return out . to <identifiersep> string ( ) ; } catch ( io <identifiersep> exception ex ) { logger . info ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } catch ( evaluator <identifiersep> exception ex ) { logger . info ( <string_literal> + ex . get <identifiersep> message ( ) ) ; <LOG> } catch ( exception ex ) { } return source ; } <comment> private static class custom <identifiersep> error <identifiersep> reporter implements error <identifiersep> reporter { @ override <ect>
{ try { css <identifiersep> compressor compressor = new css <identifiersep> compressor ( new string <identifiersep> reader ( source ) ) ; string <identifiersep> writer out = new string <identifiersep> writer ( ) ; compressor . compress ( out , - 1 ) ; return out . to <identifiersep> string ( ) ; <LOG> } catch ( io <identifiersep> exception ex ) { } return source ; } } ; } } <ect>
} else { id = long . value <identifiersep> of ( value2 ) ; path = value1 ; } <comment> <LOG> if ( ! directory . exists ( ) ) { continue ; } if ( ! directory . is <identifiersep> directory ( ) ) { this . logger . warn ( <string_literal> , directory ) ; continue ; } store <identifiersep> deleted <identifiersep> attachment ( directory , id , session ) ; <ect>
@ override public void job <identifiersep> paused ( job <identifiersep> key job <identifiersep> key ) { logger . info ( <string_literal> , job <identifiersep> key ) ; } @ override public void job <identifiersep> resumed ( job <identifiersep> key job <identifiersep> key ) <LOG> { } @ override public void scheduler <identifiersep> error ( string message , scheduler <identifiersep> exception error ) { logger . error ( message , error ) ; } @ override <ect>
@ override public string get <identifiersep> name ( ) { return <string_literal> ; } @ override public void job <identifiersep> to <identifiersep> be <identifiersep> executed ( job <identifiersep> execution <identifiersep> context context ) <LOG> { } @ override public void job <identifiersep> execution <identifiersep> vetoed ( job <identifiersep> execution <identifiersep> context context ) { } @ override public void job <identifiersep> was <identifiersep> executed ( job <identifiersep> execution <identifiersep> context context , job <identifiersep> execution <identifiersep> exception e ) <ect>
<comment> <LOG> get <identifiersep> protected <identifiersep> plugin ( ) . pause <identifiersep> job ( object , this . context ) ; return true ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . context . put ( <string_literal> , e . get <identifiersep> message ( ) ) ; return false ; } } <comment> <ect>
<comment> <LOG> get <identifiersep> protected <identifiersep> plugin ( ) . unschedule <identifiersep> job ( object , this . context ) ; return true ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . context . put ( <string_literal> , e . get <identifiersep> message ( ) ) ; return false ; } } <comment> <ect>
x <identifiersep> wiki <identifiersep> context xcontext = utils . < provider < x <identifiersep> wiki <identifiersep> context > > get <identifiersep> component ( x <identifiersep> wiki <identifiersep> context . type <identifiersep> provider ) . get ( ) ; try { string initial <identifiersep> db = ! xcontext . get <identifiersep> wiki <identifiersep> id ( ) . equals ( <string_literal> ) ? xcontext . get <identifiersep> wiki <identifiersep> id ( ) : xcontext . get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) ; list < string > wiki <identifiersep> servers = new array <identifiersep> list < string > ( ) ; try { wiki <identifiersep> servers = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> virtual <identifiersep> wikis <identifiersep> database <identifiersep> names ( xcontext ) ; <LOG> } catch ( exception e ) { } <comment> <ect>
xcontext . set <identifiersep> wiki <identifiersep> id ( wiki <identifiersep> name ) ; restore <identifiersep> existing <identifiersep> jobs ( xcontext ) ; } } finally { xcontext . set <identifiersep> wiki <identifiersep> id ( initial <identifiersep> db ) ; } } catch ( scheduler <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; <LOG> } catch ( scheduler <identifiersep> plugin <identifiersep> exception e ) { } } <comment> <ect>
job <identifiersep> state status = get <identifiersep> job <identifiersep> status ( object , context ) ; switch ( status . get <identifiersep> quartz <identifiersep> state ( ) ) { case paused : <comment> <LOG> if ( get <identifiersep> trigger ( object , context ) . compare <identifiersep> to ( trigger ) != 0 ) { } get <identifiersep> scheduler ( ) . reschedule <identifiersep> job ( trigger . get <identifiersep> key ( ) , trigger ) ; break ; case none : logger . debug ( <string_literal> , object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ) ; get <identifiersep> scheduler ( ) . schedule <identifiersep> job ( trigger ) ; <ect>
if ( get <identifiersep> trigger ( object , context ) . compare <identifiersep> to ( trigger ) != 0 ) { logger . debug ( <string_literal> , object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ) ; } get <identifiersep> scheduler ( ) . reschedule <identifiersep> job ( trigger . get <identifiersep> key ( ) , trigger ) ; break ; case none : logger . debug ( <string_literal> , object . get <identifiersep> string <identifiersep> value ( <string_literal> ) ) ; <LOG> get <identifiersep> scheduler ( ) . schedule <identifiersep> job ( trigger ) ; if ( object . get <identifiersep> string <identifiersep> value ( <string_literal> ) . equals ( <string_literal> ) ) { get <identifiersep> scheduler ( ) . pause <identifiersep> job ( new job <identifiersep> key ( xjob ) ) ; save <identifiersep> status ( <string_literal> , object , context ) ; } else { save <identifiersep> status ( <string_literal> , object , context ) ; <ect>
base <identifiersep> object original <identifiersep> job <identifiersep> obj = original <identifiersep> document . get <identifiersep> x <identifiersep> object ( xwiki <identifiersep> job <identifiersep> classreference ) ; if ( job <identifiersep> obj == null ) { if ( original <identifiersep> job <identifiersep> obj != null ) { <comment> <LOG> } catch ( scheduler <identifiersep> plugin <identifiersep> exception e ) { exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } else { if ( original <identifiersep> job <identifiersep> obj == null ) { <comment> <ect>
string wiki = ( ( wiki <identifiersep> deleted <identifiersep> event ) event ) . get <identifiersep> wiki <identifiersep> id ( ) ; component <identifiersep> manager component <identifiersep> manager = this . component <identifiersep> manager <identifiersep> manager . get <identifiersep> component <identifiersep> manager ( new wiki <identifiersep> namespace ( wiki ) . serialize ( ) , false ) ; if ( component <identifiersep> manager instanceof disposable ) { try { ( ( disposable ) component <identifiersep> manager ) . dispose ( ) ; <LOG> } catch ( component <identifiersep> lifecycle <identifiersep> exception e ) { } } } } <ect>
try { list < wiki <identifiersep> component > components = provider . build <identifiersep> components ( reference ) ; this . wiki <identifiersep> component <identifiersep> manager <identifiersep> event <identifiersep> listener <identifiersep> helper . register <identifiersep> component <identifiersep> list ( components ) ; } catch ( wiki <identifiersep> component <identifiersep> exception e ) { this . logger . warn ( <string_literal> , reference , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } <comment> <ect>
list < string > parameters = new array <identifiersep> list < string > ( ) ; parameters . add ( component <identifiersep> class ) ; parameters . add ( component <identifiersep> role <identifiersep> type <identifiersep> field ) ; try { x <identifiersep> wiki <identifiersep> context xcontext = xcontext <identifiersep> provider . get ( ) ; results . add <identifiersep> all ( xcontext . get <identifiersep> wiki ( ) . get <identifiersep> store ( ) . search <identifiersep> document <identifiersep> references ( query , parameters , xcontext ) ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } return results ; } @ override public list < wiki <identifiersep> component > build <identifiersep> components ( document <identifiersep> reference reference ) throws wiki <identifiersep> component <identifiersep> exception { list < wiki <identifiersep> component > components = new array <identifiersep> list < wiki <identifiersep> component > ( ) ; <ect>
<comment> public void unregister <identifiersep> components ( entity <identifiersep> reference entity <identifiersep> reference ) { try { this . wiki <identifiersep> component <identifiersep> manager . unregister <identifiersep> wiki <identifiersep> components ( entity <identifiersep> reference ) ; <LOG> } catch ( wiki <identifiersep> component <identifiersep> exception e ) { exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } <ect>
this . wiki <identifiersep> component <identifiersep> manager <identifiersep> context . set <identifiersep> current <identifiersep> user <identifiersep> reference ( component . get <identifiersep> author <identifiersep> reference ( ) ) ; this . wiki <identifiersep> component <identifiersep> manager <identifiersep> context . set <identifiersep> current <identifiersep> entity <identifiersep> reference ( component . get <identifiersep> entity <identifiersep> reference ( ) ) ; <comment> <LOG> } catch ( initialization <identifiersep> exception e ) { } } <comment> <ect>
<comment> <LOG> <comment> <ect>
try { <comment> <LOG> } catch ( transformer <identifiersep> exception e ) { } } <comment> <ect>
{ protected static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( tika <identifiersep> utils . class ) ; private static tika tika ; static { try { tika = new tika ( new tika <identifiersep> config ( tika <identifiersep> utils . class . get <identifiersep> resource ( <string_literal> ) ) ) ; <LOG> } catch ( exception e ) { exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; tika = new tika ( ) ; } } private tika <identifiersep> utils ( ) { <comment> <ect>
else { fieldset . class <identifiersep> name = <string_literal> ; } } <comment> window . create <identifiersep> cookie = x <identifiersep> wiki . cookies . create . wrap ( <LOG> function ( ) { var args = $a ( arguments ) , proceed = args . shift ( ) ; return proceed . apply ( window , args ) ; } ) ; <comment> <ect>
return proceed . apply ( window , args ) ; } ) ; <comment> window . erase <identifiersep> cookie = x <identifiersep> wiki . cookies . erase . wrap ( <LOG> function ( ) { var args = $a ( arguments ) , proceed = args . shift ( ) ; return proceed . apply ( window , args ) ; } ) ; <comment> <ect>
var args = $a ( arguments ) , proceed = args . shift ( ) ; return proceed . apply ( window , args ) ; } ) ; <comment> <LOG> window . cancel <identifiersep> edit = function ( ) { x <identifiersep> wiki . edit <identifiersep> lock . unlock ( ) ; } <comment> window . lock <identifiersep> edit = function ( ) { <ect>
window . lock <identifiersep> edit = function ( ) { warn ( <string_literal> ) ; x <identifiersep> wiki . edit <identifiersep> lock . lock ( ) ; } <comment> <LOG> window . cancel <identifiersep> cancel <identifiersep> edit = function ( ) { x <identifiersep> wiki . edit <identifiersep> lock . set <identifiersep> locked ( false ) ; } x <identifiersep> wiki . resource = x <identifiersep> wiki . resource || { } ; object . extend ( x <identifiersep> wiki . resource , { <comment> <ect>
if ( monthyear ) { var a <identifiersep> month <identifiersep> year = monthyear . split ( this . locale . date <identifiersep> field <identifiersep> delimiter ) ; month = parse <identifiersep> int ( a <identifiersep> month <identifiersep> year [ this . locale . my <identifiersep> month <identifiersep> position - 1 ] ) ; year = parse <identifiersep> int ( a <identifiersep> month <identifiersep> year [ this . locale . my <identifiersep> year <identifiersep> position - 1 ] ) ; } else { month = this . today . get <identifiersep> month ( ) + 1 ; <LOG> year = this . today . get <identifiersep> full <identifiersep> year ( ) ; } this . page <identifiersep> date = new date ( year , month - 1 , 1 ) ; this .  <identifiersep> page <identifiersep> date = new date ( this . page <identifiersep> date . get <identifiersep> time ( ) ) ; if ( selected ) { this . selected <identifiersep> dates = this .  <identifiersep> parse <identifiersep> dates ( selected ) ; this .  <identifiersep> selected <identifiersep> dates = this . selected <identifiersep> dates . concat ( ) ; <ect>
this . render <identifiersep> footer ( ) ; this . on <identifiersep> render ( ) ; } ; <comment> <LOG> yahoo . widget . calendar <identifiersep> core . prototype . render <identifiersep> header = function ( ) { this . header <identifiersep> cell . inner <identifiersep> html = <string_literal> ; var header <identifiersep> container = document . create <identifiersep> element ( <string_literal> ) ; header <identifiersep> container . class <identifiersep> name = this . style . css <identifiersep> header ; header <identifiersep> container . append <identifiersep> child ( document . create <identifiersep> text <identifiersep> node ( this . build <identifiersep> month <identifiersep> label ( ) ) ) ; this . header <identifiersep> cell . append <identifiersep> child ( header <identifiersep> container ) ; <ect>
yahoo . widget . calendar <identifiersep> core . prototype . render <identifiersep> body = function ( working <identifiersep> date ) { this . logger . log ( <string_literal> , <string_literal> ) ; this . pre <identifiersep> month <identifiersep> days = working <identifiersep> date . get <identifiersep> day ( ) ; if ( this . options . start <identifiersep> weekday > 0 ) { this . pre <identifiersep> month <identifiersep> days -= this . options . start <identifiersep> weekday ; } if ( this . pre <identifiersep> month <identifiersep> days < 0 ) { <LOG> this . pre <identifiersep> month <identifiersep> days += <number_literal> ; } this . month <identifiersep> days = yahoo . widget . date <identifiersep> math . find <identifiersep> month <identifiersep> end ( working <identifiersep> date ) . get <identifiersep> date ( ) ; this . logger . log ( this . month <identifiersep> days + <string_literal> , <string_literal> ) ; this . post <identifiersep> month <identifiersep> days = yahoo . widget . calendar <identifiersep> core . display <identifiersep> days - this . pre <identifiersep> month <identifiersep> days - this . month <identifiersep> days ; this . logger . log ( this . post <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; working <identifiersep> date = yahoo . widget . date <identifiersep> math . subtract ( working <identifiersep> date , yahoo . widget . date <identifiersep> math . day , this . pre <identifiersep> month <identifiersep> days ) ; <ect>
this . pre <identifiersep> month <identifiersep> days -= this . options . start <identifiersep> weekday ; } if ( this . pre <identifiersep> month <identifiersep> days < 0 ) { this . pre <identifiersep> month <identifiersep> days += <number_literal> ; } this . logger . log ( this . pre <identifiersep> month <identifiersep> days + <string_literal> , <string_literal> ) ; this . month <identifiersep> days = yahoo . widget . date <identifiersep> math . find <identifiersep> month <identifiersep> end ( working <identifiersep> date ) . get <identifiersep> date ( ) ; this . logger . log ( this . month <identifiersep> days + <string_literal> , <string_literal> ) ; <LOG> this . post <identifiersep> month <identifiersep> days = yahoo . widget . calendar <identifiersep> core . display <identifiersep> days - this . pre <identifiersep> month <identifiersep> days - this . month <identifiersep> days ; working <identifiersep> date = yahoo . widget . date <identifiersep> math . subtract ( working <identifiersep> date , yahoo . widget . date <identifiersep> math . day , this . pre <identifiersep> month <identifiersep> days ) ; this . logger . log ( <string_literal> + working <identifiersep> date , <string_literal> ) ; var week <identifiersep> row <identifiersep> index = 0 ; for ( var c = 0 ; c < this . cells . length ; ++ c ) { var cell <identifiersep> renderers = new array ( ) ; <ect>
<comment> <LOG> this . render <identifiersep> row <identifiersep> footer ( working <identifiersep> date , row <identifiersep> footer <identifiersep> cell ) ; } } } var renderer = null ; if ( working <identifiersep> date . get <identifiersep> full <identifiersep> year ( ) == this . today . get <identifiersep> full <identifiersep> year ( ) && working <identifiersep> date . get <identifiersep> month ( ) == this . today . get <identifiersep> month ( ) && working <identifiersep> date . get <identifiersep> date ( ) == this . today . get <identifiersep> date ( ) ) { cell <identifiersep> renderers [ cell <identifiersep> renderers . length ] = this . render <identifiersep> cell <identifiersep> style <identifiersep> today ; <ect>
var post <identifiersep> days = this . post <identifiersep> month <identifiersep> days ; if ( post <identifiersep> days >= <number_literal> && this . options . hide <identifiersep> blank <identifiersep> weeks ) { var blank <identifiersep> weeks = math . floor ( post <identifiersep> days / <number_literal> ) ; for ( var p = 0 ; p < blank <identifiersep> weeks ; ++ p ) { post <identifiersep> days -= <number_literal> ; } } if ( c >= ( ( this . pre <identifiersep> month <identifiersep> days + post <identifiersep> days + this . month <identifiersep> days ) - <number_literal> ) ) { <LOG> yahoo . util . dom . add <identifiersep> class ( cell , this . style . css <identifiersep> cell <identifiersep> bottom ) ; } } } ; <comment> <ect>
<comment> yahoo . widget . calendar <identifiersep> core . prototype . select = function ( date ) { this . on <identifiersep> before <identifiersep> select ( ) ; this . logger . log ( <string_literal> + date , <string_literal> ) ; <LOG> var a <identifiersep> to <identifiersep> be <identifiersep> selected = this .  <identifiersep> to <identifiersep> field <identifiersep> array ( date ) ; for ( var a = 0 ; a < a <identifiersep> to <identifiersep> be <identifiersep> selected . length ; ++ a ) { var to <identifiersep> select = a <identifiersep> to <identifiersep> be <identifiersep> selected [ a ] ; <comment> <ect>
<comment> yahoo . widget . calendar <identifiersep> core . prototype . deselect = function ( date ) { this . on <identifiersep> before <identifiersep> deselect ( ) ; <LOG> var a <identifiersep> to <identifiersep> be <identifiersep> selected = this .  <identifiersep> to <identifiersep> field <identifiersep> array ( date ) ; for ( var a = 0 ; a < a <identifiersep> to <identifiersep> be <identifiersep> selected . length ; ++ a ) { var to <identifiersep> select = a <identifiersep> to <identifiersep> be <identifiersep> selected [ a ] ; <comment> <ect>
this . sync ( ) ; this . do <identifiersep> next <identifiersep> month = function ( e , cal <identifiersep> group ) { cal <identifiersep> group . next <identifiersep> month ( ) ; } ; this . do <identifiersep> previous <identifiersep> month = function ( e , cal <identifiersep> group ) { cal <identifiersep> group . previous <identifiersep> month ( ) ; <LOG> } ; } ; <comment> <ect>
<comment> <LOG> yahoo . widget . check <identifiersep> node . prototype . on <identifiersep> check <identifiersep> click = function ( ) { } <comment> yahoo . widget . check <identifiersep> node . prototype . update <identifiersep> parent = function ( ) { var p = this . parent ; <ect>
this . check <identifiersep> state = state ; this . checked = ( state > 0 ) ; } ; <comment> <LOG> yahoo . widget . check <identifiersep> node . prototype . check = function ( ) { this . set <identifiersep> check <identifiersep> state ( <number_literal> ) ; for ( var i = 0 ; i < this . children . length ; ++ i ) { <comment> <ect>
<comment> <LOG> animate <identifiersep> expand : function ( el ) { if ( this .  <identifiersep> expand <identifiersep> anim && this .  <identifiersep> anim <identifiersep> count < this . max <identifiersep> anim ) { <comment> <ect>
return true ; } return false ; } , <comment> <LOG> expand <identifiersep> complete : function ( ) { -- this .  <identifiersep> anim <identifiersep> count ; <comment> <ect>
<comment> expand : function ( ) { <comment> <LOG> if ( <string_literal> != typeof ret && ! ret ) { return ; } if ( ! this . get <identifiersep> el ( ) ) { this . expanded = true ; return ; } if ( ! this . children <identifiersep> rendered ) { <ect>
if ( ! this . get <identifiersep> el ( ) ) { this . expanded = true ; return ; } if ( ! this . children <identifiersep> rendered ) { this . logger . log ( <string_literal> ) ; this . get <identifiersep> children <identifiersep> el ( ) . inner <identifiersep> html = this . render <identifiersep> children ( ) ; <LOG> } else { } this . expanded = true ; if ( this . has <identifiersep> icon ) { this . get <identifiersep> toggle <identifiersep> el ( ) . class <identifiersep> name = this . get <identifiersep> style ( ) ; } <comment> <ect>
<comment> get <identifiersep> style : function ( ) { <comment> <LOG> if ( this . is <identifiersep> loading ) { return <string_literal> ; } else { <comment> <ect>
<comment> is <identifiersep> dynamic : function ( ) { <LOG> var lazy = ( ! this . is <identifiersep> root ( ) && ( this .  <identifiersep> dyn <identifiersep> load || this . tree . root .  <identifiersep> dyn <identifiersep> load ) ) ; return lazy ; } , get <identifiersep> icon <identifiersep> mode : function ( ) { return ( this . icon <identifiersep> mode || this . tree . root . icon <identifiersep> mode ) ; } , <ect>
render <identifiersep> children : function ( ) { this . logger . log ( <string_literal> + this . index ) ; var node = this ; if ( this . is <identifiersep> dynamic ( ) && ! this . dynamic <identifiersep> load <identifiersep> complete ) { this . is <identifiersep> loading = true ; this . tree . locked = true ; <LOG> if ( this . data <identifiersep> loader ) { set <identifiersep> timeout ( function ( ) { node . data <identifiersep> loader ( node , function ( ) { node . load <identifiersep> complete ( ) ; <ect>
function ( ) { node . tree . root . data <identifiersep> loader ( node , function ( ) { node . load <identifiersep> complete ( ) ; } ) ; } , <number_literal> ) ; <LOG> } else { return <string_literal> ; } return <string_literal> ; } else { return this . complete <identifiersep> render ( ) ; } } , <ect>
return sb . join ( <string_literal> ) ; } , <comment> <LOG> load <identifiersep> complete : function ( ) { this . get <identifiersep> children <identifiersep> el ( ) . inner <identifiersep> html = this . complete <identifiersep> render ( ) ; this . dynamic <identifiersep> load <identifiersep> complete = true ; this . is <identifiersep> loading = false ; this . expand ( ) ; this . tree . locked = false ; <ect>
<comment> <LOG> get <identifiersep> node <identifiersep> html : function ( ) { return <string_literal> ; } , <comment> <ect>
<comment> <LOG> yahoo . widget . text <identifiersep> node . prototype . on <identifiersep> label <identifiersep> click = function ( me ) { <comment> <ect>
var tvanim = this ; var s = this . el . style ; s . opacity = 0 . 1 ; s . filter = <string_literal> ; s . display = <string_literal> ; <comment> <LOG> var dur = 0 . <number_literal> ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> add <identifiersep> listener : function ( el , s <identifiersep> type , fn , o <identifiersep> scope , b <identifiersep> override ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } <comment> <ect>
<comment> <LOG> return true ; } <comment> <ect>
public x <identifiersep> wiki <identifiersep> document get <identifiersep> document ( entity <identifiersep> reference reference ) { x <identifiersep> wiki <identifiersep> context context = xcontext <identifiersep> provider . get ( ) ; try { return context . get <identifiersep> wiki ( ) . get <identifiersep> document ( reference , context ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { return null ; } } <comment> <ect>
} catch ( ratings <identifiersep> exception re ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + rating . get <identifiersep> author ( ) , re ) ; } } } catch ( reputation <identifiersep> exception e ) { if ( e . get <identifiersep> code ( ) != reputation <identifiersep> exception . error <identifiersep> reputation <identifiersep> not <identifiersep> implemented ) { <comment> <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { + <string_literal> + document <identifiersep> ref , e ) ; } } } <comment> <ect>
if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + doc . get <identifiersep> creator <identifiersep> reference ( ) . get <identifiersep> name ( ) , re ) ; } } } catch ( reputation <identifiersep> exception e ) { if ( e . get <identifiersep> code ( ) != reputation <identifiersep> exception . error <identifiersep> reputation <identifiersep> not <identifiersep> implemented ) { <comment> <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { } } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + document <identifiersep> ref , e ) ; } } <comment> <ect>
try { map < string , average <identifiersep> rating > authors <identifiersep> ratings = calc <identifiersep> new <identifiersep> authors <identifiersep> reputation ( document <identifiersep> ref , rating , old <identifiersep> vote ) ; <comment> <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { } } } } } @ override public average <identifiersep> rating calc <identifiersep> new <identifiersep> voter <identifiersep> reputation ( document <identifiersep> reference voter , document <identifiersep> reference document <identifiersep> ref , rating rating , int old <identifiersep> vote ) throws reputation <identifiersep> exception { notimplemented ( ) ; <ect>
this . observation <identifiersep> manager . notify ( new update <identifiersep> rating <identifiersep> event ( document <identifiersep> ref , rating , old <identifiersep> vote ) , null ) ; } } return rating ; } @ override public list < rating > get <identifiersep> ratings ( document <identifiersep> reference document <identifiersep> ref , int start , int count , boolean asc ) throws ratings <identifiersep> exception <LOG> { } try { int skipped = 0 ; int nb = 0 ; x <identifiersep> wiki <identifiersep> document doc = get <identifiersep> x <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> ref , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; list < base <identifiersep> object > bobjects = doc . get <identifiersep> objects ( get <identifiersep> ratings <identifiersep> class <identifiersep> name ( ) ) ; <ect>
&& configuration <identifiersep> document . get <identifiersep> x <identifiersep> object ( ratings <identifiersep> manager . ratings <identifiersep> config <identifiersep> classreference ) != null ) { base <identifiersep> property prop = ( base <identifiersep> property ) configuration <identifiersep> document . get <identifiersep> x <identifiersep> object ( ratings <identifiersep> manager . ratings <identifiersep> config <identifiersep> classreference ) . get ( ratings <identifiersep> manager . ratings <identifiersep> config <identifiersep> class <identifiersep> fieldname <identifiersep> manager <identifiersep> hint ) ; string hint = ( prop == null ) ? null : ( string ) prop . get <identifiersep> value ( ) ; ratings <identifiersep> hint = ( hint == null ) ? ratings <identifiersep> hint : hint ; } <LOG> } catch ( exception e ) { } try { return component <identifiersep> manager . get <identifiersep> instance ( ratings <identifiersep> manager . class , ratings <identifiersep> hint ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <comment> <ect>
if ( hint == <string_literal> ) { prop = ( base <identifiersep> property ) configuration <identifiersep> document . get <identifiersep> x <identifiersep> object ( ratings <identifiersep> manager . ratings <identifiersep> config <identifiersep> classreference ) . get ( ratings <identifiersep> manager . ratings <identifiersep> config <identifiersep> class <identifiersep> fieldname <identifiersep> reputation <identifiersep> custom <identifiersep> algorithm ) ; hint = ( prop == null ) ? null : ( string ) prop . get <identifiersep> value ( ) ; } reputation <identifiersep> algorithm <identifiersep> hint = ( hint == null ) ? reputation <identifiersep> algorithm <identifiersep> hint : hint ; } <LOG> } catch ( exception e ) { } <comment> <ect>
return reputation <identifiersep> instance ; } } catch ( throwable e ) { logger . error ( <string_literal> + reputation <identifiersep> algorithm <identifiersep> hint , e ) ; } } try { return component <identifiersep> manager . get <identifiersep> instance ( reputation <identifiersep> algorithm . class , reputation <identifiersep> algorithm <identifiersep> hint ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> <comment> <ect>
x <identifiersep> wiki <identifiersep> context context ) { list < string > wiki <identifiersep> servers = new array <identifiersep> list < string > ( ) ; list < string > results = new array <identifiersep> list < string > ( ) ; try { wiki <identifiersep> servers = context . get <identifiersep> wiki ( ) . get <identifiersep> virtual <identifiersep> wikis <identifiersep> database <identifiersep> names ( context ) ; <LOG> } catch ( exception e ) { } string ori <identifiersep> database = context . get <identifiersep> wiki <identifiersep> id ( ) ; try { for ( string wiki : wiki <identifiersep> servers ) { string wiki <identifiersep> prefix = wiki + wiki <identifiersep> space <identifiersep> sep ; context . set <identifiersep> wiki <identifiersep> id ( wiki ) ; <ect>
@ override public void init ( x <identifiersep> wiki <identifiersep> context context ) { super . init ( context ) ; try { this . store . init ( context ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } @ override public void virtual <identifiersep> init ( x <identifiersep> wiki <identifiersep> context context ) { super . virtual <identifiersep> init ( context ) ; } @ override <ect>
watch <identifiersep> list <identifiersep> event event = new watch <identifiersep> list <identifiersep> event ( raw <identifiersep> event , context ) ; if ( ! events . contains ( event ) ) { events . add ( new watch <identifiersep> list <identifiersep> event ( raw <identifiersep> event , context ) ) ; } else { watch <identifiersep> list <identifiersep> event existing <identifiersep> composite <identifiersep> event = events . get ( events . index <identifiersep> of ( event ) ) ; existing <identifiersep> composite <identifiersep> event . add <identifiersep> event ( event ) ; } } <LOG> } catch ( activity <identifiersep> stream <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } <comment> public int get <identifiersep> event <identifiersep> number ( ) <ect>
if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } return - <number_literal> ; } <comment> <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { + <string_literal> ) ; } return - <number_literal> ; } string wiki <identifiersep> forbidden <identifiersep> list = param ( <string_literal> ) ; if ( util . contains ( wiki <identifiersep> name , wiki <identifiersep> forbidden <identifiersep> list , <string_literal> ) ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { <ect>
serverdoc . set <identifiersep> syntax ( syntax . xwiki <identifiersep> 1 <identifiersep> 0 ) ; } serverdoc . set <identifiersep> parent <identifiersep> reference ( virtual <identifiersep> wiki <identifiersep> definition <identifiersep> class <identifiersep> reference ) ; save <identifiersep> document ( serverdoc , context ) ; } else { <comment> <LOG> if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { + <string_literal> ) ; } return - <number_literal> ; logger . warn ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; <ect>
<comment> <LOG> if ( e . get <identifiersep> code ( ) == <number_literal> ) { + <string_literal> ) ; } else if ( e . get <identifiersep> code ( ) == <number_literal> ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } else { <ect>
if ( e . get <identifiersep> code ( ) == <number_literal> ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; } else if ( e . get <identifiersep> code ( ) == <number_literal> ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> ) ; <LOG> } else { + <string_literal> , e ) ; } } } catch ( exception e ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> , e ) ; } try { <ect>
+ <string_literal> , e ) ; } } } catch ( exception e ) { logger . error ( <string_literal> + wiki <identifiersep> name + <string_literal> + wiki <identifiersep> url + <string_literal> + wiki <identifiersep> admin + <string_literal> + <string_literal> , e ) ; } try { update <identifiersep> database ( wiki <identifiersep> name , true , false , context ) ; <LOG> } catch ( exception e ) { + <string_literal> , e ) ; return - <number_literal> ; } <comment> <ect>
host = request <identifiersep> url . get <identifiersep> host ( ) ; } catch ( exception e ) { } <comment> <LOG> string uri = request . get <identifiersep> request <identifiersep> uri ( ) ; } <comment> <ect>
manager . preverify ( document , new x <identifiersep> wiki <identifiersep> document ( document . get <identifiersep> document <identifiersep> reference ( ) ) , x <identifiersep> wiki <identifiersep> doc <identifiersep> change <identifiersep> notification <identifiersep> interface . event <identifiersep> delete , context ) ; } else if ( event instanceof action <identifiersep> executed <identifiersep> event ) { manager . verify ( document , ( ( action <identifiersep> executed <identifiersep> event ) event ) . get <identifiersep> action <identifiersep> name ( ) , context ) ; } else if ( event instanceof action <identifiersep> executing <identifiersep> event ) { manager . preverify ( document , ( ( action <identifiersep> executing <identifiersep> event ) event ) . get <identifiersep> action <identifiersep> name ( ) , context ) ; } <LOG> } else { } } } <ect>
} else { logger . debug ( <string_literal> ) ; } } <comment> <LOG> } catch ( exception e ) { config = new x <identifiersep> wiki <identifiersep> config ( ) ; } } return config . get <identifiersep> property ( property <identifiersep> key , default <identifiersep> value ) ; } } <ect>
private logger logger ; @ override public void initialize ( velocity <identifiersep> context context ) { try { context . put ( velocity <identifiersep> context <identifiersep> key , new office <identifiersep> importer <identifiersep> velocity <identifiersep> bridge ( this . component <identifiersep> manager ) ) ; <LOG> } catch ( office <identifiersep> importer <identifiersep> exception ex ) { } } } <ect>
if ( gidx > - 1 && gidx > oidx ) { <comment> <LOG> if ( ! original . equals ( result ) ) { } return result ; } @ override public list filter <identifiersep> results ( list results ) { return results ; <ect>
<comment> <LOG> if ( ! statement . equals ( result ) ) { } return result ; } @ override public list filter <identifiersep> results ( list results ) { <comment> <ect>
count <identifiersep> query . add <identifiersep> filter ( filter ) ; } <comment> <LOG> } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } return result ; } @ override public string get <identifiersep> statement ( ) { <ect>
@ override public void on <identifiersep> event ( event event , object source , object data ) { if ( event instanceof application <identifiersep> started <identifiersep> event ) { try { environment <identifiersep> version <identifiersep> check <identifiersep> timer . initialize ( ) ; <LOG> } catch ( initialization <identifiersep> exception e ) { } } } } <ect>
<comment> private void repair <identifiersep> extension ( extension <identifiersep> id extension <identifiersep> id , string namespace , boolean dependency , map < string , extension <identifiersep> dependency > managed <identifiersep> dependencies ) throws install <identifiersep> exception { <LOG> if ( this . installed <identifiersep> repository . get <identifiersep> installed <identifiersep> extension ( extension <identifiersep> id . get <identifiersep> id ( ) , namespace ) != null ) { return ; } if ( get <identifiersep> request ( ) . is <identifiersep> verbose ( ) ) { if ( namespace != null ) { this . logger . info ( log <identifiersep> repair <identifiersep> namespace <identifiersep> begin , <string_literal> , extension <identifiersep> id , namespace ) ; <ect>
this . progress <identifiersep> manager . pop <identifiersep> level <identifiersep> progress ( this ) ; } } } private void diff ( installed <identifiersep> extension installed <identifiersep> extension , string namespace , set < local <identifiersep> document <identifiersep> reference > alreadydone ) { collection < extension <identifiersep> id > excluded <identifiersep> extensions = get <identifiersep> request ( ) . get <identifiersep> excluded <identifiersep> extensions ( ) ; if ( xar <identifiersep> extension <identifiersep> handler . type . equals ( installed <identifiersep> extension . get <identifiersep> type ( ) ) && ( excluded <identifiersep> extensions == null || ! excluded <identifiersep> extensions . contains ( installed <identifiersep> extension . get <identifiersep> id ( ) ) ) ) { <LOG> if ( get <identifiersep> request ( ) . is <identifiersep> verbose ( ) ) { namespace ) ; } try { wiki <identifiersep> reference wiki <identifiersep> reference = new wiki <identifiersep> reference ( xar <identifiersep> handler <identifiersep> utils . get <identifiersep> wiki <identifiersep> from <identifiersep> namespace ( namespace ) ) ; diff ( new xar <identifiersep> file ( new file ( installed <identifiersep> extension . get <identifiersep> file ( ) . get <identifiersep> absolute <identifiersep> path ( ) ) ) , wiki <identifiersep> reference , installed <identifiersep> extension . get <identifiersep> id ( ) , alreadydone ) ; <ect>
try { wiki <identifiersep> reference wiki <identifiersep> reference = new wiki <identifiersep> reference ( xar <identifiersep> handler <identifiersep> utils . get <identifiersep> wiki <identifiersep> from <identifiersep> namespace ( namespace ) ) ; diff ( new xar <identifiersep> file ( new file ( installed <identifiersep> extension . get <identifiersep> file ( ) . get <identifiersep> absolute <identifiersep> path ( ) ) ) , wiki <identifiersep> reference , installed <identifiersep> extension . get <identifiersep> id ( ) , alreadydone ) ; } catch ( unsupported <identifiersep> namespace <identifiersep> exception e ) { this . logger . error ( <string_literal> , namespace , e ) ; <LOG> } catch ( io <identifiersep> exception e ) { } catch ( xar <identifiersep> exception e ) { this . logger . error ( <string_literal> , installed <identifiersep> extension . get <identifiersep> id ( ) , e ) ; } } } private void diff ( xar <identifiersep> file xar <identifiersep> file , wiki <identifiersep> reference wiki <identifiersep> reference , extension <identifiersep> id extension <identifiersep> id , set < local <identifiersep> document <identifiersep> reference > alreadydone ) { <ect>
this . progress <identifiersep> manager . start <identifiersep> step ( this ) ; if ( ! alreadydone . contains ( xar <identifiersep> entry ) ) { try { diff ( this . packager . get <identifiersep> x <identifiersep> wiki <identifiersep> document ( xar <identifiersep> file . get <identifiersep> input <identifiersep> stream ( xar <identifiersep> entry ) , wiki <identifiersep> reference ) , extension <identifiersep> id ) ; } catch ( exception e ) { <LOG> <comment> <ect>
try { x <identifiersep> wiki <identifiersep> document next <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document . get <identifiersep> document <identifiersep> reference <identifiersep> with <identifiersep> locale ( ) , xcontext ) ; if ( next <identifiersep> document . is <identifiersep> new ( ) ) { next <identifiersep> document = null ; } maybe <identifiersep> add <identifiersep> document <identifiersep> diff ( this . document <identifiersep> diff <identifiersep> builder . diff ( previous <identifiersep> document , next <identifiersep> document ) ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } private void maybe <identifiersep> add <identifiersep> document <identifiersep> diff ( document <identifiersep> unified <identifiersep> diff document <identifiersep> diff ) { int differences <identifiersep> count = document <identifiersep> diff . size ( ) + document <identifiersep> diff . get <identifiersep> attachment <identifiersep> diffs ( ) . size ( ) + document <identifiersep> diff . get <identifiersep> object <identifiersep> diffs ( ) . size ( ) + document <identifiersep> diff . get <identifiersep> class <identifiersep> property <identifiersep> diffs ( ) . size ( ) ; if ( get <identifiersep> request ( ) . is <identifiersep> verbose ( ) ) { <ect>
{ int differences <identifiersep> count = document <identifiersep> diff . size ( ) + document <identifiersep> diff . get <identifiersep> attachment <identifiersep> diffs ( ) . size ( ) + document <identifiersep> diff . get <identifiersep> object <identifiersep> diffs ( ) . size ( ) + document <identifiersep> diff . get <identifiersep> class <identifiersep> property <identifiersep> diffs ( ) . size ( ) ; if ( get <identifiersep> request ( ) . is <identifiersep> verbose ( ) ) { if ( document <identifiersep> diff . get <identifiersep> next <identifiersep> reference ( ) == null ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) ) ; <LOG> } else if ( document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) == null ) { } else if ( differences <identifiersep> count > 0 ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) , differences <identifiersep> count ) ; } else { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) ) ; <ect>
this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) ) ; } else if ( document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) == null ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> next <identifiersep> reference ( ) ) ; } else if ( differences <identifiersep> count > 0 ) { this . logger . info ( <string_literal> , document <identifiersep> diff . get <identifiersep> previous <identifiersep> reference ( ) , differences <identifiersep> count ) ; <LOG> } else { } } if ( differences <identifiersep> count > 0 ) { get <identifiersep> status ( ) . get <identifiersep> document <identifiersep> diffs ( ) . add ( document <identifiersep> diff ) ; } } } <ect>
{ installed <identifiersep> extension installed <identifiersep> extension = this . installed <identifiersep> repository . get <identifiersep> installed <identifiersep> extension ( extension <identifiersep> id ) ; if ( installed <identifiersep> extension != null && installed <identifiersep> extension . get <identifiersep> type ( ) . equals ( xar <identifiersep> extension <identifiersep> handler . type ) ) { if ( get <identifiersep> installed <identifiersep> extension ( installed <identifiersep> extension . get <identifiersep> id ( ) ) == null ) { try { add <identifiersep> cache <identifiersep> xar <identifiersep> extension ( installed <identifiersep> extension ) ; <LOG> } catch ( exception e ) { } } } else { remove <identifiersep> cached <identifiersep> xar <identifiersep> extension ( extension <identifiersep> id ) ; } } private xar <identifiersep> installed <identifiersep> extension add <identifiersep> cache <identifiersep> xar <identifiersep> extension ( installed <identifiersep> extension installed <identifiersep> extension ) throws io <identifiersep> exception , xar <identifiersep> exception { <ect>
if ( ! ack ) { <comment> <LOG> } catch ( interrupted <identifiersep> exception e ) { cancelable <identifiersep> event cancelable <identifiersep> event = ( cancelable <identifiersep> event ) event ; cancelable <identifiersep> event . cancel ( <string_literal> ) ; } } } private void check <identifiersep> if <identifiersep> page <identifiersep> belong <identifiersep> to <identifiersep> extensions ( entity <identifiersep> selection entity <identifiersep> selection , extension <identifiersep> breaking <identifiersep> question question ) { xar <identifiersep> installed <identifiersep> extension <identifiersep> repository repository = ( xar <identifiersep> installed <identifiersep> extension <identifiersep> repository ) installed <identifiersep> extension <identifiersep> repository ; <ect>
x <identifiersep> wiki <identifiersep> document document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , xcontext ) ; if ( ! document . is <identifiersep> new ( ) ) { xcontext . get <identifiersep> wiki ( ) . delete <identifiersep> document ( document , xcontext ) ; if ( configuration . is <identifiersep> verbose ( ) ) { this . logger . info ( log <identifiersep> deleteddocument , <string_literal> , document . get <identifiersep> document <identifiersep> reference <identifiersep> with <identifiersep> locale ( ) ) ; } } <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } private boolean is <identifiersep> mandatory <identifiersep> document ( document <identifiersep> reference document <identifiersep> reference ) { return this . initializer <identifiersep> manager . get <identifiersep> mandatory <identifiersep> document <identifiersep> initializer ( document <identifiersep> reference ) != null ; } public x <identifiersep> wiki <identifiersep> document get <identifiersep> x <identifiersep> wiki <identifiersep> document ( wiki <identifiersep> reference wiki <identifiersep> reference , local <identifiersep> document <identifiersep> reference document <identifiersep> reference , xar <identifiersep> file xar <identifiersep> file ) throws xar <identifiersep> exception , io <identifiersep> exception <ect>
extension <identifiersep> plan plan = ( extension <identifiersep> plan ) context . get <identifiersep> property ( abstract <identifiersep> extension <identifiersep> job . contextkey <identifiersep> plan ) ; if ( plan != null ) { if ( request . is <identifiersep> verbose ( ) ) { this . logger . info ( log <identifiersep> extensionplan <identifiersep> begin , <string_literal> ) ; } context . set <identifiersep> property ( xar <identifiersep> extension <identifiersep> plan . contextkey <identifiersep> xarinstallplan , new xar <identifiersep> extension <identifiersep> plan ( plan , this . xar <identifiersep> repository , this . local <identifiersep> repository ) ) ; <LOG> if ( request . is <identifiersep> verbose ( ) ) { } } } } private xar <identifiersep> extension <identifiersep> plan get <identifiersep> xar <identifiersep> extension <identifiersep> plan ( ) { execution <identifiersep> context context = this . execution . get <identifiersep> context ( ) ; if ( context != null ) { return ( xar <identifiersep> extension <identifiersep> plan ) context . get <identifiersep> property ( xar <identifiersep> extension <identifiersep> plan . contextkey <identifiersep> xarinstallplan ) ; <ect>
private extension <identifiersep> validator get <identifiersep> extension <identifiersep> validator ( string type ) { component <identifiersep> manager component <identifiersep> manager = this . component <identifiersep> manager <identifiersep> provider . get ( ) ; if ( component <identifiersep> manager . has <identifiersep> component ( extension <identifiersep> validator . class , type ) ) { try { return component <identifiersep> manager . < extension <identifiersep> validator > get <identifiersep> instance ( extension <identifiersep> validator . class , type ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } return null ; } @ override public void check <identifiersep> install <identifiersep> internal ( extension extension , string namespace , request request ) throws install <identifiersep> exception { <comment> <ect>
extension <identifiersep> id wiki <identifiersep> ui = this . distribution <identifiersep> manager . get <identifiersep> wiki <identifiersep> ui <identifiersep> extension <identifiersep> id ( ) ; if ( wiki <identifiersep> ui != null && string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( wiki <identifiersep> ui . get <identifiersep> id ( ) ) ) { <comment> <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } else { <comment> <ect>
ui = this . distribution <identifiersep> manager . get <identifiersep> wiki <identifiersep> ui <identifiersep> extension <identifiersep> id ( ) ; } if ( ui != null && string <identifiersep> utils . is <identifiersep> not <identifiersep> blank ( ui . get <identifiersep> id ( ) ) ) { <comment> <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } else { <comment> <ect>
if ( get <identifiersep> state ( ) == null ) { set <identifiersep> state ( state . completed ) ; wiki <identifiersep> descriptor <identifiersep> manager wiki <identifiersep> descriptor <identifiersep> manager = this . wiki <identifiersep> descriptor <identifiersep> manager <identifiersep> provider . get ( ) ; collection < string > wiki <identifiersep> ids ; try { wiki <identifiersep> ids = wiki <identifiersep> descriptor <identifiersep> manager . get <identifiersep> all <identifiersep> ids ( ) ; <LOG> } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { set <identifiersep> state ( null ) ; return ; } extension <identifiersep> id wiki <identifiersep> extension <identifiersep> ui = this . distribution <identifiersep> manager . get <identifiersep> wiki <identifiersep> ui <identifiersep> extension <identifiersep> id ( ) ; if ( wiki <identifiersep> extension <identifiersep> ui != null ) { for ( string wiki <identifiersep> id : wiki <identifiersep> ids ) { <ect>
if ( is <identifiersep> main <identifiersep> wiki ( ) ) { try { if ( rights <identifiersep> manager . get <identifiersep> instance ( ) . count <identifiersep> all <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( true , null , this . xcontext <identifiersep> provider . get ( ) ) == 0 ) { <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } } } <ect>
<comment> <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e1 ) { } <comment> <ect>
distribution <identifiersep> job <identifiersep> thread . set <identifiersep> daemon ( true ) ; distribution <identifiersep> job <identifiersep> thread . set <identifiersep> name ( <string_literal> ) ; distribution <identifiersep> job <identifiersep> thread . start ( ) ; <comment> <LOG> } catch ( exception e ) { } return null ; } private list < string > get <identifiersep> wiki <identifiersep> job <identifiersep> id ( string wiki ) { return arrays . as <identifiersep> list ( jobid , <string_literal> , wiki ) ; } @ override <ect>
@ override public distribution <identifiersep> state get <identifiersep> farm <identifiersep> distribution <identifiersep> state ( ) { distribution <identifiersep> job <identifiersep> status previous <identifiersep> status = null ; try { previous <identifiersep> status = get <identifiersep> previous <identifiersep> farm <identifiersep> job <identifiersep> status ( ) ; <LOG> } catch ( exception e ) { } return get <identifiersep> distribution <identifiersep> state ( previous <identifiersep> status ) ; } @ override public distribution <identifiersep> state get <identifiersep> wiki <identifiersep> distribution <identifiersep> state ( string wiki ) { return get <identifiersep> distribution <identifiersep> state ( get <identifiersep> previous <identifiersep> wiki <identifiersep> job <identifiersep> status ( wiki ) ) ; <ect>
new wiki <identifiersep> reference ( xcontext . get <identifiersep> wiki <identifiersep> id ( ) ) ) ; } <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } return false ; } @ override public void delete <identifiersep> previous <identifiersep> wiki <identifiersep> job <identifiersep> status ( string wiki ) { this . job <identifiersep> status <identifiersep> storage . remove ( get <identifiersep> wiki <identifiersep> job <identifiersep> id ( wiki ) ) ; <ect>
protected static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( all <identifiersep> i <identifiersep> ts . class ) ; private static repository <identifiersep> utils repository <identifiersep> util ; @ x <identifiersep> wiki <identifiersep> executor <identifiersep> suite . pre <identifiersep> start public void pre <identifiersep> start ( list < x <identifiersep> wiki <identifiersep> executor > executors ) throws exception { x <identifiersep> wiki <identifiersep> executor executor = executors . get ( 0 ) ; <LOG> repository <identifiersep> util = new repository <identifiersep> utils ( ) ; properties <identifiersep> configuration properties = executor . load <identifiersep> x <identifiersep> wiki <identifiersep> properties <identifiersep> configuration ( ) ; <comment> <ect>
super . init ( context ) ; logger . info ( <string_literal> ) ; file dir = this . environment . get <identifiersep> temporary <identifiersep> directory ( ) ; temp <identifiersep> dir = new file ( dir , <string_literal> ) ; try { temp <identifiersep> dir . mkdirs ( ) ; <LOG> } catch ( exception e1 ) { dir = new file ( context . get <identifiersep> wiki ( ) . param ( <string_literal> ) ) ; try { temp <identifiersep> dir = new file ( dir , <string_literal> ) ; } catch ( exception e2 ) { logger . error ( <string_literal> + temp <identifiersep> dir , e2 ) ; <ect>
x <identifiersep> wiki <identifiersep> document annotation <identifiersep> class <identifiersep> document = deprecated <identifiersep> context . get <identifiersep> wiki ( ) . get <identifiersep> document ( annotation <identifiersep> class <identifiersep> reference , deprecated <identifiersep> context ) ; if ( this . initializer . update <identifiersep> document ( annotation <identifiersep> class <identifiersep> document ) ) { deprecated <identifiersep> context . get <identifiersep> wiki ( ) . save <identifiersep> document ( annotation <identifiersep> class <identifiersep> document , <string_literal> , deprecated <identifiersep> context ) ; } <LOG> } catch ( exception e ) { } } } <ect>
{ <comment> <LOG> object <identifiersep> to <identifiersep> properties <identifiersep> map . clear ( ) ; <comment> <ect>
<comment> <LOG> for ( document <identifiersep> reference document <identifiersep> reference : document <identifiersep> to <identifiersep> dated <identifiersep> objects <identifiersep> map . key <identifiersep> set ( ) ) { do <identifiersep> work <identifiersep> on <identifiersep> document <identifiersep> hibernate <identifiersep> callback . set <identifiersep> document <identifiersep> reference ( document <identifiersep> reference ) ; get <identifiersep> store ( ) . execute <identifiersep> write ( get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) , true , do <identifiersep> work <identifiersep> on <identifiersep> document <identifiersep> hibernate <identifiersep> callback ) ; } } <comment> <ect>
<comment> private void log <identifiersep> exception ( exception e , string target , string user ) <LOG> { } } <ect>
local <identifiersep> extension local <identifiersep> extension = this . local <identifiersep> repository . get <identifiersep> local <identifiersep> extension ( extension <identifiersep> id ) ; if ( local <identifiersep> extension == null ) { extension extension ; try { <comment> <LOG> } catch ( resolve <identifiersep> exception e ) { <comment> <ect>
try { x <identifiersep> wiki <identifiersep> document document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( reference , xcontext ) ; if ( document . get <identifiersep> translation ( ) == 1 ) { xcontext . get <identifiersep> wiki ( ) . delete <identifiersep> document ( document , xcontext ) ; this . logger . info ( <string_literal> , reference ) ; } else { <LOG> xcontext . get <identifiersep> wiki ( ) . delete <identifiersep> all <identifiersep> documents ( document , xcontext ) ; } return true ; } catch ( exception e ) { this . logger . error ( <string_literal> , reference , e ) ; return false ; } } @ override <ect>
public boolean remove <identifiersep> lock ( document <identifiersep> reference reference ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { x <identifiersep> wiki <identifiersep> document document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( reference , xcontext ) ; if ( document . get <identifiersep> lock ( xcontext ) != null ) { <LOG> document . remove <identifiersep> lock ( xcontext ) ; } return true ; } catch ( exception e ) { <comment> <ect>
try { x <identifiersep> wiki <identifiersep> document old <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( old <identifiersep> reference , xcontext ) ; int number = old <identifiersep> document . create <identifiersep> x <identifiersep> object ( redirect <identifiersep> class <identifiersep> reference , xcontext ) ; string location = this . default <identifiersep> entity <identifiersep> reference <identifiersep> serializer . serialize ( new <identifiersep> reference ) ; old <identifiersep> document . get <identifiersep> x <identifiersep> object ( redirect <identifiersep> class <identifiersep> reference , number ) . set <identifiersep> string <identifiersep> value ( <string_literal> , location ) ; old <identifiersep> document . set <identifiersep> hidden ( true ) ; <LOG> xcontext . get <identifiersep> wiki ( ) . save <identifiersep> document ( old <identifiersep> document , <string_literal> , xcontext ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { this . logger . error ( <string_literal> , old <identifiersep> reference , new <identifiersep> reference , e ) ; } } else { this . logger . warn ( <string_literal> , <ect>
if ( ! parent <identifiersep> child <identifiersep> configuration . is <identifiersep> parent <identifiersep> child <identifiersep> mechanism <identifiersep> enabled ( ) ) { document <identifiersep> reference hierarchical <identifiersep> parent = get <identifiersep> hierarchical <identifiersep> parent ( document <identifiersep> reference ) ; if ( ! hierarchical <identifiersep> parent . equals ( document . get <identifiersep> parent <identifiersep> reference ( ) ) ) { document . set <identifiersep> parent <identifiersep> reference ( hierarchical <identifiersep> parent ) ; save = true ; } } if ( save ) { <LOG> wiki . save <identifiersep> document ( document , <string_literal> , true , context ) ; } } catch ( exception e ) { this . logger . error ( <string_literal> , document <identifiersep> reference , e ) ; } } private document <identifiersep> reference get <identifiersep> hierarchical <identifiersep> parent ( document <identifiersep> reference document <identifiersep> reference ) { final string space <identifiersep> home <identifiersep> page = entity <identifiersep> reference <identifiersep> provider . get <identifiersep> default <identifiersep> reference ( entity <identifiersep> type . document ) . get <identifiersep> name ( ) ; <ect>
x <identifiersep> wiki <identifiersep> context context = this . xcontext <identifiersep> provider . get ( ) ; x <identifiersep> wiki xwiki = context . get <identifiersep> wiki ( ) ; document <identifiersep> reference deleted <identifiersep> document <identifiersep> reference = null ; try { <comment> <LOG> if ( deleted <identifiersep> document == null ) { return false ; } deleted <identifiersep> document <identifiersep> reference = deleted <identifiersep> document . get <identifiersep> document <identifiersep> reference ( ) ; <comment> <ect>
return true ; } } catch ( exception e ) { <comment> <LOG> } else { } } return false ; } @ override public list < long > get <identifiersep> deleted <identifiersep> document <identifiersep> ids ( string batch <identifiersep> id ) { x <identifiersep> wiki <identifiersep> context context = this . xcontext <identifiersep> provider . get ( ) ; <ect>
continue ; } } if ( modified ) { document . set <identifiersep> content ( xdom ) ; save <identifiersep> document <identifiersep> preserving <identifiersep> content <identifiersep> author ( document , <string_literal> , false ) ; this . logger . info ( <string_literal> , document . get <identifiersep> document <identifiersep> reference <identifiersep> with <identifiersep> locale ( ) , old <identifiersep> target , new <identifiersep> target ) ; <LOG> } else { } } private boolean rename <identifiersep> link ( block block , document <identifiersep> reference current <identifiersep> document <identifiersep> reference , document <identifiersep> reference old <identifiersep> target , document <identifiersep> reference new <identifiersep> target ) throws illegal <identifiersep> argument <identifiersep> exception { boolean modified = false ; resource <identifiersep> reference resource <identifiersep> reference = linked <identifiersep> resource <identifiersep> helper . get <identifiersep> resource <identifiersep> reference ( block ) ; <ect>
string serialized <identifiersep> link <identifiersep> reference = this . compact <identifiersep> entity <identifiersep> reference <identifiersep> serializer . serialize ( old <identifiersep> link <identifiersep> reference , new <identifiersep> document <identifiersep> reference ) ; <comment> <LOG> save <identifiersep> document <identifiersep> preserving <identifiersep> content <identifiersep> author ( document , <string_literal> , true ) ; } else { this . logger . info ( <string_literal> , document . get <identifiersep> document <identifiersep> reference ( ) ) ; } } <comment> <ect>
process ( entity <identifiersep> references . iterator ( ) . next ( ) ) ; } } @ override protected void process ( entity <identifiersep> reference source ) { <comment> <LOG> if ( source . get <identifiersep> type ( ) != destination . get <identifiersep> type ( ) ) { destination . get <identifiersep> type ( ) ) ; return ; } super . process ( source ) ; } @ override protected void process ( document <identifiersep> reference source , entity <identifiersep> reference destination ) <ect>
case document : process ( new document <identifiersep> reference ( source ) , destination ) ; break ; case space : process ( new space <identifiersep> reference ( source ) , destination ) ; break ; <LOG> default : } } private boolean is <identifiersep> descendant <identifiersep> or <identifiersep> self ( entity <identifiersep> reference alice , entity <identifiersep> reference bob ) { entity <identifiersep> reference parent = alice ; while ( parent != null && ! parent . equals ( bob ) ) { parent = parent . get <identifiersep> parent ( ) ; <ect>
{ if ( destination . get <identifiersep> type ( ) == entity <identifiersep> type . space || destination . get <identifiersep> type ( ) == entity <identifiersep> type . wiki ) { process ( source , new space <identifiersep> reference ( source . get <identifiersep> name ( ) , destination ) ) ; } else if ( destination . get <identifiersep> type ( ) == entity <identifiersep> type . document && is <identifiersep> space <identifiersep> home <identifiersep> reference ( new document <identifiersep> reference ( destination ) ) ) { process ( source , new space <identifiersep> reference ( source . get <identifiersep> name ( ) , destination . get <identifiersep> parent ( ) ) ) ; <LOG> } else { } } protected void process ( final space <identifiersep> reference source , final space <identifiersep> reference destination ) { visit <identifiersep> documents ( source , new visitor < document <identifiersep> reference > ( ) { @ override <ect>
{ <comment> <LOG> } else if ( ! this . model <identifiersep> bridge . exists ( old <identifiersep> reference ) ) { } else if ( this . request . is <identifiersep> delete <identifiersep> source ( ) && ! has <identifiersep> access ( right . delete , old <identifiersep> reference ) ) { <comment> <ect>
try { this . status . ask ( question ) ; if ( ! question . is <identifiersep> ask <identifiersep> again ( ) ) { <comment> <LOG> } catch ( interrupted <identifiersep> exception e ) { return false ; } } else { return this . overwrite <identifiersep> all ; } } private void update <identifiersep> links ( document <identifiersep> reference old <identifiersep> reference , document <identifiersep> reference new <identifiersep> reference ) { <ect>
update <identifiersep> back <identifiersep> links ( old <identifiersep> reference , new <identifiersep> reference , wiki <identifiersep> id ) ; this . progress <identifiersep> manager . end <identifiersep> step ( this ) ; } } finally { if ( pop <identifiersep> level <identifiersep> progress ) { this . progress <identifiersep> manager . pop <identifiersep> level <identifiersep> progress ( this ) ; } } } private void update <identifiersep> back <identifiersep> links ( document <identifiersep> reference old <identifiersep> reference , document <identifiersep> reference new <identifiersep> reference , string wiki <identifiersep> id ) <LOG> { list < document <identifiersep> reference > backlink <identifiersep> document <identifiersep> references = this . model <identifiersep> bridge . get <identifiersep> back <identifiersep> linked <identifiersep> references ( old <identifiersep> reference , wiki <identifiersep> id ) ; this . progress <identifiersep> manager . push <identifiersep> level <identifiersep> progress ( backlink <identifiersep> document <identifiersep> references . size ( ) , this ) ; try { for ( document <identifiersep> reference backlink <identifiersep> document <identifiersep> reference : backlink <identifiersep> document <identifiersep> references ) { <ect>
maybe <identifiersep> delete ( document <identifiersep> reference ) ; } } ) ; } private void maybe <identifiersep> delete ( document <identifiersep> reference document <identifiersep> reference ) { entity <identifiersep> selection entity <identifiersep> selection = concerned <identifiersep> entities . get ( document <identifiersep> reference ) ; if ( entity <identifiersep> selection != null && ! entity <identifiersep> selection . is <identifiersep> selected ( ) ) { <LOG> <comment> <ect>
entity <identifiersep> selection entity <identifiersep> selection = concerned <identifiersep> entities . get ( document <identifiersep> reference ) ; if ( entity <identifiersep> selection != null && ! entity <identifiersep> selection . is <identifiersep> selected ( ) ) { <comment> <LOG> } else if ( ! has <identifiersep> access ( right . delete , document <identifiersep> reference ) ) { } else { this . model <identifiersep> bridge . delete ( document <identifiersep> reference ) ; } } } <ect>
case document : process ( new document <identifiersep> reference ( entity <identifiersep> reference ) ) ; break ; case space : process ( new space <identifiersep> reference ( entity <identifiersep> reference ) ) ; break ; <LOG> default : } } private void process ( document <identifiersep> reference document <identifiersep> reference ) { <comment> <ect>
int status <identifiersep> code = abstract <identifiersep> escaping <identifiersep> test . get <identifiersep> client ( ) . execute <identifiersep> method ( get ) ; switch ( status <identifiersep> code ) { case http <identifiersep> status . sc <identifiersep> ok : <comment> <LOG> <comment> <ect>
<comment> protected list < validation <identifiersep> error > get <identifiersep> under <identifiersep> escaping <identifiersep> errors ( string url ) { <LOG> <comment> <ect>
while ( ( line = reader . read <identifiersep> line ( ) ) != null ) { matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) && matcher . group <identifiersep> count ( ) == <number_literal> ) { return matcher . group ( <number_literal> ) ; } } } catch ( io <identifiersep> exception exception ) { exception . print <identifiersep> stack <identifiersep> trace ( ) ; } <LOG> <comment> <ect>
matcher matcher = pattern . compile ( <string_literal> ) . matcher ( body ) ; if ( matcher . find ( ) && matcher . group <identifiersep> count ( ) == <number_literal> ) { this . secret <identifiersep> token = matcher . group ( <number_literal> ) ; return this . secret <identifiersep> token ; } } catch ( io <identifiersep> exception exception ) { exception . print <identifiersep> stack <identifiersep> trace ( ) ; } <LOG> <comment> <ect>
boolean has <identifiersep> error = false ; for ( validation <identifiersep> error error : errors ) { if ( error . get <identifiersep> type ( ) == validation <identifiersep> error . type . warning ) { if ( error . get <identifiersep> line ( ) >= 0 ) { system . out . println ( <string_literal> + error . get <identifiersep> line ( ) + <string_literal> + error . get <identifiersep> column ( ) + <string_literal> + error . get <identifiersep> message ( ) ) ; <LOG> } else { } } else { if ( error . get <identifiersep> line ( ) >= 0 ) { message . append ( <string_literal> + error . to <identifiersep> string ( ) + <string_literal> + error . get <identifiersep> line ( ) + <string_literal> + error . get <identifiersep> column ( ) + <string_literal> ) ; } else { <ect>
message . append ( <string_literal> + error . to <identifiersep> string ( ) + <string_literal> + error . get <identifiersep> line ( ) + <string_literal> + error . get <identifiersep> column ( ) + <string_literal> ) ; } else { message . append ( <string_literal> + error . to <identifiersep> string ( ) ) ; } has <identifiersep> error = true ; } } if ( has <identifiersep> error ) { <LOG> system . err . println ( <string_literal> ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new string <identifiersep> reader ( new string ( response <identifiersep> body ) ) ) ; int index = 1 ; for ( string line = reader . read <identifiersep> line ( ) ; line != null ; line = reader . read <identifiersep> line ( ) , ++ index ) { system . err . println ( index + <string_literal> + line ) ; } } assert <identifiersep> false ( message . to <identifiersep> string ( ) , has <identifiersep> error ) ; <ect>
boolean has <identifiersep> error = false ; for ( validation <identifiersep> error error : errors ) { if ( error . get <identifiersep> type ( ) == validation <identifiersep> error . type . warning ) { if ( error . get <identifiersep> line ( ) >= 0 ) { system . out . println ( <string_literal> + error . get <identifiersep> line ( ) + <string_literal> + error . get <identifiersep> column ( ) + <string_literal> + error . get <identifiersep> message ( ) ) ; <LOG> } else { } } else { if ( error . get <identifiersep> line ( ) >= 0 ) { message . append ( <string_literal> + error . to <identifiersep> string ( ) + <string_literal> + error . get <identifiersep> line ( ) + <string_literal> + error . get <identifiersep> column ( ) + <string_literal> ) ; } else { <ect>
error <identifiersep> lines . add ( error . get <identifiersep> line ( ) - 1 ) ; error <identifiersep> lines . add ( error . get <identifiersep> line ( ) ) ; error <identifiersep> lines . add ( error . get <identifiersep> line ( ) + 1 ) ; error <identifiersep> lines . add ( error . get <identifiersep> line ( ) + <number_literal> ) ; has <identifiersep> error = true ; } } if ( has <identifiersep> error ) { <LOG> system . err . println ( <string_literal> ) ; message . append ( <string_literal> ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new string <identifiersep> reader ( new string ( response <identifiersep> body ) ) ) ; int index = 1 ; int last <identifiersep> error <identifiersep> line = - 1 ; for ( string line = reader . read <identifiersep> line ( ) ; line != null ; line = reader . read <identifiersep> line ( ) , ++ index ) { <ect>
<comment> <LOG> logger . info ( delimiter ) ; } @ override public void life <identifiersep> cycle <identifiersep> stopped ( life <identifiersep> cycle event ) { logger . info ( messages . get <identifiersep> string ( <string_literal> ) ) ; } } <ect>
