try { file <identifiersep> icon = file <identifiersep> system <identifiersep> view . get <identifiersep> file <identifiersep> system <identifiersep> view ( ) . get <identifiersep> system <identifiersep> icon ( file ) ; } catch ( exception e ) { <LOG> <comment> try { file <identifiersep> icon = new j <identifiersep> file <identifiersep> chooser ( ) . get <identifiersep> icon ( file ) ; } catch ( exception e1 ) <ect>
<comment> private static final random random = new random ( ) ; static { string prefer6 = system . get <identifiersep> property ( <string_literal> ) ; string prefer4 = system . get <identifiersep> property ( <string_literal> ) ; <LOG> logger . info ( <string_literal> + prefer4 ) ; } <comment> <ect>
if ( ! use <identifiersep> dns <identifiersep> cache ) { lookup . set <identifiersep> cache ( new cache ( ) ) ; } records = lookup . run ( ) ; } catch ( text <identifiersep> parse <identifiersep> exception tpe ) { <LOG> throw new parse <identifiersep> exception ( tpe . get <identifiersep> message ( ) , 0 ) ; } catch ( dnssec <identifiersep> runtime <identifiersep> exception e ) { throw new dnssec <identifiersep> exception ( e ) ; } if ( records == null ) { <ect>
try { lookup lookup = create <identifiersep> lookup ( domain , type . naptr ) ; records = lookup . run ( ) ; } catch ( text <identifiersep> parse <identifiersep> exception tpe ) { <LOG> throw new parse <identifiersep> exception ( tpe . get <identifiersep> message ( ) , 0 ) ; } catch ( dnssec <identifiersep> runtime <identifiersep> exception e ) { throw new dnssec <identifiersep> exception ( e ) ; } if ( records == null ) <ect>
while ( keep <identifiersep> accepting ) { socket instance <identifiersep> socket = lock <identifiersep> socket . accept ( ) ; new lock <identifiersep> server <identifiersep> connection <identifiersep> processor ( instance <identifiersep> socket ) . start ( ) ; } } catch ( exception exc ) { <LOG> } } } <comment> private static class lock <identifiersep> server <identifiersep> connection <identifiersep> processor extends thread { <ect>
catch ( io <identifiersep> exception exc ) { <comment> <LOG> } <comment> <ect>
<comment> private void handle <identifiersep> uri ( string uri ) { <LOG> arg <identifiersep> delegator . handle <identifiersep> uri ( uri ) ; } <comment> <ect>
if ( name == null || name . trim ( ) . length ( ) == 0 ) { name = <string_literal> ; } if ( version == null || version . trim ( ) . length ( ) == 0 ) { version = <string_literal> ; } <LOG> } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <LOG> if ( m <identifiersep> update <identifiersep> executor != null ) { m <identifiersep> update <identifiersep> executor . shutdown ( ) ; m <identifiersep> update <identifiersep> executor = null ; } } <comment> <ect>
{ service <identifiersep> listener . service <identifiersep> changed ( new service <identifiersep> event ( service <identifiersep> event . registered , service <identifiersep> reference ) ) ; } } <LOG> } <comment> <ect>
if ( hresult < 0 ) throw new runtime <identifiersep> exception ( <string_literal> + hresult ) ; } finally { messenger . stop ( bundle <identifiersep> context ) ; } <LOG> } <comment> <ect>
server <identifiersep> comments = xml <identifiersep> utils . new <identifiersep> document <identifiersep> builder <identifiersep> factory ( ) . new <identifiersep> document <identifiersep> builder ( ) . parse ( resources . get <identifiersep> property <identifiersep> input <identifiersep> stream ( <string_literal> ) ) ; } catch ( sax <identifiersep> exception e ) { <LOG> } catch ( parser <identifiersep> configuration <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; <ect>
color c = color . get <identifiersep> color ( <string_literal> , color ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> line ( id , t , c , p <identifiersep> start , p <identifiersep> end ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> rect ) { whiteboard <identifiersep> object <identifiersep> rect rect = ( whiteboard <identifiersep> object <identifiersep> rect ) wbo ; <LOG> color c = color . get <identifiersep> color ( <string_literal> , color ) ; double height , width ; whiteboard <identifiersep> point p = rect . get <identifiersep> whiteboard <identifiersep> point ( ) ; width = rect . get <identifiersep> width ( ) ; height = rect . get <identifiersep> height ( ) ; boolean fill = rect . is <identifiersep> fill ( ) ; <ect>
boolean fill = circle . is <identifiersep> fill ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> circle ( id , t , c , p , r , fill ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> text ) { whiteboard <identifiersep> object <identifiersep> text text = ( whiteboard <identifiersep> object <identifiersep> text ) wbo ; <LOG> color c = color . get <identifiersep> color ( <string_literal> , color ) ; whiteboard <identifiersep> point p = text . get <identifiersep> whiteboard <identifiersep> point ( ) ; int size = text . get <identifiersep> font <identifiersep> size ( ) ; string txt = text . get <identifiersep> text ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> text ( id , c , p , size , txt ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> image ) <ect>
{ public void whiteboard <identifiersep> participant <identifiersep> added ( whiteboard <identifiersep> participant <identifiersep> event evt ) { } public void whiteboard <identifiersep> participant <identifiersep> removed ( whiteboard <identifiersep> participant <identifiersep> event evt ) { <LOG> whiteboard <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( contact . get <identifiersep> address ( ) + <string_literal> ) ; } public void whiteboard <identifiersep> state <identifiersep> changed ( whiteboard <identifiersep> change <identifiersep> event evt ) { } } } <ect>
= contact . get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> whiteboarding . class ) ; if ( op <identifiersep> set <identifiersep> wb == null ) { <LOG> return ; } whiteboard <identifiersep> frame wbf = get <identifiersep> whiteboard <identifiersep> frame ( contact ) ; if ( wbf != null ) { wbf . set <identifiersep> visible ( true ) ; return ; <ect>
+ <string_literal> + task . delay + <string_literal> ) ; timer . schedule ( task , task . delay ) ; } return ; } pp . unregister ( ) ; } catch ( throwable t ) { <LOG> } } } ) . start ( ) ; } <comment> private void trace <identifiersep> current <identifiersep> pp <identifiersep> state ( ) <ect>
{ logger . trace ( <string_literal> + connected <identifiersep> interfaces ) ; logger . trace ( <string_literal> + auto <identifiersep> reconn <identifiersep> enabled <identifiersep> providers . key <identifiersep> set ( ) ) ; logger . trace ( <string_literal> + currently <identifiersep> reconnecting . key <identifiersep> set ( ) ) ; <LOG> logger . trace ( <string_literal> + unregistering <identifiersep> providers ) ; logger . trace ( <string_literal> ) ; } <comment> <ect>
logger . trace ( <string_literal> + auto <identifiersep> reconn <identifiersep> enabled <identifiersep> providers . key <identifiersep> set ( ) ) ; logger . trace ( <string_literal> + currently <identifiersep> reconnecting . key <identifiersep> set ( ) ) ; logger . trace ( <string_literal> + needs <identifiersep> reconnection ) ; logger . trace ( <string_literal> + unregistering <identifiersep> providers ) ; <LOG> } <comment> <ect>
&& currently <identifiersep> reconnecting . contains <identifiersep> key ( pp ) ) { currently <identifiersep> reconnecting . remove ( pp ) . cancel ( ) ; } unregistering <identifiersep> providers . remove ( pp ) ; { <LOG> if ( ! currently <identifiersep> reconnecting . contains <identifiersep> key ( pp ) && ! needs <identifiersep> reconnection . contains ( pp ) { <comment> <ect>
{ <comment> <LOG> entry . set <identifiersep> sound <identifiersep> file ( file <identifiersep> uri ) ; sound <identifiersep> file <identifiersep> text <identifiersep> field . set <identifiersep> text ( file <identifiersep> uri ) ; } catch ( malformed <identifiersep> url <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } else <ect>
catch ( malformed <identifiersep> url <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } else { <LOG> } } else if ( e . get <identifiersep> source ( ) == program <identifiersep> file <identifiersep> button ) { if ( row < 0 ) return ; notification <identifiersep> entry entry = notification <identifiersep> list . get <identifiersep> notification <identifiersep> entry ( row ) ; <ect>
entry . set <identifiersep> program <identifiersep> file ( file . get <identifiersep> absolute <identifiersep> path ( ) ) ; program <identifiersep> file <identifiersep> text <identifiersep> field . set <identifiersep> text ( file . get <identifiersep> absolute <identifiersep> path ( ) ) ; } else { <LOG> } } else if ( e . get <identifiersep> source ( ) == play <identifiersep> sound <identifiersep> button ) { string sound <identifiersep> file = sound <identifiersep> file <identifiersep> text <identifiersep> field . get <identifiersep> text ( ) ; logger . debug ( <string_literal> + sound <identifiersep> file + <string_literal> + sound <identifiersep> file . length ( ) ) ; if ( sound <identifiersep> file . length ( ) != 0 ) <ect>
sc <identifiersep> audio <identifiersep> clip sound = audio <identifiersep> notif <identifiersep> serv . create <identifiersep> audio ( sound <identifiersep> file ) ; sound . play ( ) ; <comment> <LOG> } } } <comment> public void insert <identifiersep> update ( document <identifiersep> event event ) { <ect>
<comment> <LOG> return null ; } } <comment> <ect>
reload <identifiersep> configuration ( ) ; } catch ( exception e ) { logger . error ( <string_literal> ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } finally { try { in . close ( ) ; } catch ( io <identifiersep> exception e ) <ect>
system . set <identifiersep> property ( sys <identifiersep> key , ( string ) value ) ; } else { provisioning <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . set <identifiersep> property ( key , value ) ; } <LOG> } <comment> <ect>
. bundle <identifiersep> context . install <identifiersep> bundle ( jar . to <identifiersep> uri ( ) . to <identifiersep> url ( ) . to <identifiersep> string ( ) ) ; selector . select <identifiersep> no <identifiersep> skin ( ) ; new <identifiersep> bundle . start ( ) ; } catch ( malformed <identifiersep> url <identifiersep> exception ex ) { <LOG> } } } catch ( bundle <identifiersep> exception ex ) { logger . info ( <string_literal> , ex ) ; skin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; <ect>
<comment> protected void catch <identifiersep> exception ( throwable exception ) { <LOG> } <comment> protected abstract object construct ( ) throws exception ; <comment> <ect>
signup <identifiersep> link ) ; try { swing <identifiersep> utilities . invoke <identifiersep> and <identifiersep> wait ( creator ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } catch ( invocation <identifiersep> target <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } return creator . authentication <identifiersep> window ; } } , null ) ; <ect>
return null ; try { image = image <identifiersep> io . read ( path ) ; } catch ( exception exc ) { <LOG> } return image ; } <comment> <ect>
swing <identifiersep> utilities . invoke <identifiersep> and <identifiersep> wait ( creator ) ; } catch ( interrupted <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( invocation <identifiersep> target <identifiersep> exception e ) { <LOG> } return creator . dialog ; } <comment> public static account <identifiersep> manager get <identifiersep> account <identifiersep> manager ( ) <ect>
<comment> <LOG> } list < protocol <identifiersep> provider <identifiersep> service > providers <identifiersep> list = new array <identifiersep> list < protocol <identifiersep> provider <identifiersep> service > ( ) ; if ( ser <identifiersep> refs != null ) { for ( service <identifiersep> reference ser <identifiersep> ref : ser <identifiersep> refs ) { <ect>
configuration <identifiersep> service config <identifiersep> service = protocol <identifiersep> provider <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) ; string factory <identifiersep> package = get <identifiersep> factory <identifiersep> impl <identifiersep> package <identifiersep> name ( factory ) ; list < string > accounts = config <identifiersep> service . get <identifiersep> property <identifiersep> names <identifiersep> by <identifiersep> prefix ( factory <identifiersep> package , true ) ; <LOG> + factory <identifiersep> package + <string_literal> ) ; for ( iterator < string > stored <identifiersep> account <identifiersep> iter = accounts . iterator ( ) ; stored <identifiersep> account <identifiersep> iter . has <identifiersep> next ( ) ; ) { string stored <identifiersep> account = stored <identifiersep> account <identifiersep> iter . next ( ) ; <comment> <ect>
catch ( exception ex ) { <comment> <LOG> } catch ( exception <identifiersep> in <identifiersep> initializer <identifiersep> error ex ) { <comment> <ect>
{ media <identifiersep> type media <identifiersep> type = device . get <identifiersep> media <identifiersep> type ( ) ; media <identifiersep> stream stream = get <identifiersep> stream ( call <identifiersep> peer <identifiersep> media <identifiersep> handler , media <identifiersep> type ) ; if ( stream == null ) { <LOG> media <identifiersep> service media <identifiersep> service = protocol <identifiersep> media <identifiersep> activator . get <identifiersep> media <identifiersep> service ( ) ; srtp <identifiersep> control srtp <identifiersep> control = srtp <identifiersep> controls . find <identifiersep> first ( media <identifiersep> type ) ; <comment> <ect>
logger . trace ( <string_literal> ) ; } } } else { { <LOG> } presence <identifiersep> status presence <identifiersep> status = forget <identifiersep> presence <identifiersep> status ( pps ) ; if ( ( presence <identifiersep> status != null ) && on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status . equals ( presence . get <identifiersep> presence <identifiersep> status ( ) ) ) <ect>
logger . trace ( <string_literal> ) ; } publish <identifiersep> presence <identifiersep> status ( presence , presence <identifiersep> status ) ; } } } else { { <LOG> } <comment> forget <identifiersep> presence <identifiersep> status ( pps ) ; } } } } } <comment> <ect>
try { icon = new byte [ is . available ( ) ] ; is . read ( icon ) ; } catch ( io <identifiersep> exception exc ) { <LOG> } finally { try { if ( is != null ) is . close ( ) ; } catch ( io <identifiersep> exception ex ) <ect>
return null ; byte [ ] icon = null ; try { icon = new byte [ is . available ( ) ] ; is . read ( icon ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return icon ; } } <ect>
bundle <identifiersep> context . register <identifiersep> service ( provisioning <identifiersep> discovery <identifiersep> service . class . get <identifiersep> name ( ) , provisioning <identifiersep> service , null ) ; provisioning <identifiersep> discovery <identifiersep> dhcp <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; <LOG> } <comment> <ect>
for ( dhcp <identifiersep> transaction t : transactions ) { t . cancel ( ) ; } return new string ( opt <identifiersep> provisioning . get <identifiersep> value ( ) ) ; } } } catch ( socket <identifiersep> timeout <identifiersep> exception est ) { <LOG> } } catch ( exception e ) { logger . warn ( <string_literal> , e ) ; } for ( dhcp <identifiersep> transaction t : transactions ) { t . cancel ( ) ; <ect>
try { discover = new dhcp <identifiersep> provisioning <identifiersep> discover ( <number_literal> , ( byte ) <number_literal> ) ; discover . add <identifiersep> discovery <identifiersep> listener ( this ) ; } catch ( exception e ) { <LOG> } } <comment> <ect>
l . plugin <identifiersep> component <identifiersep> added ( evt ) ; break ; case plugin <identifiersep> component <identifiersep> event . plugin <identifiersep> component <identifiersep> removed : l . plugin <identifiersep> component <identifiersep> removed ( evt ) ; break ; default : <LOG> break ; } } } } } <comment> <ect>
this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( null <identifiersep> pointer <identifiersep> exception e ) { <LOG> this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( unsupported <identifiersep> operation <identifiersep> exception e ) { <ect>
this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( security <identifiersep> exception e ) { <LOG> this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( io <identifiersep> exception e ) { <ect>
this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( exception e ) { <LOG> this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } } else if ( source <identifiersep> button . equals ( cancel <identifiersep> button ) ) { if ( file <identifiersep> transfer != null ) <ect>
service <identifiersep> utils . get <identifiersep> service ( gui <identifiersep> activator . bundle <identifiersep> context , message <identifiersep> history <identifiersep> service . class ) . erase <identifiersep> locally <identifiersep> stored <identifiersep> history ( ) ; service <identifiersep> utils . get <identifiersep> service ( gui <identifiersep> activator . bundle <identifiersep> context , file <identifiersep> history <identifiersep> service . class ) . erase <identifiersep> locally <identifiersep> stored <identifiersep> history ( ) ; } catch ( io <identifiersep> exception ex ) { <LOG> chat <identifiersep> panel . add <identifiersep> error <identifiersep> message ( <string_literal> , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , ex . get <identifiersep> localized <identifiersep> message ( ) ) ; } } } } <comment> <ect>
try { element elem = document . get <identifiersep> element ( message <identifiersep> id ) ; document . set <identifiersep> outer <identifiersep> html ( elem , new <identifiersep> message ) ; } catch ( bad <identifiersep> location <identifiersep> exception ex ) { <LOG> } catch ( io <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } } } @ override public object construct ( ) throws exception { <ect>
<comment> public void invitation <identifiersep> received ( ad <identifiersep> hoc <identifiersep> chat <identifiersep> room <identifiersep> invitation <identifiersep> received <identifiersep> event evt ) { <LOG> operation <identifiersep> set <identifiersep> ad <identifiersep> hoc <identifiersep> multi <identifiersep> user <identifiersep> chat multi <identifiersep> user <identifiersep> chat <identifiersep> op <identifiersep> set = evt . get <identifiersep> source <identifiersep> operation <identifiersep> set ( ) ; invitation <identifiersep> received <identifiersep> dialog dialog = new invitation <identifiersep> received <identifiersep> dialog ( this , multi <identifiersep> user <identifiersep> chat <identifiersep> op <identifiersep> set , evt . get <identifiersep> invitation ( ) ) ; dialog . set <identifiersep> visible ( true ) ; } <comment> <ect>
<comment> public void remove <identifiersep> all <identifiersep> chats ( ) { <LOG> if ( tabbed <identifiersep> pane . get <identifiersep> tab <identifiersep> count ( ) > 0 ) { this . tabbed <identifiersep> pane . remove <identifiersep> all ( ) ; conversation <identifiersep> count = 0 ; if ( tabbed <identifiersep> pane . get <identifiersep> tab <identifiersep> count ( ) == 0 ) set <identifiersep> toolbar <identifiersep> visible ( false ) ; <ect>
string display <identifiersep> name = account <identifiersep> info <identifiersep> utils . get <identifiersep> display <identifiersep> name ( account <identifiersep> info <identifiersep> op <identifiersep> set ) ; if ( display <identifiersep> name != null && display <identifiersep> name . length ( ) > 0 ) return display <identifiersep> name ; } } catch ( throwable e ) { <LOG> } return protocol <identifiersep> provider . get <identifiersep> account <identifiersep> id ( ) . get <identifiersep> display <identifiersep> name ( ) ; } <comment> <ect>
recorder recorder ; try { recorder = get <identifiersep> recorder ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ofex ) { <LOG> return false ; } list < string > supported <identifiersep> formats = recorder . get <identifiersep> supported <identifiersep> formats ( ) ; return ( supported <identifiersep> formats != null ) && supported <identifiersep> formats . contains ( format ) ; } <comment> <ect>
= call <identifiersep> peer . get <identifiersep> protocol <identifiersep> provider ( ) . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> desktop <identifiersep> sharing <identifiersep> server . class ) ; if ( op <identifiersep> set <identifiersep> desktop <identifiersep> sharing <identifiersep> server != null && op <identifiersep> set <identifiersep> desktop <identifiersep> sharing <identifiersep> server . is <identifiersep> remote <identifiersep> control <identifiersep> available ( call <identifiersep> peer ) ) { <LOG> if ( enable <identifiersep> desktop <identifiersep> remote <identifiersep> control == null ) { enable <identifiersep> desktop <identifiersep> remote <identifiersep> control = new j <identifiersep> check <identifiersep> box ( gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; south <identifiersep> panel = new transparent <identifiersep> panel ( <ect>
{ if ( t instanceof interrupted <identifiersep> exception ) thread . current <identifiersep> thread ( ) . interrupt ( ) ; else if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; else <LOG> } } <comment> public static class dtmf <identifiersep> tone <identifiersep> info { <comment> <ect>
{ logger . info ( <string_literal> ) ; return ; } command = string . format ( command , call <identifiersep> peers . get ( 0 ) . get <identifiersep> address ( ) ) ; try { <LOG> runtime . get <identifiersep> runtime ( ) . exec ( command ) ; } catch ( io <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } } } <comment> <ect>
fire <identifiersep> change <identifiersep> event ( event <identifiersep> to <identifiersep> process . get <identifiersep> key ( ) , listeners <identifiersep> copy . get ( i ) ) ; } } event <identifiersep> to <identifiersep> process = null ; listeners <identifiersep> copy = null ; } } catch ( throwable t ) { <LOG> } } <comment> public void stop ( ) { synchronized ( events <identifiersep> to <identifiersep> dispatch ) <ect>
network <identifiersep> ams . start ( ) ; logger . info ( <string_literal> ) ; bundle <identifiersep> context . register <identifiersep> service ( network <identifiersep> address <identifiersep> manager <identifiersep> service . class . get <identifiersep> name ( ) , network <identifiersep> ams , null ) ; <LOG> } finally { logger . log <identifiersep> exit ( ) ; } } <comment> <ect>
{ byte [ ] src = win32localhost <identifiersep> retriever . get <identifiersep> source <identifiersep> for <identifiersep> destination ( intended <identifiersep> destination . get <identifiersep> address ( ) ) ; if ( src == null ) { <LOG> } else { try { local <identifiersep> host = inet <identifiersep> address . get <identifiersep> by <identifiersep> address ( src ) ; } catch ( unknown <identifiersep> host <identifiersep> exception uhe ) <ect>
{ local <identifiersep> host = bsd <identifiersep> localhost <identifiersep> retriever . get <identifiersep> local <identifiersep> socket <identifiersep> address ( new inet <identifiersep> socket <identifiersep> address ( intended <identifiersep> destination , random <identifiersep> addr <identifiersep> disc <identifiersep> port ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } else { <comment> <ect>
string forwarders = dns <identifiersep> util <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> string ( dns <identifiersep> util <identifiersep> activator . pname <identifiersep> dnssec <identifiersep> nameservers ) ; if ( ! string <identifiersep> utils . is <identifiersep> null <identifiersep> or <identifiersep> empty ( forwarders , true ) ) { { <LOG> } synchronized ( lookup . class ) { lookup . refresh <identifiersep> default ( ) ; string [ ] fwds = forwarders . split ( <string_literal> ) ; resolver [ ] rs = head <identifiersep> resolver . get <identifiersep> resolvers ( ) ; for ( resolver r : rs ) <ect>
try { super . load <identifiersep> trust <identifiersep> anchors ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( sb . to <identifiersep> string ( ) . get <identifiersep> bytes ( <string_literal> ) ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> logger . trace ( <string_literal> + sb . to <identifiersep> string ( ) ) ; } } <ect>
<comment> public void start ( bundle <identifiersep> context context ) throws exception { <LOG> bundle <identifiersep> context = context ; context . add <identifiersep> service <identifiersep> listener ( this ) ; options . set ( <string_literal> , <string_literal> ) ; lookup . set <identifiersep> packet <identifiersep> logger ( new dns <identifiersep> java <identifiersep> logger ( ) ) ; if ( load <identifiersep> dns <identifiersep> proxy <identifiersep> forward ( ) ) <ect>
custom <identifiersep> resolver . pdefault <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled ) ) { bundle <identifiersep> context . register <identifiersep> service ( custom <identifiersep> resolver . class . get <identifiersep> name ( ) , new configurable <identifiersep> dnssec <identifiersep> resolver ( new extended <identifiersep> resolver ( ) ) , null ) ; <LOG> } logger . info ( <string_literal> ) ; } <comment> <ect>
config <identifiersep> service . add <identifiersep> property <identifiersep> change <identifiersep> listener ( message <identifiersep> history <identifiersep> service . pname <identifiersep> is <identifiersep> message <identifiersep> history <identifiersep> enabled , msg <identifiersep> history <identifiersep> prop <identifiersep> listener ) ; if ( is <identifiersep> message <identifiersep> history <identifiersep> enabled ) { <LOG> this . load <identifiersep> message <identifiersep> history <identifiersep> service ( ) ; } } <comment> private void load <identifiersep> recent <identifiersep> messages ( ) { <ect>
if ( is <identifiersep> present ) return ; } write <identifiersep> message ( history , <string_literal> , evt . get <identifiersep> message ( ) , evt . get <identifiersep> timestamp ( ) , false ) ; } catch ( io <identifiersep> exception e ) { <LOG> } } public void message <identifiersep> delivery <identifiersep> failed ( chat <identifiersep> room <identifiersep> message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { } <comment> <ect>
message . get <identifiersep> encoding ( ) , message . get <identifiersep> message <identifiersep> uid ( ) , message . get <identifiersep> subject ( ) , sdf . format ( message <identifiersep> timestamp ) , is <identifiersep> sms <identifiersep> subtype ? msg <identifiersep> subtype <identifiersep> sms : null } , new date ( ) ) ; <comment> <LOG> } } <comment> <ect>
from . get <identifiersep> address ( ) , sdf . format ( message <identifiersep> timestamp ) , null } , new date ( ) ) ; <comment> <LOG> } } <comment> <ect>
byte [ ] photo = null ; initial <identifiersep> dir <identifiersep> context dir <identifiersep> context = null ; <comment> final search <identifiersep> controls search <identifiersep> ctl = new search <identifiersep> controls ( ) ; search <identifiersep> ctl . set <identifiersep> search <identifiersep> scope ( search <identifiersep> controls . object <identifiersep> scope ) ; search <identifiersep> ctl . set <identifiersep> returning <identifiersep> attributes ( photo <identifiersep> attributes ) ; <LOG> try { dir <identifiersep> context = connect ( ) ; string new <identifiersep> base <identifiersep> dn ; if ( settings . get <identifiersep> base <identifiersep> dn ( ) . equals ( <string_literal> ) ) new <identifiersep> base <identifiersep> dn = dn ; <ect>
<comment> public void start ( bundle <identifiersep> context bc ) { <LOG> bundle <identifiersep> context = bc ; server <identifiersep> set = new ldap <identifiersep> directory <identifiersep> set <identifiersep> impl ( get <identifiersep> config <identifiersep> service ( ) ) ; load <identifiersep> persistent <identifiersep> config ( ) ; } <comment> <ect>
<comment> ldap <identifiersep> service = new ldap <identifiersep> service <identifiersep> impl ( ) ; ldap <identifiersep> service . start ( bundle <identifiersep> context ) ; bundle <identifiersep> context . register <identifiersep> service ( ldap <identifiersep> service . class . get <identifiersep> name ( ) , ldap <identifiersep> service , null ) ; <LOG> if ( ldap <identifiersep> service . get <identifiersep> server <identifiersep> set ( ) . size ( ) == 0 ) { return ; } for ( ldap <identifiersep> directory ldap <identifiersep> dir : get <identifiersep> ldap <identifiersep> service ( ) . get <identifiersep> server <identifiersep> set ( ) ) { if ( ! ldap <identifiersep> dir . get <identifiersep> settings ( ) . is <identifiersep> enabled ( ) ) <ect>
logger . debug ( <string_literal> ) ; service <identifiersep> registration = bundle <identifiersep> context . register <identifiersep> service ( hid <identifiersep> service . class . get <identifiersep> name ( ) , new hid <identifiersep> service <identifiersep> impl ( ) , null ) ; <LOG> } <comment> <ect>
meta <identifiersep> contact <identifiersep> group mc <identifiersep> group = evt . get <identifiersep> source <identifiersep> meta <identifiersep> contact <identifiersep> group ( ) ; element mc <identifiersep> group <identifiersep> node = find <identifiersep> meta <identifiersep> contact <identifiersep> group <identifiersep> node ( mc <identifiersep> group . get <identifiersep> meta <identifiersep> uid ( ) ) ; <comment> <LOG> logger . trace ( <string_literal> , new exception ( ) ) ; return ; } switch ( evt . get <identifiersep> event <identifiersep> id ( ) ) <ect>
element old <identifiersep> mc <identifiersep> node = find <identifiersep> meta <identifiersep> contact <identifiersep> node ( evt . get <identifiersep> old <identifiersep> parent ( ) . get <identifiersep> meta <identifiersep> uid ( ) ) ; <comment> <LOG> + old <identifiersep> mc <identifiersep> node ) ; return ; } if ( new <identifiersep> mc <identifiersep> node == null ) { logger . error ( <string_literal> + new <identifiersep> mc <identifiersep> node ) ; <ect>
if ( contact . get <identifiersep> presence <identifiersep> status ( ) . is <identifiersep> online ( ) ) { online <identifiersep> contacts <identifiersep> number ++ ; } } } catch ( exception e ) { <LOG> } return online <identifiersep> contacts <identifiersep> number ; } <comment> <ect>
{ byte [ ] contact <identifiersep> image = contact . get <identifiersep> image ( ) ; if ( ( contact <identifiersep> image != null ) && ( contact <identifiersep> image . length > 0 ) ) return contact <identifiersep> image ; } catch ( exception ex ) { <LOG> } return null ; } <comment> <ect>
version <identifiersep> activator . bundle <identifiersep> context = context ; context . register <identifiersep> service ( version <identifiersep> service . class . get <identifiersep> name ( ) , new version <identifiersep> service <identifiersep> impl ( ) , null ) ; <LOG> version version = version <identifiersep> impl . current <identifiersep> version ( ) ; string application <identifiersep> name = version . get <identifiersep> application <identifiersep> name ( ) ; string version <identifiersep> string = version . to <identifiersep> string ( ) ; { logger . info ( <ect>
if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; else { systray = null ; if ( ! graphics <identifiersep> environment . is <identifiersep> headless ( ) ) <LOG> } } this . systray = systray ; if ( this . systray != null ) { init <identifiersep> systray ( ) ; } } @ override public map < string , string > get <identifiersep> systray <identifiersep> modes ( ) <ect>
try { task <identifiersep> bar <identifiersep> list3 . get <identifiersep> instance ( ) . set <identifiersep> overlay <identifiersep> icon ( ( component ) main <identifiersep> window . get <identifiersep> source ( ) , img , null ) ; } catch ( exception ex ) { <LOG> } } } private buffered <identifiersep> image create <identifiersep> overlay <identifiersep> image ( string text ) { int size = <number_literal> ; buffered <identifiersep> image image = new buffered <identifiersep> image ( size , size , buffered <identifiersep> image . type <identifiersep> int <identifiersep> argb ) ; graphics2d g = image . create <identifiersep> graphics ( ) ; <ect>
{ for ( component em : components ) { popup <identifiersep> menu <identifiersep> peer peer = new popup <identifiersep> menu <identifiersep> peer ( parent , em ) ; if ( em instanceof j <identifiersep> popup <identifiersep> menu . separator ) { <LOG> peer . gtk <identifiersep> menu <identifiersep> item = gtk . gtk <identifiersep> separator <identifiersep> menu <identifiersep> item <identifiersep> new ( ) ; } if ( em instanceof j <identifiersep> menu <identifiersep> item ) { create <identifiersep> gtk <identifiersep> menu <identifiersep> item ( peer ) ; } if ( em instanceof j <identifiersep> menu && peer . gtk <identifiersep> menu <identifiersep> item != null ) { <ect>
hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> vbox7impl . vbox7 <identifiersep> config <identifiersep> label ) ; vbox7source = new replacement <identifiersep> service <identifiersep> vbox7impl ( ) ; vbox7serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , vbox7source , hashtable ) ; <LOG> } <comment> <ect>
public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> vbox7impl ( ) { <LOG> } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { twitpic <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } } <ect>
public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> metacafe <identifiersep> impl ( ) { <LOG> } <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { vimeo <identifiersep> serv <identifiersep> reg . unregister ( ) ; <LOG> } } <ect>
+ <string_literal> ) ; return ; } mock <identifiersep> call <identifiersep> peer call <identifiersep> peer = ( mock <identifiersep> call <identifiersep> peer ) peer ; <LOG> call <identifiersep> peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . disconnected , null ) ; } <comment> <ect>
group , event <identifiersep> id , parent <identifiersep> operation <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , icq <identifiersep> provider , parent <identifiersep> operation <identifiersep> set ) ; <LOG> iterable < server <identifiersep> stored <identifiersep> group <identifiersep> listener > listeners ; synchronized ( server <identifiersep> stored <identifiersep> group <identifiersep> listeners ) { listeners = new array <identifiersep> list < server <identifiersep> stored <identifiersep> group <identifiersep> listener > ( server <identifiersep> stored <identifiersep> group <identifiersep> listeners ) ; <ect>
private void fire <identifiersep> contact <identifiersep> resolved ( contact <identifiersep> group parent <identifiersep> group , contact contact ) { <comment> <LOG> return ; } <comment> <ect>
new keep <identifiersep> alive <identifiersep> check <identifiersep> task ( ) , keepalive <identifiersep> wait ) ; logger . trace ( <string_literal> ) ; im <identifiersep> conversation . send <identifiersep> message ( new simple <identifiersep> message ( sys <identifiersep> msg . to <identifiersep> string ( ) ) ) ; } catch ( exception ex ) { <LOG> } } } <comment> private class keep <identifiersep> alive <identifiersep> check <identifiersep> task <ect>
try { image = new byte [ in . available ( ) ] ; in . read ( image ) ; } catch ( io <identifiersep> exception e ) { <LOG> } return image ; } public static resource <identifiersep> management <identifiersep> service get <identifiersep> resources ( ) { if ( resources <identifiersep> service == null ) { service <identifiersep> reference service <identifiersep> reference = icq <identifiersep> activator . bundle <identifiersep> context <ect>
public void handle <identifiersep> new <identifiersep> incoming <identifiersep> connection ( rv <identifiersep> connection <identifiersep> manager manager , incoming <identifiersep> rv <identifiersep> connection transfer ) { if ( transfer instanceof incoming <identifiersep> file <identifiersep> transfer ) { <LOG> if ( ! ( transfer instanceof incoming <identifiersep> file <identifiersep> transfer ) ) { logger . warn ( <string_literal> ) ; return ; } operation <identifiersep> set <identifiersep> persistent <identifiersep> presence <identifiersep> icq <identifiersep> impl op <identifiersep> set <identifiersep> pers <identifiersep> presence = ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence <identifiersep> icq <identifiersep> impl ) <ect>
incoming <identifiersep> file <identifiersep> transfer . close ( ) ; file <identifiersep> transfer <identifiersep> op <identifiersep> set . fire <identifiersep> file <identifiersep> transfer <identifiersep> request <identifiersep> rejected ( new file <identifiersep> transfer <identifiersep> request <identifiersep> event ( file <identifiersep> transfer <identifiersep> op <identifiersep> set , this , date ) ) ; } catch ( illegal <identifiersep> state <identifiersep> exception e ) { <LOG> return ; } } <comment> <ect>
extends timer <identifiersep> task { @ override public void run ( ) { <LOG> iterator < contact <identifiersep> group > groups <identifiersep> iter = get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) . subgroups ( ) ; while ( groups <identifiersep> iter . has <identifiersep> next ( ) ) { contact <identifiersep> group group = groups <identifiersep> iter . next ( ) ; iterator < contact > contacts <identifiersep> iter = group . contacts ( ) ; <ect>
public void handle <identifiersep> response ( snac <identifiersep> response <identifiersep> event e ) { snac <identifiersep> command snac = e . get <identifiersep> snac <identifiersep> command ( ) ; if ( snac instanceof meta <identifiersep> basic <identifiersep> info <identifiersep> cmd ) { <LOG> read <identifiersep> basic <identifiersep> user <identifiersep> info ( ( meta <identifiersep> basic <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> more <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; read <identifiersep> more <identifiersep> user <identifiersep> info ( ( meta <identifiersep> more <identifiersep> info <identifiersep> cmd ) snac ) ; <ect>
logger . trace ( <string_literal> ) ; read <identifiersep> more <identifiersep> user <identifiersep> info ( ( meta <identifiersep> more <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> email <identifiersep> info <identifiersep> cmd ) { <LOG> read <identifiersep> email <identifiersep> user <identifiersep> info ( ( meta <identifiersep> email <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> homepage <identifiersep> category <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; read <identifiersep> home <identifiersep> page <identifiersep> user <identifiersep> info ( ( meta <identifiersep> homepage <identifiersep> category <identifiersep> info <identifiersep> cmd ) snac ) ; <ect>
logger . trace ( <string_literal> ) ; read <identifiersep> home <identifiersep> page <identifiersep> user <identifiersep> info ( ( meta <identifiersep> homepage <identifiersep> category <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> work <identifiersep> info <identifiersep> cmd ) { <LOG> read <identifiersep> work <identifiersep> user <identifiersep> info ( ( meta <identifiersep> work <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> notes <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; read <identifiersep> user <identifiersep> about <identifiersep> info ( ( meta <identifiersep> notes <identifiersep> info <identifiersep> cmd ) snac ) ; <ect>
else if ( tls <identifiersep> required ) throw new xmpp <identifiersep> exception ( <string_literal> + <string_literal> ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> throw new xmpp <identifiersep> exception ( <string_literal> , e ) ; } if ( debugger == null ) { debugger = new smack <identifiersep> packet <identifiersep> debugger ( ) ; <comment> <ect>
<comment> public void shutdown ( ) { synchronized ( initialization <identifiersep> lock ) { <LOG> <comment> <ect>
<comment> public void reconnection <identifiersep> successful ( ) { <LOG> } <comment> <ect>
<comment> <LOG> } return false ; } <comment> <ect>
try { parent <identifiersep> operation <identifiersep> set . publish <identifiersep> presence <identifiersep> status ( initial <identifiersep> status , initial <identifiersep> status <identifiersep> message ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) { <LOG> } } else get <identifiersep> parent <identifiersep> provider ( ) . get <identifiersep> connection ( ) . send <identifiersep> packet ( new presence ( presence . type . available ) ) ; <comment> <ect>
void fire <identifiersep> contact <identifiersep> added ( contact <identifiersep> group parent <identifiersep> group , contact <identifiersep> jabber <identifiersep> impl contact ) { <comment> <LOG> return ; } <comment> <ect>
<comment> public void roster <identifiersep> error ( xmpp <identifiersep> error error , packet packet ) { <LOG> + error . get <identifiersep> message ( ) ) ; } <comment> public void entries <identifiersep> added ( collection < string > addresses ) <ect>
<comment> public void entries <identifiersep> updated ( collection < string > addresses ) { <LOG> <comment> <ect>
false , <comment> <LOG> } <comment> <ect>
<comment> public whiteboard <identifiersep> object create <identifiersep> whiteboard <identifiersep> object ( string name ) { whiteboard <identifiersep> object <identifiersep> jabber <identifiersep> impl wb <identifiersep> obj = null ; <LOG> if ( name . equals ( whiteboard <identifiersep> object <identifiersep> path . name ) ) { wb <identifiersep> obj = new whiteboard <identifiersep> object <identifiersep> path <identifiersep> jabber <identifiersep> impl ( ) ; } else if ( name . equals ( whiteboard <identifiersep> object <identifiersep> poly <identifiersep> line . name ) ) { wb <identifiersep> obj = new whiteboard <identifiersep> object <identifiersep> poly <identifiersep> line <identifiersep> jabber <identifiersep> impl ( ) ; <ect>
new whiteboard <identifiersep> object <identifiersep> delivered <identifiersep> event ( this , message , contact , new date ( ) ) ; fire <identifiersep> message <identifiersep> event ( msg <identifiersep> delivered <identifiersep> evt ) ; } catch ( xmpp <identifiersep> exception ex ) { ex . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } } <comment> <ect>
response = packet <identifiersep> collector . next <identifiersep> result ( smack <identifiersep> configuration . get <identifiersep> packet <identifiersep> reply <identifiersep> timeout ( ) ) ; packet <identifiersep> collector . cancel ( ) ; } catch ( exception e ) { <LOG> } is <identifiersep> carbon <identifiersep> enabled = false ; if ( response == null ) { logger . error ( <string_literal> ) ; } else if ( response . get <identifiersep> error ( ) != null ) <ect>
<comment> public void shutdown ( ) { <LOG> iterator < call <identifiersep> jabber <identifiersep> impl > active <identifiersep> calls = this . active <identifiersep> calls <identifiersep> repository . get <identifiersep> active <identifiersep> calls ( ) ; <comment> <ect>
<comment> <LOG> xmpp <identifiersep> error error = jingle <identifiersep> iq . get <identifiersep> error ( ) ; string message = <string_literal> ; if ( error != null ) { string error <identifiersep> str = <string_literal> + error . get <identifiersep> code ( ) <ect>
final <identifiersep> call . process <identifiersep> session <identifiersep> initiate ( jingle <identifiersep> iq ) ; } } . start ( ) ; return ; } else if ( call <identifiersep> peer == null ) { <LOG> return ; } <comment> <ect>
+ caller + <string_literal> + <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error ) ; } } catch ( xmpp <identifiersep> exception xmppe ) { <LOG> } ( ( call <identifiersep> peer <identifiersep> jabber <identifiersep> impl ) peer ) . transfer ( get <identifiersep> full <identifiersep> callee <identifiersep> uri ( to ) , sid ) ; } <comment> <ect>
cp <identifiersep> dtmf <identifiersep> method = dtmf <identifiersep> method . inband <identifiersep> dtmf ; } } <comment> <LOG> } ( ( audio <identifiersep> media <identifiersep> stream ) cp . get <identifiersep> media <identifiersep> handler ( ) . get <identifiersep> stream ( media <identifiersep> type . audio ) ) . start <identifiersep> sending <identifiersep> dtmf ( tone , cp <identifiersep> dtmf <identifiersep> method , minimal <identifiersep> tone <identifiersep> duration , maximal <identifiersep> tone <identifiersep> duration , <ect>
if ( old <identifiersep> status . equals ( new <identifiersep> status ) && old <identifiersep> mobile <identifiersep> indicator == contact . is <identifiersep> mobile ( ) ) { return ; } contact . update <identifiersep> presence <identifiersep> status ( new <identifiersep> status ) ; <LOG> fire <identifiersep> contact <identifiersep> presence <identifiersep> status <identifiersep> change <identifiersep> event ( contact , contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) , old <identifiersep> status , new <identifiersep> status , resource <identifiersep> updated ) ; } <comment> <ect>
else current <identifiersep> presence = user <identifiersep> stats . first ( ) ; contact <identifiersep> jabber <identifiersep> impl source <identifiersep> contact = ss <identifiersep> contact <identifiersep> list . find <identifiersep> contact <identifiersep> by <identifiersep> id ( user <identifiersep> id ) ; if ( source <identifiersep> contact == null ) { <LOG> return ; } <comment> <ect>
current <identifiersep> presence , parent <identifiersep> provider ) ) ; } catch ( illegal <identifiersep> state <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { <LOG> } } } <comment> private class jabber <identifiersep> subscription <identifiersep> listener implements packet <identifiersep> listener { <ect>
throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . illegal <identifiersep> argument ) ; } try { this . irc . message ( target , message . get <identifiersep> content ( ) ) ; <LOG> } catch ( runtime <identifiersep> exception e ) { logger . trace ( <string_literal> + e . get <identifiersep> message ( ) , e ) ; throw e ; } } <comment> <ect>
else { evt = new chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> change <identifiersep> event ( this , member , event <identifiersep> id , event <identifiersep> reason ) ; } { <LOG> } iterable < chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> listener > listeners ; synchronized ( member <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> room <identifiersep> member <identifiersep> presence <identifiersep> listener > ( member <identifiersep> listeners ) ; <ect>
contact <identifiersep> group . add <identifiersep> contact ( new <identifiersep> contact ) ; connection . get <identifiersep> presence <identifiersep> manager ( ) . add <identifiersep> nick <identifiersep> watch ( contact <identifiersep> identifier ) ; fire <identifiersep> subscription <identifiersep> event ( new <identifiersep> contact , contact <identifiersep> group , subscription <identifiersep> event . subscription <identifiersep> created ) ; } catch ( runtime <identifiersep> exception e ) { <LOG> fire <identifiersep> subscription <identifiersep> event ( new <identifiersep> contact , contact <identifiersep> group , subscription <identifiersep> event . subscription <identifiersep> failed ) ; } } <comment> <ect>
<comment> @ override public void create <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> group ( final contact <identifiersep> group parent , final string group <identifiersep> name ) throws operation <identifiersep> failed <identifiersep> exception { <LOG> if ( ! ( parent instanceof contact <identifiersep> group <identifiersep> irc <identifiersep> impl ) ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } if ( group <identifiersep> name == null || group <identifiersep> name . is <identifiersep> empty ( ) ) { <ect>
{ <comment> <LOG> fire <identifiersep> message <identifiersep> delivery <identifiersep> failed ( original , to , message <identifiersep> delivery <identifiersep> failed <identifiersep> event . network <identifiersep> failure ) ; } } <comment> <ect>
<comment> public list < string > get <identifiersep> list ( ) { <LOG> if ( ! connection <identifiersep> state . is <identifiersep> connected ( ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } synchronized ( this . channellist ) { list < string > list = <ect>
. add <identifiersep> listener ( new channel <identifiersep> list <identifiersep> listener ( list <identifiersep> signal ) ) ; this . irc . raw <identifiersep> message ( <string_literal> ) ; while ( ! list <identifiersep> signal . is <identifiersep> done ( ) ) { logger . trace ( <string_literal> ) ; list <identifiersep> signal . wait ( ) ; } <LOG> } catch ( interrupted <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } list = list <identifiersep> signal . get <identifiersep> value ( ) ; this . channellist . set ( list ) ; logger . trace ( <string_literal> ) ; <ect>
logger . trace ( <string_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; } } list = list <identifiersep> signal . get <identifiersep> value ( ) ; this . channellist . set ( list ) ; <LOG> <comment> <ect>
attributes . add ( create <identifiersep> direction <identifiersep> attribute ( direction ) ) ; try { sdp . set <identifiersep> attributes ( attributes ) ; } catch ( sdp <identifiersep> exception e ) { <LOG> } } } <ect>
server <identifiersep> transaction . send <identifiersep> response ( response ) ; logger . debug ( <string_literal> + response ) ; } catch ( throwable ex ) { <LOG> return false ; } return true ; } <comment> <ect>
( ( sip <identifiersep> transaction <identifiersep> stack ) this . stack ) . set <identifiersep> address <identifiersep> resolver ( address <identifiersep> resolver ) ; sip <identifiersep> activator . get <identifiersep> network <identifiersep> address <identifiersep> manager <identifiersep> service ( ) . add <identifiersep> network <identifiersep> configuration <identifiersep> change <identifiersep> listener ( this ) ; } catch ( exception ex ) { <LOG> throw new operation <identifiersep> failed <identifiersep> exception ( <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error , ex ) ; } } <comment> <ect>
{ synchronized ( this . listeners ) { this . listeners . remove ( listener ) ; int listener <identifiersep> count = listeners . size ( ) ; <LOG> if ( listener <identifiersep> count == 0 ) stop <identifiersep> listening ( ) ; } } <comment> <ect>
return false ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) { <LOG> return false ; } } <comment> <ect>
<comment> <LOG> } <comment> private void terminate <identifiersep> subscription ( contact <identifiersep> sip <identifiersep> impl contact ) <ect>
{ try { return xml <identifiersep> utils . create <identifiersep> xml ( document ) ; } catch ( exception e ) { <LOG> return null ; } } <comment> <ect>
public void set <identifiersep> pidf <identifiersep> presence <identifiersep> status ( string presence <identifiersep> doc ) { document doc = convert <identifiersep> document ( presence <identifiersep> doc ) ; if ( doc == null ) return ; <LOG> <comment> <ect>
event <identifiersep> id , parent <identifiersep> operation <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) , sip <identifiersep> provider , parent <identifiersep> operation <identifiersep> set ) ; { <LOG> } iterable < server <identifiersep> stored <identifiersep> group <identifiersep> listener > listeners ; synchronized ( server <identifiersep> stored <identifiersep> group <identifiersep> listeners ) { listeners = new array <identifiersep> list < server <identifiersep> stored <identifiersep> group <identifiersep> listener > ( server <identifiersep> stored <identifiersep> group <identifiersep> listeners ) ; <ect>
if ( group <identifiersep> name == null || group <identifiersep> name . length ( ) == 0 ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } { <LOG> } contact <identifiersep> group <identifiersep> sip <identifiersep> impl existing <identifiersep> group = find <identifiersep> group <identifiersep> by <identifiersep> name ( group <identifiersep> name ) ; if ( existing <identifiersep> group != null ) { return existing <identifiersep> group ; } contact <identifiersep> group <identifiersep> sip <identifiersep> impl sub <identifiersep> group = new contact <identifiersep> group <identifiersep> sip <identifiersep> impl ( group <identifiersep> name , sip <identifiersep> provider ) ; <ect>
try { handler <identifiersep> provider . register ( sip <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> default <identifiersep> security <identifiersep> authority ( handler <identifiersep> provider ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception exc ) { <LOG> logger . warn ( exc . get <identifiersep> message ( ) , exc ) ; } } <comment> <ect>
return false ; } } boolean processed = false ; <comment> <LOG> dialog <identifiersep> state dialog <identifiersep> state = server <identifiersep> transaction . get <identifiersep> dialog ( ) . get <identifiersep> state ( ) ; if ( ( dialog <identifiersep> state == null ) || dialog <identifiersep> state . equals ( dialog <identifiersep> state . confirmed ) ) { logger . debug ( <string_literal> <ect>
if ( value <identifiersep> obj instanceof string ) value = ( ( string ) value <identifiersep> obj ) . get <identifiersep> bytes ( <string_literal> ) ; else if ( value <identifiersep> obj instanceof byte [ ] ) value = ( byte [ ] ) value <identifiersep> obj ; else { <LOG> return false ; } properties prop = new properties ( ) ; prop . load ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( value ) ) ; string signal = prop . get <identifiersep> property ( <string_literal> ) ; string duration <identifiersep> str = prop . get <identifiersep> property ( <string_literal> ) ; dtmf <identifiersep> tone tone = dtmf <identifiersep> tone . get <identifiersep> dtmf <identifiersep> tone ( signal ) ; <ect>
long duration = 0 ; try { duration = long . parse <identifiersep> long ( duration <identifiersep> str ) ; } catch ( number <identifiersep> format <identifiersep> exception ex ) { <LOG> } <comment> <ect>
catch ( transaction <identifiersep> unavailable <identifiersep> exception ex ) { logger . info ( <string_literal> + <string_literal> ) ; <LOG> return false ; } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <comment> <ect>
<comment> <LOG> return false ; } return true ; } return false ; } <comment> <ect>
{ transac = create <identifiersep> notify ( dialog , subscription , subscription <identifiersep> state <identifiersep> header . terminated , subscription <identifiersep> state <identifiersep> header . timeout ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) { <LOG> return false ; } try { dialog . send <identifiersep> request ( transac ) ; } catch ( exception e ) { <ect>
try { response = protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . ok , request ) ; } catch ( exception e ) { <LOG> return false ; } <comment> <ect>
response . set <identifiersep> header ( exp <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( exception e ) { <LOG> return false ; } add <identifiersep> subscription ( call <identifiersep> id , subscription ) ; <comment> <ect>
return false ; } try { dialog . send <identifiersep> request ( transac ) ; } catch ( exception e ) { <LOG> return false ; } } <comment> <ect>
{ c <identifiersep> seq <identifiersep> header = provider . get <identifiersep> header <identifiersep> factory ( ) . create <identifiersep> c <identifiersep> seq <identifiersep> header ( get <identifiersep> next <identifiersep> c <identifiersep> seq <identifiersep> value ( ) , request . options ) ; } catch ( parse <identifiersep> exception ex ) { <comment> <LOG> return ; } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <comment> <ect>
, c <identifiersep> seq <identifiersep> header , from <identifiersep> header , to <identifiersep> header , via <identifiersep> headers , max <identifiersep> forwards <identifiersep> header ) ; <LOG> } catch ( parse <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; return ; } iterator < string > supported <identifiersep> methods = provider . get <identifiersep> supported <identifiersep> methods ( ) . iterator ( ) ; <ect>
ex ) ; return ; } try { options <identifiersep> trans . send <identifiersep> request ( ) ; <LOG> } catch ( sip <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; if ( ex . get <identifiersep> cause ( ) instanceof io <identifiersep> exception ) { <comment> <ect>
{ <comment> <LOG> } } } <comment> private class cr <identifiersep> lf <identifiersep> keep <identifiersep> alive <identifiersep> task extends timer <identifiersep> task { <ect>
{ response = protocol <identifiersep> provider . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . ok , request ) ; } catch ( parse <identifiersep> exception e ) { <LOG> return false ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( sip <identifiersep> exception e ) { <ect>
{ response response = response <identifiersep> event . get <identifiersep> response ( ) ; c <identifiersep> seq <identifiersep> header cseq <identifiersep> header = ( c <identifiersep> seq <identifiersep> header ) response . get <identifiersep> header ( c <identifiersep> seq <identifiersep> header . name ) ; if ( cseq <identifiersep> header == null ) { <LOG> return false ; } if ( ! request . subscribe . equals ( cseq <identifiersep> header . get <identifiersep> method ( ) ) ) return false ; client <identifiersep> transaction client <identifiersep> transaction = response <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) ; request request = client <identifiersep> transaction . get <identifiersep> request ( ) ; <ect>
if ( ( status <identifiersep> code == response . ok ) || ( status <identifiersep> code == response . accepted ) ) { if ( exp <identifiersep> header == null ) { <comment> <LOG> return false ; } subscription <identifiersep> refresh <identifiersep> task refresh <identifiersep> task = new subscription <identifiersep> refresh <identifiersep> task ( subscription ) ; subscription . set <identifiersep> timer <identifiersep> task ( refresh <identifiersep> task ) ; int refresh <identifiersep> delay = exp <identifiersep> header . get <identifiersep> expires ( ) ; <comment> <ect>
transac = protocol <identifiersep> provider . get <identifiersep> default <identifiersep> jain <identifiersep> sip <identifiersep> provider ( ) . get <identifiersep> new <identifiersep> client <identifiersep> transaction ( request ) ; } catch ( transaction <identifiersep> unavailable <identifiersep> exception e ) { <LOG> return false ; } try { transac . send <identifiersep> request ( ) ; } catch ( sip <identifiersep> exception e ) { <ect>
<comment> public static void set <identifiersep> application <identifiersep> data ( object container , string key , object value ) { if ( container == null ) { <LOG> return ; } if ( key == null ) { logger . warn ( <string_literal> ) ; return ; } sip <identifiersep> application <identifiersep> data app <identifiersep> data = get <identifiersep> sip <identifiersep> application <identifiersep> data ( container ) ; <ect>
<comment> public static object get <identifiersep> application <identifiersep> data ( object container , string key ) { if ( container == null ) { <LOG> return null ; } if ( key == null ) { logger . warn ( <string_literal> ) ; return null ; } sip <identifiersep> application <identifiersep> data app <identifiersep> data = get <identifiersep> sip <identifiersep> application <identifiersep> data ( container ) ; <ect>
{ if ( contact == null ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } <LOG> contact <identifiersep> group <identifiersep> sip <identifiersep> impl parent <identifiersep> group = ( contact <identifiersep> group <identifiersep> sip <identifiersep> impl ) contact . get <identifiersep> parent <identifiersep> contact <identifiersep> group ( ) ; parent <identifiersep> group . remove <identifiersep> contact ( contact ) ; if ( contact . is <identifiersep> persistent ( ) ) { try <ect>
if ( group <identifiersep> name == null || group <identifiersep> name . length ( ) == 0 ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; } { <LOG> + group <identifiersep> name + <string_literal> + persistent ) ; } if ( parent <identifiersep> group . get <identifiersep> group ( group <identifiersep> name ) != null ) { throw new operation <identifiersep> failed <identifiersep> exception ( string . format ( <string_literal> , group <identifiersep> name ) , operation <identifiersep> failed <identifiersep> exception . contact <identifiersep> group <identifiersep> already <identifiersep> exists ) ; <ect>
properties ) ; registered <identifiersep> accounts . put ( account <identifiersep> id , registration ) ; if ( initialization <identifiersep> exception != null ) throw initialization <identifiersep> exception ; } catch ( exception ex ) { <LOG> throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } } <comment> <ect>
<comment> <LOG> fire <identifiersep> message <identifiersep> delivery <identifiersep> failed ( message , to , message <identifiersep> delivery <identifiersep> failed <identifiersep> event . offline <identifiersep> messages <identifiersep> not <identifiersep> supported ) ; return ; } <comment> <ect>
+ <string_literal> , ex ) ; fire <identifiersep> message <identifiersep> delivery <identifiersep> failed ( message , to , message <identifiersep> delivery <identifiersep> failed <identifiersep> event . network <identifiersep> failure ) ; continue ; } catch ( sip <identifiersep> exception ex ) { <LOG> fire <identifiersep> message <identifiersep> delivery <identifiersep> failed ( message , to , message <identifiersep> delivery <identifiersep> failed <identifiersep> event . internal <identifiersep> error ) ; continue ; } } } <comment> <ect>
for ( sip <identifiersep> message <identifiersep> processor listener : message <identifiersep> processors ) if ( ! listener . process <identifiersep> timeout ( timeout <identifiersep> event , sent <identifiersep> msg ) ) return true ; } <comment> <LOG> return false ; } request req = timeout <identifiersep> event . get <identifiersep> client <identifiersep> transaction ( ) . get <identifiersep> request ( ) ; <comment> <ect>
{ logger . trace ( <string_literal> + line ) ; handle ( ( json <identifiersep> object ) json <identifiersep> value . parse <identifiersep> with <identifiersep> exception ( line ) ) ; } catch ( throwable ex ) { <LOG> } } } catch ( io <identifiersep> exception ex ) { destroy ( ) ; } } <comment> <ect>
if ( ! authorize ( ( string ) incoming <identifiersep> object . get ( <string_literal> ) , password ) ) logger . error ( <string_literal> ) ; return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { if ( ! send <identifiersep> capas ( ( json <identifiersep> array ) incoming <identifiersep> object . get ( <string_literal> ) ) ) <LOG> return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { if ( ! send <identifiersep> features ( ( string ) incoming <identifiersep> object . get ( <string_literal> ) , ( string ) incoming <identifiersep> object . get ( <string_literal> ) ) ) logger . error ( <string_literal> ) ; <ect>
( string ) incoming <identifiersep> object . get ( <string_literal> ) ) ) logger . error ( <string_literal> ) ; return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { if ( ! get <identifiersep> phone <identifiersep> list ( ) ) <LOG> return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { phones <identifiersep> recieved ( incoming <identifiersep> object ) ; return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) <ect>
{ logger . trace ( <string_literal> + incoming <identifiersep> object ) ; return ; } } catch ( throwable t ) { <LOG> } } <comment> @ suppress <identifiersep> warnings ( <string_literal> ) <ect>
try { ret <identifiersep> val = this . history <identifiersep> service <identifiersep> impl . parse ( file ) ; } catch ( exception e ) { <comment> <LOG> log . error ( <string_literal> , e ) ; <comment> <ect>
<comment> public document get <identifiersep> fixed <identifiersep> document ( file file ) { <LOG> string <identifiersep> buffer result <identifiersep> doc <identifiersep> str = new string <identifiersep> buffer ( <string_literal> ) ; try { buffered <identifiersep> reader in <identifiersep> reader = new buffered <identifiersep> reader ( new file <identifiersep> reader ( file ) ) ; string line = null ; while ( ( line = in <identifiersep> reader . read <identifiersep> line ( ) ) != null ) <ect>
<comment> <LOG> return null ; } } <comment> <ect>
try { this . history <identifiersep> service <identifiersep> impl . parse ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( str . get <identifiersep> bytes ( <string_literal> ) ) ) ; } catch ( exception ex ) { <LOG> return false ; } return true ; } } <ect>
output <identifiersep> dir . mkdirs ( ) ; } for ( int i = 0 ; i < ids . length ; i ++ ) { logger . info ( <string_literal> + ids [ i ] + <string_literal> ) ; test <identifiersep> suite slick = get <identifiersep> test <identifiersep> suite ( bc , ids [ i ] ) ; <LOG> file output <identifiersep> file = new file ( output <identifiersep> dir , <string_literal> + ids [ i ] + <string_literal> ) ; if ( ! output <identifiersep> file . exists ( ) ) { output <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ; } logger . debug ( <string_literal> <ect>
err <identifiersep> count += res . error <identifiersep> count ( ) + res . failure <identifiersep> count ( ) ; run <identifiersep> count += res . run <identifiersep> count ( ) ; out . flush ( ) ; out . close ( ) ; } <comment> <LOG> logger . info ( <string_literal> + run <identifiersep> count + <string_literal> + err <identifiersep> count + <string_literal> ) ; logger . info ( <string_literal> ) ; logger . info ( <string_literal> ) ; <comment> <ect>
logger . info ( <string_literal> ) ; logger . info ( <string_literal> ) ; logger . info ( <string_literal> + run <identifiersep> count + <string_literal> + err <identifiersep> count + <string_literal> ) ; logger . info ( <string_literal> ) ; <LOG> <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context bc ) { <LOG> } <comment> <ect>
meta <identifiersep> history <identifiersep> service <identifiersep> lick . bc = bundle <identifiersep> context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test ( test <identifiersep> meta <identifiersep> history <identifiersep> service . suite ( ) ) ; bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; <LOG> } <comment> <ect>
} ; } <comment> public void write <identifiersep> records ( ) { <LOG> assert <identifiersep> not <identifiersep> null ( <string_literal> , test <identifiersep> meta <identifiersep> contact ) ; <comment> <ect>
bc = bundle <identifiersep> context ; set <identifiersep> name ( <string_literal> ) ; hashtable < string , string > properties = new hashtable < string , string > ( ) ; properties . put ( <string_literal> , get <identifiersep> name ( ) ) ; add <identifiersep> test ( create <identifiersep> suite ( ) ) ; bundle <identifiersep> context . register <identifiersep> service ( get <identifiersep> class ( ) . get <identifiersep> name ( ) , this , properties ) ; <LOG> } <comment> <ect>
+ <string_literal> ) ; } else { suite . add <identifiersep> test ( new test <identifiersep> suite ( test <identifiersep> class ) ) ; } } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <LOG> } } } return suite ; } } <ect>
return default <identifiersep> values ; } public void set <identifiersep> user <identifiersep> name <identifiersep> editable ( boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ) { } public boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ( ) { return false ; } } ) ; synchronized ( registration <identifiersep> lock ) { <LOG> registration <identifiersep> lock . wait ( <number_literal> ) ; logger . info ( <string_literal> ) ; } } <comment> <ect>
{ op <identifiersep> set <identifiersep> presence2 . set <identifiersep> authorization <identifiersep> handler ( new auth <identifiersep> handler ( ) ) ; op <identifiersep> set <identifiersep> presence2 . subscribe ( fixture . our <identifiersep> user <identifiersep> id ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex1 ) { <comment> <LOG> object o = new object ( ) ; synchronized ( o ) { o . wait ( <number_literal> ) ; } } } @ override public operation <identifiersep> set <identifiersep> file <identifiersep> transfer get <identifiersep> op <identifiersep> set <identifiersep> fil <identifiersep> transfer1 ( ) <ect>
<comment> public void initialize <identifiersep> buddy <identifiersep> list ( hashtable < string , list < string > > list <identifiersep> contents ) { <LOG> mutable <identifiersep> buddy <identifiersep> list joust <identifiersep> sim <identifiersep> buddy <identifiersep> list = conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; <comment> <ect>
{ string screenname = contacts <identifiersep> to <identifiersep> add <identifiersep> to <identifiersep> this <identifiersep> group . next ( ) ; <comment> <LOG> newly <identifiersep> created <identifiersep> group . add <identifiersep> buddy ( screenname ) ; <comment> <ect>
system . out . println ( <string_literal> + buddy ) ; } public void buddies <identifiersep> reordered ( buddy <identifiersep> list list , group group , list < ? extends buddy > old <identifiersep> buddies , list < ? extends buddy > new <identifiersep> buddies ) { <LOG> } public void group <identifiersep> name <identifiersep> changed ( group group , string old <identifiersep> name , string new <identifiersep> name ) { system . out . println ( <string_literal> <ect>
{ java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . set <identifiersep> level ( java . util . logging . level . finest ) ; icq <identifiersep> tester <identifiersep> agent icqtests = new icq <identifiersep> tester <identifiersep> agent ( <string_literal> ) ; if ( ! icqtests . register ( <string_literal> ) ) { <LOG> return ; } thread . sleep ( <number_literal> ) ; icqtests . conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) . add <identifiersep> retroactive <identifiersep> layout <identifiersep> listener ( icqtests . rl ) ; thread . sleep ( <number_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
buddy buddy <identifiersep> to <identifiersep> move = null ; for ( group group : list . get <identifiersep> groups ( ) ) { if ( group . get <identifiersep> name ( ) . equals ( <string_literal> ) ) grp <identifiersep> group = ( mutable <identifiersep> group ) group ; list < ? extends buddy > buddies = group . get <identifiersep> buddies <identifiersep> copy ( ) ; <LOG> thread . sleep ( <number_literal> ) ; for ( buddy buddy : buddies ) { system . out . println ( buddy . get <identifiersep> screenname ( ) ) ; if ( buddy . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) . equals ( <string_literal> ) ) buddy <identifiersep> to <identifiersep> move = buddy ; <ect>
system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; thread . sleep ( <number_literal> ) ; list < buddy > list <identifiersep> to <identifiersep> move = new array <identifiersep> list < buddy > ( ) ; list <identifiersep> to <identifiersep> move . add ( buddy <identifiersep> to <identifiersep> move ) ; list . move <identifiersep> buddies ( list <identifiersep> to <identifiersep> move , grp <identifiersep> group ) ; <LOG> thread . sleep ( <number_literal> ) ; <comment> <ect>
<comment> public void subscription <identifiersep> resolved ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void contact <identifiersep> modified ( contact <identifiersep> property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } } <ect>
<comment> public void got <identifiersep> typing <identifiersep> state ( conversation conversation , typing <identifiersep> info typing <identifiersep> info ) { <LOG> + typing <identifiersep> info . get <identifiersep> typing <identifiersep> state ( ) ) ; synchronized ( this ) { collected <identifiersep> typing <identifiersep> info . add ( typing <identifiersep> info ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> delivery <identifiersep> failed ( message <identifiersep> delivery <identifiersep> failed <identifiersep> event evt ) { <LOG> synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> stat <identifiersep> msg <identifiersep> event ( long wait <identifiersep> for ) { <LOG> synchronized ( this ) { if ( collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; return ; <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void contact <identifiersep> modified ( contact <identifiersep> property <identifiersep> change <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> failed ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void registration <identifiersep> state <identifiersep> changed ( registration <identifiersep> state <identifiersep> change <identifiersep> event evt ) { logger . debug ( <string_literal> + evt ) ; if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) ) { <LOG> state <identifiersep> recieved = evt . get <identifiersep> new <identifiersep> state ( ) ; event <identifiersep> reason = evt . get <identifiersep> reason <identifiersep> code ( ) ; synchronized ( registration <identifiersep> lock ) { logger . debug ( <string_literal> ) ; registration <identifiersep> lock . notify <identifiersep> all ( ) ; <ect>
state <identifiersep> recieved = evt . get <identifiersep> new <identifiersep> state ( ) ; event <identifiersep> reason = evt . get <identifiersep> reason <identifiersep> code ( ) ; synchronized ( registration <identifiersep> lock ) { logger . debug ( <string_literal> ) ; registration <identifiersep> lock . notify <identifiersep> all ( ) ; <LOG> } } } } } <ect>
{ op <identifiersep> set <identifiersep> presence2 . set <identifiersep> authorization <identifiersep> handler ( new auth <identifiersep> handler ( ) ) ; op <identifiersep> set <identifiersep> presence2 . subscribe ( fixture . user <identifiersep> id1 ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex1 ) { <comment> <LOG> object o = new object ( ) ; synchronized ( o ) { o . wait ( <number_literal> ) ; } } } @ override public operation <identifiersep> set <identifiersep> file <identifiersep> transfer get <identifiersep> op <identifiersep> set <identifiersep> fil <identifiersep> transfer1 ( ) <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> ) ; <LOG> + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list = jabber <identifiersep> slick <identifiersep> fixture . pre <identifiersep> installed <identifiersep> buddy <identifiersep> list ; logger . debug ( <string_literal> ) ; <ect>
chat <identifiersep> room <identifiersep> member <identifiersep> role . member , get <identifiersep> role ( fixture . user <identifiersep> id2 , members , room <identifiersep> name , true ) ) ; assert <identifiersep> equals ( <string_literal> + <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , get <identifiersep> role ( fixture . user <identifiersep> id3 , members , room <identifiersep> name , true ) ) ; <LOG> } <comment> <ect>
if ( mem . get <identifiersep> contact <identifiersep> address ( ) . equals ( user <identifiersep> id ) ) role <identifiersep> found = mem . get <identifiersep> role ( ) ; if ( print <identifiersep> debug <identifiersep> info ) logger . info ( <string_literal> + i + <string_literal> + mem . get <identifiersep> contact <identifiersep> address ( ) + <string_literal> + mem . get <identifiersep> role ( ) ) ; } if ( print <identifiersep> debug <identifiersep> info ) <LOG> return role <identifiersep> found ; } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . guest , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
fixture . user <identifiersep> id2 , role <identifiersep> event <identifiersep> user3 . get <identifiersep> source <identifiersep> member ( ) . get <identifiersep> contact <identifiersep> address ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . member , role <identifiersep> event <identifiersep> user3 . get <identifiersep> previous <identifiersep> role ( ) ) ; assert <identifiersep> equals ( <string_literal> , chat <identifiersep> room <identifiersep> member <identifiersep> role . moderator , role <identifiersep> event <identifiersep> user3 . get <identifiersep> new <identifiersep> role ( ) ) ; <LOG> } <comment> <ect>
+ <string_literal> + system . get <identifiersep> property ( <string_literal> ) + <string_literal> + new date ( ) . to <identifiersep> string ( ) + <string_literal> ; string list = system . get <identifiersep> property ( <string_literal> ) ; <LOG> <comment> <ect>
logger . trace ( <string_literal> ) ; presence <identifiersep> status new <identifiersep> status = supported <identifiersep> status <identifiersep> set1 . get ( new <identifiersep> status <identifiersep> name ) ; presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; string new <identifiersep> status <identifiersep> message = status <identifiersep> message <identifiersep> root + new <identifiersep> status ; <LOG> + <string_literal> + new <identifiersep> status . get <identifiersep> status <identifiersep> name ( ) ) ; <comment> <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } <comment> <ect>
{ <comment> <LOG> subtest <identifiersep> query <identifiersep> contact <identifiersep> status ( jabber <identifiersep> status <identifiersep> enum . do <identifiersep> not <identifiersep> disturb , jabber <identifiersep> status <identifiersep> enum . do <identifiersep> not <identifiersep> disturb ) ; <comment> <ect>
<comment> public void group <identifiersep> name <identifiersep> changed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void group <identifiersep> resolved ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } } <comment> <ect>
{ logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { <LOG> return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <ect>
return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <LOG> } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
public void wait <identifiersep> for <identifiersep> pres <identifiersep> event ( long wait <identifiersep> for ) { logger . trace ( <string_literal> ) ; synchronized ( this ) { if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { <LOG> return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <ect>
return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) logger . trace ( <string_literal> ) ; else <LOG> } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; } } } <comment> <ect>
logger . trace ( <string_literal> + collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; if ( collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) <LOG> else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) { <LOG> collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . clear ( ) ; <comment> <LOG> lock . wait ( <number_literal> ) ; } <comment> <ect>
this . operation <identifiersep> set <identifiersep> presence2 . get <identifiersep> presence <identifiersep> status ( ) ; presence <identifiersep> status new <identifiersep> status = get <identifiersep> sample <identifiersep> status1 ( ) ; <comment> <LOG> <comment> <ect>
<comment> public void post <identifiersep> test <identifiersep> unsubscribe ( ) throws exception { <LOG> <comment> <ect>
. remove <identifiersep> contact <identifiersep> presence <identifiersep> status <identifiersep> listener ( contact <identifiersep> pres <identifiersep> evt <identifiersep> collector ) ; } assert <identifiersep> equals ( <string_literal> , 0 , contact <identifiersep> pres <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . size ( ) ) ; } public void clear <identifiersep> lists ( ) throws exception { <LOG> this . fixture . clear <identifiersep> providers <identifiersep> lists ( ) ; object o = new object ( ) ; synchronized ( o ) { o . wait ( <number_literal> ) ; } } <comment> <ect>
break ; default : string parsed = p <identifiersep> applet . join ( p <identifiersep> applet . subset ( path <identifiersep> tokens , 0 , i ) , <string_literal> ) ; string unparsed = p <identifiersep> applet . join ( p <identifiersep> applet . subset ( path <identifiersep> tokens , i ) , <string_literal> ) ; <LOG> system . err . println ( <string_literal> + unparsed ) ; throw new runtime <identifiersep> exception ( <string_literal> + path <identifiersep> tokens [ i ] ) ; } <comment> <ect>
parse <identifiersep> path <identifiersep> vertex ( x1 , y1 ) ; parse <identifiersep> path <identifiersep> vertex ( x2 , y2 ) ; parse <identifiersep> path <identifiersep> vertex ( x3 , y3 ) ; } <comment> <LOG> <comment> <ect>
start = stop + 1 ; } return outgoing ; } static protected p <identifiersep> matrix2d parse <identifiersep> single <identifiersep> transform ( string matrix <identifiersep> str ) { <comment> <LOG> return null ; } float [ ] m = p <identifiersep> applet . parse <identifiersep> float ( p <identifiersep> applet . split <identifiersep> tokens ( pieces [ <number_literal> ] , <string_literal> ) ) ; if ( pieces [ 1 ] . equals ( <string_literal> ) ) { return new p <identifiersep> matrix2d ( m [ 0 ] , m [ <number_literal> ] , m [ <number_literal> ] , m [ 1 ] , m [ <number_literal> ] , m [ <number_literal> ] ) ; } else if ( pieces [ 1 ] . equals ( <string_literal> ) ) { float tx = m [ 0 ] ; <ect>
return color <identifiersep> names . get ( color <identifiersep> text ) ; } else if ( color <identifiersep> text . starts <identifiersep> with ( <string_literal> ) ) { if ( color <identifiersep> text . length ( ) == <number_literal> ) { <comment> <LOG> } else if ( color <identifiersep> text . starts <identifiersep> with ( <string_literal> ) ) { return parse <identifiersep> rgb ( color <identifiersep> text ) ; } else { system . err . println ( <string_literal> + color <identifiersep> text + <string_literal> ) ; return 0 ; } } <comment> <ect>
protected long frame <identifiersep> rate <identifiersep> last <identifiersep> nanos = 0 ; public void handle <identifiersep> draw ( ) { <comment> <LOG> <comment> <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( illegal <identifiersep> access <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( invocation <identifiersep> target <identifiersep> exception e ) { e . get <identifiersep> target <identifiersep> exception ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( no <identifiersep> such <identifiersep> method <identifiersep> exception nsme ) { <LOG> <string_literal> + get <identifiersep> class ( ) . get <identifiersep> name ( ) ) ; } catch ( exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } <comment> <ect>
<comment> public void save <identifiersep> frame ( string filename ) { try { g . save ( save <identifiersep> path ( insert <identifiersep> frame ( filename ) ) ) ; } catch ( security <identifiersep> exception se ) { <LOG> <string_literal> ) ; } } <comment> <ect>
<comment> <LOG> <comment> <comment> <ect>
system . err . println ( <string_literal> + value + <string_literal> + args <identifiersep> display ) ; } } else if ( param . equals ( args <identifiersep> window <identifiersep> color ) ) { if ( value . char <identifiersep> at ( 0 ) == ' # ' && value . length ( ) == <number_literal> ) { value = value . substring ( 1 ) ; window <identifiersep> color = 0xff000000 | integer . parse <identifiersep> int ( value , <number_literal> ) ; } else { <LOG> } } else if ( param . equals ( args <identifiersep> stop <identifiersep> color ) ) { if ( value . char <identifiersep> at ( 0 ) == ' # ' && value . length ( ) == <number_literal> ) { value = value . substring ( 1 ) ; stop <identifiersep> color = 0xff000000 | integer . parse <identifiersep> int ( value , <number_literal> ) ; } else { system . err . println ( args <identifiersep> stop <identifiersep> color + <string_literal> ) ; <ect>
folder = value ; } else if ( param . equals ( args <identifiersep> location ) ) { location = parse <identifiersep> int ( split ( value , ' , ' ) ) ; } else if ( param . equals ( args <identifiersep> density ) ) { density = parse <identifiersep> int ( value , - 1 ) ; if ( density == - 1 ) { <LOG> } else if ( density != 1 && density != <number_literal> ) { density = - 1 ; system . err . println ( args <identifiersep> density + <string_literal> ) ; } } } else { if ( args [ arg <identifiersep> index ] . equals ( args <identifiersep> present ) ) { present = true ; <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> if ( present ) { if ( hide <identifiersep> stop ) { stop <identifiersep> color = 0 ; <comment> <ect>
for ( int i = 0 ; i < count ; i ++ ) { outgoing . indices . put ( keys [ i ] , i ) ; } outgoing . count = count ; return outgoing ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { <LOG> } } <comment> public void write ( print <identifiersep> writer writer ) { for ( int i = 0 ; i < count ; i ++ ) { <ect>
for ( int i = 0 ; i < count ; i ++ ) { outgoing . indices . put ( keys [ i ] , i ) ; } outgoing . count = count ; return outgoing ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { <LOG> } } <comment> public void write ( print <identifiersep> writer writer ) { for ( int i = 0 ; i < count ; i ++ ) { <ect>
indent <identifiersep> factor = - 1 ; } else if ( opt . starts <identifiersep> with ( <string_literal> ) ) { indent <identifiersep> factor = p <identifiersep> applet . parse <identifiersep> int ( opt . substring ( <number_literal> ) , - <number_literal> ) ; if ( indent <identifiersep> factor == - <number_literal> ) { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + opt ) ; } } else { <LOG> } } } output . print ( format ( indent <identifiersep> factor ) ) ; output . flush ( ) ; return true ; } <comment> <ect>
for ( int i = 0 ; i < count ; i ++ ) { outgoing . indices . put ( keys [ i ] , i ) ; } outgoing . count = count ; return outgoing ; } public void print ( ) { for ( int i = 0 ; i < size ( ) ; i ++ ) { <LOG> } } <comment> public void write ( print <identifiersep> writer writer ) { for ( int i = 0 ; i < count ; i ++ ) { <ect>
int window <identifiersep> scale <identifiersep> factor ; public p <identifiersep> surface <identifiersep> awt ( p <identifiersep> graphics graphics ) { <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
@ override public void validate ( ) { super . validate ( ) ; new <identifiersep> size . width = get <identifiersep> width ( ) ; new <identifiersep> size . height = get <identifiersep> height ( ) ; <comment> <LOG> <comment> <ect>
render ( ) ; <comment> <LOG> paint ( g ) ; } @ override public void paint ( graphics screen ) { <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> return super . text <identifiersep> width <identifiersep> impl ( buffer , start , stop ) ; } <comment> <ect>
<comment> <LOG> throw new runtime <identifiersep> exception ( <string_literal> ) ; } return raster ; } @ override public void load <identifiersep> pixels ( ) { if ( pixels == null || ( pixels . length != pixel <identifiersep> width * pixel <identifiersep> height ) ) { pixels = new int [ pixel <identifiersep> width * pixel <identifiersep> height ] ; <ect>
<comment> <LOG> if ( current <identifiersep> version != null ) { string java <identifiersep> home = registry . get <identifiersep> string <identifiersep> value ( registry <identifiersep> root <identifiersep> key . local <identifiersep> machine , jdk <identifiersep> key + <string_literal> + current <identifiersep> version , <string_literal> ) ; system . out . println ( <string_literal> + java <identifiersep> home + <string_literal> ) ; <ect>
libraries = new array <identifiersep> list < library > ( ) ; import <identifiersep> to <identifiersep> library <identifiersep> table . put ( pkg , libraries ) ; } else { if ( base . debug ) { system . err . println ( <string_literal> ) ; system . err . println ( get <identifiersep> path ( ) ) ; <LOG> for ( library library : libraries ) { system . err . println ( library . get <identifiersep> path ( ) ) ; } system . err . println ( <string_literal> + pkg ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + pkg + <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( get <identifiersep> path ( ) ) ; system . err . println ( <string_literal> ) ; for ( library library : libraries ) { system . err . println ( library . get <identifiersep> path ( ) ) ; } system . err . println ( <string_literal> + pkg ) ; <LOG> system . err . println ( <string_literal> + pkg + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( ) ; } } libraries . add ( this ) ; } } public boolean has <identifiersep> examples ( ) { return examples <identifiersep> folder . exists ( ) ; <ect>
system . err . println ( <string_literal> ) ; for ( library library : libraries ) { system . err . println ( library . get <identifiersep> path ( ) ) ; } system . err . println ( <string_literal> + pkg ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + pkg + <string_literal> ) ; <LOG> system . err . println ( ) ; } } libraries . add ( this ) ; } } public boolean has <identifiersep> examples ( ) { return examples <identifiersep> folder . exists ( ) ; } public file get <identifiersep> examples <identifiersep> folder ( ) { return examples <identifiersep> folder ; <ect>
string name = targ . get <identifiersep> name ( ) ; int ind = name . last <identifiersep> index <identifiersep> of ( ' . ' ) ; string ct = null ; if ( ind > 0 ) { ct = map . get ( name . substring ( ind ) ) ; } if ( ct == null ) { <LOG> ct = <string_literal> ; } ps . print ( <string_literal> + ct ) ; ps . write ( eol ) ; } else { ps . print ( <string_literal> ) ; ps . write ( eol ) ; <ect>
vertical . set <identifiersep> values ( first <identifiersep> line , visible <identifiersep> lines , 0 , get <identifiersep> line <identifiersep> count ( ) ) ; vertical . set <identifiersep> unit <identifiersep> increment ( <number_literal> ) ; vertical . set <identifiersep> block <identifiersep> increment ( visible <identifiersep> lines ) ; } <comment> <LOG> <comment> <ect>
} else { painter . current <identifiersep> line <identifiersep> index = line ; tokens = painter . current <identifiersep> line <identifiersep> tokens = token <identifiersep> marker . mark <identifiersep> tokens ( line <identifiersep> segment , line ) ; } int offset = 0 ; <comment> <LOG> for ( ; ; ) { byte id = tokens . id ; if ( id == token . end ) return offset ; if ( id == token . null ) { fm = painter . get <identifiersep> font <identifiersep> metrics ( ) ; <ect>
magic <identifiersep> caret = - 1 ; scroll <identifiersep> to <identifiersep> caret ( ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
<comment> <LOG> file temp <identifiersep> contrib <identifiersep> file = base . get <identifiersep> settings <identifiersep> file ( <string_literal> ) ; temp <identifiersep> contrib <identifiersep> file . set <identifiersep> writable ( true , false ) ; contribution <identifiersep> manager . download ( url , base . get <identifiersep> installed <identifiersep> contribs <identifiersep> info ( ) , temp <identifiersep> contrib <identifiersep> file , progress ) ; if ( ! progress . is <identifiersep> canceled ( ) && ! progress . is <identifiersep> error ( ) ) { if ( listing <identifiersep> file . exists ( ) ) { <ect>
temp <identifiersep> folder = type . create <identifiersep> temp <identifiersep> folder ( ) ; } catch ( io <identifiersep> exception e ) { if ( status != null ) status . set <identifiersep> error <identifiersep> message ( language . text ( <string_literal> ) ) ; return null ; } util . unzip ( contrib <identifiersep> archive , temp <identifiersep> folder ) ; <LOG> <comment> <ect>
int version ; try { version = integer . parse <identifiersep> int ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { version = get <identifiersep> version ( ) ; system . err . println ( <string_literal> + name + <string_literal> ) ; <LOG> } string pretty <identifiersep> version = properties . get ( <string_literal> ) ; if ( pretty <identifiersep> version != null && pretty <identifiersep> version . is <identifiersep> empty ( ) ) { pretty <identifiersep> version = null ; } string compatible <identifiersep> contribs <identifiersep> list = null ; if ( get <identifiersep> type ( ) == contribution <identifiersep> type . examples ) { compatible <identifiersep> contribs <identifiersep> list = properties . get ( modes <identifiersep> property ) ; <ect>
conn . set <identifiersep> do <identifiersep> output ( true ) ; conn . get <identifiersep> output <identifiersep> stream ( ) . write ( post ) ; } if ( progress != null ) { <comment> <LOG> progress . start <identifiersep> task ( language . text ( <string_literal> ) , file <identifiersep> size ) ; } input <identifiersep> stream in = conn . get <identifiersep> input <identifiersep> stream ( ) ; file <identifiersep> output <identifiersep> stream out = new file <identifiersep> output <identifiersep> stream ( dest ) ; byte [ ] b = new byte [ <number_literal> ] ; int amount ; if ( progress != null ) { <ect>
w == font . get <identifiersep> string <identifiersep> bounds ( <string_literal> , frc ) . get <identifiersep> width ( ) ) { <comment> <LOG> outgoing . add ( font ) ; <comment> <ect>
slider <identifiersep> box . set <identifiersep> alignment <identifiersep> y ( 0 ) ; slider <identifiersep> box . set <identifiersep> border ( border <identifiersep> factory . create <identifiersep> bevel <identifiersep> border ( bevel <identifiersep> border . lowered ) ) ; slider <identifiersep> box . add ( slider ) ; box . add ( slider <identifiersep> box ) ; box . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; box . add ( create <identifiersep> color <identifiersep> fields ( button <identifiersep> name , button <identifiersep> listener ) ) ; <LOG> box . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; <comment> <ect>
box . add ( create <identifiersep> color <identifiersep> fields ( button <identifiersep> name , button <identifiersep> listener ) ) ; <comment> <LOG> <comment> <ect>
public void set <identifiersep> color ( color color ) { update <identifiersep> rgb ( color . get <identifiersep> rgb ( ) ) ; } public string get <identifiersep> hex <identifiersep> color ( ) { return <string_literal> + p <identifiersep> applet . hex ( red , <number_literal> ) + p <identifiersep> applet . hex ( green , <number_literal> ) + p <identifiersep> applet . hex ( blue , <number_literal> ) ; } public class color <identifiersep> listener implements document <identifiersep> listener { public void changed <identifiersep> update ( document <identifiersep> event e ) { <LOG> } public void remove <identifiersep> update ( document <identifiersep> event e ) { <comment> <ect>
} else if ( next <identifiersep> index == - 1 && all <identifiersep> tabs ) { <comment> <LOG> tab <identifiersep> index = - 1 ; } else if ( tab <identifiersep> index == sketch . get <identifiersep> code <identifiersep> count ( ) - 1 ) { break ; } try { document doc = sketch . get <identifiersep> code ( tab <identifiersep> index + 1 ) . get <identifiersep> document ( ) ; if ( doc != null ) { <ect>
try { mt . wait <identifiersep> for <identifiersep> id ( 0 ) ; } catch ( interrupted <identifiersep> exception ie ) { } <comment> <LOG> synchronized ( this ) { paint <identifiersep> called = true ; notify <identifiersep> all ( ) ; } return ; } <comment> <ect>
return defaults . get ( attribute ) ; } public void set ( string attribute , string value ) { table . put ( attribute , value ) ; } public boolean get <identifiersep> boolean ( string attribute ) { string value = get ( attribute ) ; if ( value == null ) { <LOG> return false ; } return boolean . parse <identifiersep> boolean ( value ) ; } public void set <identifiersep> boolean ( string attribute , boolean value ) { set ( attribute , value ? <string_literal> : <string_literal> ) ; } public int get <identifiersep> integer ( string attribute ) { string value = get ( attribute ) ; <ect>
try { final string program = processing <identifiersep> test <identifiersep> util . preprocess ( id , res ( id + <string_literal> ) ) ; final process <identifiersep> result compiler <identifiersep> result = compiler . compile ( id , program ) ; if ( ! compiler <identifiersep> result . succeeded ( ) ) { system . err . println ( program ) ; <LOG> system . err . println ( compiler <identifiersep> result . get <identifiersep> stderr ( ) ) ; fail ( <string_literal> + compiler <identifiersep> result . get <identifiersep> result ( ) ) ; } final file expected <identifiersep> file = res ( id + <string_literal> ) ; if ( expected <identifiersep> file . exists ( ) ) { final string expected = processing <identifiersep> test <identifiersep> util . read ( expected <identifiersep> file ) ; assert <identifiersep> equals ( expected , program ) ; <ect>
for ( event event : event <identifiersep> set ) { <comment> <LOG> <comment> <ect>
sketch <identifiersep> out ) ; err <identifiersep> thread . start ( ) ; out <identifiersep> thread . start ( ) ; <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
list < connector > connectors = org . eclipse . jdi . bootstrap . virtual <identifiersep> machine <identifiersep> manager ( ) . all <identifiersep> connectors ( ) ; <comment> <LOG> <comment> <ect>
<comment> private boolean check <identifiersep> for <identifiersep> java <identifiersep> tabs ( ) { for ( sketch <identifiersep> code code : get <identifiersep> sketch ( ) . get <identifiersep> code ( ) ) { if ( code . get <identifiersep> extension ( ) . equals ( <string_literal> ) ) { if ( ! java <identifiersep> tab <identifiersep> warned ) { <LOG> system . out . println ( <string_literal> + <string_literal> ) ; <comment> <ect>
string show <identifiersep> mod <identifiersep> code = preferences . get ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code ) ; if ( show <identifiersep> mod <identifiersep> code == null ) { preferences . set <identifiersep> boolean ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code , false ) ; } if ( preferences . get <identifiersep> boolean ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code ) ) { system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < code . length ; i ++ ) { <LOG> system . out . println ( <string_literal> ) ; system . out . println ( code [ i ] . get <identifiersep> program ( ) ) ; } } return true ; } static private string replace <identifiersep> string ( string str , int start , int end , string put ) { return str . substring ( 0 , start ) + put + str . substring ( end , str . length ( ) ) ; } <comment> <ect>
else { string <identifiersep> builder ans = new string <identifiersep> builder ( label ) ; while ( ans . index <identifiersep> of ( <string_literal> ) > - 1 ) { int a = ans . index <identifiersep> of ( <string_literal> ) , b = ans . index <identifiersep> of ( <string_literal> ) ; if ( a > b ) break ; ans . replace ( a , b + 1 , <string_literal> ) ; <LOG> <comment> <ect>
<comment> public static ast <identifiersep> node resolve <identifiersep> expression ( ast <identifiersep> node nearest <identifiersep> node , ast <identifiersep> node expression , boolean no <identifiersep> compare ) { <LOG> + no <identifiersep> compare ) ; if ( expression instanceof simple <identifiersep> name ) { return find <identifiersep> declaration2 ( ( ( simple <identifiersep> name ) expression ) , nearest <identifiersep> node ) ; } else if ( expression instanceof method <identifiersep> invocation ) { log ( <string_literal> + ( ( method <identifiersep> invocation ) expression ) . get <identifiersep> name ( ) ) ; <ect>
list < ast <identifiersep> node > nodes ; if ( parent instanceof type <identifiersep> declaration ) { nodes = ( ( type <identifiersep> declaration ) parent ) . body <identifiersep> declarations ( ) ; } else if ( parent instanceof block ) { nodes = ( ( block ) parent ) . statements ( ) ; } else { <LOG> return null ; } if ( nodes . size ( ) > 0 ) { ast <identifiersep> node ret <identifiersep> node = parent ; for ( ast <identifiersep> node c <identifiersep> node : nodes ) { log ( c <identifiersep> node + <string_literal> + get <identifiersep> line <identifiersep> number ( c <identifiersep> node ) + <string_literal> + line <identifiersep> number ) ; if ( get <identifiersep> line <identifiersep> number ( c <identifiersep> node ) < = line <identifiersep> number ) <ect>
} else if ( at . get <identifiersep> element <identifiersep> type ( ) instanceof simple <identifiersep> type ) { return ( simple <identifiersep> type ) at . get <identifiersep> element <identifiersep> type ( ) ; } else return null ; } else if ( t instanceof parameterized <identifiersep> type ) { parameterized <identifiersep> type pmt = ( parameterized <identifiersep> type ) t ; <LOG> if ( pmt . get <identifiersep> type ( ) instanceof simple <identifiersep> type ) { return ( simple <identifiersep> type ) pmt . get <identifiersep> type ( ) ; } else return null ; } return ( simple <identifiersep> type ) t ; } static public type extrac <identifiersep> type <identifiersep> info2 ( ast <identifiersep> node node ) { <ect>
if ( td . get <identifiersep> name ( ) . to <identifiersep> string ( ) . equals ( name ) ) { if ( constrains . contains ( ast <identifiersep> node . class <identifiersep> instance <identifiersep> creation ) ) { <comment> <LOG> return md ; } } } else { <comment> <ect>
phrase = phrase . substring ( 0 , phrase . length ( ) - 1 ) ; } boolean incremental = ! no <identifiersep> compare && phrase . length ( ) > last <identifiersep> predicted <identifiersep> phrase . length ( ) && phrase . starts <identifiersep> with ( last <identifiersep> predicted <identifiersep> phrase ) ; if ( incremental ) { log ( pde <identifiersep> phrase + <string_literal> + last <identifiersep> predicted <identifiersep> phrase ) ; <LOG> if ( phrase . contains ( <string_literal> ) ) { int x = phrase . last <identifiersep> index <identifiersep> of ( ' . ' ) ; candidates = trim <identifiersep> candidates ( phrase . substring ( x + 1 ) , candidates ) ; } else { candidates = trim <identifiersep> candidates ( phrase , candidates ) ; } last <identifiersep> predicted <identifiersep> phrase = phrase ; <ect>
<comment> protected void print <identifiersep> stack <identifiersep> trace ( thread <identifiersep> reference t ) { if ( ! t . is <identifiersep> suspended ( ) ) { return ; } try { <LOG> int i = 0 ; for ( stack <identifiersep> frame f : t . frames ( ) ) { <comment> <ect>
<comment> public synchronized void print <identifiersep> threads ( ) { if ( ! is <identifiersep> paused ( ) ) { return ; } <LOG> for ( thread <identifiersep> reference t : vm ( ) . all <identifiersep> threads ( ) ) { print <identifiersep> thread ( t ) ; } } <comment> <ect>
<comment> protected void print <identifiersep> thread ( thread <identifiersep> reference t ) { system . out . println ( t . name ( ) ) ; system . out . println ( <string_literal> + t . is <identifiersep> suspended ( ) ) ; <LOG> system . out . println ( <string_literal> + thread <identifiersep> status <identifiersep> to <identifiersep> string ( t . status ( ) ) ) ; } <comment> <ect>
<comment> protected void print <identifiersep> local <identifiersep> variables ( thread <identifiersep> reference t ) { if ( ! t . is <identifiersep> suspended ( ) ) { return ; } try { if ( t . frame <identifiersep> count ( ) == 0 ) { <LOG> } else { stack <identifiersep> frame sf = t . frame ( 0 ) ; list < local <identifiersep> variable > locals = sf . visible <identifiersep> variables ( ) ; if ( locals . is <identifiersep> empty ( ) ) { system . out . println ( <string_literal> ) ; return ; <ect>
for ( tree <identifiersep> path path : expanded <identifiersep> nodes ) { <comment> <LOG> } } <comment> <ect>
<comment> <LOG> break ; } } if ( new <identifiersep> path [ i + 1 ] == null ) { <comment> <ect>
if ( obj == null ) { return false ; } if ( get <identifiersep> class ( ) != obj . get <identifiersep> class ( ) ) { return false ; } final variable <identifiersep> node other = ( variable <identifiersep> node ) obj ; if ( ( this . type == null ) ? ( other . type != null ) : ! this . type . equals ( other . type ) ) { <LOG> return false ; } if ( ( this . name == null ) ? ( other . name != null ) : ! this . name . equals ( other . name ) ) { <comment> <ect>
<comment> <LOG> return false ; } return true ; } <comment> @ override <ect>
for ( file sub : files ) { string relative <identifiersep> path = sub . get <identifiersep> absolute <identifiersep> path ( ) . substring ( root <identifiersep> path . length ( ) ) ; <comment> <LOG> zip <identifiersep> entry entry = new zip <identifiersep> entry ( relative <identifiersep> path ) ; zos . put <identifiersep> next <identifiersep> entry ( entry ) ; <comment> <ect>
( ( event . get <identifiersep> modifiers ( ) & input <identifiersep> event . ctrl <identifiersep> mask ) != 0 ) ) { <comment> <LOG> index -= <number_literal> ; <comment> <ect>
float a = handles . get ( <number_literal> ) . new <identifiersep> value . float <identifiersep> value ( ) ; if ( color <identifiersep> mode . mode <identifiersep> type == color <identifiersep> mode . rgb ) { return verified <identifiersep> rgb <identifiersep> color ( v1 , v2 , v3 , a ) ; } else { return verified <identifiersep> hsb <identifiersep> color ( v1 , v2 , v3 , a ) ; } } } catch ( exception e ) { <LOG> ilegal <identifiersep> color = true ; return color . white ; } <comment> <ect>
<comment> <LOG> if ( m [ 1 ] . equals ( <string_literal> ) ) { exception . set <identifiersep> message ( <string_literal> ) ; system . err . println ( <string_literal> + <string_literal> ) ; handle <identifiersep> crusty <identifiersep> code ( ) ; } else { <ect>
mapper . insert <identifiersep> directory ( folder . get <identifiersep> absolute <identifiersep> path ( ) ) ; break ; } } } else if ( p <identifiersep> applet . platform == p <identifiersep> constants . linux ) { check <identifiersep> dir ( <string_literal> , mapper ) ; check <identifiersep> dir ( <string_literal> , mapper ) ; check <identifiersep> dir ( system . get <identifiersep> property ( <string_literal> ) + <string_literal> , mapper ) ; } <LOG> } return mapper ; } static protected void check <identifiersep> dir ( string path , default <identifiersep> font <identifiersep> mapper mapper ) { file folder = new file ( path ) ; if ( folder . exists ( ) ) { mapper . insert <identifiersep> directory ( path ) ; traverse <identifiersep> dir ( folder , mapper ) ; <ect>
<comment> public boolean displayable ( ) { return false ; } <comment> <LOG> <comment> <comment> <ect>
public void end <identifiersep> record ( ) { super . end <identifiersep> record ( ) ; dispose ( ) ; } public void end <identifiersep> raw ( ) { system . out . println ( <string_literal> ) ; super . end <identifiersep> raw ( ) ; <LOG> <comment> <comment> <ect>
<comment> <comment> <LOG> g2 . fill <identifiersep> rect ( ( int ) x1 , ( int ) y1 , ( int ) ( x2 - x1 ) , ( int ) ( y2 - y1 ) ) ; } * <comment> <ect>
return <string_literal> } private void generate <identifiersep> main <identifiersep> java <identifiersep> file <identifiersep> echoing ( string out , string err ) { file ( <string_literal> ) < < <string_literal> <string_literal> $out <string_literal> <LOG> } } <string_literal> <string_literal> <ect>
public static void main ( string . . . args ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> <string_literal> public class hello { public static void main ( string . . . args ) { <LOG> } } <string_literal> <string_literal> main <string_literal> build . gradle <string_literal> <string_literal> apply plugin : <string_literal> <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> java <string_literal> <string_literal> file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> } } <string_literal> <string_literal> <string_literal> apply plugin : in <identifiersep> memory <identifiersep> build <identifiersep> cache <identifiersep> plugin <string_literal> <string_literal> <ect>
private $option <identifiersep> type my <identifiersep> prop ; @ option ( option = <string_literal> , description = <string_literal> ) public void set <identifiersep> my <identifiersep> prop ( $option <identifiersep> type my <identifiersep> prop ) { this . my <identifiersep> prop = my <identifiersep> prop ; } @ task <identifiersep> action public void render <identifiersep> option <identifiersep> value ( ) { <LOG> } private static enum test <identifiersep> enum { opt <identifiersep> 1 , opt <identifiersep> <number_literal> , opt <identifiersep> <number_literal> } } <string_literal> <string_literal> <string_literal> import org . gradle . api . default <identifiersep> task ; <ect>
private void write <identifiersep> detail <identifiersep> tree ( list < build <identifiersep> operation <identifiersep> record > roots ) throws io <identifiersep> exception { try { string raw <identifiersep> json = json <identifiersep> output . to <identifiersep> json ( build <identifiersep> operation <identifiersep> tree . serialize ( roots ) ) ; string pretty <identifiersep> json = json <identifiersep> output . pretty <identifiersep> print ( raw <identifiersep> json ) ; files . as <identifiersep> char <identifiersep> sink ( file ( base <identifiersep> path , <string_literal> ) , charsets . utf <identifiersep> <number_literal> ) . write ( pretty <identifiersep> json ) ; } catch ( out <identifiersep> of <identifiersep> memory <identifiersep> error e ) { <LOG> } } private void write <identifiersep> summary <identifiersep> tree ( final list < build <identifiersep> operation <identifiersep> record > roots ) throws io <identifiersep> exception { files . as <identifiersep> char <identifiersep> sink ( file ( base <identifiersep> path , <string_literal> ) , charsets . utf <identifiersep> <number_literal> ) . write <identifiersep> lines ( new iterable < string > ( ) { @ override @ nonnull public iterator < string > iterator ( ) { final deque < queue < build <identifiersep> operation <identifiersep> record > > stack = new array <identifiersep> deque < queue < build <identifiersep> operation <identifiersep> record > > ( collections . singleton ( new array <identifiersep> deque < build <identifiersep> operation <identifiersep> record > ( roots ) ) ) ; <ect>
return ; } active . put ( id , <string_literal> ) ; started notification = new started ( start <identifiersep> event . get <identifiersep> start <identifiersep> time ( ) , id , parent <identifiersep> id , build <identifiersep> operation . get <identifiersep> details ( ) ) ; try { notification <identifiersep> listener . started ( notification ) ; } catch ( throwable e ) { <LOG> maybe <identifiersep> throw ( e ) ; } } private void maybe <identifiersep> throw ( throwable e ) { if ( e instanceof error && ! ( e instanceof linkage <identifiersep> error ) ) { throw ( error ) e ; } } @ override public void progress ( operation <identifiersep> identifier build <identifiersep> operation <identifiersep> id , operation <identifiersep> progress <identifiersep> event progress <identifiersep> event ) { <ect>
return new delta ( file <identifiersep> system <identifiersep> subset , immutable <identifiersep> set . copy <identifiersep> of ( current <identifiersep> watch <identifiersep> points ) ) ; } public boolean should <identifiersep> fire ( file file ) { return root <identifiersep> subset . contains ( file ) ; } public boolean should <identifiersep> watch ( file directory ) { final boolean result = root <identifiersep> subset . is <identifiersep> in <identifiersep> roots <identifiersep> or <identifiersep> ancestor <identifiersep> or <identifiersep> any <identifiersep> root ( directory ) || is <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( directory , all <identifiersep> requested <identifiersep> roots , true ) ; <LOG> } return result ; } class delta { private file <identifiersep> system <identifiersep> subset file <identifiersep> system <identifiersep> subset ; private iterable < ? extends file > roots ; private file <identifiersep> system <identifiersep> subset combined <identifiersep> roots ; private iterable < ? extends file > starting <identifiersep> watch <identifiersep> points ; <ect>
return ( watch <identifiersep> event . modifier ) enum . value <identifiersep> of ( ( class < enum > ) class . for <identifiersep> name ( class <identifiersep> name ) , enum <identifiersep> name ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } } void watch ( file <identifiersep> system <identifiersep> subset file <identifiersep> system <identifiersep> subset ) throws io <identifiersep> exception { lock . lock ( ) ; try { <LOG> final watch <identifiersep> points <identifiersep> registry . delta delta = watch <identifiersep> points <identifiersep> registry . append <identifiersep> file <identifiersep> system <identifiersep> subset ( file <identifiersep> system <identifiersep> subset , get <identifiersep> current <identifiersep> watch <identifiersep> points ( ) ) ; iterable < ? extends file > starting <identifiersep> watch <identifiersep> points = delta . get <identifiersep> starting <identifiersep> watch <identifiersep> points ( ) ; for ( file dir : starting <identifiersep> watch <identifiersep> points ) { log . debug ( <string_literal> , dir ) ; final path dir <identifiersep> path = dir . to <identifiersep> path ( ) ; watch <identifiersep> dir ( dir <identifiersep> path ) ; <ect>
} catch ( unrecoverable <identifiersep> task <identifiersep> output <identifiersep> unpacking <identifiersep> exception e ) { <comment> <LOG> } } else { logger . info ( <string_literal> , task ) ; } } else { logger . info ( <string_literal> , task ) ; } } delegate . execute ( task , state , context ) ; if ( task <identifiersep> output <identifiersep> caching <identifiersep> enabled ) { <ect>
} catch ( exception e ) { <comment> <LOG> } } delegate . execute ( task , state , context ) ; if ( task <identifiersep> output <identifiersep> caching <identifiersep> enabled ) { if ( cache <identifiersep> key . is <identifiersep> valid ( ) ) { if ( state . get <identifiersep> failure ( ) == null ) { try { task <identifiersep> artifact <identifiersep> state task <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; <ect>
task <identifiersep> artifact <identifiersep> state task <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; map < string , map < string , file <identifiersep> content <identifiersep> snapshot > > output <identifiersep> snapshots = task <identifiersep> state . get <identifiersep> output <identifiersep> content <identifiersep> snapshots ( ) ; build <identifiersep> cache . store ( build <identifiersep> cache <identifiersep> command <identifiersep> factory . create <identifiersep> store ( cache <identifiersep> key , output <identifiersep> properties , output <identifiersep> snapshots , task , context . get <identifiersep> execution <identifiersep> time ( ) ) ) ; } catch ( exception e ) { logger . warn ( <string_literal> , cache <identifiersep> key . get <identifiersep> display <identifiersep> name ( ) , task , e ) ; } } else { <LOG> } } else { logger . info ( <string_literal> , task ) ; } } } private static sorted <identifiersep> set < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > resolve <identifiersep> properties ( immutable <identifiersep> sorted <identifiersep> set < ? extends task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > properties ) { immutable <identifiersep> sorted <identifiersep> set . builder < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > builder = immutable <identifiersep> sorted <identifiersep> set . natural <identifiersep> order ( ) ; for ( task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec property : properties ) { <comment> <ect>
try { skip = ! task . get <identifiersep> only <identifiersep> if ( ) . is <identifiersep> satisfied <identifiersep> by ( task ) ; } catch ( throwable t ) { state . set <identifiersep> outcome ( new gradle <identifiersep> exception ( string . format ( <string_literal> , task ) , t ) ) ; return ; } if ( skip ) { <LOG> state . set <identifiersep> outcome ( task <identifiersep> execution <identifiersep> outcome . skipped ) ; return ; } executer . execute ( task , state , context ) ; } } <ect>
if ( file <identifiersep> or <identifiersep> directory . exists ( ) ) { if ( file <identifiersep> or <identifiersep> directory . is <identifiersep> file ( ) ) { process <identifiersep> single <identifiersep> file ( file <identifiersep> or <identifiersep> directory , visitor , spec , stop <identifiersep> flag ) ; } else { walk <identifiersep> dir ( file <identifiersep> or <identifiersep> directory , path , visitor , spec , stop <identifiersep> flag ) ; } } else { <LOG> } } private void process <identifiersep> single <identifiersep> file ( file file , file <identifiersep> visitor visitor , spec < file <identifiersep> tree <identifiersep> element > spec , atomic <identifiersep> boolean stop <identifiersep> flag ) { relative <identifiersep> path path = new relative <identifiersep> path ( true , file . get <identifiersep> name ( ) ) ; file <identifiersep> visit <identifiersep> details details = new default <identifiersep> file <identifiersep> visit <identifiersep> details ( file , path , stop <identifiersep> flag , file <identifiersep> system , file <identifiersep> system , false ) ; if ( is <identifiersep> allowed ( details , spec ) ) { visitor . visit <identifiersep> file ( details ) ; } } private void walk <identifiersep> dir ( file file , relative <identifiersep> path path , file <identifiersep> visitor visitor , spec < file <identifiersep> tree <identifiersep> element > spec , atomic <identifiersep> boolean stop <identifiersep> flag ) { <ect>
if ( ! visited <identifiersep> files . add ( details . get <identifiersep> relative <identifiersep> path ( ) ) ) { if ( strategy == duplicates <identifiersep> strategy . exclude ) { return ; } else if ( strategy == duplicates <identifiersep> strategy . fail ) { throw new duplicate <identifiersep> file <identifiersep> copying <identifiersep> exception ( string . format ( <string_literal> , details . get <identifiersep> relative <identifiersep> path ( ) ) ) ; } else if ( strategy == duplicates <identifiersep> strategy . warn ) { <LOG> } } } action . process <identifiersep> file ( details ) ; } } ) ; } } ) ; } } <ect>
groovy <identifiersep> system <identifiersep> loader groovy <identifiersep> system <identifiersep> for <identifiersep> loader = groovy <identifiersep> system <identifiersep> loader <identifiersep> factory . for <identifiersep> class <identifiersep> loader ( class <identifiersep> loader ) ; cleanup cleanup = new cleanup ( lib <identifiersep> classpath , cached <identifiersep> class <identifiersep> loader , finalizer <identifiersep> thread . get <identifiersep> reference <identifiersep> queue ( ) , class <identifiersep> loader , groovy <identifiersep> system <identifiersep> for <identifiersep> loader , gradle <identifiersep> api <identifiersep> groovy , ant <identifiersep> builder <identifiersep> adapter <identifiersep> groovy ) ; finalizer <identifiersep> thread . put <identifiersep> cleanup ( lib <identifiersep> classpath , cleanup ) ; cache <identifiersep> entries . put ( lib <identifiersep> classpath , cache <identifiersep> entry ) ; } else { <LOG> } } <comment> <ect>
try { while ( ! stopped . get ( ) ) { cleanup entry = ( cleanup ) reference <identifiersep> queue . remove ( ) ; class <identifiersep> path key = entry . get <identifiersep> key ( ) ; remove <identifiersep> cache <identifiersep> entry ( key , entry , dont <identifiersep> close <identifiersep> classloader ) ; } } catch ( interrupted <identifiersep> exception ex ) { <LOG> } } private void remove <identifiersep> cache <identifiersep> entry ( class <identifiersep> path key , cleanup entry , cleanup . mode mode ) { log . debug ( <string_literal> , key . get <identifiersep> as <identifiersep> ur <identifiersep> is ( ) ) ; } lock . lock ( ) ; try { cache <identifiersep> entries . remove ( key ) ; <ect>
try { properties . load ( input <identifiersep> stream ) ; } catch ( io <identifiersep> exception e ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( e ) ; } if ( ! properties . string <identifiersep> property <identifiersep> names ( ) . contains <identifiersep> all ( metadata <identifiersep> keys ) ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; } <LOG> unique <identifiersep> id origin <identifiersep> build <identifiersep> invocation <identifiersep> id = unique <identifiersep> id . from ( properties . get <identifiersep> property ( build <identifiersep> invocation <identifiersep> id <identifiersep> key ) ) ; long original <identifiersep> execution <identifiersep> time = long . parse <identifiersep> long ( properties . get <identifiersep> property ( execution <identifiersep> time <identifiersep> key ) ) ; return new origin <identifiersep> task <identifiersep> execution <identifiersep> metadata ( origin <identifiersep> build <identifiersep> invocation <identifiersep> id , original <identifiersep> execution <identifiersep> time ) ; } } ; } } <ect>
} catch ( exception e ) { logger . warn ( <string_literal> , task ) ; try { cleanup <identifiersep> outputs <identifiersep> after <identifiersep> unpack <identifiersep> failure ( ) ; task <identifiersep> artifact <identifiersep> state . after <identifiersep> outputs <identifiersep> removed <identifiersep> before <identifiersep> task ( ) ; } catch ( exception e <identifiersep> cleanup ) { <LOG> throw new unrecoverable <identifiersep> task <identifiersep> output <identifiersep> unpacking <identifiersep> exception ( string . format ( <string_literal> , task ) , e ) ; } throw new gradle <identifiersep> exception ( string . format ( <string_literal> , task ) , e ) ; } finally { clean <identifiersep> local <identifiersep> state ( ) ; } logger . info ( <string_literal> , task ) ; return new build <identifiersep> cache <identifiersep> load <identifiersep> command . result < origin <identifiersep> task <identifiersep> execution <identifiersep> metadata > ( ) { <ect>
this . task <identifiersep> execution <identifiersep> time = task <identifiersep> execution <identifiersep> time ; } @ override public build <identifiersep> cache <identifiersep> key get <identifiersep> key ( ) { return cache <identifiersep> key ; } @ override public build <identifiersep> cache <identifiersep> store <identifiersep> command . result store ( output <identifiersep> stream output ) throws io <identifiersep> exception { <LOG> final task <identifiersep> output <identifiersep> packer . pack <identifiersep> result pack <identifiersep> result = packer . pack ( output <identifiersep> properties , output <identifiersep> snapshots , output , task <identifiersep> output <identifiersep> origin <identifiersep> factory . create <identifiersep> writer ( task , task <identifiersep> execution <identifiersep> time ) ) ; return new build <identifiersep> cache <identifiersep> store <identifiersep> command . result ( ) { @ override public long get <identifiersep> artifact <identifiersep> entry <identifiersep> count ( ) { return pack <identifiersep> result . get <identifiersep> entries ( ) ; } } ; <ect>
try { process <identifiersep> builder process <identifiersep> builder = process <identifiersep> builder <identifiersep> factory . create <identifiersep> process <identifiersep> builder ( exec <identifiersep> handle ) ; process process = process <identifiersep> launcher . start ( process <identifiersep> builder ) ; streams <identifiersep> handler . connect <identifiersep> streams ( process , exec <identifiersep> handle . get <identifiersep> display <identifiersep> name ( ) , executor ) ; set <identifiersep> process ( process ) ; exec <identifiersep> handle . started ( ) ; <LOG> streams <identifiersep> handler . start ( ) ; if ( exec <identifiersep> handle . is <identifiersep> daemon ( ) ) { streams <identifiersep> handler . stop ( ) ; detached ( ) ; } else { int exit <identifiersep> value = process . wait <identifiersep> for ( ) ; <ect>
system . exit ( <number_literal> ) ; } } public static class slow <identifiersep> app { public static void main ( string [ ] args ) throws interrupted <identifiersep> exception { thread . sleep ( 10000l ) ; } } public static class slow <identifiersep> daemon <identifiersep> app { public static void main ( string [ ] args ) throws interrupted <identifiersep> exception { <LOG> system . out . close ( ) ; system . err . close ( ) ; int nap <identifiersep> time = ( args . length == 0 ) ? 10000l : integer . value <identifiersep> of ( args [ 0 ] ) thread . sleep ( nap <identifiersep> time ) ; } } public static class fast <identifiersep> daemon <identifiersep> app { public static void main ( string [ ] args ) throws interrupted <identifiersep> exception { <ect>
def java <identifiersep> file = new file ( temporary <identifiersep> folder . root , <string_literal> ) java <identifiersep> file . parent <identifiersep> file . mkdirs ( ) java <identifiersep> file < < ''' package pkg ; public class hello { public static void main ( string [ ] args ) { <LOG> } } ''' def checkstyle <identifiersep> config = new file ( temporary <identifiersep> folder . root , <string_literal> ) checkstyle <identifiersep> config . parent <identifiersep> file . mkdirs ( ) checkstyle <identifiersep> config < < ''' < ! doctype module public <string_literal> <ect>
this . data = data ; } @ before <identifiersep> class public void before <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test public void test1 ( ) { <LOG> } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; <ect>
system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { <LOG> } } <ect>
if ( args . length > 1 ) { connector . use <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( new file ( args [ 1 ] ) ) ; } } connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { idea <identifiersep> project project = connection . get <identifiersep> model ( idea <identifiersep> project . class ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( project ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { system . out . println ( <string_literal> + module ) ; <ect>
project <identifiersep> connection connection = connector . connect ( ) ; try { idea <identifiersep> project project = connection . get <identifiersep> model ( idea <identifiersep> project . class ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( project ) ; <LOG> system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { <ect>
system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( project ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { <LOG> system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; <ect>
system . out . println ( project ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; <LOG> for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> source <identifiersep> directory dir : root . get <identifiersep> source <identifiersep> directories ( ) ) { <ect>
system . out . println ( string . format ( <string_literal> , id ) ) ; try { resource <identifiersep> handler . write <identifiersep> to ( id , http <identifiersep> exchange ) ; } catch ( throwable e ) { failures . add ( e ) ; } } else { <LOG> if ( http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) . equals ( <string_literal> ) ) { http <identifiersep> exchange . send <identifiersep> response <identifiersep> headers ( <number_literal> , - 1 ) ; } else { byte [ ] message = string . format ( <string_literal> , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) . get <identifiersep> path ( ) ) . get <identifiersep> bytes ( ) ; http <identifiersep> exchange . send <identifiersep> response <identifiersep> headers ( <number_literal> , message . length ) ; http <identifiersep> exchange . get <identifiersep> response <identifiersep> body ( ) . write ( message ) ; <ect>
system . out . println ( string . format ( <string_literal> , id , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) ) ) ; return null ; } for ( tracking <identifiersep> http <identifiersep> handler handler : handlers ) { resource <identifiersep> handler resource <identifiersep> handler = handler . handle ( id , http <identifiersep> exchange ) ; if ( resource <identifiersep> handler != null ) { return resource <identifiersep> handler ; } } <LOG> failures . add ( new assertion <identifiersep> error ( string . format ( <string_literal> , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) . get <identifiersep> path ( ) ) ) ) ; } catch ( throwable t ) { system . out . println ( string . format ( <string_literal> , id , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) ) ) ; failures . add ( new assertion <identifiersep> error ( string . format ( <string_literal> , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) . get <identifiersep> path ( ) ) , t ) ) ; } finally { lock . unlock ( ) ; <ect>
return ; } catch ( closed <identifiersep> channel <identifiersep> exception e ) { <comment> <LOG> handle <identifiersep> connection ( output <identifiersep> stream ) ; output <identifiersep> stream . flush ( ) ; } finally { connection . close ( ) ; } } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
} catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } private void handle <identifiersep> connection ( output <identifiersep> stream output <identifiersep> stream ) throws io <identifiersep> exception { system . out . println ( <string_literal> ) ; synchronized ( lock ) { if ( connected ) { <LOG> output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; return ; } system . out . println ( <string_literal> ) ; connected = true ; lock . notify <identifiersep> all ( ) ; long expiry = monotonic <identifiersep> clock <identifiersep> millis ( ) + <number_literal> ; <ect>
<string_literal> <string_literal> void do <identifiersep> something$ { method <identifiersep> num } ( ) { \\ n <string_literal> <LOG> } sb . append ( <string_literal> ) } return sb . to <identifiersep> string ( ) } void simple <identifiersep> android <identifiersep> app ( ) { file ( 'src / main / res / values / strings . xml' ) < < ''' < ? xml version = <string_literal> encoding = <string_literal> ? > < resources > < string name = <string_literal> > android gradle < / string > <ect>
use <identifiersep> multicast <identifiersep> fallback ( ) ; } } private void analyze <identifiersep> network <identifiersep> interfaces ( ) throws socket <identifiersep> exception { enumeration < network <identifiersep> interface > interfaces = network <identifiersep> interface . get <identifiersep> network <identifiersep> interfaces ( ) ; while ( interfaces . has <identifiersep> more <identifiersep> elements ( ) ) { analyze <identifiersep> network <identifiersep> interface ( interfaces . next <identifiersep> element ( ) ) ; } } private void analyze <identifiersep> network <identifiersep> interface ( network <identifiersep> interface network <identifiersep> interface ) { <LOG> try { boolean is <identifiersep> loopback <identifiersep> interface = network <identifiersep> interface . is <identifiersep> loopback ( ) ; logger . debug ( <string_literal> , is <identifiersep> loopback <identifiersep> interface ) ; boolean is <identifiersep> multicast = network <identifiersep> interface . supports <identifiersep> multicast ( ) ; logger . debug ( <string_literal> , is <identifiersep> multicast ) ; boolean is <identifiersep> remote = false ; <ect>
private void analyze <identifiersep> network <identifiersep> interface ( network <identifiersep> interface network <identifiersep> interface ) { logger . debug ( <string_literal> , network <identifiersep> interface . get <identifiersep> display <identifiersep> name ( ) ) ; try { boolean is <identifiersep> loopback <identifiersep> interface = network <identifiersep> interface . is <identifiersep> loopback ( ) ; logger . debug ( <string_literal> , is <identifiersep> loopback <identifiersep> interface ) ; boolean is <identifiersep> multicast = network <identifiersep> interface . supports <identifiersep> multicast ( ) ; <LOG> boolean is <identifiersep> remote = false ; enumeration < inet <identifiersep> address > candidates = network <identifiersep> interface . get <identifiersep> inet <identifiersep> addresses ( ) ; while ( candidates . has <identifiersep> more <identifiersep> elements ( ) ) { inet <identifiersep> address candidate = candidates . next <identifiersep> element ( ) ; if ( is <identifiersep> loopback <identifiersep> interface ) { if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { <ect>
inet <identifiersep> address candidate = candidates . next <identifiersep> element ( ) ; if ( is <identifiersep> loopback <identifiersep> interface ) { if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { logger . debug ( <string_literal> , candidate ) ; loopback . add ( candidate ) ; } else { <LOG> } } else { if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { logger . debug ( <string_literal> , candidate ) ; } else { logger . debug ( <string_literal> , candidate ) ; remote . add ( candidate ) ; <ect>
acme { core { 'hello . java' ( '''package com . acme . core ; import org . apache . commons . lang3 . string <identifiersep> utils ; public class hello { public void greet ( string name ) { <LOG> } } ''' ) } } } } } } } subproject ( 'client' ) { def build <identifiersep> dot <identifiersep> gradle = file ( 'build . gradle' ) with <identifiersep> variants ( build <identifiersep> dot <identifiersep> gradle ) with <identifiersep> dependencies ( build <identifiersep> dot <identifiersep> gradle , 'compile project ( <string_literal> ) ' ) src { <ect>
cached . get <identifiersep> external <identifiersep> resource <identifiersep> meta <identifiersep> data ( ) , new factory < external <identifiersep> resource <identifiersep> meta <identifiersep> data > ( ) { public external <identifiersep> resource <identifiersep> meta <identifiersep> data create ( ) { return remote <identifiersep> meta <identifiersep> data ; } } ) ; if ( is <identifiersep> unchanged ) { <LOG> <comment> <ect>
download <identifiersep> action ( external <identifiersep> resource <identifiersep> name source ) { this . source = source ; } @ override public object execute ( input <identifiersep> stream input <identifiersep> stream , external <identifiersep> resource <identifiersep> meta <identifiersep> data meta <identifiersep> data ) throws io <identifiersep> exception { destination = temporary <identifiersep> file <identifiersep> provider . create <identifiersep> temporary <identifiersep> file ( <string_literal> , <string_literal> ) ; this . meta <identifiersep> data = meta <identifiersep> data ; <LOG> if ( destination . get <identifiersep> parent <identifiersep> file ( ) != null ) { g <identifiersep> file <identifiersep> utils . mkdirs ( destination . get <identifiersep> parent <identifiersep> file ( ) ) ; } file <identifiersep> output <identifiersep> stream output <identifiersep> stream = new file <identifiersep> output <identifiersep> stream ( destination ) ; try { io <identifiersep> utils . copy <identifiersep> large ( input <identifiersep> stream , output <identifiersep> stream ) ; } finally { <ect>
private boolean logged ; public no <identifiersep> maven <identifiersep> local <identifiersep> repository <identifiersep> resource <identifiersep> finder ( cannot <identifiersep> locate <identifiersep> local <identifiersep> maven <identifiersep> repository <identifiersep> exception ex ) { this . ex = ex ; } public locally <identifiersep> available <identifiersep> resource <identifiersep> candidates find <identifiersep> candidates ( module <identifiersep> component <identifiersep> artifact <identifiersep> metadata criterion ) { if ( ! logged ) { logger . warn ( <string_literal> ) ; <LOG> logged = true ; } return new locally <identifiersep> available <identifiersep> resource <identifiersep> candidates ( ) { public boolean is <identifiersep> none ( ) { return true ; } public locally <identifiersep> available <identifiersep> resource find <identifiersep> by <identifiersep> hash <identifiersep> value ( hash <identifiersep> value hash <identifiersep> value ) { return null ; <ect>
<comment> <LOG> return ; } <comment> <ect>
<comment> <LOG> } return ; } <comment> <ect>
return collection <identifiersep> utils . filter ( incoming <identifiersep> edges , transitive <identifiersep> edges ) ; } } <comment> <LOG> return true ; } if ( selector == module <identifiersep> exclusions . exclude <identifiersep> none ( ) ) { return false ; } module <identifiersep> identifier target <identifiersep> module <identifiersep> id = dependency <identifiersep> state . get <identifiersep> module <identifiersep> identifier ( ) ; if ( selector . exclude <identifiersep> module ( target <identifiersep> module <identifiersep> id ) ) { logger . debug ( <string_literal> , target <identifiersep> module <identifiersep> id , this ) ; <ect>
if ( details . has <identifiersep> failure ( ) ) { throw unchecked <identifiersep> exception . throw <identifiersep> as <identifiersep> unchecked <identifiersep> exception ( details . get <identifiersep> failure ( ) ) ; } component <identifiersep> resolution <identifiersep> state selected = details . get <identifiersep> selected ( ) ; conflict <identifiersep> resolution <identifiersep> result result = new default <identifiersep> conflict <identifiersep> resolution <identifiersep> result ( conflict . participants , selected ) ; resolution <identifiersep> action . execute ( result ) ; maybe <identifiersep> set <identifiersep> reason ( conflict . participants , selected ) ; <LOG> } private void maybe <identifiersep> set <identifiersep> reason ( set < module <identifiersep> identifier > partifipants , component <identifiersep> resolution <identifiersep> state selected ) { for ( module <identifiersep> identifier identifier : partifipants ) { module <identifiersep> replacements <identifiersep> data . replacement replacement = module <identifiersep> replacements . get <identifiersep> replacement <identifiersep> for ( identifier ) ; if ( replacement != null ) { string reason = replacement . get <identifiersep> reason ( ) ; if ( reason != null ) { <ect>
if ( fetching <identifiersep> cost . is <identifiersep> fast ( ) ) { return true ; } else if ( fetching <identifiersep> cost . is <identifiersep> expensive ( ) ) { return false ; } } } return true ; } private void resolve <identifiersep> module ( module <identifiersep> component <identifiersep> identifier identifier , component <identifiersep> override <identifiersep> metadata component <identifiersep> override <identifiersep> metadata , buildable <identifiersep> component <identifiersep> resolve <identifiersep> result result ) { <LOG> list < throwable > errors = new array <identifiersep> list < throwable > ( ) ; list < component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state > resolve <identifiersep> states = new array <identifiersep> list < component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state > ( ) ; for ( module <identifiersep> component <identifiersep> repository repository : repositories ) { resolve <identifiersep> states . add ( new component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state ( identifier , component <identifiersep> override <identifiersep> metadata , repository , versioned <identifiersep> component <identifiersep> chooser ) ) ; } final repository <identifiersep> chain <identifiersep> module <identifiersep> resolution latest <identifiersep> resolved = find <identifiersep> best <identifiersep> match ( resolve <identifiersep> states , errors ) ; if ( latest <identifiersep> resolved != null ) { <ect>
for ( module <identifiersep> component <identifiersep> repository repository : repositories ) { resolve <identifiersep> states . add ( new component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state ( identifier , component <identifiersep> override <identifiersep> metadata , repository , versioned <identifiersep> component <identifiersep> chooser ) ) ; } final repository <identifiersep> chain <identifiersep> module <identifiersep> resolution latest <identifiersep> resolved = find <identifiersep> best <identifiersep> match ( resolve <identifiersep> states , errors ) ; if ( latest <identifiersep> resolved != null ) { logger . debug ( <string_literal> , latest <identifiersep> resolved . module . get <identifiersep> module <identifiersep> version <identifiersep> id ( ) , latest <identifiersep> resolved . repository ) ; for ( throwable error : errors ) { <LOG> } result . resolved ( meta <identifiersep> data <identifiersep> factory . transform ( latest <identifiersep> resolved ) ) ; return ; } if ( ! errors . is <identifiersep> empty ( ) ) { result . failed ( new module <identifiersep> version <identifiersep> resolve <identifiersep> exception ( identifier , errors ) ) ; } else { for ( component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state resolve <identifiersep> state : resolve <identifiersep> states ) { <ect>
list < throwable > errors = new array <identifiersep> list < throwable > ( ) ; list < repository <identifiersep> resolve <identifiersep> state > resolve <identifiersep> states = lists . new <identifiersep> array <identifiersep> list <identifiersep> with <identifiersep> capacity ( repositories . size ( ) ) ; for ( module <identifiersep> component <identifiersep> repository repository : repositories ) { resolve <identifiersep> states . add ( new repository <identifiersep> resolve <identifiersep> state ( versioned <identifiersep> component <identifiersep> chooser , dependency , repository , version <identifiersep> selector , rejected <identifiersep> version <identifiersep> selector ) ) ; } final repository <identifiersep> chain <identifiersep> module <identifiersep> resolution latest <identifiersep> resolved = find <identifiersep> latest <identifiersep> module ( resolve <identifiersep> states , errors ) ; if ( latest <identifiersep> resolved != null ) { <LOG> for ( throwable error : errors ) { logger . debug ( <string_literal> , error ) ; } result . resolved ( meta <identifiersep> data <identifiersep> factory . transform ( latest <identifiersep> resolved ) ) ; return ; } if ( ! errors . is <identifiersep> empty ( ) ) { result . failed ( new module <identifiersep> version <identifiersep> resolve <identifiersep> exception ( requested , errors ) ) ; <ect>
public build <identifiersep> operation <identifiersep> descriptor . builder description ( ) { string display <identifiersep> name = <string_literal> + file . get <identifiersep> name ( ) ; return build <identifiersep> operation <identifiersep> descriptor . display <identifiersep> name ( display <identifiersep> name ) . progress <identifiersep> display <identifiersep> name ( display <identifiersep> name ) ; } } ) ; } } ) ; <LOG> return jar <identifiersep> file ; } } <ect>
logger . debug ( <string_literal> , put <identifiersep> request . get <identifiersep> name ( ) , put <identifiersep> request . get <identifiersep> bucket ( ) ) ; put <identifiersep> request . execute ( ) ; } catch ( io <identifiersep> exception e ) { throw resource <identifiersep> exceptions . put <identifiersep> failed ( destination , e ) ; } } @ nullable public storage <identifiersep> object get <identifiersep> resource ( uri uri ) throws resource <identifiersep> exception { <LOG> string path = clean <identifiersep> resource <identifiersep> path ( uri ) ; try { storage . objects . get get <identifiersep> request = storage . objects ( ) . get ( uri . get <identifiersep> host ( ) , path ) ; return get <identifiersep> request . execute ( ) ; } catch ( google <identifiersep> json <identifiersep> response <identifiersep> exception e ) { <comment> <ect>
gradle <identifiersep> build build = controller . get <identifiersep> build <identifiersep> model ( ) ; map < string , android <identifiersep> project > result = new tree <identifiersep> map < string , android <identifiersep> project > ( ) ; for ( basic <identifiersep> gradle <identifiersep> project project : build . get <identifiersep> projects ( ) ) { android <identifiersep> project android <identifiersep> project = controller . find <identifiersep> model ( project , android <identifiersep> project . class ) ; result . put ( project . get <identifiersep> path ( ) , android <identifiersep> project ) ; } timer . stop ( ) ; <LOG> <comment> <ect>
model <identifiersep> builder . set <identifiersep> jvm <identifiersep> arguments ( <string_literal> ) ; if ( model <identifiersep> builder <identifiersep> action != null ) { model <identifiersep> builder <identifiersep> action . execute ( model <identifiersep> builder ) ; } timer action <identifiersep> timer = new timer ( ) ; map < string , android <identifiersep> project > models = model <identifiersep> builder . run ( ) ; action <identifiersep> timer . stop ( ) ; <LOG> system . out . println ( <string_literal> + models . size ( ) ) ; new inspector ( ) . inspect <identifiersep> model ( models ) ; sync <identifiersep> timer . stop ( ) ; system . out . println ( <string_literal> + sync <identifiersep> timer . duration ( ) ) ; } } <ect>
map < string , android <identifiersep> project > models = model <identifiersep> builder . run ( ) ; action <identifiersep> timer . stop ( ) ; system . out . println ( <string_literal> + action <identifiersep> timer . duration ( ) ) ; system . out . println ( <string_literal> + models . size ( ) ) ; new inspector ( ) . inspect <identifiersep> model ( models ) ; sync <identifiersep> timer . stop ( ) ; <LOG> } } <ect>
@ inject public custom <identifiersep> task ( string message , int number ) { this . message = message ; this . number = number ; } @ task <identifiersep> action void print <identifiersep> it ( ) { <LOG> } } @ override public void apply ( project p ) { p . get <identifiersep> tasks ( ) . create ( <string_literal> , custom <identifiersep> task . class , <string_literal> ) ; } } ''' file ( 'build <identifiersep> src / src / main / resources / meta - <number_literal> / gradle - plugins / custom . properties' ) < < 'implementation - class = custom <identifiersep> plugin' build <identifiersep> file < < <string_literal> <ect>
public custom <identifiersep> task ( int number , worker <identifiersep> executor executor ) { this . number = number ; this . executor = executor ; } @ task <identifiersep> action void print <identifiersep> it ( ) { if ( executor != null ) { <LOG> } else { system . out . println ( number + <string_literal> ) ; } } } @ override public void apply ( project p ) { p . get <identifiersep> tasks ( ) . create ( <string_literal> , custom <identifiersep> task . class , <number_literal> ) ; } } ''' <ect>
new file ( package <identifiersep> directory , <string_literal> ) . text = <string_literal> <string_literal> <LOG> } } <string_literal> <string_literal> <ect>
then : skipped compilation <identifiersep> task when : file ( 'src / main / java / required <identifiersep> by <identifiersep> scala . java' ) . text = <string_literal> <string_literal> <LOG> <comment> <ect>
import org . gradle . integtests . tooling . fixture . tooling <identifiersep> api <identifiersep> specification import spock . lang . issue @ target <identifiersep> gradle <identifiersep> version ( <string_literal> ) class combining <identifiersep> command <identifiersep> line <identifiersep> arguments <identifiersep> cross <identifiersep> version <identifiersep> spec extends tooling <identifiersep> api <identifiersep> specification { @ issue ( <string_literal> ) def <string_literal> ( ) { <LOG> when : def out = with <identifiersep> build { it . with <identifiersep> arguments ( ' - b' , 'build <identifiersep> x . gradle' , ' - i' ) } . standard <identifiersep> output then : out . contains ( 'info message' ) } <comment> <ect>
tooling <identifiersep> api . close ( ) } def <string_literal> ( ) { tooling <identifiersep> api . verbose <identifiersep> logging = true file ( <string_literal> ) < < <string_literal> <string_literal> sys err logging xxx <string_literal> println logging yyy <string_literal> <LOG> project . logger . warn ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; <string_literal> <string_literal> <ect>
println <string_literal> project . logger . error ( <string_literal> ) ; project . logger . warn ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; <LOG> <string_literal> <string_literal> <ect>
assume . assume <identifiersep> true target <identifiersep> dist . tooling <identifiersep> api <identifiersep> non <identifiersep> ascii <identifiersep> output <identifiersep> supported tooling <identifiersep> api . verbose <identifiersep> logging = false file ( <string_literal> ) < < <string_literal> <string_literal> system . err \\ u03b1 \\ u03b2 <string_literal> system . out \\ u03b1 \\ u03b2 <string_literal> error logging \\ u03b1 \\ u03b2 <string_literal> <LOG> project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; <string_literal> <string_literal> <ect>
when : update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { private string name ; private int get <identifiersep> age ( ) { return <number_literal> ; } public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
when : update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { private string name ; public boolean is <identifiersep> famous ; public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' recompiled 'main' <ect>
update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; @ ann2 ( b = <string_literal> , a = <string_literal> ) @ ann1 ( <string_literal> ) public class person { private string name ; public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
update <identifiersep> file ( 'src / my <identifiersep> lib / java / com / acme / person . java' , '''package com . acme ; public class person { private string name ; @ ann2 ( b = <string_literal> , a = <string_literal> ) @ ann1 ( <string_literal> ) public void say <identifiersep> hello ( ) { <LOG> } } ''' ) then : succeeds ' : main <identifiersep> jar' and : recompiled 'my <identifiersep> lib' not <identifiersep> recompiled 'main' <ect>
public class $ { test <identifiersep> class <identifiersep> name } { private final $ { production <identifiersep> class <identifiersep> name } production = new $ { production <identifiersep> class <identifiersep> name } ( <string_literal> ) ; @ test public void test <identifiersep> one ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; <LOG> } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ test public void test <identifiersep> two ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; system . err . println ( <string_literal> + i ) ; <ect>
system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ test public void test <identifiersep> two ( ) { for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; <LOG> } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } } <ect>
this . logging <identifiersep> manager <identifiersep> factory = logging <identifiersep> manager <identifiersep> factory ; this . maven <identifiersep> repository <identifiersep> locator = maven <identifiersep> repository <identifiersep> locator ; } public void publish ( maven <identifiersep> normalized <identifiersep> publication publication , maven <identifiersep> artifact <identifiersep> repository artifact <identifiersep> repository ) { if ( artifact <identifiersep> repository == null ) { logger . info ( <string_literal> ) ; } else { <LOG> } maven <identifiersep> publish <identifiersep> action deploy <identifiersep> task = create <identifiersep> deploy <identifiersep> task ( publication . get <identifiersep> pom <identifiersep> file ( ) , publication . get <identifiersep> metadata <identifiersep> file ( ) , maven <identifiersep> repository <identifiersep> locator , artifact <identifiersep> repository ) ; add <identifiersep> pom <identifiersep> and <identifiersep> artifacts ( deploy <identifiersep> task , publication ) ; execute ( deploy <identifiersep> task ) ; } abstract protected maven <identifiersep> publish <identifiersep> action create <identifiersep> deploy <identifiersep> task ( file pom <identifiersep> file , file metadata <identifiersep> file , local <identifiersep> maven <identifiersep> repository <identifiersep> locator maven <identifiersep> repository <identifiersep> locator , maven <identifiersep> artifact <identifiersep> repository artifact <identifiersep> repository ) ; private void add <identifiersep> pom <identifiersep> and <identifiersep> artifacts ( maven <identifiersep> publish <identifiersep> action publish <identifiersep> action , maven <identifiersep> normalized <identifiersep> publication publication ) { maven <identifiersep> artifact main <identifiersep> artifact = publication . get <identifiersep> main <identifiersep> artifact ( ) ; <ect>
current <identifiersep> build <identifiersep> operation <identifiersep> ref . set ( build <identifiersep> operation <identifiersep> ref ) ; string message = event . get <identifiersep> request <identifiersep> type ( ) == request <identifiersep> type . put ? <string_literal> : <string_literal> ; logger . info ( message , event . get <identifiersep> resource ( ) . get <identifiersep> resource <identifiersep> name ( ) , <string_literal> , event . get <identifiersep> resource ( ) . get <identifiersep> repository <identifiersep> url ( ) ) ; } public void transfer <identifiersep> started ( transfer <identifiersep> event event ) { long content <identifiersep> length = event . get <identifiersep> resource ( ) . get <identifiersep> content <identifiersep> length ( ) ; if ( content <identifiersep> length > 0 ) { <LOG> } } public void transfer <identifiersep> failed ( transfer <identifiersep> event event ) { if ( event . get <identifiersep> exception ( ) instanceof metadata <identifiersep> not <identifiersep> found <identifiersep> exception ) { logger . info ( event . get <identifiersep> exception ( ) . get <identifiersep> message ( ) ) ; } else { logger . error ( event . get <identifiersep> exception ( ) . get <identifiersep> message ( ) ) ; } reset <identifiersep> current <identifiersep> build <identifiersep> operation <identifiersep> ref ( ) ; <ect>
final list < daemon <identifiersep> stop <identifiersep> event > stop <identifiersep> events = daemon <identifiersep> registry . get <identifiersep> stop <identifiersep> events ( ) ; <comment> <LOG> } logger . lifecycle ( daemon <identifiersep> startup <identifiersep> message . generate ( busy <identifiersep> daemons . size ( ) , idle <identifiersep> daemons . size ( ) , recent <identifiersep> stop <identifiersep> events . size ( ) ) ) ; } private daemon <identifiersep> client <identifiersep> connection connect <identifiersep> to <identifiersep> idle <identifiersep> daemon ( collection < daemon <identifiersep> info > idle <identifiersep> daemons , explaining <identifiersep> spec < daemon <identifiersep> context > constraint ) { final list < daemon <identifiersep> info > compatible <identifiersep> idle <identifiersep> daemons = get <identifiersep> compatible <identifiersep> daemons ( idle <identifiersep> daemons , constraint ) ; return find <identifiersep> connection ( compatible <identifiersep> idle <identifiersep> daemons ) ; } private daemon <identifiersep> client <identifiersep> connection connect <identifiersep> to <identifiersep> canceled <identifiersep> daemon ( collection < daemon <identifiersep> info > busy <identifiersep> daemons , explaining <identifiersep> spec < daemon <identifiersep> context > constraint ) { daemon <identifiersep> client <identifiersep> connection connection = null ; <ect>
public daemon <identifiersep> client <identifiersep> connection start <identifiersep> daemon ( explaining <identifiersep> spec < daemon <identifiersep> context > constraint ) { return do <identifiersep> start <identifiersep> daemon ( constraint , false ) ; } private daemon <identifiersep> client <identifiersep> connection do <identifiersep> start <identifiersep> daemon ( explaining <identifiersep> spec < daemon <identifiersep> context > constraint , boolean single <identifiersep> run ) { progress <identifiersep> logger progress <identifiersep> logger = progress <identifiersep> logger <identifiersep> factory . new <identifiersep> operation ( default <identifiersep> daemon <identifiersep> connector . class ) . start ( <string_literal> , <string_literal> ) ; final daemon <identifiersep> startup <identifiersep> info startup <identifiersep> info = daemon <identifiersep> starter . start <identifiersep> daemon ( single <identifiersep> run ) ; <LOG> countdown <identifiersep> timer timer = time . start <identifiersep> countdown <identifiersep> timer ( connect <identifiersep> timeout ) ; try { do { daemon <identifiersep> client <identifiersep> connection daemon <identifiersep> connection = connect <identifiersep> to <identifiersep> daemon <identifiersep> with <identifiersep> id ( startup <identifiersep> info , constraint ) ; if ( daemon <identifiersep> connection != null ) { start <identifiersep> listener . daemon <identifiersep> started ( daemon <identifiersep> connection . get <identifiersep> daemon ( ) ) ; <ect>
private static class forward <identifiersep> text <identifiersep> stream <identifiersep> to <identifiersep> connection implements text <identifiersep> stream { private final dispatch < ? super input <identifiersep> message > dispatch ; public forward <identifiersep> text <identifiersep> stream <identifiersep> to <identifiersep> connection ( dispatch < ? super input <identifiersep> message > dispatch ) { this . dispatch = dispatch ; } public void text ( string input ) { <LOG> } dispatch . dispatch ( new forward <identifiersep> input ( input . get <identifiersep> bytes ( ) ) ) ; } public void end <identifiersep> of <identifiersep> stream ( @ nullable throwable failure ) { close <identifiersep> input message = new close <identifiersep> input ( ) ; logger . debug ( <string_literal> , message ) ; dispatch . dispatch ( message ) ; } } } <ect>
<comment> public object execute ( build <identifiersep> action action , build <identifiersep> request <identifiersep> context request <identifiersep> context , build <identifiersep> action <identifiersep> parameters parameters , service <identifiersep> registry context <identifiersep> services ) { uuid build <identifiersep> id = id <identifiersep> generator . generate <identifiersep> id ( ) ; list < daemon <identifiersep> initial <identifiersep> connect <identifiersep> exception > accumulated <identifiersep> exceptions = lists . new <identifiersep> array <identifiersep> list ( ) ; <LOG> int sane <identifiersep> number <identifiersep> of <identifiersep> attempts = <number_literal> ; <comment> <ect>
logger . warn ( <string_literal> ) ; } } public void on <identifiersep> cancel ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , canceled ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { <LOG> } } public void on <identifiersep> start ( address connector <identifiersep> address ) { logger . info ( <string_literal> , daemon <identifiersep> messages . advertising <identifiersep> daemon , connector <identifiersep> address ) ; logger . debug ( <string_literal> , daemon <identifiersep> context ) ; this . connector <identifiersep> address = connector <identifiersep> address ; daemon <identifiersep> registry . store ( new daemon <identifiersep> info ( connector <identifiersep> address , daemon <identifiersep> context , token , busy ) ) ; } public void on <identifiersep> expire ( string reason , daemon <identifiersep> expiration <identifiersep> status status ) { <ect>
try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , canceled ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } public void on <identifiersep> start ( address connector <identifiersep> address ) { logger . info ( <string_literal> , daemon <identifiersep> messages . advertising <identifiersep> daemon , connector <identifiersep> address ) ; <LOG> this . connector <identifiersep> address = connector <identifiersep> address ; daemon <identifiersep> registry . store ( new daemon <identifiersep> info ( connector <identifiersep> address , daemon <identifiersep> context , token , busy ) ) ; } public void on <identifiersep> expire ( string reason , daemon <identifiersep> expiration <identifiersep> status status ) { logger . debug ( <string_literal> , reason ) ; final date timestamp = new date ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; daemon <identifiersep> registry . store <identifiersep> stop <identifiersep> event ( new daemon <identifiersep> stop <identifiersep> event ( timestamp , daemon <identifiersep> context . get <identifiersep> pid ( ) , status , reason ) ) ; <ect>
daemon <identifiersep> registry . store ( new daemon <identifiersep> info ( connector <identifiersep> address , daemon <identifiersep> context , token , busy ) ) ; } public void on <identifiersep> expire ( string reason , daemon <identifiersep> expiration <identifiersep> status status ) { logger . debug ( <string_literal> , reason ) ; final date timestamp = new date ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; daemon <identifiersep> registry . store <identifiersep> stop <identifiersep> event ( new daemon <identifiersep> stop <identifiersep> event ( timestamp , daemon <identifiersep> context . get <identifiersep> pid ( ) , status , reason ) ) ; } public void stop ( ) { <LOG> try { daemon <identifiersep> registry . remove ( connector <identifiersep> address ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } logger . debug ( <string_literal> ) ; } } <ect>
public void stop ( ) { logger . debug ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . remove ( connector <identifiersep> address ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } <LOG> } } <ect>
failure = e ; return ; } if ( message == null ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) ) ; return ; } if ( message instanceof input <identifiersep> message ) { <LOG> stdin <identifiersep> queue . add ( ( input <identifiersep> message ) message ) ; } else if ( message instanceof cancel ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; cancel <identifiersep> queue . add ( ( cancel ) message ) ; } else { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; <ect>
logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; stdin <identifiersep> queue . add ( ( input <identifiersep> message ) message ) ; } else if ( message instanceof cancel ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; cancel <identifiersep> queue . add ( ( cancel ) message ) ; } else { <LOG> receive <identifiersep> queue . add ( message ) ; } } } finally { stdin <identifiersep> queue . disconnect ( ) ; cancel <identifiersep> queue . disconnect ( ) ; disconnect <identifiersep> queue . disconnect ( ) ; receive <identifiersep> queue . disconnect ( failure ) ; <ect>
super ( executor <identifiersep> factory , <string_literal> ) ; } @ override protected boolean do <identifiersep> handle <identifiersep> command ( runnable handler , cancel command ) { try { handler . run ( ) ; } catch ( exception e ) { <LOG> } return true ; } @ override protected void do <identifiersep> handle <identifiersep> disconnect ( ) { queue . clear ( ) ; } } private static class disconnect <identifiersep> queue implements stoppable { private final lock lock = new reentrant <identifiersep> lock ( ) ; <ect>
@ override public daemon <identifiersep> expiration <identifiersep> result check <identifiersep> expiration ( ) { try { final daemon <identifiersep> context daemon <identifiersep> context = daemon . get <identifiersep> daemon <identifiersep> context ( ) ; final file daemon <identifiersep> registry <identifiersep> dir = daemon <identifiersep> context . get <identifiersep> daemon <identifiersep> registry <identifiersep> dir ( ) ; if ( ! new daemon <identifiersep> dir ( daemon <identifiersep> registry <identifiersep> dir ) . get <identifiersep> registry ( ) . can <identifiersep> read ( ) ) { <LOG> return new daemon <identifiersep> expiration <identifiersep> result ( graceful <identifiersep> expire , registry <identifiersep> became <identifiersep> unreadable ) ; } else { <comment> <ect>
} else { symlink symlink = new native <identifiersep> platform <identifiersep> backed <identifiersep> symlink ( posix <identifiersep> files ) ; file <identifiersep> mode <identifiersep> mutator chmod = new native <identifiersep> platform <identifiersep> backed <identifiersep> chmod ( posix <identifiersep> files ) ; file <identifiersep> mode <identifiersep> accessor stat = new native <identifiersep> platform <identifiersep> backed <identifiersep> stat ( posix <identifiersep> files ) ; return new generic <identifiersep> file <identifiersep> system ( chmod , stat , symlink , metadata <identifiersep> accessor ) ; } symlink symlink = java <identifiersep> reflection <identifiersep> util . new <identifiersep> instance <identifiersep> or <identifiersep> fallback ( <string_literal> , file <identifiersep> system <identifiersep> services . class . get <identifiersep> class <identifiersep> loader ( ) , unsupported <identifiersep> symlink . class ) ; <LOG> <comment> <ect>
if ( separator <identifiersep> pos > - 1 ) { try { pid = long . parse <identifiersep> long ( runtime <identifiersep> mx <identifiersep> bean <identifiersep> name . substring ( 0 , separator <identifiersep> pos ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { logger . debug ( <string_literal> + runtime <identifiersep> mx <identifiersep> bean <identifiersep> name ) ; } } else { <LOG> } return pid ; } @ override public environment <identifiersep> modification <identifiersep> result maybe <identifiersep> set <identifiersep> environment ( map < string , string > source ) { return environment <identifiersep> modification <identifiersep> result . unsupported <identifiersep> environment ; } @ override public void remove <identifiersep> environment <identifiersep> variable ( string name ) throws native <identifiersep> integration <identifiersep> exception { <ect>
net . rubygrapefruit . platform . native . init ( native <identifiersep> base <identifiersep> dir ) ; } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception ex ) { logger . debug ( <string_literal> ) ; use <identifiersep> native <identifiersep> integrations = false ; } catch ( native <identifiersep> exception ex ) { if ( ex . get <identifiersep> cause ( ) instanceof unsatisfied <identifiersep> link <identifiersep> error && ex . get <identifiersep> cause ( ) . get <identifiersep> message ( ) . to <identifiersep> lower <identifiersep> case ( ) . contains ( <string_literal> ) ) { <LOG> use <identifiersep> native <identifiersep> integrations = false ; } else if ( ex . get <identifiersep> message ( ) . equals ( <string_literal> ) && ex . get <identifiersep> cause ( ) . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <comment> <ect>
logger . debug ( <string_literal> , format ( ex ) ) ; use <identifiersep> native <identifiersep> integrations = false ; } else { throw ex ; } } if ( initialize <identifiersep> jansi ) { jansi <identifiersep> boot <identifiersep> path <identifiersep> configurer . configure ( native <identifiersep> base <identifiersep> dir ) ; } <LOG> } initialized = true ; } } public static file get <identifiersep> native <identifiersep> services <identifiersep> dir ( file user <identifiersep> home <identifiersep> dir ) { string override <identifiersep> property = get <identifiersep> native <identifiersep> dir <identifiersep> override ( ) ; if ( override <identifiersep> property == null ) { return new file ( user <identifiersep> home <identifiersep> dir , <string_literal> ) ; } else { <ect>
given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> command <identifiersep> line <identifiersep> process <identifiersep> logging ( ) def logger = logger <identifiersep> factory . get <identifiersep> logger ( <string_literal> ) def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) when : <LOG> then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) logger . info ( <string_literal> ) <ect>
then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) logger . info ( <string_literal> ) <LOG> then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . stop ( ) <ect>
given : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> command <identifiersep> line <identifiersep> process <identifiersep> logging ( ) def logger = logger . get <identifiersep> logger ( <string_literal> ) def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . add <identifiersep> standard <identifiersep> output <identifiersep> listener ( listener ) when : <LOG> then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) logger . info ( <string_literal> ) <ect>
then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) logger . info ( <string_literal> ) <LOG> then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . stop ( ) <ect>
def logging <identifiersep> manager = registry . new <identifiersep> instance ( logging <identifiersep> manager <identifiersep> internal ) logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn logging <identifiersep> manager . start ( ) def logger = logger . get <identifiersep> logger ( <string_literal> ) when : logger . warning ( <string_literal> ) <LOG> then : outputs . std <identifiersep> out == '' outputs . std <identifiersep> err == '' } def does <identifiersep> not <identifiersep> consume <identifiersep> from <identifiersep> system <identifiersep> output <identifiersep> and <identifiersep> error <identifiersep> when <identifiersep> nested ( ) { when : def registry = logging <identifiersep> service <identifiersep> registry . new <identifiersep> nested <identifiersep> logging ( ) <ect>
@ test public void routes <identifiersep> log <identifiersep> messages <identifiersep> via <identifiersep> slf4j ( ) { logger logger = logging . get <identifiersep> logger ( logging <identifiersep> test . class ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . debug , <string_literal> ) ; logger . debug ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . info , <string_literal> ) ; <LOG> expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . warn , <string_literal> ) ; logger . warn ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; logger . lifecycle ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . error , <string_literal> ) ; logger . error ( <string_literal> ) ; <ect>
logger . info ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . warn , <string_literal> ) ; logger . warn ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; logger . lifecycle ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . error , <string_literal> ) ; <LOG> expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . quiet , <string_literal> ) ; logger . quiet ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; logger . log ( log <identifiersep> level . lifecycle , <string_literal> ) ; } @ test public void ignores <identifiersep> trace <identifiersep> level <identifiersep> logging ( ) { <ect>
@ test public void ignores <identifiersep> trace <identifiersep> level <identifiersep> logging ( ) { logger logger = logging . get <identifiersep> logger ( logging <identifiersep> test . class ) ; context . checking ( new expectations ( ) { { never ( output <identifiersep> event <identifiersep> listener ) ; } } ) ; <LOG> } @ test public void delegates <identifiersep> level <identifiersep> is <identifiersep> enabled <identifiersep> to <identifiersep> slf4j ( ) { logging . set <identifiersep> level ( log <identifiersep> level . warn ) ; logger logger = logging . get <identifiersep> logger ( logging <identifiersep> test . class ) ; assert <identifiersep> true ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) ; <ect>
if ( module <identifiersep> swift <identifiersep> deps . exists ( ) && ! changed <identifiersep> sources . is <identifiersep> empty ( ) ) { try { swift <identifiersep> deps swift <identifiersep> deps = parse ( module <identifiersep> swift <identifiersep> deps ) ; adjust <identifiersep> timestamps ( swift <identifiersep> deps , changed <identifiersep> sources ) ; write ( module <identifiersep> swift <identifiersep> deps , swift <identifiersep> deps ) ; } catch ( exception e ) { <LOG> return false ; } } return true ; } <comment> <ect>
public class hello { public static void main ( string . . . args ) { <LOG> } } <ect>
spec . set <identifiersep> source ( new simple <identifiersep> file <identifiersep> collection ( spec . get <identifiersep> source ( ) . get <identifiersep> files ( ) ) ) ; } private void resolve <identifiersep> classpath ( scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { list < file > class <identifiersep> path = lists . new <identifiersep> array <identifiersep> list ( spec . get <identifiersep> compile <identifiersep> classpath ( ) ) ; class <identifiersep> path . add ( spec . get <identifiersep> destination <identifiersep> dir ( ) ) ; spec . set <identifiersep> compile <identifiersep> classpath ( class <identifiersep> path ) ; <LOG> } } private void resolve <identifiersep> non <identifiersep> strings <identifiersep> in <identifiersep> compiler <identifiersep> args ( scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { <comment> <ect>
private work <identifiersep> result delegate <identifiersep> and <identifiersep> handle <identifiersep> errors ( scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { try { return delegate . execute ( spec ) ; } catch ( compilation <identifiersep> failed <identifiersep> exception e ) { if ( spec . get <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> fail <identifiersep> on <identifiersep> error ( ) && spec . get <identifiersep> scala <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> fail <identifiersep> on <identifiersep> error ( ) ) { throw e ; } <LOG> return work <identifiersep> results . did <identifiersep> work ( false ) ; } } } <ect>
public properties get <identifiersep> properties ( ) { return properties ; } private class initializer implements cache <identifiersep> initialization <identifiersep> action { public boolean requires <identifiersep> initialization ( file <identifiersep> lock lock ) { if ( ! did <identifiersep> rebuild ) { if ( validator != null && ! validator . is <identifiersep> valid ( ) ) { <LOG> return true ; } } if ( ! lock . get <identifiersep> unlocked <identifiersep> cleanly ( ) ) { if ( lock . get <identifiersep> state ( ) . can <identifiersep> detect <identifiersep> changes ( ) && ! lock . get <identifiersep> state ( ) . is <identifiersep> in <identifiersep> initial <identifiersep> state ( ) ) { logger . warn ( <string_literal> , default <identifiersep> persistent <identifiersep> directory <identifiersep> cache . this ) ; } return true ; } properties cached <identifiersep> properties = g <identifiersep> util . load <identifiersep> properties ( properties <identifiersep> file ) ; <ect>
return true ; } properties cached <identifiersep> properties = g <identifiersep> util . load <identifiersep> properties ( properties <identifiersep> file ) ; for ( map . entry < ? , ? > entry : properties . entry <identifiersep> set ( ) ) { string previous <identifiersep> value = cached <identifiersep> properties . get <identifiersep> property ( entry . get <identifiersep> key ( ) . to <identifiersep> string ( ) ) ; string current <identifiersep> value = entry . get <identifiersep> value ( ) . to <identifiersep> string ( ) ; if ( ! previous <identifiersep> value . equals ( current <identifiersep> value ) ) { <LOG> return true ; } } return false ; } public void initialize ( file <identifiersep> lock file <identifiersep> lock ) { for ( file file : get <identifiersep> base <identifiersep> dir ( ) . list <identifiersep> files ( ) ) { if ( file <identifiersep> lock . is <identifiersep> lock <identifiersep> file ( file ) || file . equals ( properties <identifiersep> file ) ) { continue ; <ect>
return false ; } @ override public void cleanup ( ) { if ( cleanup <identifiersep> action != null ) { timer timer = time . start <identifiersep> timer ( ) ; cleanup <identifiersep> action . clean ( default <identifiersep> persistent <identifiersep> directory <identifiersep> cache . this ) ; <LOG> } g <identifiersep> file <identifiersep> utils . touch ( gc <identifiersep> file ) ; } } } <ect>
this . operation <identifiersep> display <identifiersep> name = operation <identifiersep> display <identifiersep> name ; this . lock <identifiersep> file = determine <identifiersep> lock <identifiersep> target <identifiersep> file ( target ) ; g <identifiersep> file <identifiersep> utils . mkdirs ( lock <identifiersep> file . get <identifiersep> parent <identifiersep> file ( ) ) ; try { lock <identifiersep> file . create <identifiersep> new <identifiersep> file ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> throw e ; } lock <identifiersep> state <identifiersep> serializer state <identifiersep> protocol = options . is <identifiersep> use <identifiersep> cross <identifiersep> version <identifiersep> implementation ( ) ? new version1lock <identifiersep> state <identifiersep> serializer ( ) : new default <identifiersep> lock <identifiersep> state <identifiersep> serializer ( ) ; lock <identifiersep> file <identifiersep> access = new lock <identifiersep> file <identifiersep> access ( lock <identifiersep> file , new lock <identifiersep> state <identifiersep> access ( state <identifiersep> protocol ) ) ; try { if ( when <identifiersep> contended != null ) { file <identifiersep> lock <identifiersep> contention <identifiersep> handler . start ( lock <identifiersep> id , when <identifiersep> contended ) ; <ect>
import static org . junit . assert . * ; public class $ { test <identifiersep> class <identifiersep> name } { private final $ { production <identifiersep> class <identifiersep> name } production = new $ { production <identifiersep> class <identifiersep> name } ( <string_literal> ) ; @ org . junit . test public void test <identifiersep> one ( ) throws exception { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> system . err . println ( <string_literal> + i ) ; if ( i % <number_literal> == 0 ) { thread . sleep ( <number_literal> ) ; } } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) throws exception { <ect>
if ( i % <number_literal> == 0 ) { thread . sleep ( <number_literal> ) ; } } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) throws exception { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> system . err . println ( <string_literal> + i ) ; if ( i % <number_literal> == 0 ) { thread . sleep ( <number_literal> ) ; } } string expected = < % = binding . has <identifiersep> variable ( <string_literal> ) && binding . half <identifiersep> tests <identifiersep> fail ? <string_literal> : <string_literal> % > ; assert <identifiersep> equals ( production . get <identifiersep> property ( ) , expected ) ; } } <ect>
throw new gradle <identifiersep> exception ( <string_literal> , e ) ; } } private static file java <identifiersep> exe ( file jdk <identifiersep> path , string command ) { return new file ( new file ( jdk <identifiersep> path , <string_literal> ) , operating <identifiersep> system . current ( ) . get <identifiersep> executable <identifiersep> name ( command ) ) ; } <comment> <LOG> <comment> private static class java <identifiersep> probe implements opcodes { <ect>
module <identifiersep> build += test <identifiersep> ng ( module <identifiersep> dependencies ) if ( submodule <identifiersep> build <identifiersep> file . exists ( ) ) { submodule <identifiersep> build <identifiersep> file . rename <identifiersep> to ( new file ( project <identifiersep> dir ( module ) , <string_literal> ) ) } def package <identifiersep> tests = package <identifiersep> tests ( module ) ; if ( package <identifiersep> tests ) { module <identifiersep> build += package <identifiersep> tests ; } <LOG> submodule <identifiersep> build <identifiersep> file . text = module <identifiersep> build } <comment> <ect>
system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { <LOG> } } <string_literal> <string_literal> attaches events to correct test descriptors of a suite <string_literal> test . use <identifiersep> test <identifiersep> ng { suites 'suite . xml' } <string_literal> suite . xml <string_literal> <string_literal> < ? xml version = <string_literal> encoding = <string_literal> ? > < ! doctype suite system <string_literal> > < suite name = <string_literal> > <ect>
public class test1 { @ before <identifiersep> class public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { <LOG> } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { <LOG> } } <string_literal> <string_literal> src / test / java / test2 . java <string_literal> <string_literal> import java . io . serializable ; import org . testng . annotations . after <identifiersep> class ; import org . testng . annotations . before <identifiersep> class ; import org . testng . annotations . test ; <ect>
private static final long serial <identifiersep> version <identifiersep> uid = 1l ; } @ before <identifiersep> class public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { <LOG> } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { system . out . println ( <string_literal> ) ; } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; <ect>
@ before <identifiersep> test public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; <LOG> } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; <LOG> } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { <ect>
@ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; <LOG> } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; <LOG> } } <string_literal> <string_literal> <ect>
test < < <string_literal> <string_literal> output from foo <string_literal> <LOG> } } <string_literal> <string_literal> <string_literal> apply plugin : 'java' $ { maven <identifiersep> central <identifiersep> repository ( ) } dependencies { test <identifiersep> compile 'org . testng : testng : <number_literal> . <number_literal> . 1' } <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> log <identifiersep> less <identifiersep> stuff <string_literal> false <string_literal> true <string_literal> stdout . <string_literal> <LOG> } else { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } } <string_literal> <string_literal> test <string_literal> <ect>
public void test ( ) { if ( system . get <identifiersep> property ( <string_literal> , <string_literal> ) . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } else { system . out . println ( <string_literal> ) ; <LOG> } } } <string_literal> <string_literal> test <string_literal> logging <identifiersep> test <string_literal> this is stdout . \\ n <string_literal> <ect>
system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / org / gradle / testing / super <identifiersep> test . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude public class super <identifiersep> test { @ category ( super <identifiersep> class <identifiersep> tests . class ) @ test public void failing ( ) { <LOG> fail ( <string_literal> ) ; } @ category ( super <identifiersep> class <identifiersep> tests . class ) @ test public void passing ( ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / org / gradle / testing / sub <identifiersep> test . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude <ect>
@ suite . suite <identifiersep> classes ( { test . class , other <identifiersep> test . class } ) public class test <identifiersep> suite { @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { <LOG> system . err . println ( <string_literal> ) ; } } <ect>
test <identifiersep> results <identifiersep> provider . visit <identifiersep> classes ( new action < test <identifiersep> class <identifiersep> result > ( ) { public void execute ( final test <identifiersep> class <identifiersep> result result ) { final file report <identifiersep> file = new file ( test <identifiersep> results <identifiersep> dir , get <identifiersep> report <identifiersep> file <identifiersep> name ( result ) ) ; queue . add ( new j <identifiersep> unit <identifiersep> xml <identifiersep> report <identifiersep> file <identifiersep> generator ( result , report <identifiersep> file , xml <identifiersep> writer ) ) ; } } ) ; } } ) ; <LOG> } private string get <identifiersep> report <identifiersep> file <identifiersep> name ( test <identifiersep> class <identifiersep> result result ) { return <string_literal> + file <identifiersep> utils . to <identifiersep> safe <identifiersep> file <identifiersep> name ( result . get <identifiersep> class <identifiersep> name ( ) ) + <string_literal> ; } private static class j <identifiersep> unit <identifiersep> xml <identifiersep> report <identifiersep> file <identifiersep> generator implements runnable <identifiersep> build <identifiersep> operation { private final test <identifiersep> class <identifiersep> result result ; private final file report <identifiersep> file ; private final j <identifiersep> unit <identifiersep> xml <identifiersep> result <identifiersep> writer xml <identifiersep> writer ; <ect>
try { try { completed . await ( ) ; } catch ( interrupted <identifiersep> exception e ) { throw new unchecked <identifiersep> exception ( e ) ; } } finally { <LOG> <comment> <ect>
@ override public void generate <identifiersep> report ( test <identifiersep> results <identifiersep> provider results <identifiersep> provider , file report <identifiersep> dir ) { log . info ( <string_literal> ) ; timer clock = time . start <identifiersep> timer ( ) ; all <identifiersep> test <identifiersep> results model = load <identifiersep> model <identifiersep> from <identifiersep> provider ( results <identifiersep> provider ) ; generate <identifiersep> files ( model , results <identifiersep> provider , report <identifiersep> dir ) ; <LOG> } private all <identifiersep> test <identifiersep> results load <identifiersep> model <identifiersep> from <identifiersep> provider ( test <identifiersep> results <identifiersep> provider results <identifiersep> provider ) { final all <identifiersep> test <identifiersep> results model = new all <identifiersep> test <identifiersep> results ( ) ; results <identifiersep> provider . visit <identifiersep> classes ( new action < test <identifiersep> class <identifiersep> result > ( ) { public void execute ( test <identifiersep> class <identifiersep> result class <identifiersep> result ) { model . add <identifiersep> test <identifiersep> class ( class <identifiersep> result . get <identifiersep> id ( ) , class <identifiersep> result . get <identifiersep> class <identifiersep> name ( ) , class <identifiersep> result . get <identifiersep> class <identifiersep> display <identifiersep> name ( ) ) ; list < test <identifiersep> method <identifiersep> result > collected <identifiersep> results = class <identifiersep> result . get <identifiersep> results ( ) ; <ect>
import org . jetbrains . annotations . not <identifiersep> null ; import org . jetbrains . annotations . nullable ; class a { @ not <identifiersep> null object foo ( string s ) { <LOG> return <string_literal> ; } @ not <identifiersep> null object foo ( ) { return foo ( null ) ; } @ nullable object bar ( string s ) { <ect>
system . out . println ( <string_literal> + s ) ; return s == null ? <string_literal> : null ; } @ not <identifiersep> null object bar ( ) { return bar ( null ) ; } public @ nullable object bar1 ( string s ) { <LOG> return s == null ? <string_literal> : null ; } public @ not <identifiersep> null object bar1 ( ) { return bar1 ( null ) ; } @ deprecated public void f ( ) { f ( 1 ) ; <ect>
class a { private int bar ( string s ) { <LOG> return 0 ; } private int bar ( ) { return bar ( null ) ; } <ect>
system . out . println ( <string_literal> + i + c + s ) ; } void foo ( int i , char c ) { foo ( i , c , <string_literal> ) ; } void foo ( int i ) { foo ( i , 'a' , <string_literal> ) ; } int bar ( string s ) { <LOG> return 0 ; } int bar ( ) { return bar ( null ) ; } <ect>
public class c { private string my <identifiersep> x = <string_literal> ; public string get <identifiersep> x ( ) { <LOG> return my <identifiersep> x ; } public void set <identifiersep> x ( string x ) { this . my <identifiersep> x = x ; } void foo ( ) { system . out . println ( <string_literal> + my <identifiersep> x ) ; } <ect>
<comment> <LOG> case <number_literal> : break loop ; } system . out . println ( ) ; } } <ect>
<comment> <LOG> } <ect>
<comment> <LOG> case <number_literal> : system . out . println ( <string_literal> ) ; throw new runtime <identifiersep> exception ( ) ; default : system . out . println ( <string_literal> ) ; return 0 ; } <ect>
return log ( <string_literal> ) ; } fun box ( ) : string { log ( <string_literal> ) a . b . c ( g ) log ( <string_literal> ) a . b . c ( foo ( ) ) <LOG> a . b . c ( bar ( ) ) log ( <string_literal> ) a . b . c ( baz ( ) ) log ( <string_literal> ) a . b . c ( boo ( g ) ) assert <identifiersep> equals ( <string_literal> <string_literal> <ect>
log ( <string_literal> ) a . b . c ( foo ( ) ) log ( <string_literal> ) a . b . c ( bar ( ) ) log ( <string_literal> ) a . b . c ( baz ( ) ) <LOG> a . b . c ( boo ( g ) ) assert <identifiersep> equals ( <string_literal> <string_literal> <ect>
package foo inline fun bar ( ) : int { log ( <string_literal> ) return <number_literal> } val x : int get ( ) { <LOG> return 1 } fun box ( ) : string { assert <identifiersep> equals ( <number_literal> , x + bar ( ) + x ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
if ( i == 1 ) continue var j = - 1 do { ++ j if ( j == 1 ) { if ( i == <number_literal> ) continue @ outer else continue } <LOG> } while ( j < <number_literal> ) log ( <string_literal> ) } while ( predicate ( i ) ) } fun box ( ) : string { bar { log ( <string_literal> ) <ect>
return } result [ last <identifiersep> parameter . original ] = resolved <identifiersep> call <identifiersep> argument . simple <identifiersep> argument ( external <identifiersep> argument ) } fun process <identifiersep> defaults <identifiersep> and <identifiersep> run <identifiersep> checks ( ) { for ( ( parameter , resolved <identifiersep> argument ) in result ) { if ( ! parameter . is <identifiersep> vararg ) { if ( resolved <identifiersep> argument ! is resolved <identifiersep> call <identifiersep> argument . simple <identifiersep> argument ) { <LOG> } else { if ( resolved <identifiersep> argument . call <identifiersep> argument . is <identifiersep> spread ) { add <identifiersep> diagnostic ( non <identifiersep> vararg <identifiersep> spread ( resolved <identifiersep> argument . call <identifiersep> argument ) ) } } } } for ( parameter in parameters ) { if ( ! result . contains <identifiersep> key ( parameter . original ) ) { if ( parameter . has <identifiersep> default <identifiersep> value ( ) ) { <ect>
if ( ! stub . has <identifiersep> return <identifiersep> type <identifiersep> ref ( ) ) { return null ; } else { list < kt <identifiersep> type <identifiersep> reference > type <identifiersep> references = get <identifiersep> stub <identifiersep> or <identifiersep> psi <identifiersep> children <identifiersep> as <identifiersep> list ( kt <identifiersep> stub <identifiersep> element <identifiersep> types . type <identifiersep> reference ) ; int return <identifiersep> type <identifiersep> ref <identifiersep> position <identifiersep> in <identifiersep> psi = stub . is <identifiersep> extension ( ) ? 1 : 0 ; if ( type <identifiersep> references . size ( ) < = return <identifiersep> type <identifiersep> ref <identifiersep> position <identifiersep> in <identifiersep> psi ) { <LOG> return null ; } return type <identifiersep> references . get ( return <identifiersep> type <identifiersep> ref <identifiersep> position <identifiersep> in <identifiersep> psi ) ; } } return type <identifiersep> ref <identifiersep> helpers <identifiersep> kt . get <identifiersep> type <identifiersep> reference ( this ) ; } @ override @ nullable public kt <identifiersep> type <identifiersep> reference set <identifiersep> type <identifiersep> reference ( @ nullable kt <identifiersep> type <identifiersep> reference type <identifiersep> ref ) { <ect>
val has <identifiersep> question <identifiersep> marks : boolean get ( ) { for ( element in generate <identifiersep> sequence ( node . first <identifiersep> child <identifiersep> node , ast <identifiersep> node : : get <identifiersep> tree <identifiersep> next ) ) { when ( element . element <identifiersep> type ) { kt <identifiersep> tokens . quest - > return true kt <identifiersep> tokens . coloncolon - > return false } } <LOG> } val double <identifiersep> colon <identifiersep> token <identifiersep> reference : psi <identifiersep> element get ( ) = find <identifiersep> child <identifiersep> by <identifiersep> type ( kt <identifiersep> tokens . coloncolon ) ! ! fun set <identifiersep> receiver <identifiersep> expression ( new <identifiersep> receiver <identifiersep> expression : kt <identifiersep> expression ) { val old <identifiersep> receiver <identifiersep> expression = this . receiver <identifiersep> expression old <identifiersep> receiver <identifiersep> expression ? . replace ( new <identifiersep> receiver <identifiersep> expression ) ? : add <identifiersep> before ( new <identifiersep> receiver <identifiersep> expression , double <identifiersep> colon <identifiersep> token <identifiersep> reference ) } val is <identifiersep> empty <identifiersep> lhs : boolean <ect>
int offset = my <identifiersep> builder . get <identifiersep> current <identifiersep> offset ( ) ; parse <identifiersep> expression ( ) ; if (  <identifiersep> at ( long <identifiersep> template <identifiersep> entry <identifiersep> end ) ) { advance ( ) ; break ; } else { <LOG> if ( offset == my <identifiersep> builder . get <identifiersep> current <identifiersep> offset ( ) ) { <comment> <ect>
<comment> private boolean parse <identifiersep> function <identifiersep> parameter <identifiersep> rest ( boolean type <identifiersep> required ) { boolean no <identifiersep> errors = true ; <comment> <LOG> if ( at ( colon ) ) { <comment> <ect>
for ( string version : args ) { maven <identifiersep> comparable <identifiersep> version c = new maven <identifiersep> comparable <identifiersep> version ( version ) ; if ( prev != null ) { int compare = prev . compare <identifiersep> to ( c ) ; <LOG> + ( ( compare == 0 ) ? <string_literal> : ( ( compare < 0 ) ? <string_literal> : <string_literal> ) ) + ' ' + version ) ; } system . out . println ( string . value <identifiersep> of ( i ++ ) + <string_literal> + version + <string_literal> + c . get <identifiersep> canonical ( ) ) ; prev = c ; } } } <ect>
true } ) } private fun traverse <identifiersep> directory ( dir : file , action : ( js <identifiersep> library ) - > unit ) { try { process <identifiersep> directory ( dir , action ) } catch ( ex : io <identifiersep> exception ) { <LOG> } } private fun copy <identifiersep> js <identifiersep> files <identifiersep> from <identifiersep> zip ( file : file , output <identifiersep> library <identifiersep> js <identifiersep> path : string , copy <identifiersep> source <identifiersep> map : boolean ) { traverse <identifiersep> archive ( file ) { copy <identifiersep> library ( output <identifiersep> library <identifiersep> js <identifiersep> path , it , copy <identifiersep> source <identifiersep> map ) } } private fun copy <identifiersep> library ( output <identifiersep> path : string , library : js <identifiersep> library , copy <identifiersep> source <identifiersep> map : boolean ) { val target <identifiersep> file = file ( output <identifiersep> path , library . path ) target <identifiersep> file . parent <identifiersep> file . mkdirs ( ) target <identifiersep> file . write <identifiersep> text ( library . content ) <ect>
val properties = properties ( ) properties . load ( manifest <identifiersep> properties ) js <identifiersep> std <identifiersep> lib = properties . get <identifiersep> property <identifiersep> or <identifiersep> fail ( <string_literal> ) } catch ( e : io <identifiersep> exception ) { log . error ( e ) } } else { <LOG> } title <identifiersep> kotlin <identifiersep> javascript <identifiersep> stdlib = js <identifiersep> std <identifiersep> lib } @ jvm <identifiersep> static fun get <identifiersep> jar <identifiersep> file ( classes <identifiersep> roots : list < virtual <identifiersep> file > , jar <identifiersep> name : string ) : virtual <identifiersep> file ? { return classes <identifiersep> roots . first <identifiersep> or <identifiersep> null { it . name == jar <identifiersep> name } } @ suppress ( <string_literal> ) <comment> <ect>
private fun process <identifiersep> directory <identifiersep> single <identifiersep> evaluator ( source <identifiersep> root : file , target <identifiersep> root : file , evaluator : evaluator ) { val ( source <identifiersep> files , source <identifiersep> directories ) = source <identifiersep> root . list <identifiersep> files ( ) . partition { ! it . is <identifiersep> directory } val processed <identifiersep> files = hash <identifiersep> set <identifiersep> of < file > ( ) for ( source <identifiersep> file in source <identifiersep> files ) { val result = process <identifiersep> file <identifiersep> single <identifiersep> evaluator ( source <identifiersep> file , evaluator ) <LOG> if ( result is file <identifiersep> processing <identifiersep> result . skip ) { continue } val target <identifiersep> file = source <identifiersep> file . make <identifiersep> relative <identifiersep> to ( source <identifiersep> root , target <identifiersep> root ) processed <identifiersep> files += target <identifiersep> file if ( target <identifiersep> file . exists ( ) && target <identifiersep> file . is <identifiersep> directory ) target <identifiersep> file . delete <identifiersep> recursively ( ) <ect>
target <identifiersep> dir . delete ( ) } target <identifiersep> dir . mkdirs <identifiersep> or <identifiersep> fail ( ) process <identifiersep> directory <identifiersep> single <identifiersep> evaluator ( source <identifiersep> dir , target <identifiersep> dir , evaluator ) processed <identifiersep> files += target <identifiersep> dir } for ( target <identifiersep> file in target <identifiersep> root . list <identifiersep> files ( ) ) { if ( ! processed <identifiersep> files . remove ( processed <identifiersep> files . find { file <identifiersep> util . files <identifiersep> equal ( it , target <identifiersep> file ) } ) ) { <LOG> target <identifiersep> file . delete <identifiersep> recursively ( ) } } } } fun string . convert <identifiersep> line <identifiersep> separators ( ) : string = string <identifiersep> util . convert <identifiersep> line <identifiersep> separators ( this ) fun file . is <identifiersep> text <identifiersep> equal <identifiersep> to ( content : string ) : boolean = read <identifiersep> text ( ) . lines ( ) == content . lines ( ) fun file . make <identifiersep> relative <identifiersep> to ( from : file , to : file ) = file ( to , to <identifiersep> relative <identifiersep> string ( from ) ) fun file . mkdirs <identifiersep> or <identifiersep> fail ( ) { if ( ! mkdirs ( ) && ! exists ( ) ) { <ect>
+ already <identifiersep> matched + <string_literal> + erased <identifiersep> signature ) ; } } } private trace <identifiersep> method <identifiersep> visitor get <identifiersep> dumping <identifiersep> visitor <identifiersep> wrapper ( method <identifiersep> visitor mv , string method <identifiersep> name , string method <identifiersep> desc ) { return new trace <identifiersep> method <identifiersep> visitor ( mv , new textifier ( asm5 ) { @ override public void visit <identifiersep> method <identifiersep> end ( ) { <LOG> for ( object line : get <identifiersep> text ( ) ) { system . out . print ( line ) ; } system . out . println ( ) ; system . out . println ( ) ; super . visit <identifiersep> method <identifiersep> end ( ) ; } } ) ; <ect>
system . err . println ( <string_literal> + java <identifiersep> version + <string_literal> + <string_literal> ) ; system . exit ( 1 ) ; } try { run ( args ) ; } catch ( preloader <identifiersep> exception e ) { <LOG> system . err . println ( ) ; print <identifiersep> usage ( system . err ) ; system . exit ( 1 ) ; } } private static void run ( string [ ] args ) throws exception { final long start <identifiersep> time = system . nano <identifiersep> time ( ) ; final options options = parse <identifiersep> options ( args ) ; <ect>
fun box ( ) : string { var bottles = <number_literal> while ( bottles > 0 ) { <LOG> bottles -= 1 bottles -- } return if ( bottles == - 1 ) <string_literal> else <string_literal> } <ect>
var result = <string_literal> fun log ( message : any ) { result += <string_literal> } var proceed : ( ) - > unit = { } var finished = false suspend fun bar ( x : int ) : int = suspend <identifiersep> coroutine { c - > <LOG> proceed = { c . resume ( x ) } } inline suspend fun foo ( x : int ) = bar ( x ) fun async ( a : suspend ( ) - > unit ) { a . start <identifiersep> coroutine ( object : continuation < unit > { override fun resume ( value : unit ) { proceed = { <ect>
<comment> <LOG> } fun box ( ) : string { var del = test <identifiersep> java ( test <identifiersep> runnable ( ) ) del . run ( ) if ( del ! is runnable ) return <string_literal> return <string_literal> <ect>
log = <string_literal> val g1 = g ( object : c { } ) g1 . foo ( <number_literal> ) g1 . foo ( ) val g2 = g ( object : c { override fun foo ( x : int ) { <LOG> } } ) g2 . foo ( <number_literal> ) g2 . foo ( ) } fun test2 ( ) { log = <string_literal> val h1 = h ( object : c { } ) <ect>
import org . jetbrains . kotlin . resolve . descriptor <identifiersep> util . annotation <identifiersep> class import org . jetbrains . kotlin . types . error <identifiersep> utils class annotation <identifiersep> serializer ( private val string <identifiersep> table : descriptor <identifiersep> aware <identifiersep> string <identifiersep> table ) { fun serialize <identifiersep> annotation ( annotation : annotation <identifiersep> descriptor ) : proto <identifiersep> buf . annotation = proto <identifiersep> buf . annotation . new <identifiersep> builder ( ) . apply { val annotation <identifiersep> class = annotation . annotation <identifiersep> class ? : error ( <string_literal> ) if ( error <identifiersep> utils . is <identifiersep> error ( annotation <identifiersep> class ) ) { <LOG> } id = string <identifiersep> table . get <identifiersep> fq <identifiersep> name <identifiersep> index ( annotation <identifiersep> class ) for ( ( name , value ) in annotation . all <identifiersep> value <identifiersep> arguments ) { val argument = proto <identifiersep> buf . annotation . argument . new <identifiersep> builder ( ) argument . name <identifiersep> id = string <identifiersep> table . get <identifiersep> string <identifiersep> index ( name . as <identifiersep> string ( ) ) argument . set <identifiersep> value ( value <identifiersep> proto ( value ) ) add <identifiersep> argument ( argument ) <ect>
private fun < t : any > instantiate <identifiersep> resolver ( resolver <identifiersep> class : k <identifiersep> class < t > ) : t ? { try { resolver <identifiersep> class . object <identifiersep> instance ? . let { return it } val constructor <identifiersep> without <identifiersep> parameters = resolver <identifiersep> class . constructors . find { it . parameters . all { it . is <identifiersep> optional } } if ( constructor <identifiersep> without <identifiersep> parameters == null ) { <LOG> return null } return constructor <identifiersep> without <identifiersep> parameters . call <identifiersep> by ( empty <identifiersep> map ( ) ) } catch ( ex : class <identifiersep> cast <identifiersep> exception ) { log . warn ( <string_literal> ) return null } } private val sam <identifiersep> with <identifiersep> receiver <identifiersep> annotations : list < string > ? by lazy { <ect>
} ? . get <identifiersep> additional <identifiersep> compiler <identifiersep> arguments ( environment ) } private inline fun < t > take <identifiersep> unless <identifiersep> error ( report <identifiersep> error : boolean = true , body : ( ) - > t ? ) : t ? = try { body ( ) } catch ( ex : throwable ) { if ( report <identifiersep> error ) { <LOG> } else { log . warn ( <string_literal> + template . qualified <identifiersep> name , ex ) } null } companion object { internal val log = logger . get <identifiersep> instance ( kotlin <identifiersep> script <identifiersep> definition <identifiersep> from <identifiersep> annotated <identifiersep> template : : class . java ) } } interface dependency <identifiersep> resolver <identifiersep> wrapper < t : script <identifiersep> dependencies <identifiersep> resolver > { <ect>
val daemon <identifiersep> launching <identifiersep> options = configure <identifiersep> daemon <identifiersep> jvm <identifiersep> options ( inherit <identifiersep> memory <identifiersep> limits = true , inherit <identifiersep> other <identifiersep> jvm <identifiersep> options = false , inherit <identifiersep> additional <identifiersep> properties = true ) val client <identifiersep> options = configure <identifiersep> client <identifiersep> options ( ) val filtered <identifiersep> args = args . as <identifiersep> iterable ( ) . filter <identifiersep> extract <identifiersep> props ( compiler <identifiersep> id , daemon <identifiersep> options , daemon <identifiersep> launching <identifiersep> options , client <identifiersep> options , prefix = compile <identifiersep> daemon <identifiersep> cmdline <identifiersep> options <identifiersep> prefix ) if ( ! client <identifiersep> options . stop ) { if ( compiler <identifiersep> id . compiler <identifiersep> classpath . none ( ) ) { <comment> <LOG> detect <identifiersep> compiler <identifiersep> classpath ( ) ? . let { compiler <identifiersep> id . compiler <identifiersep> classpath = it } } if ( compiler <identifiersep> id . compiler <identifiersep> classpath . none ( ) ) throw illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) else println ( <string_literal> + compiler <identifiersep> id . compiler <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( file . path <identifiersep> separator ) ) <ect>
val compiler <identifiersep> messages <identifiersep> stream = print <identifiersep> stream ( buffered <identifiersep> output <identifiersep> stream ( remote <identifiersep> output <identifiersep> stream <identifiersep> client ( compiler <identifiersep> messages <identifiersep> stream <identifiersep> proxy , rpc <identifiersep> profiler ) , remote <identifiersep> stream <identifiersep> buffer <identifiersep> size ) ) val service <identifiersep> output <identifiersep> stream = print <identifiersep> stream ( buffered <identifiersep> output <identifiersep> stream ( remote <identifiersep> output <identifiersep> stream <identifiersep> client ( service <identifiersep> output <identifiersep> stream <identifiersep> proxy , rpc <identifiersep> profiler ) , remote <identifiersep> stream <identifiersep> buffer <identifiersep> size ) ) try { val compile <identifiersep> service <identifiersep> reporter = daemon <identifiersep> message <identifiersep> reporter <identifiersep> print <identifiersep> stream <identifiersep> adapter ( service <identifiersep> output <identifiersep> stream ) if ( args . none ( ) ) throw illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) <LOG> val exit <identifiersep> code = checked <identifiersep> compile ( compile <identifiersep> service <identifiersep> reporter , rpc <identifiersep> profiler ) { body ( compiler <identifiersep> messages <identifiersep> stream , event <identifiersep> manger , rpc <identifiersep> profiler ) . code } compile <identifiersep> service . call <identifiersep> result . good ( exit <identifiersep> code ) } finally { service <identifiersep> output <identifiersep> stream . flush ( ) compiler <identifiersep> messages <identifiersep> stream . flush ( ) <ect>
<string_literal> . let { daemon <identifiersep> message <identifiersep> reporter . report ( report <identifiersep> severity . info , it ) log . info ( it ) } } } return res } <comment> <LOG> throw e } } override fun clear <identifiersep> jar <identifiersep> cache ( ) { zip <identifiersep> handler . clear <identifiersep> file <identifiersep> accessor <identifiersep> cache ( ) ( kotlin <identifiersep> core <identifiersep> environment . application <identifiersep> environment ? . jar <identifiersep> file <identifiersep> system as ? core <identifiersep> jar <identifiersep> file <identifiersep> system ) ? . clear <identifiersep> handlers <identifiersep> cache ( ) } private inline fun < r > if <identifiersep> alive ( min <identifiersep> aliveness : aliveness = aliveness . last <identifiersep> session , body : ( ) - > compile <identifiersep> service . call <identifiersep> result < r > ) : compile <identifiersep> service . call <identifiersep> result < r > = rwlock . read { if <identifiersep> alive <identifiersep> checks <identifiersep> impl ( min <identifiersep> aliveness , body ) <ect>
log . info ( <string_literal> ) compile <identifiersep> service . call <identifiersep> result . dying ( ) } else - > { try { body ( ) } catch ( e : throwable ) { <LOG> compile <identifiersep> service . call <identifiersep> result . error ( e . message ? : <string_literal> ) } } } } private inline fun < r > with <identifiersep> valid <identifiersep> client <identifiersep> or <identifiersep> session <identifiersep> proxy ( session <identifiersep> id : int , body : ( client <identifiersep> or <identifiersep> session <identifiersep> proxy < any > ? ) - > compile <identifiersep> service . call <identifiersep> result < r > ) : compile <identifiersep> service . call <identifiersep> result < r > { val session : client <identifiersep> or <identifiersep> session <identifiersep> proxy < any > ? = if ( session <identifiersep> id == compile <identifiersep> service . no <identifiersep> session ) null <ect>
catch ( e : io <identifiersep> exception ) { } } return null } @ jvm <identifiersep> static fun main ( args : array < string > ) { ensure <identifiersep> server <identifiersep> hostname <identifiersep> is <identifiersep> set <identifiersep> up ( ) val jvm <identifiersep> arguments = management <identifiersep> factory . get <identifiersep> runtime <identifiersep> mx <identifiersep> bean ( ) . input <identifiersep> arguments <LOG> log . info ( <string_literal> + jvm <identifiersep> arguments . join <identifiersep> to <identifiersep> string ( <string_literal> ) ) log . info ( <string_literal> + args . join <identifiersep> to <identifiersep> string ( <string_literal> ) ) set <identifiersep> idea <identifiersep> io <identifiersep> use <identifiersep> fallback ( ) val compiler <identifiersep> id = compiler <identifiersep> id ( ) val daemon <identifiersep> options = daemon <identifiersep> options ( ) try { <ect>
log . debug ( <string_literal> ) } } if ( properties . watch <identifiersep> access && vm . can <identifiersep> watch <identifiersep> field <identifiersep> access ( ) ) { val request = manager . create <identifiersep> access <identifiersep> watchpoint <identifiersep> request ( this , field ) debug <identifiersep> process . requests <identifiersep> manager . enable <identifiersep> request ( request ) <LOG> } } } } breakpoint <identifiersep> type . method - > { val field <identifiersep> name = get <identifiersep> field <identifiersep> name ( ) if ( properties . watch <identifiersep> access ) { val getter = ref <identifiersep> type . methods <identifiersep> by <identifiersep> name ( jvm <identifiersep> abi . getter <identifiersep> name ( field <identifiersep> name ) ) . first <identifiersep> or <identifiersep> null ( ) if ( getter != null ) { create <identifiersep> method <identifiersep> breakpoint ( debug <identifiersep> process , ref <identifiersep> type , getter ) <ect>
else { var entry <identifiersep> request : method <identifiersep> entry <identifiersep> request ? = find <identifiersep> request ( debug <identifiersep> process , method <identifiersep> entry <identifiersep> request : : class . java , this ) if ( entry <identifiersep> request == null ) { entry <identifiersep> request = manager . create <identifiersep> method <identifiersep> entry <identifiersep> request ( this ) ! ! <LOG> } } else { entry <identifiersep> request . disable ( ) } entry <identifiersep> request . add <identifiersep> class <identifiersep> filter ( ref <identifiersep> type ) manager . enable <identifiersep> request ( entry <identifiersep> request ) } } inline private fun < reified t : event <identifiersep> request > find <identifiersep> request ( debug <identifiersep> process : debug <identifiersep> process <identifiersep> impl , request <identifiersep> class : class < t > , requestor : requestor ) : t ? { val requests = debug <identifiersep> process . requests <identifiersep> manager . find <identifiersep> requests ( requestor ) <ect>
fun insert <identifiersep> expression ( expr : kt <identifiersep> element ? ) : list < kt <identifiersep> expression > { when ( expr ) { is kt <identifiersep> block <identifiersep> expression - > return expr . statements . flat <identifiersep> map ( : : insert <identifiersep> expression ) is kt <identifiersep> expression - > { val new <identifiersep> debug <identifiersep> expression = parent . add <identifiersep> before ( expr , element <identifiersep> before ) if ( new <identifiersep> debug <identifiersep> expression == null ) { <LOG> return empty <identifiersep> list ( ) } parent . add <identifiersep> before ( psi <identifiersep> factory . create <identifiersep> new <identifiersep> line ( ) , element <identifiersep> before ) return list <identifiersep> of ( new <identifiersep> debug <identifiersep> expression as kt <identifiersep> expression ) } } return empty <identifiersep> list ( ) } val containing <identifiersep> file = code <identifiersep> fragment . context ? . containing <identifiersep> file if ( containing <identifiersep> file is kt <identifiersep> code <identifiersep> fragment ) { <ect>
import org . jetbrains . kotlin . types . type <identifiersep> util . make <identifiersep> nullable import java . util . concurrent . atomic . atomic <identifiersep> reference class kotlin <identifiersep> code <identifiersep> fragment <identifiersep> factory : code <identifiersep> fragment <identifiersep> factory ( ) { override fun create <identifiersep> code <identifiersep> fragment ( item : text <identifiersep> with <identifiersep> imports , context : psi <identifiersep> element ? , project : project ) : java <identifiersep> code <identifiersep> fragment { val context <identifiersep> element = get <identifiersep> wrapped <identifiersep> context <identifiersep> element ( project , context ) if ( context <identifiersep> element == null ) { <LOG> } val code <identifiersep> fragment = if ( item . kind == code <identifiersep> fragment <identifiersep> kind . expression ) { kt <identifiersep> expression <identifiersep> code <identifiersep> fragment ( project , <string_literal> , item . text , init <identifiersep> imports ( item . imports ) , <ect>
if ( original is type <identifiersep> alias <identifiersep> constructor <identifiersep> descriptor ) { return get <identifiersep> declaration <identifiersep> for <identifiersep> descriptor ( original . type <identifiersep> alias <identifiersep> descriptor , file ) } if ( original is value <identifiersep> parameter <identifiersep> descriptor ) { val callable = original . containing <identifiersep> declaration val callable <identifiersep> declaration = get <identifiersep> declaration <identifiersep> for <identifiersep> descriptor ( callable , file ) as ? kt <identifiersep> callable <identifiersep> declaration ? : return null if ( original . index >= callable <identifiersep> declaration . value <identifiersep> parameters . size ) { <LOG> callable <identifiersep> declaration . value <identifiersep> parameter <identifiersep> list ? . text ) return null } return callable <identifiersep> declaration . value <identifiersep> parameters [ original . index ] } if ( original is constructor <identifiersep> descriptor && original . is <identifiersep> primary ) { val class <identifiersep> or <identifiersep> object = get <identifiersep> declaration <identifiersep> for <identifiersep> descriptor ( original . containing <identifiersep> declaration , file ) as ? kt <identifiersep> class <identifiersep> or <identifiersep> object return class <identifiersep> or <identifiersep> object ? . primary <identifiersep> constructor ? : class <identifiersep> or <identifiersep> object <ect>
<string_literal> } val binary <identifiersep> class <identifiersep> for <identifiersep> package <identifiersep> class = class <identifiersep> finder . find <identifiersep> kotlin <identifiersep> class ( class <identifiersep> id . top <identifiersep> level ( facade <identifiersep> fq <identifiersep> name ) ) val header = binary <identifiersep> class <identifiersep> for <identifiersep> package <identifiersep> class ? . class <identifiersep> header val annotation <identifiersep> data = header ? . data val strings = header ? . strings if ( annotation <identifiersep> data == null || strings == null ) { <LOG> return empty <identifiersep> list ( ) } val ( name <identifiersep> resolver , package <identifiersep> proto ) = jvm <identifiersep> proto <identifiersep> buf <identifiersep> util . read <identifiersep> package <identifiersep> data <identifiersep> from ( annotation <identifiersep> data , strings ) val members <identifiersep> scope = deserialized <identifiersep> package <identifiersep> member <identifiersep> scope ( create <identifiersep> dummy <identifiersep> package <identifiersep> fragment ( header . package <identifiersep> name ? . let ( : : fq <identifiersep> name ) ? : facade <identifiersep> fq <identifiersep> name . parent ( ) ) , package <identifiersep> proto , name <identifiersep> resolver , jvm <identifiersep> package <identifiersep> part <identifiersep> source ( binary <identifiersep> class <identifiersep> for <identifiersep> package <identifiersep> class , package <identifiersep> proto , name <identifiersep> resolver ) , deserialization <identifiersep> components ) { empty <identifiersep> list ( ) } <ect>
val data = class <identifiersep> header . data if ( data == null ) { log . error ( <string_literal> ) return null } val strings = class <identifiersep> header . strings if ( strings == null ) { <LOG> return null } val ( name <identifiersep> resolver , class <identifiersep> proto ) = jvm <identifiersep> proto <identifiersep> buf <identifiersep> util . read <identifiersep> class <identifiersep> data <identifiersep> from ( data , strings ) return class <identifiersep> data ( name <identifiersep> resolver , class <identifiersep> proto , kotlin <identifiersep> jvm <identifiersep> binary <identifiersep> source <identifiersep> element ( binary <identifiersep> class ) ) } } <ect>
val annotation <identifiersep> data = header . data if ( annotation <identifiersep> data == null ) { log . error ( <string_literal> ) return null } val strings = header . strings if ( strings == null ) { <LOG> return null } return when ( header . kind ) { kotlin <identifiersep> class <identifiersep> header . kind . class - > { if ( class <identifiersep> id . is <identifiersep> local ) return null val ( name <identifiersep> resolver , class <identifiersep> proto ) = jvm <identifiersep> proto <identifiersep> buf <identifiersep> util . read <identifiersep> class <identifiersep> data <identifiersep> from ( annotation <identifiersep> data , strings ) val context = components . create <identifiersep> context ( name <identifiersep> resolver , package <identifiersep> fq <identifiersep> name , type <identifiersep> table ( class <identifiersep> proto . type <identifiersep> table ) ) <ect>
override fun depends <identifiersep> on <identifiersep> file <identifiersep> content ( ) = true protected val log : logger = logger . get <identifiersep> instance ( class <identifiersep> of <identifiersep> index ) protected inline fun try <identifiersep> block ( input <identifiersep> data : file <identifiersep> content , body : ( ) - > unit ) { try { body ( ) } catch ( e : throwable ) { <LOG> } } } <ect>
if ( file ! is kt <identifiersep> file || dumb <identifiersep> service . get <identifiersep> instance ( file . get <identifiersep> project ( ) ) . is <identifiersep> dumb ) return list <identifiersep> of ( ) val collected <identifiersep> data = try { collect <identifiersep> reference <identifiersep> data ( file , start <identifiersep> offsets , end <identifiersep> offsets ) } catch ( e : process <identifiersep> canceled <identifiersep> exception ) { <comment> <LOG> return list <identifiersep> of ( ) } catch ( e : throwable ) { log . error ( <string_literal> , e ) return list <identifiersep> of ( ) } if ( collected <identifiersep> data . is <identifiersep> empty ( ) ) return list <identifiersep> of ( ) return list <identifiersep> of ( kotlin <identifiersep> reference <identifiersep> transferable <identifiersep> data ( collected <identifiersep> data . to <identifiersep> typed <identifiersep> array ( ) ) ) <ect>
private fun find <identifiersep> references <identifiersep> to <identifiersep> restore ( file : psi <identifiersep> file , block <identifiersep> start : int , reference <identifiersep> data : array < out kotlin <identifiersep> reference <identifiersep> data > ) : list < reference <identifiersep> to <identifiersep> restore <identifiersep> data > { if ( file ! is kt <identifiersep> file ) return list <identifiersep> of ( ) val references = reference <identifiersep> data . map { it to find <identifiersep> reference ( it , file , block <identifiersep> start ) } val binding <identifiersep> context = try { file . get <identifiersep> resolution <identifiersep> facade ( ) . analyze ( references . map <identifiersep> not <identifiersep> null { it . second ? . element } , body <identifiersep> resolve <identifiersep> mode . partial ) } catch ( e : throwable ) { <LOG> return empty <identifiersep> list ( ) } val file <identifiersep> resolution <identifiersep> scope = file . get <identifiersep> resolution <identifiersep> facade ( ) . get <identifiersep> file <identifiersep> resolution <identifiersep> scope ( file ) return references . map <identifiersep> not <identifiersep> null { pair - > val data = pair . first val reference = pair . second if ( reference != null ) <ect>
expression <identifiersep> type = diagnostic <identifiersep> with <identifiersep> parameters . b } errors . constant <identifiersep> expected <identifiersep> type <identifiersep> mismatch - > { val diagnostic <identifiersep> with <identifiersep> parameters = errors . constant <identifiersep> expected <identifiersep> type <identifiersep> mismatch . cast ( diagnostic ) expected <identifiersep> type = diagnostic <identifiersep> with <identifiersep> parameters . b expression <identifiersep> type = context . get <identifiersep> type ( diagnostic <identifiersep> element ) if ( expression <identifiersep> type == null ) { <LOG> return empty <identifiersep> list ( ) } } else - > { log . error ( <string_literal> + default <identifiersep> error <identifiersep> messages . render ( diagnostic ) ) return empty <identifiersep> list ( ) } } if ( expression <identifiersep> type . is <identifiersep> primitive <identifiersep> number <identifiersep> type ( ) && expected <identifiersep> type . is <identifiersep> primitive <identifiersep> number <identifiersep> type ( ) ) { var wrong <identifiersep> primitive <identifiersep> literal <identifiersep> fix : wrong <identifiersep> primitive <identifiersep> literal <identifiersep> fix ? = null <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; <LOG> b b = new b ( ) ; b . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + b . get <identifiersep> foo ( ) ) ; } <ect>
package client ; import server . kotlin <identifiersep> top <identifiersep> level <identifiersep> property <identifiersep> usages <identifiersep> 0kt ; class j <identifiersep> client { void foo <identifiersep> bar ( ) { <LOG> system . out . println ( <string_literal> + kotlin <identifiersep> top <identifiersep> level <identifiersep> property <identifiersep> usages <identifiersep> 0kt . get <identifiersep> foo ( ) . length ( ) ) ; kotlin <identifiersep> top <identifiersep> level <identifiersep> property <identifiersep> usages <identifiersep> 0kt . set <identifiersep> foo ( <string_literal> ) ; } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; <LOG> b b = new b ( ) ; b . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + b . get <identifiersep> foo ( ) ) ; } <ect>
package client ; import server . * ; class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; <LOG> b b = new b ( ) ; b . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + b . get <identifiersep> foo ( ) ) ; } <ect>
if ( root . is <identifiersep> directory ( ) ) { file [ ] files = root . list <identifiersep> files ( ) ; if ( files == null ) return ; for ( file file : files ) { process <identifiersep> file ( file ) ; } } else if ( root . get <identifiersep> name ( ) . ends <identifiersep> with ( <string_literal> ) ) { <LOG> string path = root . get <identifiersep> absolute <identifiersep> path ( ) ; system . out . println ( <string_literal> + path ) ; change ( path ) ; build <identifiersep> all <identifiersep> modules ( ) . assert <identifiersep> successful ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; <ect>
else if ( root . get <identifiersep> name ( ) . ends <identifiersep> with ( <string_literal> ) ) { system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; string path = root . get <identifiersep> absolute <identifiersep> path ( ) ; system . out . println ( <string_literal> + path ) ; change ( path ) ; build <identifiersep> all <identifiersep> modules ( ) . assert <identifiersep> successful ( ) ; <LOG> system . out . println ( <string_literal> ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
build <identifiersep> all <identifiersep> modules ( ) . assert <identifiersep> successful ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; <LOG> system . out . println ( <string_literal> ) ; } } @ override protected void rebuild <identifiersep> all <identifiersep> modules ( ) { system . out . println ( <string_literal> ) ; super . rebuild <identifiersep> all <identifiersep> modules ( ) ; system . out . println ( <string_literal> ) ; <ect>
. assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; system . out . println ( <string_literal> ) ; } } @ override protected void rebuild <identifiersep> all <identifiersep> modules ( ) { <LOG> super . rebuild <identifiersep> all <identifiersep> modules ( ) ; system . out . println ( <string_literal> ) ; } @ not <identifiersep> null @ override protected build <identifiersep> result build <identifiersep> all <identifiersep> modules ( ) { system . out . println ( <string_literal> ) ; <ect>
kotlin <identifiersep> builder . log . debug ( <string_literal> + files <identifiersep> to <identifiersep> compile . key <identifiersep> set ( ) . join <identifiersep> to <identifiersep> string { it . presentable <identifiersep> name } ) <comment> <LOG> + ( if ( total <identifiersep> removed <identifiersep> files == 0 ) <string_literal> else <string_literal> ) + <string_literal> + files <identifiersep> to <identifiersep> compile . key <identifiersep> set ( ) . join <identifiersep> to <identifiersep> string { it . presentable <identifiersep> name } ) try { val compiler <identifiersep> runner = jps <identifiersep> kotlin <identifiersep> compiler <identifiersep> runner ( ) compiler <identifiersep> runner . run <identifiersep> k2jvm <identifiersep> compiler ( common <identifiersep> arguments , k2jvm <identifiersep> arguments , compiler <identifiersep> settings , environment , module <identifiersep> file ) } finally { <ect>
public enum severity { <comment> @ non <identifiersep> null <LOG> <comment> @ non <identifiersep> null error ( <string_literal> ) , <comment> <ect>
@ non <identifiersep> null error ( <string_literal> ) , <comment> @ non <identifiersep> null <LOG> <comment> @ non <identifiersep> null informational ( <string_literal> ) , <ect>
return m <identifiersep> delegate . find <identifiersep> rule <identifiersep> jars ( project ) ; } @ override public boolean is <identifiersep> project <identifiersep> directory ( @ non <identifiersep> null file dir ) { return m <identifiersep> delegate . is <identifiersep> project <identifiersep> directory ( dir ) ; } @ override public void register <identifiersep> project ( @ non <identifiersep> null file dir , @ non <identifiersep> null project project ) { <LOG> m <identifiersep> delegate . register <identifiersep> project ( dir , project ) ; } @ override public issue <identifiersep> registry add <identifiersep> custom <identifiersep> lint <identifiersep> rules ( @ non <identifiersep> null issue <identifiersep> registry registry ) { return m <identifiersep> delegate . add <identifiersep> custom <identifiersep> lint <identifiersep> rules ( registry ) ; } @ non <identifiersep> null @ override <ect>
val correct <identifiersep> error <identifiersep> types = configuration . get ( kapt3configuration <identifiersep> keys . correct <identifiersep> error <identifiersep> types ) == <string_literal> val map <identifiersep> diagnostic <identifiersep> locations = configuration . get ( kapt3configuration <identifiersep> keys . map <identifiersep> diagnostic <identifiersep> locations ) == <string_literal> if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) <ect>
if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) logger . info ( <string_literal> + java <identifiersep> source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) logger . info ( <string_literal> + java <identifiersep> source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> ) } val kapt3analysis <identifiersep> completed <identifiersep> handler <identifiersep> extension = classpath <identifiersep> based <identifiersep> kapt3extension ( compile <identifiersep> classpath , ap <identifiersep> classpath , java <identifiersep> source <identifiersep> roots , sources <identifiersep> output <identifiersep> dir , class <identifiersep> files <identifiersep> output <identifiersep> dir , <ect>
class kotlin <identifiersep> all <identifiersep> open <identifiersep> maven <identifiersep> plugin <identifiersep> extension : kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension { @ requirement lateinit var logger : logger override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = allopen <identifiersep> compiler <identifiersep> plugin <identifiersep> id override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) = true override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { <LOG> return empty <identifiersep> list ( ) } } @ component ( role = kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension : : class , hint = <string_literal> ) class kotlin <identifiersep> spring <identifiersep> maven <identifiersep> plugin <identifiersep> extension : kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension { private companion object { val preset <identifiersep> arg <identifiersep> name = <string_literal> } override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = allopen <identifiersep> compiler <identifiersep> plugin <identifiersep> id <ect>
val artifact <identifiersep> id : default <identifiersep> artifact = when { depends <identifiersep> on . group <identifiersep> id . is <identifiersep> valid <identifiersep> param ( ) || depends <identifiersep> on . artifact <identifiersep> id . is <identifiersep> valid <identifiersep> param ( ) - > { default <identifiersep> artifact ( depends <identifiersep> on . group <identifiersep> id . or <identifiersep> null <identifiersep> if <identifiersep> blank ( ) , depends <identifiersep> on . artifact <identifiersep> id . or <identifiersep> null <identifiersep> if <identifiersep> blank ( ) , null , depends <identifiersep> on . version . or <identifiersep> null <identifiersep> if <identifiersep> blank ( ) ) } depends <identifiersep> on . value . is <identifiersep> valid <identifiersep> param ( ) && depends <identifiersep> on . value . count { it == ' : ' } == <number_literal> - > { default <identifiersep> artifact ( depends <identifiersep> on . value ) } else - > { <LOG> return null } } try { val deps = aether ( current <identifiersep> repos ( ) , local <identifiersep> repo ) . resolve ( artifact <identifiersep> id , java <identifiersep> scopes . runtime ) if ( deps != null ) return deps . map { it . file } else { <ect>
compiler <identifiersep> message <identifiersep> severity . strong <identifiersep> warning , compiler <identifiersep> message <identifiersep> severity . warning , compiler <identifiersep> message <identifiersep> severity . info - > log . info ( loc <identifiersep> message ) compiler <identifiersep> message <identifiersep> severity . logging - > log . debug ( loc <identifiersep> message ) compiler <identifiersep> message <identifiersep> severity . output - > { } } } } internal fun kotlin <identifiersep> logger . log <identifiersep> finish ( strategy : string ) { <LOG> } internal fun exit <identifiersep> code <identifiersep> from <identifiersep> process <identifiersep> exit <identifiersep> code ( log : kotlin <identifiersep> logger , code : int ) : exit <identifiersep> code { val exit <identifiersep> code = exit <identifiersep> code . values ( ) . find { it . code == code } if ( exit <identifiersep> code != null ) return exit <identifiersep> code log . debug ( <string_literal> ) return if ( code == 0 ) exit <identifiersep> code . ok else exit <identifiersep> code . compilation <identifiersep> error <ect>
val execution <identifiersep> strategy = kotlin <identifiersep> compiler <identifiersep> execution <identifiersep> strategy if ( execution <identifiersep> strategy == daemon <identifiersep> execution <identifiersep> strategy ) { val daemon <identifiersep> exit <identifiersep> code = compile <identifiersep> with <identifiersep> daemon ( compiler <identifiersep> class <identifiersep> name , compiler <identifiersep> args , environment ) if ( daemon <identifiersep> exit <identifiersep> code != null ) { return daemon <identifiersep> exit <identifiersep> code } else { <LOG> } } val is <identifiersep> gradle <identifiersep> daemon <identifiersep> used = system . get <identifiersep> property ( <string_literal> ) ? . let ( string : : to <identifiersep> boolean ) return if ( execution <identifiersep> strategy == in <identifiersep> process <identifiersep> execution <identifiersep> strategy || is <identifiersep> gradle <identifiersep> daemon <identifiersep> used == false ) { compile <identifiersep> in <identifiersep> process ( args <identifiersep> array , compiler <identifiersep> class <identifiersep> name , environment ) } else { compile <identifiersep> out <identifiersep> of <identifiersep> process ( args <identifiersep> array , compiler <identifiersep> class <identifiersep> name , environment ) } } private val kotlin <identifiersep> compiler <identifiersep> execution <identifiersep> strategy : string <ect>
block . fix <identifiersep> forward <identifiersep> name <identifiersep> references ( ) val source <identifiersep> map <identifiersep> file = file ( file . parent , file . name + <string_literal> ) if ( source <identifiersep> map <identifiersep> file . exists ( ) ) { val source <identifiersep> map <identifiersep> parse = source <identifiersep> map <identifiersep> file . reader ( ) . use { source <identifiersep> map <identifiersep> parser . parse ( it ) } when ( source <identifiersep> map <identifiersep> parse ) { is source <identifiersep> map <identifiersep> error - > { <LOG> system . exit ( 1 ) } is source <identifiersep> map <identifiersep> success - > { val source <identifiersep> map = source <identifiersep> map <identifiersep> parse . value val remapper = source <identifiersep> map <identifiersep> location <identifiersep> remapper ( source <identifiersep> map ) remapper . remap ( block ) } } } insertion <identifiersep> place . statements += statements <ect>
it . return <identifiersep> type . is <identifiersep> subtype <identifiersep> of ( type <identifiersep> member <identifiersep> template ) - > yield ( it . call ( this ) as member <identifiersep> template ) it . return <identifiersep> type . is <identifiersep> subtype <identifiersep> of ( type <identifiersep> iterable <identifiersep> of <identifiersep> member <identifiersep> templates ) - > @ suppress ( <string_literal> ) yield <identifiersep> all ( it . call ( this ) as iterable < member <identifiersep> template > ) else - > <LOG> } } } } . run { if ( default <identifiersep> actions . is <identifiersep> empty ( ) ) this else on <identifiersep> each { t - > default <identifiersep> actions . for <identifiersep> each ( t : : builder ) } } private val default <identifiersep> actions = mutable <identifiersep> list <identifiersep> of < member <identifiersep> build <identifiersep> action > ( ) fun default <identifiersep> builder ( builder <identifiersep> action : member <identifiersep> build <identifiersep> action ) { default <identifiersep> actions += builder <identifiersep> action } companion object { <ect>
val has <identifiersep> jar <identifiersep> extension = ends <identifiersep> with ( <string_literal> ) val escaped = this . wildcards <identifiersep> to <identifiersep> escaped <identifiersep> regex <identifiersep> string ( ) return regex ( if ( has <identifiersep> jar <identifiersep> extension ) escaped else <string_literal> ) <comment> <LOG> } fun project . tools <identifiersep> jar ( jdk <identifiersep> home : file = file ( this . property ( <string_literal> ) as string ) ) : file ? = first <identifiersep> from <identifiersep> java <identifiersep> home <identifiersep> that <identifiersep> exists ( <string_literal> , jdk <identifiersep> home = jdk <identifiersep> home ) object embedded <identifiersep> components { val configuration <identifiersep> name = <string_literal> } fun project . contains <identifiersep> embedded <identifiersep> components ( ) { configurations . create ( embedded <identifiersep> components . configuration <identifiersep> name ) <ect>
unix <identifiersep> conventional <identifiersep> jdk <identifiersep> dir <identifiersep> rex . contains <identifiersep> match <identifiersep> in ( dir . name ) && file ( dir , <string_literal> , <string_literal> ) . is <identifiersep> file } ? : continue for ( dir in installed <identifiersep> jdks ) { val version <identifiersep> match = java <identifiersep> version <identifiersep> regex . find ( dir . name ) if ( version <identifiersep> match == null ) { <LOG> } else { add <identifiersep> if <identifiersep> better ( project , version <identifiersep> match . value , dir . name , dir ) } } } } private val windows <identifiersep> conventional <identifiersep> jdk <identifiersep> registry <identifiersep> paths = list <identifiersep> of ( <string_literal> , <string_literal> ) fun mutable <identifiersep> collection < jdk <identifiersep> id > . discover <identifiersep> jdks <identifiersep> on <identifiersep> windows ( project : project ) { <ect>
public void configure ( job <identifiersep> conf job <identifiersep> conf ) { try { hadoop <identifiersep> util . init <identifiersep> log4j ( job <identifiersep> conf ) ; log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; <LOG> current <identifiersep> process = new hadoop <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , job <identifiersep> conf , true ) ; string map <identifiersep> node <identifiersep> state = job <identifiersep> conf . get <identifiersep> raw ( <string_literal> ) ; if ( map <identifiersep> node <identifiersep> state == null ) map <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; flow <identifiersep> node = deserialize <identifiersep> base64 ( map <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , flow <identifiersep> node . get <identifiersep> ordinal ( ) ) ; <ect>
map <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; flow <identifiersep> node = deserialize <identifiersep> base64 ( map <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , flow <identifiersep> node . get <identifiersep> ordinal ( ) ) ; tap source = flows . get <identifiersep> tap <identifiersep> for <identifiersep> id ( flow <identifiersep> node . get <identifiersep> source <identifiersep> taps ( ) , job <identifiersep> conf . get ( <string_literal> ) ) ; stream <identifiersep> graph = new hadoop <identifiersep> map <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , source ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) <LOG> for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) log . info ( <string_literal> + trap ) ; log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) <ect>
stream <identifiersep> graph = new hadoop <identifiersep> map <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , source ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) tail ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) <LOG> log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) { report <identifiersep> if <identifiersep> local ( throwable ) ; if ( throwable instanceof cascading <identifiersep> exception ) throw ( cascading <identifiersep> exception ) throwable ; <ect>
if ( ! blocking <identifiersep> continue <identifiersep> polling <identifiersep> steps ( ) ) return true ; { log <identifiersep> info ( <string_literal> ) ; for ( tap source : get <identifiersep> sources <identifiersep> collection ( ) ) <LOG> for ( tap sink : get <identifiersep> sinks <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + sink ) ; } <comment> <ect>
{ vertex <identifiersep> status vertex <identifiersep> status = update <identifiersep> progress ( dag <identifiersep> client , status <identifiersep> get <identifiersep> counters ) ; if ( vertex <identifiersep> status == null ) return null ; tez <identifiersep> counters vertex <identifiersep> counters = vertex <identifiersep> status . get <identifiersep> vertex <identifiersep> counters ( ) ; if ( vertex <identifiersep> counters == null ) <LOG> return vertex <identifiersep> counters ; } } ; } <comment> private set < tap > get <identifiersep> streamed <identifiersep> taps ( flow <identifiersep> node flow <identifiersep> node ) <ect>
continue ; task <identifiersep> status task <identifiersep> status = get <identifiersep> task <identifiersep> status <identifiersep> for ( timeline <identifiersep> client , slice <identifiersep> stats . get <identifiersep> process <identifiersep> slice <identifiersep> id ( ) ) ; update <identifiersep> slice <identifiersep> with ( ( tez <identifiersep> slice <identifiersep> stats ) slice <identifiersep> stats , task <identifiersep> status , system . current <identifiersep> time <identifiersep> millis ( ) ) ; count ++ ; } if ( count == 0 ) all <identifiersep> children <identifiersep> finished = true ; <LOG> return slice <identifiersep> stats <identifiersep> map . size ( ) == get <identifiersep> total <identifiersep> task <identifiersep> count ( ) ; } private boolean fetch <identifiersep> all <identifiersep> tasks ( timeline <identifiersep> client timeline <identifiersep> client ) { long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; string from <identifiersep> task <identifiersep> id = null ; int start <identifiersep> size = slice <identifiersep> stats <identifiersep> map . size ( ) ; <ect>
int added = total - start <identifiersep> size ; int remaining = get <identifiersep> total <identifiersep> task <identifiersep> count ( ) - total ; string duration = format <identifiersep> duration <identifiersep> from <identifiersep> millis ( system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ) ; if ( total == get <identifiersep> total <identifiersep> task <identifiersep> count ( ) && retrieved <identifiersep> are <identifiersep> finished ) all <identifiersep> children <identifiersep> finished = true ; if ( iteration == 0 && total == 0 ) <LOG> else log <identifiersep> info ( <string_literal> , added , iteration , duration , total , remaining ) ; return total == get <identifiersep> total <identifiersep> task <identifiersep> count ( ) ; } private void update <identifiersep> slice <identifiersep> with ( tez <identifiersep> slice <identifiersep> stats slice <identifiersep> stats , task <identifiersep> status task <identifiersep> status , long last <identifiersep> fetch ) { if ( task <identifiersep> status == null ) <ect>
{ try { return timeline <identifiersep> client . get <identifiersep> vertex <identifiersep> child ( task <identifiersep> id ) ; } catch ( tez <identifiersep> exception exception ) { <LOG> } return null ; } private iterator < task <identifiersep> status > get <identifiersep> task <identifiersep> status <identifiersep> iterator ( timeline <identifiersep> client timeline <identifiersep> client , string start <identifiersep> task <identifiersep> id ) { try { string vertex <identifiersep> id = retrieve <identifiersep> vertex <identifiersep> id ( ( dag <identifiersep> client ) timeline <identifiersep> client ) ; <ect>
try { thread . sleep ( seconds <identifiersep> delay * <number_literal> ) ; } catch ( interrupted <identifiersep> exception exception1 ) { <comment> <LOG> throw saved ; } public static object create <identifiersep> protected <identifiersep> object ( class type , object [ ] parameters , class [ ] parameter <identifiersep> types ) { try { constructor constructor = type . get <identifiersep> declared <identifiersep> constructor ( parameter <identifiersep> types ) ; <ect>
throw new cascading <identifiersep> exception ( <string_literal> + target . get <identifiersep> class ( ) . get <identifiersep> name ( ) + <string_literal> + field <identifiersep> name , exception ) ; } } private static field get <identifiersep> declared <identifiersep> field ( string field <identifiersep> name , class < ? > type ) { if ( type == object . class ) { <LOG> return null ; } try { return type . get <identifiersep> declared <identifiersep> field ( field <identifiersep> name ) ; } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception exception ) { <ect>
try { log . info ( <string_literal> , stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) ) ; return thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { <LOG> } } } log . info ( <string_literal> ) ; return default <identifiersep> type ; } public static string find <identifiersep> containing <identifiersep> jar ( class < ? > type ) { class <identifiersep> loader class <identifiersep> loader = type . get <identifiersep> class <identifiersep> loader ( ) ; string class <identifiersep> file = type . get <identifiersep> name ( ) . replace <identifiersep> all ( <string_literal> , <string_literal> ) + <string_literal> ; <ect>
try { if ( version <identifiersep> properties == null ) { version <identifiersep> properties = load <identifiersep> version <identifiersep> properties ( ) ; if ( version <identifiersep> properties . is <identifiersep> empty ( ) ) <LOG> } } catch ( io <identifiersep> exception exception ) { log . warn ( <string_literal> , exception ) ; version <identifiersep> properties = new properties ( ) ; } return version <identifiersep> properties ; } public static synchronized void print <identifiersep> banner ( ) <ect>
flow <identifiersep> stats . mark <identifiersep> started ( ) ; fire <identifiersep> on <identifiersep> starting ( ) ; { log <identifiersep> info ( <string_literal> ) ; for ( tap source : get <identifiersep> sources <identifiersep> collection ( ) ) <LOG> for ( tap sink : get <identifiersep> sinks <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + sink ) ; } spawn <identifiersep> steps ( ) ; } catch ( throwable throwable ) { this . throwable = throwable ; <ect>
finally { { long total <identifiersep> slice <identifiersep> cpu <identifiersep> seconds = get <identifiersep> total <identifiersep> slice <identifiersep> cpu <identifiersep> milli <identifiersep> seconds ( ) ; if ( total <identifiersep> slice <identifiersep> cpu <identifiersep> seconds == - 1 ) <LOG> else log <identifiersep> info ( <string_literal> + format <identifiersep> duration <identifiersep> from <identifiersep> millis ( flow <identifiersep> stats . get <identifiersep> duration ( ) ) + <string_literal> + format <identifiersep> duration <identifiersep> from <identifiersep> millis ( total <identifiersep> slice <identifiersep> cpu <identifiersep> seconds ) ) ; } flow <identifiersep> stats . cleanup ( ) ; internal <identifiersep> shutdown ( ) ; deregister <identifiersep> shutdown <identifiersep> hook ( ) ; } } } <comment> <ect>
if ( num <identifiersep> threads == 0 ) num <identifiersep> threads = eligible <identifiersep> jobs <identifiersep> size ; if ( num <identifiersep> threads == 0 ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + get <identifiersep> name ( ) ) ; { <LOG> log <identifiersep> info ( <string_literal> + eligible <identifiersep> jobs <identifiersep> size ) ; log <identifiersep> info ( <string_literal> + num <identifiersep> threads ) ; } list < future < throwable > > futures = spawn <identifiersep> jobs ( num <identifiersep> threads ) ; for ( future < throwable > future : futures ) { throwable = future . get ( ) ; <ect>
if ( num <identifiersep> threads == 0 ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + get <identifiersep> name ( ) ) ; { log <identifiersep> info ( <string_literal> + ( get <identifiersep> max <identifiersep> num <identifiersep> parallel <identifiersep> steps ( ) != 1 ) ) ; log <identifiersep> info ( <string_literal> + eligible <identifiersep> jobs <identifiersep> size ) ; <LOG> } list < future < throwable > > futures = spawn <identifiersep> jobs ( num <identifiersep> threads ) ; for ( future < throwable > future : futures ) { throwable = future . get ( ) ; if ( throwable != null ) { <ect>
<comment> private void make <identifiersep> graph ( pipe current , map < string , tap > sources , map < string , tap > sinks ) { <LOG> if ( current instanceof sub <identifiersep> assembly ) { for ( pipe pipe : sub <identifiersep> assembly . unwind ( current . get <identifiersep> previous ( ) ) ) make <identifiersep> graph ( pipe , sources , sinks ) ; return ; } if ( contains <identifiersep> vertex ( current ) ) <ect>
add <identifiersep> vertex ( current ) ; tap sink = sinks . remove ( current . get <identifiersep> name ( ) ) ; if ( sink != null ) { log . debug ( <string_literal> , sink ) ; add <identifiersep> vertex ( sink ) ; <LOG> add <identifiersep> edge ( current , sink ) . set <identifiersep> name ( current . get <identifiersep> name ( ) ) ; } <comment> <ect>
{ tap source = sources . remove ( current . get <identifiersep> name ( ) ) ; if ( source != null ) { log . debug ( <string_literal> , source ) ; add <identifiersep> vertex ( source ) ; <LOG> scope scope = add <identifiersep> edge ( source , current ) ; scope . set <identifiersep> name ( current . get <identifiersep> name ( ) ) ; set <identifiersep> ordinal ( source , current , scope ) ; } } for ( pipe previous : sub <identifiersep> assembly . unwind ( current . get <identifiersep> previous ( ) ) ) { make <identifiersep> graph ( previous , sources , sinks ) ; <ect>
pipe pipe = ( pipe ) element ; tap trap = traps . get ( pipe . get <identifiersep> name ( ) ) ; if ( trap == null ) continue ; add <identifiersep> vertex ( trap ) ; <LOG> if ( get <identifiersep> edge ( pipe , trap ) != null ) continue ; add <identifiersep> edge ( pipe , trap ) . set <identifiersep> name ( pipe . get <identifiersep> name ( ) ) ; <comment> <ect>
throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + source . to <identifiersep> string ( ) ) ; scope outgoing <identifiersep> scope = ( ( scoped <identifiersep> element ) source ) . outgoing <identifiersep> scope <identifiersep> for ( incoming <identifiersep> scopes ) ; { log . debug ( <string_literal> + source ) ; if ( outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) != null ) <LOG> if ( outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) ) ; <ect>
log . debug ( <string_literal> + source ) ; if ( outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) != null ) <LOG> if ( outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) ) ; } for ( scope scope : outgoing <identifiersep> scopes ) scope . copy <identifiersep> fields ( outgoing <identifiersep> scope ) ; } } <ect>
rule <identifiersep> durations . put ( rule . get <identifiersep> rule <identifiersep> phase ( ) , durations ) ; } if ( durations . contains <identifiersep> key ( rule . get <identifiersep> rule <identifiersep> name ( ) ) ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + rule . get <identifiersep> rule <identifiersep> name ( ) ) ; long duration = end - begin ; <comment> <LOG> durations . put ( rule . get <identifiersep> rule <identifiersep> name ( ) , duration ) ; } public void write <identifiersep> stats ( print <identifiersep> writer writer ) { writer . format ( <string_literal> , ( duration / 1000f ) ) ; writer . println ( ) ; for ( plan <identifiersep> phase phase : phase <identifiersep> durations . key <identifiersep> set ( ) ) <ect>
long get <identifiersep> sink <identifiersep> modified ( ) throws io <identifiersep> exception { long sink <identifiersep> modified = util . get <identifiersep> sink <identifiersep> modified ( get <identifiersep> config ( ) , sinks . key <identifiersep> set ( ) ) ; { if ( sink <identifiersep> modified == - 1l ) <LOG> if ( sink <identifiersep> modified == 0l ) log <identifiersep> info ( <string_literal> ) ; else log <identifiersep> info ( <string_literal> + new date ( sink <identifiersep> modified ) ) ; } return sink <identifiersep> modified ; } protected throwable prepare <identifiersep> resources ( ) <ect>
vertex <identifiersep> map . put <identifiersep> all ( copy . get <identifiersep> vertex <identifiersep> mapping ( ) ) ; log . trace ( <string_literal> , vertex <identifiersep> map ) ; } else { <LOG> copy . back <identifiersep> track ( ) ; log . trace ( <string_literal> , state , found ) ; return found ; } } <ect>
name += sink <identifiersep> name ; return name . replace <identifiersep> all ( <string_literal> , <string_literal> ) ; } } , null ) ; writer . close ( ) ; } catch ( io <identifiersep> exception exception ) { <LOG> } } @ override public void write <identifiersep> dot <identifiersep> nested ( string filename , element <identifiersep> graph graph ) { element <identifiersep> graphs . print <identifiersep> process <identifiersep> graph ( filename , graph , this ) ; } public boolean contains <identifiersep> edge ( process source <identifiersep> vertex , process target <identifiersep> vertex ) { <ect>
{ try { collector . close ( ) ; } catch ( exception exception ) { <LOG> } } } finally { collectors = null ; } } } <comment> <ect>
{ throw new tap <identifiersep> exception ( <string_literal> + path , exception ) ; } if ( collectors . size ( ) > open <identifiersep> writes <identifiersep> threshold ) purge <identifiersep> collectors ( ) ; collectors . put ( path , collector ) ; <LOG> return collector ; } private void purge <identifiersep> collectors ( ) { int num <identifiersep> to <identifiersep> close = math . max ( 1 , ( int ) ( open <identifiersep> writes <identifiersep> threshold * . <number_literal> ) ) ; log . info ( <string_literal> , num <identifiersep> to <identifiersep> close , collectors . size ( ) ) ; <ect>
{ try { listener . notify ( this , from <identifiersep> status , to <identifiersep> status ) ; } catch ( throwable throwable ) { <LOG> } } } protected abstract process <identifiersep> logger get <identifiersep> process <identifiersep> logger ( ) ; protected string get <identifiersep> stats <identifiersep> string ( ) { string string = <string_literal> + status + <string_literal> + start <identifiersep> time ; if ( finished <identifiersep> time != 0 ) string += <string_literal> + ( finished <identifiersep> time - start <identifiersep> time ) ; <ect>
{ if ( ! has <identifiersep> captured <identifiersep> final <identifiersep> counters && ! warned <identifiersep> stale ) { if ( cached <identifiersep> counters == null ) log . warn ( <string_literal> , max <identifiersep> fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) ) ; else <LOG> warned <identifiersep> stale = true ; } return cached <identifiersep> counters ; } boolean is <identifiersep> process <identifiersep> finished = stats . is <identifiersep> finished ( ) ; <comment> <ect>
{ log . warn ( <string_literal> ) ; } catch ( execution <identifiersep> exception exception ) { fetch <identifiersep> attempts ++ ; if ( fetch <identifiersep> attempts >= max <identifiersep> fetch <identifiersep> attempts ) <LOG> else log . warn ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) . get <identifiersep> message ( ) ) ; if ( cached <identifiersep> counters != null ) { log . error ( <string_literal> ) ; return cached <identifiersep> counters ; <ect>
if ( fetch <identifiersep> attempts >= max <identifiersep> fetch <identifiersep> attempts ) log . error ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) ) ; else log . warn ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) . get <identifiersep> message ( ) ) ; if ( cached <identifiersep> counters != null ) { <LOG> return cached <identifiersep> counters ; } log . error ( <string_literal> , exception . get <identifiersep> cause ( ) ) ; if ( exception . get <identifiersep> cause ( ) instanceof flow <identifiersep> exception ) throw ( flow <identifiersep> exception ) exception . get <identifiersep> cause ( ) ; throw new flow <identifiersep> exception ( exception . get <identifiersep> cause ( ) ) ; } catch ( timeout <identifiersep> exception exception ) <ect>
try { file <identifiersep> system file <identifiersep> system = file <identifiersep> system . get ( new uri ( <string_literal> , null , null ) , configuration ) ; return file <identifiersep> system != null ; } catch ( io <identifiersep> exception exception ) <comment> <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception exception ) { throw new runtime <identifiersep> exception ( <string_literal> , exception ) ; } return false ; } @ override public void copy <identifiersep> from <identifiersep> local ( string input <identifiersep> file ) throws io <identifiersep> exception <ect>
log . info ( <string_literal> ) ; flow . start ( ) ; util . safe <identifiersep> sleep ( <number_literal> ) ; assert <identifiersep> true ( <string_literal> , listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; while ( true ) { <LOG> thread . sleep ( <number_literal> ) ; map < string , flow <identifiersep> step <identifiersep> job > map = flows . get <identifiersep> jobs <identifiersep> map ( flow ) ; if ( map == null || map . values ( ) . size ( ) == 0 ) continue ; flow <identifiersep> step <identifiersep> job flow <identifiersep> step <identifiersep> job = map . values ( ) . iterator ( ) . next ( ) ; if ( flow <identifiersep> step <identifiersep> job . get <identifiersep> step <identifiersep> stats ( ) . get <identifiersep> status ( ) == cascading <identifiersep> stats . status . failed ) <ect>
start . release ( ) ; log . info ( <string_literal> ) ; flow . complete ( ) ; return system . nano <identifiersep> time ( ) - start <identifiersep> time ; } ) ; start . acquire ( ) ; <LOG> flow . stop ( ) ; long stop <identifiersep> time = system . nano <identifiersep> time ( ) - start <identifiersep> time ; long complete <identifiersep> time = future . get ( ) ; assert <identifiersep> true ( string . format ( <string_literal> , stop <identifiersep> time , complete <identifiersep> time ) , stop <identifiersep> time < = complete <identifiersep> time ) ; assert <identifiersep> true ( <string_literal> , listener . stopped . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; assert <identifiersep> true ( <string_literal> , listener . completed . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; <ect>
flow . start ( ) ; assert <identifiersep> true ( <string_literal> , listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; if ( on <identifiersep> fail == failing <identifiersep> flow <identifiersep> listener . on <identifiersep> fail . stopping ) { while ( true ) { <LOG> thread . sleep ( <number_literal> ) ; map < string , flow <identifiersep> step <identifiersep> job > map = flows . get <identifiersep> jobs <identifiersep> map ( flow ) ; if ( map == null || map . values ( ) . size ( ) == 0 ) continue ; flow <identifiersep> step <identifiersep> job flow <identifiersep> step <identifiersep> job = map . values ( ) . iterator ( ) . next ( ) ; if ( flow <identifiersep> step <identifiersep> job . get <identifiersep> step <identifiersep> stats ( ) . get <identifiersep> status ( ) == cascading <identifiersep> stats . status . failed ) <ect>
{ path job <identifiersep> output <identifiersep> path = task <identifiersep> output <identifiersep> path . get <identifiersep> parent ( ) . get <identifiersep> parent ( ) ; <comment> <LOG> log . info ( <string_literal> , task <identifiersep> id , job <identifiersep> output <identifiersep> path ) ; } } return true ; } <comment> <ect>
{ write <identifiersep> success <identifiersep> marker ( conf , file <identifiersep> output <identifiersep> format . get <identifiersep> output <identifiersep> path ( as <identifiersep> job <identifiersep> conf <identifiersep> instance ( conf ) ) ) ; } public static void write <identifiersep> success <identifiersep> marker ( configuration conf , path output <identifiersep> path ) throws io <identifiersep> exception { if ( conf . get <identifiersep> boolean ( <string_literal> , true ) ) { <LOG> path marker <identifiersep> path = new path ( output <identifiersep> path , <string_literal> ) ; file <identifiersep> system fs = marker <identifiersep> path . get <identifiersep> file <identifiersep> system ( conf ) ; fs . create ( marker <identifiersep> path ) . close ( ) ; } } <comment> <ect>
path output <identifiersep> path = file <identifiersep> output <identifiersep> format . get <identifiersep> output <identifiersep> path ( as <identifiersep> job <identifiersep> conf <identifiersep> instance ( conf ) ) ; if ( output <identifiersep> path != null ) { path tmp <identifiersep> dir = new path ( output <identifiersep> path , temporary <identifiersep> path ) ; file <identifiersep> system file <identifiersep> sys = tmp <identifiersep> dir . get <identifiersep> file <identifiersep> system ( conf ) ; if ( ! file <identifiersep> sys . exists ( tmp <identifiersep> dir ) && ! file <identifiersep> sys . mkdirs ( tmp <identifiersep> dir ) ) <LOG> } } private static void move <identifiersep> task <identifiersep> outputs ( configuration conf , file <identifiersep> system fs , path job <identifiersep> output <identifiersep> dir , path task <identifiersep> output ) throws io <identifiersep> exception { string task <identifiersep> id = conf . get ( <string_literal> , conf . get ( <string_literal> ) ) ; if ( fs . is <identifiersep> file ( task <identifiersep> output ) ) { path final <identifiersep> output <identifiersep> path = get <identifiersep> final <identifiersep> path ( job <identifiersep> output <identifiersep> dir , task <identifiersep> output , get <identifiersep> task <identifiersep> output <identifiersep> path ( conf ) ) ; <ect>
{ file <identifiersep> system fs = get <identifiersep> fs <identifiersep> safe ( conf , path ) ; if ( fs == null ) return false ; boolean result = conf . get <identifiersep> boolean ( <string_literal> + fs . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , false ) ; if ( result ) <LOG> return result ; } } <ect>
{ if ( ! attempted <identifiersep> cleanup ) stream <identifiersep> graph . cleanup ( ) ; } catch ( throwable current <identifiersep> throwable ) { if ( ! ( current <identifiersep> throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) <LOG> if ( throwable == null ) throwable = current <identifiersep> throwable ; successful = false ; } finally { mark <identifiersep> complete . release ( ) ; <ect>
{ int i = count . get <identifiersep> and <identifiersep> add ( 1 ) ; <comment> <LOG> start . release ( ) ; return ; } super . operate ( flow <identifiersep> process , function <identifiersep> call ) ; } } ) ; tap sink = get <identifiersep> platform ( ) . get <identifiersep> text <identifiersep> file ( get <identifiersep> output <identifiersep> path ( <string_literal> ) , sink <identifiersep> mode . replace ) ; flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( ) . connect ( source , sink , pipe ) ; <ect>
super . operate ( flow <identifiersep> process , function <identifiersep> call ) ; } } ) ; tap sink = get <identifiersep> platform ( ) . get <identifiersep> text <identifiersep> file ( get <identifiersep> output <identifiersep> path ( <string_literal> ) , sink <identifiersep> mode . replace ) ; flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( ) . connect ( source , sink , pipe ) ; <comment> <LOG> start . acquire ( ) ; <comment> <ect>
public static void make <identifiersep> suites ( test <identifiersep> platform test <identifiersep> platform , properties properties , map < string , pipe > pipes , test <identifiersep> suite suite , class type ) throws illegal <identifiersep> access <identifiersep> exception , invocation <identifiersep> target <identifiersep> exception , instantiation <identifiersep> exception , io <identifiersep> exception , class <identifiersep> not <identifiersep> found <identifiersep> exception { for ( string name : pipes . key <identifiersep> set ( ) ) { if ( is <identifiersep> undefined ( properties , name ) ) { <LOG> continue ; } <comment> <ect>
timed <identifiersep> iterators [ 0 ] . reset ( current <identifiersep> values ) ; accept ( current <identifiersep> key , timed <identifiersep> iterators ) ; <comment> <LOG> return throwable ; } return null ; } @ override protected hadoop <identifiersep> group <identifiersep> by <identifiersep> closure create <identifiersep> closure ( ) { return new tez <identifiersep> group <identifiersep> by <identifiersep> closure ( flow <identifiersep> process , key <identifiersep> fields , values <identifiersep> fields ) ; <ect>
public void prepare ( ) { try { if ( logical <identifiersep> input != null ) { <LOG> logical <identifiersep> input . start ( ) ; } if ( logical <identifiersep> outputs != null ) { for ( logical <identifiersep> output logical <identifiersep> output : logical <identifiersep> outputs ) { log . info ( <string_literal> , logical <identifiersep> output . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , get <identifiersep> boundary ( ) , pipe . id ( get <identifiersep> boundary ( ) ) ) ; <ect>
value <identifiersep> entry . set <identifiersep> tuple ( current <identifiersep> key ) ; next . receive ( this , 0 , value <identifiersep> entry ) ; } complete ( this ) ; } catch ( throwable throwable ) { if ( ! ( throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) <LOG> return throwable ; } return local <identifiersep> throwable ; } protected output <identifiersep> collector create <identifiersep> output <identifiersep> collector ( ) { if ( logical <identifiersep> outputs . size ( ) == 1 ) return new old <identifiersep> output <identifiersep> collector ( util . get <identifiersep> first ( logical <identifiersep> outputs ) ) ; <ect>
try { if ( logical <identifiersep> inputs != null ) { for ( logical <identifiersep> input logical <identifiersep> input : logical <identifiersep> inputs . get <identifiersep> values ( ) ) { <LOG> logical <identifiersep> input . start ( ) ; } } if ( logical <identifiersep> output != null ) { log . info ( <string_literal> , logical <identifiersep> output . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , get <identifiersep> splice ( ) , pipe . id ( get <identifiersep> splice ( ) ) ) ; logical <identifiersep> output . start ( ) ; } } catch ( exception exception ) <ect>
logger . error ( fields . class , <string_literal> + s + <string_literal> + e , e ) ; return default <identifiersep> value ; } } public static int parse <identifiersep> int ( string s , int default <identifiersep> value ) { try { return integer . parse <identifiersep> int ( s ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return default <identifiersep> value ; } } public static long parse <identifiersep> short ( string s , short default <identifiersep> value ) { try { return short . parse <identifiersep> short ( s ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { logger . error ( fields . class , <string_literal> + s + <string_literal> + e , e ) ; <ect>
filter . put ( offset / <number_literal> , b ) ; } @ override public void unset <identifiersep> bit ( int offset ) { byte b = filter . get ( offset / <number_literal> ) ; byte v = ( byte ) ( ( b > > > offset % <number_literal> * <number_literal> ) & <number_literal> ) ; if ( v == 0 && warn <identifiersep> on <identifiersep> remove <identifiersep> from <identifiersep> empty ) <LOG> if ( v == 0 || v == <number_literal> ) return ; <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + add + <string_literal> + current ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; logger . error ( this , <string_literal> + time <identifiersep> util . format <identifiersep> time ( milliseconds . convert ( time <identifiersep> last <identifiersep> tick - now <identifiersep> ns , nanoseconds ) , <number_literal> , true ) ) ; time <identifiersep> last <identifiersep> tick = now <identifiersep> ns ; return 0 ; } long next <identifiersep> tick = time <identifiersep> last <identifiersep> tick + nanos <identifiersep> per <identifiersep> tick ; if ( next <identifiersep> tick > now <identifiersep> ns ) { <ect>
<comment> <LOG> time <identifiersep> last <identifiersep> tick = now <identifiersep> ns ; return 0 ; } long next <identifiersep> tick = time <identifiersep> last <identifiersep> tick + nanos <identifiersep> per <identifiersep> tick ; if ( next <identifiersep> tick > now <identifiersep> ns ) { return 0 ; } if ( next <identifiersep> tick + nanos <identifiersep> per <identifiersep> tick > now <identifiersep> ns ) { <ect>
<comment> <LOG> <comment> <ect>
super ( g , r , name ) ; this . current <identifiersep> priority = priority ; this . dont <identifiersep> check <identifiersep> renice = dont <identifiersep> check <identifiersep> renice ; } @ override public final void run ( ) { if ( ! set <identifiersep> native <identifiersep> priority ( current <identifiersep> priority ) ) <LOG> super . run ( ) ; real <identifiersep> run ( ) ; } public void real <identifiersep> run ( ) { <comment> <ect>
<comment>  <identifiersep> disabled = true ; logger . error ( this , <string_literal> + native <identifiersep> priority <identifiersep> base + <string_literal> + real <identifiersep> prio + <string_literal> + this ) ; <LOG> new null <identifiersep> pointer <identifiersep> exception ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; } final int linux <identifiersep> priority = native <identifiersep> priority <identifiersep> base + native <identifiersep> priority <identifiersep> range - ( native <identifiersep> priority <identifiersep> range * ( prio - min <identifiersep> priority ) ) / java <identifiersep> priority <identifiersep> range ; if ( linux <identifiersep> priority == real <identifiersep> prio ) return true ; <comment> <ect>
<comment> public synchronized void completed <identifiersep> init ( ) { if ( original <identifiersep> files == null ) { <LOG> return ; } for ( file f : original <identifiersep> files ) { if ( logger . should <identifiersep> log ( log <identifiersep> level . minor , this ) ) logger . minor ( this , <string_literal> + f ) ; f . delete ( ) ; } original <identifiersep> files = null ; <ect>
<comment> <LOG> raf = new random <identifiersep> access <identifiersep> file ( file , <string_literal> ) ; long count ; <comment> <ect>
if ( executable ) { if ( ! ( copy <identifiersep> to . set <identifiersep> executable ( true ) || copy <identifiersep> to . can <identifiersep> execute ( ) ) ) { system . err . println ( <string_literal> + copy <identifiersep> from + <string_literal> + copy <identifiersep> to + <string_literal> ) ; <comment> <LOG> return false ; } } private static cipher <identifiersep> input <identifiersep> stream cis ; private static zero <identifiersep> input <identifiersep> stream zis = new zero <identifiersep> input <identifiersep> stream ( ) ; private static long cis <identifiersep> counter ; <comment> <ect>
<comment> <LOG> return ret ; } protected void inner <identifiersep> resume ( client <identifiersep> context context ) throws resume <identifiersep> failed <identifiersep> exception { generator = context . persistent <identifiersep> fg ; if ( file == null ) { <comment> <ect>
@ override protected void finalize ( ) throws throwable { <comment> <LOG> else logger . error ( this , <string_literal> + size ( ) + <string_literal> + is <identifiersep> ram <identifiersep> bucket ( ) + <string_literal> + this ) ; free ( ) ; } super . finalize ( ) ; } @ override public long creation <identifiersep> time ( ) { <ect>
string pid <identifiersep> string = get <identifiersep> field <identifiersep> from <identifiersep> proc <identifiersep> self <identifiersep> stat ( 0 , o ) ; if ( null == pid <identifiersep> string ) { return - 1 ; } try { pid = integer . parse <identifiersep> int ( pid <identifiersep> string . trim ( ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> } return pid ; } <comment> <ect>
string msg ; if ( - 1 != pid ) { msg = <string_literal> + pid ; } else { msg = <string_literal> ; } if ( log <identifiersep> to <identifiersep> std <identifiersep> out <identifiersep> enabled ) { <LOG> } if ( log <identifiersep> to <identifiersep> file <identifiersep> enabled ) { log <identifiersep> static ( o , msg , log <identifiersep> to <identifiersep> file <identifiersep> verbosity ) ; } return pid ; } <comment> <ect>
log <identifiersep> debug <identifiersep> field . set ( null , should <identifiersep> log ( log <identifiersep> level . debug , clazz ) ) ; } done = true ; } catch ( security <identifiersep> exception e ) { } catch ( no <identifiersep> such <identifiersep> field <identifiersep> exception e ) { } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { } catch ( illegal <identifiersep> access <identifiersep> exception e ) { } <LOG> } } ; register <identifiersep> log <identifiersep> threshold <identifiersep> callback ( ltc ) ; } <comment> <ect>
while ( true ) { if ( grab <identifiersep> arrays . length == 0 ) return null ; int x = context . fast <identifiersep> weak <identifiersep> random . next <identifiersep> int ( grab <identifiersep> arrays . length ) ; remove <identifiersep> random <identifiersep> with <identifiersep> object < t > rga = grab <identifiersep> arrays [ x ] ; if ( rga == null ) { <comment> <LOG> excluded ++ ; if ( excluded > max <identifiersep> excluded ) { logger . normal ( this , <string_literal> + this + <string_literal> + grab <identifiersep> arrays . length , new exception ( <string_literal> ) ) ; return null ; } continue ; } long exclude <identifiersep> time = rga . get <identifiersep> wakeup <identifiersep> time ( context , now ) ; <ect>
if ( strings == null ) return null ; double [ ] ret = new double [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { try { ret [ i ] = double . value <identifiersep> of ( strings [ i ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return null ; } } return ret ; } public float [ ] get <identifiersep> float <identifiersep> array ( string key ) { string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; float [ ] ret = new float [ strings . length ] ; <ect>
if ( strings == null ) return null ; boolean [ ] ret = new boolean [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { try { ret [ i ] = boolean . value <identifiersep> of ( strings [ i ] ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> return null ; } } return ret ; } public void put <identifiersep> overwrite ( string key , string [ ] strings ) { put <identifiersep> overwrite ( key , unsplit ( strings ) ) ; } public void put <identifiersep> encoded ( string key , string [ ] strings ) { string [ ] copy = arrays . copy <identifiersep> of ( strings , strings . length ) ; <ect>
else if ( interval <identifiersep> name . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) interval = calendar . month ; else if ( interval <identifiersep> name . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) interval = calendar . year ; else throw new interval <identifiersep> parse <identifiersep> exception ( <string_literal> + interval <identifiersep> name ) ; <LOG> } public static class interval <identifiersep> parse <identifiersep> exception extends exception { private static final long serial <identifiersep> version <identifiersep> uid = 69847854744673572l ; public interval <identifiersep> parse <identifiersep> exception ( string string ) { super ( string ) ; } } <comment> <ect>
if ( alt <identifiersep> log <identifiersep> stream != null ) my <identifiersep> write ( alt <identifiersep> log <identifiersep> stream , null ) ; } if ( died ) { try { log <identifiersep> stream . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> } if ( alt <identifiersep> log <identifiersep> stream != null ) { try { alt <identifiersep> log <identifiersep> stream . close ( ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; } } synchronized ( list ) { <ect>
callback . set <identifiersep> store ( this ) ; shutdown <identifiersep> hook . add <identifiersep> early <identifiersep> job ( new native <identifiersep> thread ( new shutdown <identifiersep> db ( ) , <string_literal> , native <identifiersep> thread . high <identifiersep> priority , true ) ) ; cleaner <identifiersep> thread = new cleaner ( ) ; cleaner <identifiersep> status <identifiersep> user <identifiersep> alert = new cleaner <identifiersep> status <identifiersep> user <identifiersep> alert ( cleaner <identifiersep> thread ) ; <comment> <LOG> try { cleaner <identifiersep> thread . resize <identifiersep> store ( prev <identifiersep> store <identifiersep> size , false ) ; } finally { cleaner <identifiersep> global <identifiersep> lock . unlock ( ) ; } write <identifiersep> config <identifiersep> file ( ) ; } if ( ( ( ! slot <identifiersep> filter <identifiersep> disabled ) && slot <identifiersep> filter . is <identifiersep> new ( ) ) && ! new <identifiersep> store ) { <ect>
cleaner <identifiersep> global <identifiersep> lock . unlock ( ) ; } write <identifiersep> config <identifiersep> file ( ) ; } if ( ( ( ! slot <identifiersep> filter <identifiersep> disabled ) && slot <identifiersep> filter . is <identifiersep> new ( ) ) && ! new <identifiersep> store ) { flags | = flag <identifiersep> rebuild <identifiersep> bloom ; system . out . println ( <string_literal> ) ; } else if ( ( flags & flag <identifiersep> rebuild <identifiersep> bloom ) != 0 ) <LOG> } private boolean started = false ; <comment> public boolean start ( ticker ticker , boolean long <identifiersep> start ) throws io <identifiersep> exception { <ect>
return entry ; } private entry probe <identifiersep> entry0 ( byte [ ] digested <identifiersep> key , byte [ ] routing <identifiersep> key , long probe <identifiersep> store <identifiersep> size , boolean with <identifiersep> data ) throws io <identifiersep> exception { entry entry = null ; long [ ] offset = get <identifiersep> offset <identifiersep> from <identifiersep> digested <identifiersep> key ( digested <identifiersep> key , probe <identifiersep> store <identifiersep> size ) ; for ( int i = 0 ; i < offset . length ; i ++ ) { if ( log <identifiersep> debug ) <LOG> try { if ( store <identifiersep> file <identifiersep> offset <identifiersep> ready == - 1 || offset [ i ] < this . store <identifiersep> file <identifiersep> offset <identifiersep> ready ) { entry = read <identifiersep> entry ( offset [ i ] , digested <identifiersep> key , routing <identifiersep> key , with <identifiersep> data ) ; if ( entry != null ) return entry ; } } catch ( eof <identifiersep> exception e ) { <ect>
throw new io <identifiersep> exception ( <string_literal> + e ) ; } byte [ ] digested <identifiersep> key = cipher <identifiersep> manager . get <identifiersep> digested <identifiersep> key ( routing <identifiersep> key ) ; try { map < long , condition > lock <identifiersep> map = lock <identifiersep> digested <identifiersep> key ( digested <identifiersep> key , false ) ; if ( lock <identifiersep> map == null ) { if ( log <identifiersep> debug ) <LOG> return false ; } try { <comment> <ect>
@ override public dsa <identifiersep> public <identifiersep> key get <identifiersep> key ( byte [ ] hash , boolean can <identifiersep> read <identifiersep> client <identifiersep> cache , boolean for <identifiersep> ulpr , block <identifiersep> metadata meta ) { try { return store . fetch ( hash , false , false , meta ) ; } catch ( io <identifiersep> exception e ) { <LOG> return null ; } } @ override public void cache <identifiersep> key ( byte [ ] hash , dsa <identifiersep> public <identifiersep> key key , boolean deep , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore , boolean for <identifiersep> ulpr , boolean write <identifiersep> local <identifiersep> to <identifiersep> datastore ) { try { <ect>
byte [ ] routing <identifiersep> key = routing <identifiersep> key <identifiersep> wrapped . get ( ) ; block block = blocks <identifiersep> by <identifiersep> routing <identifiersep> key . get ( routing <identifiersep> key <identifiersep> wrapped ) ; t ret ; try { ret = callback . construct ( block . data , block . header , routing <identifiersep> key , block . full <identifiersep> key , can <identifiersep> read <identifiersep> client <identifiersep> cache , false , null , null ) ; } catch ( key <identifiersep> verify <identifiersep> exception e ) { <LOG> continue ; } try { target . get <identifiersep> store ( ) . put ( ret , block . data , block . header , false , block . old <identifiersep> block ) ; } catch ( key <identifiersep> collision <identifiersep> exception e ) { <comment> <ect>
<comment> <LOG> } } @ override public int data <identifiersep> length ( ) { return chk <identifiersep> block . data <identifiersep> length ; } @ override public int full <identifiersep> key <identifiersep> length ( ) { return node <identifiersep> chk . full <identifiersep> key <identifiersep> length ; <ect>
key = blocks <identifiersep> by <identifiersep> routing <identifiersep> key . peek <identifiersep> key ( ) ; } finally { config <identifiersep> lock . write <identifiersep> lock ( ) . unlock ( ) ; } try { back <identifiersep> datastore . put ( block . block , block . data , block . header , block . overwrite , block . is <identifiersep> old <identifiersep> block ) ; } catch ( io <identifiersep> exception e ) { <LOG> } catch ( key <identifiersep> collision <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + e , e ) ; } config <identifiersep> lock . write <identifiersep> lock ( ) . lock ( ) ; try { block < t > current <identifiersep> version <identifiersep> of <identifiersep> block = blocks <identifiersep> by <identifiersep> routing <identifiersep> key . get ( key ) ; <comment> <ect>
if ( completed ) return ; completed = true ; if ( last <identifiersep> sent <identifiersep> packet > 0 ) { delta = now - last <identifiersep> sent <identifiersep> packet ; long threshold = ( real <identifiersep> time ? block <identifiersep> receiver . receipt <identifiersep> timeout <identifiersep> realtime : block <identifiersep> receiver . receipt <identifiersep> timeout <identifiersep> bulk ) ; if ( delta > threshold ) <LOG> else if ( delta > threshold / <number_literal> ) logger . normal ( this , <string_literal> + block <identifiersep> transmitter . this + <string_literal> + time <identifiersep> util . format <identifiersep> time ( delta , <number_literal> , true ) + <string_literal> + delta + <string_literal> + real <identifiersep> time ) ; else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + block <identifiersep> transmitter . this + <string_literal> + time <identifiersep> util . format <identifiersep> time ( delta , <number_literal> , true ) + <string_literal> + delta + <string_literal> + real <identifiersep> time ) ; } last <identifiersep> sent <identifiersep> packet = now ; block <identifiersep> sends <identifiersep> pending -- ; <ect>
<comment> <LOG> } return iface ; } <comment> <ect>
} finally { lock . unlock ( ) ; } } catch ( io <identifiersep> exception e ) { if ( e instanceof socket <identifiersep> exception && ignore <identifiersep> unbindable <identifiersep> ip6 && addr != null && addr . get <identifiersep> address ( ) instanceof inet6address ) continue ; <LOG> logger . error ( this , <string_literal> + address + <string_literal> + port ) ; if ( broken <identifiersep> list == null ) broken <identifiersep> list = new array <identifiersep> list < string > ( ) ; broken <identifiersep> list . add ( address ) ; } } <comment> <ect>
lock . unlock ( ) ; } } public void wait <identifiersep> bound ( ) { lock . lock ( ) ; try { if ( acceptors . size ( ) > 0 ) return ; while ( true ) { <LOG> bound <identifiersep> condition . await <identifiersep> uninterruptibly ( ) ; if ( acceptors . size ( ) > 0 ) { logger . error ( this , <string_literal> ) ; return ; } if ( shutdown ) return ; <ect>
<comment> public void send ( peer <identifiersep> context destination , message m , byte <identifiersep> counter ctr ) throws not <identifiersep> connected <identifiersep> exception { if ( m . get <identifiersep> spec ( ) . is <identifiersep> internal <identifiersep> only ( ) ) { <LOG> return ; } destination . send <identifiersep> async ( m , null , ctr ) ; } public void set <identifiersep> dispatcher ( dispatcher d ) {  <identifiersep> dispatcher = d ; } <comment> <ect>
<comment> boolean timed <identifiersep> out ( long time ) { if (  <identifiersep> matched ) { <LOG> return true ; <comment> <ect>
 <identifiersep> sock . set <identifiersep> reuse <identifiersep> address ( true ) ; } catch ( socket <identifiersep> exception e ) { throw new runtime <identifiersep> exception ( e ) ; } try {  <identifiersep> sock . set <identifiersep> traffic <identifiersep> class ( node . get <identifiersep> traffic <identifiersep> class ( ) . value ) ; } catch ( socket <identifiersep> exception e ) { <LOG> } boolean r = socket <identifiersep> options . set <identifiersep> address <identifiersep> preference (  <identifiersep> sock , socket <identifiersep> options . socket <identifiersep> addr <identifiersep> preference . ipv6 <identifiersep> prefer <identifiersep> src <identifiersep> public ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + listen <identifiersep> port + <string_literal> + ( r ? <string_literal> : <string_literal> ) ) ; <comment> <ect>
} catch ( throwable tt ) { } try { t . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( throwable tt ) { } } finally { system . err . println ( <string_literal> +  <identifiersep> sock . get <identifiersep> local <identifiersep> port ( ) ) ; <LOG> synchronized ( this ) {  <identifiersep> is <identifiersep> done = true ; notify <identifiersep> all ( ) ; } } } private void run <identifiersep> loop ( ) { byte [ ] buf = new byte [ max <identifiersep> receive <identifiersep> size ] ; datagram <identifiersep> packet packet = new datagram <identifiersep> packet ( buf , buf . length ) ; <ect>
public chk <identifiersep> block ( byte [ ] data2 , byte [ ] header2 , node <identifiersep> chk key , boolean verify , byte crypto <identifiersep> algorithm ) throws chk <identifiersep> verify <identifiersep> exception { data = data2 ; headers = header2 ; if ( headers . length != total <identifiersep> headers <identifiersep> length ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + headers . length + <string_literal> + total <identifiersep> headers <identifiersep> length ) ; hash <identifiersep> identifier = ( short ) ( ( ( headers [ 0 ] & 0xff ) < < <number_literal> ) + ( headers [ 1 ] & 0xff ) ) ; <LOG> if ( ( key != null ) && ! verify ) { this . chk = key ; hash <identifiersep> code = key . hash <identifiersep> code ( ) ^ fields . hash <identifiersep> code ( data ) ^ fields . hash <identifiersep> code ( headers ) ^ crypto <identifiersep> algorithm ; return ; } <comment> <ect>
crypto <identifiersep> key = null ; if ( uri . extra != null ) { extra = uri . extra . clone ( ) ; } else extra = null ; this . suggested <identifiersep> edition = uri . suggested <identifiersep> edition ; <LOG> } boolean no <identifiersep> cache <identifiersep> uri = false ; <comment> public freenet <identifiersep> uri intern ( ) { boolean changed <identifiersep> anything = false ; byte [ ] x = extra ; if ( key <identifiersep> type . equals ( <string_literal> ) ) <ect>
this . suggested <identifiersep> edition = 0 ; } <comment> public void decompose ( ) { string r = routing <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( routing <identifiersep> key ) ; string k = crypto <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( crypto <identifiersep> key ) ; string e = extra == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( extra ) ; <LOG> system . out . println ( <string_literal> + key <identifiersep> type ) ; system . out . println ( <string_literal> + r ) ; system . out . println ( <string_literal> + k ) ; system . out . println ( <string_literal> + e ) ; system . out . println ( <string_literal> + ( doc <identifiersep> name == null ? <string_literal> : doc <identifiersep> name ) ) ; <ect>
public void decompose ( ) { string r = routing <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( routing <identifiersep> key ) ; string k = crypto <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( crypto <identifiersep> key ) ; string e = extra == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( extra ) ; system . out . println ( <string_literal> + this ) ; system . out . println ( <string_literal> + key <identifiersep> type ) ; <LOG> system . out . println ( <string_literal> + k ) ; system . out . println ( <string_literal> + e ) ; system . out . println ( <string_literal> + ( doc <identifiersep> name == null ? <string_literal> : doc <identifiersep> name ) ) ; system . out . print ( <string_literal> ) ; if ( meta <identifiersep> str == null ) <ect>
key . length + <string_literal> + hash . digest <identifiersep> size ) ; secret <identifiersep> key <identifiersep> spec signing <identifiersep> key = new secret <identifiersep> key <identifiersep> spec ( key , hash . algo ) ; mac mac ; try { mac = mac . get <identifiersep> instance ( hash . algo ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { <LOG> throw new error ( e ) ; } try { mac . init ( signing <identifiersep> key ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { logger . error ( hmac . class , <string_literal> , e ) ; throw new error ( e ) ; <ect>
{ nonce [ 0 ] & = 0x80 ; } else { nonce [ <number_literal> - n . length ] = 1 ; } int bottom = nonce [ <number_literal> ] & 0x3f ; <LOG> byte [ ] ktop = new byte [ <number_literal> ] ; nonce [ <number_literal> ] & = 0x <identifiersep> c0 ; hash <identifiersep> cipher . process <identifiersep> block ( nonce , 0 , ktop , 0 ) ; byte [ ] stretch = new byte [ <number_literal> ] ; system . arraycopy ( ktop , 0 , stretch , 0 , <number_literal> ) ; for ( int i = 0 ; i < <number_literal> ; ++ i ) <ect>
message <identifiersep> digest sun <identifiersep> md = message <identifiersep> digest . get <identifiersep> instance ( algo , sun ) ; sun <identifiersep> md . digest ( ) ; if ( md . get <identifiersep> provider ( ) != sun <identifiersep> md . get <identifiersep> provider ( ) ) { long time <identifiersep> def = benchmark ( md ) ; long time <identifiersep> sun = benchmark ( sun <identifiersep> md ) ; system . out . println ( algo + <string_literal> + md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; <LOG> logger . minor ( clazz , algo + <string_literal> + md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + sun <identifiersep> md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; if ( time <identifiersep> sun < time <identifiersep> def ) { md = sun <identifiersep> md ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <comment> <ect>
md = sun <identifiersep> md ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <comment> <LOG> } } provider md <identifiersep> provider = md . get <identifiersep> provider ( ) ; system . out . println ( algo + <string_literal> + md <identifiersep> provider ) ; logger . normal ( clazz , algo + <string_literal> + md <identifiersep> provider ) ; md <identifiersep> providers <identifiersep> internal . put ( algo , md <identifiersep> provider ) ; } md <identifiersep> providers = collections . unmodifiable <identifiersep> map ( md <identifiersep> providers <identifiersep> internal ) ; ctx = message <identifiersep> digest . get <identifiersep> instance ( <string_literal> , md <identifiersep> providers . get ( <string_literal> ) ) ; <ect>
system . out . println ( <string_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( s [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( si [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( si [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( i <identifiersep> g [ i ] [ j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t5 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t5 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t6 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t7 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t5 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <LOG> system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t7 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t8 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( u1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <ect>
c . init ( cipher . encrypt <identifiersep> mode , k , iv ) ; c . do <identifiersep> final ( plaintext ) ; logger . normal ( rijndael . class , <string_literal> + provider ) ; system . out . println ( <string_literal> + provider ) ; return provider ; } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> return null ; } } <comment> <ect>
@ override public void on <identifiersep> resume ( client <identifiersep> context context ) throws resume <identifiersep> failed <identifiersep> exception { underlying <identifiersep> buffer . on <identifiersep> resume ( context ) ; try { setup ( context . get <identifiersep> persistent <identifiersep> master <identifiersep> secret ( ) , false ) ; } catch ( io <identifiersep> exception e ) { <LOG> throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } } @ override public void store <identifiersep> to ( data <identifiersep> output <identifiersep> stream dos ) throws io <identifiersep> exception { <ect>
if ( type == null ) throw new storage <identifiersep> format <identifiersep> exception ( <string_literal> ) ; lockable <identifiersep> random <identifiersep> access <identifiersep> buffer underlying = bucket <identifiersep> tools . restore <identifiersep> raf <identifiersep> from ( dis , fg , persistent <identifiersep> file <identifiersep> tracker , master <identifiersep> key ) ; try { return new encrypted <identifiersep> random <identifiersep> access <identifiersep> buffer ( type , underlying , master <identifiersep> key , false ) ; } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } } @ override public int hash <identifiersep> code ( ) { final int prime = <number_literal> ; int result = 1 ; result = prime * result + ( ( type == null ) ? 0 : type . hash <identifiersep> code ( ) ) ; <ect>
try { <comment> sig = signature . get <identifiersep> instance ( default <identifiersep> hash <identifiersep> algorithm ) ; selftest <identifiersep> sign ( key , sig ) ; } catch ( throwable e ) { <comment> <LOG> kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kg . initialize ( this . spec ) ; key = kg . generate <identifiersep> key <identifiersep> pair ( ) ; sig = signature . get <identifiersep> instance ( default <identifiersep> hash <identifiersep> algorithm , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; selftest <identifiersep> sign ( key , sig ) ; <ect>
broken <identifiersep> peers <identifiersep> file . delete ( ) ; file <identifiersep> output <identifiersep> stream fos = new file <identifiersep> output <identifiersep> stream ( broken <identifiersep> peers <identifiersep> file ) ; fis = new file <identifiersep> input <identifiersep> stream ( peers <identifiersep> file ) ; file <identifiersep> util . copy ( fis , fos , - 1 ) ; fos . close ( ) ; fis . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> ) ; } } if ( ! dropped <identifiersep> old <identifiersep> peers . is <identifiersep> empty ( ) ) { try { node . client <identifiersep> core . alerts . register ( dropped <identifiersep> old <identifiersep> peers ) ; logger . error ( this , dropped <identifiersep> old <identifiersep> peers . get <identifiersep> text ( ) ) ; <ect>
if ( ! dropped <identifiersep> old <identifiersep> peers . is <identifiersep> empty ( ) ) { try { node . client <identifiersep> core . alerts . register ( dropped <identifiersep> old <identifiersep> peers ) ; logger . error ( this , dropped <identifiersep> old <identifiersep> peers . get <identifiersep> text ( ) ) ; } catch ( throwable t ) { <comment> <LOG> } } return ! some <identifiersep> broken ; } public boolean add <identifiersep> peer ( peer <identifiersep> node pn ) { return add <identifiersep> peer ( pn , false , false ) ; } <comment> <ect>
boolean in <identifiersep> my <identifiersep> peers = false ; for ( peer <identifiersep> node mp : my <identifiersep> peers ) { if ( mp == pn ) { in <identifiersep> my <identifiersep> peers = true ; break ; } } if ( ! in <identifiersep> my <identifiersep> peers ) { <LOG> <comment> <ect>
file <identifiersep> output <identifiersep> stream fos = null ; file f ; file full = new file ( filename ) . get <identifiersep> absolute <identifiersep> file ( ) ; try { f = file . create <identifiersep> temp <identifiersep> file ( full . get <identifiersep> name ( ) + <string_literal> , <string_literal> , full . get <identifiersep> parent <identifiersep> file ( ) ) ; } catch ( io <identifiersep> exception e2 ) { <LOG> closer . close ( fos ) ; return ; } try { fos = new file <identifiersep> output <identifiersep> stream ( f ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e2 ) { logger . error ( this , <string_literal> + f + <string_literal> + e2 , e2 ) ; <ect>
continue ; } if ( filename . get <identifiersep> parent <identifiersep> file ( ) != null ) filename . get <identifiersep> parent <identifiersep> file ( ) . mkdirs ( ) ; freenet <identifiersep> uri max <identifiersep> chk = null ; s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; if ( s == null ) { <LOG> <comment> <ect>
pattern p = null ; if ( type == dependency <identifiersep> type . classpath ) { <comment> <LOG> <comment> <ect>
p = pattern . compile ( regex ) ; } catch ( pattern <identifiersep> syntax <identifiersep> exception e ) { logger . error ( this , <string_literal> + regex + <string_literal> ) ; p = null ; } } byte [ ] expected <identifiersep> hash = parse <identifiersep> expected <identifiersep> hash ( props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) , base <identifiersep> name ) ; if ( expected <identifiersep> hash == null ) { <LOG> broken = true ; continue ; } s = props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) ; long size = - 1 ; if ( s != null ) { try { <ect>
try { <comment> <LOG> broken = true ; continue ; } } current <identifiersep> file = get <identifiersep> dependency <identifiersep> in <identifiersep> use ( p ) ; } <comment> <ect>
if ( file <identifiersep> version == null ) { f . delete ( ) ; system . out . println ( <string_literal> + f ) ; continue ; } if ( fields . compare <identifiersep> version ( file <identifiersep> version , version ) < = 0 ) { f . delete ( ) ; <LOG> } <comment> <ect>
f = new file ( f , to <identifiersep> find ) ; if ( f . exists ( ) && f . can <identifiersep> execute ( ) ) { if ( ! f . can <identifiersep> read ( ) ) { logger . error ( this , <string_literal> + f ) ; return false ; } if ( f . length ( ) < script <identifiersep> head . length ) { <LOG> return false ; <comment> <ect>
if ( s == null ) break ; filename = new file ( s ) ; <comment> <LOG> atomic <identifiersep> deployer . cleanup ( ) ; return false ; } try { key = new freenet <identifiersep> uri ( s ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + file <identifiersep> base + <string_literal> + s + <string_literal> + e , e ) ; <ect>
s = props . get <identifiersep> property ( file <identifiersep> base + <string_literal> ) ; long size = - 1 ; if ( s != null ) { try { size = long . parse <identifiersep> long ( s ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> atomic <identifiersep> deployer . cleanup ( ) ; return false ; } } <comment> <ect>
if ( inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) ) { try { <comment> <LOG> logger . error ( this , <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name + <string_literal> + e , e ) ; return false ; } system . out . println ( <string_literal> + name + <string_literal> + restart <identifiersep> script + <string_literal> ) ; wrapper <identifiersep> manager . stop ( 0 ) ; return true ; } else return false ; <ect>
system . err . println ( <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name ) ; return false ; } } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name + <string_literal> + e ) ; logger . error ( this , <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name + <string_literal> + e , e ) ; return false ; } <LOG> wrapper <identifiersep> manager . stop ( 0 ) ; return true ; } else return false ; } private file find <identifiersep> shell ( ) { file f = new file ( <string_literal> ) ; if ( f . exists ( ) && f . can <identifiersep> execute ( ) ) return f ; <ect>
static final string restart <identifiersep> script <identifiersep> name = <string_literal> ; private file create <identifiersep> restart <identifiersep> script ( ) throws io <identifiersep> exception { <comment> <LOG> return null ; } <comment> <ect>
string ver = a . get <identifiersep> value ( key ) ; if ( ver != null ) return ver ; } a = m . get <identifiersep> attributes ( <string_literal> ) ; if ( a != null ) { string ver = a . get <identifiersep> value ( key ) ; if ( ver != null ) return ver ; } } } <LOG> return null ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { return null ; } catch ( io <identifiersep> exception e ) { return null ; } finally { <ect>
try { return new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( f , true ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { logger . error ( this , <string_literal> , e ) ; return null ; } catch ( io <identifiersep> exception e ) { <LOG> return null ; } } <comment> private file get <identifiersep> blob <identifiersep> file ( ) { if ( blob <identifiersep> file . exists ( ) ) return blob <identifiersep> file ; return null ; } @ override <ect>
throw new invalid <identifiersep> config <identifiersep> value <identifiersep> exception ( l10n ( <string_literal> , <string_literal> , e . get <identifiersep> localized <identifiersep> message ( ) ) ) ; } legacy <identifiersep> jar <identifiersep> fetcher . legacy <identifiersep> fetch <identifiersep> callback legacy <identifiersep> fetcher <identifiersep> callback = new legacy <identifiersep> jar <identifiersep> fetcher . legacy <identifiersep> fetch <identifiersep> callback ( ) { @ override public void on <identifiersep> success ( legacy <identifiersep> jar <identifiersep> fetcher fetcher ) { if ( transition <identifiersep> main <identifiersep> jar <identifiersep> fetcher . fetched ( ) ) { <LOG> broadcast <identifiersep> uom <identifiersep> announces <identifiersep> old ( ) ; } } @ override public void on <identifiersep> failure ( fetch <identifiersep> exception e , legacy <identifiersep> jar <identifiersep> fetcher fetcher ) { logger . error ( this , <string_literal> <ect>
system . err . println ( <string_literal> + filename + <string_literal> + directory . dir ( ) + <string_literal> + filename ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { closer . close ( fos ) ; closer . close ( result . as <identifiersep> bucket ( ) ) ; } } @ override public void on <identifiersep> resume ( client <identifiersep> context context ) { <ect>
try { <comment> <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; } main <identifiersep> updater . start ( ) ; start <identifiersep> plugin <identifiersep> updaters ( ) ; transition <identifiersep> main <identifiersep> jar <identifiersep> fetcher . start ( ) ; } } private void start <identifiersep> plugin <identifiersep> updaters ( ) { for ( official <identifiersep> plugin <identifiersep> description plugin : node . get <identifiersep> plugin <identifiersep> manager ( ) . get <identifiersep> official <identifiersep> plugins ( ) ) { <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + source + <string_literal> + lname + <string_literal> ) ; return ; } if ( add <identifiersep> on <identifiersep> fail && asked <identifiersep> send <identifiersep> jar . size ( ) + sending <identifiersep> jar . size ( ) >= max <identifiersep> nodes <identifiersep> sending <identifiersep> jar ) { hash <identifiersep> set < peer <identifiersep> node > offered <identifiersep> jar = nodes <identifiersep> offered <identifiersep> main <identifiersep> jar ; if ( offered <identifiersep> jar . add ( source ) ) <LOG> return ; } else { if ( sending <identifiersep> jar . contains ( source ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + lname + <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> ) ; return ; <ect>
prb = new partially <identifiersep> received <identifiersep> bulk ( update <identifiersep> manager . node . get <identifiersep> usm ( ) , length , node . packet <identifiersep> size , data , true ) ; final bulk <identifiersep> transmitter bt ; try { bt = new bulk <identifiersep> transmitter ( prb , source , uid , false , update <identifiersep> manager . ctr , true ) ; } catch ( disconnected <identifiersep> exception e ) { <LOG> data . close ( ) ; return true ; } final runnable r = new runnable ( ) { @ override public void run ( ) { try { <ect>
if ( ! bt . send ( ) ) logger . error ( this , <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) + <string_literal> + bt . get <identifiersep> cancel <identifiersep> reason ( ) ) ; else logger . normal ( this , <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) ) ; } catch ( disconnected <identifiersep> exception e ) { <comment> <LOG> } finally { data . close ( ) ; } } } ; message msg = dmt . create <identifiersep> uom <identifiersep> sending <identifiersep> revocation ( uid , length , update <identifiersep> manager . get <identifiersep> revocation <identifiersep> uri ( ) . to <identifiersep> string ( ) ) ; try { source . send <identifiersep> async ( msg , new async <identifiersep> message <identifiersep> callback ( ) { <ect>
public void disconnected ( ) { <comment> <LOG> } @ override public void sent ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } @ override public string to <identifiersep> string ( ) { <ect>
length = raf . size ( ) ; prb = new partially <identifiersep> received <identifiersep> bulk ( update <identifiersep> manager . node . get <identifiersep> usm ( ) , length , node . packet <identifiersep> size , raf , true ) ; try { bt = new bulk <identifiersep> transmitter ( prb , source , uid , false , update <identifiersep> manager . ctr , true ) ; } catch ( disconnected <identifiersep> exception e ) { <LOG> raf . close ( ) ; return ; } msg = dmt . create <identifiersep> uom <identifiersep> sending <identifiersep> main <identifiersep> jar ( uid , length , uri . to <identifiersep> string ( ) , version ) ; } catch ( runtime <identifiersep> exception e ) { source . finished <identifiersep> sending <identifiersep> uom <identifiersep> jar ( false ) ; <ect>
logger . minor ( this , <string_literal> ) ; <comment> <LOG> source . finished <identifiersep> sending <identifiersep> uom <identifiersep> jar ( false ) ; } @ override public void fatal <identifiersep> error ( ) { <comment> <ect>
logger . minor ( this , <string_literal> ) ; } @ override public string to <identifiersep> string ( ) { return super . to <identifiersep> string ( ) + <string_literal> + uid + <string_literal> + source . get <identifiersep> peer ( ) + <string_literal> ; } } , update <identifiersep> manager . ctr ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <LOG> return ; } catch ( runtime <identifiersep> exception e ) { source . finished <identifiersep> sending <identifiersep> uom <identifiersep> jar ( false ) ; throw e ; } catch ( error e ) { source . finished <identifiersep> sending <identifiersep> uom <identifiersep> jar ( false ) ; <ect>
final int version = m . get <identifiersep> int ( dmt . main <identifiersep> jar <identifiersep> version ) ; final freenet <identifiersep> uri jar <identifiersep> uri ; try { jar <identifiersep> uri = new freenet <identifiersep> uri ( key ) . set <identifiersep> suggested <identifiersep> edition ( version ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> + version + <string_literal> + e + <string_literal> + key , e ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { this . nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar . remove ( source ) ; } return true ; } if ( ! jar <identifiersep> uri . equals ( update <identifiersep> manager . get <identifiersep> uri ( ) . set <identifiersep> suggested <identifiersep> edition ( version ) ) ) { <ect>
integer x = peers <identifiersep> fetching <identifiersep> dependencies . get ( source ) ; if ( x == null ) { logger . error ( this , <string_literal> + source ) ; } else if ( x == 1 ) { peers <identifiersep> fetching <identifiersep> dependencies . remove ( source ) ; } else if ( x < = 0 ) { <LOG> peers <identifiersep> fetching <identifiersep> dependencies . remove ( source ) ; } else { peers <identifiersep> fetching <identifiersep> dependencies . put ( source , x - 1 ) ; } } } <comment> private boolean increment <identifiersep> dependencies ( peer <identifiersep> node source ) { <ect>
@ override public void run ( ) { boolean failed = false ; file tmp = null ; file <identifiersep> random <identifiersep> access <identifiersep> buffer raf = null ; try { <LOG> long uid = update <identifiersep> manager . node . fast <identifiersep> weak <identifiersep> random . next <identifiersep> long ( ) ; fetch <identifiersep> from . send <identifiersep> async ( dmt . create <identifiersep> uom <identifiersep> fetch <identifiersep> dependency ( uid , expected <identifiersep> hash , size ) , null , update <identifiersep> manager . ctr ) ; tmp = file <identifiersep> util . create <identifiersep> temp <identifiersep> file ( save <identifiersep> to . get <identifiersep> name ( ) , node <identifiersep> update <identifiersep> manager . temp <identifiersep> file <identifiersep> suffix , save <identifiersep> to . get <identifiersep> parent <identifiersep> file ( ) ) ; raf = new file <identifiersep> random <identifiersep> access <identifiersep> buffer ( tmp , size , false ) ; partially <identifiersep> received <identifiersep> bulk prb = new partially <identifiersep> received <identifiersep> bulk ( update <identifiersep> manager . node . get <identifiersep> usm ( ) , size , <ect>
system . err . println ( <string_literal> + tmp + <string_literal> + save <identifiersep> to + <string_literal> ) ; } peer <identifiersep> maybe <identifiersep> free <identifiersep> all <identifiersep> slots ( fetch <identifiersep> from ) ; } else { synchronized ( uom <identifiersep> dependency <identifiersep> fetcher . this ) { if ( completed ) return ; } failed = true ; <LOG> <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { <comment> <ect>
bucket to <identifiersep> free = result . as <identifiersep> bucket ( ) ; if ( to <identifiersep> free != null ) to <identifiersep> free . free ( ) ; } return ; } if ( result == null || result . as <identifiersep> bucket ( ) == null || result . as <identifiersep> bucket ( ) . size ( ) == 0 ) { temp <identifiersep> blob <identifiersep> file . delete ( ) ; <LOG> system . err . println ( <string_literal> + available <identifiersep> version ) ; <comment> <ect>
blob <identifiersep> file . delete ( ) ; if ( ! temp <identifiersep> blob <identifiersep> file . rename <identifiersep> to ( blob <identifiersep> file ) ) if ( blob <identifiersep> file . exists ( ) && temp <identifiersep> blob <identifiersep> file . exists ( ) && blob <identifiersep> file . length ( ) == temp <identifiersep> blob <identifiersep> file . length ( ) ) logger . minor ( this , <string_literal> + temp <identifiersep> blob <identifiersep> file + <string_literal> + blob <identifiersep> file + <string_literal> + fetched <identifiersep> version + <string_literal> ) ; else { <LOG> blob <identifiersep> file = null ; } } this . fetched <identifiersep> version = fetched <identifiersep> version ; system . out . println ( <string_literal> + jar <identifiersep> name ( ) + <string_literal> + fetched <identifiersep> version ) ; if ( fetched <identifiersep> version > current <identifiersep> version ) logger . normal ( this , <string_literal> + fetched <identifiersep> version + <string_literal> ) ; maybe <identifiersep> parse <identifiersep> manifest ( result , fetched <identifiersep> version ) ; <ect>
string name = ze . get <identifiersep> name ( ) ; if ( name . equals ( <string_literal> ) ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; long size = ze . get <identifiersep> size ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + size ) ; if ( size > max <identifiersep> manifest <identifiersep> size ) { <LOG> break ; } byte [ ] buf = new byte [ ( int ) size ] ; data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( zis ) ; dis . read <identifiersep> fully ( buf ) ; byte <identifiersep> array <identifiersep> input <identifiersep> stream bais = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( buf ) ; input <identifiersep> stream <identifiersep> reader isr = new input <identifiersep> stream <identifiersep> reader ( bais , <string_literal> ) ; <ect>
zis . close <identifiersep> entry ( ) ; } } } finally { closer . close ( zis ) ; } } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; } catch ( throwable t ) { <LOG> } finally { closer . close ( is ) ; } } static final string dependencies <identifiersep> file = <string_literal> ; <comment> <ect>
byte [ ] salt = new byte [ <number_literal> ] ; dis . read <identifiersep> fully ( salt ) ; byte [ ] iv = new byte [ <number_literal> ] ; dis . read <identifiersep> fully ( iv ) ; byte [ ] data <identifiersep> and <identifiersep> hash = new byte [ length - salt . length - iv . length ] ; dis . read <identifiersep> fully ( data <identifiersep> and <identifiersep> hash ) ; <LOG> byte [ ] pwd = password . get <identifiersep> bytes ( <string_literal> ) ; message <identifiersep> digest md = sha256 . get <identifiersep> message <identifiersep> digest ( ) ; md . update ( pwd ) ; md . update ( salt ) ; byte [ ] outer <identifiersep> key = md . digest ( ) ; block <identifiersep> cipher cipher ; <ect>
<comment> <LOG> byte [ ] data = arrays . copy <identifiersep> of ( data <identifiersep> and <identifiersep> hash , data <identifiersep> and <identifiersep> hash . length - old <identifiersep> hash <identifiersep> length ) ; byte [ ] hash = arrays . copy <identifiersep> of <identifiersep> range ( data <identifiersep> and <identifiersep> hash , data . length , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <ect>
pcfb <identifiersep> mode pcfb = pcfb <identifiersep> mode . create ( cipher , iv ) ; pcfb . block <identifiersep> decipher ( data <identifiersep> and <identifiersep> hash , 0 , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <LOG> clear ( data <identifiersep> and <identifiersep> hash ) ; byte [ ] check <identifiersep> hash = md . digest ( data ) ; <comment> <ect>
byte [ ] client <identifiersep> cache <identifiersep> key = new byte [ <number_literal> ] ; dis . read <identifiersep> fully ( client <identifiersep> cache <identifiersep> key ) ; byte [ ] database <identifiersep> key = null ; database <identifiersep> key = new byte [ <number_literal> ] ; dis . read <identifiersep> fully ( database <identifiersep> key ) ; byte [ ] tempfiles <identifiersep> master <identifiersep> secret = new byte [ <number_literal> ] ; <LOG> hard <identifiersep> random . next <identifiersep> bytes ( tempfiles <identifiersep> master <identifiersep> secret ) ; master <identifiersep> keys ret = new master <identifiersep> keys ( client <identifiersep> cache <identifiersep> key , database <identifiersep> key , tempfiles <identifiersep> master <identifiersep> secret , flags ) ; clear ( data ) ; clear ( hash ) ; sha256 . return <identifiersep> message <identifiersep> digest ( md ) ; return ret ; <ect>
if ( msg . get <identifiersep> spec ( ) == dmt . fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ) { handle <identifiersep> data <identifiersep> insert <identifiersep> rejected ( msg , next , this <identifiersep> tag ) ; return do . next <identifiersep> peer ; <comment> <LOG> finish ( internal <identifiersep> error , next ) ; return do . finished ; } <comment> <ect>
<comment> <LOG> } @ override public void acknowledged ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ssk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void disconnected ( ) { <ect>
@ override public void acknowledged ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ssk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void disconnected ( ) { <LOG> next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void fatal <identifiersep> error ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ssk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } , ssk <identifiersep> insert <identifiersep> sender . this ) ; <ect>
next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } } @ override public boolean should <identifiersep> timeout ( ) { return false ; } @ override public void on <identifiersep> timeout ( ) { <LOG> next . fatal <identifiersep> timeout ( tag , false ) ; } @ override public void on <identifiersep> disconnect ( peer <identifiersep> context ctx ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void on <identifiersep> restarted ( peer <identifiersep> context ctx ) { <ect>
} ) ; return offer <identifiersep> status . fetching ; } finally { orig <identifiersep> tag . sender <identifiersep> transfer <identifiersep> ends ( ( node <identifiersep> chk ) key , this ) ; } } else { <comment> <LOG> return offer <identifiersep> status . try <identifiersep> another ; } } @ override protected message <identifiersep> filter make <identifiersep> accepted <identifiersep> rejected <identifiersep> filter ( peer <identifiersep> node next , long accepted <identifiersep> timeout , uid <identifiersep> tag tag ) { assert ( tag == orig <identifiersep> tag ) ; <comment> <ect>
if ( pub <identifiersep> key == null ) pub <identifiersep> key = dsa <identifiersep> public <identifiersep> key . create ( pubkey <identifiersep> as <identifiersep> bytes ) ; ( ( node <identifiersep> ssk ) key ) . set <identifiersep> pub <identifiersep> key ( pub <identifiersep> key ) ; return true ; } catch ( ssk <identifiersep> verify <identifiersep> exception e ) { pub <identifiersep> key = null ; <LOG> int t = time <identifiersep> since <identifiersep> sent ( ) ; node . failure <identifiersep> table . on <identifiersep> failed ( key , next , htl , t , t ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return false ; <comment> <ect>
next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return ; } if ( have <identifiersep> set <identifiersep> prb ) <comment> <LOG> if ( ! was <identifiersep> fork ) finish ( internal <identifiersep> error , next , true ) ; } finally { if ( was <identifiersep> fork ) next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; } } @ override <ect>
int time <identifiersep> left = msg . get <identifiersep> int ( dmt . time <identifiersep> left ) ; int orig <identifiersep> time <identifiersep> left = time <identifiersep> left ; if ( time <identifiersep> left < = 0 ) { if ( time <identifiersep> left == 0 ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; } else { <LOG> } orig <identifiersep> time <identifiersep> left = 0 ; time <identifiersep> left = 0 ; } <comment> <ect>
if ( ( ! must <identifiersep> send ) && packet . get <identifiersep> length ( ) >= ( max <identifiersep> packet <identifiersep> size * <number_literal> / <number_literal> ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; <comment> <LOG> must <identifiersep> send = true ; } } if ( ( ! must <identifiersep> send ) && num <identifiersep> acks > 0 ) { int max <identifiersep> send <identifiersep> buffer <identifiersep> size = max <identifiersep> send <identifiersep> buffer <identifiersep> size ( ) ; synchronized ( send <identifiersep> buffer <identifiersep> lock ) { if ( send <identifiersep> buffer <identifiersep> used > max <identifiersep> send <identifiersep> buffer <identifiersep> size / <number_literal> ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + send <identifiersep> buffer <identifiersep> used ) ; <ect>
break prio ; } } int message <identifiersep> id = get <identifiersep> message <identifiersep> id ( ) ; if ( message <identifiersep> id == - 1 ) { <comment> <LOG> if ( ! was <identifiersep> generated <identifiersep> ping ) { message <identifiersep> queue . pushfront <identifiersep> prioritized <identifiersep> message <identifiersep> item ( item ) ; <comment> <ect>
sent <identifiersep> packet . add <identifiersep> fragment ( frag ) ; <comment> <LOG> queue . put ( message <identifiersep> id , wrapper ) ; } if ( wrapper . all <identifiersep> sent ( ) ) { if ( ( have <identifiersep> added <identifiersep> stats <identifiersep> bulk == null ) && wrapper . get <identifiersep> item ( ) . send <identifiersep> load <identifiersep> bulk ) { add <identifiersep> stats <identifiersep> bulk = true ; break ; } if ( ( have <identifiersep> added <identifiersep> stats <identifiersep> rt == null ) && wrapper . get <identifiersep> item ( ) . send <identifiersep> load <identifiersep> rt ) { <ect>
int seq <identifiersep> num = key <identifiersep> context . allocate <identifiersep> sequence <identifiersep> number ( pn ) ; if ( seq <identifiersep> num == - 1 ) return null ; packet . set <identifiersep> sequence <identifiersep> number ( seq <identifiersep> num ) ; if ( log <identifiersep> debug && ack <identifiersep> only ) { logger . debug ( this , <string_literal> + packet . get <identifiersep> length ( ) + <string_literal> + this ) ; } else if ( log <identifiersep> debug && ! ack <identifiersep> only ) { <LOG> } if ( packet . get <identifiersep> fragments ( ) . size ( ) > 0 ) { key <identifiersep> context . sent ( sent <identifiersep> packet , seq <identifiersep> num , packet . get <identifiersep> length ( ) ) ; } return packet ; } private int ping <identifiersep> counter ; <comment> <ect>
} , ! req . ignore <identifiersep> store , req . can <identifiersep> write <identifiersep> client <identifiersep> cache , req . real <identifiersep> time <identifiersep> flag , req . local <identifiersep> request <identifiersep> only , req . ignore <identifiersep> store ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; req . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) , context ) ; return true ; } } catch ( throwable t ) { <LOG> req . on <identifiersep> failure ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error ) , context ) ; return true ; } return true ; } } <ect>
if ( ports <identifiersep> not <identifiersep> forwarded . length == 1 ) { return prefix + l10n ( <string_literal> + key <identifiersep> suffix , <string_literal> , integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) ) ; } else if ( ports <identifiersep> not <identifiersep> forwarded . length == <number_literal> ) { return prefix + l10n ( <string_literal> + key <identifiersep> suffix , new string [ ] { <string_literal> , <string_literal> } , new string [ ] { integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) , integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 1 ] ) ) } ) ; } else { <LOG> return <string_literal> ; } } @ override public string get <identifiersep> text ( ) { string url = l10n ( <string_literal> ) ; boolean maybe <identifiersep> forwarded = true ; for ( int port <identifiersep> not <identifiersep> forwarded : ports <identifiersep> not <identifiersep> forwarded ) { <ect>
if ( ports <identifiersep> not <identifiersep> forwarded . length == 1 ) { sb . append ( l10n ( <string_literal> , <string_literal> , integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) ) ) ; } else if ( ports <identifiersep> not <identifiersep> forwarded . length >= <number_literal> ) { sb . append ( l10n ( <string_literal> , new string [ ] { <string_literal> , <string_literal> } , new string [ ] { integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) , integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 1 ] ) ) } ) ) ; if ( ports <identifiersep> not <identifiersep> forwarded . length > <number_literal> ) <LOG> } return sb . to <identifiersep> string ( ) ; } @ override public void is <identifiersep> valid ( boolean validity ) { valid = validity ; } @ override public boolean is <identifiersep> valid ( ) { <ect>
<comment> <LOG> <comment> <ect>
} catch ( peer <identifiersep> parse <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; <LOG> return ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } if ( n . peers . add <identifiersep> peer ( pn ) ) <ect>
} catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; <LOG> return ; } if ( n . peers . add <identifiersep> peer ( pn ) ) system . out . println ( <string_literal> + pn ) ; n . peers . write <identifiersep> peers <identifiersep> darknet <identifiersep> urgent ( ) ; } <comment> <ect>
return false ; } <comment> private boolean remove <identifiersep> peer ( string node <identifiersep> identifier ) { <LOG> for ( darknet <identifiersep> peer <identifiersep> node pn : n . peers . get <identifiersep> darknet <identifiersep> peers ( ) ) { peer peer = pn . get <identifiersep> peer ( ) ; string node <identifiersep> ip <identifiersep> and <identifiersep> port = <string_literal> ; if ( peer != null ) { node <identifiersep> ip <identifiersep> and <identifiersep> port = peer . to <identifiersep> string ( ) ; <ect>
private < t extends uid <identifiersep> tag > boolean inner <identifiersep> lock ( hash <identifiersep> map < long , t > overall <identifiersep> map , hash <identifiersep> map < long , t > local <identifiersep> map , t tag , long uid , boolean ssk , boolean insert , boolean offer <identifiersep> reply , boolean local ) { synchronized ( overall <identifiersep> map ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + overall <identifiersep> map . size ( ) , new exception ( <string_literal> ) ) ; t old <identifiersep> tag = overall <identifiersep> map . get ( uid ) ; if ( old <identifiersep> tag != null ) { if ( old <identifiersep> tag == tag ) { <LOG> } else { return false ; } } overall <identifiersep> map . put ( uid , tag ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + overall <identifiersep> map . size ( ) ) ; if ( local ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid + <string_literal> + ssk + <string_literal> + insert + <string_literal> + offer <identifiersep> reply + <string_literal> + local + <string_literal> + local <identifiersep> map . size ( ) , new exception ( <string_literal> ) ) ; <ect>
if ( ( his <identifiersep> buf . length % <number_literal> != 0 ) || ( his <identifiersep> buf . length < <number_literal> ) ) { logger . error ( this , <string_literal> + uid ) ; return ; } <comment> <LOG> return ; } <comment> <ect>
if ( his <identifiersep> buf <identifiersep> long . length < <number_literal> ) { logger . error ( this , <string_literal> + uid ) ; return ; } long his <identifiersep> random = his <identifiersep> buf <identifiersep> long [ 0 ] ; double his <identifiersep> loc = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ 1 ] ) ; if ( ! location . is <identifiersep> valid ( his <identifiersep> loc ) ) { <LOG> return ; } register <identifiersep> known <identifiersep> location ( his <identifiersep> loc ) ; double [ ] his <identifiersep> friend <identifiersep> locs = new double [ his <identifiersep> buf <identifiersep> long . length - <number_literal> ] ; for ( int i = 0 ; i < his <identifiersep> friend <identifiersep> locs . length ; i ++ ) { his <identifiersep> friend <identifiersep> locs [ i ] = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ i + <number_literal> ] ) ; if ( ! location . is <identifiersep> valid ( his <identifiersep> friend <identifiersep> locs [ i ] ) ) { <ect>
<comment> <LOG> } finally { unlock ( reached <identifiersep> end ) ; if ( item != null ) remove <identifiersep> recently <identifiersep> forwarded <identifiersep> item ( item ) ; } } } <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn ) ; } swaps <identifiersep> rejected <identifiersep> rate <identifiersep> limit ++ ; return true ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + pn + <string_literal> + old <identifiersep> id ) ; int htl = m . get <identifiersep> int ( dmt . htl ) ; if ( htl > swap <identifiersep> max <identifiersep> htl ) { <LOG> htl = swap <identifiersep> max <identifiersep> htl ; } htl -- ; if ( ! node . enable <identifiersep> swapping || htl < = 0 && swapping <identifiersep> disabled ( ) ) { <comment> <ect>
public void on <identifiersep> failed ( key key , peer <identifiersep> node routed <identifiersep> to , short htl , long rf <identifiersep> timeout , long ft <identifiersep> timeout ) { if ( ft <identifiersep> timeout < 0 || ft <identifiersep> timeout > reject <identifiersep> time ) { logger . error ( this , <string_literal> + ft <identifiersep> timeout , new exception ( <string_literal> ) ) ; ft <identifiersep> timeout = math . max ( math . min ( reject <identifiersep> time , ft <identifiersep> timeout ) , 0 ) ; } if ( rf <identifiersep> timeout < 0 || rf <identifiersep> timeout > recently <identifiersep> failed <identifiersep> time ) { if ( rf <identifiersep> timeout > 0 ) <LOG> rf <identifiersep> timeout = math . max ( math . min ( recently <identifiersep> failed <identifiersep> time , rf <identifiersep> timeout ) , 0 ) ; } if ( ! ( node . enable <identifiersep> ulpr <identifiersep> data <identifiersep> propagation || node . enable <identifiersep> per <identifiersep> node <identifiersep> failure <identifiersep> tables ) ) return ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; failure <identifiersep> table <identifiersep> entry entry ; synchronized ( this ) { entry = entries <identifiersep> by <identifiersep> key . get ( key ) ; <ect>
if ( ft <identifiersep> timeout < - 1 || ft <identifiersep> timeout > reject <identifiersep> time ) { <comment> <LOG> rf <identifiersep> timeout = math . max ( math . min ( recently <identifiersep> failed <identifiersep> time , rf <identifiersep> timeout ) , 0 ) ; } if ( ! ( node . enable <identifiersep> ulpr <identifiersep> data <identifiersep> propagation || node . enable <identifiersep> per <identifiersep> node <identifiersep> failure <identifiersep> tables ) ) return ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; failure <identifiersep> table <identifiersep> entry entry ; synchronized ( this ) { entry = entries <identifiersep> by <identifiersep> key . get ( key ) ; <ect>
public class failure <identifiersep> table <identifiersep> cleaner implements runnable { @ override public void run ( ) { try { real <identifiersep> run ( ) ; } catch ( throwable t ) { <LOG> } finally { node . ticker . queue <identifiersep> timed <identifiersep> job ( this , cleanup <identifiersep> period ) ; } } private void real <identifiersep> run ( ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; failure <identifiersep> table <identifiersep> entry [ ] entries ; <ect>
freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; <comment> <LOG> else logger . normal ( this , <string_literal> + req + <string_literal> ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + req ) ; } } <comment> <ect>
lm . set <identifiersep> location ( loc <identifiersep> d ) ; my <identifiersep> name = fs . get ( <string_literal> ) ; if ( my <identifiersep> name == null ) { my <identifiersep> name = new <identifiersep> name ( ) ; } string ver <identifiersep> string = fs . get ( <string_literal> ) ; if ( ver <identifiersep> string == null ) { <LOG> system . err . println ( <string_literal> ) ; } else { last <identifiersep> version = version . get <identifiersep> arbitrary <identifiersep> build <identifiersep> number ( ver <identifiersep> string , - 1 ) ; } } public void make <identifiersep> store ( string val ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception { string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; if ( val . equals ( <string_literal> ) ) { <ect>
public void make <identifiersep> store ( string val ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception { string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; if ( val . equals ( <string_literal> ) ) { try { init <identifiersep> salt <identifiersep> hash <identifiersep> fs ( suffix , true , null ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { <LOG> system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
fos = new file <identifiersep> output <identifiersep> stream ( backup ) ; fs . write <identifiersep> to ( fos ) ; fos . close ( ) ; fos = null ; file <identifiersep> util . rename <identifiersep> to ( backup , orig ) ; } catch ( io <identifiersep> exception ioe ) { <LOG> return ; } finally { closer . close ( fos ) ; } } private void init <identifiersep> node <identifiersep> file <identifiersep> settings ( ) { logger . normal ( this , <string_literal> ) ; <comment> <ect>
try { toadlets = new simple <identifiersep> toadlet <identifiersep> server ( fproxy <identifiersep> config , new array <identifiersep> bucket <identifiersep> factory ( ) , executor , this ) ; fproxy <identifiersep> config . finished <identifiersep> initialization ( ) ; toadlets . start ( ) ; } catch ( io <identifiersep> exception e4 ) { logger . error ( this , <string_literal> + e4 , e4 ) ; <LOG> e4 . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> could <identifiersep> not <identifiersep> start <identifiersep> fproxy , <string_literal> + e4 ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e4 ) { system . err . println ( <string_literal> + e4 ) ; e4 . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> could <identifiersep> not <identifiersep> start <identifiersep> fproxy , <string_literal> + e4 ) ; <ect>
<comment> node <identifiersep> config . finished <identifiersep> initialization ( ) ; if ( should <identifiersep> write <identifiersep> config ) config . store ( ) ; write <identifiersep> node <identifiersep> file ( ) ; <comment> <LOG> plugin <identifiersep> manager = new plugin <identifiersep> manager ( this , last <identifiersep> version ) ; shutdown <identifiersep> hook . add <identifiersep> early <identifiersep> job ( new native <identifiersep> thread ( <string_literal> , native <identifiersep> thread . high <identifiersep> priority , true ) { @ override public void real <identifiersep> run ( ) { plugin <identifiersep> manager . stop ( seconds . to <identifiersep> millis ( <number_literal> ) ) ; <comment> <ect>
file dir = store <identifiersep> dir . dir ( ) ; file [ ] list = dir . list <identifiersep> files ( ) ; for ( file f : list ) { string name = f . get <identifiersep> name ( ) ; if ( f . is <identifiersep> file ( ) && name . to <identifiersep> lower <identifiersep> case ( ) . matches ( <string_literal> ) ) { <LOG> try { file <identifiersep> util . secure <identifiersep> delete ( f ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + f + <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } } private void fix <identifiersep> certs <identifiersep> files ( ) { <ect>
try { file tmp <identifiersep> file = file . create <identifiersep> temp <identifiersep> file ( plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https . certfile <identifiersep> old , <string_literal> , new file ( <string_literal> ) ) ; plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https . write <identifiersep> certs <identifiersep> to ( tmp <identifiersep> file ) ; if ( file <identifiersep> util . rename <identifiersep> to ( tmp <identifiersep> file , certs ) ) { long new <identifiersep> length = certs . length ( ) ; if ( new <identifiersep> length != old <identifiersep> length ) <LOG> } else { if ( certs . length ( ) != tmp <identifiersep> file . length ( ) ) { system . err . println ( <string_literal> + certs + <string_literal> ) ; file manual = new file ( plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https . certfile <identifiersep> old + <string_literal> ) ; manual . delete ( ) ; if ( tmp <identifiersep> file . rename <identifiersep> to ( manual ) ) <ect>
} else { if ( certs . length ( ) != tmp <identifiersep> file . length ( ) ) { system . err . println ( <string_literal> + certs + <string_literal> ) ; file manual = new file ( plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https . certfile <identifiersep> old + <string_literal> ) ; manual . delete ( ) ; if ( tmp <identifiersep> file . rename <identifiersep> to ( manual ) ) <LOG> else tmp <identifiersep> file . delete ( ) ; } } } catch ( io <identifiersep> exception e ) { } } <comment> <ect>
failure <identifiersep> table . on <identifiersep> found ( block ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } catch ( throwable t ) { system . err . println ( t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } if ( client <identifiersep> core != null && client <identifiersep> core . request <identifiersep> starters != null ) { client <identifiersep> core . request <identifiersep> starters . chk <identifiersep> fetch <identifiersep> scheduler <identifiersep> bulk . trip <identifiersep> pending <identifiersep> key ( block ) ; client <identifiersep> core . request <identifiersep> starters . chk <identifiersep> fetch <identifiersep> scheduler <identifiersep> rt . trip <identifiersep> pending <identifiersep> key ( block ) ; } } <comment> public void store <identifiersep> insert ( ssk <identifiersep> block block , boolean deep , boolean overwrite , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore ) throws key <identifiersep> collision <identifiersep> exception { store ( block , deep , overwrite , can <identifiersep> write <identifiersep> client <identifiersep> cache , can <identifiersep> write <identifiersep> datastore , false ) ; <ect>
logger . error ( this , <string_literal> + e , e ) ; } catch ( key <identifiersep> collision <identifiersep> exception e ) { throw e ; } catch ( throwable t ) { system . err . println ( t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> } if ( client <identifiersep> core != null && client <identifiersep> core . request <identifiersep> starters != null ) { client <identifiersep> core . request <identifiersep> starters . ssk <identifiersep> fetch <identifiersep> scheduler <identifiersep> bulk . trip <identifiersep> pending <identifiersep> key ( block ) ; client <identifiersep> core . request <identifiersep> starters . ssk <identifiersep> fetch <identifiersep> scheduler <identifiersep> rt . trip <identifiersep> pending <identifiersep> key ( block ) ; } } final boolean decrement <identifiersep> at <identifiersep> max ; final boolean decrement <identifiersep> at <identifiersep> min ; <comment> <ect>
system . out . println ( reason ) ; } finally { system . exit ( reason ) ; } } public void exit ( string reason ) { try { this . park ( ) ; <LOG> } finally { system . exit ( 0 ) ; } } <comment> <ect>
public void received <identifiersep> node <identifiersep> to <identifiersep> node <identifiersep> message ( peer <identifiersep> node src , int type , short <identifiersep> buffer message <identifiersep> data , boolean parting <identifiersep> message ) { boolean from <identifiersep> darknet = src instanceof darknet <identifiersep> peer <identifiersep> node ; node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener listener = null ; synchronized ( this ) { listener = n2nm <identifiersep> listeners . get ( type ) ; } if ( listener == null ) { <LOG> return ; } listener . handle <identifiersep> message ( message <identifiersep> data . get <identifiersep> data ( ) , from <identifiersep> darknet , src , type ) ; } private node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener diff <identifiersep> noderef <identifiersep> listener = new node <identifiersep> to <identifiersep> node <identifiersep> message <identifiersep> listener ( ) { @ override public void handle <identifiersep> message ( byte [ ] data , boolean from <identifiersep> darknet , peer <identifiersep> node src , int type ) { logger . normal ( this , <string_literal> + src . get <identifiersep> peer ( ) ) ; <ect>
<comment> <LOG> add <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> backward ( list ) ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + list + <string_literal> ) ; add <identifiersep> to <identifiersep> empty <identifiersep> backward ( list ) ; } if ( prev == null ) list = non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . head ( ) ; <ect>
} else if ( must <identifiersep> send <identifiersep> load <identifiersep> bulk && item . send <identifiersep> load <identifiersep> bulk && ! add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> bulk . value ) { add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> bulk . value = true ; must <identifiersep> send <identifiersep> load <identifiersep> bulk = false ; } if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; if ( ret != null ) return ret ; } if ( log <identifiersep> debug ) <LOG> if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; return null ; } } <comment> <ect>
int non <identifiersep> empty = non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id == null ? 0 : non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . size ( ) ; int empty = empty <identifiersep> items <identifiersep> with <identifiersep> id == null ? 0 : empty <identifiersep> items <identifiersep> with <identifiersep> id . size ( ) ; int by <identifiersep> id = items <identifiersep> by <identifiersep> id == null ? 0 : items <identifiersep> by <identifiersep> id . size ( ) ; if ( non <identifiersep> empty + empty < by <identifiersep> id ) { logger . error ( this , <string_literal> + non <identifiersep> empty + <string_literal> + empty + <string_literal> + by <identifiersep> id + <string_literal> + this ) ; } else if ( log <identifiersep> debug ) <LOG> } if ( round <identifiersep> robin <identifiersep> between <identifiersep> ui <identifiersep> ds ) move <identifiersep> to <identifiersep> urgent ( now ) ; clear <identifiersep> old <identifiersep> non <identifiersep> urgent ( now ) ; if ( round <identifiersep> robin <identifiersep> between <identifiersep> ui <identifiersep> ds ) { message <identifiersep> item item = add <identifiersep> urgent <identifiersep> messages ( now , add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> rt , add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> bulk ) ; if ( item != null ) return item ; <ect>
return ; } if ( list . time <identifiersep> last <identifiersep> sent == - 1 || now - list . time <identifiersep> last <identifiersep> sent > forget <identifiersep> after ) { <comment> <LOG> else if ( old != list ) logger . error ( this , <string_literal> + old + <string_literal> + list + <string_literal> + list . id ) ; empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( list ) ; removed ++ ; } else { if ( log <identifiersep> debug && removed > 0 ) <ect>
public void set ( string [ ] val ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception { set <identifiersep> upload <identifiersep> allowed <identifiersep> dirs ( val ) ; } } ) ; set <identifiersep> upload <identifiersep> allowed <identifiersep> dirs ( node <identifiersep> config . get <identifiersep> string <identifiersep> arr ( <string_literal> ) ) ; logger . normal ( this , <string_literal> ) ; <LOG> usk <identifiersep> manager . init ( client <identifiersep> context ) ; node <identifiersep> config . register ( <string_literal> , <string_literal> , sort <identifiersep> order ++ , true , false , <string_literal> , <string_literal> , new int <identifiersep> callback ( ) { @ override public integer get ( ) { <ect>
<comment> <LOG> return true ; } <comment> <ect>
public void run ( ) { logger . normal ( this , <string_literal> ) ; if ( node . get <identifiersep> database <identifiersep> key ( ) != null ) { try { finish <identifiersep> init <identifiersep> storage ( ) ; } catch ( throwable t ) { <LOG> system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
<comment> public void async <identifiersep> get ( final key key , boolean offers <identifiersep> only , final request <identifiersep> completion <identifiersep> listener listener , boolean can <identifiersep> read <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , final boolean real <identifiersep> time <identifiersep> flag , boolean local <identifiersep> only , boolean ignore <identifiersep> store ) { final long uid = make <identifiersep> uid ( ) ; final boolean is <identifiersep> ssk = key instanceof node <identifiersep> ssk ; final request <identifiersep> tag tag = new request <identifiersep> tag ( is <identifiersep> ssk , request <identifiersep> tag . start . async <identifiersep> get , null , real <identifiersep> time <identifiersep> flag , uid , node ) ; if ( ! tracker . lock <identifiersep> uid ( uid , is <identifiersep> ssk , false , false , true , real <identifiersep> time <identifiersep> flag , tag ) ) { <LOG> listener . on <identifiersep> failed ( new low <identifiersep> level <identifiersep> get <identifiersep> exception ( low <identifiersep> level <identifiersep> get <identifiersep> exception . internal <identifiersep> error , <string_literal> ) ) ; return ; } tag . set <identifiersep> accepted ( ) ; short htl = node . max <identifiersep> htl ( ) ; <comment> <ect>
@ override protected void maybe <identifiersep> clear <identifiersep> peer <identifiersep> added <identifiersep> time <identifiersep> on <identifiersep> restart ( long now ) { <comment> <LOG> <comment> <ect>
offset += <number_literal> ; } else { if ( plaintext . length < ( offset + <number_literal> ) ) { packet . error = true ; return packet ; } if ( prev <identifiersep> fragment <identifiersep> id == - 1 ) { <LOG> packet . error = true ; return packet ; } message <identifiersep> id = prev <identifiersep> fragment <identifiersep> id + ( ( ( plaintext [ offset ] & 0x0f ) < < <number_literal> ) | ( plaintext [ offset + 1 ] & 0x <identifiersep> ff ) ) ; offset += <number_literal> ; } prev <identifiersep> fragment <identifiersep> id = message <identifiersep> id ; <ect>
logger . warning ( npf <identifiersep> packet . class , <string_literal> ) ; } } else { fragment <identifiersep> offset = value ; } } else { message <identifiersep> length = fragment <identifiersep> length ; } if ( ( offset + fragment <identifiersep> length ) > plaintext . length ) { <LOG> packet . error = true ; break ; } byte [ ] fragment <identifiersep> data = arrays . copy <identifiersep> of <identifiersep> range ( plaintext , offset , offset + fragment <identifiersep> length ) ; offset += fragment <identifiersep> length ; packet . fragments . add ( new message <identifiersep> fragment ( short <identifiersep> message , is <identifiersep> fragmented , first <identifiersep> fragment , message <identifiersep> id , fragment <identifiersep> length , message <identifiersep> length , fragment <identifiersep> offset , fragment <identifiersep> data , null ) ) ; <ect>
return true ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + m + <string_literal> + source ) ; if ( callback != null ) { try { callback . snoop ( m , node ) ; } catch ( throwable t ) { <LOG> } } message <identifiersep> type spec = m . get <identifiersep> spec ( ) ; if ( spec == dmt . fnp <identifiersep> ping ) { <comment> <ect>
node . park ( ) ; system . exit ( 0 ) ; } } system . err . println ( <string_literal> + target <identifiersep> peers + <string_literal> ) ; node . park ( ) ; system . exit ( exit <identifiersep> failed <identifiersep> target ) ; } catch ( throwable t ) { <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; try { if ( node != null ) node . park ( ) ; } catch ( throwable t1 ) { } system . exit ( exit <identifiersep> threw <identifiersep> something ) ; <ect>
public static void main ( string [ ] args ) throws exception { system . out . println ( <string_literal> ) ; system . out . println ( ) ; string dir = <string_literal> ; file wd = new file ( dir ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { <LOG> system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } wd . mkdir ( ) ; <comment> <ect>
logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + i ) ; } logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + number <identifiersep> of <identifiersep> nodes + <string_literal> ) ; <comment> <LOG> nodes [ i ] . start ( false ) ; } wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; <comment> <ect>
<comment> <LOG> system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <string_literal> + ( double ) no <identifiersep> swaps / ( double ) new <identifiersep> swaps + <string_literal> + ( ( total <identifiersep> started * <number_literal> ) - ( no <identifiersep> swaps + new <identifiersep> swaps ) ) ) ; system . err . println ( <string_literal> + ( ( double ) ( no <identifiersep> swaps - last <identifiersep> no <identifiersep> swaps ) ) / ( ( double ) ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ) ; last <identifiersep> no <identifiersep> swaps = no <identifiersep> swaps ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> already <identifiersep> locked ) ; system . err . println ( <string_literal> + location <identifiersep> manager . swaps <identifiersep> rejected <identifiersep> nowhere <identifiersep> to <identifiersep> go ) ; <ect>
csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <comment> <LOG> insert <identifiersep> block block = new insert <identifiersep> block ( single , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; freenet <identifiersep> uri uri = null ; int successes = 0 ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . err . println ( <string_literal> + i ) ; try { <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . err . println ( <string_literal> + i ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri this <identifiersep> uri = client . insert ( block , false , null ) ; if ( uri != null && ! this <identifiersep> uri . equals ( uri ) ) { <LOG> system . exit ( exit <identifiersep> different <identifiersep> uri ) ; } uri = this <identifiersep> uri ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + i + <string_literal> + ( t2 - t1 ) + <string_literal> + uri + <string_literal> ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; csv <identifiersep> line . add ( uri . to <identifiersep> ascii <identifiersep> string ( ) ) ; <ect>
csv <identifiersep> line . add ( uri . to <identifiersep> ascii <identifiersep> string ( ) ) ; successes ++ ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; <LOG> } } if ( successes == <number_literal> ) system . err . println ( <string_literal> + successes ) ; else if ( successes != 0 ) system . err . println ( <string_literal> + successes ) ; else system . err . println ( <string_literal> + successes ) ; <ect>
csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + e + <string_literal> + i + <string_literal> ) ; } } if ( successes == <number_literal> ) system . err . println ( <string_literal> + successes ) ; else if ( successes != 0 ) <LOG> else system . err . println ( <string_literal> + successes ) ; uri = null ; <comment> <ect>
system . err . println ( <string_literal> + e ) ; } } for ( int i = 0 ; i < mhk <identifiersep> ur <identifiersep> is . length ; i ++ ) { try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( mhk <identifiersep> ur <identifiersep> is [ i ] ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( fetch <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; <ect>
private static final int opennet <identifiersep> port1 = <number_literal> ; private static final int darknet <identifiersep> port2 = <number_literal> ; private static final int opennet <identifiersep> port2 = <number_literal> ; private static final int max <identifiersep> n = <number_literal> ; public static void main ( string [ ] args ) { if ( args . length < 0 || args . length > <number_literal> ) { <LOG> system . exit ( 1 ) ; } string uid = args [ 0 ] ; if ( args . length == <number_literal> && ( args [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) || args [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) || args [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) ) { try { dump <identifiersep> stats ( uid ) ; } catch ( io <identifiersep> exception e ) { <ect>
dump <identifiersep> stats ( uid ) ; } catch ( io <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( 1 ) ; } catch ( parse <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( <number_literal> ) ; } system . exit ( 0 ) ; } list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( <number_literal> ) ; } system . exit ( 0 ) ; } list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <LOG> csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; try { final file dir = new file ( <string_literal> + uid ) ; <ect>
break ; } } } } } static void connect ( node a , node b ) { try { a . connect ( b , trust , visibility ) ; b . connect ( a , trust , visibility ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( freenet . io . comm . reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; <ect>
b . connect ( a , trust , visibility ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( freenet . io . comm . reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { <LOG> } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } } static double distance ( node a , node b ) { double a <identifiersep> l = a . get <identifiersep> location ( ) ; double b <identifiersep> l = b . get <identifiersep> location ( ) ; return location . distance ( a <identifiersep> l , b <identifiersep> l ) ; <ect>
if ( count <identifiersep> backed <identifiersep> off > 0 ) { if ( log <identifiersep> minor ) logger . minor ( real <identifiersep> node <identifiersep> test . class , <string_literal> + nodes [ i ] + <string_literal> + count <identifiersep> backed <identifiersep> off ) ; } } double avg <identifiersep> ping <identifiersep> time = total <identifiersep> ping <identifiersep> time / nodes . length ; if ( count <identifiersep> fully <identifiersep> connected == nodes . length && count <identifiersep> really <identifiersep> connected == nodes . length && total <identifiersep> backed <identifiersep> off == 0 && min <identifiersep> ping <identifiersep> time < node <identifiersep> stats . default <identifiersep> sub <identifiersep> max <identifiersep> ping <identifiersep> time && max <identifiersep> ping <identifiersep> time < node <identifiersep> stats . default <identifiersep> sub <identifiersep> max <identifiersep> ping <identifiersep> time && avg <identifiersep> ping <identifiersep> time < node <identifiersep> stats . default <identifiersep> sub <identifiersep> max <identifiersep> ping <identifiersep> time ) { <LOG> logger . normal ( real <identifiersep> node <identifiersep> test . class , <string_literal> ) ; system . err . println ( ) ; return ; } else { long t <identifiersep> delta = ( system . current <identifiersep> time <identifiersep> millis ( ) - t <identifiersep> start ) / <number_literal> ; system . err . println ( <string_literal> + count <identifiersep> fully <identifiersep> connected + <string_literal> + nodes . length + <string_literal> + total <identifiersep> connections + <string_literal> + total <identifiersep> peers + <string_literal> + total <identifiersep> partial <identifiersep> connections + <string_literal> + total <identifiersep> compatible <identifiersep> connections + <string_literal> + total <identifiersep> backed <identifiersep> off + <string_literal> + ( int ) min <identifiersep> ping <identifiersep> time + <string_literal> + ( int ) avg <identifiersep> ping <identifiersep> time + <string_literal> + ( int ) max <identifiersep> ping <identifiersep> time + <string_literal> + t <identifiersep> delta + 's' ) ; <ect>
static final boolean real <identifiersep> time <identifiersep> flag = false ; static final friend <identifiersep> trust trust = friend <identifiersep> trust . low ; static final friend <identifiersep> visibility visibility = friend <identifiersep> visibility . no ; public static final int darknet <identifiersep> port <identifiersep> base = real <identifiersep> node <identifiersep> ping <identifiersep> test . darknet <identifiersep> port <identifiersep> end ; public static final int darknet <identifiersep> port <identifiersep> end = darknet <identifiersep> port <identifiersep> base + number <identifiersep> of <identifiersep> nodes ; public static void main ( string [ ] args ) throws fs <identifiersep> parse <identifiersep> exception , peer <identifiersep> parse <identifiersep> exception , chk <identifiersep> encode <identifiersep> exception , invalid <identifiersep> threshold <identifiersep> exception , node <identifiersep> init <identifiersep> exception , reference <identifiersep> signature <identifiersep> verification <identifiersep> exception , key <identifiersep> collision <identifiersep> exception , ssk <identifiersep> encode <identifiersep> exception , io <identifiersep> exception , interrupted <identifiersep> exception , ssk <identifiersep> verify <identifiersep> exception , invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception , peer <identifiersep> too <identifiersep> old <identifiersep> exception { <LOG> system . err . println ( ) ; string test <identifiersep> name = <string_literal> ; file wd = new file ( test <identifiersep> name ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; <ect>
try { file <identifiersep> output <identifiersep> stream fos = new file <identifiersep> output <identifiersep> stream ( file , true ) ; output <identifiersep> stream <identifiersep> writer w = new output <identifiersep> stream <identifiersep> writer ( fos ) ; w . write ( fields . comma <identifiersep> list ( csv <identifiersep> line . to <identifiersep> array ( ) , ' ! ' ) + <string_literal> ) ; w . close ( ) ; } catch ( io <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> threw <identifiersep> something ) ; } } } <ect>
wd . mkdir ( ) ; <comment> <LOG> system . out . println ( ) ; dummy <identifiersep> random <identifiersep> source random = new dummy <identifiersep> random <identifiersep> source ( ) ; <comment> <ect>
for ( int i = 0 ; i < number <identifiersep> of <identifiersep> nodes ; i ++ ) { nodes [ i ] . start ( false ) ; system . err . println ( <string_literal> + i + <string_literal> + nodes . length ) ; } wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; wait <identifiersep> for <identifiersep> ping <identifiersep> average ( 0 . <number_literal> , nodes , random , max <identifiersep> pings , <number_literal> ) ; system . out . println ( ) ; <LOG> system . out . println ( ) ; high <identifiersep> level <identifiersep> simple <identifiersep> client [ ] clients = new high <identifiersep> level <identifiersep> simple <identifiersep> client [ nodes . length ] ; for ( int i = 0 ; i < clients . length ; i ++ ) { clients [ i ] = nodes [ i ] . client <identifiersep> core . make <identifiersep> client ( request <identifiersep> starter . immediate <identifiersep> splitfile <identifiersep> priority <identifiersep> class , false , false ) ; } <comment> <ect>
logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + new string ( new <identifiersep> block . memory <identifiersep> decode ( ) , <string_literal> ) ) ; logger . normal ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + chk . get <identifiersep> uri ( ) ) ; logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( block . get <identifiersep> headers ( ) ) ) ; <comment> <LOG> logger . minor ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + fields . hash <identifiersep> code ( enc <identifiersep> data ) + <string_literal> + fields . hash <identifiersep> code ( enc <identifiersep> headers ) ) ; } catch ( freenet . node . low <identifiersep> level <identifiersep> put <identifiersep> exception put <identifiersep> ex ) { logger . error ( real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . class , <string_literal> + put <identifiersep> ex ) ; system . err . println ( <string_literal> + put <identifiersep> ex ) ; system . exit ( exit <identifiersep> insert <identifiersep> failed ) ; } } <comment> <ect>
if ( i == 0 ) uri = todays <identifiersep> insert ; else { uri = get <identifiersep> historic <identifiersep> uri ( uid , i , target <identifiersep> date ) ; } if ( uri == null ) { system . out . println ( <string_literal> + i ) ; continue ; } <LOG> try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + i + <string_literal> + ( t2 - t1 ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; <ect>
+ opennet <identifiersep> peers + <string_literal> + opennet <identifiersep> conns ) ; seconds ++ ; if ( opennet <identifiersep> conns >= target <identifiersep> peers ) { success = true ; break ; } } if ( ! success ) <LOG> return success ; } } <ect>
public static void main ( string [ ] args ) throws exception { system . out . println ( <string_literal> ) ; system . out . println ( ) ; string dir = <string_literal> ; file wd = new file ( dir ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { <LOG> system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } if ( ! wd . mkdir ( ) ) { system . err . println ( <string_literal> + dir + <string_literal> ) ; return ; } node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir , false , log <identifiersep> level . error , <string_literal> , true ) ; <comment> <ect>
<comment> <LOG> nodes [ i ] = node <identifiersep> starter . create <identifiersep> test <identifiersep> node ( darknet <identifiersep> port <identifiersep> base + i , 0 , dir , true , max <identifiersep> htl , 0 <comment> , random , executor , <number_literal> * number <identifiersep> of <identifiersep> nodes , <number_literal> * <number_literal> , true , enable <identifiersep> swapping , false , false , false , enable <identifiersep> swap <identifiersep> queueing , true , output <identifiersep> bandwidth <identifiersep> limit , enable <identifiersep> foaf , false , true , false , null , i == 0 ) ; logger . normal ( real <identifiersep> node <identifiersep> probe <identifiersep> test . class , <string_literal> + i ) ; } logger . normal ( real <identifiersep> node <identifiersep> probe <identifiersep> test . class , <string_literal> + number <identifiersep> of <identifiersep> nodes + <string_literal> ) ; <comment> <ect>
system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> try { int selection = integer . parse <identifiersep> int ( r . read <identifiersep> line ( ) ) ; if ( selection == types . length ) { system . err . print ( <string_literal> + ( number <identifiersep> of <identifiersep> nodes - 1 ) + <string_literal> ) ; index = integer . value <identifiersep> of ( r . read <identifiersep> line ( ) ) ; } else if ( selection == types . length + 1 ) { <ect>
t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; } catch ( insert <identifiersep> exception e ) { f = e ; } finally { synchronized ( insert <identifiersep> batch . this ) { running <identifiersep> inserts -- ; <LOG> <comment> <ect>
public static void main ( string [ ] args ) { if ( args . length < 1 || args . length > <number_literal> ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( ) ; <LOG> csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; <ect>
<comment> <LOG> system . exit ( exit <identifiersep> no <identifiersep> seednodes ) ; } final file inner <identifiersep> dir = new file ( dir , integer . to <identifiersep> string ( darknet <identifiersep> port1 ) ) ; inner <identifiersep> dir . mkdir ( ) ; fis = new file <identifiersep> input <identifiersep> stream ( seednodes ) ; file <identifiersep> util . write <identifiersep> to ( fis , new file ( inner <identifiersep> dir , <string_literal> ) ) ; fis . close ( ) ; <ect>
fast <identifiersep> random . next <identifiersep> bytes ( buf ) ; int to <identifiersep> write = ( int ) math . min ( test <identifiersep> size - written , buf . length ) ; os . write ( buf , 0 , to <identifiersep> write ) ; written += to <identifiersep> write ; } os . close ( ) ; <comment> <LOG> freenet <identifiersep> uri uri = insert <identifiersep> data ( data <identifiersep> file ) ; <comment> <ect>
} catch ( fetch <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> fetch <identifiersep> failed ) ; return ; } long end <identifiersep> fetch <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> second <identifiersep> node . park ( ) ; system . exit ( 0 ) ; } catch ( throwable t ) { system . err . println ( <string_literal> + t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; try { <ect>
private static freenet <identifiersep> uri insert <identifiersep> data ( file data <identifiersep> file ) throws io <identifiersep> exception { long start <identifiersep> insert <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; inet <identifiersep> address localhost = inet <identifiersep> address . get <identifiersep> by <identifiersep> name ( <string_literal> ) ; socket sock = new socket ( localhost , <number_literal> ) ; output <identifiersep> stream sock <identifiersep> os = sock . get <identifiersep> output <identifiersep> stream ( ) ; input <identifiersep> stream sock <identifiersep> is = sock . get <identifiersep> input <identifiersep> stream ( ) ; <LOG> line <identifiersep> reading <identifiersep> input <identifiersep> stream lis = new line <identifiersep> reading <identifiersep> input <identifiersep> stream ( sock <identifiersep> is ) ; output <identifiersep> stream <identifiersep> writer osw = new output <identifiersep> stream <identifiersep> writer ( sock <identifiersep> os , <string_literal> ) ; osw . write ( <string_literal> + system . current <identifiersep> time <identifiersep> millis ( ) + <string_literal> ) ; osw . flush ( ) ; string name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( lis , <number_literal> , <number_literal> , true , false , true ) ; <ect>
osw . flush ( ) ; string name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( lis , <number_literal> , <number_literal> , true , false , true ) ; if ( ! name . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } <LOG> osw . write ( <string_literal> + test <identifiersep> size + <string_literal> ) ; osw . flush ( ) ; input <identifiersep> stream is = new file <identifiersep> input <identifiersep> stream ( data <identifiersep> file ) ; file <identifiersep> util . copy ( is , sock <identifiersep> os , test <identifiersep> size ) ; system . out . println ( <string_literal> ) ; while ( true ) { <ect>
<comment> if ( version != 1 ) { logger . error ( this , <string_literal> + version ) ; return ; } if ( neg <identifiersep> type >= 0 && neg <identifiersep> type < <number_literal> ) { <comment> <LOG> return ; } else if ( neg <identifiersep> type == <number_literal> ) { <comment> <ect>
<comment> process <identifiersep> jfk <identifiersep> message4 ( payload , <number_literal> , pn , reply <identifiersep> to , old <identifiersep> opennet <identifiersep> peer , false , - 1 , neg <identifiersep> type ) ; } } } ) ; } else { <LOG> return ; } } <comment> <ect>
byte [ ] his <identifiersep> exponential = arrays . copy <identifiersep> of <identifiersep> range ( payload , offset , offset + modulus <identifiersep> length ) ; if ( unknown <identifiersep> initiator ) { <comment> <LOG> return ; } } if ( throttle <identifiersep> rekey ( pn , reply <identifiersep> to ) ) return ; try { send <identifiersep> jfk <identifiersep> message2 ( nonce <identifiersep> initiator , his <identifiersep> exponential , pn , reply <identifiersep> to , unknown <identifiersep> initiator , setup <identifiersep> type , neg <identifiersep> type ) ; } catch ( no <identifiersep> contexts <identifiersep> exception e ) { handle <identifiersep> no <identifiersep> contexts <identifiersep> exception ( e , no <identifiersep> contexts <identifiersep> exception . context . replying ) ; <ect>
logger . error ( this , <string_literal> + pn ) ; } } private long last <identifiersep> logged <identifiersep> no <identifiersep> contexts = - 1 ; private static long log <identifiersep> no <identifiersep> contexts <identifiersep> interval = minutes . to <identifiersep> millis ( 1 ) ; private void handle <identifiersep> no <identifiersep> contexts <identifiersep> exception ( no <identifiersep> contexts <identifiersep> exception e , freenet . node . fnp <identifiersep> packet <identifiersep> mangler . no <identifiersep> contexts <identifiersep> exception . context context ) { if ( node . get <identifiersep> uptime ( ) < seconds . to <identifiersep> millis ( <number_literal> ) ) { <LOG> return ; } <comment> <ect>
logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { <LOG> return null ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; } if ( seed . equals ( pn ) ) { logger . normal ( this , <string_literal> ) ; <ect>
if ( seed . equals ( pn ) ) { logger . normal ( this , <string_literal> ) ; return pn ; } node . peers . add <identifiersep> peer ( seed ) ; return seed ; } else { <LOG> return null ; } } <comment> <ect>
buffer <identifiersep> offset += identity . length ; <comment> <LOG> return true ; } <comment> <ect>
synchronized ( pn . jfk <identifiersep> nonces <identifiersep> sent ) { <comment> <LOG> return true ; } <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; return ; } catch ( waited <identifiersep> too <identifiersep> long <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + uid + <string_literal> ) ; return ; } catch ( peer <identifiersep> restarted <identifiersep> exception e ) { <LOG> return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { logger . error ( this , <string_literal> + uid ) ; return ; } } int status = sender . get <identifiersep> status ( ) ; if ( status == ssk <identifiersep> insert <identifiersep> sender . not <identifiersep> finished ) { <ect>
try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <LOG> return ; } <comment> <ect>
try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { <LOG> } can <identifiersep> commit = true ; finish ( status ) ; return ; } <comment> <ect>
message msg = dmt . create <identifiersep> fnp <identifiersep> rejected <identifiersep> overload ( uid , true , true , real <identifiersep> time <identifiersep> flag ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <LOG> } finish ( status ) ; return ; } } <comment> <ect>
return false ; } if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . is <identifiersep> directory ( ) ) { logger . error ( this , <string_literal> + extra <identifiersep> peer <identifiersep> data <identifiersep> peer <identifiersep> dir . get <identifiersep> path ( ) ) ; return false ; } file extra <identifiersep> peer <identifiersep> data <identifiersep> file = new file ( extra <identifiersep> peer <identifiersep> data <identifiersep> dir <identifiersep> path + file . separator + get <identifiersep> identity <identifiersep> string ( ) + file . separator + file <identifiersep> number ) ; if ( ! extra <identifiersep> peer <identifiersep> data <identifiersep> file . exists ( ) ) { <LOG> return false ; } string f = extra <identifiersep> peer <identifiersep> data <identifiersep> file . get <identifiersep> path ( ) ; file <identifiersep> output <identifiersep> stream fos ; try { fos = new file <identifiersep> output <identifiersep> stream ( f ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e2 ) { <ect>
bw . close ( ) ; } catch ( io <identifiersep> exception e ) { try { fos . close ( ) ; } catch ( io <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e , e ) ; } <LOG> return false ; } return true ; } public synchronized string get <identifiersep> private <identifiersep> darknet <identifiersep> comment <identifiersep> note ( ) { return private <identifiersep> darknet <identifiersep> comment ; } public synchronized void set <identifiersep> private <identifiersep> darknet <identifiersep> comment <identifiersep> note ( string comment ) { int local <identifiersep> file <identifiersep> number ; <ect>
logger . error ( this , err ) ; system . err . println ( err ) ; on <identifiersep> receive <identifiersep> failure ( ) ; } else { data . close ( ) ; if ( ! dest . rename <identifiersep> to ( node . client <identifiersep> core . downloads <identifiersep> dir ( ) . file ( base <identifiersep> filename ) ) ) { <LOG> } on <identifiersep> receive <identifiersep> success ( ) ; } } catch ( throwable t ) { logger . error ( this , <string_literal> + t + <string_literal> , t ) ; on <identifiersep> receive <identifiersep> failure ( ) ; } finally { remove ( ) ; <ect>
try { if ( ! transmitter . send ( ) ) { string err = <string_literal> + uid + <string_literal> + file <identifiersep> offer . this ; logger . error ( this , err ) ; system . err . println ( err ) ; } } catch ( throwable t ) { <LOG> remove ( ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; } } , <string_literal> + uid + <string_literal> + filename ) ; } public void reject ( ) { accepted <identifiersep> or <identifiersep> rejected = true ; <ect>
logger . error ( this , <string_literal> + this + <string_literal> ) ; return false ; } else return false ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> + this + <string_literal> + e , e ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> } synchronized ( this ) { if ( ark != null ) { if ( ( my <identifiersep> ark == null ) || ( ( my <identifiersep> ark != ark ) && ! my <identifiersep> ark . equals ( ark ) ) ) { my <identifiersep> ark = ark ; return true ; } } } return false ; <ect>
if ( log <identifiersep> minor ) logger . debug ( this , <string_literal> + local <identifiersep> handshake <identifiersep> ip + <string_literal> + short <identifiersep> to <identifiersep> string ( ) + <string_literal> + ignore <identifiersep> hostnames + ' ) ' ) ; local <identifiersep> handshake <identifiersep> ip . get <identifiersep> address ( false ) ; } else { <comment> <LOG> local <identifiersep> handshake <identifiersep> ip . get <identifiersep> handshake <identifiersep> address ( ) ; } } <comment> <ect>
logger . minor ( this , <string_literal> + msg + <string_literal> + cb + <string_literal> + this + <string_literal> + node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + msg . get <identifiersep> priority ( ) ) ; if ( ! is <identifiersep> connected ( ) ) { if ( cb != null ) cb . disconnected ( ) ; throw new not <identifiersep> connected <identifiersep> exception ( ) ; } if ( msg . get <identifiersep> source ( ) != null ) { <LOG> } add <identifiersep> to <identifiersep> local <identifiersep> node <identifiersep> sent <identifiersep> messages <identifiersep> to <identifiersep> statistic ( msg ) ; message <identifiersep> item item = new message <identifiersep> item ( msg , cb == null ? null : new async <identifiersep> message <identifiersep> callback [ ] { cb } , ctr ) ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; report <identifiersep> backoff <identifiersep> status ( now ) ; int max <identifiersep> size = get <identifiersep> max <identifiersep> packet <identifiersep> size ( ) ; int x = message <identifiersep> queue . queue <identifiersep> and <identifiersep> estimate <identifiersep> size ( item , max <identifiersep> size ) ; <ect>
if ( ( ! should <identifiersep> rekey ) && total <identifiersep> bytes <identifiersep> exchanged <identifiersep> with <identifiersep> current <identifiersep> tracker > fnp <identifiersep> packet <identifiersep> mangler . amount <identifiersep> of <identifiersep> bytes <identifiersep> allowed <identifiersep> before <identifiersep> we <identifiersep> rekey ) { should <identifiersep> rekey = true ; time <identifiersep> when <identifiersep> rekeying <identifiersep> should <identifiersep> occur = now ; } } if ( should <identifiersep> disconnect ) { string time = time <identifiersep> util . format <identifiersep> time ( fnp <identifiersep> packet <identifiersep> mangler . max <identifiersep> session <identifiersep> key <identifiersep> rekeying <identifiersep> delay ) ; system . err . println ( <string_literal> + this + <string_literal> + time + <string_literal> ) ; <LOG> force <identifiersep> disconnect ( ) ; } else if ( should <identifiersep> return || has <identifiersep> live <identifiersep> handshake ( now ) ) { return ; } else if ( should <identifiersep> rekey ) { start <identifiersep> rekeying ( ) ; } } @ override <ect>
if ( ! dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ) { logger . error ( this , <string_literal> + peer <identifiersep> node . this + <string_literal> + real <identifiersep> time ) ; dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed = true ; } } } public void clear <identifiersep> dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ( ) { synchronized ( routed <identifiersep> to <identifiersep> lock ) { if ( dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed ) { <LOG> dont <identifiersep> send <identifiersep> unless <identifiersep> guaranteed = false ; } } } } public void no <identifiersep> longer <identifiersep> routing <identifiersep> to ( uid <identifiersep> tag tag , boolean offered <identifiersep> key ) { if ( offered <identifiersep> key && ! ( tag instanceof request <identifiersep> tag ) ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; synchronized ( routed <identifiersep> to <identifiersep> lock ) { if ( offered <identifiersep> key ) <ect>
if ( has <identifiersep> no <identifiersep> signature ) err <identifiersep> cause += <string_literal> ; if ( is <identifiersep> ecds <identifiersep> asig <identifiersep> invalid ) err <identifiersep> cause += <string_literal> ; if ( failed ) err <identifiersep> cause += <string_literal> ; <LOG> this . is <identifiersep> signature <identifiersep> verification <identifiersep> successfull = false ; throw new reference <identifiersep> signature <identifiersep> verification <identifiersep> exception ( <string_literal> + err <identifiersep> cause ) ; } else { this . is <identifiersep> signature <identifiersep> verification <identifiersep> successfull = true ; if ( ! dont <identifiersep> keep <identifiersep> full <identifiersep> field <identifiersep> set ( ) ) this . full <identifiersep> field <identifiersep> set = fs ; <ect>
if ( key != null ) { <comment> <LOG> return null ; } } <comment> @ override public void cache <identifiersep> key ( byte [ ] hash , dsa <identifiersep> public <identifiersep> key key , boolean deep , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore , boolean for <identifiersep> ulpr , boolean write <identifiersep> local <identifiersep> to <identifiersep> datastore ) { <ect>
private abstract class my <identifiersep> callback < t > extends string <identifiersep> callback implements enumerable <identifiersep> option <identifiersep> callback { private final array <identifiersep> list < security <identifiersep> level <identifiersep> listener < t > > listeners ; my <identifiersep> callback ( ) { listeners = new array <identifiersep> list < security <identifiersep> level <identifiersep> listener < t > > ( ) ; } public void add <identifiersep> listener ( security <identifiersep> level <identifiersep> listener < t > listener ) { if ( listeners . contains ( listener ) ) { <LOG> return ; } listeners . add ( listener ) ; } @ override public void set ( string val ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception , node <identifiersep> need <identifiersep> restart <identifiersep> exception { t old <identifiersep> level = get <identifiersep> value ( ) ; set <identifiersep> value ( val ) ; <ect>
read <identifiersep> bookmarks ( main <identifiersep> category , sfs ) ; } else { logger . normal ( this , <string_literal> + file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( backup <identifiersep> bookmarks <identifiersep> file ) ) ; <comment> <LOG> } } <comment> <ect>
try { fos = new file <identifiersep> output <identifiersep> stream ( backup <identifiersep> bookmarks <identifiersep> file ) ; sfs . write <identifiersep> to <identifiersep> big <identifiersep> buffer ( fos ) ; fos . close ( ) ; fos = null ; if ( ! file <identifiersep> util . rename <identifiersep> to ( backup <identifiersep> bookmarks <identifiersep> file , bookmarks <identifiersep> file ) ) <LOG> } catch ( io <identifiersep> exception ioe ) { logger . error ( this , <string_literal> + ioe . get <identifiersep> message ( ) , ioe ) ; } finally { closer . close ( fos ) ; synchronized ( bookmarks ) { is <identifiersep> saving <identifiersep> bookmarks = false ; <ect>
simple <identifiersep> field <identifiersep> set subset = sfs . get <identifiersep> subset ( bookmark <identifiersep> category . name + i ) ; bookmark <identifiersep> category current <identifiersep> category = new bookmark <identifiersep> category ( subset ) ; category . add <identifiersep> bookmark ( current <identifiersep> category ) ; string name = ( is <identifiersep> root ? <string_literal> : ( prefix + category . name + ' / ' ) ) ;  <identifiersep> inner <identifiersep> read <identifiersep> bookmarks ( name , current <identifiersep> category , subset . get <identifiersep> subset ( <string_literal> ) ) ; } } catch ( fs <identifiersep> parse <identifiersep> exception e ) { <LOG> has <identifiersep> been <identifiersep> parsed <identifiersep> without <identifiersep> any <identifiersep> problem = false ; } } if ( has <identifiersep> been <identifiersep> parsed <identifiersep> without <identifiersep> any <identifiersep> problem ) store <identifiersep> bookmarks ( ) ; } public simple <identifiersep> field <identifiersep> set to <identifiersep> simple <identifiersep> field <identifiersep> set ( ) { simple <identifiersep> field <identifiersep> set sfs = new simple <identifiersep> field <identifiersep> set ( true ) ; sfs . put ( <string_literal> , 1 ) ; <ect>
try { client <identifiersep> put = new client <identifiersep> put ( fcp . get <identifiersep> global <identifiersep> forever <identifiersep> client ( ) , insert <identifiersep> uri , identifier , integer . max <identifiersep> value , null , request <identifiersep> starter . bulk <identifiersep> splitfile <identifiersep> priority <identifiersep> class , persistence . forever , null , false , ! compress , - 1 , upload <identifiersep> from . direct , null , file . get <identifiersep> content <identifiersep> type ( ) , copied <identifiersep> bucket , null , fnam , false , false , node . fork <identifiersep> on <identifiersep> cacheable <identifiersep> default , high <identifiersep> level <identifiersep> simple <identifiersep> client <identifiersep> impl . extra <identifiersep> inserts <identifiersep> single <identifiersep> block , high <identifiersep> level <identifiersep> simple <identifiersep> client <identifiersep> impl . extra <identifiersep> inserts <identifiersep> splitfile <identifiersep> header , false , cmode , override <identifiersep> splitfile <identifiersep> key , false , fcp . core ) ; if ( client <identifiersep> put != null ) try { fcp . start <identifiersep> blocking ( client <identifiersep> put , context ) ; } catch ( identifier <identifiersep> collision <identifiersep> exception e ) { <LOG> write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return false ; } write <identifiersep> permanent <identifiersep> redirect ( ctx , <string_literal> , path ( ) ) ; return true ; } catch ( identifier <identifiersep> collision <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; <ect>
core . node . change <identifiersep> master <identifiersep> password ( pass , <string_literal> , true ) ; } catch ( io <identifiersep> exception e ) { if ( ! core . node . get <identifiersep> master <identifiersep> password <identifiersep> file ( ) . exists ( ) ) { <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new io <identifiersep> exception ( <string_literal> , e ) ; } } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { return prompt <identifiersep> password ( new <identifiersep> threat <identifiersep> level , password <identifiersep> prompt . decrypt <identifiersep> wrong ) ; } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e ) { return error <identifiersep> corrupt ; <ect>
<comment> private string prompt <identifiersep> password ( security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level new <identifiersep> threat <identifiersep> level , password <identifiersep> prompt type ) { if ( type == password <identifiersep> prompt . decrypt <identifiersep> wrong ) { <LOG> } string <identifiersep> builder destination = new string <identifiersep> builder ( first <identifiersep> time <identifiersep> wizard <identifiersep> toadlet . wizard <identifiersep> step . security <identifiersep> physical + <string_literal> ) . append ( new <identifiersep> threat <identifiersep> level . name ( ) ) . append ( <string_literal> ) . append ( type . name ( ) ) ; return destination . to <identifiersep> string ( ) ; } public void set <identifiersep> threat <identifiersep> level ( security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level new <identifiersep> threat <identifiersep> level , security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level old <identifiersep> threat <identifiersep> level ) throws io <identifiersep> exception { core . node . security <identifiersep> levels . set <identifiersep> threat <identifiersep> level ( new <identifiersep> threat <identifiersep> level ) ; core . store <identifiersep> config ( ) ; <ect>
try { core . node . late <identifiersep> setup <identifiersep> database ( null ) ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { <comment> <LOG> } } private void add <identifiersep> back <identifiersep> to <identifiersep> physical <identifiersep> seclevels <identifiersep> button ( html <identifiersep> node form ) { form . add <identifiersep> child ( <string_literal> ) . add <identifiersep> child ( <string_literal> , new string [ ] { <string_literal> , <string_literal> , <string_literal> } , new string [ ] { <string_literal> , <string_literal> , wizard <identifiersep> l10n . l10n ( <string_literal> ) } ) ; } } <ect>
codes [ i ] = ( short ) - 1 ; } ips [ i ] = ( int ) ip ; } raf . close ( ) ; return new cache ( codes , ips ) ; } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <comment> <LOG> } catch ( io <identifiersep> exception e ) { logger . error ( this , e . get <identifiersep> message ( ) ) ; } catch ( ip <identifiersep> converter <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; <comment> <ect>
running <identifiersep> persistent <identifiersep> requests . remove ( r ) ; removed <identifiersep> from <identifiersep> running = true ; logger . error ( this , <string_literal> + r + <string_literal> + r . get <identifiersep> identifier ( ) + <string_literal> ) ; break ; } } } if ( req == null ) return false ; } else if ( ! ( ( removed <identifiersep> from <identifiersep> running = running <identifiersep> persistent <identifiersep> requests . remove ( req ) ) || completed <identifiersep> unacked <identifiersep> requests . remove ( req ) ) ) { <LOG> return false ; } client <identifiersep> requests <identifiersep> by <identifiersep> identifier . remove ( identifier ) ; } if ( kill ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + req ) ; req . cancel ( context ) ; } req . request <identifiersep> was <identifiersep> removed ( context ) ; <ect>
add <identifiersep> persistent <identifiersep> requests ( reqs , only <identifiersep> forever ) ; for ( client <identifiersep> request req : reqs ) { try { status . add ( req . get <identifiersep> status ( ) ) ; } catch ( throwable t ) { <comment> <LOG> <comment> <ect>
public request <identifiersep> status <identifiersep> cache get <identifiersep> request <identifiersep> status <identifiersep> cache ( ) { return status <identifiersep> cache ; } public void update <identifiersep> request <identifiersep> status <identifiersep> cache ( ) { update <identifiersep> request <identifiersep> status <identifiersep> cache ( status <identifiersep> cache ) ; } private void update <identifiersep> request <identifiersep> status <identifiersep> cache ( request <identifiersep> status <identifiersep> cache cache ) { if ( persistence == persistence . forever ) { <LOG> array <identifiersep> list < request <identifiersep> status > statuses = new array <identifiersep> list < request <identifiersep> status > ( ) ; add <identifiersep> persistent <identifiersep> request <identifiersep> status ( statuses , true ) ; for ( request <identifiersep> status status : statuses ) { if ( status instanceof download <identifiersep> request <identifiersep> status ) cache . add <identifiersep> download ( ( download <identifiersep> request <identifiersep> status ) status ) ; else <ect>
try { if ( ssl ) { temp <identifiersep> network <identifiersep> interface = ssl <identifiersep> network <identifiersep> interface . create ( port , bind <identifiersep> to , allowed <identifiersep> hosts , node . executor , true ) ; } else { temp <identifiersep> network <identifiersep> interface = network <identifiersep> interface . create ( port , bind <identifiersep> to , allowed <identifiersep> hosts , node . executor , true ) ; } } catch ( io <identifiersep> exception be ) { <LOG> system . out . println ( <string_literal> + bind <identifiersep> to + ' : ' + port + <string_literal> ) ; } this . network <identifiersep> interface = temp <identifiersep> network <identifiersep> interface ; } public void maybe <identifiersep> start ( ) { if ( this . enabled ) { maybe <identifiersep> get <identifiersep> network <identifiersep> interface ( ) ; logger . normal ( this , <string_literal> + bind <identifiersep> to + ' : ' + port + ' . ' ) ; <ect>
data <identifiersep> input <identifiersep> stream inner <identifiersep> dis = new data <identifiersep> input <identifiersep> stream ( checker . checksum <identifiersep> reader <identifiersep> with <identifiersep> length ( dis , context . temp <identifiersep> bucket <identifiersep> factory , <number_literal> ) ) ; try { if ( getter . resume <identifiersep> from <identifiersep> trivial <identifiersep> progress ( inner <identifiersep> dis , context ) ) { read <identifiersep> transient <identifiersep> progress <identifiersep> fields ( inner <identifiersep> dis ) ; } } catch ( io <identifiersep> exception e ) { <LOG> } finally { inner <identifiersep> dis . close ( ) ; } } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { logger . error ( this , <string_literal> ) ; } } if ( compat <identifiersep> mode == null ) compat <identifiersep> mode = new compatibility <identifiersep> analyser ( ) ; <ect>
<comment> <LOG> } if ( persistence == persistence . connection ) { free <identifiersep> data ( ) ; } finish ( ) ; try <identifiersep> send <identifiersep> final <identifiersep> message ( null , null ) ; if ( client != null ) client . notify <identifiersep> success ( this ) ; <ect>
return generated <identifiersep> uri ; } @ override public void on <identifiersep> generated <identifiersep> metadata ( bucket metadata , base <identifiersep> client <identifiersep> putter state ) { boolean delete = false ; synchronized ( this ) { if ( generated <identifiersep> uri != null ) <LOG> if ( generated <identifiersep> metadata != null ) { logger . error ( this , <string_literal> + state + <string_literal> + this ) ; delete = true ; } else { generated <identifiersep> metadata = metadata ; } } if ( delete ) { <ect>
synchronized ( this ) { if ( succeeded ) { msg = new put <identifiersep> successful <identifiersep> message ( identifier , global , generated <identifiersep> uri , startup <identifiersep> time , completion <identifiersep> time ) ; } else { msg = put <identifiersep> failed <identifiersep> message ; } } if ( msg == null ) { <LOG> } else { if ( persistence == persistence . connection && handler == null ) handler = orig <identifiersep> handler . output <identifiersep> handler ; if ( handler != null ) handler . queue ( fcp <identifiersep> message . with <identifiersep> list <identifiersep> request <identifiersep> identifier ( msg , list <identifiersep> request <identifiersep> identifier ) ) ; else <ect>
system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; system . err . println ( <string_literal> ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; <comment> <ect>
system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; system . err . println ( <string_literal> ) ; <comment> <LOG> system . err . println ( <string_literal> ) ; <comment> <ect>
file backup = get <identifiersep> plugin <identifiersep> store <identifiersep> file ( store <identifiersep> identifier , is <identifiersep> encrypted , true ) ; file main = get <identifiersep> plugin <identifiersep> store <identifiersep> file ( store <identifiersep> identifier , is <identifiersep> encrypted , false ) ; if ( backup . exists ( ) && main . exists ( ) ) { file <identifiersep> util . secure <identifiersep> delete ( backup ) ; } if ( main . exists ( ) ) { if ( ! main . rename <identifiersep> to ( backup ) ) <LOG> } write <identifiersep> plugin <identifiersep> store <identifiersep> inner ( store <identifiersep> identifier , store , is <identifiersep> encrypted , false ) ; file f = get <identifiersep> plugin <identifiersep> store <identifiersep> file ( store <identifiersep> identifier , ! is <identifiersep> encrypted , true ) ; if ( f . exists ( ) ) { file <identifiersep> util . secure <identifiersep> delete ( f ) ; } f = get <identifiersep> plugin <identifiersep> store <identifiersep> file ( store <identifiersep> identifier , ! is <identifiersep> encrypted , false ) ; if ( f . exists ( ) ) { <ect>
final string client <identifiersep> identifier = handler . connection <identifiersep> identifier ; replysender = new plugin <identifiersep> reply <identifiersep> sender <identifiersep> fcp ( handler , pluginname2 , client <identifiersep> identifier , client <identifiersep> side <identifiersep> identifier ) ; } protected weak <identifiersep> reference < fred <identifiersep> plugin <identifiersep> fcp > find <identifiersep> plugin ( string pluginname2 ) throws plugin <identifiersep> not <identifiersep> found <identifiersep> exception { logger . normal ( this , <string_literal> + pluginname2 ) ; fred <identifiersep> plugin <identifiersep> fcp plug = node . plugin <identifiersep> manager . get <identifiersep> fcp <identifiersep> plugin ( pluginname2 ) ; if ( plug == null ) { <LOG> throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( ) ; } logger . normal ( this , <string_literal> + pluginname2 ) ; return new weak <identifiersep> reference < fred <identifiersep> plugin <identifiersep> fcp > ( plug ) ; } public void send ( final simple <identifiersep> field <identifiersep> set plugparams , final bucket data2 ) { node . executor . execute ( new runnable ( ) { @ override <ect>
if ( plugin <identifiersep> main <identifiersep> class <identifiersep> name == null ) { logger . error ( this , <string_literal> ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } if ( this . is <identifiersep> plugin <identifiersep> loaded ( plugin <identifiersep> main <identifiersep> class <identifiersep> name ) ) { <LOG> return null ; } } catch ( jar <identifiersep> exception je1 ) { logger . error ( this , <string_literal> , je1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , je1 ) ; <ect>
} catch ( jar <identifiersep> exception je1 ) { logger . error ( this , <string_literal> , je1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , je1 ) ; } catch ( zip <identifiersep> exception ze1 ) { <LOG> plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ze1 ) ; } catch ( io <identifiersep> exception ioe1 ) { logger . error ( this , <string_literal> , ioe1 ) ; plugin <identifiersep> file . delete ( ) ; <ect>
closer . close ( plugin <identifiersep> jar <identifiersep> file ) ; } try { jar <identifiersep> class <identifiersep> loader jar <identifiersep> class <identifiersep> loader = new jar <identifiersep> class <identifiersep> loader ( plugin <identifiersep> file ) ; class < ? > plugin <identifiersep> main <identifiersep> class = jar <identifiersep> class <identifiersep> loader . load <identifiersep> class ( plugin <identifiersep> main <identifiersep> class <identifiersep> name ) ; object object = plugin <identifiersep> main <identifiersep> class . new <identifiersep> instance ( ) ; if ( ! ( object instanceof fred <identifiersep> plugin ) ) { <LOG> plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } if ( pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet ) { system . err . println ( <string_literal> + name ) ; <ect>
long ver = - 1 ; if ( min <identifiersep> ver != - 1 ) { if ( object instanceof fred <identifiersep> plugin <identifiersep> real <identifiersep> versioned ) { ver = ( ( fred <identifiersep> plugin <identifiersep> real <identifiersep> versioned ) object ) . get <identifiersep> real <identifiersep> version ( ) ; } } <comment> <LOG> logger . error ( this , <string_literal> + name + <string_literal> + min <identifiersep> ver + <string_literal> + ver ) ; <comment> <ect>
this . expected <identifiersep> size = expected <identifiersep> size ; this . expected <identifiersep> mime <identifiersep> type = expected <identifiersep> mime <identifiersep> type ; error <identifiersep> codes = null ; init <identifiersep> cause ( t ) ; new <identifiersep> uri = null ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( long expected <identifiersep> size , data <identifiersep> filter <identifiersep> exception t , string expected <identifiersep> mime <identifiersep> type ) { super ( get <identifiersep> message ( fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> validation <identifiersep> failed ) + <string_literal> + node <identifiersep> l10n . get <identifiersep> base ( ) . get <identifiersep> string ( <string_literal> ) + <string_literal> + t . get <identifiersep> message ( ) ) ; extra <identifiersep> message = t . get <identifiersep> message ( ) ; this . mode = fetch <identifiersep> exception <identifiersep> mode . content <identifiersep> validation <identifiersep> failed ; <ect>
logger . error ( this , <string_literal> + this ) ; else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes ) { super ( get <identifiersep> message ( mode ) ) ; if ( error <identifiersep> codes . is <identifiersep> empty ( ) ) { <LOG> } extra <identifiersep> message = null ; this . mode = mode ; this . error <identifiersep> codes = error <identifiersep> codes ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <ect>
logger . error ( this , <string_literal> + this ) ; else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes , string msg ) { super ( get <identifiersep> message ( mode ) + <string_literal> + msg ) ; if ( error <identifiersep> codes . is <identifiersep> empty ( ) ) { <LOG> } extra <identifiersep> message = msg ; this . mode = mode ; this . error <identifiersep> codes = error <identifiersep> codes ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <ect>
extra <identifiersep> message = msg ; error <identifiersep> codes = null ; this . mode = mode ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) <LOG> else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , freenet <identifiersep> uri new <identifiersep> uri ) { super ( get <identifiersep> message ( mode ) ) ; extra <identifiersep> message = null ; this . mode = mode ; <ect>
context . get <identifiersep> chk <identifiersep> fetch <identifiersep> scheduler ( real <identifiersep> time <identifiersep> flag ) . fetching <identifiersep> keys ( ) , context . ticker , context . memory <identifiersep> limited <identifiersep> job <identifiersep> runner , new crc <identifiersep> checksum <identifiersep> checker ( ) , context . job <identifiersep> runner . new <identifiersep> salt ( ) , salter , resumed , callback <identifiersep> complete <identifiersep> via <identifiersep> truncation != null ) ; } catch ( resume <identifiersep> failed <identifiersep> exception e ) { raf . free ( ) ; <LOG> throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( io <identifiersep> exception e ) { raf . free ( ) ; logger . error ( this , <string_literal> + e + <string_literal> + raf , e ) ; throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { <ect>
} catch ( io <identifiersep> exception e ) { raf . free ( ) ; logger . error ( this , <string_literal> + e + <string_literal> + raf , e ) ; throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { raf . free ( ) ; <LOG> throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e , e ) ; } catch ( fetch <identifiersep> exception e ) { raf . free ( ) ; throw e ; } synchronized ( this ) { last <identifiersep> notified <identifiersep> store <identifiersep> fetch = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
if ( o instanceof hash <identifiersep> map ) { hash <identifiersep> map < string , object > sub <identifiersep> map = ( hash <identifiersep> map < string , object > ) o ; builder . push <identifiersep> current <identifiersep> dir ( ) ; builder . make <identifiersep> sub <identifiersep> dir <identifiersep> cd ( name ) ; make <identifiersep> put <identifiersep> handlers ( builder , sub <identifiersep> map , default <identifiersep> name ) ; builder . pop <identifiersep> current <identifiersep> dir ( ) ; <LOG> } else { manifest <identifiersep> element element = ( manifest <identifiersep> element ) o ; builder . add <identifiersep> element ( name , element , name . equals ( default <identifiersep> name ) ) ; } } } @ override public void inner <identifiersep> on <identifiersep> resume ( client <identifiersep> context context ) throws resume <identifiersep> failed <identifiersep> exception { super . inner <identifiersep> on <identifiersep> resume ( context ) ; <ect>
boolean shutdown = false ; checkpoint <identifiersep> lock lock = null ; try { lock = parent . job <identifiersep> runner . lock ( ) ; inner <identifiersep> decode ( chunk ) ; } catch ( io <identifiersep> exception e ) { <LOG> parent . fail <identifiersep> on <identifiersep> disk <identifiersep> error ( e ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <ect>
synchronized ( this ) { if ( finished ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; return ; } finished = true ; } if ( f != null ) <LOG> } @ override public long get <identifiersep> token ( ) { return token ; } @ override public void schedule ( client <identifiersep> context context ) { start ( context . usk <identifiersep> manager , context ) ; <ect>
return polling <identifiersep> priority <identifiersep> progress ; } @ override public void on <identifiersep> found <identifiersep> edition ( final long l , final usk key , client <identifiersep> context context , final boolean metadata , final short codec , final byte [ ] data , final boolean new <identifiersep> known <identifiersep> good , final boolean new <identifiersep> slot <identifiersep> too ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + l + <string_literal> + this ) ; synchronized ( this ) { if ( fetcher == null ) { <LOG> } if ( finished ) { logger . error ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; return ; } finished = true ; fetcher = null ; } if ( persistent ) { <ect>
this . errors = new failure <identifiersep> code <identifiersep> tracker ( false ) ; this . checksum <identifiersep> checker = checker ; this . checksum <identifiersep> length = checker . checksum <identifiersep> length ( ) ; this . persistent = persistent ; this . complete <identifiersep> via <identifiersep> truncation = ( storage <identifiersep> file != null ) ; if ( decompressors . size ( ) > 1 ) { <LOG> } this . client <identifiersep> metadata = client <identifiersep> metadata == null ? new client <identifiersep> metadata ( ) : client <identifiersep> metadata . clone ( ) ; <comment> <ect>
segment . read <identifiersep> metadata ( ) ; if ( segment . has <identifiersep> failed ( ) ) { raf . close ( ) ; raf . free ( ) ; <comment> <LOG> needs <identifiersep> decode = true ; } if ( segment . needs <identifiersep> decode ( ) ) needs <identifiersep> decode = true ; if ( needs <identifiersep> decode ) { if ( segments <identifiersep> to <identifiersep> try <identifiersep> decode == null ) segments <identifiersep> to <identifiersep> try <identifiersep> decode = new array <identifiersep> list < split <identifiersep> file <identifiersep> fetcher <identifiersep> segment <identifiersep> storage > ( ) ; <ect>
failed ++ ; break ; } } catch ( throwable t ) { if ( partial . status == request <identifiersep> load <identifiersep> status . loaded ) failed <identifiersep> serialize = true ; failed ++ ; <LOG> logger . error ( this , <string_literal> + req + <string_literal> + t , t ) ; try { req . cancel ( context ) ; } catch ( throwable t1 ) { logger . error ( this , <string_literal> + req + <string_literal> + t1 , t1 ) ; } } } if ( success > 0 ) <ect>
failed ++ ; system . err . println ( <string_literal> + req + <string_literal> ) ; logger . error ( this , <string_literal> + req + <string_literal> + t , t ) ; try { req . cancel ( context ) ; } catch ( throwable t1 ) { <LOG> } } } if ( success > 0 ) system . out . println ( <string_literal> + success + <string_literal> ) ; if ( restored <identifiersep> fully > 0 ) system . out . println ( <string_literal> + restored <identifiersep> fully + <string_literal> ) ; if ( restored <identifiersep> restarted > 0 ) system . out . println ( <string_literal> + restored <identifiersep> restarted + <string_literal> ) ; <ect>
req . cancel ( context ) ; } catch ( throwable t1 ) { logger . error ( this , <string_literal> + req + <string_literal> + t1 , t1 ) ; } } } if ( success > 0 ) system . out . println ( <string_literal> + success + <string_literal> ) ; if ( restored <identifiersep> fully > 0 ) <LOG> if ( restored <identifiersep> restarted > 0 ) system . out . println ( <string_literal> + restored <identifiersep> restarted + <string_literal> ) ; if ( failed > 0 ) system . err . println ( <string_literal> + failed + <string_literal> ) ; return failed <identifiersep> serialize ; } else { <ect>
system . out . println ( <string_literal> + success + <string_literal> ) ; if ( restored <identifiersep> fully > 0 ) system . out . println ( <string_literal> + restored <identifiersep> fully + <string_literal> ) ; if ( restored <identifiersep> restarted > 0 ) system . out . println ( <string_literal> + restored <identifiersep> restarted + <string_literal> ) ; if ( failed > 0 ) <LOG> return failed <identifiersep> serialize ; } else { <comment> <ect>
@ override public void on <identifiersep> found <identifiersep> edition ( long l , usk key , client <identifiersep> context context , boolean metadata , short codec , byte [ ] data , boolean new <identifiersep> known <identifiersep> good , boolean new <identifiersep> slot <identifiersep> too ) { if ( l < 0 ) { logger . error ( this , <string_literal> + l + <string_literal> + key + <string_literal> ) ; return ; } if ( l < orig <identifiersep> usk . suggested <identifiersep> edition ) { <LOG> return ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + l + <string_literal> + this + <string_literal> ) ; <comment> <ect>
( single <identifiersep> file <identifiersep> fetcher ) single <identifiersep> file <identifiersep> fetcher . create ( this , this , uri , ctx , new archive <identifiersep> context ( ctx . max <identifiersep> temp <identifiersep> length , ctx . max <identifiersep> archive <identifiersep> levels ) , ctx . max <identifiersep> non <identifiersep> splitfile <identifiersep> retries , 0 , true , l , true , false , context , real <identifiersep> time <identifiersep> flag , false ) ; getter . schedule ( context ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; } catch ( fetch <identifiersep> exception e ) { <LOG> } } @ override public void on <identifiersep> success ( stream <identifiersep> generator stream <identifiersep> generator , client <identifiersep> metadata client <identifiersep> metadata , list < ? extends compressor > decompressors , final client <identifiersep> get <identifiersep> state state , client <identifiersep> context context ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + state + <string_literal> + stream <identifiersep> generator . size ( ) + <string_literal> + client <identifiersep> metadata . get <identifiersep> mime <identifiersep> type ( ) ) ; decompressor <identifiersep> thread <identifiersep> manager decompressor <identifiersep> manager = null ; output <identifiersep> stream output = null ; <ect>
return ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) , state , context ) ; return ; } catch ( throwable t ) { <LOG> on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; return ; } piped <identifiersep> input <identifiersep> stream pipe <identifiersep> in = null ; piped <identifiersep> output <identifiersep> stream pipe <identifiersep> out = null ; try { output = final <identifiersep> result . get <identifiersep> output <identifiersep> stream ( ) ; <ect>
<comment> <LOG> on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; return ; } finally { closer . close ( output ) ; closer . close ( pipe <identifiersep> out ) ; } final fetch <identifiersep> result result = new fetch <identifiersep> result ( client <identifiersep> metadata , final <identifiersep> result ) ; <ect>
dbr <identifiersep> attempt [ ] atts ; usk <identifiersep> manager . on <identifiersep> finished ( this ) ; sendable <identifiersep> get store <identifiersep> checker ; bucket data ; synchronized ( this ) { if ( cancelled ) logger . error ( this , <string_literal> + this ) ; <LOG> cancelled = true ; attempts = running <identifiersep> attempts . values ( ) . to <identifiersep> array ( new usk <identifiersep> attempt [ running <identifiersep> attempts . size ( ) ] ) ; polling = polling <identifiersep> attempts . values ( ) . to <identifiersep> array ( new usk <identifiersep> attempt [ polling <identifiersep> attempts . size ( ) ] ) ; atts = dbr <identifiersep> attempts . to <identifiersep> array ( new dbr <identifiersep> attempt [ dbr <identifiersep> attempts . size ( ) ] ) ; attempts <identifiersep> to <identifiersep> start . clear ( ) ; running <identifiersep> attempts . clear ( ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + normal <identifiersep> poll <identifiersep> priority + <string_literal> + progress <identifiersep> poll <identifiersep> priority + <string_literal> + this + <string_literal> + orig <identifiersep> usk ) ; return ; } for ( usk <identifiersep> callback cb : local <identifiersep> callbacks ) { short prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; if ( prio < normal <identifiersep> prio ) normal <identifiersep> prio = prio ; <LOG> prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) ; if ( prio < progress <identifiersep> prio ) progress <identifiersep> prio = prio ; } for ( usk <identifiersep> fetcher <identifiersep> callback cb : fetcher <identifiersep> callbacks ) { short prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; if ( prio < normal <identifiersep> prio ) normal <identifiersep> prio = prio ; <ect>
prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) ; if ( prio < progress <identifiersep> prio ) progress <identifiersep> prio = prio ; } for ( usk <identifiersep> fetcher <identifiersep> callback cb : fetcher <identifiersep> callbacks ) { short prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; if ( prio < normal <identifiersep> prio ) normal <identifiersep> prio = prio ; <LOG> prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) ; if ( prio < progress <identifiersep> prio ) progress <identifiersep> prio = prio ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + normal <identifiersep> prio + <string_literal> + progress <identifiersep> prio + <string_literal> + this + <string_literal> + orig <identifiersep> usk ) ; synchronized ( this ) { normal <identifiersep> poll <identifiersep> priority = normal <identifiersep> prio ; progress <identifiersep> poll <identifiersep> priority = progress <identifiersep> prio ; <ect>
running <identifiersep> store <identifiersep> checker = new store <identifiersep> checker <identifiersep> getter ( parent , checker ) ; } try { context . get <identifiersep> ssk <identifiersep> fetch <identifiersep> scheduler ( real <identifiersep> time <identifiersep> flag ) . register ( null , new sendable <identifiersep> get [ ] { running <identifiersep> store <identifiersep> checker } , false , null , false ) ; } catch ( throwable t ) { synchronized ( this ) { running <identifiersep> store <identifiersep> checker = null ; } <LOG> try { running <identifiersep> store <identifiersep> checker . unregister ( context , progress <identifiersep> poll <identifiersep> priority ) ; } catch ( throwable ignored ) { <comment> <ect>
logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = e ; } catch ( throwable t ) { <LOG> ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) ; } finally { closer . close ( data <identifiersep> input ) ; closer . close ( data <identifiersep> output ) ; closer . close ( output ) ; } if ( ex != null ) { <ect>
expected <identifiersep> size = length ; } result = new fetch <identifiersep> result ( metadata , return <identifiersep> bucket ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <LOG> ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; } catch ( fetch <identifiersep> exception e ) { <comment> <ect>
ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; } catch ( fetch <identifiersep> exception e ) { <comment> <LOG> ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; } if ( ex != null ) { on <identifiersep> failure ( ex , state , context , true ) ; if ( raf != null ) try { raf . close ( ) ; <ect>
return ; } } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + block . get <identifiersep> client <identifiersep> key ( ) . get <identifiersep> uri ( ) + <string_literal> + this , new exception ( <string_literal> ) ) ; try { binary <identifiersep> blob <identifiersep> writer . add <identifiersep> key ( block , context ) ; } catch ( io <identifiersep> exception e ) { <LOG> on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + e ) , null , context ) ; } catch ( binary <identifiersep> blob <identifiersep> already <identifiersep> closed <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , <string_literal> + e ) , null , context ) ; } } <comment> protected boolean collecting <identifiersep> binary <identifiersep> blob ( ) { <ect>
cm = new client <identifiersep> metadata ( mime <identifiersep> type ) ; metadata m ; if ( element . target <identifiersep> uri != null ) { <comment> <LOG> container <identifiersep> items . add ( new container <identifiersep> element ( element . get <identifiersep> data ( ) , archive <identifiersep> prefix + name ) ) ; m = new metadata ( document <identifiersep> type . archive <identifiersep> internal <identifiersep> redirect , null , null , archive <identifiersep> prefix + element . full <identifiersep> name , cm ) ; } smc . add <identifiersep> item ( name , m ) ; } } return smc . get <identifiersep> metadata ( ) ; } private transient boolean resumed = false ; @ override <ect>
} catch ( key <identifiersep> encode <identifiersep> exception e ) { logger . error ( single <identifiersep> block <identifiersep> inserter . class , <string_literal> + e , e ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . invalid <identifiersep> uri , e , null ) ; } catch ( io <identifiersep> exception e ) { <LOG> throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; } catch ( invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; } } protected static client <identifiersep> key <identifiersep> block inner <identifiersep> encode ( random <identifiersep> source random , freenet <identifiersep> uri uri , bucket source <identifiersep> data , boolean is <identifiersep> metadata , short compression <identifiersep> codec , int source <identifiersep> length , string compressor <identifiersep> descriptor , boolean pre1254 , byte crypto <identifiersep> algorithm , byte [ ] crypto <identifiersep> key ) throws insert <identifiersep> exception , chk <identifiersep> encode <identifiersep> exception , io <identifiersep> exception , ssk <identifiersep> encode <identifiersep> exception , malformed <identifiersep> url <identifiersep> exception , invalid <identifiersep> compression <identifiersep> codec <identifiersep> exception { string uri <identifiersep> type = uri . get <identifiersep> key <identifiersep> type ( ) ; if ( uri <identifiersep> type . equals ( <string_literal> ) ) { <ect>
errors . inc ( insert <identifiersep> exception <identifiersep> mode . route <identifiersep> not <identifiersep> found ) ; break ; case low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> really <identifiersep> not <identifiersep> found : errors . inc ( insert <identifiersep> exception <identifiersep> mode . route <identifiersep> really <identifiersep> not <identifiersep> found ) ; break ; default : <LOG> errors . inc ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) ; } if ( e . code == low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> not <identifiersep> found || e . code == low <identifiersep> level <identifiersep> put <identifiersep> exception . route <identifiersep> really <identifiersep> not <identifiersep> found ) { consecutive <identifiersep> rn <identifiersep> fs ++ ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + consecutive <identifiersep> rn <identifiersep> fs + <string_literal> + ctx . consecutive <identifiersep> rn <identifiersep> fs <identifiersep> count <identifiersep> as <identifiersep> success ) ; <comment> <ect>
finished = true ; if ( resulting <identifiersep> key == null ) { should <identifiersep> send <identifiersep> key = true ; resulting <identifiersep> key = key ; } else { if ( ! resulting <identifiersep> key . equals ( key ) ) <LOG> } } if ( free <identifiersep> data ) { source <identifiersep> data . free ( ) ; source <identifiersep> data = null ; } parent . completed <identifiersep> block ( false , context ) ; unregister ( context , get <identifiersep> priority <identifiersep> class ( ) ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + cb ) ; <ect>
try { on <identifiersep> compressed <identifiersep> inner ( output , context ) ; } catch ( insert <identifiersep> exception e ) { cb . on <identifiersep> failure ( e , single <identifiersep> file <identifiersep> inserter . this , context ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; <LOG> t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
hash <identifiersep> this <identifiersep> layer <identifiersep> only = hash <identifiersep> result . get ( hashes , hash <identifiersep> type . sha256 ) ; hashes = null ; <comment> <LOG> } } hash <identifiersep> result [ ] client <identifiersep> hashes = hashes ; if ( persistent ) client <identifiersep> hashes = hash <identifiersep> result . copy ( hashes ) ; ctx . event <identifiersep> producer . produce <identifiersep> event ( new expected <identifiersep> hashes <identifiersep> event ( client <identifiersep> hashes ) , context ) ; <comment> <ect>
metadata <identifiersep> bucket = meta . to <identifiersep> bucket ( context . get <identifiersep> bucket <identifiersep> factory ( persistent ) ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { <comment> <LOG> throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e . to <identifiersep> string ( ) , null ) ; } client <identifiersep> put <identifiersep> state meta <identifiersep> putter = create <identifiersep> inserter ( parent , metadata <identifiersep> bucket , ( short ) - 1 , ctx , mcb , true , ( int ) orig <identifiersep> size , - 1 , true , context , true , false ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + meta <identifiersep> putter + <string_literal> + this ) ; mcb . add <identifiersep> uri <identifiersep> generator ( meta <identifiersep> putter ) ; mcb . add ( data <identifiersep> putter ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + meta <identifiersep> insert <identifiersep> success + <string_literal> + meta <identifiersep> insert <identifiersep> started ) ; } } else if ( state == metadata <identifiersep> putter ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this + <string_literal> + state ) ; meta <identifiersep> insert <identifiersep> success = true ; metadata <identifiersep> putter = null ; } else { <LOG> } if ( split <identifiersep> insert <identifiersep> success && meta <identifiersep> insert <identifiersep> success ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; finished = true ; if ( free <identifiersep> data ) block . free ( ) ; else { <ect>
meta <identifiersep> put <identifiersep> handler ph = new meta <identifiersep> put <identifiersep> handler ( this , null , m , context . get <identifiersep> bucket <identifiersep> factory ( persistent ( ) ) ) ; ph . start ( context ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e1 ) { resolve ( e1 , context ) ; } } } private void try <identifiersep> complete ( client <identifiersep> context context ) { <comment> <LOG> synchronized ( this ) { if ( finished || cancelled ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( finished ? <string_literal> : <string_literal> ) ) ; return ; } if ( ! running <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + ( finished ? <string_literal> : <string_literal> ) ) ; return ; } if ( ! running <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; } if ( ! container <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { <LOG> return ; } if ( container <identifiersep> mode ) { if ( root <identifiersep> container <identifiersep> put <identifiersep> handler != null ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; } } else { <ect>
if ( container <identifiersep> mode ) { if ( root <identifiersep> container <identifiersep> put <identifiersep> handler != null ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; } } else { if ( root <identifiersep> meta <identifiersep> put <identifiersep> handler != null ) { <LOG> return ; } } finished = true ; } complete ( context ) ; } private void complete ( client <identifiersep> context context ) { <comment> <ect>
if ( container <identifiersep> handle2 == null ) throw new null <identifiersep> pointer <identifiersep> exception ( ) ; <comment> <LOG> if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + per <identifiersep> container <identifiersep> put <identifiersep> handlers <identifiersep> waiting <identifiersep> for <identifiersep> metadata . get ( container <identifiersep> handle2 ) . size ( ) + <string_literal> + container <identifiersep> handle2 ) ; } } <comment> <ect>
case state1 : switch ( c ) { case ' \\ n' : case ' ' : case ' \\ t' : buffer . append ( c ) ; <LOG> break ; case ' @ ' : if ( prevc != ' \\ \\ ' ) { is <identifiersep> state1present = true ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; } buffer . append ( c ) ; <ect>
break ; } string brace <identifiersep> space = buffer . substring ( 0 , i ) ; buffer . delete ( 0 , i ) ; if ( buffer . length ( ) > <number_literal> && buffer . substring ( 0 , <number_literal> ) . equals ( <string_literal> ) ) { brace <identifiersep> space += buffer . substring ( 0 , <number_literal> ) ; if ( <string_literal> . index <identifiersep> of ( buffer . char <identifiersep> at ( <number_literal> ) ) == - 1 ) { <LOG> return ; } buffer . delete ( 0 , <number_literal> ) ; for ( i = 0 ; i < buffer . length ( ) ; i ++ ) { char c1 = buffer . char <identifiersep> at ( i ) ; if ( c1 == ' ' || c1 == ' \\ f' || c1 == ' \\ t' || c1 == ' \\ r' || c1 == ' \\ n' ) continue ; <ect>
buffer . set <identifiersep> length ( 0 ) ; boolean valid = false ; if ( parts != null ) { if ( parts . length < 1 ) { ignore <identifiersep> elements <identifiersep> s1 = true ; <LOG> valid = false ; } else if ( parts [ 0 ] instanceof simple <identifiersep> parsed <identifiersep> word && <string_literal> . equals ( ( ( simple <identifiersep> parsed <identifiersep> word ) parts [ 0 ] ) . original . to <identifiersep> lower <identifiersep> case ( ) ) ) { if ( parts . length < <number_literal> ) { ignore <identifiersep> elements <identifiersep> s1 = true ; <ect>
filtered <identifiersep> tokens . append ( <string_literal> ) ; } } } <comment> <LOG> } else { w . write ( filtered <identifiersep> tokens . to <identifiersep> string ( ) ) ; filtered <identifiersep> tokens . set <identifiersep> length ( 0 ) ; } buffer . set <identifiersep> length ( 0 ) ; s2comma = false ; if ( for <identifiersep> page ) { <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> value ) ; buffer . set <identifiersep> length ( 0 ) ; obj = get <identifiersep> verifier ( property <identifiersep> name ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> + property <identifiersep> value ) ; if ( obj != null ) { parsed <identifiersep> word [ ] words = split ( property <identifiersep> value , obj . allow <identifiersep> comma <identifiersep> delimiters ) ; <LOG> if ( ! ignore <identifiersep> elements <identifiersep> s2 && ! ignore <identifiersep> elements <identifiersep> s3 && verify <identifiersep> token ( current <identifiersep> media , elements , obj , words ) ) { if ( changed <identifiersep> anything ( words ) ) property <identifiersep> value = reconstruct ( words ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> before <identifiersep> property ) ; whitespace <identifiersep> before <identifiersep> property = <string_literal> ; filtered <identifiersep> tokens . append ( property <identifiersep> name ) ; <ect>
filtered <identifiersep> tokens . append ( property <identifiersep> name ) ; filtered <identifiersep> tokens . append ( ' : ' ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> after <identifiersep> colon ) ; filtered <identifiersep> tokens . append ( property <identifiersep> value ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> + property <identifiersep> value ) ; } } else { <LOG> } property <identifiersep> name = <string_literal> ; } else { <comment> <ect>
close <identifiersep> ignored <identifiersep> s2 = false ; ignore <identifiersep> elements <identifiersep> s2 = false ; } else ignore <identifiersep> elements <identifiersep> s2 = false ; if ( ! ignore <identifiersep> elements <identifiersep> s1 ) { w . write ( filtered <identifiersep> tokens . to <identifiersep> string ( ) ) ; <LOG> } filtered <identifiersep> tokens . set <identifiersep> length ( 0 ) ; whitespace <identifiersep> after <identifiersep> colon = <string_literal> ; if ( for <identifiersep> page ) { for <identifiersep> page = false ; current <identifiersep> state = state1 ; } else { <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; break ; case ' { ' : <comment> <LOG> break ; case ' <string_literal> <ect>
<comment> <LOG> return false ; } for ( int i = tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> lower <identifiersep> limit ; i < = tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> upper <identifiersep> limit && i < = value <identifiersep> parts . length ; i ++ ) { parsed <identifiersep> word [ ] before = arrays . copy <identifiersep> of ( value <identifiersep> parts , i ) ; if ( css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ verifier <identifiersep> index ] . check <identifiersep> validity ( before , cb ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + i + <string_literal> + verifier <identifiersep> index + <string_literal> + to <identifiersep> string ( before ) ) ; if ( i == value <identifiersep> parts . length && lower <identifiersep> limit < = 1 ) { <ect>
for ( int i = tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> lower <identifiersep> limit ; i < = tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> upper <identifiersep> limit && i < = value <identifiersep> parts . length ; i ++ ) { parsed <identifiersep> word [ ] before = arrays . copy <identifiersep> of ( value <identifiersep> parts , i ) ; if ( css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ verifier <identifiersep> index ] . check <identifiersep> validity ( before , cb ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + i + <string_literal> + verifier <identifiersep> index + <string_literal> + to <identifiersep> string ( before ) ) ; if ( i == value <identifiersep> parts . length && lower <identifiersep> limit < = 1 ) { if ( recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( second <identifiersep> part , new parsed <identifiersep> word [ 0 ] , cb ) ) { <LOG> return true ; } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + second <identifiersep> part ) ; return false ; } } else if ( i == value <identifiersep> parts . length && lower <identifiersep> limit > 1 ) return false ; <ect>
} else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + second <identifiersep> part ) ; return false ; } } else if ( i == value <identifiersep> parts . length && lower <identifiersep> limit > 1 ) return false ; parsed <identifiersep> word [ ] after = arrays . copy <identifiersep> of <identifiersep> range ( value <identifiersep> parts , i , value <identifiersep> parts . length ) ; <LOG> if ( recursive <identifiersep> variable <identifiersep> occurance <identifiersep> verifier ( verifier <identifiersep> index , after , lower <identifiersep> limit - 1 , upper <identifiersep> limit - 1 , tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> lower <identifiersep> limit , tokens <identifiersep> can <identifiersep> be <identifiersep> given <identifiersep> upper <identifiersep> limit , second <identifiersep> part , cb ) ) return true ; } } return false ; } static string to <identifiersep> string ( parsed <identifiersep> word [ ] words ) { if ( words == null ) return null ; string <identifiersep> builder sb = new string <identifiersep> builder ( ) ; <ect>
first <identifiersep> part = expression . substring ( last <identifiersep> a + 1 , i ) ; last <identifiersep> a = i ; if ( i == expression . length ( ) ) second <identifiersep> part = <string_literal> ; else second <identifiersep> part = expression . substring ( i + 1 , expression . length ( ) ) ; <LOG> boolean result = false ; int index = integer . parse <identifiersep> int ( first <identifiersep> part ) ; for ( int j = 0 ; j < words . length ; j ++ ) { <comment> <ect>
<comment> <LOG> } boolean detected = false ; for ( string allowed <identifiersep> content <identifiersep> type : allowed <identifiersep> content <identifiersep> types ) { if ( typesplit [ 0 ] . equals <identifiersep> ignore <identifiersep> case ( allowed <identifiersep> content <identifiersep> type ) ) { if ( ( typesplit [ 1 ] == null ) || ( pc . charset != null && typesplit [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( pc . charset ) ) ) { hn . put ( <string_literal> , http <identifiersep> equiv ) ; <ect>
parser . parse ( ) ; } finally { w . flush ( ) ; } } @ override public string get <identifiersep> charset ( byte [ ] input , int length , string charset ) throws data <identifiersep> filter <identifiersep> exception , io <identifiersep> exception { if ( log <identifiersep> debug ) <LOG> if ( input . length > get <identifiersep> charset <identifiersep> buffer <identifiersep> size ( ) && log <identifiersep> minor ) { logger . minor ( this , <string_literal> ) ; } input <identifiersep> stream strm = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( input , 0 , length ) ; null <identifiersep> writer w = new null <identifiersep> writer ( ) ; input <identifiersep> stream <identifiersep> reader isr ; buffered <identifiersep> reader r = null ; <ect>
int idx = u . last <identifiersep> index <identifiersep> of ( ' / ' ) ; if ( idx > 0 ) { u = u . substring ( 0 , idx + 1 ) ; try { stripped <identifiersep> base <identifiersep> uri = new uri ( u ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <LOG> stripped <identifiersep> base <identifiersep> uri = base <identifiersep> uri ; } } else stripped <identifiersep> base <identifiersep> uri = base <identifiersep> uri ; } @ override public string process <identifiersep> uri ( string u , string override <identifiersep> type ) throws comment <identifiersep> exception { return process <identifiersep> uri ( u , override <identifiersep> type , false , false ) ; <ect>
if ( ! no <identifiersep> relative ) uri = stripped <identifiersep> base <identifiersep> uri . relativize ( uri ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uri . to <identifiersep> ascii <identifiersep> string ( ) + <string_literal> + path + <string_literal> + base <identifiersep> uri + <string_literal> + stripped <identifiersep> base <identifiersep> uri . to <identifiersep> string ( ) ) ; return uri . to <identifiersep> ascii <identifiersep> string ( ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { <LOG> string p = path ; if ( type <identifiersep> override != null ) p += <string_literal> + type <identifiersep> override ; if ( u . get <identifiersep> fragment ( ) != null ) { try { <comment> <ect>
system . out . println ( <string_literal> ) ; if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { throw new exception ( <string_literal> ) ; } system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { thread . sleep ( <number_literal> ) ; <LOG> if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { throw new exception ( <string_literal> ) ; } } system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; if ( new string ( base64 . decode <identifiersep> standard ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . split ( <string_literal> ) [ 1 ] ) ) . compare <identifiersep> to ( request <identifiersep> id1 ) != 0 ) { <ect>
thread . sleep ( <number_literal> ) ; system . out . println ( <string_literal> + i ) ; if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { throw new exception ( <string_literal> ) ; } } system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> if ( new string ( base64 . decode <identifiersep> standard ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . split ( <string_literal> ) [ 1 ] ) ) . compare <identifiersep> to ( request <identifiersep> id1 ) != 0 ) { throw new exception ( <string_literal> ) ; } } c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) ; c2 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id2 ) ; } @ seconds <identifiersep> long ( 0 ) @ test <identifiersep> type ( type . integration ) <ect>
try { serializer . write <identifiersep> to <identifiersep> data <identifiersep> output <identifiersep> stream ( too <identifiersep> long , dos ) ; } catch ( io <identifiersep> exception e ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> , e ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { <comment> <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } private static void read <identifiersep> write ( object [ ] data ) { byte <identifiersep> array <identifiersep> output <identifiersep> stream byte <identifiersep> output <identifiersep> stream = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; data <identifiersep> output <identifiersep> stream dos = new data <identifiersep> output <identifiersep> stream ( byte <identifiersep> output <identifiersep> stream ) ; <comment> <ect>
final int k = filter . get <identifiersep> k ( ) ; final double q = 1 - math . pow ( 1 - 1 . 0 / filter <identifiersep> size , k * pass ) ; final double p = math . pow ( q , k ) ; final double actual = ( double ) f <identifiersep> pos / pass <identifiersep> false ; final double limit = p * 1 . <number_literal> + 1 . 0 / pass <identifiersep> false ; <comment> <LOG> system . out . println ( <string_literal> + q ) ; system . out . println ( <string_literal> + p ) ; system . out . println ( <string_literal> + limit ) ; system . out . println ( <string_literal> + actual ) ; system . out . println ( <string_literal> + actual / p ) ; <comment> <ect>
text = new byte [ <number_literal> ] ; for ( int i = 0 ; i < text . length ; i ++ ) text [ i ] = ( byte ) 0xdd ; mv = s . mac ( key , text , <number_literal> ) ; system . out . println ( hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( mv , 0 , mv . length ) ) ; key = new byte [ <number_literal> ] ; <LOG> for ( int i = 0 ; i < key . length ; i ++ ) key [ i ] = ( byte ) ( i + 1 ) ; for ( int i = 0 ; i < text . length ; i ++ ) text [ i ] = ( byte ) 0xcd ; mv = s . mac ( key , text , <number_literal> ) ; system . out . println ( hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( mv , 0 , mv . length ) ) ; <ect>
public short get <identifiersep> priority <identifiersep> class ( ) { return 0 ; } @ override public synchronized void fail <identifiersep> on <identifiersep> disk <identifiersep> error ( io <identifiersep> exception e ) { failed = true ; notify <identifiersep> all ( ) ; <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } @ override public void set <identifiersep> splitfile <identifiersep> blocks ( int required <identifiersep> blocks , int remaining <identifiersep> blocks ) { assert <identifiersep> equals ( required <identifiersep> blocks , splitfile . data <identifiersep> blocks . length ) ; assert <identifiersep> equals ( remaining <identifiersep> blocks , splitfile . check <identifiersep> blocks . length ) ; } @ override <ect>
synchronized ( this ) { started = true ; notify <identifiersep> all ( ) ; } try { job <identifiersep> runner . wait <identifiersep> and <identifiersep> checkpoint ( ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <LOG> return ; } assert <identifiersep> true ( job <identifiersep> runner . grab <identifiersep> has <identifiersep> checkpointed ( ) ) ; synchronized ( this ) { finished = true ; notify <identifiersep> all ( ) ; } } public synchronized boolean has <identifiersep> started ( ) { <ect>
pure <identifiersep> code . encode ( src <identifiersep> bufs , repair <identifiersep> bufs , index <identifiersep> backup ) ; long t3 = system . current <identifiersep> time <identifiersep> millis ( ) ; float d <identifiersep> native <identifiersep> encode = t2 - t1 ; float d <identifiersep> pure <identifiersep> encode = t3 - t2 ; buffer [ ] repair <identifiersep> bufs2 = repair <identifiersep> bufs . clone ( ) ; system . arraycopy ( repair <identifiersep> bufs , 0 , repair <identifiersep> bufs2 , 0 , repair <identifiersep> bufs . length ) ; <LOG> t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; maybe <identifiersep> native . decode ( repair <identifiersep> bufs , index ) ; t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; pure <identifiersep> code . decode ( repair <identifiersep> bufs2 , index <identifiersep> backup ) ; t3 = system . current <identifiersep> time <identifiersep> millis ( ) ; float d <identifiersep> native <identifiersep> decode = t2 - t1 ; <ect>
r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> float ( ) + <string_literal> ) ; if ( j%4 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%4 == <number_literal> ) ) system . out . println ( ) ; <LOG> r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> double ( ) + <string_literal> ) ; if ( j%3 == <number_literal> ) system . out . println ( ) ; } if ( ! ( j%3 == <number_literal> ) ) system . out . println ( ) ; <ect>
@ override public void message <identifiersep> received ( tidy <identifiersep> message message ) { <comment> <LOG> message . get <identifiersep> message ( ) ) ; } } <ect>
try { <comment> <LOG> <comment> <ect>
if ( this . properties == null ) { url url = this . environment . get <identifiersep> resource ( get <identifiersep> skin <identifiersep> folder ( ) + <string_literal> ) ; if ( url != null ) { try { this . properties = new configurations ( ) . properties ( url ) ; } catch ( configuration <identifiersep> exception e ) { <LOG> exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; this . properties = new base <identifiersep> configuration ( ) ; } } else { logger . debug ( <string_literal> , this . id ) ; this . properties = new base <identifiersep> configuration ( ) ; } } return this . properties ; <ect>
long size ; if ( properties . is <identifiersep> with <identifiersep> wiki <identifiersep> attachments <identifiersep> content ( ) ) { try { content = attachment . get <identifiersep> content <identifiersep> input <identifiersep> stream ( xcontext ) ; size = long . value <identifiersep> of ( attachment . get <identifiersep> long <identifiersep> size ( ) ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> content = new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( new byte [ 0 ] ) ; size = 0l ; } } else { content = null ; size = null ; } <comment> <ect>
try { for ( version version : document . get <identifiersep> revisions ( xcontext ) ) { x <identifiersep> wiki <identifiersep> document revision <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document , version . to <identifiersep> string ( ) , xcontext ) ; write <identifiersep> revision ( revision <identifiersep> document , filter , document <identifiersep> filter , properties ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } write <identifiersep> revision ( document , filter , document <identifiersep> filter , properties ) ; <comment> <ect>
{ return jobtype ; } @ override protected void run <identifiersep> internal ( ) throws exception { string wiki <identifiersep> id = get <identifiersep> request ( ) . get <identifiersep> wiki <identifiersep> id ( ) ; <LOG> x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; <comment> <ect>
<comment> <LOG> } } @ override public string get <identifiersep> content ( ) { return this . content ; } @ property <identifiersep> hidden @ override <ect>
. get <identifiersep> component ( entity <identifiersep> reference <identifiersep> serializer . type <identifiersep> string ) ; protected void log <identifiersep> allow ( string username , string page , string action , string info ) { logger . debug ( <string_literal> , username , page , action , info ) ; } protected void log <identifiersep> deny ( string username , string page , string action , string info ) { <LOG> } protected void log <identifiersep> deny ( string name , string resource <identifiersep> key , string access <identifiersep> level , string info , exception e ) { logger . debug ( <string_literal> , name , resource <identifiersep> key , access <identifiersep> level , info , e ) ; } @ override public list < string > list <identifiersep> all <identifiersep> levels ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <ect>
return <string_literal> ; } else { return right ; } } @ override public boolean check <identifiersep> access ( string action , x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <LOG> string username = null ; x <identifiersep> wiki <identifiersep> user user = null ; boolean needs <identifiersep> auth = false ; string right = get <identifiersep> right ( action ) ; if ( right . equals ( <string_literal> ) ) { user = context . get <identifiersep> wiki ( ) . check <identifiersep> auth ( context ) ; <ect>
logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , doc . get <identifiersep> full <identifiersep> name ( ) , access <identifiersep> level , user , allow , global ) ; } list < base <identifiersep> object > right <identifiersep> objects = doc . get <identifiersep> x <identifiersep> objects ( right <identifiersep> class <identifiersep> reference ) ; if ( right <identifiersep> objects != null ) { <LOG> } for ( int i = 0 ; i < right <identifiersep> objects . size ( ) ; i ++ ) { logger . debug ( <string_literal> , i ) ; base <identifiersep> object bobj = right <identifiersep> objects . get ( i ) ; if ( bobj == null ) { logger . debug ( <string_literal> , i ) ; continue ; <ect>
logger . debug ( <string_literal> , right <identifiersep> objects . size ( ) ) ; } for ( int i = 0 ; i < right <identifiersep> objects . size ( ) ; i ++ ) { logger . debug ( <string_literal> , i ) ; base <identifiersep> object bobj = right <identifiersep> objects . get ( i ) ; if ( bobj == null ) { <LOG> continue ; } string users = bobj . get <identifiersep> string <identifiersep> value ( field <identifiersep> name ) ; string levels = bobj . get <identifiersep> string <identifiersep> value ( <string_literal> ) ; boolean allowdeny = ( bobj . get <identifiersep> int <identifiersep> value ( <string_literal> ) == 1 ) ; if ( allowdeny == allow ) { logger . debug ( <string_literal> , access <identifiersep> level , levels ) ; <ect>
get <identifiersep> cookie <identifiersep> value ( request . get <identifiersep> cookies ( ) , get <identifiersep> cookie <identifiersep> prefix ( ) + cookie <identifiersep> validation , default <identifiersep> value ) ; string calculated <identifiersep> hash = get <identifiersep> validation <identifiersep> hash ( username , password , get <identifiersep> client <identifiersep> ip ( request ) ) ; if ( cookie <identifiersep> hash . equals ( calculated <identifiersep> hash ) ) { return true ; } else { logger . warn ( <string_literal> ) ; <LOG> forget <identifiersep> login ( request , response ) ; } } return false ; } <comment> <ect>
public boolean can <identifiersep> undelete ( ) { try { return has <identifiersep> access <identifiersep> level ( admin <identifiersep> right , get <identifiersep> full <identifiersep> name ( ) ) || has <identifiersep> access <identifiersep> level ( <string_literal> , get <identifiersep> full <identifiersep> name ( ) ) ; } catch ( x <identifiersep> wiki <identifiersep> exception ex ) { <comment> <LOG> return false ; } } <comment> <ect>
public document get <identifiersep> document ( ) { if ( can <identifiersep> undelete ( ) ) { try { return new document ( this . deleted <identifiersep> doc . restore <identifiersep> document ( null , this . context ) , this . context ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } return null ; } <comment> public document <identifiersep> reference get <identifiersep> document <identifiersep> reference ( ) <ect>
return this . doc . get <identifiersep> rendered <identifiersep> title ( syntax . value <identifiersep> of ( syntax <identifiersep> id ) , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; } catch ( parse <identifiersep> exception e ) { logger . error ( <string_literal> + syntax <identifiersep> id + <string_literal> , e ) ; throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <string_literal> + syntax <identifiersep> id + <string_literal> , e ) ; } catch ( exception e ) { <LOG> throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <string_literal> + get <identifiersep> prefixed <identifiersep> full <identifiersep> name ( ) + <string_literal> , e ) ; } } <comment> public string get <identifiersep> format ( ) <ect>
this . ds . close ( ) ; this . ds = null ; } else { logger . warn ( <string_literal> ) ; } } catch ( exception e ) { throw new hibernate <identifiersep> exception ( <string_literal> , e ) ; } <LOG> } <comment> <ect>
private void try <identifiersep> to <identifiersep> procceed <identifiersep> to <identifiersep> migration ( ) throws data <identifiersep> migration <identifiersep> exception { x <identifiersep> wiki <identifiersep> config config = get <identifiersep> x <identifiersep> wiki <identifiersep> config ( ) ; if ( <string_literal> . equals ( config . get <identifiersep> property ( <string_literal> , <string_literal> ) ) && ! <string_literal> . equals ( config . get <identifiersep> property ( <string_literal> ) ) ) { <comment> <LOG> start <identifiersep> migrations <identifiersep> only <identifiersep> once ( ) ; <comment> <ect>
string database = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) . get <identifiersep> wiki <identifiersep> id ( ) ; if ( ! needed <identifiersep> migrations . is <identifiersep> empty ( ) ) { this . logger . info ( <string_literal> , database , curversion ) ; for ( x <identifiersep> wiki <identifiersep> migration migration : needed <identifiersep> migrations ) { <LOG> migration . data <identifiersep> migration . get <identifiersep> description ( ) , ( migration . is <identifiersep> forced ? <string_literal> : <string_literal> ) ) ; } } else { if ( curversion != null ) { this . logger . info ( <string_literal> , database , curversion ) ; } else { <ect>
versioning <identifiersep> store . set <identifiersep> session ( null , context ) ; versioning <identifiersep> store . set <identifiersep> transaction ( null , context ) ; prepared <identifiersep> statement delete <identifiersep> statement = session . connection ( ) . prepare <identifiersep> statement ( <string_literal> ) ; while ( rs . next ( ) ) { <LOG> } long doc <identifiersep> id = long . parse <identifiersep> long ( rs . get <identifiersep> string ( 1 ) ) ; string s <identifiersep> archive = rs . get <identifiersep> string ( <number_literal> ) ; <comment> <ect>
<comment> <LOG> } stmt . execute <identifiersep> update ( sql ) ; } connection . commit ( ) ; } catch ( exception e ) { throw new hibernate <identifiersep> exception ( <string_literal> + sql + <string_literal> , e ) ; } finally { try { <ect>
if ( b <identifiersep> transaction ) { this . store . end <identifiersep> transaction ( do <identifiersep> commit ) ; } if ( monitor != null ) { monitor . end <identifiersep> timer ( x <identifiersep> wiki <identifiersep> hibernate <identifiersep> base <identifiersep> store . hint ) ; } } catch ( exception e ) { if ( logger . is <identifiersep> error <identifiersep> enabled ( ) ) { <LOG> } } } } <comment> <ect>
if ( output <identifiersep> syntax == null ) { string output <identifiersep> syntax <identifiersep> id = ( string ) parameters . get ( <string_literal> ) ; if ( output <identifiersep> syntax <identifiersep> id != null ) { try { output <identifiersep> syntax = syntax . value <identifiersep> of ( output <identifiersep> syntax <identifiersep> id ) ; } catch ( exception e ) { <LOG> return null ; } } else { output <identifiersep> syntax = rendering <identifiersep> context . get <identifiersep> target <identifiersep> syntax ( ) ; } } return output <identifiersep> syntax ; } <comment> <ect>
{ x <identifiersep> wiki <identifiersep> context context = get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ; string content = null ; try { content = document . get <identifiersep> translated <identifiersep> content ( ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> e ) ; return null ; } string rendered <identifiersep> content = this . rendering <identifiersep> cache . get <identifiersep> rendered <identifiersep> content ( document . get <identifiersep> document <identifiersep> reference ( ) , content , context ) ; if ( rendered <identifiersep> content == null ) { map < string , object > actual <identifiersep> parameters = new hash <identifiersep> map < string , object > ( parameters ) ; <ect>
return arch ; } catch ( exception e ) { <comment> <LOG> return null ; } } public void set <identifiersep> document <identifiersep> archive ( x <identifiersep> wiki <identifiersep> document <identifiersep> archive arch ) { <comment> <ect>
string <identifiersep> writer writer = new string <identifiersep> writer ( ) ; try { velocity <identifiersep> manager velocity <identifiersep> manager = utils . get <identifiersep> component ( velocity <identifiersep> manager . class ) ; velocity <identifiersep> manager . get <identifiersep> velocity <identifiersep> engine ( ) . evaluate ( vcontext , writer , name , content ) ; return writer . to <identifiersep> string ( ) ; } catch ( exception e ) { <LOG> object [ ] args = { name } ; x <identifiersep> wiki <identifiersep> exception xe = new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> rendering <identifiersep> velocity <identifiersep> exception , <string_literal> , e , args ) ; return util . get <identifiersep> html <identifiersep> exception <identifiersep> message ( xe , context ) ; } } <comment> <ect>
doc . set <identifiersep> content <identifiersep> dirty ( is <identifiersep> content <identifiersep> dirty ( ) ) ; doc . set <identifiersep> meta <identifiersep> data <identifiersep> dirty ( is <identifiersep> meta <identifiersep> data <identifiersep> dirty ( ) ) ; doc . elements = this . elements ; doc . original <identifiersep> document = this . original <identifiersep> document ; } catch ( exception e ) { <comment> <LOG> } return doc ; } <comment> <ect>
<comment> <LOG> return null ; } } <comment> <ect>
html <identifiersep> cleaner cleaner = utils . get <identifiersep> component ( html <identifiersep> cleaner . class ) ; html <identifiersep> cleaner <identifiersep> configuration config = cleaner . get <identifiersep> default <identifiersep> configuration ( ) ; list < html <identifiersep> filter > filters = new array <identifiersep> list < html <identifiersep> filter > ( config . get <identifiersep> filters ( ) ) ; filters . add ( utils . get <identifiersep> component ( html <identifiersep> filter . class , <string_literal> ) ) ; config . set <identifiersep> filters ( filters ) ; string result = html <identifiersep> utils . to <identifiersep> string ( cleaner . clean ( new string <identifiersep> reader ( input ) , config ) ) ; <LOG> return result ; } <comment> <ect>
throws x <identifiersep> wiki <identifiersep> exception { logger . debug ( <string_literal> , xhtml ) ; <comment> <LOG> render <identifiersep> xslfo ( xmlfo , out , type , context ) ; } <comment> <ect>
<comment> string apply <identifiersep> css ( string html , string css , x <identifiersep> wiki <identifiersep> context context ) { <LOG> try { <comment> <ect>
string result = out . to <identifiersep> string ( ) ; <comment> <LOG> return html ; } } <comment> <ect>
try { group <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
try { group <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> wiki <identifiersep> users <identifiersep> or <identifiersep> groups ( false , wiki <identifiersep> name , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; group <identifiersep> list = convert ( xdoc <identifiersep> list ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> wiki <identifiersep> users <identifiersep> or <identifiersep> groups ( false , wiki <identifiersep> name , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; group <identifiersep> list = convert ( xdoc <identifiersep> list ) ; } catch ( rights <identifiersep> manager <identifiersep> exception e ) { <LOG> group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
document <identifiersep> stat . inc <identifiersep> visits ( ) ; } } <comment> <LOG> } } } <ect>
try { if ( stats <identifiersep> util . is <identifiersep> wiki <identifiersep> stats <identifiersep> enabled ( context ) && ! stats <identifiersep> util . get <identifiersep> storage <identifiersep> filtered <identifiersep> users ( context ) . contains ( this . current <identifiersep> document <identifiersep> reference <identifiersep> resolver . resolve ( context . get <identifiersep> user ( ) ) ) ) { this . stats <identifiersep> register . add <identifiersep> stats ( document , action , context ) ; } } catch ( exception e ) { <LOG> } } @ override public map < ? , ? > get <identifiersep> action <identifiersep> statistics ( string action , scope scope , period period , duration step , x <identifiersep> wiki <identifiersep> context context ) { return this . stats <identifiersep> reader . get <identifiersep> action <identifiersep> statistics ( action , scope , period , step , context ) ; } @ override <ect>
} else { try { string ip = request . get <identifiersep> remote <identifiersep> addr ( ) ; string ua = request . get <identifiersep> header ( reqprop <identifiersep> useragent ) ; visit <identifiersep> stats = find <identifiersep> visit <identifiersep> by <identifiersep> ipua ( compute <identifiersep> unique <identifiersep> id ( ip , ua ) , context ) ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> } } return visit <identifiersep> stats ; } <comment> <ect>
qm . create <identifiersep> query ( <string_literal> + <string_literal> , query . xpath ) . bind <identifiersep> value ( <string_literal> , field <identifiersep> name ) . bind <identifiersep> value ( sfield <identifiersep> value , field <identifiersep> value ) . bind <identifiersep> value ( sdate , current <identifiersep> date ) . execute ( ) ; } catch ( exception e ) { <LOG> } } else if ( qm . has <identifiersep> language ( query . hql ) ) { try { solist = qm . create <identifiersep> query ( <string_literal> + <string_literal> + field <identifiersep> name + <string_literal> + <string_literal> , query . hql ) . bind <identifiersep> value ( sfield <identifiersep> value , field <identifiersep> value ) <ect>
return - <number_literal> ; } try { if ( ! context . get <identifiersep> util ( ) . match ( get <identifiersep> configuration ( ) . get <identifiersep> property ( <string_literal> , <string_literal> ) , xwikiname ) ) { return - <number_literal> ; } } catch ( runtime <identifiersep> exception ex ) { <LOG> if ( ! context . get <identifiersep> util ( ) . match ( <string_literal> , xwikiname ) ) { return - <number_literal> ; } } if ( ( ! password . equals ( password2 ) ) || ( password . trim ( ) . equals ( <string_literal> ) ) ) { <comment> <ect>
local <identifiersep> topic = topic . substring ( i0 + 1 ) ; } else { prefixed <identifiersep> topic = context . get <identifiersep> wiki <identifiersep> id ( ) + <string_literal> + topic ; local <identifiersep> topic = topic ; } x <identifiersep> wiki <identifiersep> document doc = null ; try { <LOG> try { @ suppress <identifiersep> warnings ( <string_literal> ) set < string > included <identifiersep> docs = ( set < string > ) context . get ( <string_literal> ) ; if ( included <identifiersep> docs == null ) { included <identifiersep> docs = new hash <identifiersep> set < string > ( ) ; context . put ( <string_literal> , included <identifiersep> docs ) ; <ect>
get <identifiersep> current <identifiersep> mixed <identifiersep> document <identifiersep> reference <identifiersep> resolver ( ) . resolve ( local <identifiersep> topic ) ; doc = get <identifiersep> document ( target <identifiersep> document <identifiersep> reference , context ) ; if ( check <identifiersep> access ( <string_literal> , doc , context ) == false ) { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> access , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> access <identifiersep> denied , <string_literal> + doc ) ; } } catch ( x <identifiersep> wiki <identifiersep> exception e ) { <LOG> return <string_literal> + topic + <string_literal> ; } x <identifiersep> wiki <identifiersep> document contentdoc = doc . get <identifiersep> translated <identifiersep> document ( context ) ; string result ; if ( is <identifiersep> form ) { <comment> <ect>
} finally { context . set <identifiersep> wiki <identifiersep> id ( db ) ; } } try { context . set <identifiersep> wiki <identifiersep> id ( source <identifiersep> wiki ) ; list < string > list = get <identifiersep> store ( ) . search ( sql , 0 , 0 , parameters , context ) ; <LOG> } wiki <identifiersep> reference source <identifiersep> wiki <identifiersep> reference = new wiki <identifiersep> reference ( source <identifiersep> wiki ) ; wiki <identifiersep> reference target <identifiersep> wiki <identifiersep> reference = new wiki <identifiersep> reference ( target <identifiersep> wiki ) ; for ( string docname : list ) { document <identifiersep> reference source <identifiersep> document <identifiersep> reference = get <identifiersep> current <identifiersep> mixed <identifiersep> document <identifiersep> reference <identifiersep> resolver ( ) . resolve ( docname ) ; source <identifiersep> document <identifiersep> reference = source <identifiersep> document <identifiersep> reference . replace <identifiersep> parent ( source <identifiersep> document <identifiersep> reference . get <identifiersep> wiki <identifiersep> reference ( ) , source <identifiersep> wiki <identifiersep> reference ) ; <ect>
<comment> <LOG> <comment> <ect>
<comment> public string get <identifiersep> resource <identifiersep> file <identifiersep> path ( string filename ) throws io <identifiersep> exception { string path = uri . create ( delimiter + resources <identifiersep> directory + delimiter + filename ) . normalize ( ) . to <identifiersep> string ( ) ; <comment> <LOG> throw new io <identifiersep> exception ( <string_literal> + filename + <string_literal> ) ; } return path ; } <comment> <ect>
private boolean render <identifiersep> skin ( string filename , x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception , io <identifiersep> exception { logger . debug ( <string_literal> , filename , doc . get <identifiersep> document <identifiersep> reference ( ) ) ; try { if ( doc . is <identifiersep> new ( ) ) { <LOG> } else { return render <identifiersep> file <identifiersep> from <identifiersep> object <identifiersep> field ( filename , doc , context ) || render <identifiersep> file <identifiersep> from <identifiersep> attachment ( filename , doc , context ) || ( skins <identifiersep> directory . equals ( doc . get <identifiersep> space ( ) ) && render <identifiersep> file <identifiersep> from <identifiersep> filesystem ( get <identifiersep> skin <identifiersep> file <identifiersep> path ( filename , doc . get <identifiersep> name ( ) ) , context ) ) ; } } catch ( io <identifiersep> exception e ) { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> app , <ect>
response . get <identifiersep> output <identifiersep> stream ( ) . write ( data ) ; } catch ( io <identifiersep> exception e ) { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> app , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> app <identifiersep> send <identifiersep> response <identifiersep> exception , <string_literal> , e ) ; } return true ; } } catch ( io <identifiersep> exception ex ) { <LOG> } return false ; } <comment> <ect>
logger . debug ( <string_literal> + failed <identifiersep> files ) ; logger . debug ( <string_literal> + wrong <identifiersep> file <identifiersep> names ) ; if ( ajax ) { try { response . get <identifiersep> output <identifiersep> stream ( ) . println ( <string_literal> ) ; } catch ( io <identifiersep> exception ex ) { <LOG> } return false ; } <comment> <ect>
private include <identifiersep> servlet <identifiersep> as <identifiersep> string ( ) { } static public string invoke <identifiersep> servlet <identifiersep> and <identifiersep> return <identifiersep> as <identifiersep> string ( string url , http <identifiersep> servlet <identifiersep> request servlet <identifiersep> request , http <identifiersep> servlet <identifiersep> response servlet <identifiersep> response ) throws io <identifiersep> exception , servlet <identifiersep> exception { <LOG> } request <identifiersep> dispatcher request <identifiersep> dispatcher = servlet <identifiersep> request . get <identifiersep> request <identifiersep> dispatcher ( url ) ; if ( request <identifiersep> dispatcher == null ) { illegal <identifiersep> argument <identifiersep> exception iae = new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + url ) ; logger . error ( iae . get <identifiersep> message ( ) , iae ) ; throw iae ; <ect>
x <identifiersep> wiki <identifiersep> lock lock = document . get <identifiersep> lock ( context ) ; edit <identifiersep> form edit <identifiersep> form = ( edit <identifiersep> form ) context . get <identifiersep> form ( ) ; if ( lock == null || lock . get <identifiersep> user <identifiersep> name ( ) . equals ( context . get <identifiersep> user ( ) ) || edit <identifiersep> form . is <identifiersep> lock <identifiersep> force ( ) ) { document . set <identifiersep> lock ( context . get <identifiersep> user ( ) , context ) ; } } catch ( exception e ) { <comment> <LOG> } } } <ect>
mpreq . set <identifiersep> parameter ( s <identifiersep> name , s <identifiersep> value ) ; } } } } catch ( exception e ) { if ( ( e instanceof x <identifiersep> wiki <identifiersep> exception ) && ( ( ( x <identifiersep> wiki <identifiersep> exception ) e ) . get <identifiersep> code ( ) == x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> app <identifiersep> file <identifiersep> exception <identifiersep> maxsize ) ) { context . put ( <string_literal> , e ) ; } else { <LOG> } } return fileupload ; } <comment> public static void set <identifiersep> component <identifiersep> manager ( component <identifiersep> manager component <identifiersep> manager ) <ect>
if ( batch <identifiersep> entry . reference == null ) { solr <identifiersep> instance . delete <identifiersep> by <identifiersep> query ( batch <identifiersep> entry . delete <identifiersep> query ) ; } else { solr <identifiersep> instance . delete ( this . solr <identifiersep> referece <identifiersep> resolver . get <identifiersep> id ( batch <identifiersep> entry . reference ) ) ; } ++ this . batch <identifiersep> size ; } } catch ( throwable e ) { <LOG> } finally { this . execution . remove <identifiersep> context ( ) ; } <comment> <ect>
} catch ( exception e ) { this . logger . error ( <string_literal> , e ) ; try { solr <identifiersep> instance . rollback ( ) ; } catch ( exception ex ) { <comment> <LOG> } } this . batch <identifiersep> size = 0 ; } <comment> <ect>
{ if ( ! this . disposed ) { <comment> <LOG> } } } @ override public int get <identifiersep> queue <identifiersep> size ( ) { return this . index <identifiersep> queue . size ( ) + this . resolve <identifiersep> queue . size ( ) + this . batch <identifiersep> size ; } @ override public indexer <identifiersep> job start <identifiersep> index ( indexer <identifiersep> request request ) throws solr <identifiersep> indexer <identifiersep> exception <ect>
solr <identifiersep> document . add <identifiersep> field ( field <identifiersep> utils . attachment <identifiersep> author , author <identifiersep> string <identifiersep> reference ) ; try { <comment> <LOG> } } } <ect>
x <identifiersep> wiki <identifiersep> document document = this . context . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> name , this . context ) ; if ( this . context . get <identifiersep> wiki ( ) . check <identifiersep> access ( tag <identifiersep> access <identifiersep> right , document , this . context ) ) { result = this . get <identifiersep> protected <identifiersep> plugin ( ) . add <identifiersep> tags <identifiersep> to <identifiersep> document ( tags , document , this . context ) ; } else { result = tag <identifiersep> operation <identifiersep> result . not <identifiersep> allowed ; } } catch ( exception ex ) { <LOG> result = tag <identifiersep> operation <identifiersep> result . failed ; } return result ; } <comment> <ect>
try { if ( has <identifiersep> admin <identifiersep> rights ( ) ) { result = this . get <identifiersep> protected <identifiersep> plugin ( ) . rename <identifiersep> tag ( tag , new <identifiersep> tag , this . context ) ; } else { result = tag <identifiersep> operation <identifiersep> result . not <identifiersep> allowed ; } } catch ( exception ex ) { <LOG> result = tag <identifiersep> operation <identifiersep> result . failed ; } return result ; } <comment> <ect>
observation <identifiersep> manager om = this . component <identifiersep> manager . get <identifiersep> instance ( observation <identifiersep> manager . class ) ; om . remove <identifiersep> listener ( get <identifiersep> name ( ) ) ; this . remote <identifiersep> observation <identifiersep> manager = this . component <identifiersep> manager . get <identifiersep> instance ( remote <identifiersep> observation <identifiersep> manager . class ) ; om . add <identifiersep> listener ( this ) ; this . remote <identifiersep> observation <identifiersep> manager . notify ( new local <identifiersep> event <identifiersep> data ( event , source , data ) ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } } else { this . remote <identifiersep> observation <identifiersep> manager . notify ( new local <identifiersep> event <identifiersep> data ( event , source , data ) ) ; } } } <ect>
throw new remote <identifiersep> event <identifiersep> exception ( <string_literal> + channel <identifiersep> id + <string_literal> , e ) ; } <comment> <LOG> } this . logger . info ( <string_literal> , channel <identifiersep> id ) ; } @ override public void stop <identifiersep> channel ( string channel <identifiersep> id ) throws remote <identifiersep> event <identifiersep> exception { j <identifiersep> channel channel = this . channels . get ( channel <identifiersep> id ) ; if ( channel == null ) { <ect>
result = super . get <identifiersep> property ( key , default <identifiersep> value ) ; } else { <comment> <LOG> result = null ; } } else { result = super . get <identifiersep> property ( key ) ; } return result ; } } <ect>
if ( this . send <identifiersep> mail <identifiersep> thread != null ) { this . send <identifiersep> mail <identifiersep> runnable . stop <identifiersep> processing ( ) ; <comment> <LOG> } <comment> <ect>
@ override public void dispose ( ) throws component <identifiersep> lifecycle <identifiersep> exception { try { stop <identifiersep> mail <identifiersep> threads ( ) ; } catch ( interrupted <identifiersep> exception e ) { <LOG> } } } <ect>
<comment> <LOG> break ; } catch ( exception e ) { <comment> <ect>
+ <string_literal> + <string_literal> , this . execution <identifiersep> directory ) ) ; } } private void wait <identifiersep> for <identifiersep> x <identifiersep> wiki <identifiersep> to <identifiersep> load ( ) throws exception { <comment> <LOG> response response = is <identifiersep> x <identifiersep> wiki <identifiersep> started ( get <identifiersep> url ( ) , timeout <identifiersep> seconds ) ; if ( response . timed <identifiersep> out ) { string message = string . format ( <string_literal> , timeout <identifiersep> seconds , response . response <identifiersep> code , new string ( response . response <identifiersep> body ) ) ; logger . info ( message ) ; stop ( ) ; <ect>
} finally { <comment> <LOG> } return response ; } public void stop ( ) throws exception { if ( ! should <identifiersep> start <identifiersep> xwiki ) { return ; } logger . debug ( <string_literal> , get <identifiersep> url ( ) ) ; <ect>
<comment> <LOG> } else { logger . info ( <string_literal> ) ; } } private void stop <identifiersep> internal ( ) throws exception { string stop <identifiersep> command = get <identifiersep> default <identifiersep> stop <identifiersep> command ( get <identifiersep> port ( ) , get <identifiersep> stop <identifiersep> port ( ) ) ; logger . debug ( <string_literal> , stop <identifiersep> command ) ; <ect>
logger . info ( <string_literal> , get <identifiersep> url ( ) ) ; } else { logger . info ( <string_literal> ) ; } } private void stop <identifiersep> internal ( ) throws exception { string stop <identifiersep> command = get <identifiersep> default <identifiersep> stop <identifiersep> command ( get <identifiersep> port ( ) , get <identifiersep> stop <identifiersep> port ( ) ) ; <LOG> default <identifiersep> execute <identifiersep> result <identifiersep> handler stop <identifiersep> process <identifiersep> handler = execute <identifiersep> command ( stop <identifiersep> command ) ; <comment> <ect>
security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( entity ) ; if ( entry == null ) { logger . debug ( <string_literal> , get <identifiersep> entry <identifiersep> key ( entity ) ) ; } return null ; } <LOG> } return ( security <identifiersep> rule <identifiersep> entry ) entry . get <identifiersep> entry ( ) ; } @ override public void remove ( user <identifiersep> security <identifiersep> reference user , security <identifiersep> reference entity ) { write <identifiersep> lock . lock ( ) ; try { <ect>
{ write <identifiersep> lock . lock ( ) ; try { security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( entity ) ; if ( entry != null ) { <LOG> } this . cache . remove ( entry . get <identifiersep> key ( ) ) ; } } finally { write <identifiersep> lock . unlock ( ) ; } } @ override public collection < group <identifiersep> security <identifiersep> reference > get <identifiersep> immediate <identifiersep> groups <identifiersep> for ( user <identifiersep> security <identifiersep> reference user ) { <ect>
if ( retries < max <identifiersep> retries ) { this . logger . debug ( <string_literal> , retries ) ; continue ; } } catch ( conflicting <identifiersep> insertion <identifiersep> exception e ) { last <identifiersep> exception = e ; if ( retries < max <identifiersep> retries ) { <LOG> continue ; } } finally { rules <identifiersep> invalidator . resume ( ) ; } string message = string . format ( <string_literal> , retries ) ; this . logger . error ( message ) ; throw new authorization <identifiersep> exception ( user . get <identifiersep> original <identifiersep> document <identifiersep> reference ( ) , entity . get <identifiersep> original <identifiersep> reference ( ) , <ect>
base <identifiersep> object extension <identifiersep> object <identifiersep> to <identifiersep> save = document . get <identifiersep> x <identifiersep> object ( extension <identifiersep> object . get <identifiersep> reference ( ) ) ; extension <identifiersep> object <identifiersep> to <identifiersep> save . set ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . prop <identifiersep> extension <identifiersep> lastversion , last <identifiersep> version , xcontext ) ; need <identifiersep> save = true ; } <comment> <LOG> } else { this . logger . debug ( <string_literal> , document . get <identifiersep> document <identifiersep> reference ( ) ) ; } int current <identifiersep> value = get <identifiersep> value ( extension <identifiersep> object , x <identifiersep> wiki <identifiersep> repository <identifiersep> model . prop <identifiersep> extension <identifiersep> validextension , 0 ) ; if ( ( current <identifiersep> value == 1 ) != valid ) { base <identifiersep> object extension <identifiersep> object <identifiersep> to <identifiersep> save = document . get <identifiersep> x <identifiersep> object ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extension <identifiersep> classreference ) ; extension <identifiersep> object <identifiersep> to <identifiersep> save . set ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . prop <identifiersep> extension <identifiersep> validextension , valid ? <string_literal> : <string_literal> , xcontext ) ; <ect>
query . bind <identifiersep> value ( <string_literal> , x <identifiersep> wiki <identifiersep> server <identifiersep> class <identifiersep> document <identifiersep> initializer . field <identifiersep> wikiprettyname ) ; query . bind <identifiersep> value ( <string_literal> , <string_literal> ) ; list < string > results = query . execute ( ) ; for ( string result : results ) { fix <identifiersep> document ( result ) ; } } catch ( query <identifiersep> exception e ) { <LOG> } } private void fix <identifiersep> document ( string document <identifiersep> name ) { x <identifiersep> wiki <identifiersep> context context = xcontext <identifiersep> provider . get ( ) ; x <identifiersep> wiki xwiki = context . get <identifiersep> wiki ( ) ; document <identifiersep> reference document <identifiersep> reference = document <identifiersep> reference <identifiersep> resolver . resolve ( document <identifiersep> name ) ; try { <ect>
string wiki <identifiersep> id = descriptor . get <identifiersep> id ( ) ; for ( string property <identifiersep> group <identifiersep> name : property <identifiersep> group <identifiersep> providers . key <identifiersep> set ( ) ) { wiki <identifiersep> property <identifiersep> group <identifiersep> provider provider = property <identifiersep> group <identifiersep> providers . get ( property <identifiersep> group <identifiersep> name ) ; try { descriptor . add <identifiersep> property <identifiersep> group ( provider . get ( wiki <identifiersep> id ) ) ; } catch ( wiki <identifiersep> property <identifiersep> group <identifiersep> exception e ) { <LOG> } } } @ override public void save <identifiersep> for <identifiersep> descriptor ( wiki <identifiersep> descriptor descriptor ) throws wiki <identifiersep> property <identifiersep> group <identifiersep> exception { string wiki <identifiersep> id = descriptor . get <identifiersep> id ( ) ; for ( string property <identifiersep> group <identifiersep> name : property <identifiersep> group <identifiersep> providers . key <identifiersep> set ( ) ) { wiki <identifiersep> property <identifiersep> group group = descriptor . get <identifiersep> property <identifiersep> group ( property <identifiersep> group <identifiersep> name ) ; <ect>
try { for ( string document <identifiersep> full <identifiersep> name : document <identifiersep> fullnames ) { this . progress . start <identifiersep> step ( this ) ; document <identifiersep> reference orig <identifiersep> doc <identifiersep> reference = document <identifiersep> reference <identifiersep> resolver . resolve ( document <identifiersep> full <identifiersep> name , from <identifiersep> wiki <identifiersep> reference ) ; document <identifiersep> reference new <identifiersep> doc <identifiersep> reference = orig <identifiersep> doc <identifiersep> reference . set <identifiersep> wiki <identifiersep> reference ( new wiki <identifiersep> reference ( to <identifiersep> wiki <identifiersep> id ) ) ; <LOG> xwiki . copy <identifiersep> document ( orig <identifiersep> doc <identifiersep> reference , new <identifiersep> doc <identifiersep> reference , null , ! with <identifiersep> history , true , context ) ; logger . info ( <string_literal> , orig <identifiersep> doc <identifiersep> reference , new <identifiersep> doc <identifiersep> reference ) ; this . progress . end <identifiersep> step ( this ) ; } } finally { this . progress . pop <identifiersep> level <identifiersep> progress ( this ) ; this . progress . end <identifiersep> step ( this ) ; <ect>
if ( ! is <identifiersep> authorized <identifiersep> extension ( request . get <identifiersep> extension <identifiersep> id ( ) ) ) { throw new wiki <identifiersep> creation <identifiersep> exception ( string . format ( <string_literal> , request . get <identifiersep> extension <identifiersep> id ( ) ) ) ; } } return wiki <identifiersep> creator . create <identifiersep> wiki ( request ) ; } catch ( wiki <identifiersep> creation <identifiersep> exception e ) { set <identifiersep> last <identifiersep> error ( e ) ; <LOG> } catch ( access <identifiersep> denied <identifiersep> exception e ) { set <identifiersep> last <identifiersep> error ( e ) ; } return null ; } private boolean is <identifiersep> authorized <identifiersep> extension ( extension <identifiersep> id extension <identifiersep> id ) { extension <identifiersep> id default <identifiersep> extension = get <identifiersep> default <identifiersep> wiki <identifiersep> extension <identifiersep> id ( ) ; <ect>
<comment> public int get <identifiersep> height ( string page <identifiersep> name , string attachment <identifiersep> name ) { try { return get <identifiersep> protected <identifiersep> plugin ( ) . get <identifiersep> height ( get <identifiersep> attachment ( page <identifiersep> name , attachment <identifiersep> name ) , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; } catch ( exception e ) { <LOG> return - 1 ; } } <comment> <ect>
<string_literal> + <string_literal> , this . capacity ) , e ) ; } } lru . set <identifiersep> max <identifiersep> entries ( this . capacity ) ; try { this . image <identifiersep> cache = utils . get <identifiersep> component ( cache <identifiersep> manager . class ) . create <identifiersep> new <identifiersep> local <identifiersep> cache ( configuration ) ; } catch ( cache <identifiersep> exception e ) { <LOG> } } } @ override public void flush <identifiersep> cache ( ) { if ( this . image <identifiersep> cache != null ) { this . image <identifiersep> cache . dispose ( ) ; } this . image <identifiersep> cache = null ; <ect>
public list < string > list <identifiersep> captcha <identifiersep> names ( ) { list < string > captcha <identifiersep> names = new array <identifiersep> list < string > ( ) ; try { captcha <identifiersep> names . add <identifiersep> all ( component <identifiersep> manager . get <identifiersep> instance <identifiersep> map ( captcha <identifiersep> verifier . class ) . key <identifiersep> set ( ) ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> } return captcha <identifiersep> names ; } @ override @ deprecated public boolean is <identifiersep> enabled ( ) { return true ; <ect>
+ <string_literal> , query . xwql ) ; q . bind <identifiersep> value ( <string_literal> , this . serializer . serialize ( this . bridge . get <identifiersep> current <identifiersep> user <identifiersep> reference ( ) ) ) ; q . set <identifiersep> limit ( limit > 0 ? limit : <number_literal> ) . set <identifiersep> offset ( offset >= 0 ? offset : 0 ) ; result = this . stream . search <identifiersep> events ( q ) ; } catch ( query <identifiersep> exception ex ) { <LOG> } return result ; } @ override public list < event > get <identifiersep> recent <identifiersep> messages <identifiersep> for <identifiersep> group ( document <identifiersep> reference group ) { return get <identifiersep> recent <identifiersep> messages <identifiersep> for <identifiersep> group ( group , <number_literal> , 0 ) ; } @ override <ect>
string result = <string_literal> ; try { base <identifiersep> object watch <identifiersep> object = get <identifiersep> watch <identifiersep> list <identifiersep> object ( user ) ; result = watch <identifiersep> object . get <identifiersep> string <identifiersep> value ( watch <identifiersep> list <identifiersep> class <identifiersep> document <identifiersep> initializer . interval <identifiersep> property ) ; } catch ( exception e ) { <comment> <LOG> } return result ; } @ override public collection < string > get <identifiersep> subscribers ( string interval <identifiersep> id ) { return notification <identifiersep> cache . get ( ) . get <identifiersep> subscribers ( interval <identifiersep> id ) ; } } <ect>
notification <identifiersep> data . put ( watch <identifiersep> list <identifiersep> event <identifiersep> mime <identifiersep> message <identifiersep> factory . template <identifiersep> parameter , realtime <identifiersep> email <identifiersep> template ) ; notification <identifiersep> data . put ( watch <identifiersep> list <identifiersep> event <identifiersep> mime <identifiersep> message <identifiersep> factory . skip <identifiersep> context <identifiersep> user <identifiersep> parameter , true ) ; notification <identifiersep> data . put ( watch <identifiersep> list <identifiersep> event <identifiersep> mime <identifiersep> message <identifiersep> factory . attach <identifiersep> author <identifiersep> avatars <identifiersep> parameter , true ) ; <comment> <LOG> } } <comment> <ect>
<comment> <LOG> return null ; } private void fix <identifiersep> class <identifiersep> property ( base <identifiersep> class bclass , string name , string pretty <identifiersep> name ) { property <identifiersep> interface property = bclass . get ( name ) ; if ( ! ( property instanceof db <identifiersep> list <identifiersep> class ) ) { bclass . remove <identifiersep> field ( name ) ; <ect>
<comment> protected dashboard <identifiersep> renderer get <identifiersep> dashboard <identifiersep> renderer ( string layout ) { try { return this . component <identifiersep> manager . get <identifiersep> instance ( dashboard <identifiersep> renderer . class , layout ) ; } catch ( component <identifiersep> lookup <identifiersep> exception e ) { <LOG> return null ; } } <comment> <ect>
xml <identifiersep> reader . next <identifiersep> tag ( ) ; file directory = new file ( path ) ; if ( ! directory . exists ( ) ) { this . logger . warn ( <string_literal> , directory ) ; continue ; } if ( ! directory . is <identifiersep> directory ( ) ) { <LOG> continue ; } store <identifiersep> deleted <identifiersep> attachment ( directory , id , session ) ; } } } } private void store <identifiersep> deleted <identifiersep> attachment ( file directory , long id , session session ) throws parser <identifiersep> configuration <identifiersep> exception , sax <identifiersep> exception , io <identifiersep> exception { this . logger . info ( <string_literal> , directory ) ; <ect>
for ( file child : file . list <identifiersep> files ( ) ) { migrate <identifiersep> with <identifiersep> children ( child ) ; } } } private file migrate ( file file , boolean case <identifiersep> insensitive ) throws io <identifiersep> exception { file new <identifiersep> file = encode ( file , case <identifiersep> insensitive ) ; if ( ! new <identifiersep> file . equals ( file ) ) { <LOG> <comment> <ect>
<comment> private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( status <identifiersep> listener . class ) ; @ override public void job <identifiersep> scheduled ( trigger trigger ) { <LOG> } @ override public void job <identifiersep> unscheduled ( trigger <identifiersep> key key ) { logger . info ( <string_literal> , key ) ; } @ override public void trigger <identifiersep> finalized ( trigger trigger ) <ect>
@ override public void trigger <identifiersep> resumed ( trigger <identifiersep> key trigger <identifiersep> key ) { } @ override public void job <identifiersep> paused ( job <identifiersep> key job <identifiersep> key ) { <LOG> } @ override public void job <identifiersep> resumed ( job <identifiersep> key job <identifiersep> key ) { logger . info ( <string_literal> , job <identifiersep> key ) ; } @ override public void scheduler <identifiersep> error ( string message , scheduler <identifiersep> exception error ) <ect>
<comment> if ( typeof x <identifiersep> wiki . widgets == 'object' && typeof x <identifiersep> wiki . widgets . full <identifiersep> screen == 'function' ) { x <identifiersep> wiki . editors = x <identifiersep> wiki . editors || { } ; x <identifiersep> wiki . editors . full <identifiersep> screen <identifiersep> editing = class . create ( x <identifiersep> wiki . widgets . full <identifiersep> screen , { initialize : function ( $super ) { <LOG> $super ( ) ; } } ) ; } <comment> <ect>
 <identifiersep> xwk = window ; } <comment>  <identifiersep> xwk . ajax <identifiersep> suggest = class . create ( x <identifiersep> wiki . widgets . suggest , { initialize : function ( $super ) { <LOG> var args = $a ( arguments ) args . shift ( ) ; $super . apply (  <identifiersep> xwk , args ) ; } } ) ; <comment> <ect>
<comment> if ( typeof x <identifiersep> wiki . widgets == <string_literal> && typeof x <identifiersep> wiki . widgets . live <identifiersep> table == <string_literal> ) { window . ass <identifiersep> table = class . create ( x <identifiersep> wiki . widgets . live <identifiersep> table , { initialize : function ( $super , url , limit , dom <identifiersep> node , scroll <identifiersep> node , filter <identifiersep> node , get <identifiersep> handler , has <identifiersep> filters , action ) { <comment> <LOG> if ( $ ( <string_literal> ) ) { <comment> <ect>
<comment> window . toggle <identifiersep> form = function ( form ) { <LOG> var fieldset = form . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) . item ( 0 ) ; if ( fieldset . class <identifiersep> name == <string_literal> ) { fieldset . class <identifiersep> name = <string_literal> ; } else { fieldset . class <identifiersep> name = <string_literal> ; } } <comment> <ect>
<comment> <LOG> -- this .  <identifiersep> anim <identifiersep> count ; <comment> <ect>
<comment> remove <identifiersep> children : function ( node ) { <LOG> while ( node . children . length ) { this .  <identifiersep> delete <identifiersep> node ( node . children [ 0 ] ) ; } node . children <identifiersep> rendered = false ; node . dynamic <identifiersep> load <identifiersep> complete = false ; <comment> <ect>
<comment> insert <identifiersep> after : function ( node ) { <LOG> var p = node . parent ; if ( p ) { if ( this . tree ) { this . tree . pop <identifiersep> node ( this ) ; } var ref <identifiersep> index = node . is <identifiersep> child <identifiersep> of ( p ) ; this . logger . log ( ref <identifiersep> index ) ; <ect>
collapse : function ( ) { <comment> <LOG> return ; } if ( ! this . get <identifiersep> el ( ) ) { this . expanded = false ; return ; } <comment> <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
<comment> fire <identifiersep> legacy <identifiersep> event : function ( e , legacy <identifiersep> index ) { <LOG> var ok = true ; var le = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; for ( var i = 0 , len = le . length ; i < len ; ++ i ) { var li = le [ i ] ; if ( li && li [ this . wfn ] ) { var scope = li [ this . adj <identifiersep> scope ] ; <ect>
<comment> <LOG> return false ; } <comment> <ect>
li [ this . el ] == el && li [ this . type ] == s <identifiersep> type && li [ this . fn ] == fn ) { llist . splice ( i , 1 ) ; } } } } else if ( el . remove <identifiersep> event <identifiersep> listener ) { el . remove <identifiersep> event <identifiersep> listener ( s <identifiersep> type , cache <identifiersep> item [ this . wfn ] , false ) ; <LOG> } else if ( el . detach <identifiersep> event ) { el . detach <identifiersep> event ( <string_literal> + s <identifiersep> type , cache <identifiersep> item [ this . wfn ] ) ; } <comment> <ect>
<comment> <LOG> this . on ( el , d [ this . type ] , d [ this . fn ] , d [ this . scope ] , d [ this . adj <identifiersep> scope ] ) ; delete delayed <identifiersep> listeners [ i ] ; } else { still <identifiersep> delayed . push ( d ) ; } } } delayed <identifiersep> listeners = still <identifiersep> delayed ; <ect>
try { wiki <identifiersep> descriptor descriptor = utils . get <identifiersep> component ( wiki <identifiersep> descriptor <identifiersep> manager . class ) . get <identifiersep> by <identifiersep> alias ( host ) ; if ( descriptor != null ) { return new document <identifiersep> reference ( context . get <identifiersep> main <identifiersep> x <identifiersep> wiki ( ) , <string_literal> , <string_literal> + string <identifiersep> utils . capitalize ( descriptor . get <identifiersep> id ( ) ) ) ; } } catch ( wiki <identifiersep> manager <identifiersep> exception e ) { <LOG> } return null ; } <comment> <ect>
mail <identifiersep> sender = get <identifiersep> plugin <identifiersep> api ( <string_literal> , context ) ; mail <identifiersep> sender <identifiersep> class = class . for <identifiersep> name ( <string_literal> ) ; <comment> <LOG> send <identifiersep> message <identifiersep> old ( sender , recipients , raw <identifiersep> message , context ) ; return ; logger . trace ( <string_literal> + raw <identifiersep> message + <string_literal> ) ; } string message <identifiersep> recipients = string <identifiersep> utils . join ( recipients , ' , ' ) ; try { <ect>
} else { throw new runtime <identifiersep> exception ( cause ) ; } } catch ( exception e ) { <comment> <LOG> } <comment> @ deprecated private void x <identifiersep> wiki . send <identifiersep> message <identifiersep> old ( string sender , string [ ] recipient , string message , x <identifiersep> wiki <identifiersep> context context ) <ect>
} ; } private x <identifiersep> wiki <identifiersep> notification <identifiersep> manager get <identifiersep> notification <identifiersep> manager ( x <identifiersep> wiki <identifiersep> context context ) { try { return ( x <identifiersep> wiki <identifiersep> notification <identifiersep> manager ) x <identifiersep> wiki . class . get <identifiersep> method ( <string_literal> ) . invoke ( context . get <identifiersep> wiki ( ) ) ; } catch ( exception e ) { <LOG> } return null ; } @ override public void on <identifiersep> event ( event event , object source , object data ) { x <identifiersep> wiki <identifiersep> document document = ( x <identifiersep> wiki <identifiersep> document ) source ; x <identifiersep> wiki <identifiersep> document original <identifiersep> document = document . get <identifiersep> original <identifiersep> document ( ) ; <ect>
document <identifiersep> reference reference = entry . get <identifiersep> key ( ) ; <comment> <LOG> <comment> <ect>
try { current <identifiersep> document . load <identifiersep> attachments <identifiersep> content <identifiersep> safe ( xcontext ) ; if ( ! current <identifiersep> document . equals <identifiersep> data ( previous <identifiersep> document ) ) { <comment> <LOG> <comment> <ect>
packager . delete <identifiersep> document ( entry . get <identifiersep> key ( ) , configuration ) ; } } } finally { <comment> <LOG> } context . set <identifiersep> property ( xar <identifiersep> extension <identifiersep> plan . contextkey <identifiersep> xarinstallplan , null ) ; } } } } } private package <identifiersep> configuration create <identifiersep> package <identifiersep> configuration ( request request ) { return create <identifiersep> package <identifiersep> configuration ( request , null ) ; } private package <identifiersep> configuration create <identifiersep> package <identifiersep> configuration ( request request , string wiki ) { <ect>
{ execution <identifiersep> context context = this . execution . get <identifiersep> context ( ) ; if ( context != null && context . get <identifiersep> property ( xar <identifiersep> extension <identifiersep> plan . contextkey <identifiersep> xarinstallplan ) == null ) { extension <identifiersep> plan plan = ( extension <identifiersep> plan ) context . get <identifiersep> property ( abstract <identifiersep> extension <identifiersep> job . contextkey <identifiersep> plan ) ; if ( plan != null ) { if ( request . is <identifiersep> verbose ( ) ) { <LOG> } context . set <identifiersep> property ( xar <identifiersep> extension <identifiersep> plan . contextkey <identifiersep> xarinstallplan , new xar <identifiersep> extension <identifiersep> plan ( plan , this . xar <identifiersep> repository , this . local <identifiersep> repository ) ) ; if ( request . is <identifiersep> verbose ( ) ) { this . logger . info ( log <identifiersep> extensionplan <identifiersep> end , <string_literal> ) ; } } } } private xar <identifiersep> extension <identifiersep> plan get <identifiersep> xar <identifiersep> extension <identifiersep> plan ( ) { <ect>
return ; } } } else { return ; } <comment> <LOG> } } } <ect>
public boolean create ( document <identifiersep> reference document <identifiersep> reference ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { x <identifiersep> wiki <identifiersep> document new <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , xcontext ) ; xcontext . get <identifiersep> wiki ( ) . save <identifiersep> document ( new <identifiersep> document , xcontext ) ; <LOG> return true ; } catch ( exception e ) { this . logger . error ( <string_literal> , document <identifiersep> reference , e ) ; return false ; } } @ override public boolean copy ( document <identifiersep> reference source , document <identifiersep> reference destination ) <ect>
x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { string language = source . get <identifiersep> locale ( ) != null ? source . get <identifiersep> locale ( ) . to <identifiersep> string ( ) : null ; boolean result = xcontext . get <identifiersep> wiki ( ) . copy <identifiersep> document ( source , destination , language , false , true , true , xcontext ) ; if ( result ) { <LOG> } else { this . logger . warn ( <string_literal> + <string_literal> , source , destination ) ; } return result ; } catch ( exception e ) { <ect>
{ x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { x <identifiersep> wiki <identifiersep> document document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( reference , xcontext ) ; if ( document . get <identifiersep> translation ( ) == 1 ) { xcontext . get <identifiersep> wiki ( ) . delete <identifiersep> document ( document , xcontext ) ; <LOG> } else { xcontext . get <identifiersep> wiki ( ) . delete <identifiersep> all <identifiersep> documents ( document , xcontext ) ; this . logger . info ( <string_literal> , reference ) ; } return true ; } catch ( exception e ) { this . logger . error ( <string_literal> , reference , e ) ; <ect>
<comment> <LOG> } else if ( this . model <identifiersep> bridge . exists ( new <identifiersep> document <identifiersep> reference ) ) { <comment> <ect>
if ( request . get <identifiersep> skipped <identifiersep> entities ( ) . contains ( new <identifiersep> document <identifiersep> reference ) ) { this . logger . debug ( <string_literal> , new <identifiersep> document <identifiersep> reference ) ; } else if ( this . model <identifiersep> bridge . exists ( new <identifiersep> document <identifiersep> reference ) ) { <comment> <LOG> } else if ( template <identifiersep> document <identifiersep> reference == null ) { <comment> <ect>
<comment> <LOG> } else { this . model <identifiersep> bridge . copy ( template <identifiersep> document <identifiersep> reference , new <identifiersep> document <identifiersep> reference ) ; } } } <ect>
{ context . get <identifiersep> util ( ) . set <identifiersep> default <identifiersep> credentials ( test <identifiersep> utils . admin <identifiersep> credentials ) ; <comment> <LOG> context . get <identifiersep> util ( ) . disable <identifiersep> syntax <identifiersep> highlighting ( ) ; } } <ect>
