<comment> try { file <identifiersep> icon = new j <identifiersep> file <identifiersep> chooser ( ) . get <identifiersep> icon ( file ) ; } catch ( exception e1 ) <LOG> { } } return file <identifiersep> icon ; } } <ect>
<comment> private static final random random = new random ( ) ; static { string prefer6 = system . get <identifiersep> property ( <string_literal> ) ; string prefer4 = system . get <identifiersep> property ( <string_literal> ) ; <LOG> logger . info ( <string_literal> + prefer6 ) ; } <comment> <ect>
org . xbill . dns . srv <identifiersep> record srv <identifiersep> record = ( org . xbill . dns . srv <identifiersep> record ) records [ i ] ; srv <identifiersep> records [ i ] = new srv <identifiersep> record ( srv <identifiersep> record ) ; } <comment> <LOG> { for ( int i = 0 ; i < srv <identifiersep> records . length ; i ++ ) { logger . trace ( srv <identifiersep> records [ i ] ) ; } } return srv <identifiersep> records ; <ect>
catch ( io <identifiersep> exception exc ) { logger . warn ( <string_literal> , exc ) ; return ; } <LOG> array <identifiersep> list < string > args <identifiersep> list = new array <identifiersep> list < string > ( ) ; int arg <identifiersep> count = <number_literal> ; try { buffered <identifiersep> reader line <identifiersep> reader = new buffered <identifiersep> reader ( new input <identifiersep> stream <identifiersep> reader ( is ) ) ; <ect>
<comment> public int handle <identifiersep> args ( string [ ] args ) { int return <identifiersep> action = action <identifiersep> continue ; for ( int i = 0 ; i < args . length ; i ++ ) <LOG> { if ( args [ i ] . equals ( <string_literal> ) || args [ i ] . equals ( <string_literal> ) ) { handle <identifiersep> version <identifiersep> arg ( ) ; <comment> <ect>
if ( config <identifiersep> arg . starts <identifiersep> with ( <string_literal> ) ) { config <identifiersep> arg = config <identifiersep> arg . substring ( <string_literal> . length ( ) ) ; } file config <identifiersep> dir = new file ( config <identifiersep> arg ) ; config <identifiersep> dir . mkdirs ( ) ; if ( ! config <identifiersep> dir . is <identifiersep> directory ( ) ) <LOG> { error <identifiersep> code = error <identifiersep> code <identifiersep> create <identifiersep> dir <identifiersep> failed ; return action <identifiersep> error ; } system . set <identifiersep> property ( pname <identifiersep> sc <identifiersep> home <identifiersep> dir <identifiersep> location , config <identifiersep> dir . get <identifiersep> parent ( ) ) ; system . set <identifiersep> property ( pname <identifiersep> sc <identifiersep> cache <identifiersep> dir <identifiersep> location , config <identifiersep> dir . get <identifiersep> parent ( ) ) ; system . set <identifiersep> property ( pname <identifiersep> sc <identifiersep> log <identifiersep> dir <identifiersep> location , config <identifiersep> dir . get <identifiersep> parent ( ) ) ; <ect>
<comment> static int get <identifiersep> status ( messenger <identifiersep> contact messenger <identifiersep> contact ) { string signin <identifiersep> name = messenger <identifiersep> contact . signin <identifiersep> name ; <LOG> protocol <identifiersep> presence <identifiersep> status presence <identifiersep> status ; if ( signin <identifiersep> name == null ) presence <identifiersep> status = null ; else { self self = get <identifiersep> self ( signin <identifiersep> name ) ; <ect>
public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <comment> <LOG> return ; ms <identifiersep> office <identifiersep> comm <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; messenger . start ( bundle <identifiersep> context ) ; boolean stop <identifiersep> messenger = true ; try <ect>
try { west <identifiersep> icon <identifiersep> label . set <identifiersep> icon ( new image <identifiersep> icon ( image <identifiersep> io . read ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( resources . get <identifiersep> image ( resources . page <identifiersep> image ) ) ) ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { } this . west <identifiersep> panel . add ( west <identifiersep> icon <identifiersep> label , border <identifiersep> layout . north ) ; this . main <identifiersep> panel . add ( west <identifiersep> panel , border <identifiersep> layout . west ) ; <comment> <ect>
height = rect . get <identifiersep> height ( ) ; boolean fill = rect . is <identifiersep> fill ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> rect ( id , t , c , p , width , height , fill ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> circle ) { <LOG> whiteboard <identifiersep> object <identifiersep> circle circle = ( whiteboard <identifiersep> object <identifiersep> circle ) wbo ; color c = color . get <identifiersep> color ( <string_literal> , color ) ; whiteboard <identifiersep> point p = circle . get <identifiersep> whiteboard <identifiersep> point ( ) ; double r = circle . get <identifiersep> radius ( ) ; boolean fill = circle . is <identifiersep> fill ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> circle ( id , t , c , p , r , fill ) ; <ect>
int size = text . get <identifiersep> font <identifiersep> size ( ) ; string txt = text . get <identifiersep> text ( ) ; w <identifiersep> shape = new whiteboard <identifiersep> shape <identifiersep> text ( id , c , p , size , txt ) ; } else if ( wbo instanceof whiteboard <identifiersep> object <identifiersep> image ) { <LOG> whiteboard <identifiersep> object <identifiersep> image img = ( whiteboard <identifiersep> object <identifiersep> image ) wbo ; double height , width ; whiteboard <identifiersep> point p = img . get <identifiersep> whiteboard <identifiersep> point ( ) ; width = img . get <identifiersep> width ( ) ; height = img . get <identifiersep> height ( ) ; byte [ ] b = img . get <identifiersep> background <identifiersep> image ( ) ; <ect>
@ override protected plugin <identifiersep> component get <identifiersep> plugin <identifiersep> instance ( ) { return new whiteboard <identifiersep> menu <identifiersep> item ( session , this ) ; } } , <LOG> container <identifiersep> filter ) ; } <comment> <ect>
} ) . start ( ) ; } <comment> private void trace <identifiersep> current <identifiersep> pp <identifiersep> state ( ) <LOG> { logger . trace ( <string_literal> + auto <identifiersep> reconn <identifiersep> enabled <identifiersep> providers . key <identifiersep> set ( ) ) ; logger . trace ( <string_literal> + currently <identifiersep> reconnecting . key <identifiersep> set ( ) ) ; logger . trace ( <string_literal> + needs <identifiersep> reconnection ) ; <ect>
{ logger . trace ( <string_literal> + connected <identifiersep> interfaces ) ; logger . trace ( <string_literal> + auto <identifiersep> reconn <identifiersep> enabled <identifiersep> providers . key <identifiersep> set ( ) ) ; logger . trace ( <string_literal> + currently <identifiersep> reconnecting . key <identifiersep> set ( ) ) ; <LOG> logger . trace ( <string_literal> + needs <identifiersep> reconnection ) ; logger . trace ( <string_literal> ) ; } <comment> <ect>
pp , new array <identifiersep> list < string > ( connected <identifiersep> interfaces ) ) ; if ( currently <identifiersep> reconnecting . contains <identifiersep> key ( pp ) ) currently <identifiersep> reconnecting . remove ( pp ) . cancel ( ) ; unregistering <identifiersep> providers . remove ( pp ) ; <LOG> { trace <identifiersep> current <identifiersep> pp <identifiersep> state ( ) ; } } else if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) || is <identifiersep> server <identifiersep> returned <identifiersep> erroneous <identifiersep> input <identifiersep> event ) { <comment> <ect>
<comment> <LOG> { } } else { logger . debug ( <string_literal> ) ; } } else if ( e . get <identifiersep> source ( ) == program <identifiersep> file <identifiersep> button ) <ect>
file file = program <identifiersep> file <identifiersep> chooser . get <identifiersep> file <identifiersep> from <identifiersep> dialog ( ) ; if ( file != null ) { <comment> <LOG> <comment> <ect>
{ logger . debug ( <string_literal> ) ; } } else if ( e . get <identifiersep> source ( ) == play <identifiersep> sound <identifiersep> button ) { <LOG> string sound <identifiersep> file = sound <identifiersep> file <identifiersep> text <identifiersep> field . get <identifiersep> text ( ) ; if ( sound <identifiersep> file . length ( ) != 0 ) { audio <identifiersep> notifier <identifiersep> service audio <identifiersep> notif <identifiersep> serv = notification <identifiersep> configuration <identifiersep> activator . get <identifiersep> audio <identifiersep> notifier <identifiersep> service ( ) ; <ect>
<comment> provisioning <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . store <identifiersep> configuration ( ) ; provisioning <identifiersep> activator . get <identifiersep> configuration <identifiersep> service ( ) . reload <identifiersep> configuration ( ) ; } catch ( exception e ) <LOG> { } } catch ( io <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } finally { <ect>
else if ( key . ends <identifiersep> with ( <string_literal> ) ) { <comment> provisioning <identifiersep> activator . get <identifiersep> credentials <identifiersep> storage <identifiersep> service ( ) . store <identifiersep> password ( key . substring ( 0 , key . last <identifiersep> index <identifiersep> of ( <string_literal> ) ) , <LOG> ( string ) value ) ; return ; } else if ( key . starts <identifiersep> with ( system <identifiersep> prop <identifiersep> prefix ) ) { string sys <identifiersep> key = key . substring ( system <identifiersep> prop <identifiersep> prefix . length ( ) , key . length ( ) ) ; <ect>
file jar = null ; try { jar = resources . get <identifiersep> resources ( ) . prepare <identifiersep> skin <identifiersep> bundle <identifiersep> from <identifiersep> zip ( new <identifiersep> bundle <identifiersep> file ) ; } catch ( exception ex ) <LOG> { skin <identifiersep> manager <identifiersep> activator . get <identifiersep> ui <identifiersep> service ( ) . get <identifiersep> popup <identifiersep> dialog ( ) . show <identifiersep> message <identifiersep> popup <identifiersep> dialog ( ex . get <identifiersep> class ( ) + <string_literal> + ex . get <identifiersep> message ( ) , <string_literal> , popup <identifiersep> dialog . error <identifiersep> message ) ; } if ( jar != null ) <ect>
dialog = new master <identifiersep> password <identifiersep> input <identifiersep> dialog ( ) ; dialog . rebuild <identifiersep> main <identifiersep> panel ( ! prev <identifiersep> success ) ; dialog . reset <identifiersep> password ( ) ; <comment> <LOG> { } return dialog . password ; } <comment> <ect>
{ swing <identifiersep> utilities . invoke <identifiersep> and <identifiersep> wait ( creator ) ; } catch ( interrupted <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } catch ( invocation <identifiersep> target <identifiersep> exception e ) <LOG> { } return creator . authentication <identifiersep> window ; } } , null ) ; } <comment> <ect>
verify <identifiersep> certificate <identifiersep> dialog <identifiersep> creator creator = new verify <identifiersep> certificate <identifiersep> dialog <identifiersep> creator ( certs , title , message ) ; try { swing <identifiersep> utilities . invoke <identifiersep> and <identifiersep> wait ( creator ) ; } catch ( interrupted <identifiersep> exception e ) <LOG> { } catch ( invocation <identifiersep> target <identifiersep> exception e ) { logger . error ( <string_literal> , e ) ; } return creator . dialog ; } <comment> <ect>
<string_literal> + <string_literal> + <string_literal> + <string_literal> + listener , <LOG> throwable ) ; } } <comment> <ect>
string stored <identifiersep> account = stored <identifiersep> account <identifiersep> iter . next ( ) ; <comment> <LOG> continue ; list < string > stored <identifiersep> account <identifiersep> properties = config <identifiersep> service . get <identifiersep> property <identifiersep> names <identifiersep> by <identifiersep> prefix ( stored <identifiersep> account , false ) ; map < string , string > account <identifiersep> properties = new hashtable < string , string > ( ) ; boolean disabled = false ; <ect>
bundle <identifiersep> context , credentials <identifiersep> storage <identifiersep> service . class ) ; credentials <identifiersep> storage . remove <identifiersep> password ( factory <identifiersep> package + <string_literal> + account <identifiersep> node <identifiersep> name ) ; } if ( configuration <identifiersep> properties . size ( ) > 0 ) <LOG> configuration <identifiersep> service . set <identifiersep> properties ( configuration <identifiersep> properties ) ; + <string_literal> + factory <identifiersep> package ) ; } <comment> <ect>
= forget <identifiersep> presence <identifiersep> status ( pps ) ; if ( ( presence <identifiersep> status != null ) && on <identifiersep> the <identifiersep> phone <identifiersep> presence <identifiersep> status . equals ( presence . get <identifiersep> presence <identifiersep> status ( ) ) ) { <LOG> { } publish <identifiersep> presence <identifiersep> status ( presence , presence <identifiersep> status ) ; } } } else { { <ect>
<comment> public void service <identifiersep> changed ( service <identifiersep> event ev ) { <LOG> { } single <identifiersep> call <identifiersep> in <identifiersep> progress <identifiersep> policy . this . service <identifiersep> changed ( ev ) ; } } } <ect>
return ; collection < file <identifiersep> transfer <identifiersep> status <identifiersep> listener > listeners = null ; synchronized ( status <identifiersep> listeners ) { listeners <LOG> = new array <identifiersep> list < file <identifiersep> transfer <identifiersep> status <identifiersep> listener > ( status <identifiersep> listeners ) ; } + <string_literal> + status ) ; file <identifiersep> transfer <identifiersep> status <identifiersep> change <identifiersep> event status <identifiersep> event = new file <identifiersep> transfer <identifiersep> status <identifiersep> change <identifiersep> event ( this , status , new <identifiersep> status , reason ) ; <comment> <ect>
<comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception { <LOG> provisioning <identifiersep> discovery <identifiersep> dhcp <identifiersep> activator . bundle <identifiersep> context = null ; } <comment> <ect>
t . cancel ( ) ; } return new string ( opt <identifiersep> provisioning . get <identifiersep> value ( ) ) ; } } } catch ( socket <identifiersep> timeout <identifiersep> exception est ) { logger . warn ( <string_literal> , est ) ; } } catch ( exception e ) <LOG> { } for ( dhcp <identifiersep> transaction t : transactions ) { t . cancel ( ) ; } return null ; } <comment> <ect>
{ int rand = new random ( ) . next <identifiersep> int ( <number_literal> ) - 1 ; try { sock . send ( message ) ; } catch ( exception e ) <LOG> { } nb <identifiersep> retransmit ++ ; if ( nb <identifiersep> retransmit < max <identifiersep> retransmit ) { timer . schedule ( new retransmission <identifiersep> handler ( ) , ( interval + rand ) * <number_literal> ) ; <ect>
logger . debug ( <string_literal> , e ) ; this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( unsupported <identifiersep> operation <identifiersep> exception e ) <LOG> { this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( security <identifiersep> exception e ) <ect>
logger . debug ( <string_literal> , e ) ; this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { this . show <identifiersep> error <identifiersep> message ( resources . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) ) ; } catch ( exception e ) <ect>
{ service <identifiersep> utils . get <identifiersep> service ( gui <identifiersep> activator . bundle <identifiersep> context , message <identifiersep> history <identifiersep> service . class ) . erase <identifiersep> locally <identifiersep> stored <identifiersep> history ( ( ( chat <identifiersep> room <identifiersep> wrapper ) desc ) . get <identifiersep> chat <identifiersep> room ( ) ) ; } } catch ( io <identifiersep> exception ex ) <LOG> { chat <identifiersep> panel . add <identifiersep> error <identifiersep> message ( destination , gui <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> i18n <identifiersep> string ( <string_literal> ) , ex . get <identifiersep> localized <identifiersep> message ( ) ) ; } } } else if ( menu <identifiersep> item <identifiersep> name . equals ( <string_literal> ) ) <ect>
element elem = document . get <identifiersep> element ( message <identifiersep> id ) ; document . set <identifiersep> outer <identifiersep> html ( elem , new <identifiersep> message ) ; } catch ( bad <identifiersep> location <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } catch ( io <identifiersep> exception ex ) <LOG> { } } } } @ override public object construct ( ) throws exception { matcher div <identifiersep> matcher = div <identifiersep> pattern . matcher ( chat <identifiersep> string ) ; string opening <identifiersep> tag = <string_literal> ; <ect>
message <identifiersep> type , msg . get <identifiersep> content ( ) , msg . get <identifiersep> content <identifiersep> type ( ) , msg . get <identifiersep> message <identifiersep> uid ( ) , null ) ; } else <LOG> { } } <comment> <ect>
<comment> public void update <identifiersep> close <identifiersep> action ( boolean can <identifiersep> hide ) { if ( configuration <identifiersep> utils . is <identifiersep> minimize <identifiersep> instead <identifiersep> of <identifiersep> hide ( ) ) <LOG> { set <identifiersep> default <identifiersep> close <identifiersep> operation ( j <identifiersep> frame . do <identifiersep> nothing <identifiersep> on <identifiersep> close ) ; } else { logger . info ( <string_literal> + ( can <identifiersep> hide ? <string_literal> <ect>
description . append ( <string_literal> ) ; recorder recorder ; try { recorder = get <identifiersep> recorder ( ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ofex ) <LOG> { recorder = null ; } if ( recorder != null ) { list < string > supported <identifiersep> formats = recorder . get <identifiersep> supported <identifiersep> formats ( ) ; <ect>
catch ( throwable t ) { if ( t instanceof interrupted <identifiersep> exception ) thread . current <identifiersep> thread ( ) . interrupt ( ) ; else if ( t instanceof thread <identifiersep> death ) throw ( thread <identifiersep> death ) t ; <LOG> else } } <comment> <ect>
<string_literal> ) ; if ( command == null ) { return ; } list < call <identifiersep> peer > call <identifiersep> peers = call <identifiersep> conference . get <identifiersep> call <identifiersep> peers ( ) ; if ( call <identifiersep> peers . is <identifiersep> empty ( ) ) <LOG> { return ; } command = string . format ( command , call <identifiersep> peers . get ( 0 ) . get <identifiersep> address ( ) ) ; try { logger . info ( <string_literal> + command ) ; <ect>
netaddr <identifiersep> activator . bundle <identifiersep> context = bundle <identifiersep> context ; <comment> <LOG> network <identifiersep> ams . start ( ) ; bundle <identifiersep> context . register <identifiersep> service ( network <identifiersep> address <identifiersep> manager <identifiersep> service . class . get <identifiersep> name ( ) , network <identifiersep> ams , null ) ; logger . info ( <string_literal> ) ; } finally <ect>
<comment> public void stop ( bundle <identifiersep> context bundle <identifiersep> context ) { if ( network <identifiersep> ams != null ) <LOG> network <identifiersep> ams . stop ( ) ; configuration <identifiersep> service = null ; packet <identifiersep> logging <identifiersep> service = null ; } <comment> <ect>
else { try { local <identifiersep> host = inet <identifiersep> address . get <identifiersep> by <identifiersep> address ( src ) ; } catch ( unknown <identifiersep> host <identifiersep> exception uhe ) <LOG> { } } } else if ( os <identifiersep> utils . is <identifiersep> mac ) { try { local <identifiersep> host = bsd <identifiersep> localhost <identifiersep> retriever <ect>
<comment> <LOG> { } } lookup . set <identifiersep> default <identifiersep> resolver ( this ) ; } } string <identifiersep> builder sb = new string <identifiersep> builder ( ) ; for ( int i = 1 ; ; i ++ ) { string anchor = dns <identifiersep> util <identifiersep> activator . get <identifiersep> resources ( ) . get <identifiersep> settings <identifiersep> string ( <ect>
{ super . load <identifiersep> trust <identifiersep> anchors ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( sb . to <identifiersep> string ( ) . get <identifiersep> bytes ( <string_literal> ) ) ) ; } catch ( io <identifiersep> exception e ) { <LOG> logger . error ( <string_literal> , e ) ; } } } <ect>
custom <identifiersep> resolver . pname <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled , custom <identifiersep> resolver . pdefault <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled ) ) { bundle <identifiersep> context . register <identifiersep> service ( custom <identifiersep> resolver . class . get <identifiersep> name ( ) , new parallel <identifiersep> resolver <identifiersep> impl ( ) , <LOG> null ) ; } if ( get <identifiersep> configuration <identifiersep> service ( ) . get <identifiersep> boolean ( custom <identifiersep> resolver . pname <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled , custom <identifiersep> resolver . pdefault <identifiersep> dnssec <identifiersep> resolver <identifiersep> enabled ) ) { bundle <identifiersep> context . register <identifiersep> service ( <ect>
break ; } } } if ( is <identifiersep> present ) return ; } write <identifiersep> message ( history , <string_literal> , evt . get <identifiersep> source <identifiersep> chat <identifiersep> room <identifiersep> member ( ) , evt . get <identifiersep> message ( ) , evt . get <identifiersep> timestamp ( ) ) ; } catch ( io <identifiersep> exception e ) <LOG> { } } public void message <identifiersep> delivered ( chat <identifiersep> room <identifiersep> message <identifiersep> delivered <identifiersep> event evt ) { try { if ( ! is <identifiersep> history <identifiersep> logging <identifiersep> enabled ( <ect>
<comment> <LOG> { } } <comment> <ect>
message . get <identifiersep> encoding ( ) , message . get <identifiersep> message <identifiersep> uid ( ) , from . get <identifiersep> contact <identifiersep> address ( ) , sdf . format ( message <identifiersep> timestamp ) , null } , new date ( ) ) ; <comment> <LOG> { } } <comment> <ect>
{ naming <identifiersep> enumeration < ? > values = attribute . get <identifiersep> all ( ) ; if ( values . has <identifiersep> more ( ) ) { photo = ( byte [ ] ) values . next ( ) ; } } } } } catch ( naming <identifiersep> exception e ) <LOG> { e . print <identifiersep> stack <identifiersep> trace ( ) ; } finally { if ( dir <identifiersep> context != null ) disconnect ( dir <identifiersep> context ) ; <ect>
<comment> public void stop ( bundle <identifiersep> context bc ) <LOG> { } <comment> <ect>
<comment> public void start ( bundle <identifiersep> context bundle <identifiersep> context ) throws exception <LOG> { service <identifiersep> registration = bundle <identifiersep> context . register <identifiersep> service ( hid <identifiersep> service . class . get <identifiersep> name ( ) , new hid <identifiersep> service <identifiersep> impl ( ) , null ) ; logger . debug ( <string_literal> ) ; <ect>
public void proto <identifiersep> contact <identifiersep> added ( proto <identifiersep> contact <identifiersep> event evt ) { element mc <identifiersep> node = find <identifiersep> meta <identifiersep> contact <identifiersep> node ( evt . get <identifiersep> parent ( ) . get <identifiersep> meta <identifiersep> uid ( ) ) ; <comment> <LOG> { return ; } element proto <identifiersep> node = create <identifiersep> proto <identifiersep> contact <identifiersep> node ( evt . get <identifiersep> proto <identifiersep> contact ( ) ) ; if ( proto <identifiersep> node == null ) { logger . error ( <string_literal> <ect>
if ( old <identifiersep> mc <identifiersep> node == null ) { logger . error ( <string_literal> + old <identifiersep> mc <identifiersep> node ) ; return ; } if ( new <identifiersep> mc <identifiersep> node == null ) <LOG> { + new <identifiersep> mc <identifiersep> node ) ; return ; } element proto <identifiersep> node = xml <identifiersep> utils . locate <identifiersep> element ( old <identifiersep> mc <identifiersep> node , proto <identifiersep> contact <identifiersep> node <identifiersep> name , proto <identifiersep> contact <identifiersep> address <identifiersep> attr <identifiersep> name , evt . get <identifiersep> proto <identifiersep> contact ( ) <ect>
<comment> void add <identifiersep> subgroup ( meta <identifiersep> contact <identifiersep> group subgroup ) <LOG> { + <string_literal> + get <identifiersep> group <identifiersep> name ( ) ) ; this . subgroups . add ( ( meta <identifiersep> contact <identifiersep> group <identifiersep> impl ) subgroup ) ; ( ( meta <identifiersep> contact <identifiersep> group <identifiersep> impl ) subgroup ) . parent <identifiersep> meta <identifiersep> contact <identifiersep> group = this ; this . subgroups <identifiersep> ordered <identifiersep> copy = new linked <identifiersep> list < meta <identifiersep> contact <identifiersep> group > ( subgroups ) ; <ect>
else if ( error <identifiersep> code == operation <identifiersep> failed <identifiersep> exception . invalid <identifiersep> account <identifiersep> properties ) { logger . error ( <string_literal> + <string_literal> , ex ) ; } else <LOG> { } } } } <ect>
toolkit . get <identifiersep> default <identifiersep> toolkit ( ) . get <identifiersep> image ( dock <identifiersep> icon <identifiersep> url <identifiersep> to <identifiersep> set ) ) ; } else if ( original <identifiersep> dock <identifiersep> image != null ) { application . set <identifiersep> dock <identifiersep> icon <identifiersep> image ( original <identifiersep> dock <identifiersep> image ) ; } } catch ( exception e ) <LOG> { } } } @ override public boolean check <identifiersep> initialized ( ) { return initialized ; } <comment> <ect>
else if ( error <identifiersep> code == operation <identifiersep> failed <identifiersep> exception . invalid <identifiersep> account <identifiersep> properties ) { logger . error ( <string_literal> + <string_literal> , ex ) ; } else <LOG> { } } } } <ect>
<comment> public void stop ( bundle <identifiersep> context context ) throws exception { <LOG> vbox7serv <identifiersep> reg . unregister ( ) ; } } <ect>
hashtable < string , string > hashtable = new hashtable < string , string > ( ) ; hashtable . put ( replacement <identifiersep> service . source <identifiersep> name , replacement <identifiersep> service <identifiersep> twitpic <identifiersep> impl . twitpic <identifiersep> config <identifiersep> label ) ; twitpic <identifiersep> source = new replacement <identifiersep> service <identifiersep> twitpic <identifiersep> impl ( ) ; twitpic <identifiersep> serv <identifiersep> reg = context . register <identifiersep> service ( replacement <identifiersep> service . class . get <identifiersep> name ( ) , <LOG> twitpic <identifiersep> source , hashtable ) ; } <comment> <ect>
<comment> public static final string source <identifiersep> name = <string_literal> ; <comment> public replacement <identifiersep> service <identifiersep> twitpic <identifiersep> impl ( ) <LOG> { } <comment> <ect>
<comment> public void add <identifiersep> call <identifiersep> peer ( mock <identifiersep> call <identifiersep> peer call <identifiersep> peer ) { if ( ! do <identifiersep> add <identifiersep> call <identifiersep> peer ( call <identifiersep> peer ) ) return ; <LOG> call <identifiersep> peer . add <identifiersep> call <identifiersep> peer <identifiersep> listener ( this ) ; fire <identifiersep> call <identifiersep> peer <identifiersep> event ( call <identifiersep> peer , call <identifiersep> peer <identifiersep> event . call <identifiersep> peer <identifiersep> added ) ; } <comment> <ect>
<comment> void fire <identifiersep> group <identifiersep> event ( contact <identifiersep> group group , int event <identifiersep> id ) { <comment> <LOG> if ( parent <identifiersep> operation <identifiersep> set == null ) { return ; } server <identifiersep> stored <identifiersep> group <identifiersep> event evt = new server <identifiersep> stored <identifiersep> group <identifiersep> event ( group , event <identifiersep> id , parent <identifiersep> operation <identifiersep> set . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) <ect>
<comment> private void fire <identifiersep> contact <identifiersep> added ( contact <identifiersep> group parent <identifiersep> group , contact contact ) { <comment> <LOG> if ( parent <identifiersep> operation <identifiersep> set == null ) { return ; } <comment> <ect>
<comment> boolean check <identifiersep> first <identifiersep> packet ( ) throws exception { <LOG> string received <identifiersep> str = received <identifiersep> keep <identifiersep> alive <identifiersep> packets . remove <identifiersep> last ( ) ; received <identifiersep> str = received <identifiersep> str . replace <identifiersep> all ( sys <identifiersep> msg <identifiersep> prefix <identifiersep> test , <string_literal> ) ; string [ ] ss = received <identifiersep> str . split ( <string_literal> ) ; string prov <identifiersep> hash <identifiersep> str = ss [ 0 ] . split ( <string_literal> ) [ 1 ] ; string opset <identifiersep> hash <identifiersep> str = ss [ 1 ] . split ( <string_literal> ) [ 1 ] ; if ( icq <identifiersep> provider . hash <identifiersep> code ( ) != integer . parse <identifiersep> int ( prov <identifiersep> hash <identifiersep> str ) <ect>
<comment> <LOG> { return null ; } <comment> <ect>
{ if ( transfer instanceof incoming <identifiersep> file <identifiersep> transfer ) { logger . trace ( <string_literal> + transfer . get <identifiersep> class ( ) ) ; if ( ! ( transfer instanceof incoming <identifiersep> file <identifiersep> transfer ) ) <LOG> { return ; } operation <identifiersep> set <identifiersep> persistent <identifiersep> presence <identifiersep> icq <identifiersep> impl op <identifiersep> set <identifiersep> pers <identifiersep> presence = ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence <identifiersep> icq <identifiersep> impl ) icq <identifiersep> provider . get <identifiersep> operation <identifiersep> set ( operation <identifiersep> set <identifiersep> persistent <identifiersep> presence . class ) ; <ect>
new authorization <identifiersep> request ( ) ; req . set <identifiersep> reason ( <string_literal> + <string_literal> ) ; op <identifiersep> set <identifiersep> extended <identifiersep> authorizations . re <identifiersep> request <identifiersep> authorization ( req , source <identifiersep> contact ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { } } } } } } <comment> private class away <identifiersep> message <identifiersep> listener implements info <identifiersep> service <identifiersep> listener <ect>
{ logger . trace ( <string_literal> ) ; read <identifiersep> basic <identifiersep> user <identifiersep> info ( ( meta <identifiersep> basic <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> more <identifiersep> info <identifiersep> cmd ) <LOG> { read <identifiersep> more <identifiersep> user <identifiersep> info ( ( meta <identifiersep> more <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> email <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; <ect>
{ logger . trace ( <string_literal> ) ; read <identifiersep> email <identifiersep> user <identifiersep> info ( ( meta <identifiersep> email <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> homepage <identifiersep> category <identifiersep> info <identifiersep> cmd ) <LOG> { read <identifiersep> home <identifiersep> page <identifiersep> user <identifiersep> info ( ( meta <identifiersep> homepage <identifiersep> category <identifiersep> info <identifiersep> cmd ) snac ) ; } else if ( snac instanceof meta <identifiersep> work <identifiersep> info <identifiersep> cmd ) { logger . trace ( <string_literal> ) ; <ect>
{ <comment> <LOG> disconnect <identifiersep> and <identifiersep> clean <identifiersep> connection ( ) ; event <identifiersep> during <identifiersep> login = null ; fire <identifiersep> registration <identifiersep> state <identifiersep> changed ( get <identifiersep> registration <identifiersep> state ( ) , registration <identifiersep> state . connection <identifiersep> failed , registration <identifiersep> state <identifiersep> change <identifiersep> event . reason <identifiersep> server <identifiersep> not <identifiersep> found , null ) ; return connect <identifiersep> state . abort <identifiersep> connecting ; <ect>
<comment> public void reconnecting <identifiersep> in ( int i ) <LOG> { } <comment> public void reconnection <identifiersep> successful ( ) <ect>
<comment> public void reconnection <identifiersep> failed ( exception exception ) <LOG> { } } <comment> public protocol <identifiersep> icon get <identifiersep> protocol <identifiersep> icon ( ) <ect>
<comment> <LOG> { } } } <comment> <ect>
<comment> void fire <identifiersep> contact <identifiersep> resolved ( contact <identifiersep> group parent <identifiersep> group , contact <identifiersep> jabber <identifiersep> impl contact ) { <comment> <LOG> if ( parent <identifiersep> operation <identifiersep> set == null ) { return ; } <comment> <ect>
<comment> public void entries <identifiersep> added ( collection < string > addresses ) <LOG> { for ( string id : addresses ) { add <identifiersep> entry <identifiersep> to <identifiersep> contact <identifiersep> list ( id ) ; } } <comment> <ect>
new whiteboard <identifiersep> participant <identifiersep> jabber <identifiersep> impl ( source <identifiersep> contact , this ) ) ; try { send <identifiersep> whiteboard <identifiersep> object ( create <identifiersep> whiteboard <identifiersep> object ( whiteboard <identifiersep> object <identifiersep> line . name ) ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { } } <comment> public whiteboard <identifiersep> session get <identifiersep> whiteboard <identifiersep> session ( ) <ect>
if ( wb <identifiersep> obj . get <identifiersep> id ( ) . equals ( obj . get <identifiersep> id ( ) ) ) whiteboard <identifiersep> objects . remove ( i ) ; else i ++ ; } } catch ( xmpp <identifiersep> exception ex ) { <LOG> ex . print <identifiersep> stack <identifiersep> trace ( ) ; } } <comment> <ect>
return ; whiteboard <identifiersep> object <identifiersep> packet <identifiersep> extension new <identifiersep> message = ( whiteboard <identifiersep> object <identifiersep> packet <identifiersep> extension ) object <identifiersep> ext ; if ( msg . get <identifiersep> type ( ) == org . jivesoftware . smack . packet . message . type . error ) <LOG> { int error <identifiersep> code = packet . get <identifiersep> error ( ) . get <identifiersep> code ( ) ; int error <identifiersep> result <identifiersep> code = whiteboard <identifiersep> object <identifiersep> delivery <identifiersep> failed <identifiersep> event . unknown <identifiersep> error ; if ( error <identifiersep> code == <number_literal> ) { <ect>
{ call <identifiersep> peer peer = call <identifiersep> peers . next ( ) ; try { hangup <identifiersep> call <identifiersep> peer ( peer ) ; } catch ( exception ex ) <LOG> { } } } } <comment> private void subscribe <identifiersep> for <identifiersep> jingle <identifiersep> packets ( ) { <ect>
string message = <string_literal> ; if ( error != null ) { string error <identifiersep> str = <string_literal> + error . get <identifiersep> code ( ) + <string_literal> + error . get <identifiersep> message ( ) ; <LOG> message += <string_literal> + error <identifiersep> str ; } if ( call <identifiersep> peer != null ) call <identifiersep> peer . set <identifiersep> state ( call <identifiersep> peer <identifiersep> state . failed , message ) ; return ; } jingle <identifiersep> action action = jingle <identifiersep> iq . get <identifiersep> action ( ) ; if ( action == jingle <identifiersep> action . session <identifiersep> initiate ) <ect>
<string_literal> + to + <string_literal> + <string_literal> , operation <identifiersep> failed <identifiersep> exception . internal <identifiersep> error ) ; } } catch ( xmpp <identifiersep> exception xmppe ) <LOG> { } transfer ( peer , to , target <identifiersep> jabber <identifiersep> g <identifiersep> talk <identifiersep> impl . get <identifiersep> sid ( ) ) ; } <comment> <ect>
{ cp <identifiersep> dtmf <identifiersep> method = dtmf <identifiersep> method . inband <identifiersep> dtmf ; } } <comment> <LOG> { } ( ( audio <identifiersep> media <identifiersep> stream ) cp . get <identifiersep> media <identifiersep> handler ( ) . get <identifiersep> stream ( media <identifiersep> type . audio ) ) . stop <identifiersep> sending <identifiersep> dtmf ( cp <identifiersep> dtmf <identifiersep> method ) ; } } <ect>
for ( chat <identifiersep> room chat <identifiersep> room : chat <identifiersep> rooms ) { if ( chat <identifiersep> room . get <identifiersep> name ( ) . equals ( user <identifiersep> id ) ) { user <identifiersep> id = presence . get <identifiersep> from ( ) ; <LOG> break ; } } } <comment> <ect>
source <identifiersep> contact . set <identifiersep> status <identifiersep> message ( current <identifiersep> presence . get <identifiersep> status ( ) ) ; update <identifiersep> contact <identifiersep> status ( source <identifiersep> contact , jabber <identifiersep> status <identifiersep> to <identifiersep> presence <identifiersep> status ( current <identifiersep> presence , parent <identifiersep> provider ) ) ; } catch ( illegal <identifiersep> state <identifiersep> exception ex ) <LOG> { } catch ( illegal <identifiersep> argument <identifiersep> exception ex ) { logger . error ( <string_literal> , ex ) ; } } } <comment> <ect>
operation <identifiersep> failed <identifiersep> exception . illegal <identifiersep> argument ) ; } try { this . irc . message ( target , message . get <identifiersep> content ( ) ) ; logger . trace ( <string_literal> ) ; } catch ( runtime <identifiersep> exception e ) <LOG> { throw e ; } } <comment> <ect>
chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> change <identifiersep> event evt = new chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> change <identifiersep> event ( this , member , previous <identifiersep> role , new <identifiersep> role ) ; <LOG> { } iterable < chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> listener > listeners ; synchronized ( member <identifiersep> role <identifiersep> listeners ) { listeners = new array <identifiersep> list < chat <identifiersep> room <identifiersep> member <identifiersep> role <identifiersep> listener > ( <ect>
connection . get <identifiersep> presence <identifiersep> manager ( ) . remove <identifiersep> nick <identifiersep> watch ( contact . get <identifiersep> address ( ) ) ; } parent <identifiersep> group . remove <identifiersep> contact ( irc <identifiersep> contact ) ; fire <identifiersep> subscription <identifiersep> event ( irc <identifiersep> contact , parent <identifiersep> group , subscription <identifiersep> event . subscription <identifiersep> removed ) ; } catch ( runtime <identifiersep> exception e ) <LOG> { fire <identifiersep> subscription <identifiersep> event ( irc <identifiersep> contact , parent <identifiersep> group , subscription <identifiersep> event . subscription <identifiersep> failed ) ; } } <comment> <ect>
entry < string , class < ? extends command > > entry = it . next ( ) ; if ( entry . get <identifiersep> value ( ) == type && ( command == null || command . equals ( entry . get <identifiersep> key ( ) ) ) ) { it . remove ( ) ; <LOG> { + <string_literal> + type . to <identifiersep> string ( ) + <string_literal> ) ; } } } } <comment> private final protocol <identifiersep> provider <identifiersep> service <identifiersep> irc <identifiersep> impl provider ; <ect>
try { this . irc . add <identifiersep> listener ( new channel <identifiersep> list <identifiersep> listener ( list <identifiersep> signal ) ) ; this . irc . raw <identifiersep> message ( <string_literal> ) ; while ( ! list <identifiersep> signal . is <identifiersep> done ( ) ) <LOG> { list <identifiersep> signal . wait ( ) ; } logger . trace ( <string_literal> ) ; } catch ( interrupted <identifiersep> exception e ) { logger . warn ( <string_literal> , e ) ; <ect>
while ( ! list <identifiersep> signal . is <identifiersep> done ( ) ) { logger . trace ( <string_literal> ) ; list <identifiersep> signal . wait ( ) ; } logger . trace ( <string_literal> ) ; } catch ( interrupted <identifiersep> exception e ) <LOG> { } } list = list <identifiersep> signal . get <identifiersep> value ( ) ; this . channellist . set ( list ) ; logger . trace ( <string_literal> ) ; <comment> <ect>
{ if ( string <identifiersep> utils . is <identifiersep> null <identifiersep> or <identifiersep> empty ( call <identifiersep> fwd <identifiersep> to ) ) return false ; response response ; try <LOG> { response = ( ( protocol <identifiersep> provider <identifiersep> service <identifiersep> sip <identifiersep> impl ) protocol <identifiersep> provider ) . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . moved <identifiersep> temporarily , invite ) ; contact <identifiersep> header contact <identifiersep> header = ( contact <identifiersep> header ) response . get <identifiersep> header ( contact <identifiersep> header . name ) ; <ect>
if ( arrays . as <identifiersep> list ( default <identifiersep> suites ) . contains ( enabled <identifiersep> suite ) ) { offered <identifiersep> suites . add ( enabled <identifiersep> suite ) ; } } string [ ] new <identifiersep> cipher <identifiersep> suites = new string [ offered <identifiersep> suites . size ( ) ] ; new <identifiersep> cipher <identifiersep> suites = offered <identifiersep> suites . to <identifiersep> array ( new <identifiersep> cipher <identifiersep> suites ) ; <LOG> ( ( sip <identifiersep> stack <identifiersep> impl ) this . stack ) . set <identifiersep> enabled <identifiersep> cipher <identifiersep> suites ( new <identifiersep> cipher <identifiersep> suites ) ; <comment> <ect>
{ synchronized ( this . listeners ) { if ( this . listeners . size ( ) == 0 ) start <identifiersep> listening ( ) ; <LOG> this . listeners . add ( listener ) ; } } <comment> <ect>
<comment> <LOG> { this . distant <identifiersep> paet = null ; if ( this . use <identifiersep> distant <identifiersep> pa ) { logger . debug ( <ect>
document create <identifiersep> document ( ) { try { return xml <identifiersep> utils . create <identifiersep> document ( ) ; } catch ( exception e ) <LOG> { return null ; } } <comment> <ect>
document convert <identifiersep> document ( string document ) { try { return xml <identifiersep> utils . create <identifiersep> document ( document ) ; } catch ( exception e ) <LOG> { return null ; } } <comment> <ect>
catch ( parse <identifiersep> exception ex ) { throw new illegal <identifiersep> argument <identifiersep> exception ( string . format ( <string_literal> , contact <identifiersep> id ) , <LOG> ex ) ; } contact <identifiersep> sip <identifiersep> impl new <identifiersep> unresolved <identifiersep> contact = new contact <identifiersep> sip <identifiersep> impl ( contact <identifiersep> address , sip <identifiersep> provider ) ; new <identifiersep> unresolved <identifiersep> contact . set <identifiersep> persistent ( true ) ; parent <identifiersep> group . add <identifiersep> contact ( new <identifiersep> unresolved <identifiersep> contact ) ; new <identifiersep> unresolved <identifiersep> contact . set <identifiersep> persistent <identifiersep> data ( persistent <identifiersep> data ) ; <ect>
try { provider = select <identifiersep> handling <identifiersep> provider ( uri ) ; } catch ( operation <identifiersep> failed <identifiersep> exception exc ) { <LOG> <comment> <ect>
address callee <identifiersep> address , javax . sip . message . message cause , call <identifiersep> conference conference ) throws operation <identifiersep> failed <identifiersep> exception { <LOG> call <identifiersep> sip <identifiersep> impl call = create <identifiersep> outgoing <identifiersep> call ( ) ; if ( conference != null ) call . set <identifiersep> conference ( conference ) ; call . invite ( callee <identifiersep> address , cause ) ; return call ; } <comment> <ect>
properties prop = new properties ( ) ; prop . load ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( value ) ) ; string signal = prop . get <identifiersep> property ( <string_literal> ) ; string duration <identifiersep> str = prop . get <identifiersep> property ( <string_literal> ) ; dtmf <identifiersep> tone tone = dtmf <identifiersep> tone . get <identifiersep> dtmf <identifiersep> tone ( signal ) ; if ( tone == null ) <LOG> { return false ; } long duration = 0 ; try { duration = long . parse <identifiersep> long ( duration <identifiersep> str ) ; <ect>
try { response <identifiersep> ok = pps . get <identifiersep> message <identifiersep> factory ( ) . create <identifiersep> response ( response . ok , request <identifiersep> event . get <identifiersep> request ( ) ) ; } catch ( parse <identifiersep> exception ex ) { <LOG> <comment> <ect>
+ <string_literal> ) ; logger . trace ( <string_literal> , ex ) ; return false ; } catch ( invalid <identifiersep> argument <identifiersep> exception ex ) { <LOG> <comment> <ect>
logger . error ( <string_literal> , e ) ; return false ; } try { dialog . send <identifiersep> request ( transac ) ; } catch ( exception e ) <LOG> { return false ; } return true ; } <comment> <ect>
<comment> <LOG> { return false ; } response . set <identifiersep> header ( exp <identifiersep> header ) ; try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; <ect>
client <identifiersep> transaction transac ; try { transac = create <identifiersep> notify ( dialog , subscription , subscription <identifiersep> state <identifiersep> header . active , null ) ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { return false ; } try { dialog . send <identifiersep> request ( transac ) ; } catch ( exception e ) <ect>
{ <comment> <LOG> <comment> <ect>
, to <identifiersep> header , via <identifiersep> headers , max <identifiersep> forwards <identifiersep> header ) ; logger . debug ( <string_literal> + request ) ; } catch ( parse <identifiersep> exception ex ) <LOG> { return ; } iterator < string > supported <identifiersep> methods = provider . get <identifiersep> supported <identifiersep> methods ( ) . iterator ( ) ; <comment> <ect>
try { options <identifiersep> trans . send <identifiersep> request ( ) ; logger . debug ( <string_literal> + request ) ; } catch ( sip <identifiersep> exception ex ) <LOG> { if ( ex . get <identifiersep> cause ( ) instanceof io <identifiersep> exception ) { <comment> <ect>
logger . error ( <string_literal> , e ) ; return false ; } try { server <identifiersep> transaction . send <identifiersep> response ( response ) ; } catch ( sip <identifiersep> exception e ) <LOG> { } catch ( invalid <identifiersep> argument <identifiersep> exception e ) { <comment> <ect>
process <identifiersep> authentication <identifiersep> challenge ( client <identifiersep> transaction , response , source <identifiersep> provider ) ; processed = true ; } catch ( operation <identifiersep> failed <identifiersep> exception e ) <LOG> { } } else if ( ( status <identifiersep> code != response . ok ) && ( status <identifiersep> code != response . accepted ) ) processed = true ; <comment> <ect>
return false ; } expires <identifiersep> header exp = request . get <identifiersep> expires ( ) ; try { exp . set <identifiersep> expires ( min . get <identifiersep> expires ( ) ) ; } catch ( invalid <identifiersep> argument <identifiersep> exception e ) <LOG> { return false ; } client <identifiersep> transaction transac = null ; try { transac <ect>
{ if ( container == null ) { logger . warn ( <string_literal> ) ; return ; } if ( key == null ) <LOG> { return ; } sip <identifiersep> application <identifiersep> data app <identifiersep> data = get <identifiersep> sip <identifiersep> application <identifiersep> data ( container ) ; if ( app <identifiersep> data == null ) { app <identifiersep> data = new sip <identifiersep> application <identifiersep> data ( ) ; <ect>
{ if ( container == null ) { logger . debug ( <string_literal> ) ; return null ; } if ( key == null ) <LOG> { return null ; } sip <identifiersep> application <identifiersep> data app <identifiersep> data = get <identifiersep> sip <identifiersep> application <identifiersep> data ( container ) ; if ( app <identifiersep> data == null ) return null ; return app <identifiersep> data . get ( key ) ; <ect>
|| update <identifiersep> rules ; update <identifiersep> rules = remove <identifiersep> contact <identifiersep> from <identifiersep> polite <identifiersep> block <identifiersep> list ( contact ) || update <identifiersep> rules ; if ( update <identifiersep> rules ) update <identifiersep> pres <identifiersep> rules ( ) ; } catch ( x <identifiersep> cap <identifiersep> exception e ) <LOG> { } <comment> <ect>
{ service . initialize ( user <identifiersep> id , ( sip <identifiersep> account <identifiersep> id <identifiersep> impl ) account <identifiersep> id ) ; <comment> <LOG> { throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + ex . get <identifiersep> message ( ) ) ; } return service ; } } <ect>
{ request mes ; try { mes = create <identifiersep> message <identifiersep> request ( to , msg ) ; } catch ( operation <identifiersep> failed <identifiersep> exception ex ) <LOG> { fire <identifiersep> message <identifiersep> delivery <identifiersep> failed ( message , to , message <identifiersep> delivery <identifiersep> failed <identifiersep> event . internal <identifiersep> error ) ; continue ; } try { <ect>
{ synchronized ( message <identifiersep> processors ) { for ( sip <identifiersep> message <identifiersep> processor listener : message <identifiersep> processors ) if ( ! listener . process <identifiersep> timeout ( timeout <identifiersep> event , sent <identifiersep> msg ) ) return true ; } <LOG> <comment> <ect>
{ password = sip <identifiersep> activator . get <identifiersep> protocol <identifiersep> provider <identifiersep> factory ( ) . load <identifiersep> password ( account <identifiersep> id ) ; } else { password = account <identifiersep> id . get <identifiersep> clist <identifiersep> option <identifiersep> password ( ) ; } <LOG> if ( ! authorize ( ( string ) incoming <identifiersep> object . get ( <string_literal> ) , password ) ) return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { if ( ! send <identifiersep> capas ( ( json <identifiersep> array ) incoming <identifiersep> object . get ( <string_literal> ) ) ) logger . error ( <string_literal> ) ; <ect>
if ( ! send <identifiersep> capas ( ( json <identifiersep> array ) incoming <identifiersep> object . get ( <string_literal> ) ) ) logger . error ( <string_literal> ) ; return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { if ( ! send <identifiersep> features ( ( string ) incoming <identifiersep> object . get ( <string_literal> ) , <LOG> ( string ) incoming <identifiersep> object . get ( <string_literal> ) ) ) return ; } else if ( class <identifiersep> field . equals ( <string_literal> ) ) { if ( ! get <identifiersep> phone <identifiersep> list ( ) ) logger . error ( <string_literal> ) ; <ect>
else if ( class <identifiersep> field . equals ( <string_literal> ) ) { destroy ( ) ; return ; } else <LOG> { return ; } } catch ( throwable t ) { logger . error ( <string_literal> , t ) ; } } <comment> <ect>
try { ret <identifiersep> val = this . history <identifiersep> service <identifiersep> impl . parse ( file ) ; } catch ( exception e ) { <comment> <LOG> <comment> <ect>
result <identifiersep> doc <identifiersep> str . append ( <string_literal> ) ; try { document result = this . history <identifiersep> service <identifiersep> impl . parse ( new byte <identifiersep> array <identifiersep> input <identifiersep> stream ( result <identifiersep> doc <identifiersep> str . to <identifiersep> string ( ) . get <identifiersep> bytes ( <string_literal> ) ) ) ; <LOG> <comment> <ect>
{ result . append ( line ) ; break ; } result . append ( line ) ; } return result ; } catch ( io <identifiersep> exception ex ) <LOG> { return null ; } } <comment> <ect>
xml <identifiersep> formatter fmtr = new xml <identifiersep> formatter ( new print <identifiersep> stream ( out ) ) ; test <identifiersep> result res = sc <identifiersep> test <identifiersep> runner . run ( slick , fmtr ) ; err <identifiersep> count += res . error <identifiersep> count ( ) + res . failure <identifiersep> count ( ) ; run <identifiersep> count += res . run <identifiersep> count ( ) ; out . flush ( ) ; out . close ( ) ; } <LOG> <comment> <ect>
out . close ( ) ; } <comment> <LOG> + <string_literal> ) ; logger . info ( <string_literal> ) ; <comment> <ect>
try { <comment> <LOG> { } <comment> <ect>
mock <identifiersep> prov <identifiersep> properties . put ( meta <identifiersep> contact <identifiersep> list <identifiersep> service . provider <identifiersep> mask <identifiersep> property , <string_literal> ) ; mock <identifiersep> pr <identifiersep> service <identifiersep> registration = meta <identifiersep> history <identifiersep> service <identifiersep> lick . bc . register <identifiersep> service ( protocol <identifiersep> provider <identifiersep> service . class . get <identifiersep> name ( ) , mock <identifiersep> provider , <LOG> mock <identifiersep> prov <identifiersep> properties ) ; test <identifiersep> meta <identifiersep> contact = meta <identifiersep> cl <identifiersep> service . get <identifiersep> root ( ) . get <identifiersep> meta <identifiersep> contact ( mock <identifiersep> provider , test <identifiersep> contact <identifiersep> name <identifiersep> 1 ) ; <comment> <ect>
iter = v . iterator ( ) ; while ( iter . has <identifiersep> next ( ) ) { call <identifiersep> peer item = iter . next ( ) ; mock <identifiersep> b <identifiersep> telphony <identifiersep> op <identifiersep> set . hangup <identifiersep> call <identifiersep> peer ( item ) ; } } catch ( exception ex1 ) <LOG> { fail ( <string_literal> + participant ) ; } } private void wait <identifiersep> seconds ( long secs ) { object lock = new object ( ) ; synchronized ( lock ) { <ect>
{ <comment> <LOG> tests = <string_literal> ; } string <identifiersep> tokenizer st = new string <identifiersep> tokenizer ( tests ) ; string [ ] ids = new string [ st . count <identifiersep> tokens ( ) ] ; int n = 0 ; while ( st . has <identifiersep> more <identifiersep> tokens ( ) ) { <ect>
public void set <identifiersep> user <identifiersep> name <identifiersep> editable ( boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ) { } public boolean is <identifiersep> user <identifiersep> name <identifiersep> editable ( ) { return false ; } } ) ; synchronized ( registration <identifiersep> lock ) { logger . info ( <string_literal> ) ; <LOG> registration <identifiersep> lock . wait ( <number_literal> ) ; } } <comment> <ect>
public authorization <identifiersep> response process <identifiersep> authorisation <identifiersep> request ( authorization <identifiersep> request req , contact source <identifiersep> contact ) { logger . trace ( <string_literal> + req + <string_literal> + source <identifiersep> contact ) ; return new authorization <identifiersep> response ( authorization <identifiersep> response . accept , <string_literal> ) ; } public authorization <identifiersep> request create <identifiersep> authorization <identifiersep> request ( contact contact ) <LOG> { return new authorization <identifiersep> request ( ) ; } public void process <identifiersep> authorization <identifiersep> response ( authorization <identifiersep> response response , contact source <identifiersep> contact ) { logger . debug ( <string_literal> + source <identifiersep> contact . get <identifiersep> address ( ) + <string_literal> + <ect>
<comment> <LOG> string group <identifiersep> name = new <identifiersep> groups <identifiersep> enum . next <identifiersep> element ( ) ; <comment> <ect>
{ system . out . println ( <string_literal> + old <identifiersep> name + <string_literal> + new <identifiersep> name <LOG> + <string_literal> + group . get <identifiersep> name ( ) ) ; } } <comment> <ect>
{ system . out . println ( <string_literal> ) ; ; return ; } thread . sleep ( <number_literal> ) ; icqtests . conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) . add <identifiersep> retroactive <identifiersep> layout <identifiersep> listener ( icqtests . rl ) ; <LOG> thread . sleep ( <number_literal> ) ; thread . sleep ( <number_literal> ) ; java . util . logging . logger . get <identifiersep> logger ( <string_literal> ) . set <identifiersep> level ( java . util . logging . level . finest ) ; mutable <identifiersep> buddy <identifiersep> list list = icqtests . conn . get <identifiersep> ssi <identifiersep> service ( ) . get <identifiersep> buddy <identifiersep> list ( ) ; mutable <identifiersep> group grp <identifiersep> group = null ; buddy buddy <identifiersep> to <identifiersep> move = null ; <ect>
thread . sleep ( <number_literal> ) ; for ( buddy buddy : buddies ) { system . out . println ( buddy . get <identifiersep> screenname ( ) ) ; if ( buddy . get <identifiersep> screenname ( ) . get <identifiersep> formatted ( ) . equals ( <string_literal> ) ) buddy <identifiersep> to <identifiersep> move = buddy ; } } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; system . out . println ( ) ; thread . sleep ( <number_literal> ) ; list < buddy > list <identifiersep> to <identifiersep> move = new array <identifiersep> list < buddy > ( ) ; list <identifiersep> to <identifiersep> move . add ( buddy <identifiersep> to <identifiersep> move ) ; list . move <identifiersep> buddies ( list <identifiersep> to <identifiersep> move , grp <identifiersep> group ) ; system . out . println ( <string_literal> ) ; <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void typing <identifiersep> notification <identifiersep> received ( typing <identifiersep> notification <identifiersep> event event ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( event ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void message <identifiersep> received ( message <identifiersep> received <identifiersep> event evt ) <LOG> { synchronized ( this ) { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
if ( collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> <ect>
<comment> public void subscription <identifiersep> removed ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void subscription <identifiersep> moved ( subscription <identifiersep> moved <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
if ( evt . get <identifiersep> new <identifiersep> state ( ) . equals ( registration <identifiersep> state . unregistered ) ) { logger . debug ( <string_literal> ) ; state <identifiersep> recieved = evt . get <identifiersep> new <identifiersep> state ( ) ; event <identifiersep> reason = evt . get <identifiersep> reason <identifiersep> code ( ) ; synchronized ( registration <identifiersep> lock ) <LOG> { registration <identifiersep> lock . notify <identifiersep> all ( ) ; logger . debug ( <string_literal> ) ; } } } } } <ect>
receivers <identifiersep> event <identifiersep> collector . collected <identifiersep> events . get ( 0 ) instanceof message <identifiersep> received <identifiersep> event ) ; <comment> <LOG> fixture . user <identifiersep> id2 ) ; + <string_literal> ) ; <comment> <ect>
<comment> public void test <identifiersep> retrieving <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list ( ) { contact <identifiersep> group root <identifiersep> group <LOG> = op <identifiersep> set <identifiersep> pers <identifiersep> presence1 . get <identifiersep> server <identifiersep> stored <identifiersep> contact <identifiersep> list <identifiersep> root ( ) ; logger . debug ( <string_literal> + root <identifiersep> group . get <identifiersep> group <identifiersep> name ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> contacts ( ) + <string_literal> + root <identifiersep> group . count <identifiersep> subgroups ( ) + <string_literal> + root <identifiersep> group . to <identifiersep> string ( ) ) ; hashtable < string , list < string > > expected <identifiersep> contact <identifiersep> list <ect>
<comment> private chat <identifiersep> room <identifiersep> member <identifiersep> role get <identifiersep> role ( string user <identifiersep> id , list < chat <identifiersep> room <identifiersep> member > members , string room <identifiersep> name , boolean print <identifiersep> debug <identifiersep> info ) { <LOG> if ( print <identifiersep> debug <identifiersep> info ) chat <identifiersep> room <identifiersep> member <identifiersep> role role <identifiersep> found = null ; for ( int i = 0 ; i < members . size ( ) ; i ++ ) { chat <identifiersep> room <identifiersep> member mem = members . get ( i ) ; if ( mem . get <identifiersep> contact <identifiersep> address ( ) . equals ( user <identifiersep> id ) ) <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
{ try { thread . sleep ( <number_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { } <LOG> string room <identifiersep> name = test <identifiersep> room <identifiersep> base <identifiersep> name + room <identifiersep> id ; chat <identifiersep> room room <identifiersep> user1 = op <identifiersep> set <identifiersep> muc1 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user1 ) ; chat <identifiersep> room room <identifiersep> user3 = op <identifiersep> set <identifiersep> muc3 . find <identifiersep> room ( room <identifiersep> name ) ; assert <identifiersep> not <identifiersep> null ( <string_literal> , room <identifiersep> user3 ) ; muc <identifiersep> event <identifiersep> collector room <identifiersep> user1col = new muc <identifiersep> event <identifiersep> collector ( <ect>
<comment> private void subtest <identifiersep> state <identifiersep> transition ( string new <identifiersep> status <identifiersep> name ) throws exception <LOG> { presence <identifiersep> status new <identifiersep> status = supported <identifiersep> status <identifiersep> set1 . get ( new <identifiersep> status <identifiersep> name ) ; presence <identifiersep> status old <identifiersep> status = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> presence <identifiersep> status ( ) ; string old <identifiersep> status <identifiersep> message = operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ; string new <identifiersep> status <identifiersep> message = status <identifiersep> message <identifiersep> root + new <identifiersep> status ; <ect>
new <identifiersep> status <identifiersep> message , status <identifiersep> event <identifiersep> collector . collected <identifiersep> stat <identifiersep> msg <identifiersep> events . get ( 0 ) . get <identifiersep> new <identifiersep> value ( ) ) ; <comment> <LOG> operation <identifiersep> set <identifiersep> presence1 . get <identifiersep> current <identifiersep> status <identifiersep> message ( ) ) ; } <comment> private void pause <identifiersep> after <identifiersep> state <identifiersep> changes ( ) { <ect>
<comment> public void test <identifiersep> query <identifiersep> contact <identifiersep> status ( ) throws exception { <LOG> <comment> <ect>
<comment> public void group <identifiersep> removed ( server <identifiersep> stored <identifiersep> group <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
<comment> public void wait <identifiersep> for <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; <ect>
if ( collected <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <ect>
{ if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> pres <identifiersep> events ) ; return ; } try { wait ( wait <identifiersep> for ) ; <LOG> if ( collected <identifiersep> pres <identifiersep> events . size ( ) > 0 ) else logger . trace ( <string_literal> + wait <identifiersep> for + <string_literal> ) ; } catch ( interrupted <identifiersep> exception ex ) { logger . debug ( <string_literal> , ex ) ; <ect>
<comment> public void wait <identifiersep> for <identifiersep> stat <identifiersep> msg <identifiersep> event ( long wait <identifiersep> for ) <LOG> { synchronized ( this ) { if ( collected <identifiersep> stat <identifiersep> msg <identifiersep> events . size ( ) > 0 ) { logger . trace ( <string_literal> + collected <identifiersep> stat <identifiersep> msg <identifiersep> events ) ; <ect>
<comment> public void subscription <identifiersep> created ( subscription <identifiersep> event evt ) { synchronized ( this ) <LOG> { collected <identifiersep> events . add ( evt ) ; notify <identifiersep> all ( ) ; } } <comment> <ect>
object lock = new object ( ) ; synchronized ( lock ) { logger . info ( <string_literal> ) ; lock . wait ( <number_literal> ) ; } <comment> <LOG> <comment> <ect>
<comment> <LOG> lock . wait ( <number_literal> ) ; } } <comment> <ect>
sip <identifiersep> tester <identifiersep> agent <identifiersep> contact , sub <identifiersep> evt . get <identifiersep> source <identifiersep> contact ( ) ) ; assert <identifiersep> same ( <string_literal> , this . fixture . provider1 , sub <identifiersep> evt . get <identifiersep> source <identifiersep> provider ( ) ) ; sub <identifiersep> evt <identifiersep> collector . collected <identifiersep> events . clear ( ) ; <comment> <LOG> <comment> <ect>
break ; default : string parsed = p <identifiersep> applet . join ( p <identifiersep> applet . subset ( path <identifiersep> tokens , 0 , i ) , <string_literal> ) ; string unparsed = p <identifiersep> applet . join ( p <identifiersep> applet . subset ( path <identifiersep> tokens , i ) , <string_literal> ) ; <LOG> system . err . println ( <string_literal> + parsed ) ; throw new runtime <identifiersep> exception ( <string_literal> + path <identifiersep> tokens [ i ] ) ; } <comment> <ect>
<comment> <LOG> float x2 , float y2 ) { <comment> <ect>
object object = find <identifiersep> child ( name ) ; if ( object instanceof gradient ) { gradient = ( gradient ) object ; <comment> <LOG> <comment> <ect>
<comment> <LOG> if ( inside <identifiersep> draw ) { system . exit ( 1 ) ; } inside <identifiersep> draw = true ; g . begin <identifiersep> draw ( ) ; if ( recorder != null ) { recorder . begin <identifiersep> draw ( ) ; <ect>
g . save ( save <identifiersep> path ( filename ) ) ; } <comment> public void save <identifiersep> frame ( ) { try { g . save ( save <identifiersep> path ( <string_literal> + nf ( frame <identifiersep> count , <number_literal> ) + <string_literal> ) ) ; <LOG> } catch ( security <identifiersep> exception se ) { <string_literal> ) ; } } <comment> <ect>
static public void println ( string what ) { system . out . println ( what ) ; system . out . flush ( ) ; } <comment> <LOG> static public void println ( object . . . variables ) { print ( variables ) ; println ( ) ; } <comment> <ect>
} else { system . err . println ( args <identifiersep> window <identifiersep> color + <string_literal> ) ; } } else if ( param . equals ( args <identifiersep> stop <identifiersep> color ) ) { if ( value . char <identifiersep> at ( 0 ) == ' # ' && value . length ( ) == <number_literal> ) { value = value . substring ( 1 ) ; stop <identifiersep> color = 0xff000000 | integer . parse <identifiersep> int ( value , <number_literal> ) ; <LOG> } else { } } else if ( param . equals ( args <identifiersep> sketch <identifiersep> folder ) ) { folder = value ; } else if ( param . equals ( args <identifiersep> location ) ) { location = parse <identifiersep> int ( split ( value , ' , ' ) ) ; } else if ( param . equals ( args <identifiersep> density ) ) { <ect>
location = parse <identifiersep> int ( split ( value , ' , ' ) ) ; } else if ( param . equals ( args <identifiersep> density ) ) { density = parse <identifiersep> int ( value , - 1 ) ; if ( density == - 1 ) { system . err . println ( <string_literal> + value + <string_literal> + args <identifiersep> density ) ; } else if ( density != 1 && density != <number_literal> ) { <LOG> density = - 1 ; } } } else { if ( args [ arg <identifiersep> index ] . equals ( args <identifiersep> present ) ) { present = true ; <comment> <ect>
final p <identifiersep> surface surface = sketch . init <identifiersep> surface ( ) ; <comment> <LOG> <comment> <ect>
if ( index != - 1 ) { remove <identifiersep> index ( index ) ; } return index ; } public string remove <identifiersep> index ( int index ) { if ( index < 0 || index >= count ) { throw new array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception ( index ) ; } <LOG> string key = keys [ index ] ; indices . remove ( keys [ index ] ) ; for ( int i = index ; i < count - 1 ; i ++ ) { keys [ i ] = keys [ i + 1 ] ; values [ i ] = values [ i + 1 ] ; indices . put ( keys [ i ] , i ) ; <ect>
transformer . set <identifiersep> output <identifiersep> property ( output <identifiersep> keys . encoding , <string_literal> ) ; <comment> <LOG> <comment> <ect>
int index = index ( key ) ; if ( index != - 1 ) { remove <identifiersep> index ( index ) ; } return index ; } public string remove <identifiersep> index ( int index ) { if ( index < 0 || index >= count ) { <LOG> throw new array <identifiersep> index <identifiersep> out <identifiersep> of <identifiersep> bounds <identifiersep> exception ( index ) ; } string key = keys [ index ] ; indices . remove ( key ) ; for ( int i = index ; i < count - 1 ; i ++ ) { keys [ i ] = keys [ i + 1 ] ; values [ i ] = values [ i + 1 ] ; <ect>
<comment> <comment> <LOG> <comment> <ect>
<comment> <LOG> <comment> <ect>
new <identifiersep> size . width = get <identifiersep> width ( ) ; new <identifiersep> size . height = get <identifiersep> height ( ) ; <comment> <LOG> if ( ! old <identifiersep> size . equals ( new <identifiersep> size ) ) { old <identifiersep> size = new <identifiersep> size ; sketch . set <identifiersep> size ( new <identifiersep> size . width / window <identifiersep> scale <identifiersep> factor , new <identifiersep> size . height / window <identifiersep> scale <identifiersep> factor ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
public void reset <identifiersep> matrix ( ) { g2 . set <identifiersep> transform ( new affine <identifiersep> transform ( ) ) ; g2 . scale ( pixel <identifiersep> density , pixel <identifiersep> density ) ; } <comment> <LOG> float n10 , float n11 , float n12 ) { <comment> <ect>
<comment> <LOG> string jv = system . get <identifiersep> property ( <string_literal> ) ; <comment> <ect>
} else { if ( base . debug ) { system . err . println ( <string_literal> ) ; system . err . println ( get <identifiersep> path ( ) ) ; system . err . println ( <string_literal> ) ; for ( library library : libraries ) { <LOG> system . err . println ( library . get <identifiersep> path ( ) ) ; } system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> + pkg + <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( ) ; } } libraries . add ( this ) ; <ect>
system . err . println ( <string_literal> ) ; system . err . println ( get <identifiersep> path ( ) ) ; system . err . println ( <string_literal> ) ; for ( library library : libraries ) { system . err . println ( library . get <identifiersep> path ( ) ) ; } system . err . println ( <string_literal> + pkg ) ; <LOG> system . err . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; system . err . println ( ) ; } } libraries . add ( this ) ; } } public boolean has <identifiersep> examples ( ) { return examples <identifiersep> folder . exists ( ) ; <ect>
<comment> for ( i = index ; i < nread ; i ++ ) { if ( buf [ i ] == ( byte ) ' ' ) { break ; } } string fname = new string ( buf , index , i - index ) ; <comment> <LOG> zip <identifiersep> entry entry = entries . get ( fname . substring ( 1 ) ) ; boolean ok = print <identifiersep> headers ( entry , ps ) ; if ( entry != null ) { input <identifiersep> stream stream = zip . get <identifiersep> input <identifiersep> stream ( entry ) ; if ( doing <identifiersep> get && ok ) { send <identifiersep> file ( stream , ps ) ; <ect>
<comment> public int x <identifiersep> to <identifiersep> offset ( int line , int x ) { token <identifiersep> marker <identifiersep> state token <identifiersep> marker = get <identifiersep> token <identifiersep> marker ( ) ; <comment> <LOG> font <identifiersep> metrics fm = painter . get <identifiersep> font <identifiersep> metrics ( ) ; get <identifiersep> line <identifiersep> text ( line , line <identifiersep> segment ) ; char [ ] segment <identifiersep> array = line <identifiersep> segment . array ; int segment <identifiersep> offset = line <identifiersep> segment . offset ; int segment <identifiersep> count = line <identifiersep> segment . count ; int width = horizontal <identifiersep> offset ; <ect>
caret <identifiersep> timer . restart ( ) ; } <comment> <LOG> <comment> <ect>
buffer . append ( <string_literal> + ( ( int ) c ) + <string_literal> ) ; <comment> <LOG> public void paste ( ) { if ( editable ) { clipboard clipboard = get <identifiersep> toolkit ( ) . get <identifiersep> system <identifiersep> clipboard ( ) ; try { string selection = ( ( string ) clipboard . get <identifiersep> contents ( this ) . get <identifiersep> transfer <identifiersep> data ( data <identifiersep> flavor . string <identifiersep> flavor ) ) ; <ect>
if ( file != null && file . exists ( ) ) { string [ ] lines = p <identifiersep> applet . load <identifiersep> strings ( file ) ; int start = 0 ; while ( start < lines . length ) { string type = lines [ start ] ; contribution <identifiersep> type contrib <identifiersep> type = contribution <identifiersep> type . from <identifiersep> name ( type ) ; <LOG> if ( contrib <identifiersep> type == null ) { <comment> <ect>
if ( paragraph == null || paragraph . is <identifiersep> empty ( ) ) { paragraph = get <identifiersep> paragraph ( ) ; } int version ; try { version = integer . parse <identifiersep> int ( properties . get ( <string_literal> ) ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { <LOG> version = get <identifiersep> version ( ) ; system . err . println ( <string_literal> ) ; } string pretty <identifiersep> version = properties . get ( <string_literal> ) ; if ( pretty <identifiersep> version != null && pretty <identifiersep> version . is <identifiersep> empty ( ) ) { pretty <identifiersep> version = null ; } string compatible <identifiersep> contribs <identifiersep> list = null ; <ect>
error <identifiersep> panel . validate ( ) ; } protected void update <identifiersep> category <identifiersep> chooser ( ) { if ( category <identifiersep> chooser != null ) { array <identifiersep> list < string > categories ; category <identifiersep> chooser . remove <identifiersep> all <identifiersep> items ( ) ; categories = new array <identifiersep> list < string > ( contrib <identifiersep> listing . get <identifiersep> categories ( filter ) ) ; <LOG> <comment> <ect>
<comment> <LOG> outgoing . add ( font ) ; } } } return outgoing ; } static public string [ ] get <identifiersep> mono <identifiersep> font <identifiersep> families ( ) { string <identifiersep> list families = new string <identifiersep> list ( ) ; for ( font font : get <identifiersep> mono <identifiersep> font <identifiersep> list ( ) ) { families . append <identifiersep> unique ( font . get <identifiersep> family ( ) ) ; <ect>
slider <identifiersep> box . set <identifiersep> border ( border <identifiersep> factory . create <identifiersep> bevel <identifiersep> border ( bevel <identifiersep> border . lowered ) ) ; slider <identifiersep> box . add ( slider ) ; box . add ( slider <identifiersep> box ) ; box . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; box . add ( create <identifiersep> color <identifiersep> fields ( button <identifiersep> name , button <identifiersep> listener ) ) ; <comment> <LOG> box . add ( box . create <identifiersep> horizontal <identifiersep> strut ( <number_literal> ) ) ; window . get <identifiersep> content <identifiersep> pane ( ) . add ( box , border <identifiersep> layout . center ) ; <comment> <ect>
saturation <identifiersep> field . get <identifiersep> document ( ) . add <identifiersep> document <identifiersep> listener ( color <identifiersep> listener ) ; brightness <identifiersep> field . get <identifiersep> document ( ) . add <identifiersep> document <identifiersep> listener ( color <identifiersep> listener ) ; red <identifiersep> field . get <identifiersep> document ( ) . add <identifiersep> document <identifiersep> listener ( color <identifiersep> listener ) ; green <identifiersep> field . get <identifiersep> document ( ) . add <identifiersep> document <identifiersep> listener ( color <identifiersep> listener ) ; blue <identifiersep> field . get <identifiersep> document ( ) . add <identifiersep> document <identifiersep> listener ( color <identifiersep> listener ) ; hex <identifiersep> field . get <identifiersep> document ( ) . add <identifiersep> document <identifiersep> listener ( color <identifiersep> listener ) ; <LOG> set <identifiersep> color ( initial <identifiersep> color ) ; } <comment> <ect>
<comment> <LOG> if ( tab <identifiersep> index == 0 ) { tab <identifiersep> index = sketch . get <identifiersep> code <identifiersep> count ( ) ; } else if ( tab <identifiersep> index == 0 ) { break ; } try { document doc = sketch . get <identifiersep> code ( tab <identifiersep> index - 1 ) . get <identifiersep> document ( ) ; <ect>
<comment> <LOG> return key ; } return string . format ( value , arguments ) ; } static public string pluralize ( string key , int count ) { <comment> <ect>
return false ; } return boolean . parse <identifiersep> boolean ( value ) ; } public void set <identifiersep> boolean ( string attribute , boolean value ) { set ( attribute , value ? <string_literal> : <string_literal> ) ; } public int get <identifiersep> integer ( string attribute ) { string value = get ( attribute ) ; <LOG> if ( value == null ) { return 0 ; } return integer . parse <identifiersep> int ( value ) ; } public void set <identifiersep> integer ( string key , int value ) { set ( key , string . value <identifiersep> of ( value ) ) ; } public color get <identifiersep> color ( string attribute ) { <ect>
<comment> <LOG> } catch ( exception e ) { <comment> <ect>
<comment> <LOG> err <identifiersep> thread . join ( ) ; <comment> <ect>
<comment> <LOG> <comment> <ect>
tweak <identifiersep> client . get <identifiersep> server <identifiersep> code ( port , num <identifiersep> of <identifiersep> ints > 0 , num <identifiersep> of <identifiersep> floats > 0 ) ; code [ 0 ] . set <identifiersep> program ( header + c + server <identifiersep> code ) ; <comment> <LOG> if ( preferences . get <identifiersep> boolean ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code ) ) { for ( int i = 0 ; i < code . length ; i ++ ) { system . out . println ( <string_literal> + i + <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( code [ i ] . get <identifiersep> program ( ) ) ; } } return true ; <ect>
string show <identifiersep> mod <identifiersep> code = preferences . get ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code ) ; if ( show <identifiersep> mod <identifiersep> code == null ) { preferences . set <identifiersep> boolean ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code , false ) ; } if ( preferences . get <identifiersep> boolean ( pref <identifiersep> tweak <identifiersep> show <identifiersep> code ) ) { system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < code . length ; i ++ ) { <LOG> system . out . println ( <string_literal> + i + <string_literal> ) ; system . out . println ( code [ i ] . get <identifiersep> program ( ) ) ; } } return true ; } static private string replace <identifiersep> string ( string str , int start , int end , string put ) { return str . substring ( 0 , start ) + put + str . substring ( end , str . length ( ) ) ; } <comment> <ect>
else { string <identifiersep> builder ans = new string <identifiersep> builder ( label ) ; while ( ans . index <identifiersep> of ( <string_literal> ) > - 1 ) { int a = ans . index <identifiersep> of ( <string_literal> ) , b = ans . index <identifiersep> of ( <string_literal> ) ; if ( a > b ) break ; ans . replace ( a , b + 1 , <string_literal> ) ; <LOG> <comment> <ect>
nodes = ( ( block ) parent ) . statements ( ) ; } else { log ( <string_literal> + get <identifiersep> node <identifiersep> as <identifiersep> string ( parent ) ) ; return null ; } if ( nodes . size ( ) > 0 ) { ast <identifiersep> node ret <identifiersep> node = parent ; <LOG> for ( ast <identifiersep> node c <identifiersep> node : nodes ) { if ( get <identifiersep> line <identifiersep> number ( c <identifiersep> node ) < = line <identifiersep> number ) ret <identifiersep> node = c <identifiersep> node ; } return ret <identifiersep> node ; } return parent ; } <comment> <ect>
return ( ( variable <identifiersep> declaration <identifiersep> expression ) node ) . get <identifiersep> type ( ) ; case ast <identifiersep> node . variable <identifiersep> declaration <identifiersep> statement : return ( ( variable <identifiersep> declaration <identifiersep> statement ) node ) . get <identifiersep> type ( ) ; case ast <identifiersep> node . single <identifiersep> variable <identifiersep> declaration : return ( ( single <identifiersep> variable <identifiersep> declaration ) node ) . get <identifiersep> type ( ) ; case ast <identifiersep> node . variable <identifiersep> declaration <identifiersep> fragment : <LOG> return extrac <identifiersep> type <identifiersep> info2 ( node . get <identifiersep> parent ( ) ) ; } return null ; } static protected ast <identifiersep> node defined <identifiersep> in ( ast <identifiersep> node node , string name , array <identifiersep> list < integer > constrains ) { if ( node == null ) return null ; <ect>
boolean no <identifiersep> compare = phrase . ends <identifiersep> with ( <string_literal> ) ; if ( no <identifiersep> compare ) { phrase = phrase . substring ( 0 , phrase . length ( ) - 1 ) ; } boolean incremental = ! no <identifiersep> compare && phrase . length ( ) > last <identifiersep> predicted <identifiersep> phrase . length ( ) && phrase . starts <identifiersep> with ( last <identifiersep> predicted <identifiersep> phrase ) ; <LOG> if ( incremental ) { log ( <string_literal> ) ; if ( phrase . contains ( <string_literal> ) ) { int x = phrase . last <identifiersep> index <identifiersep> of ( ' . ' ) ; candidates = trim <identifiersep> candidates ( phrase . substring ( x + 1 ) , candidates ) ; } else { <ect>
if ( ! t . is <identifiersep> suspended ( ) ) { return ; } try { system . out . println ( <string_literal> + t . name ( ) + <string_literal> ) ; int i = 0 ; for ( stack <identifiersep> frame f : t . frames ( ) ) { <LOG> <comment> <ect>
<comment> protected void print <identifiersep> thread ( thread <identifiersep> reference t ) { <LOG> system . out . println ( t . name ( ) ) ; system . out . println ( <string_literal> + t . is <identifiersep> at <identifiersep> breakpoint ( ) ) ; system . out . println ( <string_literal> + thread <identifiersep> status <identifiersep> to <identifiersep> string ( t . status ( ) ) ) ; } <comment> <ect>
<comment> protected void print <identifiersep> thread ( thread <identifiersep> reference t ) { system . out . println ( t . name ( ) ) ; system . out . println ( <string_literal> + t . is <identifiersep> suspended ( ) ) ; <LOG> system . out . println ( <string_literal> + t . is <identifiersep> at <identifiersep> breakpoint ( ) ) ; } <comment> <ect>
<comment> <LOG> protected tree <identifiersep> path synthesize <identifiersep> path ( tree <identifiersep> path path ) { if ( path . get <identifiersep> path <identifiersep> count ( ) == 0 || ! root <identifiersep> node . equals ( path . get <identifiersep> path <identifiersep> component ( 0 ) ) ) { return null ; } object [ ] new <identifiersep> path = new object [ path . get <identifiersep> path <identifiersep> count ( ) ] ; new <identifiersep> path [ 0 ] = root <identifiersep> node ; tree <identifiersep> node current <identifiersep> node = root <identifiersep> node ; <ect>
tree <identifiersep> node next <identifiersep> node = current <identifiersep> node . get <identifiersep> child <identifiersep> at ( j ) ; if ( next <identifiersep> node . equals ( path . get <identifiersep> path <identifiersep> component ( i + 1 ) ) ) { current <identifiersep> node = next <identifiersep> node ; new <identifiersep> path [ i + 1 ] = next <identifiersep> node ; <comment> <LOG> if ( new <identifiersep> path [ i + 1 ] == null ) { return null ; } } return new tree <identifiersep> path ( new <identifiersep> path ) ; } <comment> <ect>
if ( get <identifiersep> class ( ) != obj . get <identifiersep> class ( ) ) { return false ; } final variable <identifiersep> node other = ( variable <identifiersep> node ) obj ; if ( ( this . type == null ) ? ( other . type != null ) : ! this . type . equals ( other . type ) ) { <comment> <LOG> if ( ( this . name == null ) ? ( other . name != null ) : ! this . name . equals ( other . name ) ) { return false ; } if ( this . value != other . value && ( this . value == null || ! this . value . equals ( other . value ) ) ) { <comment> <ect>
offset += count ; remaining -= count ; } zos . write ( buffer ) ; zos . flush ( ) ; zos . close <identifiersep> entry ( ) ; } } file . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } else { <comment> <ect>
} else if ( <string_literal> . equals ( type ) ) { tweak <identifiersep> client . send <identifiersep> int ( index , new <identifiersep> value . int <identifiersep> value ( ) ) ; } else if ( <string_literal> . equals ( type ) ) { tweak <identifiersep> client . send <identifiersep> int ( index , new <identifiersep> value . int <identifiersep> value ( ) ) ; } else if ( <string_literal> . equals ( type ) ) { tweak <identifiersep> client . send <identifiersep> float ( index , new <identifiersep> value . float <identifiersep> value ( ) ) ; } <LOG> } catch ( exception e ) { } } public string to <identifiersep> string ( ) { return type + <string_literal> + name + <string_literal> + str <identifiersep> value + <string_literal> + tab <identifiersep> index + <string_literal> + line + <string_literal> + start <identifiersep> char + <string_literal> + end <identifiersep> char + <string_literal> ; } } <comment> <ect>
writer . flush ( ) ; writer . close ( ) ; buffered <identifiersep> reader reader = new buffered <identifiersep> reader ( new string <identifiersep> reader ( error <identifiersep> buffer . to <identifiersep> string ( ) ) ) ; <comment> <LOG> while ( ( line = reader . read <identifiersep> line ( ) ) != null ) { <comment> <ect>
have <identifiersep> exit <identifiersep> code = true ; } catch ( illegal <identifiersep> thread <identifiersep> state <identifiersep> exception e ) { <comment> <LOG> } catch ( io <identifiersep> exception e ) { return false ; } catch ( interrupted <identifiersep> exception e ) { system . out . println ( <string_literal> + file + <string_literal> + e ) ; return false ; <ect>
<comment> <comment> <LOG> <comment> <ect>
super . end <identifiersep> record ( ) ; dispose ( ) ; } public void end <identifiersep> raw ( ) { system . out . println ( <string_literal> ) ; super . end <identifiersep> raw ( ) ; system . out . println ( <string_literal> ) ; <LOG> <comment> <comment> <ect>
import org . gradle . test . fixtures . file . test <identifiersep> file import org . gradle . util . text <identifiersep> util import spock . lang . ignore <identifiersep> if class cached <identifiersep> task <identifiersep> execution <identifiersep> integration <identifiersep> test extends abstract <identifiersep> integration <identifiersep> spec implements directory <identifiersep> build <identifiersep> cache <identifiersep> fixture { public static final string original <identifiersep> hello <identifiersep> world = <string_literal> <string_literal> <LOG> public static void main ( string . . . args ) { } } <string_literal> <string_literal> <string_literal> public class hello { public static void main ( string . . . args ) { system . out . println ( <string_literal> ) ; <ect>
def original <identifiersep> home = file ( <string_literal> ) . create <identifiersep> dir ( ) original <identifiersep> location . file ( <string_literal> ) . text = external <identifiersep> task <identifiersep> def ( ) original <identifiersep> location . file ( <string_literal> ) < < <string_literal> original <identifiersep> location . file ( <string_literal> ) < < <string_literal> original <identifiersep> location . file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> public static void main ( string . . . args ) { } } <string_literal> <string_literal> build . gradle <string_literal> <string_literal> println <string_literal> println <string_literal> apply plugin : <string_literal> <ect>
private $option <identifiersep> type my <identifiersep> prop ; @ option ( option = <string_literal> , description = <string_literal> ) @ option ( option = <string_literal> , description = <string_literal> ) public void set <identifiersep> my <identifiersep> prop ( $option <identifiersep> type my <identifiersep> prop ) { this . my <identifiersep> prop = my <identifiersep> prop ; } @ task <identifiersep> action <LOG> public void render <identifiersep> option <identifiersep> value ( ) { } private static enum test <identifiersep> enum { opt <identifiersep> 1 , opt <identifiersep> <number_literal> , opt <identifiersep> <number_literal> } } <string_literal> <string_literal> <ect>
maybe <identifiersep> show <identifiersep> failure ( output ) ; } @ override public void done ( ) { assert started ; try { int suppressed <identifiersep> count = number <identifiersep> of <identifiersep> failed <identifiersep> operations <identifiersep> seen - configuration . get <identifiersep> maximum <identifiersep> failed <identifiersep> operations <identifiersep> shown ( ) ; <LOG> if ( suppressed <identifiersep> count > 0 ) { } log <identifiersep> in <identifiersep> both ( log <identifiersep> level . info , string . format ( <string_literal> , configuration . get <identifiersep> task <identifiersep> name ( ) , get <identifiersep> log <identifiersep> location ( ) ) ) ; } finally { io <identifiersep> utils . close <identifiersep> quietly ( log <identifiersep> writer ) ; started = false ; } } private void maybe <identifiersep> show <identifiersep> success ( string output ) { <ect>
object parent <identifiersep> id = parents . remove ( id ) ; if ( active . remove ( id ) == null ) { return ; } finished notification = new finished ( finish <identifiersep> event . get <identifiersep> end <identifiersep> time ( ) , id , parent <identifiersep> id , build <identifiersep> operation . get <identifiersep> details ( ) , finish <identifiersep> event . get <identifiersep> result ( ) , finish <identifiersep> event . get <identifiersep> failure ( ) ) ; try { notification <identifiersep> listener . finished ( notification ) ; <LOG> } catch ( throwable e ) { maybe <identifiersep> throw ( e ) ; } } } private static class recording <identifiersep> listener implements build <identifiersep> operation <identifiersep> notification <identifiersep> listener2 { private final queue < object > stored <identifiersep> events = new concurrent <identifiersep> linked <identifiersep> queue < object > ( ) ; @ override public void started ( build <identifiersep> operation <identifiersep> started <identifiersep> notification notification ) { <ect>
private boolean in <identifiersep> combined <identifiersep> roots <identifiersep> or <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root <identifiersep> this ( file file ) { return in <identifiersep> combined <identifiersep> roots <identifiersep> or <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( file , roots , combined <identifiersep> roots ) ; } public iterable < ? extends file > get <identifiersep> starting <identifiersep> watch <identifiersep> points ( ) { return starting <identifiersep> watch <identifiersep> points ; } public boolean should <identifiersep> watch ( file file ) { boolean result = in <identifiersep> combined <identifiersep> roots <identifiersep> or <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root <identifiersep> this ( file ) || is <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( file , all <identifiersep> requested <identifiersep> roots ) ; <LOG> if ( ! result ) { } return result ; } } static private boolean in <identifiersep> combined <identifiersep> roots <identifiersep> or <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( file file , iterable < ? extends file > roots , file <identifiersep> system <identifiersep> subset combined <identifiersep> roots <identifiersep> subset ) { return combined <identifiersep> roots <identifiersep> subset . contains ( file ) || is <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( file , roots , true ) ; } static private boolean is <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( file file , iterable < ? extends file > roots ) { return is <identifiersep> ancestor <identifiersep> of <identifiersep> any <identifiersep> root ( file , roots , false ) ; <ect>
<comment> <LOG> } else { } } else { logger . info ( <string_literal> , task ) ; } } delegate . execute ( task , state , context ) ; if ( task <identifiersep> output <identifiersep> caching <identifiersep> enabled ) { if ( cache <identifiersep> key . is <identifiersep> valid ( ) ) { <ect>
if ( cache <identifiersep> key . is <identifiersep> valid ( ) ) { if ( state . get <identifiersep> failure ( ) == null ) { try { task <identifiersep> artifact <identifiersep> state task <identifiersep> state = context . get <identifiersep> task <identifiersep> artifact <identifiersep> state ( ) ; map < string , map < string , file <identifiersep> content <identifiersep> snapshot > > output <identifiersep> snapshots = task <identifiersep> state . get <identifiersep> output <identifiersep> content <identifiersep> snapshots ( ) ; build <identifiersep> cache . store ( build <identifiersep> cache <identifiersep> command <identifiersep> factory . create <identifiersep> store ( cache <identifiersep> key , output <identifiersep> properties , output <identifiersep> snapshots , task , context . get <identifiersep> execution <identifiersep> time ( ) ) ) ; <LOG> } catch ( exception e ) { } } else { logger . debug ( <string_literal> , task ) ; } } else { logger . info ( <string_literal> , task ) ; } } } private static sorted <identifiersep> set < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > resolve <identifiersep> properties ( immutable <identifiersep> sorted <identifiersep> set < ? extends task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > properties ) { <ect>
map < string , map < string , file <identifiersep> content <identifiersep> snapshot > > output <identifiersep> snapshots = task <identifiersep> state . get <identifiersep> output <identifiersep> content <identifiersep> snapshots ( ) ; build <identifiersep> cache . store ( build <identifiersep> cache <identifiersep> command <identifiersep> factory . create <identifiersep> store ( cache <identifiersep> key , output <identifiersep> properties , output <identifiersep> snapshots , task , context . get <identifiersep> execution <identifiersep> time ( ) ) ) ; } catch ( exception e ) { logger . warn ( <string_literal> , cache <identifiersep> key . get <identifiersep> display <identifiersep> name ( ) , task , e ) ; } } else { logger . debug ( <string_literal> , task ) ; } <LOG> } else { } } } private static sorted <identifiersep> set < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > resolve <identifiersep> properties ( immutable <identifiersep> sorted <identifiersep> set < ? extends task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > properties ) { immutable <identifiersep> sorted <identifiersep> set . builder < resolved <identifiersep> task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec > builder = immutable <identifiersep> sorted <identifiersep> set . natural <identifiersep> order ( ) ; for ( task <identifiersep> output <identifiersep> file <identifiersep> property <identifiersep> spec property : properties ) { <comment> <ect>
boolean did <identifiersep> work = false ; delete <identifiersep> spec <identifiersep> internal delete <identifiersep> spec = new default <identifiersep> delete <identifiersep> spec ( ) ; action . execute ( delete <identifiersep> spec ) ; object [ ] paths = delete <identifiersep> spec . get <identifiersep> paths ( ) ; for ( file file : file <identifiersep> resolver . resolve <identifiersep> files ( paths ) ) { if ( ! file . exists ( ) ) { <LOG> continue ; } did <identifiersep> work = true ; do <identifiersep> delete <identifiersep> internal ( file , delete <identifiersep> spec ) ; } return work <identifiersep> results . did <identifiersep> work ( did <identifiersep> work ) ; } private void do <identifiersep> delete <identifiersep> internal ( file file , delete <identifiersep> spec <identifiersep> internal delete <identifiersep> spec ) { if ( file . is <identifiersep> directory ( ) && ( delete <identifiersep> spec . is <identifiersep> follow <identifiersep> symlinks ( ) || ! file <identifiersep> system . is <identifiersep> symlink ( file ) ) ) { <ect>
cached <identifiersep> class <identifiersep> loader cached <identifiersep> class <identifiersep> loader ; lock . lock ( ) ; try { cache <identifiersep> entry cache <identifiersep> entry = cache <identifiersep> entries . get ( lib <identifiersep> classpath ) ; cached <identifiersep> class <identifiersep> loader = maybe <identifiersep> get ( cache <identifiersep> entry ) ; <LOG> if ( cached <identifiersep> class <identifiersep> loader == null ) { } <comment> <ect>
this . gradle <identifiersep> api <identifiersep> groovy <identifiersep> loader = copy . gradle <identifiersep> api <identifiersep> groovy <identifiersep> loader ; this . ant <identifiersep> adapter <identifiersep> groovy <identifiersep> loader = copy . ant <identifiersep> adapter <identifiersep> groovy <identifiersep> loader ; this . class <identifiersep> loader <identifiersep> cache = copy . class <identifiersep> loader <identifiersep> cache ; } public class <identifiersep> path <identifiersep> to <identifiersep> class <identifiersep> loader <identifiersep> cache get <identifiersep> class <identifiersep> loader <identifiersep> cache ( ) { return class <identifiersep> loader <identifiersep> cache ; } <LOG> public isolated <identifiersep> ant <identifiersep> builder with <identifiersep> classpath ( iterable < file > classpath ) { } return new default <identifiersep> isolated <identifiersep> ant <identifiersep> builder ( this , classpath ) ; } public void execute ( final closure ant <identifiersep> closure ) { class <identifiersep> loader <identifiersep> cache . with <identifiersep> cached <identifiersep> class <identifiersep> loader ( lib <identifiersep> classpath , gradle <identifiersep> api <identifiersep> groovy <identifiersep> loader , ant <identifiersep> adapter <identifiersep> groovy <identifiersep> loader , new factory < class <identifiersep> loader > ( ) { @ override <ect>
public build <identifiersep> cache <identifiersep> load <identifiersep> command . result < origin <identifiersep> task <identifiersep> execution <identifiersep> metadata > load ( input <identifiersep> stream input ) { task <identifiersep> output <identifiersep> changes <identifiersep> listener . before <identifiersep> task <identifiersep> output <identifiersep> changed ( ) ; final task <identifiersep> output <identifiersep> packer . unpack <identifiersep> result unpack <identifiersep> result ; try { unpack <identifiersep> result = packer . unpack ( output <identifiersep> properties , input , task <identifiersep> output <identifiersep> origin <identifiersep> factory . create <identifiersep> reader ( task ) ) ; update <identifiersep> snapshots ( unpack <identifiersep> result . get <identifiersep> snapshots ( ) , unpack <identifiersep> result . get <identifiersep> origin <identifiersep> metadata ( ) ) ; <LOG> } catch ( exception e ) { try { cleanup <identifiersep> outputs <identifiersep> after <identifiersep> unpack <identifiersep> failure ( ) ; task <identifiersep> artifact <identifiersep> state . after <identifiersep> outputs <identifiersep> removed <identifiersep> before <identifiersep> task ( ) ; } catch ( exception e <identifiersep> cleanup ) { logger . warn ( <string_literal> , e <identifiersep> cleanup ) ; <ect>
task <identifiersep> artifact <identifiersep> state . after <identifiersep> outputs <identifiersep> removed <identifiersep> before <identifiersep> task ( ) ; } catch ( exception e <identifiersep> cleanup ) { logger . warn ( <string_literal> , e <identifiersep> cleanup ) ; throw new unrecoverable <identifiersep> task <identifiersep> output <identifiersep> unpacking <identifiersep> exception ( string . format ( <string_literal> , task ) , e ) ; } throw new gradle <identifiersep> exception ( string . format ( <string_literal> , task ) , e ) ; } finally { <LOG> clean <identifiersep> local <identifiersep> state ( ) ; } return new build <identifiersep> cache <identifiersep> load <identifiersep> command . result < origin <identifiersep> task <identifiersep> execution <identifiersep> metadata > ( ) { @ override public long get <identifiersep> artifact <identifiersep> entry <identifiersep> count ( ) { return unpack <identifiersep> result . get <identifiersep> entries ( ) ; } @ override <ect>
this . process <identifiersep> builder <identifiersep> factory = new process <identifiersep> builder <identifiersep> factory ( ) ; this . exec <identifiersep> handle = exec <identifiersep> handle ; } public void abort <identifiersep> process ( ) { lock . lock ( ) ; try { aborted = true ; <LOG> if ( process != null ) { process . destroy ( ) ; } } finally { lock . unlock ( ) ; } } public void run ( ) { try { <ect>
system . out . println ( <string_literal> ) ; system . out . close ( ) ; system . err . close ( ) ; int nap <identifiersep> time = ( args . length == 0 ) ? 10000l : integer . value <identifiersep> of ( args [ 0 ] ) thread . sleep ( nap <identifiersep> time ) ; } } public static class fast <identifiersep> daemon <identifiersep> app { <LOG> public static void main ( string [ ] args ) throws interrupted <identifiersep> exception { system . out . close ( ) ; system . err . close ( ) ; } } public static class input <identifiersep> reading <identifiersep> app { public static void main ( string [ ] args ) throws interrupted <identifiersep> exception { object <identifiersep> input <identifiersep> stream instr = new object <identifiersep> input <identifiersep> stream ( system . in ) ; <ect>
} ; } private string data ; @ factory ( data <identifiersep> provider = <string_literal> ) public test <identifiersep> factory ( string data ) { this . data = data ; } @ before <identifiersep> class <LOG> public void before <identifiersep> class ( ) { } @ test public void test1 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { <ect>
public void before <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test public void test1 ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) <LOG> public void test2 ( ) { } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> + data + <string_literal> ) ; } } <ect>
if ( args . length > 1 ) { connector . use <identifiersep> gradle <identifiersep> user <identifiersep> home <identifiersep> dir ( new file ( args [ 1 ] ) ) ; } } connector . for <identifiersep> project <identifiersep> directory ( new file ( <string_literal> ) ) ; project <identifiersep> connection connection = connector . connect ( ) ; try { idea <identifiersep> project project = connection . get <identifiersep> model ( idea <identifiersep> project . class ) ; <LOG> system . out . println ( <string_literal> ) ; system . out . println ( project ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { system . out . println ( <string_literal> + module ) ; <ect>
project <identifiersep> connection connection = connector . connect ( ) ; try { idea <identifiersep> project project = connection . get <identifiersep> model ( idea <identifiersep> project . class ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( project ) ; <LOG> system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { <ect>
system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; system . out . println ( project ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; for ( idea <identifiersep> module module : project . get <identifiersep> modules ( ) ) { <LOG> system . out . println ( <string_literal> + module ) ; system . out . println ( <string_literal> ) ; for ( gradle <identifiersep> task task : module . get <identifiersep> gradle <identifiersep> project ( ) . get <identifiersep> tasks ( ) ) { system . out . println ( <string_literal> + task . get <identifiersep> name ( ) ) ; } for ( idea <identifiersep> content <identifiersep> root root : module . get <identifiersep> content <identifiersep> roots ( ) ) { system . out . println ( <string_literal> + root . get <identifiersep> root <identifiersep> directory ( ) ) ; <ect>
@ nullable private resource <identifiersep> handler select <identifiersep> handler ( int id , http <identifiersep> exchange http <identifiersep> exchange ) { lock . lock ( ) ; try { request <identifiersep> count ++ ; condition . signal <identifiersep> all ( ) ; <LOG> if ( completed ) { return null ; } for ( tracking <identifiersep> http <identifiersep> handler handler : handlers ) { resource <identifiersep> handler resource <identifiersep> handler = handler . handle ( id , http <identifiersep> exchange ) ; if ( resource <identifiersep> handler != null ) { return resource <identifiersep> handler ; <ect>
for ( tracking <identifiersep> http <identifiersep> handler handler : handlers ) { resource <identifiersep> handler resource <identifiersep> handler = handler . handle ( id , http <identifiersep> exchange ) ; if ( resource <identifiersep> handler != null ) { return resource <identifiersep> handler ; } } system . out . println ( string . format ( <string_literal> , id , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) ) ) ; failures . add ( new assertion <identifiersep> error ( string . format ( <string_literal> , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) . get <identifiersep> path ( ) ) ) ) ; <LOG> } catch ( throwable t ) { failures . add ( new assertion <identifiersep> error ( string . format ( <string_literal> , http <identifiersep> exchange . get <identifiersep> request <identifiersep> method ( ) , http <identifiersep> exchange . get <identifiersep> request <identifiersep> uri ( ) . get <identifiersep> path ( ) ) , t ) ) ; } finally { lock . unlock ( ) ; } return null ; } void wait <identifiersep> for <identifiersep> requests ( int request <identifiersep> count ) { <ect>
handle <identifiersep> connection ( output <identifiersep> stream ) ; output <identifiersep> stream . flush ( ) ; } finally { connection . close ( ) ; } } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } <LOG> private void handle <identifiersep> connection ( output <identifiersep> stream output <identifiersep> stream ) throws io <identifiersep> exception { synchronized ( lock ) { if ( connected ) { system . out . println ( <string_literal> ) ; output <identifiersep> stream . write ( <string_literal> . get <identifiersep> bytes ( ) ) ; return ; <ect>
<number_literal> . times { map . put ( uuid . random <identifiersep> uuid ( ) , <string_literal> * $ { leak <identifiersep> rate } ) } } else { logger . warn <string_literal> } sleep <number_literal> } <string_literal> <string_literal> <LOG> string log <identifiersep> jdk ( ) { } } <ect>
enumeration < network <identifiersep> interface > interfaces = network <identifiersep> interface . get <identifiersep> network <identifiersep> interfaces ( ) ; while ( interfaces . has <identifiersep> more <identifiersep> elements ( ) ) { analyze <identifiersep> network <identifiersep> interface ( interfaces . next <identifiersep> element ( ) ) ; } } private void analyze <identifiersep> network <identifiersep> interface ( network <identifiersep> interface network <identifiersep> interface ) { logger . debug ( <string_literal> , network <identifiersep> interface . get <identifiersep> display <identifiersep> name ( ) ) ; try { <LOG> boolean is <identifiersep> loopback <identifiersep> interface = network <identifiersep> interface . is <identifiersep> loopback ( ) ; boolean is <identifiersep> multicast = network <identifiersep> interface . supports <identifiersep> multicast ( ) ; logger . debug ( <string_literal> , is <identifiersep> multicast ) ; boolean is <identifiersep> remote = false ; enumeration < inet <identifiersep> address > candidates = network <identifiersep> interface . get <identifiersep> inet <identifiersep> addresses ( ) ; while ( candidates . has <identifiersep> more <identifiersep> elements ( ) ) { <ect>
logger . debug ( <string_literal> , is <identifiersep> multicast ) ; boolean is <identifiersep> remote = false ; enumeration < inet <identifiersep> address > candidates = network <identifiersep> interface . get <identifiersep> inet <identifiersep> addresses ( ) ; while ( candidates . has <identifiersep> more <identifiersep> elements ( ) ) { inet <identifiersep> address candidate = candidates . next <identifiersep> element ( ) ; if ( is <identifiersep> loopback <identifiersep> interface ) { <LOG> if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { loopback . add ( candidate ) ; } else { logger . debug ( <string_literal> , candidate ) ; } } else { if ( candidate . is <identifiersep> loopback <identifiersep> address ( ) ) { <ect>
this . file <identifiersep> resource <identifiersep> repository = file <identifiersep> resource <identifiersep> repository ; } @ nullable @ override public locally <identifiersep> available <identifiersep> external <identifiersep> resource get <identifiersep> resource ( final external <identifiersep> resource <identifiersep> name location , @ nullable string base <identifiersep> name , final resource <identifiersep> file <identifiersep> store file <identifiersep> store , @ nullable final locally <identifiersep> available <identifiersep> resource <identifiersep> candidates additional <identifiersep> candidates ) throws io <identifiersep> exception { return producer <identifiersep> guard . guard <identifiersep> by <identifiersep> key ( location , new factory < locally <identifiersep> available <identifiersep> external <identifiersep> resource > ( ) { @ override <LOG> public locally <identifiersep> available <identifiersep> external <identifiersep> resource create ( ) { cached <identifiersep> external <identifiersep> resource cached = cached <identifiersep> external <identifiersep> resource <identifiersep> index . lookup ( location . to <identifiersep> string ( ) ) ; <comment> <ect>
<comment> <LOG> if ( local != null ) { <comment> <ect>
private class no <identifiersep> maven <identifiersep> local <identifiersep> repository <identifiersep> resource <identifiersep> finder implements locally <identifiersep> available <identifiersep> resource <identifiersep> finder < module <identifiersep> component <identifiersep> artifact <identifiersep> metadata > { private final cannot <identifiersep> locate <identifiersep> local <identifiersep> maven <identifiersep> repository <identifiersep> exception ex ; private boolean logged ; public no <identifiersep> maven <identifiersep> local <identifiersep> repository <identifiersep> resource <identifiersep> finder ( cannot <identifiersep> locate <identifiersep> local <identifiersep> maven <identifiersep> repository <identifiersep> exception ex ) { this . ex = ex ; } public locally <identifiersep> available <identifiersep> resource <identifiersep> candidates find <identifiersep> candidates ( module <identifiersep> component <identifiersep> artifact <identifiersep> metadata criterion ) { <LOG> if ( ! logged ) { logger . debug ( <string_literal> , ex ) ; logged = true ; } return new locally <identifiersep> available <identifiersep> resource <identifiersep> candidates ( ) { public boolean is <identifiersep> none ( ) { return true ; <ect>
list < edge <identifiersep> state > transitive <identifiersep> incoming = get <identifiersep> transitive <identifiersep> incoming <identifiersep> edges ( ) ; <comment> <LOG> if ( has <identifiersep> incoming <identifiersep> edges ) { } else { logger . debug ( <string_literal> , this ) ; } return ; } <comment> <ect>
return ; } <comment> <LOG> <comment> <ect>
if ( ! resolve <identifiersep> state . get <identifiersep> edge <identifiersep> filter ( ) . is <identifiersep> satisfied <identifiersep> by ( dependency ) ) { logger . debug ( <string_literal> , dependency ) ; return true ; } if ( selector == module <identifiersep> exclusions . exclude <identifiersep> none ( ) ) { return false ; } module <identifiersep> identifier target <identifiersep> module <identifiersep> id = dependency <identifiersep> state . get <identifiersep> module <identifiersep> identifier ( ) ; <LOG> if ( selector . exclude <identifiersep> module ( target <identifiersep> module <identifiersep> id ) ) { return true ; } return false ; } public void add <identifiersep> incoming <identifiersep> edge ( edge <identifiersep> state dependency <identifiersep> edge ) { incoming <identifiersep> edges . add ( dependency <identifiersep> edge ) ; resolve <identifiersep> state . on <identifiersep> more <identifiersep> selected ( this ) ; <ect>
logger . debug ( <string_literal> , identifier , repository <identifiersep> names ) ; list < throwable > errors = new array <identifiersep> list < throwable > ( ) ; list < component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state > resolve <identifiersep> states = new array <identifiersep> list < component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state > ( ) ; for ( module <identifiersep> component <identifiersep> repository repository : repositories ) { resolve <identifiersep> states . add ( new component <identifiersep> meta <identifiersep> data <identifiersep> resolve <identifiersep> state ( identifier , component <identifiersep> override <identifiersep> metadata , repository , versioned <identifiersep> component <identifiersep> chooser ) ) ; } final repository <identifiersep> chain <identifiersep> module <identifiersep> resolution latest <identifiersep> resolved = find <identifiersep> best <identifiersep> match ( resolve <identifiersep> states , errors ) ; <LOG> if ( latest <identifiersep> resolved != null ) { for ( throwable error : errors ) { logger . debug ( <string_literal> , error ) ; } result . resolved ( meta <identifiersep> data <identifiersep> factory . transform ( latest <identifiersep> resolved ) ) ; return ; } if ( ! errors . is <identifiersep> empty ( ) ) { <ect>
this . versioned <identifiersep> component <identifiersep> chooser = versioned <identifiersep> component <identifiersep> chooser ; this . meta <identifiersep> data <identifiersep> factory = meta <identifiersep> data <identifiersep> factory ; } public void add ( module <identifiersep> component <identifiersep> repository repository ) { repositories . add ( repository ) ; repository <identifiersep> names . add ( repository . get <identifiersep> name ( ) ) ; } public void resolve ( module <identifiersep> dependency <identifiersep> metadata dependency , version <identifiersep> selector version <identifiersep> selector , version <identifiersep> selector rejected <identifiersep> version <identifiersep> selector , buildable <identifiersep> component <identifiersep> id <identifiersep> resolve <identifiersep> result result ) { <LOG> module <identifiersep> component <identifiersep> selector requested = dependency . get <identifiersep> selector ( ) ; list < throwable > errors = new array <identifiersep> list < throwable > ( ) ; list < repository <identifiersep> resolve <identifiersep> state > resolve <identifiersep> states = lists . new <identifiersep> array <identifiersep> list <identifiersep> with <identifiersep> capacity ( repositories . size ( ) ) ; for ( module <identifiersep> component <identifiersep> repository repository : repositories ) { resolve <identifiersep> states . add ( new repository <identifiersep> resolve <identifiersep> state ( versioned <identifiersep> component <identifiersep> chooser , dependency , repository , version <identifiersep> selector , rejected <identifiersep> version <identifiersep> selector ) ) ; } final repository <identifiersep> chain <identifiersep> module <identifiersep> resolution latest <identifiersep> resolved = find <identifiersep> latest <identifiersep> module ( resolve <identifiersep> states , errors ) ; <ect>
list < repository <identifiersep> resolve <identifiersep> state > resolve <identifiersep> states = lists . new <identifiersep> array <identifiersep> list <identifiersep> with <identifiersep> capacity ( repositories . size ( ) ) ; for ( module <identifiersep> component <identifiersep> repository repository : repositories ) { resolve <identifiersep> states . add ( new repository <identifiersep> resolve <identifiersep> state ( versioned <identifiersep> component <identifiersep> chooser , dependency , repository , version <identifiersep> selector , rejected <identifiersep> version <identifiersep> selector ) ) ; } final repository <identifiersep> chain <identifiersep> module <identifiersep> resolution latest <identifiersep> resolved = find <identifiersep> latest <identifiersep> module ( resolve <identifiersep> states , errors ) ; if ( latest <identifiersep> resolved != null ) { logger . debug ( <string_literal> , latest <identifiersep> resolved . module . get <identifiersep> module <identifiersep> version <identifiersep> id ( ) , latest <identifiersep> resolved . repository ) ; <LOG> for ( throwable error : errors ) { } result . resolved ( meta <identifiersep> data <identifiersep> factory . transform ( latest <identifiersep> resolved ) ) ; return ; } if ( ! errors . is <identifiersep> empty ( ) ) { result . failed ( new module <identifiersep> version <identifiersep> resolve <identifiersep> exception ( requested , errors ) ) ; } else { <ect>
import org . gradle . tooling . model . gradle . basic <identifiersep> gradle <identifiersep> project ; import org . gradle . tooling . model . gradle . gradle <identifiersep> build ; import java . util . map ; import java . util . tree <identifiersep> map ; public class get <identifiersep> model implements build <identifiersep> action < map < string , android <identifiersep> project > > { @ override <LOG> public map < string , android <identifiersep> project > execute ( build <identifiersep> controller controller ) { timer timer = new timer ( ) ; gradle <identifiersep> build build = controller . get <identifiersep> build <identifiersep> model ( ) ; map < string , android <identifiersep> project > result = new tree <identifiersep> map < string , android <identifiersep> project > ( ) ; for ( basic <identifiersep> gradle <identifiersep> project project : build . get <identifiersep> projects ( ) ) { android <identifiersep> project android <identifiersep> project = controller . find <identifiersep> model ( project , android <identifiersep> project . class ) ; <ect>
import org . gradle . tooling . build <identifiersep> action <identifiersep> executer ; import org . gradle . tooling . project <identifiersep> connection ; import java . util . map ; public class sync <identifiersep> action { <comment> <LOG> public static void with <identifiersep> project <identifiersep> connection ( project <identifiersep> connection connect , action < ? super build <identifiersep> action <identifiersep> executer < map < string , android <identifiersep> project > > > model <identifiersep> builder <identifiersep> action ) { timer sync <identifiersep> timer = new timer ( ) ; build <identifiersep> action <identifiersep> executer < map < string , android <identifiersep> project > > model <identifiersep> builder = connect . action ( new get <identifiersep> model ( ) ) ; model <identifiersep> builder . set <identifiersep> standard <identifiersep> output ( system . out ) ; model <identifiersep> builder . set <identifiersep> standard <identifiersep> error ( system . err ) ; model <identifiersep> builder . for <identifiersep> tasks ( <string_literal> ) ; <ect>
model <identifiersep> builder . set <identifiersep> jvm <identifiersep> arguments ( <string_literal> ) ; if ( model <identifiersep> builder <identifiersep> action != null ) { model <identifiersep> builder <identifiersep> action . execute ( model <identifiersep> builder ) ; } timer action <identifiersep> timer = new timer ( ) ; map < string , android <identifiersep> project > models = model <identifiersep> builder . run ( ) ; action <identifiersep> timer . stop ( ) ; <LOG> system . out . println ( <string_literal> + action <identifiersep> timer . duration ( ) ) ; new inspector ( ) . inspect <identifiersep> model ( models ) ; sync <identifiersep> timer . stop ( ) ; system . out . println ( <string_literal> + sync <identifiersep> timer . duration ( ) ) ; } } <ect>
public static class custom <identifiersep> task extends default <identifiersep> task { private final worker <identifiersep> executor executor ; @ inject public custom <identifiersep> task ( worker <identifiersep> executor executor ) { this . executor = executor ; } @ task <identifiersep> action <LOG> void print <identifiersep> it ( ) { } } @ override public void apply ( project p ) { p . get <identifiersep> tasks ( ) . create ( <string_literal> , custom <identifiersep> task . class ) ; } } ''' file ( 'build <identifiersep> src / src / main / resources / meta - <number_literal> / gradle - plugins / custom . properties' ) < < 'implementation - class = custom <identifiersep> plugin' <ect>
this . number = number ; this . executor = executor ; } @ task <identifiersep> action void print <identifiersep> it ( ) { if ( executor != null ) { system . out . println ( <string_literal> + number ) ; <LOG> } else { } } } @ override public void apply ( project p ) { p . get <identifiersep> tasks ( ) . create ( <string_literal> , custom <identifiersep> task . class , <number_literal> ) ; } } ''' file ( 'build <identifiersep> src / src / main / resources / meta - <number_literal> / gradle - plugins / custom . properties' ) < < 'implementation - class = custom <identifiersep> plugin' <ect>
$ { maven <identifiersep> central <identifiersep> repository ( ) } dependencies { compile group : 'org . scala - lang' , name : 'scala - library' , version : '2 . <number_literal> . 8' } <string_literal> <string_literal> <string_literal> public class required <identifiersep> by <identifiersep> scala { <LOG> public static void print <identifiersep> something ( ) { } } <string_literal> <string_literal> <string_literal> class uses <identifiersep> java { def print <identifiersep> something ( ) : unit = { <ect>
<comment> package org . gradle . integtests . tooling . r35 ; import org . gradle . tooling . build <identifiersep> action ; import org . gradle . tooling . build <identifiersep> controller ; public class simple <identifiersep> action implements build <identifiersep> action < string > { @ override <LOG> public string execute ( build <identifiersep> controller controller ) { return <string_literal> ; } } <ect>
tooling <identifiersep> api . close ( ) } def <string_literal> ( ) { tooling <identifiersep> api . verbose <identifiersep> logging = true file ( <string_literal> ) < < <string_literal> <string_literal> sys err logging xxx <string_literal> println logging yyy <string_literal> <LOG> project . logger . error ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; <string_literal> <string_literal> <ect>
should <identifiersep> not <identifiersep> contain <identifiersep> provider <identifiersep> logging ( err ) } def <string_literal> ( ) { assume . assume <identifiersep> true target <identifiersep> dist . tooling <identifiersep> api <identifiersep> non <identifiersep> ascii <identifiersep> output <identifiersep> supported tooling <identifiersep> api . verbose <identifiersep> logging = false file ( <string_literal> ) < < <string_literal> <string_literal> system . err \\ u03b1 \\ u03b2 <string_literal> <LOG> println <string_literal> project . logger . warn ( <string_literal> ) ; project . logger . lifecycle ( <string_literal> ) ; project . logger . quiet ( <string_literal> ) ; project . logger . info ( <string_literal> ) ; project . logger . debug ( <string_literal> ) ; <ect>
apply <identifiersep> java <identifiersep> plugin ( build <identifiersep> file ) main <identifiersep> library <identifiersep> depending <identifiersep> on <identifiersep> api ( dependency <identifiersep> scope . sources , api ) file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { private string name ; public int age ; <LOG> public void say <identifiersep> hello ( ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
''' file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; @ ann1 ( <string_literal> ) @ ann2 ( a = <string_literal> , b = <string_literal> ) public class person { private string name ; <LOG> public void say <identifiersep> hello ( ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
''' file ( 'src / my <identifiersep> lib / java / com / acme / person . java' ) < < '''package com . acme ; public class person { private string name ; @ ann1 ( <string_literal> ) @ ann2 ( a = <string_literal> , b = <string_literal> ) <LOG> public void say <identifiersep> hello ( ) { } } ''' and : test <identifiersep> app <identifiersep> depending <identifiersep> on <identifiersep> api <identifiersep> class ( ) expect : succeeds ' : my <identifiersep> lib <identifiersep> jar' <ect>
for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ test public void test <identifiersep> two ( ) { <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . err . println ( <string_literal> + i ) ; } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } } <ect>
private final static logger logger = logger <identifiersep> factory . get <identifiersep> logger ( abstract <identifiersep> maven <identifiersep> publisher . class ) ; private final local <identifiersep> maven <identifiersep> repository <identifiersep> locator maven <identifiersep> repository <identifiersep> locator ; public abstract <identifiersep> maven <identifiersep> publisher ( factory < logging <identifiersep> manager <identifiersep> internal > logging <identifiersep> manager <identifiersep> factory , local <identifiersep> maven <identifiersep> repository <identifiersep> locator maven <identifiersep> repository <identifiersep> locator ) { this . logging <identifiersep> manager <identifiersep> factory = logging <identifiersep> manager <identifiersep> factory ; this . maven <identifiersep> repository <identifiersep> locator = maven <identifiersep> repository <identifiersep> locator ; } public void publish ( maven <identifiersep> normalized <identifiersep> publication publication , maven <identifiersep> artifact <identifiersep> repository artifact <identifiersep> repository ) { <LOG> if ( artifact <identifiersep> repository == null ) { } else { logger . info ( <string_literal> , artifact <identifiersep> repository . get <identifiersep> name ( ) , artifact <identifiersep> repository . get <identifiersep> url ( ) ) ; } maven <identifiersep> publish <identifiersep> action deploy <identifiersep> task = create <identifiersep> deploy <identifiersep> task ( publication . get <identifiersep> pom <identifiersep> file ( ) , publication . get <identifiersep> metadata <identifiersep> file ( ) , maven <identifiersep> repository <identifiersep> locator , artifact <identifiersep> repository ) ; add <identifiersep> pom <identifiersep> and <identifiersep> artifacts ( deploy <identifiersep> task , publication ) ; execute ( deploy <identifiersep> task ) ; <ect>
public logging <identifiersep> maven <identifiersep> transfer <identifiersep> listener ( current <identifiersep> build <identifiersep> operation <identifiersep> ref current <identifiersep> build <identifiersep> operation <identifiersep> ref , build <identifiersep> operation <identifiersep> ref build <identifiersep> operation <identifiersep> ref ) { this . current <identifiersep> build <identifiersep> operation <identifiersep> ref = current <identifiersep> build <identifiersep> operation <identifiersep> ref ; this . build <identifiersep> operation <identifiersep> ref = build <identifiersep> operation <identifiersep> ref ; } public void transfer <identifiersep> initiated ( transfer <identifiersep> event event ) { previous <identifiersep> build <identifiersep> operation <identifiersep> ref . set ( current <identifiersep> build <identifiersep> operation <identifiersep> ref . get ( ) ) ; current <identifiersep> build <identifiersep> operation <identifiersep> ref . set ( build <identifiersep> operation <identifiersep> ref ) ; <LOG> string message = event . get <identifiersep> request <identifiersep> type ( ) == request <identifiersep> type . put ? <string_literal> : <string_literal> ; } public void transfer <identifiersep> started ( transfer <identifiersep> event event ) { long content <identifiersep> length = event . get <identifiersep> resource ( ) . get <identifiersep> content <identifiersep> length ( ) ; if ( content <identifiersep> length > 0 ) { logger . info ( <string_literal> , ( content <identifiersep> length + kilo / <number_literal> ) / kilo ) ; } } public void transfer <identifiersep> failed ( transfer <identifiersep> event event ) { <ect>
+ <string_literal> , daemon ) ; } } return compatible <identifiersep> daemons ; } private daemon <identifiersep> client <identifiersep> connection find <identifiersep> connection ( list < daemon <identifiersep> info > compatible <identifiersep> daemons ) { for ( daemon <identifiersep> info daemon : compatible <identifiersep> daemons ) { try { return connect <identifiersep> to <identifiersep> daemon ( daemon , new cleanup <identifiersep> on <identifiersep> stale <identifiersep> address ( daemon , true ) ) ; <LOG> } catch ( connect <identifiersep> exception e ) { } } return null ; } public daemon <identifiersep> client <identifiersep> connection start <identifiersep> daemon ( explaining <identifiersep> spec < daemon <identifiersep> context > constraint ) { return do <identifiersep> start <identifiersep> daemon ( constraint , false ) ; } private daemon <identifiersep> client <identifiersep> connection do <identifiersep> start <identifiersep> daemon ( explaining <identifiersep> spec < daemon <identifiersep> context > constraint , boolean single <identifiersep> run ) { progress <identifiersep> logger progress <identifiersep> logger = progress <identifiersep> logger <identifiersep> factory . new <identifiersep> operation ( default <identifiersep> daemon <identifiersep> connector . class ) <ect>
private class cleanup <identifiersep> on <identifiersep> stale <identifiersep> address implements daemon <identifiersep> client <identifiersep> connection . stale <identifiersep> address <identifiersep> detector { private final daemon <identifiersep> connect <identifiersep> details daemon ; private final boolean expose <identifiersep> as <identifiersep> stale ; public cleanup <identifiersep> on <identifiersep> stale <identifiersep> address ( daemon <identifiersep> connect <identifiersep> details daemon , boolean expose <identifiersep> as <identifiersep> stale ) { this . daemon = daemon ; this . expose <identifiersep> as <identifiersep> stale = expose <identifiersep> as <identifiersep> stale ; } <LOG> public boolean maybe <identifiersep> stale <identifiersep> address ( exception failure ) { final date timestamp = new date ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; final daemon <identifiersep> stop <identifiersep> event stop <identifiersep> event = new daemon <identifiersep> stop <identifiersep> event ( timestamp , daemon . get <identifiersep> pid ( ) , null , <string_literal> ) ; daemon <identifiersep> registry . store <identifiersep> stop <identifiersep> event ( stop <identifiersep> event ) ; daemon <identifiersep> registry . remove ( daemon . get <identifiersep> address ( ) ) ; return expose <identifiersep> as <identifiersep> stale ; <ect>
this . dispatch = dispatch ; } public void text ( string input ) { logger . debug ( <string_literal> , input . replace ( <string_literal> , <string_literal> ) ) ; } dispatch . dispatch ( new forward <identifiersep> input ( input . get <identifiersep> bytes ( ) ) ) ; } public void end <identifiersep> of <identifiersep> stream ( @ nullable throwable failure ) { <LOG> close <identifiersep> input message = new close <identifiersep> input ( ) ; dispatch . dispatch ( message ) ; } } } <ect>
public void on <identifiersep> cancel ( ) { logger . info ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . mark <identifiersep> state ( connector <identifiersep> address , canceled ) ; } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { logger . warn ( <string_literal> ) ; } } <LOG> public void on <identifiersep> start ( address connector <identifiersep> address ) { logger . debug ( <string_literal> , daemon <identifiersep> context ) ; this . connector <identifiersep> address = connector <identifiersep> address ; daemon <identifiersep> registry . store ( new daemon <identifiersep> info ( connector <identifiersep> address , daemon <identifiersep> context , token , busy ) ) ; } public void on <identifiersep> expire ( string reason , daemon <identifiersep> expiration <identifiersep> status status ) { logger . debug ( <string_literal> , reason ) ; <ect>
logger . warn ( <string_literal> ) ; } } public void on <identifiersep> start ( address connector <identifiersep> address ) { logger . info ( <string_literal> , daemon <identifiersep> messages . advertising <identifiersep> daemon , connector <identifiersep> address ) ; logger . debug ( <string_literal> , daemon <identifiersep> context ) ; this . connector <identifiersep> address = connector <identifiersep> address ; daemon <identifiersep> registry . store ( new daemon <identifiersep> info ( connector <identifiersep> address , daemon <identifiersep> context , token , busy ) ) ; } <LOG> public void on <identifiersep> expire ( string reason , daemon <identifiersep> expiration <identifiersep> status status ) { final date timestamp = new date ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; daemon <identifiersep> registry . store <identifiersep> stop <identifiersep> event ( new daemon <identifiersep> stop <identifiersep> event ( timestamp , daemon <identifiersep> context . get <identifiersep> pid ( ) , status , reason ) ) ; } public void stop ( ) { logger . debug ( <string_literal> , connector <identifiersep> address ) ; try { <ect>
final date timestamp = new date ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; daemon <identifiersep> registry . store <identifiersep> stop <identifiersep> event ( new daemon <identifiersep> stop <identifiersep> event ( timestamp , daemon <identifiersep> context . get <identifiersep> pid ( ) , status , reason ) ) ; } public void stop ( ) { logger . debug ( <string_literal> , connector <identifiersep> address ) ; try { daemon <identifiersep> registry . remove ( connector <identifiersep> address ) ; <LOG> } catch ( daemon <identifiersep> registry . empty <identifiersep> registry <identifiersep> exception e ) { } logger . debug ( <string_literal> ) ; } } <ect>
if ( message == null ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) ) ; return ; } if ( message instanceof input <identifiersep> message ) { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; stdin <identifiersep> queue . add ( ( input <identifiersep> message ) message ) ; <LOG> } else if ( message instanceof cancel ) { cancel <identifiersep> queue . add ( ( cancel ) message ) ; } else { logger . debug ( <string_literal> , thread . current <identifiersep> thread ( ) . get <identifiersep> id ( ) , message ) ; receive <identifiersep> queue . add ( message ) ; } } } finally { <ect>
try { if ( command instanceof close <identifiersep> input ) { handler . on <identifiersep> end <identifiersep> of <identifiersep> input ( ) ; return true ; } else { handler . on <identifiersep> input ( ( forward <identifiersep> input ) command ) ; } <LOG> } catch ( exception e ) { return true ; } return false ; } @ override protected void do <identifiersep> handle <identifiersep> disconnect ( ) { queue . clear ( ) ; <ect>
} finally { lock . unlock ( ) ; } run <identifiersep> action ( action ) ; } private void run <identifiersep> action ( runnable action ) { try { action . run ( ) ; <LOG> } catch ( exception e ) { } finally { lock . lock ( ) ; try { notifying = false ; condition . signal <identifiersep> all ( ) ; <ect>
long pid = null ; string runtime <identifiersep> mx <identifiersep> bean <identifiersep> name = management <identifiersep> factory . get <identifiersep> runtime <identifiersep> mx <identifiersep> bean ( ) . get <identifiersep> name ( ) ; int separator <identifiersep> pos = runtime <identifiersep> mx <identifiersep> bean <identifiersep> name . index <identifiersep> of ( ' @ ' ) ; if ( separator <identifiersep> pos > - 1 ) { try { pid = long . parse <identifiersep> long ( runtime <identifiersep> mx <identifiersep> bean <identifiersep> name . substring ( 0 , separator <identifiersep> pos ) ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { } } else { logger . debug ( <string_literal> ) ; } return pid ; } @ override public environment <identifiersep> modification <identifiersep> result maybe <identifiersep> set <identifiersep> environment ( map < string , string > source ) { <ect>
if ( ! initialized ) { use <identifiersep> native <identifiersep> integrations = <string_literal> . equals <identifiersep> ignore <identifiersep> case ( system . get <identifiersep> property ( <string_literal> , <string_literal> ) ) ; if ( use <identifiersep> native <identifiersep> integrations ) { file native <identifiersep> base <identifiersep> dir = get <identifiersep> native <identifiersep> services <identifiersep> dir ( user <identifiersep> home <identifiersep> dir ) ; try { net . rubygrapefruit . platform . native . init ( native <identifiersep> base <identifiersep> dir ) ; <LOG> } catch ( native <identifiersep> integration <identifiersep> unavailable <identifiersep> exception ex ) { use <identifiersep> native <identifiersep> integrations = false ; } catch ( native <identifiersep> exception ex ) { if ( ex . get <identifiersep> cause ( ) instanceof unsatisfied <identifiersep> link <identifiersep> error && ex . get <identifiersep> cause ( ) . get <identifiersep> message ( ) . to <identifiersep> lower <identifiersep> case ( ) . contains ( <string_literal> ) ) { logger . debug ( <string_literal> , format ( ex ) ) ; use <identifiersep> native <identifiersep> integrations = false ; <ect>
} catch ( native <identifiersep> exception ex ) { if ( ex . get <identifiersep> cause ( ) instanceof unsatisfied <identifiersep> link <identifiersep> error && ex . get <identifiersep> cause ( ) . get <identifiersep> message ( ) . to <identifiersep> lower <identifiersep> case ( ) . contains ( <string_literal> ) ) { logger . debug ( <string_literal> , format ( ex ) ) ; use <identifiersep> native <identifiersep> integrations = false ; } else if ( ex . get <identifiersep> message ( ) . equals ( <string_literal> ) && ex . get <identifiersep> cause ( ) . get <identifiersep> message ( ) . contains ( <string_literal> ) ) { <LOG> <comment> <ect>
when : logger . warn ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn <LOG> logging <identifiersep> manager . start ( ) logger . warn ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  <ect>
logger . warn ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  when : <LOG> logging <identifiersep> manager . stop ( ) then : 0 * listener .  <identifiersep>  } def consumes <identifiersep> from <identifiersep> java <identifiersep> util <identifiersep> logging <identifiersep> when <identifiersep> started ( ) { standard <identifiersep> output <identifiersep> listener listener = mock ( ) given : <ect>
when : logger . warning ( <string_literal> ) then : 0 * listener .  <identifiersep>  when : logging <identifiersep> manager . level <identifiersep> internal = log <identifiersep> level . warn <LOG> logging <identifiersep> manager . start ( ) logger . warning ( <string_literal> ) then : 1 * listener . on <identifiersep> output ( 'warning' ) 1 * listener . on <identifiersep> output ( text <identifiersep> util . platform <identifiersep> line <identifiersep> separator ) 0 * listener .  <identifiersep>  <ect>
@ after public void reset <identifiersep> logging ( ) { logging . reset <identifiersep> logging ( ) ; } @ test public void routes <identifiersep> log <identifiersep> messages <identifiersep> via <identifiersep> slf4j ( ) { logger logger = logging . get <identifiersep> logger ( logging <identifiersep> test . class ) ; <LOG> expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . debug , <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . info , <string_literal> ) ; logger . info ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . warn , <string_literal> ) ; logger . warn ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; <ect>
public void routes <identifiersep> log <identifiersep> messages <identifiersep> via <identifiersep> slf4j ( ) { logger logger = logging . get <identifiersep> logger ( logging <identifiersep> test . class ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . debug , <string_literal> ) ; logger . debug ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . info , <string_literal> ) ; logger . info ( <string_literal> ) ; <LOG> expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . warn , <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; logger . lifecycle ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . error , <string_literal> ) ; logger . error ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . quiet , <string_literal> ) ; <ect>
expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; logger . lifecycle ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . error , <string_literal> ) ; logger . error ( <string_literal> ) ; expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . quiet , <string_literal> ) ; logger . quiet ( <string_literal> ) ; <LOG> expect <identifiersep> log <identifiersep> message ( log <identifiersep> level . lifecycle , <string_literal> ) ; } @ test public void ignores <identifiersep> trace <identifiersep> level <identifiersep> logging ( ) { logger logger = logging . get <identifiersep> logger ( logging <identifiersep> test . class ) ; context . checking ( new expectations ( ) { { never ( output <identifiersep> event <identifiersep> listener ) ; <ect>
command <identifiersep> line <identifiersep> tool <identifiersep> search <identifiersep> result compiler = locate ( tool ) ; if ( compiler . is <identifiersep> available ( ) ) { search <identifiersep> result < gcc <identifiersep> metadata > gcc <identifiersep> metadata = get <identifiersep> meta <identifiersep> data <identifiersep> provider ( ) . get <identifiersep> compiler <identifiersep> meta <identifiersep> data ( compiler . get <identifiersep> tool ( ) , platform <identifiersep> tool <identifiersep> chain . get <identifiersep> compiler <identifiersep> probe <identifiersep> args ( ) ) ; availability . must <identifiersep> be <identifiersep> available ( gcc <identifiersep> metadata ) ; if ( ! gcc <identifiersep> metadata . is <identifiersep> available ( ) ) { return ; } <LOG> <comment> <ect>
model { components { main ( jvm <identifiersep> library <identifiersep> spec ) } } <string_literal> <string_literal> <string_literal> public class required <identifiersep> by <identifiersep> scala { <LOG> public static void print <identifiersep> something ( ) { } } <string_literal> <string_literal> <string_literal> class uses <identifiersep> java { def print <identifiersep> something ( ) : unit = { <ect>
builder . append ( file ) ; } logger . quiet ( builder . to <identifiersep> string ( ) ) ; } private void log <identifiersep> compiler <identifiersep> arguments ( scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { return ; } list < string > compiler <identifiersep> args = new java <identifiersep> compiler <identifiersep> arguments <identifiersep> builder ( spec ) . include <identifiersep> launcher <identifiersep> options ( true ) . include <identifiersep> source <identifiersep> files ( true ) . build ( ) ; <LOG> string joined <identifiersep> args = joiner . on ( ' ' ) . join ( compiler <identifiersep> args ) ; } private work <identifiersep> result delegate <identifiersep> and <identifiersep> handle <identifiersep> errors ( scala <identifiersep> java <identifiersep> joint <identifiersep> compile <identifiersep> spec spec ) { try { return delegate . execute ( spec ) ; } catch ( compilation <identifiersep> failed <identifiersep> exception e ) { if ( spec . get <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> fail <identifiersep> on <identifiersep> error ( ) && spec . get <identifiersep> scala <identifiersep> compile <identifiersep> options ( ) . is <identifiersep> fail <identifiersep> on <identifiersep> error ( ) ) { <ect>
public boolean requires <identifiersep> initialization ( file <identifiersep> lock lock ) { if ( ! did <identifiersep> rebuild ) { if ( validator != null && ! validator . is <identifiersep> valid ( ) ) { logger . debug ( <string_literal> , default <identifiersep> persistent <identifiersep> directory <identifiersep> cache . this ) ; return true ; } } if ( ! lock . get <identifiersep> unlocked <identifiersep> cleanly ( ) ) { <LOG> if ( lock . get <identifiersep> state ( ) . can <identifiersep> detect <identifiersep> changes ( ) && ! lock . get <identifiersep> state ( ) . is <identifiersep> in <identifiersep> initial <identifiersep> state ( ) ) { } return true ; } properties cached <identifiersep> properties = g <identifiersep> util . load <identifiersep> properties ( properties <identifiersep> file ) ; for ( map . entry < ? , ? > entry : properties . entry <identifiersep> set ( ) ) { string previous <identifiersep> value = cached <identifiersep> properties . get <identifiersep> property ( entry . get <identifiersep> key ( ) . to <identifiersep> string ( ) ) ; string current <identifiersep> value = entry . get <identifiersep> value ( ) . to <identifiersep> string ( ) ; <ect>
<comment> <LOG> long time <identifiersep> in <identifiersep> days = time <identifiersep> unit . milliseconds . to <identifiersep> days ( duration ) ; return time <identifiersep> in <identifiersep> days >= cleanup <identifiersep> interval ; } } return false ; } @ override public void cleanup ( ) { if ( cleanup <identifiersep> action != null ) { <ect>
public class fixed <identifiersep> age <identifiersep> oldest <identifiersep> cache <identifiersep> cleanup extends abstract <identifiersep> cache <identifiersep> cleanup { private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( fixed <identifiersep> age <identifiersep> oldest <identifiersep> cache <identifiersep> cleanup . class ) ; private final long minimum <identifiersep> timestamp ; public fixed <identifiersep> age <identifiersep> oldest <identifiersep> cache <identifiersep> cleanup ( long age <identifiersep> in <identifiersep> days ) { this . minimum <identifiersep> timestamp = math . max ( 0 , system . current <identifiersep> time <identifiersep> millis ( ) - time <identifiersep> unit . days . to <identifiersep> millis ( age <identifiersep> in <identifiersep> days ) ) ; } @ override <LOG> protected list < file > find <identifiersep> files <identifiersep> to <identifiersep> delete ( final persistent <identifiersep> cache persistent <identifiersep> cache , file [ ] files <identifiersep> eligible <identifiersep> for <identifiersep> cleanup ) { list < file > files <identifiersep> for <identifiersep> deletion = lists . new <identifiersep> array <identifiersep> list <identifiersep> with <identifiersep> capacity ( files <identifiersep> eligible <identifiersep> for <identifiersep> cleanup . length ) ; for ( file file : files <identifiersep> eligible <identifiersep> for <identifiersep> cleanup ) { if ( file . last <identifiersep> modified ( ) < minimum <identifiersep> timestamp ) { files <identifiersep> for <identifiersep> deletion . add ( file ) ; } } return files <identifiersep> for <identifiersep> deletion ; <ect>
import static org . junit . assert . * ; public class $ { test <identifiersep> class <identifiersep> name } { private final $ { production <identifiersep> class <identifiersep> name } production = new $ { production <identifiersep> class <identifiersep> name } ( <string_literal> ) ; @ org . junit . test public void test <identifiersep> one ( ) throws exception { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> system . out . println ( <string_literal> + i ) ; if ( i % <number_literal> == 0 ) { thread . sleep ( <number_literal> ) ; } } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) throws exception { <ect>
if ( i % <number_literal> == 0 ) { thread . sleep ( <number_literal> ) ; } } assert <identifiersep> equals ( production . get <identifiersep> property ( ) , <string_literal> ) ; } @ org . junit . test public void test <identifiersep> two ( ) throws exception { for ( int i = 0 ; i < <number_literal> ; i ++ ) { <LOG> system . out . println ( <string_literal> + i ) ; if ( i % <number_literal> == 0 ) { thread . sleep ( <number_literal> ) ; } } string expected = < % = binding . has <identifiersep> variable ( <string_literal> ) && binding . half <identifiersep> tests <identifiersep> fail ? <string_literal> : <string_literal> % > ; assert <identifiersep> equals ( production . get <identifiersep> property ( ) , expected ) ; } } <ect>
throw new gradle <identifiersep> exception ( <string_literal> , e ) ; } } private static file java <identifiersep> exe ( file jdk <identifiersep> path , string command ) { return new file ( new file ( jdk <identifiersep> path , <string_literal> ) , operating <identifiersep> system . current ( ) . get <identifiersep> executable <identifiersep> name ( command ) ) ; } <comment> <LOG> <comment> private static class java <identifiersep> probe implements opcodes { <ect>
file ( <string_literal> ) < < <string_literal> <string_literal> <LOG> public void before <identifiersep> class ( ) { } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { <ect>
public void before <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) <LOG> public void test2 ( ) { } @ after <identifiersep> class public void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; } } <string_literal> <string_literal> src / test / java / test2 . java <string_literal> <string_literal> <ect>
import org . testng . annotations . before <identifiersep> class ; import org . testng . annotations . test ; public class test2 { public static class c implements serializable { private static final long serial <identifiersep> version <identifiersep> uid = 1l ; } @ before <identifiersep> class <LOG> public void before <identifiersep> class ( ) { } @ test public void test1 ( ) { system . out . println ( <string_literal> ) ; } @ test ( depends <identifiersep> on <identifiersep> methods = { <string_literal> } ) public void test2 ( ) { <ect>
public void before <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m1 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } <LOG> @ test public void m2 ( ) { system . err . println ( <string_literal> ) ; } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ test public void m2 ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> test <LOG> public void after <identifiersep> test ( ) { system . err . println ( <string_literal> ) ; } @ after <identifiersep> class public static void after <identifiersep> class ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <ect>
system . err . println ( <string_literal> ) ; } @ after <identifiersep> test public void after <identifiersep> test ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ after <identifiersep> class <LOG> public static void after <identifiersep> class ( ) { system . err . println ( <string_literal> ) ; } } <string_literal> <string_literal> <ect>
<string_literal> <string_literal> src / test / java / logging <identifiersep> test . java <string_literal> <string_literal> public class logging <identifiersep> test { @ org . junit . test public void test ( ) { <LOG> if ( system . get <identifiersep> property ( <string_literal> , <string_literal> ) . equals ( <string_literal> ) ) { system . err . println ( <string_literal> ) ; } else { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } } } <string_literal> <string_literal> <ect>
public class logging <identifiersep> test { @ org . junit . test public void test ( ) { if ( system . get <identifiersep> property ( <string_literal> , <string_literal> ) . equals ( <string_literal> ) ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; <LOG> } else { system . err . println ( <string_literal> ) ; } } } <string_literal> <string_literal> test <string_literal> <ect>
tasks . build . depends <identifiersep> on test <identifiersep> report } <string_literal> <string_literal> src / test / java / org / gradle / testing / unit <identifiersep> test . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude public class unit <identifiersep> test { <LOG> @ test public void foo ( ) { } } <string_literal> <string_literal> src / test / java / org / gradle / testing / super <identifiersep> test . java <string_literal> <string_literal> $test <identifiersep> file <identifiersep> prelude public class super <identifiersep> test { @ category ( super <identifiersep> class <identifiersep> tests . class ) @ test public void failing ( ) { <ect>
@ suite . suite <identifiersep> classes ( { test . class , other <identifiersep> test . class } ) public class test <identifiersep> suite { @ org . junit . before <identifiersep> class public static void init ( ) { system . out . println ( <string_literal> ) ; system . err . println ( <string_literal> ) ; } @ org . junit . after <identifiersep> class public static void end ( ) { <LOG> system . out . println ( <string_literal> ) ; } } <ect>
private count <identifiersep> down <identifiersep> latch completed ; private test <identifiersep> class <identifiersep> processor processor ; private test <identifiersep> result <identifiersep> processor result <identifiersep> processor ; public test <identifiersep> worker ( worker <identifiersep> test <identifiersep> class <identifiersep> processor <identifiersep> factory factory ) { this . factory = factory ; } @ override <LOG> public void execute ( final worker <identifiersep> process <identifiersep> context worker <identifiersep> process <identifiersep> context ) { completed = new count <identifiersep> down <identifiersep> latch ( 1 ) ; system . set <identifiersep> property ( worker <identifiersep> id <identifiersep> sys <identifiersep> property , worker <identifiersep> process <identifiersep> context . get <identifiersep> worker <identifiersep> id ( ) . to <identifiersep> string ( ) ) ; default <identifiersep> service <identifiersep> registry test <identifiersep> services = new test <identifiersep> framework <identifiersep> service <identifiersep> registry ( worker <identifiersep> process <identifiersep> context ) ; start <identifiersep> receiving <identifiersep> tests ( worker <identifiersep> process <identifiersep> context , test <identifiersep> services ) ; try { <ect>
public class default <identifiersep> test <identifiersep> report implements test <identifiersep> reporter { private final build <identifiersep> operation <identifiersep> executor build <identifiersep> operation <identifiersep> executor ; private final static logger log = logging . get <identifiersep> logger ( default <identifiersep> test <identifiersep> report . class ) ; public default <identifiersep> test <identifiersep> report ( build <identifiersep> operation <identifiersep> executor build <identifiersep> operation <identifiersep> executor ) { this . build <identifiersep> operation <identifiersep> executor = build <identifiersep> operation <identifiersep> executor ; } @ override <LOG> public void generate <identifiersep> report ( test <identifiersep> results <identifiersep> provider results <identifiersep> provider , file report <identifiersep> dir ) { timer clock = time . start <identifiersep> timer ( ) ; all <identifiersep> test <identifiersep> results model = load <identifiersep> model <identifiersep> from <identifiersep> provider ( results <identifiersep> provider ) ; generate <identifiersep> files ( model , results <identifiersep> provider , report <identifiersep> dir ) ; log . info ( <string_literal> , clock . get <identifiersep> elapsed ( ) , report <identifiersep> dir ) ; } private all <identifiersep> test <identifiersep> results load <identifiersep> model <identifiersep> from <identifiersep> provider ( test <identifiersep> results <identifiersep> provider results <identifiersep> provider ) { <ect>
system . out . println ( <string_literal> + s ) ; return <string_literal> ; } @ not <identifiersep> null object foo ( ) { return foo ( null ) ; } @ nullable <LOG> object bar ( string s ) { return s == null ? <string_literal> : null ; } @ not <identifiersep> null object bar ( ) { return bar ( null ) ; } public @ nullable object bar1 ( string s ) { <ect>
return s == null ? <string_literal> : null ; } public @ not <identifiersep> null object bar1 ( ) { return bar1 ( null ) ; } @ deprecated public void f ( ) { f ( 1 ) ; } <LOG> public void f ( int p ) { } <ect>
class a { <LOG> void foo ( int i , char c , string s ) { } void foo ( int i , char c ) { foo ( i , c , <string_literal> ) ; } void foo ( int i ) { foo ( i , 'a' , <string_literal> ) ; } int bar ( string s ) { <ect>
private string my <identifiersep> x = <string_literal> ; public string get <identifiersep> x ( ) { system . out . println ( <string_literal> ) ; return my <identifiersep> x ; } public void set <identifiersep> x ( string x ) { this . my <identifiersep> x = x ; } <LOG> void foo ( ) { } <ect>
<comment> <LOG> switch ( a ) { system . out . println ( <string_literal> ) } <ect>
<comment> <LOG> switch ( a ) { case <number_literal> : system . out . println ( <string_literal> ) ; return <number_literal> ; case <number_literal> : system . out . println ( <string_literal> ) ; throw new runtime <identifiersep> exception ( ) ; default : system . out . println ( <string_literal> ) ; return 0 ; } <ect>
fun box ( ) : string { log ( <string_literal> ) a . b . c ( g ) log ( <string_literal> ) a . b . c ( foo ( ) ) log ( <string_literal> ) <LOG> a . b . c ( bar ( ) ) a . b . c ( baz ( ) ) log ( <string_literal> ) a . b . c ( boo ( g ) ) assert <identifiersep> equals ( <string_literal> <string_literal> <ect>
<comment> <LOG> inline fun bar ( ) : int { return <number_literal> } val x : int get ( ) { log ( <string_literal> ) return 1 <ect>
<comment> <LOG> fun sum ( x : int , y : int ) : int { return x + y } fun box ( ) : string { assert <identifiersep> equals ( <number_literal> , sum ( fizz ( 1 ) , buzz ( <number_literal> ) ) ) assert <identifiersep> equals ( <string_literal> , pull <identifiersep> log ( ) ) return <string_literal> <ect>
override fun add <identifiersep> lower <identifiersep> constraint ( type <identifiersep> variable : type <identifiersep> constructor , sub <identifiersep> type : unwrapped <identifiersep> type ) = add <identifiersep> constraint ( type <identifiersep> variable , sub <identifiersep> type , lower ) private fun is <identifiersep> captured <identifiersep> type <identifiersep> from <identifiersep> subtyping ( type : unwrapped <identifiersep> type ) = when ( ( type as ? new <identifiersep> captured <identifiersep> type ) ? . capture <identifiersep> status ) { null , capture <identifiersep> status . from <identifiersep> expression - > false capture <identifiersep> status . for <identifiersep> subtyping - > true <LOG> capture <identifiersep> status . for <identifiersep> incorporation - > } private fun add <identifiersep> constraint ( type <identifiersep> variable <identifiersep> constructor : type <identifiersep> constructor , type : unwrapped <identifiersep> type , kind : constraint <identifiersep> kind ) { val type <identifiersep> variable = c . all <identifiersep> type <identifiersep> variables [ type <identifiersep> variable <identifiersep> constructor ] ? : error ( <string_literal> ) var target <identifiersep> type = type if ( type . contains ( this : : is <identifiersep> captured <identifiersep> type <identifiersep> from <identifiersep> subtyping ) ) { <ect>
resolve <identifiersep> scope = scope } override fun get <identifiersep> forced <identifiersep> resolve <identifiersep> scope ( ) = resolve <identifiersep> scope override fun is <identifiersep> physical ( ) = is <identifiersep> physical override fun is <identifiersep> valid ( ) = true override fun get <identifiersep> context ( ) : psi <identifiersep> element ? { if ( fake <identifiersep> context <identifiersep> for <identifiersep> java <identifiersep> file != null ) return fake <identifiersep> context <identifiersep> for <identifiersep> java <identifiersep> file <LOG> if ( context ! is kt <identifiersep> element ) { return null } return context } override fun get <identifiersep> resolve <identifiersep> scope ( ) = context ? . resolve <identifiersep> scope ? : super . get <identifiersep> resolve <identifiersep> scope ( ) override fun clone ( ) : kt <identifiersep> code <identifiersep> fragment { val clone = clone <identifiersep> impl ( calc <identifiersep> tree <identifiersep> element ( ) . clone ( ) as file <identifiersep> element ) as kt <identifiersep> code <identifiersep> fragment <ect>
<comment> public void parse <identifiersep> expression ( ) { <LOG> if ( ! at <identifiersep> set ( expression <identifiersep> first ) ) { return ; } parse <identifiersep> binary <identifiersep> expression ( precedence . assignment ) ; } <comment> <ect>
<comment> public static void main ( string . . . args ) <LOG> { if ( args . length == 0 ) { return ; } maven <identifiersep> comparable <identifiersep> version prev = null ; int i = 1 ; <ect>
{ maven <identifiersep> comparable <identifiersep> version c = new maven <identifiersep> comparable <identifiersep> version ( version ) ; if ( prev != null ) { int compare = prev . compare <identifiersep> to ( c ) ; system . out . println ( <string_literal> + prev . to <identifiersep> string ( ) + ' ' <LOG> + ( ( compare == 0 ) ? <string_literal> : ( ( compare < 0 ) ? <string_literal> : <string_literal> ) ) + ' ' + version ) ; } prev = c ; } } } <ect>
val stream = zip <identifiersep> file . get <identifiersep> input <identifiersep> stream ( zip <identifiersep> entry ) val content = file <identifiersep> util . load <identifiersep> text <identifiersep> and <identifiersep> close ( stream ) it . copy ( source <identifiersep> map <identifiersep> content = content ) } else { it } } . for <identifiersep> each ( action ) } <LOG> catch ( ex : io <identifiersep> exception ) { } finally { zip <identifiersep> file . close ( ) } } private fun get <identifiersep> suggested <identifiersep> path ( path : string ) : string ? { val system <identifiersep> independent <identifiersep> path = file <identifiersep> util . to <identifiersep> system <identifiersep> independent <identifiersep> name ( path ) if ( system <identifiersep> independent <identifiersep> path . starts <identifiersep> with ( library <identifiersep> utils . meta <identifiersep> <number_literal> ) ) { <ect>
<comment> <LOG> continue target <identifiersep> file . parent <identifiersep> file ! ! . mkdirs <identifiersep> or <identifiersep> fail ( ) target <identifiersep> file . write <identifiersep> text ( result <identifiersep> text ) } } for ( source <identifiersep> dir in source <identifiersep> directories ) { val target <identifiersep> dir = source <identifiersep> dir . make <identifiersep> relative <identifiersep> to ( source <identifiersep> root , target <identifiersep> root ) if ( target <identifiersep> dir . exists ( ) && ! target <identifiersep> dir . is <identifiersep> directory ) { <ect>
for ( declaration in result ) { val reachable = find <identifiersep> all <identifiersep> reachable <identifiersep> declarations ( declaration ) reachable . remove ( declaration ) to <identifiersep> remove . add <identifiersep> all ( reachable ) } result . remove <identifiersep> all ( to <identifiersep> remove ) val concrete <identifiersep> relevant <identifiersep> declarations = result . filter { ! it . is <identifiersep> abstract && ! it . is <identifiersep> interface <identifiersep> declaration } <LOG> if ( concrete <identifiersep> relevant <identifiersep> declarations . size != 1 ) { } return concrete <identifiersep> relevant <identifiersep> declarations [ 0 ] } <ect>
this . exception <identifiersep> data = exception <identifiersep> data ; this . log <identifiersep> applications = log <identifiersep> applications ; this . dump <identifiersep> byte <identifiersep> code = dump <identifiersep> byte <identifiersep> code ; } public boolean allows <identifiersep> multiple <identifiersep> matches ( ) { return allow <identifiersep> multiple <identifiersep> matches ; } public void report <identifiersep> application ( string class <identifiersep> name , string method <identifiersep> name , string method <identifiersep> desc ) { <LOG> if ( log <identifiersep> applications ) { } } public boolean is <identifiersep> applicable ( string name , string desc ) { return name <identifiersep> pattern . matcher ( name ) . matches ( ) && desc <identifiersep> pattern . matcher ( desc ) . matches ( ) ; } public list < method <identifiersep> data > get <identifiersep> enter <identifiersep> data ( ) { return enter <identifiersep> data ; } public list < method <identifiersep> data > get <identifiersep> normal <identifiersep> return <identifiersep> data ( ) { <ect>
fun box ( ) : string { async { val a = foo ( <number_literal> ) log ( a ) val b = foo ( <number_literal> ) log ( b ) } <LOG> while ( ! finished ) { proceed ( ) } if ( result != <string_literal> ) return <string_literal> return <string_literal> } var result = <string_literal> fun log ( message : any ) { <ect>
log ( <string_literal> ) proceed = { c . resume ( x ) } } inline suspend fun foo ( x : int ) = bar ( x ) fun async ( a : suspend ( ) - > unit ) { a . start <identifiersep> coroutine ( object : continuation < unit > { override fun resume ( value : unit ) { <LOG> proceed = { finished = true } } override fun resume <identifiersep> with <identifiersep> exception ( e : throwable ) { } override val context = empty <identifiersep> coroutine <identifiersep> context } ) } <ect>
<comment> <LOG> fun foo ( x : int ) : unit { } } interface i { fun foo ( x : int = 1 ) : unit } class g ( c : c ) : c by c , i class h ( c : c ) : i , c by c fun test1 ( ) { <ect>
resolver <identifiersep> from <identifiersep> annotation ( template ) ? : resolver <identifiersep> from <identifiersep> legacy <identifiersep> annotation ( template ) ? : dependencies <identifiersep> resolver . no <identifiersep> dependencies } private fun resolver <identifiersep> from <identifiersep> legacy <identifiersep> annotation ( template : k <identifiersep> class < out any > ) : dependencies <identifiersep> resolver ? { val legacy <identifiersep> def <identifiersep> ann = take <identifiersep> unless <identifiersep> error { template . annotations . first <identifiersep> is <identifiersep> instance <identifiersep> or <identifiersep> null < script <identifiersep> template <identifiersep> definition > ( ) <LOG> } ? : return null return instantiate <identifiersep> resolver ( legacy <identifiersep> def <identifiersep> ann . resolver ) ? . let ( : : legacy <identifiersep> package <identifiersep> dependency <identifiersep> resolver <identifiersep> wrapper ) } private fun resolver <identifiersep> from <identifiersep> annotation ( template : k <identifiersep> class < out any > ) : dependencies <identifiersep> resolver ? { val def <identifiersep> ann = take <identifiersep> unless <identifiersep> error { template . annotations . first <identifiersep> is <identifiersep> instance <identifiersep> or <identifiersep> null < kotlin . script . templates . script <identifiersep> template <identifiersep> definition > ( ) } ? : return null <ect>
return it } val constructor <identifiersep> without <identifiersep> parameters = resolver <identifiersep> class . constructors . find { it . parameters . all { it . is <identifiersep> optional } } if ( constructor <identifiersep> without <identifiersep> parameters == null ) { log . warn ( <string_literal> ) return null } return constructor <identifiersep> without <identifiersep> parameters . call <identifiersep> by ( empty <identifiersep> map ( ) ) } <LOG> catch ( ex : class <identifiersep> cast <identifiersep> exception ) { return null } } private val sam <identifiersep> with <identifiersep> receiver <identifiersep> annotations : list < string > ? by lazy { take <identifiersep> unless <identifiersep> error { template . annotations . first <identifiersep> is <identifiersep> instance <identifiersep> or <identifiersep> null < kotlin . script . extensions . sam <identifiersep> with <identifiersep> receiver <identifiersep> annotations > ( ) ? . annotations ? . to <identifiersep> list ( ) } ? : take <identifiersep> unless <identifiersep> error { template . annotations . first <identifiersep> is <identifiersep> instance <identifiersep> or <identifiersep> null < org . jetbrains . kotlin . script . sam <identifiersep> with <identifiersep> receiver <identifiersep> annotations > ( ) ? . annotations ? . to <identifiersep> list ( ) } } override val accepted <identifiersep> annotations : list < k <identifiersep> class < out annotation > > by lazy { <ect>
private inline fun < t > take <identifiersep> unless <identifiersep> error ( report <identifiersep> error : boolean = true , body : ( ) - > t ? ) : t ? = try { body ( ) } catch ( ex : throwable ) { if ( report <identifiersep> error ) { log . error ( <string_literal> + template . qualified <identifiersep> name , ex ) } <LOG> else { } null } companion object { internal val log = logger . get <identifiersep> instance ( kotlin <identifiersep> script <identifiersep> definition <identifiersep> from <identifiersep> annotated <identifiersep> template : : class . java ) } } interface dependency <identifiersep> resolver <identifiersep> wrapper < t : script <identifiersep> dependencies <identifiersep> resolver > { val delegate : t <ect>
builder . register ( compilation <identifiersep> canceled <identifiersep> status : : class . java , remote <identifiersep> compilation <identifiersep> canceled <identifiersep> status <identifiersep> client ( facade , rpc <identifiersep> profiler ) ) } return builder . build ( ) } private fun < r > checked <identifiersep> compile ( daemon <identifiersep> message <identifiersep> reporter : daemon <identifiersep> message <identifiersep> reporter , rpc <identifiersep> profiler : profiler , body : ( ) - > r ) : r { try { val profiler = if ( daemon <identifiersep> options . report <identifiersep> perf ) wall <identifiersep> and <identifiersep> thread <identifiersep> and <identifiersep> memory <identifiersep> total <identifiersep> profiler ( with <identifiersep> gc = false ) else dummy <identifiersep> profiler ( ) val res = profiler . with <identifiersep> measure ( null , body ) <LOG> val end <identifiersep> mem = if ( daemon <identifiersep> options . report <identifiersep> perf ) used <identifiersep> memory ( with <identifiersep> gc = false ) else 0l if ( daemon <identifiersep> options . report <identifiersep> perf ) { fun long . ms ( ) = time <identifiersep> unit . nanoseconds . to <identifiersep> millis ( this ) fun long . kb ( ) = this / <number_literal> val pc = profiler . get <identifiersep> total <identifiersep> counters ( ) val rpc = rpc <identifiersep> profiler . get <identifiersep> total <identifiersep> counters ( ) <ect>
if <identifiersep> alive <identifiersep> checks <identifiersep> impl ( min <identifiersep> aliveness ) { body ( ) compile <identifiersep> service . call <identifiersep> result . ok ( ) } } private inline fun < r > if <identifiersep> alive <identifiersep> checks <identifiersep> impl ( min <identifiersep> aliveness : aliveness = aliveness . last <identifiersep> session , body : ( ) - > compile <identifiersep> service . call <identifiersep> result < r > ) : compile <identifiersep> service . call <identifiersep> result < r > { val cur <identifiersep> state = state . alive . get ( ) return when { <LOG> cur <identifiersep> state < min <identifiersep> aliveness . ordinal - > { compile <identifiersep> service . call <identifiersep> result . dying ( ) } else - > { try { body ( ) } catch ( e : throwable ) { <ect>
import java . util . logging . logger val canceled <identifiersep> status <identifiersep> check <identifiersep> threshold <identifiersep> ns = time <identifiersep> unit . milliseconds . to <identifiersep> nanos ( <number_literal> ) class remote <identifiersep> compilation <identifiersep> canceled <identifiersep> status <identifiersep> client ( val facade : compiler <identifiersep> callback <identifiersep> services <identifiersep> facade , val profiler : profiler = dummy <identifiersep> profiler ( ) ) : compilation <identifiersep> canceled <identifiersep> status { private val log by lazy { logger . get <identifiersep> logger ( <string_literal> ) } @ volatile var last <identifiersep> checked : long = system . nano <identifiersep> time ( ) override fun check <identifiersep> canceled ( ) { <LOG> fun cancel <identifiersep> on <identifiersep> error ( e : exception ) { throw compilation <identifiersep> canceled <identifiersep> exception ( ) } val cur <identifiersep> nanos = system . nano <identifiersep> time ( ) if ( cur <identifiersep> nanos - last <identifiersep> checked > canceled <identifiersep> status <identifiersep> check <identifiersep> threshold <identifiersep> ns ) { profiler . with <identifiersep> measure ( this ) { try { <ect>
private fun create <identifiersep> method <identifiersep> breakpoint ( debug <identifiersep> process : debug <identifiersep> process <identifiersep> impl , ref <identifiersep> type : reference <identifiersep> type , accessor : method ) { val manager = debug <identifiersep> process . requests <identifiersep> manager val line = accessor . all <identifiersep> line <identifiersep> locations ( ) . first <identifiersep> or <identifiersep> null ( ) if ( line != null ) { val request = manager . create <identifiersep> breakpoint <identifiersep> request ( this , line ) <LOG> debug <identifiersep> process . requests <identifiersep> manager . enable <identifiersep> request ( request ) } } else { var entry <identifiersep> request : method <identifiersep> entry <identifiersep> request ? = find <identifiersep> request ( debug <identifiersep> process , method <identifiersep> entry <identifiersep> request : : class . java , this ) if ( entry <identifiersep> request == null ) { entry <identifiersep> request = manager . create <identifiersep> method <identifiersep> entry <identifiersep> request ( this ) ! ! <ect>
error <identifiersep> message . additional <identifiersep> info ? . let { <string_literal> , <string_literal> } ? : message } } fun generate <identifiersep> function ( ) : extraction <identifiersep> result ? { val original <identifiersep> file = code <identifiersep> fragment . get <identifiersep> context <identifiersep> containing <identifiersep> file ( ) ? : return null val new <identifiersep> debug <identifiersep> expressions = add <identifiersep> debug <identifiersep> expression <identifiersep> into <identifiersep> tmp <identifiersep> file <identifiersep> for <identifiersep> extract <identifiersep> function ( original <identifiersep> file , code <identifiersep> fragment , breakpoint <identifiersep> line ) if ( new <identifiersep> debug <identifiersep> expressions . is <identifiersep> empty ( ) ) return null <LOG> val tmp <identifiersep> file = new <identifiersep> debug <identifiersep> expressions . first ( ) . containing <identifiersep> kt <identifiersep> file } val target <identifiersep> sibling = tmp <identifiersep> file . declarations . first <identifiersep> or <identifiersep> null ( ) ? : return null val options = extraction <identifiersep> options ( infer <identifiersep> unit <identifiersep> type <identifiersep> for <identifiersep> unused <identifiersep> values = false , enable <identifiersep> list <identifiersep> boxing = true , allow <identifiersep> special <identifiersep> class <identifiersep> names = true , capture <identifiersep> local <identifiersep> functions = true , <ect>
val cache = evaluate <identifiersep> expression <identifiersep> cache . cached <identifiersep> compiled <identifiersep> data . value ! ! cache [ text ] } val answer = cached . first <identifiersep> or <identifiersep> null { it . source <identifiersep> position == source <identifiersep> position || evaluate <identifiersep> expression <identifiersep> cache . can <identifiersep> be <identifiersep> evaluated <identifiersep> in <identifiersep> this <identifiersep> context ( it , evaluation <identifiersep> context ) } if ( answer != null ) { return answer } <LOG> val new <identifiersep> compiled <identifiersep> data = create ( code <identifiersep> fragment , source <identifiersep> position ) synchronized ( evaluate <identifiersep> expression <identifiersep> cache . cached <identifiersep> compiled <identifiersep> data ) { evaluate <identifiersep> expression <identifiersep> cache . cached <identifiersep> compiled <identifiersep> data . value . put <identifiersep> value ( text , new <identifiersep> compiled <identifiersep> data ) } return new <identifiersep> compiled <identifiersep> data } fun < t : psi <identifiersep> element > get <identifiersep> or <identifiersep> compute <identifiersep> class <identifiersep> names ( psi <identifiersep> element : t ? , create : ( t ) - > computed <identifiersep> class <identifiersep> names ) : list < string > { if ( psi <identifiersep> element == null ) return collections . empty <identifiersep> list ( ) <ect>
navigation <identifiersep> kind : navigation <identifiersep> kind ) : kt <identifiersep> named <identifiersep> declaration ? { if ( declaration is kt <identifiersep> primary <identifiersep> constructor ) { val source <identifiersep> class <identifiersep> or <identifiersep> object = find <identifiersep> class <identifiersep> or <identifiersep> object ( declaration . get <identifiersep> containing <identifiersep> class <identifiersep> or <identifiersep> object ( ) , navigation <identifiersep> kind ) return source <identifiersep> class <identifiersep> or <identifiersep> object ? . primary <identifiersep> constructor ? : source <identifiersep> class <identifiersep> or <identifiersep> object } val member <identifiersep> name <identifiersep> as <identifiersep> string = declaration . name <LOG> if ( member <identifiersep> name <identifiersep> as <identifiersep> string == null ) { return null } val member <identifiersep> name = name . identifier ( member <identifiersep> name <identifiersep> as <identifiersep> string ) val decompiled <identifiersep> container = declaration . parent var candidates : collection < kt <identifiersep> named <identifiersep> declaration > when ( decompiled <identifiersep> container ) { <ect>
val log : logger ) : class <identifiersep> data <identifiersep> finder { override fun find <identifiersep> class <identifiersep> data ( class <identifiersep> id : class <identifiersep> id ) : class <identifiersep> data ? { val binary <identifiersep> class = class <identifiersep> finder . find <identifiersep> kotlin <identifiersep> class ( class <identifiersep> id ) ? : return null val class <identifiersep> header = binary <identifiersep> class . class <identifiersep> header val data = class <identifiersep> header . data <LOG> if ( data == null ) { return null } val strings = class <identifiersep> header . strings if ( strings == null ) { log . error ( <string_literal> ) return null <ect>
return create <identifiersep> incompatible <identifiersep> abi <identifiersep> version <identifiersep> file <identifiersep> stub ( ) } val components = create <identifiersep> stub <identifiersep> builder <identifiersep> components ( file , package <identifiersep> fq <identifiersep> name , file <identifiersep> content ) if ( header . kind == kotlin <identifiersep> class <identifiersep> header . kind . multifile <identifiersep> class ) { val part <identifiersep> files = find <identifiersep> multifile <identifiersep> class <identifiersep> parts ( file , class <identifiersep> id , header . multifile <identifiersep> part <identifiersep> names ) return create <identifiersep> multifile <identifiersep> class <identifiersep> stub ( header , part <identifiersep> files , class <identifiersep> id . as <identifiersep> single <identifiersep> fq <identifiersep> name ( ) , components ) } val annotation <identifiersep> data = header . data <LOG> if ( annotation <identifiersep> data == null ) { return null } val strings = header . strings if ( strings == null ) { log . error ( <string_literal> ) return null <ect>
else { <comment> <LOG> if ( declaration <identifiersep> descriptor == null ) { return <string_literal> } return render <identifiersep> kotlin ( context , declaration <identifiersep> descriptor , quick <identifiersep> navigation , declaration ) } private fun render <identifiersep> kotlin <identifiersep> implicit <identifiersep> lambda <identifiersep> parameter ( element : kt <identifiersep> reference <identifiersep> expression , quick <identifiersep> navigation : boolean ) : string ? { val context = element . analyze ( body <identifiersep> resolve <identifiersep> mode . partial ) val target = element . main <identifiersep> reference . resolve <identifiersep> to <identifiersep> descriptors ( context ) . single <identifiersep> or <identifiersep> null ( ) as ? value <identifiersep> parameter <identifiersep> descriptor ? ? : return null <ect>
collect <identifiersep> reference <identifiersep> data ( file , start <identifiersep> offsets , end <identifiersep> offsets ) } catch ( e : process <identifiersep> canceled <identifiersep> exception ) { <comment> <LOG> catch ( e : throwable ) { return list <identifiersep> of ( ) } if ( collected <identifiersep> data . is <identifiersep> empty ( ) ) return list <identifiersep> of ( ) return list <identifiersep> of ( kotlin <identifiersep> reference <identifiersep> transferable <identifiersep> data ( collected <identifiersep> data . to <identifiersep> typed <identifiersep> array ( ) ) ) } fun collect <identifiersep> reference <identifiersep> data ( file : kt <identifiersep> file , <ect>
<comment> <LOG> if ( diagnostic <identifiersep> element ! is kt <identifiersep> expression ) { return empty <identifiersep> list ( ) } val expected <identifiersep> type : kotlin <identifiersep> type val expression <identifiersep> type : kotlin <identifiersep> type ? when ( diagnostic . factory ) { errors . type <identifiersep> mismatch - > { <ect>
class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + a . get <identifiersep> foo ( ) ) ; b b = new b ( ) ; <LOG> b . set <identifiersep> foo ( <string_literal> ) ; } <ect>
package client ; import server . kotlin <identifiersep> top <identifiersep> level <identifiersep> property <identifiersep> usages <identifiersep> 0kt ; class j <identifiersep> client { void foo <identifiersep> bar ( ) { <LOG> system . out . println ( <string_literal> + kotlin <identifiersep> top <identifiersep> level <identifiersep> property <identifiersep> usages <identifiersep> 0kt . get <identifiersep> foo ( ) ) ; kotlin <identifiersep> top <identifiersep> level <identifiersep> property <identifiersep> usages <identifiersep> 0kt . set <identifiersep> foo ( <string_literal> ) ; } <ect>
class client { void foo <identifiersep> bar ( ) { a < string > a = new a < string > ( <string_literal> ) ; a . set <identifiersep> foo ( <string_literal> ) ; system . out . println ( <string_literal> + a . get <identifiersep> foo ( ) ) ; b b = new b ( ) ; <LOG> b . set <identifiersep> foo ( <string_literal> ) ; } <ect>
file [ ] files = root . list <identifiersep> files ( ) ; if ( files == null ) return ; for ( file file : files ) { process <identifiersep> file ( file ) ; } } else if ( root . get <identifiersep> name ( ) . ends <identifiersep> with ( <string_literal> ) ) { system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; <LOG> string path = root . get <identifiersep> absolute <identifiersep> path ( ) ; change ( path ) ; build <identifiersep> all <identifiersep> modules ( ) . assert <identifiersep> successful ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt <ect>
else if ( root . get <identifiersep> name ( ) . ends <identifiersep> with ( <string_literal> ) ) { system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; string path = root . get <identifiersep> absolute <identifiersep> path ( ) ; system . out . println ( <string_literal> + path ) ; change ( path ) ; build <identifiersep> all <identifiersep> modules ( ) . assert <identifiersep> successful ( ) ; <LOG> system . out . println ( <string_literal> ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; system . out . println ( <string_literal> ) ; <ect>
build <identifiersep> all <identifiersep> modules ( ) . assert <identifiersep> successful ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( <string_literal> ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; class <identifiersep> files <identifiersep> comparison <identifiersep> kt . assert <identifiersep> equal <identifiersep> directories ( new file ( get <identifiersep> out <identifiersep> dir <identifiersep> after <identifiersep> rebuild ( ) , <string_literal> ) , new file ( get <identifiersep> out <identifiersep> dir ( ) , <string_literal> ) , false ) ; <LOG> system . out . println ( <string_literal> + root . get <identifiersep> name ( ) ) ; } } @ override protected void rebuild <identifiersep> all <identifiersep> modules ( ) { system . out . println ( <string_literal> ) ; super . rebuild <identifiersep> all <identifiersep> modules ( ) ; system . out . println ( <string_literal> ) ; <ect>
private object lookup <identifiersep> storage <identifiersep> lock fun build <identifiersep> data <identifiersep> manager . clean <identifiersep> lookup <identifiersep> storage ( log : logger ) { synchronized ( lookup <identifiersep> storage <identifiersep> lock ) { try { clean <identifiersep> target <identifiersep> storages ( kotlin <identifiersep> data <identifiersep> container <identifiersep> target ) } catch ( e : io <identifiersep> exception ) { <LOG> if ( ! data <identifiersep> paths . get <identifiersep> target <identifiersep> data <identifiersep> root ( kotlin <identifiersep> data <identifiersep> container <identifiersep> target ) . delete <identifiersep> recursively ( ) ) { } } } } fun < t > build <identifiersep> data <identifiersep> manager . with <identifiersep> lookup <identifiersep> storage ( fn : ( lookup <identifiersep> storage ) - > t ) : t { synchronized ( lookup <identifiersep> storage <identifiersep> lock ) { try { val lookup <identifiersep> storage = get <identifiersep> storage ( kotlin <identifiersep> data <identifiersep> container <identifiersep> target , jps <identifiersep> lookup <identifiersep> storage <identifiersep> provider ) return fn ( lookup <identifiersep> storage ) <ect>
<comment> @ non <identifiersep> null fatal ( <string_literal> ) , <comment> <LOG> @ non <identifiersep> null <comment> @ non <identifiersep> null warning ( <string_literal> ) , <ect>
if ( ! jar <identifiersep> files . is <identifiersep> empty ( ) ) { list < issue <identifiersep> registry > registries = lists . new <identifiersep> array <identifiersep> list <identifiersep> with <identifiersep> expected <identifiersep> size ( jar <identifiersep> files . size ( ) ) ; registries . add ( registry ) ; for ( file jar <identifiersep> file : jar <identifiersep> files ) { try { registries . add ( jar <identifiersep> file <identifiersep> issue <identifiersep> registry . get ( this , jar <identifiersep> file ) ) ; <LOG> } catch ( throwable e ) { } } if ( registries . size ( ) > 1 ) { <comment> <ect>
val correct <identifiersep> error <identifiersep> types = configuration . get ( kapt3configuration <identifiersep> keys . correct <identifiersep> error <identifiersep> types ) == <string_literal> val map <identifiersep> diagnostic <identifiersep> locations = configuration . get ( kapt3configuration <identifiersep> keys . map <identifiersep> diagnostic <identifiersep> locations ) == <string_literal> if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) <ect>
if ( is <identifiersep> verbose ) { logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) <ect>
logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) logger . info ( <string_literal> ) <LOG> logger . info ( <string_literal> ) logger . info ( <string_literal> + compile <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + ap <identifiersep> classpath . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> + annotation <identifiersep> processors ) logger . info ( <string_literal> + java <identifiersep> source <identifiersep> roots . join <identifiersep> to <identifiersep> string ( ) ) logger . info ( <string_literal> ) <ect>
private companion object { val preset <identifiersep> arg <identifiersep> name = <string_literal> } override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = allopen <identifiersep> compiler <identifiersep> plugin <identifiersep> id @ requirement lateinit var logger : logger override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) = true <LOG> override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { return list <identifiersep> of ( plugin <identifiersep> option ( <string_literal> , allopen <identifiersep> compiler <identifiersep> plugin <identifiersep> id , preset <identifiersep> arg <identifiersep> name , <string_literal> ) ) } <ect>
error ( <string_literal> ) return null } } try { val deps = aether ( current <identifiersep> repos ( ) , local <identifiersep> repo ) . resolve ( artifact <identifiersep> id , java <identifiersep> scopes . runtime ) if ( deps != null ) return deps . map { it . file } <LOG> else { } } catch ( e : dependency <identifiersep> resolution <identifiersep> exception ) { report <identifiersep> error ? . invoke ( <string_literal> ) ? : throw e } return null } fun try <identifiersep> add <identifiersep> repo ( annotation : repository ) : boolean { val url <identifiersep> str = annotation . url . take <identifiersep> if { it . is <identifiersep> valid <identifiersep> param ( ) } ? : annotation . value . take <identifiersep> if { it . is <identifiersep> valid <identifiersep> param ( ) } ? : return false <ect>
compiler <identifiersep> message <identifiersep> severity . logging - > log . debug ( loc <identifiersep> message ) compiler <identifiersep> message <identifiersep> severity . output - > { } } } } internal fun kotlin <identifiersep> logger . log <identifiersep> finish ( strategy : string ) { debug ( <string_literal> ) } internal fun exit <identifiersep> code <identifiersep> from <identifiersep> process <identifiersep> exit <identifiersep> code ( log : kotlin <identifiersep> logger , code : int ) : exit <identifiersep> code { val exit <identifiersep> code = exit <identifiersep> code . values ( ) . find { it . code == code } <LOG> if ( exit <identifiersep> code != null ) return exit <identifiersep> code return if ( code == 0 ) exit <identifiersep> code . ok else exit <identifiersep> code . compilation <identifiersep> error <ect>
@ component ( role = kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension : : class , hint = <string_literal> ) class kotlin <identifiersep> sam <identifiersep> with <identifiersep> receiver <identifiersep> maven <identifiersep> plugin <identifiersep> extension : kotlin <identifiersep> maven <identifiersep> plugin <identifiersep> extension { @ requirement lateinit var logger : logger override fun get <identifiersep> compiler <identifiersep> plugin <identifiersep> id ( ) = sam <identifiersep> with <identifiersep> receiver <identifiersep> compiler <identifiersep> plugin <identifiersep> id override fun is <identifiersep> applicable ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) = true <LOG> override fun get <identifiersep> plugin <identifiersep> options ( project : maven <identifiersep> project , execution : mojo <identifiersep> execution ) : list < plugin <identifiersep> option > { return empty <identifiersep> list ( ) } <ect>
project . ext . is <identifiersep> sonatype <identifiersep> release = is <identifiersep> sonatype <identifiersep> publish && is <identifiersep> release project . ext [ 'signing . key <identifiersep> id' ] = project . properties [ 'kotlin . key . name' ] project . ext [ 'signing . password' ] = project . properties [ 'kotlin . key . passphrase' ] string sonatype <identifiersep> snapshots <identifiersep> url = ( is <identifiersep> sonatype <identifiersep> publish && ! is <identifiersep> release ) ? <string_literal> : null ext . repo <identifiersep> url = properties [ <string_literal> ] ? : sonatype <identifiersep> snapshots <identifiersep> url ? : properties [ <string_literal> ] ? : <string_literal> . to <identifiersep> string ( ) ext . username = properties [ <string_literal> ] ? : properties [ <string_literal> ] <LOG> ext . password = properties [ <string_literal> ] ? : properties [ <string_literal> ] do <identifiersep> last { println ( <string_literal> ) } } ext . sign <identifiersep> pom = { project project , maven <identifiersep> deployer deployer - > deployer . before <identifiersep> deployment { maven <identifiersep> deployment deployment - > if ( project . signing . required ) <ect>
val match <identifiersep> string = java <identifiersep> major <identifiersep> version <identifiersep> regex . match <identifiersep> entire ( version ) ? . group <identifiersep> values ? . get ( 1 ) val major <identifiersep> jersion = when ( match <identifiersep> string ) { <string_literal> - > jdk <identifiersep> major <identifiersep> version . jdk <identifiersep> <number_literal> <string_literal> - > jdk <identifiersep> major <identifiersep> version . jdk <identifiersep> <number_literal> <string_literal> - > jdk <identifiersep> major <identifiersep> version . jdk <identifiersep> <number_literal> <string_literal> - > jdk <identifiersep> major <identifiersep> version . jdk <identifiersep> <number_literal> <LOG> else - > { return false } } val prev = find { it . major <identifiersep> version == major <identifiersep> jersion } if ( prev == null ) { add ( jdk <identifiersep> id ( false , major <identifiersep> jersion , version , home <identifiersep> dir ) ) return true <ect>
log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; log . info ( <string_literal> , job <identifiersep> conf . get ( <string_literal> , <string_literal> ) ) ; current <identifiersep> process = new hadoop <identifiersep> flow <identifiersep> process ( new flow <identifiersep> session ( ) , job <identifiersep> conf , true ) ; string map <identifiersep> node <identifiersep> state = job <identifiersep> conf . get <identifiersep> raw ( <string_literal> ) ; if ( map <identifiersep> node <identifiersep> state == null ) map <identifiersep> node <identifiersep> state = read <identifiersep> state <identifiersep> from <identifiersep> dist <identifiersep> cache ( job <identifiersep> conf , job <identifiersep> conf . get ( flow <identifiersep> step . cascading <identifiersep> flow <identifiersep> step <identifiersep> id ) , <string_literal> ) ; <LOG> flow <identifiersep> node = deserialize <identifiersep> base64 ( map <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; tap source = flows . get <identifiersep> tap <identifiersep> for <identifiersep> id ( flow <identifiersep> node . get <identifiersep> source <identifiersep> taps ( ) , job <identifiersep> conf . get ( <string_literal> ) ) ; stream <identifiersep> graph = new hadoop <identifiersep> map <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , source ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ; for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) <ect>
flow <identifiersep> node = deserialize <identifiersep> base64 ( map <identifiersep> node <identifiersep> state , job <identifiersep> conf , base <identifiersep> flow <identifiersep> node . class ) ; log . info ( <string_literal> , flow <identifiersep> node . get <identifiersep> id ( ) , flow <identifiersep> node . get <identifiersep> ordinal ( ) ) ; tap source = flows . get <identifiersep> tap <identifiersep> for <identifiersep> id ( flow <identifiersep> node . get <identifiersep> source <identifiersep> taps ( ) , job <identifiersep> conf . get ( <string_literal> ) ) ; stream <identifiersep> graph = new hadoop <identifiersep> map <identifiersep> stream <identifiersep> graph ( current <identifiersep> process , flow <identifiersep> node , source ) ; for ( duct head : stream <identifiersep> graph . get <identifiersep> heads ( ) ) log . info ( <string_literal> + ( ( element <identifiersep> duct ) head ) . get <identifiersep> flow <identifiersep> element ( ) ) ; <LOG> for ( duct tail : stream <identifiersep> graph . get <identifiersep> tails ( ) ) for ( tap trap : flow <identifiersep> node . get <identifiersep> traps ( ) ) log . info ( <string_literal> + trap ) ; log <identifiersep> memory ( log , <string_literal> + flow <identifiersep> node . get <identifiersep> id ( ) + <string_literal> ) ; } catch ( throwable throwable ) { <ect>
<comment> <LOG> { for ( tap source : get <identifiersep> sources <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + source ) ; for ( tap sink : get <identifiersep> sinks <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + sink ) ; } <comment> <ect>
if ( vertex <identifiersep> id != null || ! ( dag <identifiersep> client instanceof timeline <identifiersep> client ) ) return vertex <identifiersep> id ; try { vertex <identifiersep> id = ( ( timeline <identifiersep> client ) dag <identifiersep> client ) . get <identifiersep> vertex <identifiersep> id ( get <identifiersep> id ( ) ) ; } catch ( io <identifiersep> exception | cascading <identifiersep> exception | tez <identifiersep> exception exception ) <LOG> { } return vertex <identifiersep> id ; } public int get <identifiersep> total <identifiersep> task <identifiersep> count ( ) { return total <identifiersep> task <identifiersep> count ; } public int get <identifiersep> succeeded <identifiersep> task <identifiersep> count ( ) <ect>
retrieved <identifiersep> are <identifiersep> finished = false ; } int retrieved = added + updated ; if ( added == 0 && updated == 1 ) <comment> <LOG> if ( continue <identifiersep> iterating ) } int total = slice <identifiersep> stats <identifiersep> map . size ( ) ; int added = total - start <identifiersep> size ; int remaining = get <identifiersep> total <identifiersep> task <identifiersep> count ( ) - total ; string duration = format <identifiersep> duration <identifiersep> from <identifiersep> millis ( system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ) ; if ( total == get <identifiersep> total <identifiersep> task <identifiersep> count ( ) && retrieved <identifiersep> are <identifiersep> finished ) <ect>
int remaining = get <identifiersep> total <identifiersep> task <identifiersep> count ( ) - total ; string duration = format <identifiersep> duration <identifiersep> from <identifiersep> millis ( system . current <identifiersep> time <identifiersep> millis ( ) - start <identifiersep> time ) ; if ( total == get <identifiersep> total <identifiersep> task <identifiersep> count ( ) && retrieved <identifiersep> are <identifiersep> finished ) all <identifiersep> children <identifiersep> finished = true ; if ( iteration == 0 && total == 0 ) log <identifiersep> info ( <string_literal> , remaining ) ; <LOG> else return total == get <identifiersep> total <identifiersep> task <identifiersep> count ( ) ; } private void update <identifiersep> slice <identifiersep> with ( tez <identifiersep> slice <identifiersep> stats slice <identifiersep> stats , task <identifiersep> status task <identifiersep> status , long last <identifiersep> fetch ) { if ( task <identifiersep> status == null ) return ; <ect>
try { constructor constructor = type . get <identifiersep> declared <identifiersep> constructor ( parameter <identifiersep> types ) ; constructor . set <identifiersep> accessible ( true ) ; return constructor . new <identifiersep> instance ( parameters ) ; } catch ( exception exception ) <LOG> { throw new flow <identifiersep> exception ( <string_literal> + type . get <identifiersep> name ( ) , exception ) ; } } public static boolean has <identifiersep> class ( string type <identifiersep> string ) { try { <ect>
stack <identifiersep> trace <identifiersep> element [ ] stack <identifiersep> trace = thread . current <identifiersep> thread ( ) . get <identifiersep> stack <identifiersep> trace ( ) ; for ( stack <identifiersep> trace <identifiersep> element stack <identifiersep> trace <identifiersep> element : stack <identifiersep> trace ) { if ( stack <identifiersep> trace <identifiersep> element . get <identifiersep> method <identifiersep> name ( ) . equals ( <string_literal> ) && ! stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) . starts <identifiersep> with ( package <identifiersep> exclude ) ) { try <LOG> { return thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { log . warn ( <string_literal> , stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) , exception ) ; } } } log . info ( <string_literal> ) ; <ect>
try { log . info ( <string_literal> , stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) ) ; return thread . current <identifiersep> thread ( ) . get <identifiersep> context <identifiersep> class <identifiersep> loader ( ) . load <identifiersep> class ( stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) ) ; } catch ( class <identifiersep> not <identifiersep> found <identifiersep> exception exception ) { <LOG> log . warn ( <string_literal> , stack <identifiersep> trace <identifiersep> element . get <identifiersep> class <identifiersep> name ( ) , exception ) ; } } } return default <identifiersep> type ; } public static string find <identifiersep> containing <identifiersep> jar ( class < ? > type ) { class <identifiersep> loader class <identifiersep> loader = type . get <identifiersep> class <identifiersep> loader ( ) ; string class <identifiersep> file = type . get <identifiersep> name ( ) . replace <identifiersep> all ( <string_literal> , <string_literal> ) + <string_literal> ; <ect>
fire <identifiersep> on <identifiersep> starting ( ) ; { log <identifiersep> info ( <string_literal> ) ; for ( tap source : get <identifiersep> sources <identifiersep> collection ( ) ) log <identifiersep> info ( <string_literal> + source ) ; <LOG> for ( tap sink : get <identifiersep> sinks <identifiersep> collection ( ) ) } spawn <identifiersep> steps ( ) ; } catch ( throwable throwable ) { this . throwable = throwable ; } finally <ect>
{ { long total <identifiersep> slice <identifiersep> cpu <identifiersep> seconds = get <identifiersep> total <identifiersep> slice <identifiersep> cpu <identifiersep> milli <identifiersep> seconds ( ) ; if ( total <identifiersep> slice <identifiersep> cpu <identifiersep> seconds == - 1 ) log <identifiersep> info ( <string_literal> + format <identifiersep> duration <identifiersep> from <identifiersep> millis ( flow <identifiersep> stats . get <identifiersep> duration ( ) ) ) ; <LOG> else } flow <identifiersep> stats . cleanup ( ) ; internal <identifiersep> shutdown ( ) ; deregister <identifiersep> shutdown <identifiersep> hook ( ) ; } } } <comment> <ect>
if ( num <identifiersep> threads == 0 ) num <identifiersep> threads = eligible <identifiersep> jobs <identifiersep> size ; if ( num <identifiersep> threads == 0 ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + get <identifiersep> name ( ) ) ; { <LOG> log <identifiersep> info ( <string_literal> + ( get <identifiersep> max <identifiersep> num <identifiersep> parallel <identifiersep> steps ( ) != 1 ) ) ; log <identifiersep> info ( <string_literal> + num <identifiersep> threads ) ; } list < future < throwable > > futures = spawn <identifiersep> jobs ( num <identifiersep> threads ) ; for ( future < throwable > future : futures ) { throwable = future . get ( ) ; <ect>
return ; } if ( contains <identifiersep> vertex ( current ) ) return ; add <identifiersep> vertex ( current ) ; tap sink = sinks . remove ( current . get <identifiersep> name ( ) ) ; if ( sink != null ) <LOG> { add <identifiersep> vertex ( sink ) ; log . debug ( <string_literal> , current , sink ) ; add <identifiersep> edge ( current , sink ) . set <identifiersep> name ( current . get <identifiersep> name ( ) ) ; } <comment> <ect>
add <identifiersep> edge ( current , sink ) . set <identifiersep> name ( current . get <identifiersep> name ( ) ) ; } <comment> <LOG> { add <identifiersep> vertex ( source ) ; log . debug ( <string_literal> , source , current ) ; scope scope = add <identifiersep> edge ( source , current ) ; scope . set <identifiersep> name ( current . get <identifiersep> name ( ) ) ; set <identifiersep> ordinal ( source , current , scope ) ; <ect>
log . debug ( <string_literal> , source , current ) ; scope scope = add <identifiersep> edge ( source , current ) ; scope . set <identifiersep> name ( current . get <identifiersep> name ( ) ) ; set <identifiersep> ordinal ( source , current , scope ) ; } } for ( pipe previous : sub <identifiersep> assembly . unwind ( current . get <identifiersep> previous ( ) ) ) { <LOG> make <identifiersep> graph ( previous , sources , sinks ) ; if ( get <identifiersep> edge ( previous , current ) != null ) throw new element <identifiersep> graph <identifiersep> exception ( previous , <string_literal> + previous ) ; scope scope = add <identifiersep> edge ( previous , current ) ; scope . set <identifiersep> name ( previous . get <identifiersep> name ( ) ) ; <comment> <ect>
scope outgoing <identifiersep> scope = ( ( scoped <identifiersep> element ) source ) . outgoing <identifiersep> scope <identifiersep> for ( incoming <identifiersep> scopes ) ; { log . debug ( <string_literal> + source ) ; if ( outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) ) ; <LOG> if ( outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) != null ) if ( outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) ) ; } for ( scope scope : outgoing <identifiersep> scopes ) <ect>
if ( outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> arguments <identifiersep> selector ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> operation <identifiersep> declared <identifiersep> fields ( ) ) ; if ( outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) != null ) log . debug ( <string_literal> + outgoing <identifiersep> scope . get <identifiersep> key <identifiersep> selectors ( ) ) ; <LOG> if ( outgoing <identifiersep> scope . get <identifiersep> out <identifiersep> values <identifiersep> selector ( ) != null ) } for ( scope scope : outgoing <identifiersep> scopes ) scope . copy <identifiersep> fields ( outgoing <identifiersep> scope ) ; } } <ect>
source <identifiersep> modified = util . get <identifiersep> source <identifiersep> modified ( config , values , sink <identifiersep> modified ) ; if ( sink <identifiersep> modified < source <identifiersep> modified ) return true ; return false ; } finally <LOG> { } } long get <identifiersep> sink <identifiersep> modified ( ) throws io <identifiersep> exception { long sink <identifiersep> modified = util . get <identifiersep> sink <identifiersep> modified ( get <identifiersep> config ( ) , sinks . key <identifiersep> set ( ) ) ; { <ect>
log . trace ( <string_literal> , vertex <identifiersep> map ) ; } else { log . trace ( <string_literal> , n1 , n2 ) ; <LOG> copy . back <identifiersep> track ( ) ; } } } return found ; } } <ect>
super ( fields . as <identifiersep> declaration ( get <identifiersep> sink <identifiersep> fields ( ) ) ) ; collectors = new tuple <identifiersep> entry <identifiersep> collector [ taps . length ] ; c conf = flow <identifiersep> process . get <identifiersep> config <identifiersep> copy ( ) ; for ( int i = 0 ; i < taps . length ; i ++ ) { c merged <identifiersep> conf = child <identifiersep> configs == null ? conf : flow <identifiersep> process . merge <identifiersep> map <identifiersep> into <identifiersep> config ( conf , child <identifiersep> configs . get ( i ) ) ; <LOG> tap < config , ? , ? > tap = taps [ i ] ; collectors [ i ] = tap . open <identifiersep> for <identifiersep> write ( flow <identifiersep> process . copy <identifiersep> with ( merged <identifiersep> conf ) , null ) ; } } protected void collect ( tuple <identifiersep> entry tuple <identifiersep> entry ) throws io <identifiersep> exception { for ( int i = 0 ; i < taps . length ; i ++ ) collectors [ i ] . add ( tuple <identifiersep> entry ) ; <ect>
tuple <identifiersep> entry <identifiersep> collector get <identifiersep> collector ( string path ) { tuple <identifiersep> entry <identifiersep> collector collector = collectors . get ( path ) ; if ( collector != null ) return collector ; try <LOG> { collector = create <identifiersep> tuple <identifiersep> entry <identifiersep> scheme <identifiersep> collector ( flow <identifiersep> process , parent , path , opened <identifiersep> collectors ) ; opened <identifiersep> collectors ++ ; flow <identifiersep> process . increment ( counters . paths <identifiersep> opened , 1 ) ; } catch ( io <identifiersep> exception exception ) { <ect>
return cached <identifiersep> counters ; <comment> <LOG> if ( cached <identifiersep> counters == null ) else log . warn ( <string_literal> , format <identifiersep> duration <identifiersep> from <identifiersep> millis ( current <identifiersep> time <identifiersep> millis ( ) - last <identifiersep> fetch ) , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) ) ; warned <identifiersep> stale = true ; } return cached <identifiersep> counters ; } boolean is <identifiersep> process <identifiersep> finished = stats . is <identifiersep> finished ( ) ; <ect>
if ( success ) { cached <identifiersep> counters = fetched ; last <identifiersep> fetch = current <identifiersep> time <identifiersep> millis ( ) ; fetch <identifiersep> attempts = 0 ; <comment> <LOG> { } catch ( execution <identifiersep> exception exception ) { fetch <identifiersep> attempts ++ ; if ( fetch <identifiersep> attempts >= max <identifiersep> fetch <identifiersep> attempts ) log . error ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) ) ; <ect>
log . warn ( <string_literal> ) ; } catch ( execution <identifiersep> exception exception ) { fetch <identifiersep> attempts ++ ; if ( fetch <identifiersep> attempts >= max <identifiersep> fetch <identifiersep> attempts ) log . error ( <string_literal> , fetch <identifiersep> attempts , stats . get <identifiersep> type ( ) , stats . get <identifiersep> status ( ) , exception . get <identifiersep> cause ( ) ) ; <LOG> else if ( cached <identifiersep> counters != null ) { log . error ( <string_literal> ) ; return cached <identifiersep> counters ; } log . error ( <string_literal> , exception . get <identifiersep> cause ( ) ) ; <ect>
pipe pipe <identifiersep> upper = new each ( new pipe ( <string_literal> ) , new fields ( <string_literal> ) , splitter ) ; pipe <identifiersep> upper = new group <identifiersep> by ( pipe <identifiersep> upper , new fields ( <string_literal> ) ) ; pipe splice = new co <identifiersep> group ( pipe <identifiersep> lower , new fields ( <string_literal> ) , pipe <identifiersep> upper , new fields ( <string_literal> ) , fields . size ( <number_literal> ) ) ; final flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( get <identifiersep> properties ( ) ) . connect ( sources , sink , splice ) ; <comment> <LOG> flow . add <identifiersep> listener ( listener ) ; flow . start ( ) ; util . safe <identifiersep> sleep ( <number_literal> ) ; assert <identifiersep> true ( <string_literal> , listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; while ( true ) { <ect>
if ( flow <identifiersep> step <identifiersep> job . is <identifiersep> started ( ) ) break ; } final semaphore start = new semaphore ( 0 ) ; final long start <identifiersep> time = system . nano <identifiersep> time ( ) ; future < long > future = new <identifiersep> single <identifiersep> thread <identifiersep> executor ( ) . submit ( ( ) - > { <LOG> start . release ( ) ; flow . complete ( ) ; return system . nano <identifiersep> time ( ) - start <identifiersep> time ; } ) ; start . acquire ( ) ; log . info ( <string_literal> ) ; <ect>
pipe pipe <identifiersep> upper = new each ( new pipe ( <string_literal> ) , new fields ( <string_literal> ) , splitter ) ; pipe <identifiersep> upper = new group <identifiersep> by ( pipe <identifiersep> upper , new fields ( <string_literal> ) ) ; pipe splice = new co <identifiersep> group ( pipe <identifiersep> lower , new fields ( <string_literal> ) , pipe <identifiersep> upper , new fields ( <string_literal> ) , fields . size ( <number_literal> ) ) ; flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( get <identifiersep> properties ( ) ) . connect ( sources , sink , splice ) ; <comment> <LOG> flow . add <identifiersep> listener ( listener ) ; flow . start ( ) ; assert <identifiersep> true ( <string_literal> , listener . started . try <identifiersep> acquire ( <number_literal> , time <identifiersep> unit . seconds ) ) ; if ( on <identifiersep> fail == failing <identifiersep> flow <identifiersep> listener . on <identifiersep> fail . stopping ) { while ( true ) <ect>
{ path job <identifiersep> output <identifiersep> path = task <identifiersep> output <identifiersep> path . get <identifiersep> parent ( ) . get <identifiersep> parent ( ) ; <comment> <LOG> log . info ( <string_literal> , task <identifiersep> id , task <identifiersep> output <identifiersep> path ) ; } } return true ; } <comment> <ect>
{ file <identifiersep> system file <identifiersep> sys = get <identifiersep> fs <identifiersep> safe ( conf , output <identifiersep> path ) ; if ( file <identifiersep> sys == null ) return ; if ( ! file <identifiersep> sys . exists ( output <identifiersep> path ) ) return ; <LOG> path tmp <identifiersep> dir = new path ( output <identifiersep> path , temporary <identifiersep> path ) ; if ( file <identifiersep> sys . exists ( tmp <identifiersep> dir ) ) file <identifiersep> sys . delete ( tmp <identifiersep> dir , true ) ; } } private static file <identifiersep> system get <identifiersep> fs <identifiersep> safe ( configuration conf , path tmp <identifiersep> dir ) { try <ect>
path final <identifiersep> output <identifiersep> path = get <identifiersep> final <identifiersep> path ( job <identifiersep> output <identifiersep> dir , task <identifiersep> output , get <identifiersep> task <identifiersep> output <identifiersep> path ( conf ) ) ; if ( ! fs . rename ( task <identifiersep> output , final <identifiersep> output <identifiersep> path ) ) { if ( ! fs . delete ( final <identifiersep> output <identifiersep> path , true ) ) throw new io <identifiersep> exception ( <string_literal> + task <identifiersep> id ) ; if ( ! fs . rename ( task <identifiersep> output , final <identifiersep> output <identifiersep> path ) ) <LOG> throw new io <identifiersep> exception ( <string_literal> + task <identifiersep> id ) ; } } else if ( fs . get <identifiersep> file <identifiersep> status ( task <identifiersep> output ) . is <identifiersep> dir ( ) ) { file <identifiersep> status [ ] paths = fs . list <identifiersep> status ( task <identifiersep> output ) ; path final <identifiersep> output <identifiersep> path = get <identifiersep> final <identifiersep> path ( job <identifiersep> output <identifiersep> dir , task <identifiersep> output , get <identifiersep> task <identifiersep> output <identifiersep> path ( conf ) ) ; fs . mkdirs ( final <identifiersep> output <identifiersep> path ) ; <ect>
@ override public input <identifiersep> stream next ( ) { safe <identifiersep> close ( ) ; path path = iterator . next ( ) ; <LOG> flow <identifiersep> process . get <identifiersep> flow <identifiersep> process <identifiersep> context ( ) . set <identifiersep> source <identifiersep> path ( path . to <identifiersep> absolute <identifiersep> path ( ) . to <identifiersep> string ( ) ) ; try { last <identifiersep> input <identifiersep> stream = files . new <identifiersep> input <identifiersep> stream ( path ) ; return last <identifiersep> input <identifiersep> stream ; } catch ( io <identifiersep> exception exception ) <ect>
<comment> <LOG> flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( ) . connect ( source , sink , pipe ) ; flow . start ( ) ; <comment> <ect>
} ) ; tap sink = get <identifiersep> platform ( ) . get <identifiersep> text <identifiersep> file ( get <identifiersep> output <identifiersep> path ( <string_literal> ) , sink <identifiersep> mode . replace ) ; flow flow = get <identifiersep> platform ( ) . get <identifiersep> flow <identifiersep> connector ( ) . connect ( source , sink , pipe ) ; <comment> <LOG> start . acquire ( ) ; flow . stop ( ) ; long source <identifiersep> size = entry <identifiersep> stream ( source , flow . get <identifiersep> flow <identifiersep> process ( ) ) . count ( ) ; long sink <identifiersep> size = entry <identifiersep> stream ( sink , flow . get <identifiersep> flow <identifiersep> process ( ) ) . count ( ) ; assert <identifiersep> not <identifiersep> same ( source <identifiersep> size , sink <identifiersep> size ) ; assert <identifiersep> equals ( limit , sink <identifiersep> size ) ; <ect>
super ( flow <identifiersep> process , source ) ; if ( logical <identifiersep> input == null ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> ) ; this . logical <identifiersep> input = ( mr <identifiersep> input ) logical <identifiersep> input ; } @ override public void prepare ( ) <LOG> { logical <identifiersep> input . start ( ) ; hadoop2tez <identifiersep> flow <identifiersep> process tez <identifiersep> flow <identifiersep> process = ( hadoop2tez <identifiersep> flow <identifiersep> process ) flow <identifiersep> process <identifiersep> wrapper . undelegate ( flow <identifiersep> process ) ; tez <identifiersep> configuration configuration = tez <identifiersep> flow <identifiersep> process . get <identifiersep> configuration ( ) ; try { <ect>
{ log . info ( <string_literal> , logical <identifiersep> input . get <identifiersep> class ( ) . get <identifiersep> simple <identifiersep> name ( ) , get <identifiersep> boundary ( ) , pipe . id ( get <identifiersep> boundary ( ) ) ) ; logical <identifiersep> input . start ( ) ; } if ( logical <identifiersep> outputs != null ) { for ( logical <identifiersep> output logical <identifiersep> output : logical <identifiersep> outputs ) <LOG> { logical <identifiersep> output . start ( ) ; } } } catch ( exception exception ) { throw new cascading <identifiersep> exception ( <string_literal> , exception ) ; } if ( role != io <identifiersep> role . source ) <ect>
timed <identifiersep> iterators [ i ] . reset ( current <identifiersep> values . get ( i ) ) ; accept ( current . get <identifiersep> key ( ) , timed <identifiersep> iterators ) ; current = forward <identifiersep> to <identifiersep> next ( readers , iterables , current <identifiersep> values ) ; } complete ( this ) ; } catch ( throwable throwable ) { <LOG> if ( ! ( throwable instanceof out <identifiersep> of <identifiersep> memory <identifiersep> error ) ) return throwable ; } return null ; } private sorted <identifiersep> list <identifiersep> multi <identifiersep> map < integer , key <identifiersep> values <identifiersep> reader > get <identifiersep> key <identifiersep> values <identifiersep> readers ( ) throws exception { sorted <identifiersep> list <identifiersep> multi <identifiersep> map < integer , key <identifiersep> values <identifiersep> reader > readers = new sorted <identifiersep> list <identifiersep> multi <identifiersep> map < > ( ) ; <ect>
} catch ( number <identifiersep> format <identifiersep> exception e ) { logger . error ( fields . class , <string_literal> + s + <string_literal> + e , e ) ; return default <identifiersep> value ; } } public static long parse <identifiersep> short ( string s , short default <identifiersep> value ) { try { return short . parse <identifiersep> short ( s ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return default <identifiersep> value ; } } <comment> <ect>
<comment> public token <identifiersep> bucket ( long max , long nanos <identifiersep> per <identifiersep> tick , long initial <identifiersep> value ) { this . max = max ; this . current = initial <identifiersep> value ; <LOG> if ( current > max ) { current = max ; } this . nanos <identifiersep> per <identifiersep> tick = nanos <identifiersep> per <identifiersep> tick ; long now = system . current <identifiersep> time <identifiersep> millis ( ) ; this . time <identifiersep> last <identifiersep> tick = nanoseconds . convert ( now , milliseconds ) ; if ( nanos <identifiersep> per <identifiersep> tick < = 0 ) throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + add + <string_literal> + current ) ; <comment> <LOG> system . err . println ( <string_literal> + time <identifiersep> util . format <identifiersep> time ( milliseconds . convert ( time <identifiersep> last <identifiersep> tick - now <identifiersep> ns , nanoseconds ) , <number_literal> , true ) ) ; logger . error ( this , <string_literal> + time <identifiersep> util . format <identifiersep> time ( milliseconds . convert ( time <identifiersep> last <identifiersep> tick - now <identifiersep> ns , nanoseconds ) , <number_literal> , true ) ) ; time <identifiersep> last <identifiersep> tick = now <identifiersep> ns ; return 0 ; } long next <identifiersep> tick = time <identifiersep> last <identifiersep> tick + nanos <identifiersep> per <identifiersep> tick ; if ( next <identifiersep> tick > now <identifiersep> ns ) { <ect>
native <identifiersep> priority <identifiersep> range = <number_literal> - native <identifiersep> priority <identifiersep> base ; system . out . println ( <string_literal> + native <identifiersep> priority <identifiersep> base + ' ) ' ) ; <comment> <LOG> if ( ! ( has <identifiersep> enough <identifiersep> nice <identifiersep> levels && has <identifiersep> three <identifiersep> nice <identifiersep> levels ) )  <identifiersep> load <identifiersep> native = true ; } else { <comment> <ect>
if ( native <identifiersep> priority <identifiersep> base != real <identifiersep> prio && ! dont <identifiersep> check <identifiersep> renice ) { <comment> <LOG>  <identifiersep> disabled = true ; system . err . println ( <string_literal> + native <identifiersep> priority <identifiersep> base + <string_literal> + real <identifiersep> prio + <string_literal> + this ) ; new null <identifiersep> pointer <identifiersep> exception ( ) . print <identifiersep> stack <identifiersep> trace ( ) ; return false ; } final int linux <identifiersep> priority = native <identifiersep> priority <identifiersep> base + native <identifiersep> priority <identifiersep> range - ( native <identifiersep> priority <identifiersep> range * ( prio - min <identifiersep> priority ) ) / java <identifiersep> priority <identifiersep> range ; if ( linux <identifiersep> priority == real <identifiersep> prio ) return true ; <comment> <ect>
public void register ( file file ) { synchronized ( this ) { if ( original <identifiersep> files == null ) throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> ) ; file = file <identifiersep> util . get <identifiersep> canonical <identifiersep> file ( file ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + file , new exception ( <string_literal> ) ) ; <LOG> if ( ! original <identifiersep> files . remove ( file ) ) } } <comment> public synchronized void completed <identifiersep> init ( ) { <ect>
boolean executable = copy <identifiersep> from . can <identifiersep> execute ( ) ; file <identifiersep> bucket out <identifiersep> bucket = new file <identifiersep> bucket ( copy <identifiersep> to , false , true , false , false ) ; file <identifiersep> bucket in <identifiersep> bucket = new file <identifiersep> bucket ( copy <identifiersep> from , true , false , false , false ) ; try { bucket <identifiersep> tools . copy ( in <identifiersep> bucket , out <identifiersep> bucket ) ; if ( executable ) { <LOG> if ( ! ( copy <identifiersep> to . set <identifiersep> executable ( true ) || copy <identifiersep> to . can <identifiersep> execute ( ) ) ) { <comment> <ect>
filename <identifiersep> generator generator , boolean delete <identifiersep> on <identifiersep> free ) { super ( generator . get <identifiersep> filename ( id ) , false ) ; this . filename <identifiersep> id = id ; this . generator = generator ; this . delete <identifiersep> on <identifiersep> free = delete <identifiersep> on <identifiersep> free ; this . file = generator . get <identifiersep> filename ( id ) ; <LOG> if ( log <identifiersep> debug ) { } } protected temp <identifiersep> file <identifiersep> bucket ( ) { <comment> <ect>
for ( list <identifiersep> iterator < temp <identifiersep> bucket <identifiersep> input <identifiersep> stream > i = tbis . list <identifiersep> iterator ( ) ; i . has <identifiersep> next ( ) ; ) { temp <identifiersep> bucket <identifiersep> input <identifiersep> stream is = i . next ( ) ; if ( for <identifiersep> free ) { i . remove ( ) ; try { is . close ( ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } else { try { is .  <identifiersep> maybe <identifiersep> reset <identifiersep> input <identifiersep> stream ( ) ; } catch ( io <identifiersep> exception e ) { i . remove ( ) ; <ect>
return - 1 ; } string ppid <identifiersep> string = get <identifiersep> field <identifiersep> from <identifiersep> proc <identifiersep> self <identifiersep> stat ( <number_literal> , o ) ; if ( null == ppid <identifiersep> string ) { return - 1 ; } try { ppid = integer . parse <identifiersep> int ( ppid <identifiersep> string . trim ( ) ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { } return ppid ; } <comment> public synchronized static int log <identifiersep> pid ( object o ) { <ect>
int ppid = get <identifiersep> ppid ( o ) ; string msg ; if ( - 1 != ppid ) { msg = <string_literal> + ppid ; } else { msg = <string_literal> ; } <LOG> if ( log <identifiersep> to <identifiersep> std <identifiersep> out <identifiersep> enabled ) { } if ( log <identifiersep> to <identifiersep> file <identifiersep> enabled ) { log <identifiersep> static ( o , msg , log <identifiersep> to <identifiersep> file <identifiersep> verbosity ) ; } return ppid ; } } <comment> public enum log <identifiersep> level { <ect>
public synchronized static int global <identifiersep> get <identifiersep> threshold ( ) { return global <identifiersep> get <identifiersep> threshold <identifiersep> new ( ) . ordinal ( ) ; } <comment> public synchronized static void global <identifiersep> remove <identifiersep> hook ( logger <identifiersep> hook hook ) { if ( logger instanceof logger <identifiersep> hook <identifiersep> chain ) { ( ( logger <identifiersep> hook <identifiersep> chain ) logger ) . remove <identifiersep> hook ( hook ) ; <LOG> } else { } } <comment> public synchronized static void destroy <identifiersep> chain <identifiersep> if <identifiersep> empty ( ) { if ( logger instanceof void <identifiersep> logger ) return ; <ect>
string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; float [ ] ret = new float [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { try { ret [ i ] = float . value <identifiersep> of ( strings [ i ] ) ; <LOG> } catch ( number <identifiersep> format <identifiersep> exception e ) { return null ; } } return ret ; } public boolean [ ] get <identifiersep> boolean <identifiersep> array ( string key ) { string [ ] strings = get <identifiersep> all ( key ) ; if ( strings == null ) return null ; <ect>
} ) ; } <comment> private static string uname ; static { uname = <string_literal> ; } static synchronized void get <identifiersep> u <identifiersep> name ( ) { <LOG> if ( ! uname . equals ( <string_literal> ) ) return ; try { inet <identifiersep> address addr = inet <identifiersep> address . get <identifiersep> local <identifiersep> host ( ) ; if ( addr != null ) { uname = new string <identifiersep> tokenizer ( addr . get <identifiersep> host <identifiersep> name ( ) , <string_literal> ) . next <identifiersep> token ( ) ; <ect>
current <identifiersep> filename = new file ( get <identifiersep> hour <identifiersep> log <identifiersep> name ( gc , - 1 , true ) ) ; synchronized ( log <identifiersep> files ) { if ( ( ! log <identifiersep> files . is <identifiersep> empty ( ) ) && log <identifiersep> files . get <identifiersep> last ( ) . filename . equals ( current <identifiersep> filename ) ) { log <identifiersep> files . remove <identifiersep> last ( ) ; } } log <identifiersep> stream = open <identifiersep> new <identifiersep> log <identifiersep> file ( current <identifiersep> filename , true ) ; if ( latest <identifiersep> file != null ) { <LOG> alt <identifiersep> log <identifiersep> stream = open <identifiersep> new <identifiersep> log <identifiersep> file ( latest <identifiersep> file , false ) ; } start <identifiersep> time = gc . get <identifiersep> time <identifiersep> in <identifiersep> millis ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + gc + <string_literal> + start <identifiersep> time ) ; last <identifiersep> time = start <identifiersep> time ; gc . add ( interval , interval <identifiersep> multiplier ) ; <ect>
try { cleaner <identifiersep> thread . resize <identifiersep> store ( prev <identifiersep> store <identifiersep> size , false ) ; } finally { cleaner <identifiersep> global <identifiersep> lock . unlock ( ) ; } write <identifiersep> config <identifiersep> file ( ) ; } if ( ( ( ! slot <identifiersep> filter <identifiersep> disabled ) && slot <identifiersep> filter . is <identifiersep> new ( ) ) && ! new <identifiersep> store ) { <LOG> flags | = flag <identifiersep> rebuild <identifiersep> bloom ; } else if ( ( flags & flag <identifiersep> rebuild <identifiersep> bloom ) != 0 ) system . out . println ( <string_literal> ) ; } private boolean started = false ; <comment> <ect>
} catch ( interrupted <identifiersep> exception e ) { throw new io <identifiersep> exception ( <string_literal> + e ) ; } byte [ ] digested <identifiersep> key = cipher <identifiersep> manager . get <identifiersep> digested <identifiersep> key ( routing <identifiersep> key ) ; try { map < long , condition > lock <identifiersep> map = lock <identifiersep> digested <identifiersep> key ( digested <identifiersep> key , true ) ; if ( lock <identifiersep> map == null ) { <LOG> if ( log <identifiersep> debug ) return null ; } try { entry entry = probe <identifiersep> entry ( digested <identifiersep> key , routing <identifiersep> key , true ) ; if ( entry == null ) { misses . increment <identifiersep> and <identifiersep> get ( ) ; <ect>
try { if ( store <identifiersep> file <identifiersep> offset <identifiersep> ready == - 1 || offset [ i ] < this . store <identifiersep> file <identifiersep> offset <identifiersep> ready ) { entry = read <identifiersep> entry ( offset [ i ] , digested <identifiersep> key , routing <identifiersep> key , with <identifiersep> data ) ; if ( entry != null ) return entry ; } } catch ( eof <identifiersep> exception e ) { <LOG> if ( prev <identifiersep> store <identifiersep> size == 0 ) <comment> <ect>
@ override public void cache <identifiersep> key ( byte [ ] hash , dsa <identifiersep> public <identifiersep> key key , boolean deep , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore , boolean for <identifiersep> ulpr , boolean write <identifiersep> local <identifiersep> to <identifiersep> datastore ) { try { store . put ( hash , key , false ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } } <ect>
t ret = callback . construct ( data , header , routing <identifiersep> key , fk , can <identifiersep> read <identifiersep> client <identifiersep> cache , can <identifiersep> read <identifiersep> slashdot <identifiersep> cache , null , null ) ; synchronized ( this ) { hits ++ ; if ( ! dont <identifiersep> promote ) { block . last <identifiersep> accessed = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> blocks <identifiersep> by <identifiersep> routing <identifiersep> key . push ( key , block ) ; } } return ret ; } catch ( key <identifiersep> verify <identifiersep> exception e ) { block . data . free ( ) ; synchronized ( this ) { blocks <identifiersep> by <identifiersep> routing <identifiersep> key . remove <identifiersep> key ( key ) ; <ect>
block = blocks <identifiersep> by <identifiersep> routing <identifiersep> key . get ( key ) ; } finally { config <identifiersep> lock . read <identifiersep> lock ( ) . unlock ( ) ; } if ( block != null ) { try { return this . callback . construct ( block . data , block . header , routing <identifiersep> key , block . block . get <identifiersep> full <identifiersep> key ( ) , can <identifiersep> read <identifiersep> client <identifiersep> cache , can <identifiersep> read <identifiersep> slashdot <identifiersep> cache , meta , null ) ; <LOG> } catch ( key <identifiersep> verify <identifiersep> exception e ) { } } return back <identifiersep> datastore . fetch ( routing <identifiersep> key , full <identifiersep> key , dont <identifiersep> promote , can <identifiersep> read <identifiersep> client <identifiersep> cache , can <identifiersep> read <identifiersep> slashdot <identifiersep> cache , ignore <identifiersep> old <identifiersep> blocks , meta ) ; } @ override public boolean probably <identifiersep> in <identifiersep> store ( byte [ ] routing <identifiersep> key ) { byte <identifiersep> array <identifiersep> wrapper key = new byte <identifiersep> array <identifiersep> wrapper ( routing <identifiersep> key ) ; block < t > block = null ; <ect>
prls =  <identifiersep> packet <identifiersep> received <identifiersep> listeners . to <identifiersep> array ( new packet <identifiersep> received <identifiersep> listener [  <identifiersep> packet <identifiersep> received <identifiersep> listeners . size ( ) ] ) ; } for ( packet <identifiersep> received <identifiersep> listener prl : prls ) { prl . packet <identifiersep> received ( position ) ; } } public synchronized boolean all <identifiersep> received <identifiersep> and <identifiersep> not <identifiersep> aborted ( ) { return  <identifiersep> received <identifiersep> count ==  <identifiersep> packets && !  <identifiersep> aborted ; } public synchronized boolean all <identifiersep> received ( ) throws aborted <identifiersep> exception { <LOG> if (  <identifiersep> received <identifiersep> count ==  <identifiersep> packets ) { return true ; } if (  <identifiersep> aborted ) { throw new aborted <identifiersep> exception ( <string_literal> +  <identifiersep> abort <identifiersep> reason + <string_literal> +  <identifiersep> abort <identifiersep> description + <string_literal> +  <identifiersep> received <identifiersep> count + <string_literal> +  <identifiersep> packets + <string_literal> + this ) ; } return false ; } public synchronized byte [ ] get <identifiersep> block ( ) throws aborted <identifiersep> exception { <ect>
addr = new inet <identifiersep> socket <identifiersep> address ( address , port ) ; server <identifiersep> socket . set <identifiersep> reuse <identifiersep> address ( true ) ; server <identifiersep> socket . bind ( addr ) ; acceptor acceptor = new acceptor ( server <identifiersep> socket ) ; try { acceptor . set <identifiersep> so <identifiersep> timeout ( timeout ) ; <LOG> } catch ( socket <identifiersep> exception e ) { } lock . lock ( ) ; try { acceptors . add ( acceptor ) ; running <identifiersep> acceptors ++ ; executor . execute ( acceptor , <string_literal> + acceptor . server <identifiersep> socket ) ; <ect>
} finally { lock . unlock ( ) ; } } catch ( io <identifiersep> exception e ) { if ( e instanceof socket <identifiersep> exception && ignore <identifiersep> unbindable <identifiersep> ip6 && addr != null && addr . get <identifiersep> address ( ) instanceof inet6address ) continue ; <LOG> system . err . println ( <string_literal> + address + <string_literal> + port ) ; if ( broken <identifiersep> list == null ) broken <identifiersep> list = new array <identifiersep> list < string > ( ) ; broken <identifiersep> list . add ( address ) ; } } <comment> <ect>
<comment> public message <identifiersep> filter or ( message <identifiersep> filter or ) { if ( ( or != null ) && (  <identifiersep> or != null ) && or !=  <identifiersep> or ) { throw new illegal <identifiersep> state <identifiersep> exception ( <string_literal> + <string_literal> +  <identifiersep> or + <string_literal> + or + <string_literal> ) ; } <LOG> if ( or .  <identifiersep> initial <identifiersep> timeout !=  <identifiersep> initial <identifiersep> timeout ) { <comment> <ect>
if (  <identifiersep> matched ) { logger . error ( this , <string_literal> + this , new exception ( <string_literal> ) ) ; return true ; <comment> <LOG> public synchronized void set <identifiersep> message ( message message ) {  <identifiersep> message = message ; <comment> <ect>
system . err . print ( r . total <identifiersep> memory ( ) ) ; system . err . println ( ) ; } catch ( throwable tt ) { } try { t . print <identifiersep> stack <identifiersep> trace ( ) ; } catch ( throwable tt ) { } <LOG> } finally { logger . error ( this , <string_literal> +  <identifiersep> sock . get <identifiersep> local <identifiersep> port ( ) ) ; synchronized ( this ) {  <identifiersep> is <identifiersep> done = true ; notify <identifiersep> all ( ) ; } } } private void run <identifiersep> loop ( ) { <ect>
throw new malformed <identifiersep> url <identifiersep> exception ( <string_literal> ) ; dsa <identifiersep> group g = global . ds <identifiersep> agroup <identifiersep> big <identifiersep> a ; dsa <identifiersep> private <identifiersep> key priv <identifiersep> key ; try { priv <identifiersep> key = new dsa <identifiersep> private <identifiersep> key ( new big <identifiersep> integer ( 1 , uri . get <identifiersep> routing <identifiersep> key ( ) ) , g ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { <LOG> <comment> <ect>
throw new malformed <identifiersep> url <identifiersep> exception ( <string_literal> ) ; if ( ! st . has <identifiersep> more <identifiersep> tokens ( ) ) { extra = null ; return ; } extra = base64 . decode ( st . next <identifiersep> token ( ) ) ; } catch ( illegal <identifiersep> base64exception e ) { <LOG> throw new malformed <identifiersep> url <identifiersep> exception ( <string_literal> + e ) ; } } <comment> public freenet <identifiersep> uri ( byte [ ] pub <identifiersep> key <identifiersep> hash , byte [ ] crypto <identifiersep> key , byte [ ] extra , string site <identifiersep> name , long suggested <identifiersep> edition2 ) { <comment> <ect>
this . suggested <identifiersep> edition = 0 ; } <comment> public void decompose ( ) { string r = routing <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( routing <identifiersep> key ) ; string k = crypto <identifiersep> key == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( crypto <identifiersep> key ) ; string e = extra == null ? <string_literal> : hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( extra ) ; <LOG> system . out . println ( <string_literal> + this ) ; system . out . println ( <string_literal> + r ) ; system . out . println ( <string_literal> + k ) ; system . out . println ( <string_literal> + e ) ; system . out . println ( <string_literal> + ( doc <identifiersep> name == null ? <string_literal> : doc <identifiersep> name ) ) ; <ect>
mac = mac . get <identifiersep> instance ( hash . algo ) ; } catch ( no <identifiersep> such <identifiersep> algorithm <identifiersep> exception e ) { logger . error ( hmac . class , <string_literal> , e ) ; throw new error ( e ) ; } try { mac . init ( signing <identifiersep> key ) ; <LOG> } catch ( invalid <identifiersep> key <identifiersep> exception e ) { throw new error ( e ) ; } return mac . do <identifiersep> final ( data ) ; } public static boolean verify ( hmac hash , byte [ ] key , byte [ ] data , byte [ ] mac ) { return message <identifiersep> digest . is <identifiersep> equal ( mac , mac ( hash , key , data ) ) ; } public static byte [ ] mac <identifiersep> with <identifiersep> sha256 ( byte [ ] k , byte [ ] text ) { <ect>
<comment> <LOG> long time <identifiersep> sun = benchmark ( sun <identifiersep> md ) ; system . out . println ( algo + <string_literal> + sun <identifiersep> md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + sun <identifiersep> md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; if ( time <identifiersep> sun < time <identifiersep> def ) { md = sun <identifiersep> md ; <ect>
system . out . println ( algo + <string_literal> + sun <identifiersep> md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> def + <string_literal> ) ; logger . minor ( clazz , algo + <string_literal> + sun <identifiersep> md . get <identifiersep> provider ( ) + <string_literal> + time <identifiersep> sun + <string_literal> ) ; if ( time <identifiersep> sun < time <identifiersep> def ) { md = sun <identifiersep> md ; } } } catch ( general <identifiersep> security <identifiersep> exception e ) { <LOG> <comment> <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( s [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( si [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( i <identifiersep> g [ i ] [ j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + byte <identifiersep> to <identifiersep> string ( i <identifiersep> g [ i ] [ j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t1 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t5 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t2 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t3 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t4 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } <LOG> system . out . println ( ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t6 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; system . out . println ( <string_literal> ) ; for ( i = 0 ; i < <number_literal> ; i ++ ) { for ( j = 0 ; j < <number_literal> ; j ++ ) system . out . print ( <string_literal> + int <identifiersep> to <identifiersep> string ( t7 [ i * <number_literal> + j ] ) + <string_literal> ) ; system . out . println ( ) ; } system . out . println ( ) ; <ect>
public final void initialize ( byte [ ] key ) { try { byte [ ] nkey = new byte [ keysize > > <number_literal> ] ; system . arraycopy ( key , 0 , nkey , 0 , nkey . length ) ; session <identifiersep> key = rijndael <identifiersep> algorithm . make <identifiersep> key ( nkey , blocksize / <number_literal> ) ; } catch ( invalid <identifiersep> key <identifiersep> exception e ) { <LOG> e . print <identifiersep> stack <identifiersep> trace ( ) ; } } @ override public synchronized final void encipher ( byte [ ] block , byte [ ] result ) { if ( block . length != blocksize / <number_literal> ) throw new illegal <identifiersep> argument <identifiersep> exception ( ) ; rijndael <identifiersep> algorithm . block <identifiersep> encrypt ( block , result , 0 , session <identifiersep> key , blocksize / <number_literal> ) ; <ect>
underlying <identifiersep> buffer . on <identifiersep> resume ( context ) ; try { setup ( context . get <identifiersep> persistent <identifiersep> master <identifiersep> secret ( ) , false ) ; } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; <LOG> } catch ( general <identifiersep> security <identifiersep> exception e ) { throw new resume <identifiersep> failed <identifiersep> exception ( e ) ; } } @ override public void store <identifiersep> to ( data <identifiersep> output <identifiersep> stream dos ) throws io <identifiersep> exception { dos . write <identifiersep> int ( magic ) ; dos . write <identifiersep> int ( type . bitmask ) ; <ect>
<comment> kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> ) ; kg . initialize ( this . spec ) ; key = selftest ( kg , kf , modulus <identifiersep> size ) ; } catch ( throwable e ) { <LOG> <comment> kg = key <identifiersep> pair <identifiersep> generator . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kf = key <identifiersep> factory . get <identifiersep> instance ( <string_literal> , jce <identifiersep> loader . bouncy <identifiersep> castle ) ; kg . initialize ( this . spec ) ; key = selftest ( kg , kf , modulus <identifiersep> size ) ; } try { <ect>
file <identifiersep> output <identifiersep> stream fos = new file <identifiersep> output <identifiersep> stream ( broken <identifiersep> peers <identifiersep> file ) ; fis = new file <identifiersep> input <identifiersep> stream ( peers <identifiersep> file ) ; file <identifiersep> util . copy ( fis , fos , - 1 ) ; fos . close ( ) ; fis . close ( ) ; system . err . println ( <string_literal> + broken <identifiersep> peers <identifiersep> file ) ; <LOG> } catch ( io <identifiersep> exception e ) { } } if ( ! dropped <identifiersep> old <identifiersep> peers . is <identifiersep> empty ( ) ) { try { node . client <identifiersep> core . alerts . register ( dropped <identifiersep> old <identifiersep> peers ) ; logger . error ( this , dropped <identifiersep> old <identifiersep> peers . get <identifiersep> text ( ) ) ; } catch ( throwable t ) { <ect>
add <identifiersep> peer <identifiersep> node <identifiersep> status ( pn . get <identifiersep> peer <identifiersep> node <identifiersep> status ( ) , pn , false ) ; pn . set <identifiersep> peer <identifiersep> node <identifiersep> status ( system . current <identifiersep> time <identifiersep> millis ( ) ) ; if ( ( ! ignore <identifiersep> opennet ) && pn instanceof opennet <identifiersep> peer <identifiersep> node ) { opennet <identifiersep> manager opennet = node . get <identifiersep> opennet ( ) ; if ( opennet != null ) opennet . force <identifiersep> add <identifiersep> peer ( ( opennet <identifiersep> peer <identifiersep> node ) pn , true ) ; <LOG> else { remove <identifiersep> peer ( pn ) ; return false ; } } notify <identifiersep> peer <identifiersep> status <identifiersep> change <identifiersep> listeners ( ) ; if ( ! pn . is <identifiersep> seed ( ) ) { <comment> <ect>
<comment> <LOG> if ( until > now + failure <identifiersep> table . recently <identifiersep> failed <identifiersep> time ) { until = now + failure <identifiersep> table . recently <identifiersep> failed <identifiersep> time ; } if ( ! node . failure <identifiersep> table . had <identifiersep> any <identifiersep> offers ( key ) ) { recently <identifiersep> failed . fail ( count <identifiersep> waiting , until ) ; return null ; } else { <ect>
if ( s == null ) { logger . error ( this , <string_literal> + base <identifiersep> name + <string_literal> ) ; <comment> <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { max <identifiersep> chk = null ; } } <comment> <ect>
<comment> <LOG> } catch ( pattern <identifiersep> syntax <identifiersep> exception e ) { p = null ; } } byte [ ] expected <identifiersep> hash = parse <identifiersep> expected <identifiersep> hash ( props . get <identifiersep> property ( base <identifiersep> name + <string_literal> ) , base <identifiersep> name ) ; if ( expected <identifiersep> hash == null ) { system . err . println ( <string_literal> + build + <string_literal> + base <identifiersep> name ) ; broken = true ; <ect>
long size = - 1 ; if ( s != null ) { try { size = long . parse <identifiersep> long ( s ) ; } catch ( number <identifiersep> format <identifiersep> exception e ) { size = - 1 ; } } <LOG> if ( size < 0 ) { broken = true ; continue ; } int order = 0 ; file current <identifiersep> file = null ; if ( type == dependency <identifiersep> type . classpath || type == dependency <identifiersep> type . optional <identifiersep> classpath <identifiersep> no <identifiersep> update ) { <ect>
string [ ] split = path . split ( file . path <identifiersep> separator ) ; for ( string s : split ) { file f = new file ( s ) ; if ( f . exists ( ) && f . is <identifiersep> directory ( ) ) { f = new file ( f , to <identifiersep> find ) ; if ( f . exists ( ) && f . can <identifiersep> execute ( ) ) { <LOG> if ( ! f . can <identifiersep> read ( ) ) { return false ; } if ( f . length ( ) < script <identifiersep> head . length ) { logger . error ( this , <string_literal> + to <identifiersep> find + <string_literal> + script <identifiersep> head + <string_literal> ) ; return false ; <comment> <ect>
file <identifiersep> input <identifiersep> stream fis = new file <identifiersep> input <identifiersep> stream ( f ) ; byte [ ] buf = new byte [ script <identifiersep> head . length ] ; data <identifiersep> input <identifiersep> stream dis = new data <identifiersep> input <identifiersep> stream ( fis ) ; try { dis . read ( buf ) ; return ! arrays . equals ( buf , script <identifiersep> head ) ; <LOG> } catch ( io <identifiersep> exception e ) { return false ; } finally { closer . close ( fis ) ; closer . close ( dis ) ; } } catch ( file <identifiersep> not <identifiersep> found <identifiersep> exception e ) { <ect>
if ( s == null ) { logger . error ( main <identifiersep> jar <identifiersep> dependencies . class , <string_literal> + file <identifiersep> base + <string_literal> ) ; atomic <identifiersep> deployer . cleanup ( ) ; return false ; } try { key = new freenet <identifiersep> uri ( s ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { atomic <identifiersep> deployer . cleanup ( ) ; return false ; } <comment> <ect>
if ( inner <identifiersep> deploy <identifiersep> multi <identifiersep> file <identifiersep> update ( ) ) { try { <comment> <LOG> system . err . println ( <string_literal> + restart <identifiersep> script + <string_literal> + shell + <string_literal> + name + <string_literal> + e ) ; return false ; } system . out . println ( <string_literal> + name + <string_literal> + restart <identifiersep> script + <string_literal> ) ; wrapper <identifiersep> manager . stop ( 0 ) ; return true ; } else return false ; <ect>
return true ; } else return false ; } private file find <identifiersep> shell ( ) { file f = new file ( <string_literal> ) ; if ( f . exists ( ) && f . can <identifiersep> execute ( ) ) return f ; f = new file ( <string_literal> ) ; <LOG> if ( f . exists ( ) && f . can <identifiersep> execute ( ) ) return f ; return null ; } static final string restart <identifiersep> script <identifiersep> name = <string_literal> ; private file create <identifiersep> restart <identifiersep> script ( ) throws io <identifiersep> exception { <comment> <ect>
if ( ! ( runsh . exists ( ) && runsh . can <identifiersep> execute ( ) ) ) { system . err . println ( <string_literal> + name ) ; return null ; } <comment> <LOG> if ( ! new file ( <string_literal> ) . exists ( ) ) { return null ; } file restart <identifiersep> freenet = new file ( restart <identifiersep> script <identifiersep> name ) ; restart <identifiersep> freenet . delete ( ) ; file <identifiersep> bucket fb = new file <identifiersep> bucket ( restart <identifiersep> freenet , false , true , false , false ) ; output <identifiersep> stream os = null ; <ect>
<comment> if ( update <identifiersep> uri . equals <identifiersep> keypair ( transition <identifiersep> main <identifiersep> jar <identifiersep> uri ) && ! jvm <identifiersep> version . needs <identifiersep> legacy <identifiersep> updater ( ) ) { try { updater <identifiersep> config . set ( <string_literal> , update <identifiersep> uri ) ; } catch ( node <identifiersep> need <identifiersep> restart <identifiersep> exception e ) { <LOG> <comment> <ect>
node . client <identifiersep> core . client <identifiersep> context . start ( get ) ; } catch ( persistence <identifiersep> disabled <identifiersep> exception e ) { <comment> <LOG> public void on <identifiersep> failure ( fetch <identifiersep> exception e , client <identifiersep> getter state ) { } @ override public void on <identifiersep> success ( fetch <identifiersep> result result , client <identifiersep> getter state ) { file temp ; file <identifiersep> output <identifiersep> stream fos = null ; try { <ect>
} else { <comment> <LOG> <comment> <ect>
was <identifiersep> fetching <identifiersep> uom = fetching <identifiersep> uom ; fetching <identifiersep> uom = true ; } if ( ! was <identifiersep> fetching <identifiersep> uom ) this . update <identifiersep> manager . on <identifiersep> start <identifiersep> fetching <identifiersep> uom ( ) ; message msg = dmt . create <identifiersep> uom <identifiersep> request <identifiersep> main <identifiersep> jar ( update <identifiersep> manager . node . random . next <identifiersep> long ( ) ) ; <LOG> try { source . send <identifiersep> async ( msg , new async <identifiersep> message <identifiersep> callback ( ) { @ override public void acknowledged ( ) { <comment> <ect>
data . close ( ) ; return true ; } final runnable r = new runnable ( ) { @ override public void run ( ) { try { <LOG> if ( ! bt . send ( ) ) else logger . normal ( this , <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) ) ; } catch ( disconnected <identifiersep> exception e ) { <comment> <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <comment> <LOG> <comment> <ect>
source . finished <identifiersep> sending <identifiersep> uom <identifiersep> jar ( false ) ; throw e ; } final runnable r = new runnable ( ) { @ override public void run ( ) { try { <LOG> if ( ! bt . send ( ) ) else logger . normal ( this , <string_literal> + name + <string_literal> + source . user <identifiersep> to <identifiersep> string ( ) ) ; raf . close ( ) ; } catch ( disconnected <identifiersep> exception e ) { <comment> <ect>
public void disconnected ( ) { <comment> <LOG> <comment> <ect>
final long length = m . get <identifiersep> long ( dmt . file <identifiersep> length ) ; string key = m . get <identifiersep> string ( dmt . main <identifiersep> jar <identifiersep> key ) ; final int version = m . get <identifiersep> int ( dmt . main <identifiersep> jar <identifiersep> version ) ; final freenet <identifiersep> uri jar <identifiersep> uri ; try { jar <identifiersep> uri = new freenet <identifiersep> uri ( key ) . set <identifiersep> suggested <identifiersep> edition ( version ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { system . err . println ( <string_literal> + version + <string_literal> + e + <string_literal> + key ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; cancel <identifiersep> send ( source , uid ) ; synchronized ( this ) { this . nodes <identifiersep> asked <identifiersep> send <identifiersep> main <identifiersep> jar . remove ( source ) ; <ect>
chosen = choose <identifiersep> random <identifiersep> peer ( uom <identifiersep> peers ) ; if ( chosen != null ) break ; if ( try <identifiersep> everything ) { logger . minor ( this , <string_literal> + save <identifiersep> to ) ; return false ; } synchronized ( this ) { <LOG> if ( peers <identifiersep> failed . size ( ) != 0 ) { peers <identifiersep> failed . clear ( ) ; try <identifiersep> everything = true ; } } if ( ! try <identifiersep> everything ) { logger . minor ( this , <string_literal> + save <identifiersep> to ) ; return false ; <ect>
synchronized ( update <identifiersep> over <identifiersep> mandatory <identifiersep> manager . this ) { dependency <identifiersep> fetchers . remove ( expected <identifiersep> hash <identifiersep> buffer ) ; } cb . on <identifiersep> success ( ) ; } else { synchronized ( uom <identifiersep> dependency <identifiersep> fetcher . this ) { if ( completed ) return ; } <LOG> failed = true ; } peer <identifiersep> maybe <identifiersep> free <identifiersep> all <identifiersep> slots ( fetch <identifiersep> from ) ; } else { synchronized ( uom <identifiersep> dependency <identifiersep> fetcher . this ) { if ( completed ) return ; } failed = true ; <ect>
} else { synchronized ( uom <identifiersep> dependency <identifiersep> fetcher . this ) { if ( completed ) return ; } failed = true ; system . err . println ( <string_literal> + save <identifiersep> to + <string_literal> + fetch <identifiersep> from + <string_literal> ) ; <comment> <LOG> } else { failed = true ; } } catch ( not <identifiersep> connected <identifiersep> exception e ) { <comment> <ect>
bucket to <identifiersep> free = result . as <identifiersep> bucket ( ) ; if ( to <identifiersep> free != null ) to <identifiersep> free . free ( ) ; } return ; } if ( result == null || result . as <identifiersep> bucket ( ) == null || result . as <identifiersep> bucket ( ) . size ( ) == 0 ) { temp <identifiersep> blob <identifiersep> file . delete ( ) ; <LOG> logger . error ( this , <string_literal> + available <identifiersep> version ) ; <comment> <ect>
if ( blob <identifiersep> file . exists ( ) && temp <identifiersep> blob <identifiersep> file . exists ( ) && blob <identifiersep> file . length ( ) == temp <identifiersep> blob <identifiersep> file . length ( ) ) logger . minor ( this , <string_literal> + temp <identifiersep> blob <identifiersep> file + <string_literal> + blob <identifiersep> file + <string_literal> + fetched <identifiersep> version + <string_literal> ) ; else { logger . error ( this , <string_literal> + temp <identifiersep> blob <identifiersep> file + <string_literal> + blob <identifiersep> file + <string_literal> ) ; blob <identifiersep> file = null ; } } <LOG> this . fetched <identifiersep> version = fetched <identifiersep> version ; if ( fetched <identifiersep> version > current <identifiersep> version ) logger . normal ( this , <string_literal> + fetched <identifiersep> version + <string_literal> ) ; maybe <identifiersep> parse <identifiersep> manifest ( result , fetched <identifiersep> version ) ; this . cg = null ; } process <identifiersep> success ( fetched <identifiersep> version , result , blob <identifiersep> file ) ; <ect>
while ( ( line = br . read <identifiersep> line ( ) ) != null ) { parse <identifiersep> manifest <identifiersep> line ( line ) ; } } else { zis . close <identifiersep> entry ( ) ; } } } finally { closer . close ( zis ) ; } <LOG> } catch ( io <identifiersep> exception e ) { } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; } finally { closer . close ( is ) ; } } static final string dependencies <identifiersep> file = <string_literal> ; <ect>
byte [ ] outer <identifiersep> key = md . digest ( ) ; block <identifiersep> cipher cipher ; try { cipher = new rijndael ( <number_literal> , <number_literal> ) ; } catch ( unsupported <identifiersep> cipher <identifiersep> exception e ) { <comment> <LOG> throw new error ( e ) ; } cipher . initialize ( outer <identifiersep> key ) ; pcfb <identifiersep> mode pcfb = pcfb <identifiersep> mode . create ( cipher , iv ) ; pcfb . block <identifiersep> decipher ( data <identifiersep> and <identifiersep> hash , 0 , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <ect>
<comment> <LOG> byte [ ] hash = arrays . copy <identifiersep> of <identifiersep> range ( data <identifiersep> and <identifiersep> hash , data . length , data <identifiersep> and <identifiersep> hash . length ) ; <comment> <ect>
<comment> <LOG> byte [ ] check <identifiersep> hash = md . digest ( data ) ; if ( ! fields . byte <identifiersep> array <identifiersep> equal ( check <identifiersep> hash , hash , 0 , 0 , old <identifiersep> hash <identifiersep> length ) ) { clear ( data ) ; clear ( hash ) ; throw new master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception ( ) ; } <comment> <ect>
next <identifiersep> peer } private static final long timeout <identifiersep> after <identifiersep> acceptedrejected <identifiersep> timeout = seconds . to <identifiersep> millis ( <number_literal> ) ; @ override protected void handle <identifiersep> accepted <identifiersep> rejected <identifiersep> timeout ( final peer <identifiersep> node next , final uid <identifiersep> tag tag ) { <comment> <LOG> <comment> <ect>
next . send <identifiersep> async ( dmt . create <identifiersep> fnp <identifiersep> data <identifiersep> insert <identifiersep> rejected ( uid , dmt . data <identifiersep> insert <identifiersep> rejected <identifiersep> timeout <identifiersep> waiting <identifiersep> for <identifiersep> accepted ) , new async <identifiersep> message <identifiersep> callback ( ) { @ override public void sent ( ) { <comment> <LOG> public void acknowledged ( ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void disconnected ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ssk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; <ect>
next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override public void disconnected ( ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + ssk <identifiersep> insert <identifiersep> sender . this ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } @ override <LOG> public void fatal <identifiersep> error ( ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } , ssk <identifiersep> insert <identifiersep> sender . this ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( tag , false ) ; } } } @ override <ect>
if ( is <identifiersep> ssk && msg . get <identifiersep> spec ( ) == dmt . fnpssk <identifiersep> data <identifiersep> found <identifiersep> headers ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + uid ) ; waiter . headers = ( ( short <identifiersep> buffer ) msg . get <identifiersep> object ( dmt . block <identifiersep> headers ) ) . get <identifiersep> data ( ) ; if ( pub <identifiersep> key != null && waiter . ssk <identifiersep> data != null ) { finish <identifiersep> ssk ( source , was <identifiersep> fork , waiter . headers , waiter . ssk <identifiersep> data ) ; return do . finished ; } <LOG> return do . wait ; } int t = time <identifiersep> since <identifiersep> sent ( ) ; node . failure <identifiersep> table . on <identifiersep> failed ( key , source , htl , t , t ) ; source . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return do . next <identifiersep> peer ; } <comment> <ect>
pub <identifiersep> key = null ; logger . error ( this , <string_literal> + source + <string_literal> + uid + <string_literal> + e . get <identifiersep> message ( ) + ' ) ' , e ) ; int t = time <identifiersep> since <identifiersep> sent ( ) ; node . failure <identifiersep> table . on <identifiersep> failed ( key , next , htl , t , t ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return false ; <comment> <LOG> } catch ( crypt <identifiersep> format <identifiersep> exception e ) { int t = time <identifiersep> since <identifiersep> sent ( ) ; node . failure <identifiersep> table . on <identifiersep> failed ( key , next , htl , t , t ) ; next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; return false ; <comment> <ect>
} else { <comment> <LOG> } catch ( throwable t ) { if ( ! was <identifiersep> fork ) finish ( internal <identifiersep> error , next , true ) ; } finally { if ( was <identifiersep> fork ) next . no <identifiersep> longer <identifiersep> routing <identifiersep> to ( orig <identifiersep> tag , false ) ; <ect>
if ( message <identifiersep> queue . must <identifiersep> send <identifiersep> now ( now ) || message <identifiersep> queue . must <identifiersep> send <identifiersep> size ( packet . get <identifiersep> length ( ) , max <identifiersep> packet <identifiersep> size ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; must <identifiersep> send = true ; } } if ( ( ! must <identifiersep> send ) && num <identifiersep> acks > 0 ) { int max <identifiersep> send <identifiersep> buffer <identifiersep> size = max <identifiersep> send <identifiersep> buffer <identifiersep> size ( ) ; synchronized ( send <identifiersep> buffer <identifiersep> lock ) { <LOG> if ( send <identifiersep> buffer <identifiersep> used > max <identifiersep> send <identifiersep> buffer <identifiersep> size / <number_literal> ) { must <identifiersep> send = true ; } } } boolean checked <identifiersep> can <identifiersep> send = false ; boolean cant <identifiersep> send = false ; boolean must <identifiersep> send <identifiersep> keepalive = false ; if ( do <identifiersep> keepalives ) { <ect>
logger . error ( this , <string_literal> ) ; if ( ! was <identifiersep> generated <identifiersep> ping ) { message <identifiersep> queue . pushfront <identifiersep> prioritized <identifiersep> message <identifiersep> item ( item ) ; <comment> <LOG> break fragments ; } message <identifiersep> wrapper wrapper = new message <identifiersep> wrapper ( item , message <identifiersep> id ) ; message <identifiersep> fragment frag = wrapper . get <identifiersep> message <identifiersep> fragment ( max <identifiersep> packet <identifiersep> size - packet . get <identifiersep> length ( ) ) ; if ( frag == null ) { message <identifiersep> queue . pushfront <identifiersep> prioritized <identifiersep> message <identifiersep> item ( item ) ; break prio ; <ect>
packet . add <identifiersep> lossy <identifiersep> message ( buf , max <identifiersep> packet <identifiersep> size ) ; } } if ( cant <identifiersep> send ) break ; } } } if ( packet . get <identifiersep> length ( ) == <number_literal> ) return null ; int seq <identifiersep> num = key <identifiersep> context . allocate <identifiersep> sequence <identifiersep> number ( pn ) ; if ( seq <identifiersep> num == - 1 ) return null ; packet . set <identifiersep> sequence <identifiersep> number ( seq <identifiersep> num ) ; <LOG> if ( log <identifiersep> debug && ack <identifiersep> only ) { } else if ( log <identifiersep> debug && ! ack <identifiersep> only ) { logger . debug ( this , <string_literal> + packet . get <identifiersep> length ( ) + <string_literal> + this ) ; } if ( packet . get <identifiersep> fragments ( ) . size ( ) > 0 ) { key <identifiersep> context . sent ( sent <identifiersep> packet , seq <identifiersep> num , packet . get <identifiersep> length ( ) ) ; } return packet ; <ect>
node <identifiersep> l10n . get <identifiersep> base ( ) . add <identifiersep> l10n <identifiersep> substitution ( div , <string_literal> + key <identifiersep> suffix , new string [ ] { <string_literal> , <string_literal> , <string_literal> , <string_literal> } , new html <identifiersep> node [ ] { html <identifiersep> node . text ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) , html <identifiersep> node . text ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 1 ] ) ) , html <identifiersep> node . link ( url ) , html <identifiersep> node . link ( connectivity <identifiersep> toadlet . path ) } ) ; <LOG> } else { } if ( inner <identifiersep> get <identifiersep> priority <identifiersep> class ( ) == user <identifiersep> alert . error ) { div . add <identifiersep> child ( <string_literal> , <string_literal> + l10n ( <string_literal> ) ) ; } return div ; } @ override public short get <identifiersep> priority <identifiersep> class ( ) { <ect>
if ( ports <identifiersep> not <identifiersep> forwarded . length == 1 ) { return l10n ( <string_literal> + key <identifiersep> suffix , new string [ ] { <string_literal> , <string_literal> , <string_literal> } , new string [ ] { integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) , <string_literal> , <string_literal> + url + <string_literal> } ) ; } else if ( ports <identifiersep> not <identifiersep> forwarded . length == <number_literal> ) { return l10n ( <string_literal> + key <identifiersep> suffix , new string [ ] { <string_literal> , <string_literal> , <string_literal> , <string_literal> } , new string [ ] { integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 0 ] ) ) , integer . to <identifiersep> string ( math . abs ( ports <identifiersep> not <identifiersep> forwarded [ 1 ] ) ) , <string_literal> , <string_literal> + url + <string_literal> } ) ; <LOG> } else { return <string_literal> ; } } @ override public string get <identifiersep> title ( ) { return get <identifiersep> short <identifiersep> text ( ) ; } @ override <ect>
<comment> private void try <identifiersep> maybe <identifiersep> run ( ) { try { maybe <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { } node . get <identifiersep> ticker ( ) . queue <identifiersep> timed <identifiersep> job ( new runnable ( ) { @ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; try <identifiersep> maybe <identifiersep> run ( ) ; <ect>
logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; <LOG> } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } if ( n . peers . add <identifiersep> peer ( pn ) ) system . out . println ( <string_literal> + pn ) ; n . peers . write <identifiersep> peers <identifiersep> darknet <identifiersep> urgent ( ) ; <ect>
logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e1 ) { system . err . println ( <string_literal> + e1 ) ; logger . error ( this , <string_literal> + e1 , e1 ) ; return ; } <LOG> if ( n . peers . add <identifiersep> peer ( pn ) ) n . peers . write <identifiersep> peers <identifiersep> darknet <identifiersep> urgent ( ) ; } <comment> <ect>
node <identifiersep> ip <identifiersep> and <identifiersep> port = peer . to <identifiersep> string ( ) ; } string name = pn . my <identifiersep> name ; string identity = pn . get <identifiersep> identity <identifiersep> string ( ) ; if ( identity . equals ( node <identifiersep> identifier ) || node <identifiersep> ip <identifiersep> and <identifiersep> port . equals ( node <identifiersep> identifier ) || name . equals ( node <identifiersep> identifier ) ) { n . remove <identifiersep> peer <identifiersep> connection ( pn ) ; <LOG> return true ; } } return false ; } private string sanitize ( string fnam ) { if ( fnam == null ) return <string_literal> ; string <identifiersep> builder sb = new string <identifiersep> builder ( fnam . length ( ) ) ; for ( int i = 0 ; i < fnam . length ( ) ; i ++ ) { <ect>
byte [ ] rehash = sha256 . digest ( his <identifiersep> buf ) ; if ( ! java . util . arrays . equals ( rehash , his <identifiersep> hash ) ) { logger . error ( this , <string_literal> + uid ) ; return ; } <comment> <LOG> if ( his <identifiersep> buf <identifiersep> long . length < <number_literal> ) { return ; } long his <identifiersep> random = his <identifiersep> buf <identifiersep> long [ 0 ] ; double his <identifiersep> loc = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ 1 ] ) ; if ( ! location . is <identifiersep> valid ( his <identifiersep> loc ) ) { logger . error ( this , <string_literal> + his <identifiersep> loc + <string_literal> + uid ) ; <ect>
logger . error ( this , <string_literal> + his <identifiersep> loc + <string_literal> + uid ) ; return ; } register <identifiersep> known <identifiersep> location ( his <identifiersep> loc ) ; double [ ] his <identifiersep> friend <identifiersep> locs = new double [ his <identifiersep> buf <identifiersep> long . length - <number_literal> ] ; for ( int i = 0 ; i < his <identifiersep> friend <identifiersep> locs . length ; i ++ ) { his <identifiersep> friend <identifiersep> locs [ i ] = double . long <identifiersep> bits <identifiersep> to <identifiersep> double ( his <identifiersep> buf <identifiersep> long [ i + <number_literal> ] ) ; <LOG> if ( ! location . is <identifiersep> valid ( his <identifiersep> friend <identifiersep> locs [ i ] ) ) { return ; } register <identifiersep> location <identifiersep> link ( his <identifiersep> loc , his <identifiersep> friend <identifiersep> locs [ i ] ) ; register <identifiersep> known <identifiersep> location ( his <identifiersep> friend <identifiersep> locs [ i ] ) ; } number <identifiersep> of <identifiersep> remote <identifiersep> peer <identifiersep> locations <identifiersep> seen <identifiersep> in <identifiersep> swaps += his <identifiersep> friend <identifiersep> locs . length ; boolean should <identifiersep> swap = should <identifiersep> swap ( my <identifiersep> loc , friend <identifiersep> locs , his <identifiersep> loc , his <identifiersep> friend <identifiersep> locs , random ^ his <identifiersep> random ) ; <ect>
buffered <identifiersep> writer bw = new buffered <identifiersep> writer ( new output <identifiersep> stream <identifiersep> writer ( os , <string_literal> ) ) ; date <identifiersep> format df = date <identifiersep> format . get <identifiersep> date <identifiersep> time <identifiersep> instance ( ) ; df . set <identifiersep> time <identifiersep> zone ( time <identifiersep> zone . get <identifiersep> time <identifiersep> zone ( <string_literal> ) ) ; bw . write ( <string_literal> + df . format ( new date ( ) ) + <string_literal> + get <identifiersep> location ( ) + ( random <identifiersep> reset ? <string_literal> + ( from <identifiersep> dup <identifiersep> location ? <string_literal> : <string_literal> ) + <string_literal> : <string_literal> ) + ' \\ n' ) ; bw . close ( ) ; os = null ; <LOG> } catch ( io <identifiersep> exception e ) { } finally { closer . close ( os ) ; } } } , <string_literal> ) ; } private boolean locked ; public static int swaps ; <ect>
<comment> public void on <identifiersep> final <identifiersep> failure ( key key , peer <identifiersep> node routed <identifiersep> to , short htl , short orig <identifiersep> htl , long rf <identifiersep> timeout , long ft <identifiersep> timeout , peer <identifiersep> node requestor ) { if ( ft <identifiersep> timeout < - 1 || ft <identifiersep> timeout > reject <identifiersep> time ) { <LOG> <comment> <ect>
try { inner <identifiersep> send <identifiersep> offered <identifiersep> key ( key , is <identifiersep> ssk , need <identifiersep> pub <identifiersep> key , uid , source , tag , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { tag . unlock <identifiersep> handler ( ) ; <comment> <LOG> tag . unlock <identifiersep> handler ( ) ; } } } , <string_literal> ) ; } <comment> <ect>
@ override public void run ( ) { freenet . support . logger . os <identifiersep> thread . log <identifiersep> pid ( this ) ; while ( true ) { try { real <identifiersep> run ( ) ; <LOG> } catch ( throwable t ) { } } } private class sender <identifiersep> thread implements runnable { private final chosen <identifiersep> block req ; private final key key ; public sender <identifiersep> thread ( chosen <identifiersep> block req , key key ) { this . req = req ; <ect>
lm . set <identifiersep> location ( loc <identifiersep> d ) ; my <identifiersep> name = fs . get ( <string_literal> ) ; if ( my <identifiersep> name == null ) { my <identifiersep> name = new <identifiersep> name ( ) ; } string ver <identifiersep> string = fs . get ( <string_literal> ) ; if ( ver <identifiersep> string == null ) { <LOG> logger . error ( this , <string_literal> ) ; } else { last <identifiersep> version = version . get <identifiersep> arbitrary <identifiersep> build <identifiersep> number ( ver <identifiersep> string , - 1 ) ; } } public void make <identifiersep> store ( string val ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception { string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; if ( val . equals ( <string_literal> ) ) { <ect>
public void make <identifiersep> store ( string val ) throws invalid <identifiersep> config <identifiersep> value <identifiersep> exception { string suffix = get <identifiersep> store <identifiersep> suffix ( ) ; if ( val . equals ( <string_literal> ) ) { try { init <identifiersep> salt <identifiersep> hash <identifiersep> fs ( suffix , true , null ) ; } catch ( node <identifiersep> init <identifiersep> exception e ) { <LOG> logger . error ( this , <string_literal> , e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e4 ) { system . err . println ( <string_literal> + e4 ) ; e4 . print <identifiersep> stack <identifiersep> trace ( ) ; throw new node <identifiersep> init <identifiersep> exception ( node <identifiersep> init <identifiersep> exception . exit <identifiersep> could <identifiersep> not <identifiersep> start <identifiersep> fproxy , <string_literal> + e4 ) ; } catch ( invalid <identifiersep> config <identifiersep> value <identifiersep> exception e4 ) { system . err . println ( <string_literal> + e4 ) ; <ect>
<comment> <LOG> logger . normal ( this , <string_literal> ) ; } <comment> private void delete <identifiersep> old <identifiersep> bdb <identifiersep> index <identifiersep> store <identifiersep> files ( ) { file db <identifiersep> dir = store <identifiersep> dir . file ( <string_literal> + get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) ) ; file <identifiersep> util . remove <identifiersep> all ( db <identifiersep> dir ) ; file dir = store <identifiersep> dir . dir ( ) ; <ect>
string name = f . get <identifiersep> name ( ) ; if ( f . is <identifiersep> file ( ) && name . to <identifiersep> lower <identifiersep> case ( ) . matches ( <string_literal> ) ) { system . out . println ( <string_literal> + f + <string_literal> ) ; try { file <identifiersep> util . secure <identifiersep> delete ( f ) ; <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; } } } } private void fix <identifiersep> certs <identifiersep> files ( ) { <comment> <ect>
plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https . write <identifiersep> certs <identifiersep> to ( tmp <identifiersep> file ) ; if ( file <identifiersep> util . rename <identifiersep> to ( tmp <identifiersep> file , certs ) ) { long new <identifiersep> length = certs . length ( ) ; if ( new <identifiersep> length != old <identifiersep> length ) system . err . println ( <string_literal> + certs + <string_literal> ) ; } else { <LOG> if ( certs . length ( ) != tmp <identifiersep> file . length ( ) ) { file manual = new file ( plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https . certfile <identifiersep> old + <string_literal> ) ; manual . delete ( ) ; if ( tmp <identifiersep> file . rename <identifiersep> to ( manual ) ) system . err . println ( <string_literal> + certs + <string_literal> + manual + <string_literal> ) ; else <ect>
ssk <identifiersep> datastore . put ( block , overwrite , ! can <identifiersep> write <identifiersep> datastore ) ; node <identifiersep> stats . avg <identifiersep> store <identifiersep> ssk <identifiersep> location . report ( loc ) ; } ssk <identifiersep> datacache . put ( block , overwrite , ! can <identifiersep> write <identifiersep> datastore ) ; node <identifiersep> stats . avg <identifiersep> cache <identifiersep> ssk <identifiersep> location . report ( loc ) ; } if ( can <identifiersep> write <identifiersep> datastore || for <identifiersep> ulpr || use <identifiersep> slashdot <identifiersep> cache ) failure <identifiersep> table . on <identifiersep> found ( block ) ; <LOG> } catch ( io <identifiersep> exception e ) { } catch ( key <identifiersep> collision <identifiersep> exception e ) { throw e ; } catch ( throwable t ) { system . err . println ( t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
private client <identifiersep> key <identifiersep> block fetch ( client <identifiersep> chk client <identifiersep> chk , boolean can <identifiersep> read <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> client <identifiersep> cache , boolean can <identifiersep> write <identifiersep> datastore ) throws chk <identifiersep> verify <identifiersep> exception { chk <identifiersep> block block = fetch ( client <identifiersep> chk . get <identifiersep> node <identifiersep> chk ( ) , false , can <identifiersep> read <identifiersep> client <identifiersep> cache , can <identifiersep> write <identifiersep> client <identifiersep> cache , can <identifiersep> write <identifiersep> datastore , false , null ) ; if ( block == null ) return null ; return new client <identifiersep> chk <identifiersep> block ( block , client <identifiersep> chk ) ; } public void exit ( int reason ) { try { <LOG> this . park ( ) ; system . out . println ( reason ) ; } finally { system . exit ( reason ) ; } } public void exit ( string reason ) { try { <ect>
is <identifiersep> stopping = true ; } try { message msg = dmt . create <identifiersep> fnp <identifiersep> disconnect ( false , false , - 1 , new short <identifiersep> buffer ( new byte [ 0 ] ) ) ; peers . local <identifiersep> broadcast ( msg , true , false , peers . ctr <identifiersep> disconn ) ; } catch ( throwable t ) { try { <LOG> <comment> <ect>
non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . remove ( list ) ; item . set <identifiersep> deadline ( list . time <identifiersep> last <identifiersep> sent + timeout ) ; list . time <identifiersep> last <identifiersep> sent = now ; if ( ! list . items . is <identifiersep> empty ( ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + list + <string_literal> ) ; add <identifiersep> to <identifiersep> non <identifiersep> empty <identifiersep> backward ( list ) ; <LOG> } else { add <identifiersep> to <identifiersep> empty <identifiersep> backward ( list ) ; } if ( prev == null ) list = non <identifiersep> empty <identifiersep> items <identifiersep> with <identifiersep> id . head ( ) ; else list = prev . get <identifiersep> next ( ) ; <ect>
message <identifiersep> item add <identifiersep> priority <identifiersep> messages ( long now , mutable <identifiersep> boolean add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> rt , mutable <identifiersep> boolean add <identifiersep> peer <identifiersep> load <identifiersep> stats <identifiersep> bulk ) { <comment> <LOG> if ( non <identifiersep> empty + empty < by <identifiersep> id ) { } else if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + non <identifiersep> empty + <string_literal> + empty + <string_literal> + by <identifiersep> id + <string_literal> + this ) ; } if ( round <identifiersep> robin <identifiersep> between <identifiersep> ui <identifiersep> ds ) move <identifiersep> to <identifiersep> urgent ( now ) ; clear <identifiersep> old <identifiersep> non <identifiersep> urgent ( now ) ; <ect>
if ( empty <identifiersep> items <identifiersep> with <identifiersep> id == null ) return ; while ( true ) { if ( log <identifiersep> minor ) check <identifiersep> order ( ) ; if ( empty <identifiersep> items <identifiersep> with <identifiersep> id . is <identifiersep> empty ( ) ) return ; items list = empty <identifiersep> items <identifiersep> with <identifiersep> id . head ( ) ; if ( ! list . items . is <identifiersep> empty ( ) ) { <LOG> <comment> <ect>
if ( val < 0 ) throw new invalid <identifiersep> config <identifiersep> value <identifiersep> exception ( l10n ( <string_literal> ) ) ; min <identifiersep> disk <identifiersep> free <identifiersep> short <identifiersep> term = val ; } temp <identifiersep> bucket <identifiersep> factory . set <identifiersep> min <identifiersep> disk <identifiersep> space ( val ) ; } } , true ) ; min <identifiersep> disk <identifiersep> free <identifiersep> short <identifiersep> term = node <identifiersep> config . get <identifiersep> long ( <string_literal> ) ; <comment> <LOG> boolean late <identifiersep> init <identifiersep> database ( database <identifiersep> key database <identifiersep> key ) throws node <identifiersep> init <identifiersep> exception { try { init <identifiersep> storage ( database <identifiersep> key ) ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { logger . error ( this , <string_literal> + ( database <identifiersep> key != null ) ) ; return true ; <ect>
try { init <identifiersep> storage ( database <identifiersep> key ) ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { logger . error ( this , <string_literal> + ( database <identifiersep> key != null ) ) ; return true ; } <comment> <LOG> fcp <identifiersep> server . load ( ) ; return true ; } <comment> <ect>
public void run ( ) { logger . normal ( this , <string_literal> ) ; if ( node . get <identifiersep> database <identifiersep> key ( ) != null ) { try { finish <identifiersep> init <identifiersep> storage ( ) ; } catch ( throwable t ) { <LOG> logger . error ( this , <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; <comment> <ect>
public boolean shall <identifiersep> we <identifiersep> route <identifiersep> according <identifiersep> to <identifiersep> our <identifiersep> peers <identifiersep> location ( int htl ) { return node . shall <identifiersep> we <identifiersep> route <identifiersep> according <identifiersep> to <identifiersep> our <identifiersep> peers <identifiersep> location ( htl ) ; } @ override boolean dont <identifiersep> keep <identifiersep> full <identifiersep> field <identifiersep> set ( ) { return true ; } public link <identifiersep> length <identifiersep> class link <identifiersep> length <identifiersep> class ( ) { <LOG> if ( ! location . is <identifiersep> valid ( get <identifiersep> location ( ) ) ) { return link <identifiersep> length <identifiersep> class . short ; <comment> <ect>
} else { value = ( ( plaintext [ offset ] & 0x <identifiersep> ff ) < < <number_literal> ) | ( plaintext [ offset + 1 ] & 0x <identifiersep> ff ) ; offset += <number_literal> ; } if ( first <identifiersep> fragment ) { message <identifiersep> length = value ; <LOG> if ( message <identifiersep> length == fragment <identifiersep> length ) { } } else { fragment <identifiersep> offset = value ; } } else { message <identifiersep> length = fragment <identifiersep> length ; } if ( ( offset + fragment <identifiersep> length ) > plaintext . length ) { <ect>
int size = fragments . size ( ) ; int biggest = 0 ; for ( message <identifiersep> fragment frag : fragments ) { total <identifiersep> message <identifiersep> data += frag . fragment <identifiersep> length ; size ++ ; if ( biggest < frag . message <identifiersep> length ) biggest = frag . message <identifiersep> length ; } <LOG> int overhead = total <identifiersep> packet <identifiersep> length - total <identifiersep> message <identifiersep> data ; for ( message <identifiersep> fragment frag : fragments ) { <comment> <ect>
static final int max <identifiersep> pings = <number_literal> ; static final boolean enable <identifiersep> swapping = false ; static final boolean enable <identifiersep> swap <identifiersep> queueing = false ; static final boolean enable <identifiersep> foaf = true ; public static int darknet <identifiersep> port <identifiersep> base = real <identifiersep> node <identifiersep> request <identifiersep> insert <identifiersep> test . darknet <identifiersep> port <identifiersep> end ; public static final int darknet <identifiersep> port <identifiersep> end = darknet <identifiersep> port <identifiersep> base + number <identifiersep> of <identifiersep> nodes ; <LOG> public static void main ( string [ ] args ) throws exception { system . out . println ( ) ; string dir = <string_literal> ; file wd = new file ( dir ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { system . err . println ( <string_literal> ) ; <ect>
<comment> <LOG> for ( int i = 0 ; i < number <identifiersep> of <identifiersep> nodes ; i ++ ) { nodes [ i ] = node <identifiersep> starter . create <identifiersep> test <identifiersep> node ( darknet <identifiersep> port <identifiersep> base + i , 0 , dir , true , max <identifiersep> htl , 0 <comment> , random , executor , <number_literal> * number <identifiersep> of <identifiersep> nodes , <number_literal> , true , enable <identifiersep> swapping , false , false , false , enable <identifiersep> swap <identifiersep> queueing , true , 0 , enable <identifiersep> foaf , false , true , false , null ) ; logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + i ) ; } logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + number <identifiersep> of <identifiersep> nodes + <string_literal> ) ; <comment> <ect>
for ( int total = 0 ; total < max <identifiersep> tests ; total ++ ) { cycle <identifiersep> number ++ ; try { thread . sleep ( sleep <identifiersep> time ) ; } catch ( interrupted <identifiersep> exception e ) { <comment> <LOG> for ( int i = 0 ; i < nodes . length ; i ++ ) { } int new <identifiersep> swaps = location <identifiersep> manager . swaps ; int total <identifiersep> started = location <identifiersep> manager . started <identifiersep> swaps ; int no <identifiersep> swaps = location <identifiersep> manager . no <identifiersep> swaps ; system . err . println ( <string_literal> + ( new <identifiersep> swaps - last <identifiersep> swaps ) ) ; system . err . println ( <string_literal> + total <identifiersep> started * <number_literal> + <string_literal> + new <identifiersep> swaps + <string_literal> + no <identifiersep> swaps + <ect>
for ( int i = 0 ; i < mhks . length ; i ++ ) mhks [ i ] = random <identifiersep> data ( node ) ; client = node . client <identifiersep> core . make <identifiersep> client ( ( short ) 0 , false , false ) ; system . err . println ( <string_literal> ) ; insert <identifiersep> block block = new insert <identifiersep> block ( single , new client <identifiersep> metadata ( ) , freenet <identifiersep> uri . empty <identifiersep> chk <identifiersep> uri ) ; freenet <identifiersep> uri uri = null ; int successes = 0 ; <LOG> for ( int i = 0 ; i < <number_literal> ; i ++ ) { try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri this <identifiersep> uri = client . insert ( block , false , null ) ; if ( uri != null && ! this <identifiersep> uri . equals ( uri ) ) { system . err . println ( <string_literal> + i + <string_literal> + this <identifiersep> uri + <string_literal> + uri ) ; <ect>
t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; freenet <identifiersep> uri this <identifiersep> uri = client . insert ( block , false , null ) ; if ( uri != null && ! this <identifiersep> uri . equals ( uri ) ) { system . err . println ( <string_literal> + i + <string_literal> + this <identifiersep> uri + <string_literal> + uri ) ; system . exit ( exit <identifiersep> different <identifiersep> uri ) ; } uri = this <identifiersep> uri ; <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; csv <identifiersep> line . add ( uri . to <identifiersep> ascii <identifiersep> string ( ) ) ; successes ++ ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
successes ++ ; } catch ( insert <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; csv <identifiersep> line . add ( insert <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; csv <identifiersep> line . add ( <string_literal> ) ; system . out . println ( <string_literal> + e + <string_literal> + i + <string_literal> ) ; } } <LOG> if ( successes == <number_literal> ) else if ( successes != 0 ) system . err . println ( <string_literal> + successes ) ; else system . err . println ( <string_literal> + successes ) ; uri = null ; <ect>
system . out . println ( <string_literal> + i + <string_literal> + ( t2 - t1 ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <LOG> csv <identifiersep> line . add ( fetch <identifiersep> exception . get <identifiersep> short <identifiersep> message ( e . get <identifiersep> mode ( ) ) ) ; } } } } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; exit <identifiersep> code = exit <identifiersep> threw <identifiersep> something ; } finally { try { <ect>
system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; if ( args . length == <number_literal> && ( args [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) || args [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) || args [ 1 ] . equals <identifiersep> ignore <identifiersep> case ( <string_literal> ) ) ) { try { dump <identifiersep> stats ( uid ) ; <LOG> } catch ( io <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( 1 ) ; } catch ( parse <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
system . exit ( 1 ) ; } catch ( parse <identifiersep> exception e ) { system . err . println ( <string_literal> + e ) ; e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( <number_literal> ) ; } system . exit ( 0 ) ; } <LOG> list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( <number_literal> + <number_literal> * max <identifiersep> n ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; system . out . println ( <string_literal> + version . build <identifiersep> number ( ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; <ect>
static void connect ( node a , node b ) { try { a . connect ( b , trust , visibility ) ; b . connect ( a , trust , visibility ) ; } catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; <LOG> } catch ( peer <identifiersep> parse <identifiersep> exception e ) { } catch ( freenet . io . comm . reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } } static double distance ( node a , node b ) { <ect>
} catch ( fs <identifiersep> parse <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; } catch ( freenet . io . comm . reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( real <identifiersep> node <identifiersep> test . class , <string_literal> , e ) ; <LOG> } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { } } static double distance ( node a , node b ) { double a <identifiersep> l = a . get <identifiersep> location ( ) ; double b <identifiersep> l = b . get <identifiersep> location ( ) ; return location . distance ( a <identifiersep> l , b <identifiersep> l ) ; } static string get <identifiersep> port <identifiersep> number ( peer <identifiersep> node p ) { <ect>
min <identifiersep> ping <identifiersep> time < node <identifiersep> stats . default <identifiersep> sub <identifiersep> max <identifiersep> ping <identifiersep> time && max <identifiersep> ping <identifiersep> time < node <identifiersep> stats . default <identifiersep> sub <identifiersep> max <identifiersep> ping <identifiersep> time && avg <identifiersep> ping <identifiersep> time < node <identifiersep> stats . default <identifiersep> sub <identifiersep> max <identifiersep> ping <identifiersep> time ) { system . err . println ( <string_literal> ) ; logger . normal ( real <identifiersep> node <identifiersep> test . class , <string_literal> ) ; system . err . println ( ) ; return ; } else { <LOG> long t <identifiersep> delta = ( system . current <identifiersep> time <identifiersep> millis ( ) - t <identifiersep> start ) / <number_literal> ; logger . normal ( real <identifiersep> node <identifiersep> test . class , <string_literal> + count <identifiersep> fully <identifiersep> connected + <string_literal> + nodes . length + <string_literal> + total <identifiersep> connections + <string_literal> + total <identifiersep> peers + <string_literal> + total <identifiersep> partial <identifiersep> connections + <string_literal> + total <identifiersep> compatible <identifiersep> connections + <string_literal> + total <identifiersep> backed <identifiersep> off + <string_literal> + ( int ) min <identifiersep> ping <identifiersep> time + <string_literal> + ( int ) avg <identifiersep> ping <identifiersep> time + <string_literal> + ( int ) max <identifiersep> ping <identifiersep> time + <string_literal> + t <identifiersep> delta + 's' ) ; thread . sleep ( <number_literal> ) ; } } } } <ect>
<comment> <LOG> if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } wd . mkdir ( ) ; <comment> <ect>
node <identifiersep> starter . create <identifiersep> test <identifiersep> node ( darknet <identifiersep> port <identifiersep> base + i , 0 , name , false , max <identifiersep> htl , <number_literal> <comment> , random , executor , <number_literal> * number <identifiersep> of <identifiersep> nodes , ( chk <identifiersep> block . data <identifiersep> length + chk <identifiersep> block . total <identifiersep> headers <identifiersep> length ) * <number_literal> , true , enable <identifiersep> swapping , false , enable <identifiersep> ulprs , enable <identifiersep> per <identifiersep> node <identifiersep> failure <identifiersep> tables , enable <identifiersep> swap <identifiersep> queueing , enable <identifiersep> packet <identifiersep> coalescing , <number_literal> , enable <identifiersep> foaf , false , true , false , null ) ; logger . normal ( real <identifiersep> node <identifiersep> routing <identifiersep> test . class , <string_literal> + i ) ; } <comment> <LOG> nodes [ i ] . start ( false ) ; } wait <identifiersep> for <identifiersep> all <identifiersep> connected ( nodes ) ; wait <identifiersep> for <identifiersep> ping <identifiersep> average ( 0 . <number_literal> , nodes , random , max <identifiersep> pings , <number_literal> ) ; system . out . println ( ) ; system . out . println ( <string_literal> ) ; system . out . println ( ) ; <ect>
high <identifiersep> level <identifiersep> simple <identifiersep> client [ ] clients = new high <identifiersep> level <identifiersep> simple <identifiersep> client [ nodes . length ] ; for ( int i = 0 ; i < clients . length ; i ++ ) { clients [ i ] = nodes [ i ] . client <identifiersep> core . make <identifiersep> client ( request <identifiersep> starter . immediate <identifiersep> splitfile <identifiersep> priority <identifiersep> class , false , false ) ; } <comment> <LOG> for ( int i = 0 ; i < insert <identifiersep> keys ; i ++ ) { int node1 = random . next <identifiersep> int ( number <identifiersep> of <identifiersep> nodes ) ; node random <identifiersep> node = nodes [ node1 ] ; string data <identifiersep> string = base <identifiersep> string + i ; byte [ ] data = data <identifiersep> string . get <identifiersep> bytes ( <string_literal> ) ; client <identifiersep> chk <identifiersep> block b ; <ect>
system . out . println ( <string_literal> + i ) ; continue ; } system . out . println ( <string_literal> + uri ) ; try { t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; client . fetch ( uri ) ; <LOG> t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( t2 - t1 ) ) ; } catch ( fetch <identifiersep> exception e ) { if ( e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . all <identifiersep> data <identifiersep> not <identifiersep> found && e . get <identifiersep> mode ( ) != fetch <identifiersep> exception <identifiersep> mode . data <identifiersep> not <identifiersep> found ) e . print <identifiersep> stack <identifiersep> trace ( ) ; <ect>
static final boolean enable <identifiersep> foaf = true ; private static final boolean do <identifiersep> insert <identifiersep> test = true ; static final int max <identifiersep> pings = <number_literal> ; static final int output <identifiersep> bandwidth <identifiersep> limit = 0 ; <comment> <LOG> public static void main ( string [ ] args ) throws exception { system . out . println ( ) ; string dir = <string_literal> ; file wd = new file ( dir ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { system . err . println ( <string_literal> ) ; <ect>
system . out . println ( ) ; string dir = <string_literal> ; file wd = new file ( dir ) ; if ( ! file <identifiersep> util . remove <identifiersep> all ( wd ) ) { system . err . println ( <string_literal> ) ; system . exit ( exit <identifiersep> cannot <identifiersep> delete <identifiersep> old <identifiersep> data ) ; } <LOG> if ( ! wd . mkdir ( ) ) { return ; } node <identifiersep> starter . global <identifiersep> test <identifiersep> init ( dir , false , log <identifiersep> level . error , <string_literal> , true ) ; <comment> <ect>
t . set <identifiersep> daemon ( true ) ; t . start ( ) ; } @ override public void run ( ) { synchronized ( insert <identifiersep> batch . this ) { running <identifiersep> inserts ++ ; <LOG> <comment> <ect>
private static final int test <identifiersep> size = <number_literal> * <number_literal> ; private static final int darknet <identifiersep> port1 = <number_literal> ; private static final int opennet <identifiersep> port1 = <number_literal> ; private static final int max <identifiersep> n = <number_literal> ; private static final int inserted <identifiersep> blocks = <number_literal> ; public static void main ( string [ ] args ) { <LOG> if ( args . length < 1 || args . length > <number_literal> ) { system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <ect>
if ( args . length < 1 || args . length > <number_literal> ) { system . err . println ( <string_literal> ) ; system . exit ( 1 ) ; } string uid = args [ 0 ] ; list < string > csv <identifiersep> line = new array <identifiersep> list < string > ( ) ; system . out . println ( <string_literal> + date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; <LOG> csv <identifiersep> line . add ( date <identifiersep> format . format ( today . get <identifiersep> time ( ) ) ) ; csv <identifiersep> line . add ( string . value <identifiersep> of ( version . build <identifiersep> number ( ) ) ) ; int exit <identifiersep> code = 0 ; node node = null ; node node2 = null ; file <identifiersep> input <identifiersep> stream fis = null ; <ect>
system . exit ( exit <identifiersep> failed <identifiersep> target ) ; } <comment> <LOG> } catch ( fetch <identifiersep> exception e ) { e . print <identifiersep> stack <identifiersep> trace ( ) ; system . exit ( exit <identifiersep> fetch <identifiersep> failed ) ; return ; } long end <identifiersep> fetch <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + uri + <string_literal> ) ; <ect>
system . exit ( exit <identifiersep> fetch <identifiersep> failed ) ; return ; } long end <identifiersep> fetch <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; system . out . println ( <string_literal> + ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + time <identifiersep> util . format <identifiersep> time ( end <identifiersep> fetch <identifiersep> time - start <identifiersep> fetch <identifiersep> time ) + <string_literal> + uri + <string_literal> ) ; second <identifiersep> node . park ( ) ; system . exit ( 0 ) ; <LOG> } catch ( throwable t ) { t . print <identifiersep> stack <identifiersep> trace ( ) ; try { if ( second <identifiersep> node != null ) second <identifiersep> node . park ( ) ; } catch ( throwable t1 ) { } <ect>
line <identifiersep> reading <identifiersep> input <identifiersep> stream lis = new line <identifiersep> reading <identifiersep> input <identifiersep> stream ( sock <identifiersep> is ) ; output <identifiersep> stream <identifiersep> writer osw = new output <identifiersep> stream <identifiersep> writer ( sock <identifiersep> os , <string_literal> ) ; osw . write ( <string_literal> + system . current <identifiersep> time <identifiersep> millis ( ) + <string_literal> ) ; osw . flush ( ) ; string name = lis . read <identifiersep> line ( <number_literal> , <number_literal> , true ) ; simple <identifiersep> field <identifiersep> set fs = new simple <identifiersep> field <identifiersep> set ( lis , <number_literal> , <number_literal> , true , false , true ) ; <LOG> if ( ! name . equals ( <string_literal> ) ) { system . exit ( exit <identifiersep> inserter <identifiersep> problem ) ; } system . out . println ( <string_literal> + sock ) ; osw . write ( <string_literal> + test <identifiersep> size + <string_literal> ) ; osw . flush ( ) ; input <identifiersep> stream is = new file <identifiersep> input <identifiersep> stream ( data <identifiersep> file ) ; <ect>
<comment> <LOG> if ( packet <identifiersep> type < 0 || packet <identifiersep> type > <number_literal> ) { return ; } else auth <identifiersep> handling <identifiersep> thread . execute ( new runnable ( ) { @ override public void run ( ) { if ( packet <identifiersep> type == 0 ) { <ect>
long t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; int modulus <identifiersep> length = get <identifiersep> modulus <identifiersep> length ( neg <identifiersep> type ) ; <comment> <LOG> if ( payload . length < nonce <identifiersep> size <identifiersep> hashed + modulus <identifiersep> length + <number_literal> + ( unknown <identifiersep> initiator ? node <identifiersep> crypto . identity <identifiersep> length : 0 ) ) { return ; } <comment> <ect>
try { send <identifiersep> jfk <identifiersep> message2 ( nonce <identifiersep> initiator , his <identifiersep> exponential , pn , reply <identifiersep> to , unknown <identifiersep> initiator , setup <identifiersep> type , neg <identifiersep> type ) ; } catch ( no <identifiersep> contexts <identifiersep> exception e ) { handle <identifiersep> no <identifiersep> contexts <identifiersep> exception ( e , no <identifiersep> contexts <identifiersep> exception . context . replying ) ; return ; } long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> if ( ( t2 - t1 ) > <number_literal> ) { } } private long last <identifiersep> logged <identifiersep> no <identifiersep> contexts = - 1 ; private static long log <identifiersep> no <identifiersep> contexts <identifiersep> interval = minutes . to <identifiersep> millis ( 1 ) ; private void handle <identifiersep> no <identifiersep> contexts <identifiersep> exception ( no <identifiersep> contexts <identifiersep> exception e , freenet . node . fnp <identifiersep> packet <identifiersep> mangler . no <identifiersep> contexts <identifiersep> exception . context context ) { if ( node . get <identifiersep> uptime ( ) < seconds . to <identifiersep> millis ( <number_literal> ) ) { <ect>
} catch ( peer <identifiersep> parse <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; } catch ( reference <identifiersep> signature <identifiersep> verification <identifiersep> exception e ) { logger . error ( this , <string_literal> + e + <string_literal> + from , e ) ; return null ; <LOG> } catch ( peer <identifiersep> too <identifiersep> old <identifiersep> exception e ) { return null ; } if ( seed . equals ( pn ) ) { logger . normal ( this , <string_literal> ) ; return pn ; } node . peers . add <identifiersep> peer ( seed ) ; <ect>
hash <identifiersep> length + <comment> <LOG> if ( payload . length - input <identifiersep> offset < expected <identifiersep> length + <number_literal> ) { return false ; } byte [ ] jfk <identifiersep> buffer = pn . get <identifiersep> jfk <identifiersep> buffer ( ) ; if ( jfk <identifiersep> buffer == null ) { logger . normal ( this , <string_literal> + pn ) ; return false ; <ect>
pn . their <identifiersep> initial <identifiersep> msg <identifiersep> id ) ; if ( new <identifiersep> tracker <identifiersep> id >= 0 ) { if ( dont <identifiersep> want ) { node . peers . disconnect <identifiersep> and <identifiersep> remove ( pn , true , true , true ) ; } else { pn . maybe <identifiersep> send <identifiersep> initial <identifiersep> messages ( ) ; } <LOG> } else { } <comment> <ect>
} catch ( waited <identifiersep> too <identifiersep> long <identifiersep> exception e1 ) { logger . error ( this , <string_literal> + uid + <string_literal> ) ; return ; } catch ( peer <identifiersep> restarted <identifiersep> exception e ) { logger . error ( this , <string_literal> + uid ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { return ; } } int status = sender . get <identifiersep> status ( ) ; if ( status == ssk <identifiersep> insert <identifiersep> sender . not <identifiersep> finished ) { continue ; } <comment> <ect>
message msg = dmt . create <identifiersep> fnp <identifiersep> route <identifiersep> not <identifiersep> found ( uid , sender . get <identifiersep> htl ( ) ) ; try { source . send <identifiersep> sync ( msg , this , real <identifiersep> time <identifiersep> flag ) ; } catch ( not <identifiersep> connected <identifiersep> exception e ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; return ; <LOG> } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { } can <identifiersep> commit = true ; finish ( status ) ; return ; } if ( status == ssk <identifiersep> insert <identifiersep> sender . success ) { <comment> <ect>
return ; } catch ( sync <identifiersep> send <identifiersep> waited <identifiersep> too <identifiersep> long <identifiersep> exception e ) { logger . error ( this , <string_literal> + msg + <string_literal> + source ) ; } can <identifiersep> commit = true ; finish ( status ) ; return ; } <LOG> <comment> <ect>
try { fs . write <identifiersep> to ( bw ) ; bw . close ( ) ; } catch ( io <identifiersep> exception e ) { try { fos . close ( ) ; <LOG> } catch ( io <identifiersep> exception e1 ) { } logger . error ( this , <string_literal> + e , e ) ; return false ; } return true ; } public synchronized string get <identifiersep> private <identifiersep> darknet <identifiersep> comment <identifiersep> note ( ) { return private <identifiersep> darknet <identifiersep> comment ; <ect>
destination = null ; string s = fs . get ( <string_literal> ) ; if ( s != null ) { try { s = base64 . decode <identifiersep> utf8 ( s ) ; } catch ( illegal <identifiersep> base64exception e ) { <LOG> <comment> <ect>
on <identifiersep> receive <identifiersep> failure ( ) ; } else { data . close ( ) ; if ( ! dest . rename <identifiersep> to ( node . client <identifiersep> core . downloads <identifiersep> dir ( ) . file ( base <identifiersep> filename ) ) ) { logger . error ( this , <string_literal> + dest . get <identifiersep> name ( ) + <string_literal> ) ; } on <identifiersep> receive <identifiersep> success ( ) ; } <LOG> } catch ( throwable t ) { on <identifiersep> receive <identifiersep> failure ( ) ; } finally { remove ( ) ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> ) ; <ect>
<comment> private peer [ ] update <identifiersep> handshake <identifiersep> i <identifiersep> ps ( peer [ ] local <identifiersep> handshake <identifiersep> i <identifiersep> ps , boolean ignore <identifiersep> hostnames ) { for ( peer local <identifiersep> handshake <identifiersep> ip : local <identifiersep> handshake <identifiersep> i <identifiersep> ps ) { if ( ignore <identifiersep> hostnames ) { <comment> <LOG> if ( log <identifiersep> minor ) local <identifiersep> handshake <identifiersep> ip . get <identifiersep> address ( false ) ; } else { <comment> <ect>
<comment> @ override public message <identifiersep> item send <identifiersep> async ( message msg , async <identifiersep> message <identifiersep> callback cb , byte <identifiersep> counter ctr ) throws not <identifiersep> connected <identifiersep> exception { <LOG> if ( ctr == null ) if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + msg + <string_literal> + cb + <string_literal> + this + <string_literal> + node . get <identifiersep> darknet <identifiersep> port <identifiersep> number ( ) + <string_literal> + msg . get <identifiersep> priority ( ) ) ; if ( ! is <identifiersep> connected ( ) ) { if ( cb != null ) cb . disconnected ( ) ; <ect>
should <identifiersep> return = is <identifiersep> rekeying || ! is <identifiersep> connected ( ) ; should <identifiersep> rekey = ( time <identifiersep> when <identifiersep> rekeying <identifiersep> should <identifiersep> occur < now ) ; if ( ( ! should <identifiersep> rekey ) && total <identifiersep> bytes <identifiersep> exchanged <identifiersep> with <identifiersep> current <identifiersep> tracker > fnp <identifiersep> packet <identifiersep> mangler . amount <identifiersep> of <identifiersep> bytes <identifiersep> allowed <identifiersep> before <identifiersep> we <identifiersep> rekey ) { should <identifiersep> rekey = true ; time <identifiersep> when <identifiersep> rekeying <identifiersep> should <identifiersep> occur = now ; } } if ( should <identifiersep> disconnect ) { <LOG> string time = time <identifiersep> util . format <identifiersep> time ( fnp <identifiersep> packet <identifiersep> mangler . max <identifiersep> session <identifiersep> key <identifiersep> rekeying <identifiersep> delay ) ; logger . error ( this , <string_literal> + this + <string_literal> + time + <string_literal> ) ; force <identifiersep> disconnect ( ) ; } else if ( should <identifiersep> return || has <identifiersep> live <identifiersep> handshake ( now ) ) { return ; } else if ( should <identifiersep> rekey ) { <ect>
public synchronized long get <identifiersep> outgoing <identifiersep> boot <identifiersep> id ( ) { return this . my <identifiersep> boot <identifiersep> id ; } private long last <identifiersep> incoming <identifiersep> rekey ; static final long throttle <identifiersep> rekey = <number_literal> ; public synchronized boolean throttle <identifiersep> rekey ( ) { long now = system . current <identifiersep> time <identifiersep> millis ( ) ; <LOG> if ( now - last <identifiersep> incoming <identifiersep> rekey < throttle <identifiersep> rekey ) { return true ; } last <identifiersep> incoming <identifiersep> rekey = now ; return false ; } public boolean full <identifiersep> packet <identifiersep> queued ( ) { packet <identifiersep> format pf ; <ect>
this . is <identifiersep> signature <identifiersep> verification <identifiersep> successfull = false ; throw new reference <identifiersep> signature <identifiersep> verification <identifiersep> exception ( <string_literal> + err <identifiersep> cause ) ; } else { this . is <identifiersep> signature <identifiersep> verification <identifiersep> successfull = true ; if ( ! dont <identifiersep> keep <identifiersep> full <identifiersep> field <identifiersep> set ( ) ) this . full <identifiersep> field <identifiersep> set = fs ; } <LOG> } catch ( illegal <identifiersep> base64exception e ) { throw new reference <identifiersep> signature <identifiersep> verification <identifiersep> exception ( <string_literal> ) ; } catch ( unsupported <identifiersep> encoding <identifiersep> exception e ) { throw new error ( <string_literal> + e , e ) ; } return ! failed ; } protected final byte [ ] get <identifiersep> pub <identifiersep> key <identifiersep> hash ( ) { <ect>
<comment> <LOG> <comment> <ect>
bookmark <identifiersep> item item = items . get ( i ) ; updated | = item . set <identifiersep> edition ( edition , node ) ; <comment> <LOG> } else if ( ! matched ) { } } @ override public short get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) { return priority ; } @ override public short get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) { <ect>
fos = new file <identifiersep> output <identifiersep> stream ( backup <identifiersep> bookmarks <identifiersep> file ) ; sfs . write <identifiersep> to <identifiersep> big <identifiersep> buffer ( fos ) ; fos . close ( ) ; fos = null ; if ( ! file <identifiersep> util . rename <identifiersep> to ( backup <identifiersep> bookmarks <identifiersep> file , bookmarks <identifiersep> file ) ) logger . error ( this , <string_literal> + backup <identifiersep> bookmarks <identifiersep> file . to <identifiersep> string ( ) + <string_literal> + bookmarks <identifiersep> file . to <identifiersep> string ( ) ) ; <LOG> } catch ( io <identifiersep> exception ioe ) { } finally { closer . close ( fos ) ; synchronized ( bookmarks ) { is <identifiersep> saving <identifiersep> bookmarks = false ; } } } private void read <identifiersep> bookmarks ( bookmark <identifiersep> category category , simple <identifiersep> field <identifiersep> set sfs ) { <ect>
public log <identifiersep> writeback <identifiersep> toadlet ( high <identifiersep> level <identifiersep> simple <identifiersep> client client ) { super ( client ) ; } public void handle <identifiersep> method <identifiersep> get ( uri uri , http <identifiersep> request req , toadlet <identifiersep> context ctx ) throws toadlet <identifiersep> context <identifiersep> closed <identifiersep> exception , io <identifiersep> exception , redirect <identifiersep> exception { if ( log <identifiersep> minor ) { try { logger . minor ( this , <string_literal> + url <identifiersep> decoder . decode ( req . get <identifiersep> param ( <string_literal> ) , false ) ) ; <LOG> } catch ( url <identifiersep> encoded <identifiersep> format <identifiersep> exception e ) { } } write <identifiersep> html <identifiersep> reply ( ctx , <number_literal> , <string_literal> , updater <identifiersep> constants . success ) ; } @ override public string path ( ) { return updater <identifiersep> constants . log <identifiersep> writeback <identifiersep> path ; } } <ect>
e . print <identifiersep> stack <identifiersep> trace ( ) ; throw new io <identifiersep> exception ( <string_literal> , e ) ; } } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { return prompt <identifiersep> password ( new <identifiersep> threat <identifiersep> level , password <identifiersep> prompt . decrypt <identifiersep> wrong ) ; } catch ( master <identifiersep> keys <identifiersep> file <identifiersep> size <identifiersep> exception e ) { return error <identifiersep> corrupt ; <LOG> } catch ( node . already <identifiersep> set <identifiersep> password <identifiersep> exception e ) { } } } <comment> <ect>
public void set <identifiersep> threat <identifiersep> level ( security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level new <identifiersep> threat <identifiersep> level , security <identifiersep> levels . physical <identifiersep> threat <identifiersep> level old <identifiersep> threat <identifiersep> level ) throws io <identifiersep> exception { core . node . security <identifiersep> levels . set <identifiersep> threat <identifiersep> level ( new <identifiersep> threat <identifiersep> level ) ; core . store <identifiersep> config ( ) ; try { core . node . late <identifiersep> setup <identifiersep> database ( null ) ; } catch ( master <identifiersep> keys <identifiersep> wrong <identifiersep> password <identifiersep> exception e ) { <LOG> <comment> <ect>
string ipcode = line . substring ( offset + <number_literal> , offset + <number_literal> ) ; long ip = decode <identifiersep> base85 ( ipcode . get <identifiersep> bytes ( <string_literal> ) ) ; try { country country = country . value <identifiersep> of ( code ) ; codes [ i ] = ( short ) country . ordinal ( ) ; } catch ( illegal <identifiersep> argument <identifiersep> exception e ) { <LOG> <comment> <ect>
return true ; } public boolean has <identifiersep> persistent <identifiersep> requests ( ) { return ! ( running <identifiersep> persistent <identifiersep> requests . is <identifiersep> empty ( ) && completed <identifiersep> unacked <identifiersep> requests . is <identifiersep> empty ( ) ) ; } public void add <identifiersep> persistent <identifiersep> requests ( list < client <identifiersep> request > v , boolean only <identifiersep> forever ) { synchronized ( this ) { for ( client <identifiersep> request req : running <identifiersep> persistent <identifiersep> requests ) { <LOG> if ( req == null ) { continue ; } if ( ( req . is <identifiersep> persistent <identifiersep> forever ( ) ) || ! only <identifiersep> forever ) v . add ( req ) ; } v . add <identifiersep> all ( completed <identifiersep> unacked <identifiersep> requests ) ; } } <comment> <ect>
<comment> public boolean set <identifiersep> watch <identifiersep> global ( boolean enabled , int verbosity <identifiersep> mask , fcp <identifiersep> server server ) { <LOG> if ( is <identifiersep> global <identifiersep> queue ) { return false ; } if ( server . global <identifiersep> forever <identifiersep> client == null ) return false ; if ( watch <identifiersep> global && ! enabled ) { server . global <identifiersep> reboot <identifiersep> client . unwatch ( this ) ; server . global <identifiersep> forever <identifiersep> client . unwatch ( this ) ; <ect>
string identifier = client <identifiersep> request . identifier ; if ( client <identifiersep> requests <identifiersep> by <identifiersep> identifier . get ( identifier ) != null ) { if ( client <identifiersep> request != client <identifiersep> requests <identifiersep> by <identifiersep> identifier . get ( identifier ) ) throw new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + client <identifiersep> request + <string_literal> + identifier + <string_literal> + client <identifiersep> requests <identifiersep> by <identifiersep> identifier . get ( identifier ) ) ; <LOG> else { return ; } } else { client <identifiersep> requests <identifiersep> by <identifiersep> identifier . put ( identifier , client <identifiersep> request ) ; } } } <ect>
if ( getter . resume <identifiersep> from <identifiersep> trivial <identifiersep> progress ( inner <identifiersep> dis , context ) ) { read <identifiersep> transient <identifiersep> progress <identifiersep> fields ( inner <identifiersep> dis ) ; } } catch ( io <identifiersep> exception e ) { logger . error ( this , <string_literal> + e ) ; } finally { inner <identifiersep> dis . close ( ) ; } <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { } } if ( compat <identifiersep> mode == null ) compat <identifiersep> mode = new compatibility <identifiersep> analyser ( ) ; if ( getter == null ) getter = make <identifiersep> getter ( make <identifiersep> bucket ( false ) ) ; this . getter = getter ; } private void read <identifiersep> transient <identifiersep> progress <identifiersep> fields ( data <identifiersep> input <identifiersep> stream dis ) throws io <identifiersep> exception , storage <identifiersep> format <identifiersep> exception { <ect>
if ( client != null ) client . notify <identifiersep> failure ( this ) ; } @ override public void on <identifiersep> generated <identifiersep> uri ( freenet <identifiersep> uri uri , base <identifiersep> client <identifiersep> putter state ) { synchronized ( this ) { if ( generated <identifiersep> uri != null ) { <LOG> if ( ! uri . equals ( generated <identifiersep> uri ) ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + generated <identifiersep> uri + <string_literal> + uri ) ; } else { generated <identifiersep> uri = uri ; } } try <identifiersep> send <identifiersep> generated <identifiersep> uri <identifiersep> message ( null , null ) ; <ect>
@ override public void on <identifiersep> generated <identifiersep> metadata ( bucket metadata , base <identifiersep> client <identifiersep> putter state ) { boolean delete = false ; synchronized ( this ) { if ( generated <identifiersep> uri != null ) logger . error ( this , <string_literal> + this + <string_literal> + state ) ; <LOG> if ( generated <identifiersep> metadata != null ) { delete = true ; } else { generated <identifiersep> metadata = metadata ; } } if ( delete ) { metadata . free ( ) ; <ect>
system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; system . err . println ( <string_literal> ) ; <comment> <LOG> system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; <comment> <ect>
system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; system . err . println ( <string_literal> ) ; <comment> <LOG> system . err . println ( <string_literal> + store <identifiersep> identifier + <string_literal> + e ) ; <comment> <ect>
@ override public void run ( ) { try { pm . register ( pi ) ; pi . get <identifiersep> plugin ( ) . run <identifiersep> plugin ( pi . get <identifiersep> plugin <identifiersep> respirator ( ) ) ; } catch ( throwable t ) { <LOG> logger . normal ( this , <string_literal> + t , t ) ; t . print <identifiersep> stack <identifiersep> trace ( ) ; } pi . unregister ( pm , false ) ; <comment> <ect>
plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } if ( this . is <identifiersep> plugin <identifiersep> loaded ( plugin <identifiersep> main <identifiersep> class <identifiersep> name ) ) { logger . error ( this , <string_literal> + filename ) ; return null ; } <LOG> } catch ( jar <identifiersep> exception je1 ) { plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , je1 ) ; } catch ( zip <identifiersep> exception ze1 ) { logger . error ( this , <string_literal> , ze1 ) ; <ect>
throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , je1 ) ; } catch ( zip <identifiersep> exception ze1 ) { logger . error ( this , <string_literal> , ze1 ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ze1 ) ; <LOG> } catch ( io <identifiersep> exception ioe1 ) { plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> , ioe1 ) ; } finally { closer . close ( plugin <identifiersep> jar <identifiersep> file ) ; <ect>
if ( ! ( object instanceof fred <identifiersep> plugin ) ) { logger . error ( this , <string_literal> ) ; plugin <identifiersep> file . delete ( ) ; if ( ! downloaded ) continue ; throw new plugin <identifiersep> not <identifiersep> found <identifiersep> exception ( <string_literal> ) ; } if ( pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> https || <LOG> pdl instanceof plugin <identifiersep> down <identifiersep> loader <identifiersep> official <identifiersep> freenet ) { <comment> <ect>
this . mode = mode ; this . expected <identifiersep> size = expected <identifiersep> size ; this . expected <identifiersep> mime <identifiersep> type = expected <identifiersep> mime <identifiersep> type ; error <identifiersep> codes = null ; init <identifiersep> cause ( t ) ; new <identifiersep> uri = null ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes ) { super ( get <identifiersep> message ( mode ) ) ; if ( error <identifiersep> codes . is <identifiersep> empty ( ) ) { <ect>
logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; } extra <identifiersep> message = null ; this . mode = mode ; this . error <identifiersep> codes = error <identifiersep> codes ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , failure <identifiersep> code <identifiersep> tracker error <identifiersep> codes , string msg ) { super ( get <identifiersep> message ( mode ) + <string_literal> + msg ) ; if ( error <identifiersep> codes . is <identifiersep> empty ( ) ) { <ect>
logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; } extra <identifiersep> message = msg ; this . mode = mode ; this . error <identifiersep> codes = error <identifiersep> codes ; new <identifiersep> uri = null ; expected <identifiersep> size = - 1 ; <LOG> if ( mode == fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error ) else if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + get <identifiersep> message ( mode ) + ' ) ' , this ) ; } public fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode mode , string msg ) { super ( get <identifiersep> message ( mode ) + <string_literal> + msg ) ; extra <identifiersep> message = msg ; <ect>
callback <identifiersep> complete <identifiersep> via <identifiersep> truncation != null ) ; } catch ( resume <identifiersep> failed <identifiersep> exception e ) { raf . free ( ) ; logger . error ( this , <string_literal> + e + <string_literal> + raf , e ) ; throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( io <identifiersep> exception e ) { <LOG> raf . free ( ) ; throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( storage <identifiersep> format <identifiersep> exception e ) { raf . free ( ) ; logger . error ( this , <string_literal> + e + <string_literal> + raf , e ) ; throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , <string_literal> + e , e ) ; <ect>
static { logger . register <identifiersep> class ( plain <identifiersep> manifest <identifiersep> putter . class ) ; } public plain <identifiersep> manifest <identifiersep> putter ( client <identifiersep> put <identifiersep> callback client <identifiersep> callback , hash <identifiersep> map < string , object > manifest <identifiersep> elements , short prio <identifiersep> class , freenet <identifiersep> uri target , string default <identifiersep> name , insert <identifiersep> context ctx , boolean get <identifiersep> chk <identifiersep> only , boolean early <identifiersep> encode , boolean persistent , byte [ ] force <identifiersep> crypto <identifiersep> key , client <identifiersep> context context ) throws too <identifiersep> many <identifiersep> files <identifiersep> insert <identifiersep> exception { super ( client <identifiersep> callback , manifest <identifiersep> elements , prio <identifiersep> class , target , default <identifiersep> name , ctx , client <identifiersep> putter . randomise <identifiersep> splitfile <identifiersep> keys ( target , ctx , persistent ) , force <identifiersep> crypto <identifiersep> key , context ) ; } @ override <LOG> protected void make <identifiersep> put <identifiersep> handlers ( hash <identifiersep> map < string , object > manifest <identifiersep> elements , string default <identifiersep> name ) { make <identifiersep> put <identifiersep> handlers ( get <identifiersep> root <identifiersep> builder ( ) , manifest <identifiersep> elements , default <identifiersep> name ) ; } @ suppress <identifiersep> warnings ( <string_literal> ) private void make <identifiersep> put <identifiersep> handlers ( free <identifiersep> form <identifiersep> builder builder , hash <identifiersep> map < string , object > manifest <identifiersep> elements , object default <identifiersep> name ) { for ( map . entry < string , object > entry : manifest <identifiersep> elements . entry <identifiersep> set ( ) ) { string name = entry . get <identifiersep> key ( ) ; <ect>
if ( keys <identifiersep> cache != null ) { split <identifiersep> file <identifiersep> segment <identifiersep> keys cached = keys <identifiersep> cache . get ( ) ; if ( cached != null ) return cached ; } split <identifiersep> file <identifiersep> segment <identifiersep> keys keys ; try { keys = read <identifiersep> segment <identifiersep> keys ( ) ; <LOG> } catch ( checksum <identifiersep> failed <identifiersep> exception e ) { <comment> <ect>
( ( usk <identifiersep> fetcher <identifiersep> tag <identifiersep> callback ) callback ) . set <identifiersep> tag ( usk <identifiersep> fetcher <identifiersep> tag . this , context ) ; callback . on <identifiersep> cancelled ( context ) ; } } @ override public void on <identifiersep> failure ( client <identifiersep> context context ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + this ) ; synchronized ( this ) { <LOG> if ( finished ) { return ; } finished = true ; } if ( persistent ) { try { context . job <identifiersep> runner . queue ( new persistent <identifiersep> job ( ) { <ect>
@ override public void on <identifiersep> found <identifiersep> edition ( final long l , final usk key , client <identifiersep> context context , final boolean metadata , final short codec , final byte [ ] data , final boolean new <identifiersep> known <identifiersep> good , final boolean new <identifiersep> slot <identifiersep> too ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + l + <string_literal> + this ) ; synchronized ( this ) { if ( fetcher == null ) { logger . error ( this , <string_literal> , new exception ( <string_literal> ) ) ; } <LOG> if ( finished ) { return ; } finished = true ; fetcher = null ; } if ( persistent ) { try { <ect>
stored <identifiersep> cross <identifiersep> check <identifiersep> blocks <identifiersep> length = 0 ; stored <identifiersep> blocks <identifiersep> length = ( ( long ) splitfile <identifiersep> data <identifiersep> blocks + total <identifiersep> cross <identifiersep> check <identifiersep> blocks ) * chk <identifiersep> block . data <identifiersep> length ; } int segment <identifiersep> count = metadata . get <identifiersep> segment <identifiersep> count ( ) ; if ( segment <identifiersep> count < = 0 ) { throw new assertion <identifiersep> error ( <string_literal> ) ; } if ( splitfile <identifiersep> type == splitfile <identifiersep> algorithm . nonredundant ) { <LOG> if ( splitfile <identifiersep> check <identifiersep> blocks > 0 ) { throw new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . invalid <identifiersep> metadata , <string_literal> + splitfile <identifiersep> check <identifiersep> blocks + <string_literal> ) ; } } else if ( splitfile <identifiersep> type == splitfile <identifiersep> algorithm . onion <identifiersep> standard ) { boolean dont <identifiersep> compress = decompressors . is <identifiersep> empty ( ) ; if ( top <identifiersep> compatibility <identifiersep> mode != 0 ) { <comment> <ect>
failed ++ ; break ; } } catch ( throwable t ) { if ( partial . status == request <identifiersep> load <identifiersep> status . loaded ) failed <identifiersep> serialize = true ; failed ++ ; <LOG> system . err . println ( <string_literal> + req + <string_literal> ) ; try { req . cancel ( context ) ; } catch ( throwable t1 ) { logger . error ( this , <string_literal> + req + <string_literal> + t1 , t1 ) ; } } } if ( success > 0 ) <ect>
system . err . println ( <string_literal> + req + <string_literal> ) ; logger . error ( this , <string_literal> + req + <string_literal> + t , t ) ; try { req . cancel ( context ) ; } catch ( throwable t1 ) { logger . error ( this , <string_literal> + req + <string_literal> + t1 , t1 ) ; } } } <LOG> if ( success > 0 ) if ( restored <identifiersep> fully > 0 ) system . out . println ( <string_literal> + restored <identifiersep> fully + <string_literal> ) ; if ( restored <identifiersep> restarted > 0 ) system . out . println ( <string_literal> + restored <identifiersep> restarted + <string_literal> ) ; if ( failed > 0 ) <ect>
} catch ( throwable t1 ) { logger . error ( this , <string_literal> + req + <string_literal> + t1 , t1 ) ; } } } if ( success > 0 ) system . out . println ( <string_literal> + success + <string_literal> ) ; if ( restored <identifiersep> fully > 0 ) system . out . println ( <string_literal> + restored <identifiersep> fully + <string_literal> ) ; <LOG> if ( restored <identifiersep> restarted > 0 ) if ( failed > 0 ) system . err . println ( <string_literal> + failed + <string_literal> ) ; return failed <identifiersep> serialize ; } else { <comment> <ect>
freenet <identifiersep> uri uri = key . get <identifiersep> ssk ( l ) . get <identifiersep> uri ( ) ; try { single <identifiersep> file <identifiersep> fetcher getter = ( single <identifiersep> file <identifiersep> fetcher ) single <identifiersep> file <identifiersep> fetcher . create ( this , this , uri , ctx , new archive <identifiersep> context ( ctx . max <identifiersep> temp <identifiersep> length , ctx . max <identifiersep> archive <identifiersep> levels ) , ctx . max <identifiersep> non <identifiersep> splitfile <identifiersep> retries , 0 , true , l , true , false , context , real <identifiersep> time <identifiersep> flag , false ) ; getter . schedule ( context ) ; <LOG> } catch ( malformed <identifiersep> url <identifiersep> exception e ) { } catch ( fetch <identifiersep> exception e ) { logger . error ( this , <string_literal> + uri + <string_literal> + e , e ) ; } } @ override public void on <identifiersep> success ( stream <identifiersep> generator stream <identifiersep> generator , client <identifiersep> metadata client <identifiersep> metadata , list < ? extends compressor > decompressors , final client <identifiersep> get <identifiersep> state state , client <identifiersep> context context ) { if ( log <identifiersep> minor ) <ect>
long max <identifiersep> len = math . max ( ctx . max <identifiersep> temp <identifiersep> length , ctx . max <identifiersep> output <identifiersep> length ) ; try { final <identifiersep> result = context . get <identifiersep> bucket <identifiersep> factory ( persistent ( ) ) . make <identifiersep> bucket ( max <identifiersep> len ) ; } catch ( insufficient <identifiersep> disk <identifiersep> space <identifiersep> exception e ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . not <identifiersep> enough <identifiersep> disk <identifiersep> space ) , state , context ) ; return ; <LOG> } catch ( io <identifiersep> exception e ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) , state , context ) ; return ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) , state , context ) ; } catch ( throwable t ) { logger . error ( this , <string_literal> + t , t ) ; on <identifiersep> failure ( new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t ) , state , context ) ; return ; <ect>
if ( local <identifiersep> callbacks . length == 0 && fetcher <identifiersep> callbacks . length == 0 ) { normal <identifiersep> poll <identifiersep> priority = default <identifiersep> normal <identifiersep> poll <identifiersep> priority ; progress <identifiersep> poll <identifiersep> priority = default <identifiersep> progress <identifiersep> poll <identifiersep> priority ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + normal <identifiersep> poll <identifiersep> priority + <string_literal> + progress <identifiersep> poll <identifiersep> priority + <string_literal> + this + <string_literal> + orig <identifiersep> usk ) ; return ; } for ( usk <identifiersep> callback cb : local <identifiersep> callbacks ) { <LOG> short prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) ; if ( prio < normal <identifiersep> prio ) normal <identifiersep> prio = prio ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) ; if ( prio < progress <identifiersep> prio ) progress <identifiersep> prio = prio ; } for ( usk <identifiersep> fetcher <identifiersep> callback cb : fetcher <identifiersep> callbacks ) { <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; if ( prio < normal <identifiersep> prio ) normal <identifiersep> prio = prio ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) ; if ( prio < progress <identifiersep> prio ) progress <identifiersep> prio = prio ; } for ( usk <identifiersep> fetcher <identifiersep> callback cb : fetcher <identifiersep> callbacks ) { <LOG> short prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> normal ( ) ; if ( prio < normal <identifiersep> prio ) normal <identifiersep> prio = prio ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + cb + <string_literal> + prio ) ; prio = cb . get <identifiersep> polling <identifiersep> priority <identifiersep> progress ( ) ; if ( prio < progress <identifiersep> prio ) progress <identifiersep> prio = prio ; } if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + normal <identifiersep> prio + <string_literal> + progress <identifiersep> prio + <string_literal> + this + <string_literal> + orig <identifiersep> usk ) ; <ect>
if ( keep <identifiersep> last <identifiersep> data ) { <comment> <LOG> } catch ( io <identifiersep> exception e ) { } } } } } private synchronized list < lookup > get <identifiersep> running <identifiersep> fetch <identifiersep> editions ( ) { list < lookup > ret = new array <identifiersep> list < lookup > ( ) ; for ( usk <identifiersep> attempt a : running <identifiersep> attempts . values ( ) ) { if ( ! ret . contains ( a . lookup ) ) ret . add ( a . lookup ) ; } for ( usk <identifiersep> attempt a : polling <identifiersep> attempts . values ( ) ) { <ect>
synchronized ( this ) { finished = true ; current <identifiersep> state = null ; expected <identifiersep> mime = metadata . get <identifiersep> mime <identifiersep> type ( ) ; expected <identifiersep> size = length ; } result = new fetch <identifiersep> result ( metadata , return <identifiersep> bucket ) ; <LOG> } catch ( io <identifiersep> exception e ) { ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; } catch ( fetch <identifiersep> exception e ) { <ect>
logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e ) ; } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { logger . error ( this , <string_literal> + e , e ) ; ex = new fetch <identifiersep> exception ( fetch <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e ) ; } catch ( fetch <identifiersep> exception e ) { <LOG> <comment> <ect>
e = e1 ; continue ; } return ; } } boolean already <identifiersep> finished = false ; synchronized ( this ) { if ( finished && ! force ) { <LOG> if ( ! cancelled ) already <identifiersep> finished = true ; } finished = true ; old <identifiersep> state = current <identifiersep> state ; current <identifiersep> state = null ; string mime = e . get <identifiersep> expected <identifiersep> mime <identifiersep> type ( ) ; <ect>
this . crypto <identifiersep> key = crypto <identifiersep> key ; } protected client <identifiersep> key <identifiersep> block inner <identifiersep> encode ( random <identifiersep> source random ) throws insert <identifiersep> exception { compatibility <identifiersep> mode cmode = ctx . get <identifiersep> compatibility <identifiersep> mode ( ) ; boolean pre1254 = ! ( cmode == compatibility <identifiersep> mode . compat <identifiersep> current || cmode . ordinal ( ) >= compatibility <identifiersep> mode . compat <identifiersep> <number_literal> . ordinal ( ) ) ; try { return inner <identifiersep> encode ( random , uri , source <identifiersep> data , is <identifiersep> metadata , compression <identifiersep> codec , source <identifiersep> length , ctx . compressor <identifiersep> descriptor , pre1254 , crypto <identifiersep> algorithm , crypto <identifiersep> key ) ; <LOG> } catch ( key <identifiersep> encode <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , e , null ) ; } catch ( malformed <identifiersep> url <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . invalid <identifiersep> uri , e , null ) ; } catch ( io <identifiersep> exception e ) { logger . error ( single <identifiersep> block <identifiersep> inserter . class , <string_literal> + e + <string_literal> + source <identifiersep> data , e ) ; <ect>
} ) ; } } protected client <identifiersep> key <identifiersep> block encode ( client <identifiersep> context context , boolean called <identifiersep> by <identifiersep> cb ) throws insert <identifiersep> exception { client <identifiersep> key <identifiersep> block block ; boolean should <identifiersep> send ; synchronized ( this ) { if ( finished ) return null ; <LOG> if ( source <identifiersep> data == null ) { return null ; } block = inner <identifiersep> encode ( context . random ) ; should <identifiersep> send = ( resulting <identifiersep> key == null ) ; resulting <identifiersep> key = block . get <identifiersep> client <identifiersep> key ( ) ; } if ( log <identifiersep> minor ) <ect>
synchronized ( this ) { if ( finished ) return null ; } return encode ( context , called <identifiersep> by <identifiersep> cb ) ; } catch ( insert <identifiersep> exception e ) { cb . on <identifiersep> failure ( e , this , context ) ; return null ; <LOG> } catch ( throwable t ) { cb . on <identifiersep> failure ( new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . internal <identifiersep> error , t , null ) , this , context ) ; return null ; } } @ override public void schedule ( client <identifiersep> context context ) throws insert <identifiersep> exception { synchronized ( this ) { <ect>
long orig <identifiersep> size = block . get <identifiersep> data ( ) . size ( ) ; byte [ ] hash <identifiersep> this <identifiersep> layer <identifiersep> only = null ; if ( hashes != null && metadata ) { hash <identifiersep> this <identifiersep> layer <identifiersep> only = hash <identifiersep> result . get ( hashes , hash <identifiersep> type . sha256 ) ; hashes = null ; <comment> <LOG> if ( log <identifiersep> debug ) { for ( hash <identifiersep> result res : hashes ) { logger . debug ( this , res . type . name ( ) + <string_literal> + res . hash <identifiersep> as <identifiersep> hex ( ) ) ; } } hash <identifiersep> result [ ] client <identifiersep> hashes = hashes ; if ( persistent ) client <identifiersep> hashes = hash <identifiersep> result . copy ( hashes ) ; ctx . event <identifiersep> producer . produce <identifiersep> event ( new expected <identifiersep> hashes <identifiersep> event ( client <identifiersep> hashes ) , context ) ; <ect>
if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + data <identifiersep> putter + <string_literal> + this ) ; metadata meta = make <identifiersep> metadata ( archive <identifiersep> type , data <identifiersep> putter . get <identifiersep> uri ( context ) , hashes ) ; random <identifiersep> access <identifiersep> bucket metadata <identifiersep> bucket ; try { metadata <identifiersep> bucket = meta . to <identifiersep> bucket ( context . get <identifiersep> bucket <identifiersep> factory ( persistent ) ) ; <LOG> } catch ( io <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; } catch ( metadata <identifiersep> unresolved <identifiersep> exception e ) { <comment> <ect>
if ( ! skip ) { if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + data + <string_literal> + data . size ( ) ) ; random <identifiersep> access <identifiersep> bucket new <identifiersep> data = context . persistent <identifiersep> bucket <identifiersep> factory . make <identifiersep> bucket ( data . size ( ) ) ; bucket <identifiersep> tools . copy ( data , new <identifiersep> data ) ; data . free ( ) ; data = new <identifiersep> data ; } <LOG> } catch ( io <identifiersep> exception e ) { throw new insert <identifiersep> exception ( insert <identifiersep> exception <identifiersep> mode . bucket <identifiersep> error , e , null ) ; } <comment> <ect>
<comment> <LOG> if ( ! running <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { return ; } if ( ! container <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; } if ( container <identifiersep> mode ) { <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; } if ( ! container <identifiersep> put <identifiersep> handlers . is <identifiersep> empty ( ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; } if ( container <identifiersep> mode ) { <LOG> if ( root <identifiersep> container <identifiersep> put <identifiersep> handler != null ) { return ; } } else { if ( root <identifiersep> meta <identifiersep> put <identifiersep> handler != null ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> ) ; return ; <ect>
return true ; } @ override public void on <identifiersep> transition ( client <identifiersep> get <identifiersep> state old <identifiersep> state , client <identifiersep> get <identifiersep> state new <identifiersep> state , client <identifiersep> context context ) { <comment> <LOG> <comment> <ect>
case ' \\ t' : buffer . append ( c ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + c ) ; break ; case ' @ ' : if ( prevc != ' \\ \\ ' ) { <LOG> is <identifiersep> state1present = true ; } buffer . append ( c ) ; break ; case ' { ' : charset <identifiersep> possible = false ; if ( stop <identifiersep> at <identifiersep> detected <identifiersep> charset ) <ect>
continue ; break ; } i ++ ; string post <identifiersep> space = buffer . substring ( i ) ; buffer . set <identifiersep> length ( i ) ; string orig = buffer . to <identifiersep> string ( ) . trim ( ) ; <LOG> parsed <identifiersep> word [ ] parts = split ( orig , false ) ; buffer . set <identifiersep> length ( 0 ) ; boolean valid = false ; if ( parts != null ) { if ( parts . length < 1 ) { <ect>
if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + buffer . to <identifiersep> string ( ) ) ; valid = false ; } else if ( parts [ 0 ] instanceof simple <identifiersep> parsed <identifiersep> word && <string_literal> . equals ( ( ( simple <identifiersep> parsed <identifiersep> word ) parts [ 0 ] ) . original . to <identifiersep> lower <identifiersep> case ( ) ) ) { if ( parts . length < <number_literal> ) { <LOG> ignore <identifiersep> elements <identifiersep> s1 = true ; valid = false ; } else { array <identifiersep> list < string > medias = comma <identifiersep> list <identifiersep> from <identifiersep> identifiers ( parts , 1 ) ; if ( medias != null && medias . size ( ) > 0 ) { for ( i = 0 ; i < medias . size ( ) ; i ++ ) { <ect>
if ( changed <identifiersep> anything ( words ) ) property <identifiersep> value = reconstruct ( words ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> before <identifiersep> property ) ; whitespace <identifiersep> before <identifiersep> property = <string_literal> ; filtered <identifiersep> tokens . append ( property <identifiersep> name ) ; filtered <identifiersep> tokens . append ( ' : ' ) ; filtered <identifiersep> tokens . append ( whitespace <identifiersep> after <identifiersep> colon ) ; <LOG> filtered <identifiersep> tokens . append ( property <identifiersep> value ) ; } } else { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + property <identifiersep> name + <string_literal> ) ; } property <identifiersep> name = <string_literal> ; } else { <comment> <ect>
<comment> <LOG> break ; } filtered <identifiersep> tokens . append ( buffer . substring ( 0 , i ) ) ; buffer . delete ( 0 , i ) ; } ignore <identifiersep> elements <identifiersep> s3 = false ; if ( ( ! ignore <identifiersep> elements <identifiersep> s2 ) || close <identifiersep> ignored <identifiersep> s2 ) { filtered <identifiersep> tokens . append ( post <identifiersep> space ) ; <ect>
for <identifiersep> page = false ; current <identifiersep> state = state1 ; } else { current <identifiersep> state = state2 ; } if ( is <identifiersep> inline ) return ; buffer . set <identifiersep> length ( 0 ) ; <LOG> s2comma = false ; break ; case ' { ' : <comment> <ect>
<comment> <LOG> if ( css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ verifier <identifiersep> index ] . check <identifiersep> validity ( before , cb ) ) { if ( i == value <identifiersep> parts . length && lower <identifiersep> limit < = 1 ) { if ( recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( second <identifiersep> part , new parsed <identifiersep> word [ 0 ] , cb ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + second <identifiersep> part ) ; return true ; } else { <ect>
if ( css <identifiersep> tokenizer <identifiersep> filter . auxilary <identifiersep> verifiers [ verifier <identifiersep> index ] . check <identifiersep> validity ( before , cb ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + i + <string_literal> + verifier <identifiersep> index + <string_literal> + to <identifiersep> string ( before ) ) ; if ( i == value <identifiersep> parts . length && lower <identifiersep> limit < = 1 ) { if ( recursive <identifiersep> parser <identifiersep> expression <identifiersep> verifier ( second <identifiersep> part , new parsed <identifiersep> word [ 0 ] , cb ) ) { if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + second <identifiersep> part ) ; return true ; <LOG> } else { return false ; } } else if ( i == value <identifiersep> parts . length && lower <identifiersep> limit > 1 ) return false ; parsed <identifiersep> word [ ] after = arrays . copy <identifiersep> of <identifiersep> range ( value <identifiersep> parts , i , value <identifiersep> parts . length ) ; if ( log <identifiersep> debug ) logger . debug ( this , <string_literal> + to <identifiersep> string ( after ) ) ; <ect>
<comment> public boolean recursive <identifiersep> double <identifiersep> bar <identifiersep> verifier ( string expression , parsed <identifiersep> word [ ] words , filter <identifiersep> callback cb ) <LOG> { if ( words == null || words . length == 0 ) return true ; string ignored <identifiersep> parts = <string_literal> ; string first <identifiersep> part = <string_literal> ; string second <identifiersep> part = <string_literal> ; <ect>
e ) ; return <string_literal> + l10n ( <string_literal> ) + <string_literal> ; } else throw e ; } string s = w . to <identifiersep> string ( ) ; if ( ( s == null ) || ( s . length ( ) == 0 ) ) <LOG> return null ; if ( log <identifiersep> minor ) logger . minor ( html <identifiersep> filter . class , <string_literal> + s ) ; return s ; } static string escape <identifiersep> quotes ( string s ) { string <identifiersep> builder buf = new string <identifiersep> builder ( s . length ( ) ) ; for ( int x = 0 ; x < s . length ( ) ; x ++ ) { <ect>
type = type . substring ( 0 , idx ) ; <comment> <LOG> if ( idx == - 1 ) { continue ; } string before = raw . substring ( 0 , idx ) . trim ( ) ; string after = raw . substring ( idx + 1 ) . trim ( ) ; if ( before . equals ( <string_literal> ) ) { charset = after ; <ect>
uri orig <identifiersep> uri = uri ; <comment> <LOG> } catch ( uri <identifiersep> syntax <identifiersep> exception e ) { throw new comment <identifiersep> exception ( <string_literal> + e ) ; } host = null ; } string rpath = uri . get <identifiersep> path ( ) ; if ( log <identifiersep> minor ) logger . minor ( this , <string_literal> + path + <string_literal> + rpath + <string_literal> ) ; if ( host == null ) { <ect>
throw new exception ( <string_literal> ) ; } system . out . println ( <string_literal> ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { thread . sleep ( <number_literal> ) ; system . out . println ( <string_literal> + i ) ; if ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . starts <identifiersep> with ( <string_literal> ) == false ) { <LOG> throw new exception ( <string_literal> ) ; } } for ( int i = 0 ; i < <number_literal> ; i ++ ) { system . out . println ( <string_literal> + i ) ; if ( new string ( base64 . decode <identifiersep> standard ( c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) . get <identifiersep> web <identifiersep> response ( ) . get <identifiersep> content <identifiersep> as <identifiersep> string ( ) . split ( <string_literal> ) [ 1 ] ) ) . compare <identifiersep> to ( request <identifiersep> id1 ) != 0 ) { throw new exception ( <string_literal> ) ; } } c1 . get <identifiersep> page ( test <identifiersep> url <identifiersep> prefix + <string_literal> + request <identifiersep> id1 ) ; <ect>
simple <identifiersep> field <identifiersep> set method <identifiersep> sfs = sfs <identifiersep> from <identifiersep> sample <identifiersep> string <identifiersep> pairs ( ) ; iterator < string > itr = method <identifiersep> sfs . toplevel <identifiersep> key <identifiersep> iterator ( ) ; for ( int i = 0 ; i < <number_literal> ; i ++ ) { assert <identifiersep> true ( itr . has <identifiersep> next ( ) ) ; assert <identifiersep> true ( is <identifiersep> a <identifiersep> key ( sample <identifiersep> string <identifiersep> pairs , <string_literal> , ( string ) itr . next ( ) ) ) ; } assert <identifiersep> false ( itr . has <identifiersep> next ( ) ) ; } <LOG> public void test <identifiersep> key <identifiersep> iteration <identifiersep> past <identifiersep> end ( ) { simple <identifiersep> field <identifiersep> set sfs = new simple <identifiersep> field <identifiersep> set ( true ) ; sfs . put <identifiersep> overwrite ( <string_literal> , <string_literal> ) ; iterator < string > key <identifiersep> iterator = sfs . key <identifiersep> iterator ( ) ; assert <identifiersep> equals ( <string_literal> , key <identifiersep> iterator . next ( ) ) ; try { <ect>
byte [ ] b = new byte [ <number_literal> ] ; do { rand . next <identifiersep> bytes ( b ) ; } while ( list . contains ( new byte <identifiersep> array <identifiersep> wrapper ( b ) ) ) ; filter . add <identifiersep> key ( b ) ; list . add ( new byte <identifiersep> array <identifiersep> wrapper ( b ) ) ; <LOG> assert <identifiersep> true ( <string_literal> , filter . check <identifiersep> filter ( b ) ) ; } int f <identifiersep> pos = 0 ; for ( int i = 0 ; i < pass <identifiersep> false ; i ++ ) { byte [ ] b = new byte [ <number_literal> ] ; <comment> <ect>
for ( int i = 0 ; i < key . length ; i ++ ) key [ i ] = ( byte ) ( i + 1 ) ; for ( int i = 0 ; i < text . length ; i ++ ) text [ i ] = ( byte ) 0xcd ; mv = s . mac ( key , text , <number_literal> ) ; system . out . println ( hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( mv , 0 , mv . length ) ) ; <LOG> key = new byte [ <number_literal> ] ; for ( int i = 0 ; i < key . length ; i ++ ) key [ i ] = ( byte ) 0x0c ; text = <string_literal> . get <identifiersep> bytes ( <string_literal> ) ; mv = s . mac ( key , text , <number_literal> ) ; system . out . println ( hex <identifiersep> util . bytes <identifiersep> to <identifiersep> hex ( mv , 0 , mv . length ) ) ; <ect>
if ( ! progress ) { <comment> <LOG> if ( ! progress ) { assert <identifiersep> true ( false ) ; } assert <identifiersep> true ( progress ) ; } synchronized void mark <identifiersep> downloaded <identifiersep> block ( int block ) { encoded <identifiersep> blocks [ block ] = true ; } public synchronized void check <identifiersep> failed ( ) { <ect>
src <identifiersep> bufs [ i ] = new buffer ( src , i * packet <identifiersep> size , packet <identifiersep> size ) ; byte [ ] repair = new byte [ kk * packet <identifiersep> size ] ; buffer [ ] repair <identifiersep> bufs = new buffer [ kk ] ; for ( int i = 0 ; i < repair <identifiersep> bufs . length ; i ++ ) { repair <identifiersep> bufs [ i ] = new buffer ( repair , i * packet <identifiersep> size , packet <identifiersep> size ) ; } int [ ] index <identifiersep> backup = new int [ index . length ] ; <LOG> system . arraycopy ( index , 0 , index <identifiersep> backup , 0 , index . length ) ; long t1 = system . current <identifiersep> time <identifiersep> millis ( ) ; maybe <identifiersep> native . encode ( src <identifiersep> bufs , repair <identifiersep> bufs , index ) ; long t2 = system . current <identifiersep> time <identifiersep> millis ( ) ; pure <identifiersep> code . encode ( src <identifiersep> bufs , repair <identifiersep> bufs , index <identifiersep> backup ) ; long t3 = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
system . out . println ( <string_literal> ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> double ( ) + <string_literal> ) ; if ( j%3 == <number_literal> ) system . out . println ( ) ; } <LOG> if ( ! ( j%3 == <number_literal> ) ) system . out . println ( ) ; r = new mersenne <identifiersep> twister ( seed ) ; for ( j = 0 ; j < <number_literal> ; j ++ ) { system . out . print ( r . next <identifiersep> gaussian ( ) + <string_literal> ) ; if ( j%3 == <number_literal> ) system . out . println ( ) ; <ect>
@ suppress <identifiersep> warnings ( <string_literal> ) map < string , exception > map = ( map < string , exception > ) context . get ( <string_literal> ) ; if ( map == null ) { map = new hash <identifiersep> map < string , exception > ( ) ; context . put ( <string_literal> , map ) ; } map . put ( feed <identifiersep> doc <identifiersep> name , e ) ; <LOG> <comment> <ect>
document <identifiersep> reference skin <identifiersep> reference = this . current <identifiersep> mixed <identifiersep> document <identifiersep> reference <identifiersep> resolver . resolve ( skin ) ; x <identifiersep> wiki xwiki = xcontext . get <identifiersep> wiki ( ) ; if ( xwiki != null && xwiki . get <identifiersep> store ( ) != null ) { x <identifiersep> wiki <identifiersep> document doc ; try { doc = xwiki . get <identifiersep> document ( skin <identifiersep> reference , xcontext ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { return null ; } if ( ! doc . is <identifiersep> new ( ) ) { return doc ; } } } return null ; } private base <identifiersep> object get <identifiersep> skin <identifiersep> object ( string skin ) <ect>
<comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } locale <identifiersep> parameters . put ( wiki <identifiersep> document <identifiersep> filter . parameter <identifiersep> creation <identifiersep> author , document . get <identifiersep> creator ( ) ) ; locale <identifiersep> parameters . put ( wiki <identifiersep> document <identifiersep> filter . parameter <identifiersep> creation <identifiersep> date , document . get <identifiersep> creation <identifiersep> date ( ) ) ; locale <identifiersep> parameters . put ( wiki <identifiersep> document <identifiersep> filter . parameter <identifiersep> lastrevision , document . get <identifiersep> version ( ) ) ; document <identifiersep> filter . begin <identifiersep> wiki <identifiersep> document <identifiersep> locale ( document . get <identifiersep> locale ( ) , locale <identifiersep> parameters ) ; if ( properties . is <identifiersep> with <identifiersep> revisions ( ) ) { <ect>
revision <identifiersep> parameters . put ( wiki <identifiersep> document <identifiersep> filter . parameter <identifiersep> content , document . get <identifiersep> content ( ) ) ; if ( properties . is <identifiersep> with <identifiersep> wiki <identifiersep> document <identifiersep> content <identifiersep> html ( ) ) { try { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; revision <identifiersep> parameters . put ( wiki <identifiersep> document <identifiersep> filter . parameter <identifiersep> content <identifiersep> html , document . get <identifiersep> rendered <identifiersep> content ( xcontext ) ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { e ) ; } } document <identifiersep> filter . begin <identifiersep> wiki <identifiersep> document <identifiersep> revision ( document . get <identifiersep> version ( ) , revision <identifiersep> parameters ) ; <comment> <ect>
try { this . progress <identifiersep> manager . start <identifiersep> step ( this , <string_literal> ) ; <comment> <LOG> xcontext . get <identifiersep> wiki ( ) . get <identifiersep> plugin <identifiersep> manager ( ) . virtual <identifiersep> init ( xcontext ) ; this . progress <identifiersep> manager . start <identifiersep> step ( this , <string_literal> ) ; <comment> <ect>
{ logger . debug ( <string_literal> , username , page , action , info ) ; } protected void log <identifiersep> deny ( string username , string page , string action , string info ) { logger . info ( <string_literal> , username , page , action , info ) ; } protected void log <identifiersep> deny ( string name , string resource <identifiersep> key , string access <identifiersep> level , string info , exception e ) <LOG> { } @ override public list < string > list <identifiersep> all <identifiersep> levels ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { return new array <identifiersep> list < string > ( alllevels ) ; } public string get <identifiersep> right ( string action ) <ect>
this . current <identifiersep> mixed <identifiersep> document <identifiersep> reference <identifiersep> resolver . resolve ( user <identifiersep> or <identifiersep> group <identifiersep> name ) ; string prefixed <identifiersep> full <identifiersep> name = this . entity <identifiersep> reference <identifiersep> serializer . serialize ( user <identifiersep> or <identifiersep> group <identifiersep> document <identifiersep> reference ) ; string shortname = user <identifiersep> or <identifiersep> group <identifiersep> name ; int i0 = user <identifiersep> or <identifiersep> group <identifiersep> name . index <identifiersep> of ( <string_literal> ) ; if ( i0 != - 1 ) { <LOG> shortname = user <identifiersep> or <identifiersep> group <identifiersep> name . substring ( i0 + 1 ) ; } access <identifiersep> level , user , allow , global ) ; } list < base <identifiersep> object > right <identifiersep> objects = doc . get <identifiersep> x <identifiersep> objects ( right <identifiersep> class <identifiersep> reference ) ; if ( right <identifiersep> objects != null ) { logger . debug ( <string_literal> , right <identifiersep> objects . size ( ) ) ; <ect>
logger . debug ( <string_literal> , user <identifiersep> or <identifiersep> group <identifiersep> name , doc . get <identifiersep> full <identifiersep> name ( ) , access <identifiersep> level , user , allow , global ) ; } list < base <identifiersep> object > right <identifiersep> objects = doc . get <identifiersep> x <identifiersep> objects ( right <identifiersep> class <identifiersep> reference ) ; if ( right <identifiersep> objects != null ) { logger . debug ( <string_literal> , right <identifiersep> objects . size ( ) ) ; } <LOG> for ( int i = 0 ; i < right <identifiersep> objects . size ( ) ; i ++ ) { base <identifiersep> object bobj = right <identifiersep> objects . get ( i ) ; if ( bobj == null ) { logger . debug ( <string_literal> , i ) ; continue ; } string users = bobj . get <identifiersep> string <identifiersep> value ( field <identifiersep> name ) ; <ect>
base64 . decode <identifiersep> base64 ( encrypted <identifiersep> text . replace <identifiersep> all ( <string_literal> , <string_literal> ) . get <identifiersep> bytes ( <string_literal> ) ) ; cipher c1 = cipher . get <identifiersep> instance ( this . cipher <identifiersep> parameters ) ; c1 . init ( cipher . decrypt <identifiersep> mode , this . secret <identifiersep> key ) ; byte [ ] decrypted <identifiersep> text = c1 . do <identifiersep> final ( decoded <identifiersep> encrypted <identifiersep> text ) ; string decrypted <identifiersep> text <identifiersep> string = new string ( decrypted <identifiersep> text ) ; return decrypted <identifiersep> text <identifiersep> string ; <LOG> } catch ( exception e ) { return null ; } } <comment> <ect>
int seconds = ( int ) ( double . parse <identifiersep> double ( waitdays ) * <number_literal> * <number_literal> * <number_literal> + 0 . <number_literal> ) ; calendar cal = calendar . get <identifiersep> instance ( ) ; cal . set <identifiersep> time ( get <identifiersep> date ( ) ) ; cal . add ( calendar . second , seconds ) ; return cal . before ( calendar . get <identifiersep> instance ( ) ) ; } catch ( exception ex ) { <LOG> <comment> <ect>
<comment> public string get <identifiersep> rendered <identifiersep> title ( string syntax <identifiersep> id ) throws x <identifiersep> wiki <identifiersep> exception { try { return this . doc . get <identifiersep> rendered <identifiersep> title ( syntax . value <identifiersep> of ( syntax <identifiersep> id ) , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; <LOG> } catch ( parse <identifiersep> exception e ) { throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <string_literal> + syntax <identifiersep> id + <string_literal> , e ) ; } catch ( exception e ) { logger . error ( <string_literal> + get <identifiersep> prefixed <identifiersep> full <identifiersep> name ( ) + <string_literal> , e ) ; throw new x <identifiersep> wiki <identifiersep> exception ( x <identifiersep> wiki <identifiersep> exception . module <identifiersep> xwiki <identifiersep> rendering , x <identifiersep> wiki <identifiersep> exception . error <identifiersep> xwiki <identifiersep> unknown , <ect>
@ override public boolean supports <identifiersep> aggressive <identifiersep> release ( ) { return false ; } protected void log <identifiersep> statistics ( ) <LOG> { this . ds . get <identifiersep> max <identifiersep> total ( ) , this . ds . get <identifiersep> num <identifiersep> idle ( ) , this . ds . get <identifiersep> max <identifiersep> idle ( ) ) ; } } } <ect>
if ( <string_literal> . equals ( config . get <identifiersep> property ( <string_literal> , <string_literal> ) ) && ! <string_literal> . equals ( config . get <identifiersep> property ( <string_literal> ) ) ) { <comment> <LOG> if ( <string_literal> . equals ( config . get <identifiersep> property ( <string_literal> , <string_literal> ) ) ) { system . exit ( 0 ) ; } } } <comment> <ect>
x <identifiersep> wiki <identifiersep> hibernate <identifiersep> versioning <identifiersep> store versioning <identifiersep> store = get <identifiersep> versioning <identifiersep> store ( ) ; transaction original <identifiersep> transaction = versioning <identifiersep> store . get <identifiersep> transaction ( context ) ; versioning <identifiersep> store . set <identifiersep> session ( null , context ) ; versioning <identifiersep> store . set <identifiersep> transaction ( null , context ) ; while ( it . has <identifiersep> next ( ) ) { <LOG> object [ ] result = ( object [ ] ) it . next ( ) ; } <comment> <ect>
<comment> public void clean <identifiersep> up ( x <identifiersep> wiki <identifiersep> context inputxcontext ) { try { session session = this . store . get <identifiersep> current <identifiersep> session ( ) ; <LOG> if ( session != null ) { } this . store . end <identifiersep> transaction ( false ) ; } } catch ( hibernate <identifiersep> exception e ) { } } public session <identifiersep> factory get <identifiersep> session <identifiersep> factory ( ) { return this . session <identifiersep> factory . get <identifiersep> session <identifiersep> factory ( ) ; <ect>
while ( document . get <identifiersep> parent <identifiersep> reference ( ) != null ) { document <identifiersep> reference parent <identifiersep> reference = document . get <identifiersep> parent <identifiersep> reference ( ) ; if ( parents . contains ( parent <identifiersep> reference ) ) { throw new exception ( <string_literal> ) ; } parents . add ( document . get <identifiersep> parent <identifiersep> reference ( ) ) ; document = xwiki . get <identifiersep> document ( document . get <identifiersep> parent <identifiersep> reference ( ) , context ) ; } <LOG> } catch ( exception e ) { } collections . reverse ( parents ) ; return parents ; } } <ect>
string displayer <identifiersep> hint = ( string ) parameters . get ( <string_literal> ) ; if ( displayer <identifiersep> hint == null ) { displayer <identifiersep> hint = <string_literal> ; } try { document <identifiersep> displayer displayer = this . component <identifiersep> manager . get <identifiersep> instance ( document <identifiersep> displayer . class , displayer <identifiersep> hint ) ; return render <identifiersep> xdom ( displayer . display ( get <identifiersep> document ( document ) , displayer <identifiersep> parameters ) , output <identifiersep> syntax ) ; <LOG> } catch ( exception e ) { return null ; } } <comment> public document <identifiersep> displayer <identifiersep> parameters create <identifiersep> document <identifiersep> displayer <identifiersep> parameters ( ) <ect>
if ( failover ) { return get <identifiersep> x <identifiersep> object ( class <identifiersep> reference ) ; } else { return null ; } } catch ( exception e ) { if ( failover ) { <LOG> return get <identifiersep> x <identifiersep> object ( class <identifiersep> reference ) ; } e . get <identifiersep> message ( ) , e ) ; return null ; } } <comment> <ect>
list < string > list ; try { base <identifiersep> class tags <identifiersep> class = context . get <identifiersep> wiki ( ) . get <identifiersep> tag <identifiersep> class ( context ) ; string possible <identifiersep> values = ( ( static <identifiersep> list <identifiersep> class ) tags <identifiersep> class . get <identifiersep> field ( x <identifiersep> wiki <identifiersep> constant . tag <identifiersep> class <identifiersep> prop <identifiersep> tags ) ) . get <identifiersep> values ( ) ; return list <identifiersep> class . get <identifiersep> list <identifiersep> from <identifiersep> string ( possible <identifiersep> values ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { list = collections . empty <identifiersep> list ( ) ; } return list ; } public void read <identifiersep> translation <identifiersep> meta <identifiersep> from <identifiersep> form ( edit <identifiersep> form eform , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { string content = eform . get <identifiersep> content ( ) ; <ect>
<comment> public void load <identifiersep> attachments <identifiersep> content <identifiersep> safe ( x <identifiersep> wiki <identifiersep> context context ) { for ( x <identifiersep> wiki <identifiersep> attachment attachment : get <identifiersep> attachment <identifiersep> list ( ) ) { try { attachment . load <identifiersep> attachment <identifiersep> content ( context ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } public void load <identifiersep> attachments ( x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { for ( x <identifiersep> wiki <identifiersep> attachment attachment : get <identifiersep> attachment <identifiersep> list ( ) ) { attachment . load <identifiersep> attachment <identifiersep> content ( context ) ; <ect>
<comment> protected void export <identifiersep> xhtml ( string xhtml , output <identifiersep> stream out , export <identifiersep> type type , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception <LOG> { <comment> <ect>
<comment> private string convert <identifiersep> x <identifiersep> html <identifiersep> to <identifiersep> xmlfo ( string xhtml , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception { <LOG> string xmlfo = apply <identifiersep> xslt ( xhtml , get <identifiersep> xhtml2fop <identifiersep> xslt ( context ) ) ; return apply <identifiersep> xslt ( xmlfo , get <identifiersep> fop <identifiersep> cleanup <identifiersep> xslt ( context ) ) ; } <comment> <ect>
output <identifiersep> format . set <identifiersep> encoding ( context . get <identifiersep> wiki ( ) . get <identifiersep> encoding ( ) ) ; } string <identifiersep> writer out = new string <identifiersep> writer ( ) ; xml <identifiersep> writer writer = new xml <identifiersep> writer ( out , output <identifiersep> format ) ; writer . write ( document ) ; string result = out . to <identifiersep> string ( ) ; <LOG> <comment> <ect>
list < string > group <identifiersep> list ; try { group <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
list < string > group <identifiersep> list ; try { group <identifiersep> list = ( list < string > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> local <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , false , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
try { list < x <identifiersep> wiki <identifiersep> document > xdoc <identifiersep> list = ( list < x <identifiersep> wiki <identifiersep> document > ) rights <identifiersep> manager . get <identifiersep> instance ( ) . get <identifiersep> all <identifiersep> matched <identifiersep> global <identifiersep> users <identifiersep> or <identifiersep> groups ( false , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> matching <identifiersep> table ( match <identifiersep> fields ) , true , new request <identifiersep> limit ( nb , start ) , rights <identifiersep> manager <identifiersep> plugin <identifiersep> api . create <identifiersep> order <identifiersep> table ( order ) , this . context ) ; group <identifiersep> list = convert ( xdoc <identifiersep> list ) ; <LOG> } catch ( rights <identifiersep> manager <identifiersep> exception e ) { group <identifiersep> list = collections . empty <identifiersep> list ( ) ; } return group <identifiersep> list ; } <comment> <ect>
public list < event > get <identifiersep> events ( ) { return events ; } @ override public void init ( x <identifiersep> wiki <identifiersep> context context ) <LOG> { } if ( stats <identifiersep> util . is <identifiersep> stats <identifiersep> enabled ( context ) ) { <comment> <ect>
x <identifiersep> wiki <identifiersep> request request = context . get <identifiersep> request ( ) ; cookie cookie = ( cookie ) context . get ( contprop <identifiersep> stats <identifiersep> cookie ) ; boolean newcookie = ( ( boolean ) context . get ( contprop <identifiersep> stats <identifiersep> newcookie ) ) . boolean <identifiersep> value ( ) ; if ( ! newcookie ) { try { visit <identifiersep> stats = find <identifiersep> visit <identifiersep> by <identifiersep> cookie ( cookie . get <identifiersep> value ( ) , context ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } else { try { string ip = request . get <identifiersep> remote <identifiersep> addr ( ) ; string ua = request . get <identifiersep> header ( reqprop <identifiersep> useragent ) ; visit <identifiersep> stats = find <identifiersep> visit <identifiersep> by <identifiersep> ipua ( compute <identifiersep> unique <identifiersep> id ( ip , ua ) , context ) ; <ect>
<comment> <LOG> <comment> <ect>
content , syntax , user <identifiersep> rights , context ) ; <comment> <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { return - <number_literal> ; } } return result ; } catch ( x <identifiersep> wiki <identifiersep> exception e ) { logger . error ( e . get <identifiersep> message ( ) , e ) ; throw e ; <ect>
try { @ suppress <identifiersep> warnings ( <string_literal> ) set < string > included <identifiersep> docs = ( set < string > ) context . get ( <string_literal> ) ; if ( included <identifiersep> docs == null ) { included <identifiersep> docs = new hash <identifiersep> set < string > ( ) ; context . put ( <string_literal> , included <identifiersep> docs ) ; } <LOG> if ( included <identifiersep> docs . contains ( prefixed <identifiersep> topic ) || current <identifiersep> doc <identifiersep> name . equals ( prefixed <identifiersep> topic ) ) { return <string_literal> ; } included <identifiersep> docs . add ( prefixed <identifiersep> topic ) ; } catch ( exception e ) { } <comment> <ect>
sql += <string_literal> ; parameters . add ( space ) ; } if ( clean ) { try { context . set <identifiersep> wiki <identifiersep> id ( target <identifiersep> wiki ) ; <LOG> list < string > list = get <identifiersep> store ( ) . search ( sql , 0 , 0 , parameters , context ) ; } for ( string docname : list ) { x <identifiersep> wiki <identifiersep> document doc = get <identifiersep> document ( docname , context ) ; delete <identifiersep> document ( doc , context ) ; } } finally { context . set <identifiersep> wiki <identifiersep> id ( db ) ; <ect>
<comment> public string get <identifiersep> skin <identifiersep> file <identifiersep> path ( string filename , string skin ) throws io <identifiersep> exception { string path = uri . create ( delimiter + skins <identifiersep> directory + delimiter + skin + delimiter + filename ) . normalize ( ) . to <identifiersep> string ( ) ; <comment> <LOG> if ( ! path . starts <identifiersep> with ( delimiter + skins <identifiersep> directory ) ) { throw new io <identifiersep> exception ( <string_literal> + filename + <string_literal> + skin + <string_literal> ) ; } return path ; } <comment> <ect>
<comment> private boolean render <identifiersep> skin ( string filename , x <identifiersep> wiki <identifiersep> document doc , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception , io <identifiersep> exception <LOG> { try { if ( doc . is <identifiersep> new ( ) ) { logger . debug ( <string_literal> , doc . get <identifiersep> document <identifiersep> reference ( ) . get <identifiersep> name ( ) ) ; } else { return render <identifiersep> file <identifiersep> from <identifiersep> object <identifiersep> field ( filename , doc , context ) <ect>
<comment> private boolean render <identifiersep> file <identifiersep> from <identifiersep> filesystem ( string path , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception <LOG> { x <identifiersep> wiki <identifiersep> response response = context . get <identifiersep> response ( ) ; try { byte [ ] data ; data = context . get <identifiersep> wiki ( ) . get <identifiersep> resource <identifiersep> content <identifiersep> as <identifiersep> bytes ( path ) ; if ( data != null && data . length > 0 ) { <ect>
{ boolean ajax = ( ( boolean ) context . get ( <string_literal> ) ) . boolean <identifiersep> value ( ) ; if ( ajax ) { try { context . get <identifiersep> response ( ) . get <identifiersep> output <identifiersep> stream ( ) . println ( <string_literal> + localize <identifiersep> plain <identifiersep> or <identifiersep> key ( ( string ) context . get ( <string_literal> ) ) ) ; <LOG> } catch ( io <identifiersep> exception ex ) { } return null ; } get <identifiersep> current <identifiersep> script <identifiersep> context ( ) . set <identifiersep> attribute ( <string_literal> , <string_literal> , script <identifiersep> context . engine <identifiersep> scope ) ; return <string_literal> ; } } <ect>
new illegal <identifiersep> argument <identifiersep> exception ( <string_literal> + url ) ; logger . error ( iae . get <identifiersep> message ( ) , iae ) ; throw iae ; } buffered <identifiersep> response buffered <identifiersep> response = new buffered <identifiersep> response ( servlet <identifiersep> response ) ; request <identifiersep> dispatcher . include ( servlet <identifiersep> request , buffered <identifiersep> response ) ; <LOG> byte [ ] buffer = buffered <identifiersep> response . get <identifiersep> buffer <identifiersep> as <identifiersep> byte <identifiersep> array ( ) ; } string buffer <identifiersep> string = new string ( buffer , servlet <identifiersep> response . get <identifiersep> character <identifiersep> encoding ( ) ) ; return buffer <identifiersep> string ; } } <ect>
<comment> <LOG> } catch ( io <identifiersep> exception e ) { <comment> <ect>
<comment> private void commit ( ) { solr <identifiersep> instance solr <identifiersep> instance = this . solr <identifiersep> instance <identifiersep> provider . get ( ) ; try { solr <identifiersep> instance . commit ( ) ; <LOG> } catch ( exception e ) { try { solr <identifiersep> instance . rollback ( ) ; } catch ( exception ex ) { <comment> <ect>
<comment> private solr <identifiersep> metadata <identifiersep> extractor get <identifiersep> metadata <identifiersep> extractor ( entity <identifiersep> type entity <identifiersep> type ) { solr <identifiersep> metadata <identifiersep> extractor result = null ; try { result = this . component <identifiersep> manager . get <identifiersep> instance ( solr <identifiersep> metadata <identifiersep> extractor . class , entity <identifiersep> type . name ( ) . to <identifiersep> lower <identifiersep> case ( ) ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } return result ; } @ override public void index ( entity <identifiersep> reference reference , boolean recurse ) { add <identifiersep> to <identifiersep> queue ( reference , recurse , index <identifiersep> operation . index ) ; <ect>
<comment> <LOG> <comment> <ect>
try { x <identifiersep> wiki <identifiersep> document document = this . context . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> name , this . context ) ; if ( this . context . get <identifiersep> wiki ( ) . check <identifiersep> access ( tag <identifiersep> access <identifiersep> right , document , this . context ) ) { result = this . get <identifiersep> protected <identifiersep> plugin ( ) . remove <identifiersep> tag <identifiersep> from <identifiersep> document ( tag , document <identifiersep> name , this . context ) ; } else { result = tag <identifiersep> operation <identifiersep> result . not <identifiersep> allowed ; } <LOG> } catch ( exception ex ) { result = tag <identifiersep> operation <identifiersep> result . failed ; } return result ; } <comment> <ect>
tag <identifiersep> operation <identifiersep> result result ; try { if ( has <identifiersep> admin <identifiersep> rights ( ) ) { result = this . get <identifiersep> protected <identifiersep> plugin ( ) . delete <identifiersep> tag ( tag , this . context ) ; } else { result = tag <identifiersep> operation <identifiersep> result . not <identifiersep> allowed ; } <LOG> } catch ( exception ex ) { result = tag <identifiersep> operation <identifiersep> result . failed ; } return result ; } } <ect>
<comment> private map < string , j <identifiersep> channel > channels = new concurrent <identifiersep> hash <identifiersep> map < string , j <identifiersep> channel > ( ) ; @ override public void send ( remote <identifiersep> event <identifiersep> data remote <identifiersep> event ) <LOG> { <comment> <ect>
try { address = internet <identifiersep> address . parse ( email ) [ 0 ] ; } catch ( address <identifiersep> exception e ) { <comment> <LOG> } else { } return address ; } } <ect>
<comment> <LOG> this . prepare <identifiersep> mail <identifiersep> thread . join ( ) ; } } @ override public void dispose ( ) throws component <identifiersep> lifecycle <identifiersep> exception { try { stop <identifiersep> mail <identifiersep> threads ( ) ; <ect>
{ try { <comment> <LOG> <comment> <ect>
if ( response . timed <identifiersep> out ) { string message = string . format ( <string_literal> , timeout <identifiersep> seconds , response . response <identifiersep> code , new string ( response . response <identifiersep> body ) ) ; logger . info ( message ) ; stop ( ) ; throw new runtime <identifiersep> exception ( message ) ; <LOG> } else { } } public response is <identifiersep> x <identifiersep> wiki <identifiersep> started ( string url , int timeout ) throws exception { http <identifiersep> client client = new http <identifiersep> client ( ) ; boolean connected = false ; long start <identifiersep> time = system . current <identifiersep> time <identifiersep> millis ( ) ; <ect>
if ( response . timed <identifiersep> out ) { logger . info ( <string_literal> , url , timeout ) ; } return response ; } public void stop ( ) throws exception { if ( ! should <identifiersep> start <identifiersep> xwiki ) { <LOG> return ; } <comment> <ect>
if ( ! this . was <identifiersep> started ) { stop <identifiersep> internal ( ) ; <comment> <LOG> } else { } } private void stop <identifiersep> internal ( ) throws exception { string stop <identifiersep> command = get <identifiersep> default <identifiersep> stop <identifiersep> command ( get <identifiersep> port ( ) , get <identifiersep> stop <identifiersep> port ( ) ) ; logger . debug ( <string_literal> , stop <identifiersep> command ) ; default <identifiersep> execute <identifiersep> result <identifiersep> handler stop <identifiersep> process <identifiersep> handler = execute <identifiersep> command ( stop <identifiersep> command ) ; <ect>
public void remove ( user <identifiersep> security <identifiersep> reference user , security <identifiersep> reference entity ) { write <identifiersep> lock . lock ( ) ; try { security <identifiersep> cache <identifiersep> entry entry = get <identifiersep> entry ( user , entity ) ; <LOG> if ( entry != null ) { } this . cache . remove ( entry . get <identifiersep> key ( ) ) ; } } finally { write <identifiersep> lock . unlock ( ) ; } } @ override public void remove ( security <identifiersep> reference entity ) <ect>
rules <identifiersep> invalidator . suspend ( ) ; try { retries ++ ; return load <identifiersep> required <identifiersep> entries ( user , entity ) ; } catch ( parent <identifiersep> entry <identifiersep> evicted <identifiersep> exception e ) { last <identifiersep> exception = e ; <LOG> if ( retries < max <identifiersep> retries ) { continue ; } } catch ( conflicting <identifiersep> insertion <identifiersep> exception e ) { last <identifiersep> exception = e ; if ( retries < max <identifiersep> retries ) { this . logger . debug ( <string_literal> , retries ) ; <ect>
{ x <identifiersep> wiki <identifiersep> document document = ( x <identifiersep> wiki <identifiersep> document ) source ; base <identifiersep> object extension <identifiersep> object = document . get <identifiersep> x <identifiersep> object ( x <identifiersep> wiki <identifiersep> repository <identifiersep> model . extension <identifiersep> classreference ) ; if ( extension <identifiersep> object != null ) { try { this . repository <identifiersep> manager <identifiersep> provider . get ( ) . validate <identifiersep> extension ( document , false ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } } <ect>
descriptor . set <identifiersep> description ( main <identifiersep> server <identifiersep> class <identifiersep> object . get <identifiersep> string <identifiersep> value ( x <identifiersep> wiki <identifiersep> server <identifiersep> class <identifiersep> document <identifiersep> initializer . field <identifiersep> description ) ) ; <comment> <LOG> } catch ( wiki <identifiersep> property <identifiersep> group <identifiersep> exception e ) { } } return descriptor ; } private list < base <identifiersep> object > normalize <identifiersep> server <identifiersep> class <identifiersep> objects ( list < base <identifiersep> object > server <identifiersep> class <identifiersep> objects ) { <comment> <ect>
servlet <identifiersep> request servlet <identifiersep> request = ( servlet <identifiersep> request ) request ; xobject . set <identifiersep> string <identifiersep> value ( x <identifiersep> wiki <identifiersep> server <identifiersep> class <identifiersep> document <identifiersep> initializer . field <identifiersep> server , servlet <identifiersep> request . get <identifiersep> http <identifiersep> servlet <identifiersep> request ( ) . get <identifiersep> server <identifiersep> name ( ) ) ; } else { xobject . set <identifiersep> string <identifiersep> value ( x <identifiersep> wiki <identifiersep> server <identifiersep> class <identifiersep> document <identifiersep> initializer . field <identifiersep> server , <string_literal> ) ; } needs <identifiersep> update = true ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } return needs <identifiersep> update ; } } <ect>
for ( string document <identifiersep> full <identifiersep> name : document <identifiersep> fullnames ) { this . progress . start <identifiersep> step ( this ) ; document <identifiersep> reference orig <identifiersep> doc <identifiersep> reference = document <identifiersep> reference <identifiersep> resolver . resolve ( document <identifiersep> full <identifiersep> name , from <identifiersep> wiki <identifiersep> reference ) ; document <identifiersep> reference new <identifiersep> doc <identifiersep> reference = orig <identifiersep> doc <identifiersep> reference . set <identifiersep> wiki <identifiersep> reference ( new wiki <identifiersep> reference ( to <identifiersep> wiki <identifiersep> id ) ) ; logger . info ( <string_literal> , orig <identifiersep> doc <identifiersep> reference , new <identifiersep> doc <identifiersep> reference ) ; <LOG> xwiki . copy <identifiersep> document ( orig <identifiersep> doc <identifiersep> reference , new <identifiersep> doc <identifiersep> reference , null , ! with <identifiersep> history , true , context ) ; this . progress . end <identifiersep> step ( this ) ; } } finally { this . progress . pop <identifiersep> level <identifiersep> progress ( this ) ; this . progress . end <identifiersep> step ( this ) ; } } catch ( query <identifiersep> exception e ) { <ect>
<comment> public int get <identifiersep> width ( string page <identifiersep> name , string attachment <identifiersep> name ) { try { return get <identifiersep> protected <identifiersep> plugin ( ) . get <identifiersep> width ( get <identifiersep> attachment ( page <identifiersep> name , attachment <identifiersep> name ) , get <identifiersep> x <identifiersep> wiki <identifiersep> context ( ) ) ; <LOG> } catch ( exception e ) { return - 1 ; } } <comment> <ect>
<comment> <LOG> } catch ( exception e ) { return attachment ; } } <comment> <ect>
<string_literal> + <string_literal> , query . xwql ) ; q . bind <identifiersep> value ( <string_literal> , this . serializer . serialize ( author ) ) ; q . set <identifiersep> limit ( limit > 0 ? limit : <number_literal> ) . set <identifiersep> offset ( offset >= 0 ? offset : 0 ) ; result = this . stream . search <identifiersep> events ( q ) ; <LOG> } catch ( query <identifiersep> exception ex ) { } return result ; } @ override public list < event > get <identifiersep> recent <identifiersep> direct <identifiersep> messages ( ) { return get <identifiersep> recent <identifiersep> direct <identifiersep> messages ( <number_literal> , 0 ) ; <ect>
break ; default : break ; } if ( register ) { try { this . store . add <identifiersep> watched <identifiersep> element ( user , current <identifiersep> doc . get <identifiersep> prefixed <identifiersep> full <identifiersep> name ( ) , watched <identifiersep> element <identifiersep> type . document ) ; <LOG> } catch ( x <identifiersep> wiki <identifiersep> exception e ) { } } } } <ect>
fix <identifiersep> class <identifiersep> property ( watch <identifiersep> list <identifiersep> class , <string_literal> , <string_literal> ) ; fix <identifiersep> class <identifiersep> property ( watch <identifiersep> list <identifiersep> class , <string_literal> , <string_literal> ) ; fix <identifiersep> class <identifiersep> property ( watch <identifiersep> list <identifiersep> class , <string_literal> , <string_literal> ) ; <comment> <LOG> session . save ( watch <identifiersep> list <identifiersep> class <identifiersep> document ) ; <comment> <ect>
<comment> <LOG> } catch ( exception e ) { } return needs <identifiersep> update ; } <comment> protected abstract string get <identifiersep> cron ( ) ; <ect>
if ( ! directory . is <identifiersep> directory ( ) ) { this . logger . warn ( <string_literal> , directory ) ; continue ; } store <identifiersep> deleted <identifiersep> attachment ( directory , id , session ) ; } } } } private void store <identifiersep> deleted <identifiersep> attachment ( file directory , long id , session session ) throws parser <identifiersep> configuration <identifiersep> exception , sax <identifiersep> exception , io <identifiersep> exception <LOG> { <comment> <ect>
return store != null ? store : this . hibernate <identifiersep> attachment <identifiersep> versioning <identifiersep> store ; } private attachment <identifiersep> versioning <identifiersep> store get <identifiersep> attachment <identifiersep> versioning <identifiersep> store ( string store <identifiersep> type ) { if ( store <identifiersep> type != null && ! store <identifiersep> type . equals ( x <identifiersep> wiki <identifiersep> hibernate <identifiersep> base <identifiersep> store . hint ) ) { try { return this . component <identifiersep> manager . get <identifiersep> instance ( attachment <identifiersep> versioning <identifiersep> store . class , store <identifiersep> type ) ; <LOG> } catch ( component <identifiersep> lookup <identifiersep> exception e ) { } } return null ; } } <ect>
@ override public void job <identifiersep> scheduled ( trigger trigger ) { logger . info ( <string_literal> , trigger . get <identifiersep> key ( ) ) ; } @ override public void job <identifiersep> unscheduled ( trigger <identifiersep> key key ) <LOG> { } @ override public void trigger <identifiersep> finalized ( trigger trigger ) { } @ override public void trigger <identifiersep> paused ( trigger <identifiersep> key trigger <identifiersep> key ) <ect>
$super ( ) ; } } ) ; } <comment> <LOG> if ( window . use <identifiersep> xw <identifiersep> kns ) { if ( typeof  <identifiersep> xwk == <string_literal> ) {  <identifiersep> xwk = new object ( ) ; } } else {  <identifiersep> xwk = window ; } <comment> <ect>
$super . apply (  <identifiersep> xwk , args ) ; } } ) ; <comment> window . display <identifiersep> doc <identifiersep> extra = x <identifiersep> wiki . display <identifiersep> doc <identifiersep> extra . wrap ( <LOG> function ( ) { var args = $a ( arguments ) , proceed = args . shift ( ) ; return proceed . apply ( window , args ) ; } ) ; <comment> <ect>
<comment> <LOG> window . hide <identifiersep> form = function ( form ) { form . get <identifiersep> elements <identifiersep> by <identifiersep> tag <identifiersep> name ( <string_literal> ) . item ( 0 ) . class <identifiersep> name = <string_literal> ; } <comment> <ect>
this . id = this . generate <identifiersep> id ( id ) ; } this .  <identifiersep> nodes = [ ] ; <comment> <LOG> this . logger = new yahoo . widget . log <identifiersep> writer ( this . to <identifiersep> string ( ) ) ; } , <comment> draw : function ( ) { <ect>
<comment> <LOG> insert <identifiersep> before : function ( node ) { var p = node . parent ; if ( p ) { if ( this . tree ) { this . tree . pop <identifiersep> node ( this ) ; } var ref <identifiersep> index = node . is <identifiersep> child <identifiersep> of ( p ) ; <ect>
if ( this . has <identifiersep> children ( ) ) { this . get <identifiersep> children <identifiersep> el ( ) . style . display = <string_literal> ; } } } , <comment> <LOG> hide <identifiersep> children : function ( ) { if ( ! this . tree . animate <identifiersep> collapse ( this . get <identifiersep> children <identifiersep> el ( ) ) ) { this . get <identifiersep> children <identifiersep> el ( ) . style . display = <string_literal> ; } } , <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> remove <identifiersep> listener : function ( el , s <identifiersep> type , fn , index ) { <LOG> if ( ! fn || ! fn . call ) { return false ; } var i , len ; <comment> <ect>
if ( <string_literal> == typeof index ) { index = this .  <identifiersep> get <identifiersep> cache <identifiersep> index ( el , s <identifiersep> type , fn ) ; } if ( index >= 0 ) { cache <identifiersep> item = listeners [ index ] ; } if ( ! el || ! cache <identifiersep> item ) { <comment> <LOG> return false ; } if ( this . use <identifiersep> legacy <identifiersep> event ( el , s <identifiersep> type ) ) { var legacy <identifiersep> index = this . get <identifiersep> legacy <identifiersep> index ( el , s <identifiersep> type ) ; var llist = legacy <identifiersep> handlers [ legacy <identifiersep> index ] ; if ( llist ) { for ( i = 0 , len = llist . length ; i < len ; ++ i ) { <ect>
<comment>  <identifiersep> try <identifiersep> preload <identifiersep> attach : function ( ) { if ( this . locked ) { return false ; } <LOG> this . locked = true ; <comment> <ect>
<comment> @ deprecated public void x <identifiersep> wiki . send <identifiersep> message ( string sender , string [ ] recipients , string raw <identifiersep> message , x <identifiersep> wiki <identifiersep> context context ) throws x <identifiersep> wiki <identifiersep> exception <LOG> { <comment> <ect>
mail <identifiersep> sender <identifiersep> send <identifiersep> raw = mail <identifiersep> sender <identifiersep> class . get <identifiersep> method ( <string_literal> , new class [ ] { string . class , string . class , string . class } ) ; } catch ( exception e ) { logger . error ( <string_literal> , e ) ; send <identifiersep> message <identifiersep> old ( sender , recipients , raw <identifiersep> message , context ) ; <LOG> return ; } } string message <identifiersep> recipients = string <identifiersep> utils . join ( recipients , ' , ' ) ; try { mail <identifiersep> sender <identifiersep> send <identifiersep> raw . invoke ( mail <identifiersep> sender , sender , message <identifiersep> recipients , raw <identifiersep> message ) ; } catch ( invocation <identifiersep> target <identifiersep> exception ite ) { throwable cause = ite . get <identifiersep> cause ( ) ; <ect>
string encoding = context . get <identifiersep> wiki ( ) . get <identifiersep> encoding ( ) ; byte <identifiersep> array <identifiersep> output <identifiersep> stream os = new byte <identifiersep> array <identifiersep> output <identifiersep> stream ( ) ; try { xml <identifiersep> writer wr = new xml <identifiersep> writer ( os , new output <identifiersep> format ( <string_literal> , true , encoding ) ) ; wr . write ( doc ) ; return os . to <identifiersep> string ( encoding ) ; <LOG> } catch ( io <identifiersep> exception e ) { return <string_literal> ; } } <comment> @ deprecated <ect>
pages . put ( reference , false ) ; continue ; } <comment> <LOG> } catch ( exception e ) { <comment> <ect>
pages . put ( reference , false ) ; continue ; } } <comment> <LOG> } catch ( interrupted <identifiersep> exception e ) { <comment> <ect>
throw new extension <identifiersep> exception ( <string_literal> , e ) ; } map < xar <identifiersep> entry , local <identifiersep> extension > pages = this . next <identifiersep> xar <identifiersep> entries . get ( wiki ) ; if ( pages == null ) { pages = new hash <identifiersep> map < > ( ) ; this . next <identifiersep> xar <identifiersep> entries . put ( wiki , pages ) ; } pages . put ( entry , next <identifiersep> extension ) ; } <LOG> } catch ( exception e ) { e ) ; } } } } } public xar <identifiersep> extension <identifiersep> plan <identifiersep> entry get <identifiersep> previous <identifiersep> xar <identifiersep> extension <identifiersep> plan <identifiersep> entry ( document <identifiersep> reference document <identifiersep> reference ) { string wiki = document <identifiersep> reference . get <identifiersep> wiki <identifiersep> reference ( ) . get <identifiersep> name ( ) ; local <identifiersep> document <identifiersep> reference local <identifiersep> document <identifiersep> reference = new local <identifiersep> document <identifiersep> reference ( document <identifiersep> reference ) ; <ect>
this . logger . warn ( log <identifiersep> descriptor <identifiersep> failread , <string_literal> , entry . get <identifiersep> name ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) ) ; } } } else { try { this . document <identifiersep> reader . read ( zis , filter , proxy <identifiersep> filter ) ; } catch ( skip <identifiersep> entity <identifiersep> exception skip ) { <LOG> if ( this . properties . is <identifiersep> verbose ( ) ) { } } catch ( exception e ) { if ( this . properties . is <identifiersep> verbose ( ) ) { this . logger . warn ( log <identifiersep> document <identifiersep> failread , <string_literal> , entry . get <identifiersep> name ( ) , exception <identifiersep> utils . get <identifiersep> root <identifiersep> cause <identifiersep> message ( e ) , e ) ; } } } } } } <ect>
x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; try { x <identifiersep> wiki <identifiersep> document new <identifiersep> document = xcontext . get <identifiersep> wiki ( ) . get <identifiersep> document ( document <identifiersep> reference , xcontext ) ; xcontext . get <identifiersep> wiki ( ) . save <identifiersep> document ( new <identifiersep> document , xcontext ) ; this . logger . info ( <string_literal> , document <identifiersep> reference ) ; return true ; <LOG> } catch ( exception e ) { return false ; } } @ override public boolean copy ( document <identifiersep> reference source , document <identifiersep> reference destination ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; <ect>
this . logger . info ( <string_literal> , source , destination ) ; } else { this . logger . warn ( <string_literal> + <string_literal> , source , destination ) ; } return result ; <LOG> } catch ( exception e ) { return false ; } } @ override public boolean delete ( document <identifiersep> reference reference ) { x <identifiersep> wiki <identifiersep> context xcontext = this . xcontext <identifiersep> provider . get ( ) ; <ect>
maybe <identifiersep> create ( new <identifiersep> space <identifiersep> web <identifiersep> home <identifiersep> reference , null ) ; } } private void maybe <identifiersep> create ( document <identifiersep> reference new <identifiersep> document <identifiersep> reference , document <identifiersep> reference template <identifiersep> document <identifiersep> reference ) { if ( request . get <identifiersep> skipped <identifiersep> entities ( ) . contains ( new <identifiersep> document <identifiersep> reference ) ) { this . logger . debug ( <string_literal> , new <identifiersep> document <identifiersep> reference ) ; } else if ( this . model <identifiersep> bridge . exists ( new <identifiersep> document <identifiersep> reference ) ) { <LOG> <comment> <ect>
this . logger . warn ( <string_literal> , new <identifiersep> document <identifiersep> reference ) ; } else if ( ! has <identifiersep> access ( right . edit , new <identifiersep> document <identifiersep> reference ) ) { this . logger . error ( <string_literal> , new <identifiersep> document <identifiersep> reference ) ; } else if ( template <identifiersep> document <identifiersep> reference == null ) { <comment> <LOG> } else if ( ! has <identifiersep> access ( right . view , template <identifiersep> document <identifiersep> reference ) ) { } else if ( ! this . model <identifiersep> bridge . exists ( template <identifiersep> document <identifiersep> reference ) ) { <comment> <ect>
{ private static final logger logger = logger <identifiersep> factory . get <identifiersep> logger ( all <identifiersep> tests . class ) ; @ page <identifiersep> object <identifiersep> suite . post <identifiersep> start public void post <identifiersep> start ( persistent <identifiersep> test <identifiersep> context context ) throws exception { context . get <identifiersep> util ( ) . set <identifiersep> default <identifiersep> credentials ( test <identifiersep> utils . admin <identifiersep> credentials ) ; <LOG> <comment> <ect>
